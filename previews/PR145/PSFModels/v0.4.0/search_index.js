var documenterSearchIndex = {"docs":
[{"location":"api/#API/Reference","page":"API/Reference","title":"API/Reference","text":"","category":"section"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"using PSFModels: Gaussian, Moffat, AiryDisk\nusing Plots","category":"page"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"","category":"page"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"PSFModels.PSFModel","category":"page"},{"location":"api/#PSFModels.PSFModel","page":"API/Reference","title":"PSFModels.PSFModel","text":"PSFModels.PSFModel{T} <: AbstractMatrix{T}\n\nAbstract type for PSF models.\n\nIn general, all PSFModels have a set of pre-determined axes (the size is set upon creation) but they are lazy. That is, no memory is allocated and the values are calculated on the fly.\n\nInterface\n\nThe interface to define a model is as follows (for an example model Model)\n\nmethod description\nModel() constructor(s)\nBase.size(m::Model) size, necessary for AbstractArray interface\nBase.axes(m::Model) axes, necessary for AbstractArray interface\n(m::Model)(point::AbstractVector) evaluate the model at the point in 2d space (x, y)\n\nbrowsing through the implementation of PSFModels.Gaussian should give a good idea of how to create a model\n\n\n\n\n\n","category":"type"},{"location":"api/#Gaussian","page":"API/Reference","title":"Gaussian","text":"","category":"section"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"PSFModels.Gaussian\nPSFModels.Normal","category":"page"},{"location":"api/#PSFModels.Gaussian","page":"API/Reference","title":"PSFModels.Gaussian","text":"PSFModels.Gaussian([T=Float64]; fwhm, x=0, y=0, amp=1, maxsize=3, extent=maxsize .* fwhm)\nPSFModels.Gaussian([T=Float64]; fwhm, pos, amp=1, maxsize=3, extent=maxsize .* fwhm)\nPSFModels.Gaussian([T=Float64]; fwhm, r, theta, amp=1, maxsize=3, extent=maxsize .* fwhm)\n\nAn unnormalized bivariate Gaussian distribution. The position can be specified in (x, y) coordinates as a Tuple, AbstractVector, or as separate arguments. By default the model is placed at the origin. The position can also be given as a polar coordinate using r/ρ and theta/θ, optionally centered around origin.\n\nThe fwhm can be a scalar (isotropic) or a vector/tuple (diagonal). For efficient calculations, we recommend using StaticArrays. Here, maxsize is a multiple of the fwhm, and can be given as a scalar or as a tuple for each axis. The extent defines the bounding box for the model and is used for the default rendering size.\n\nFunctional form\n\nf(x | x̂, FWHM) = exp[-4ln(2) * ||x - x̂|| / FWHM^2]\n\nwhere x̂ and x are position vectors (indices) ||⋅|| represents the square-distance, and FWHM is the full width at half-maximum. If FWHM is a scalar, the Gaussian distribution will be isotropic. If FWHM is a vector or tuple, the weighting is applied along each axis (diagonal).\n\n\n\n\n\n","category":"type"},{"location":"api/#PSFModels.Normal","page":"API/Reference","title":"PSFModels.Normal","text":"PSFModels.Normal\n\nAn alias for PSFModels.Gaussian\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"model = Gaussian(fwhm=10)\nplot(model; title=\"Gaussian(fwhm=10)\")","category":"page"},{"location":"api/#Airy-Disk","page":"API/Reference","title":"Airy Disk","text":"","category":"section"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"PSFModels.AiryDisk","category":"page"},{"location":"api/#PSFModels.AiryDisk","page":"API/Reference","title":"PSFModels.AiryDisk","text":"PSFModels.AiryDisk([T=Float64]; fwhm, x=0, y=0, amp=1, maxsize=3, extent=maxsize .* fwhm)\nPSFModels.AiryDisk([T=Float64]; fwhm, pos, amp=1, maxsize=3, extent=maxsize .* fwhm)\nPSFModels.AiryDisk([T=Float64]; fwhm, r, theta, amp=1, maxsize=3, extent=maxsize .* fwhm)\n\nAn unnormalized Airy disk. The position can be specified in (x, y) coordinates as a Tuple, AbstractVector, or as separate arguments. By default the model is placed at the origin. The position can also be given as a polar coordinate using r/ρ and theta/θ, optionally centered around origin.\n\nThe fwhm can be a scalar (isotropic) or a vector/tuple (diagonal). For efficient calculations, we recommend using StaticArrays. Here, maxsize is a multiple of the fwhm, and can be given as a scalar or as a tuple for each axis. The extent defines the bounding box for the model and is used for the default rendering size.\n\nFunctional form\n\nThe Airy disk is a distribution over the radius r (the square-Euclidean distance)\n\nf(x | x̂, FWHM) = [ 2J₁(q) / q ]^2\n\nwhere J₁ is the first-order Bessel function of the first kind and\n\nq ≈ π * r / (0.973 * FWHM)\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"model = AiryDisk(fwhm=10)\nplot(model; title=\"AiryDisk(fwhm=10)\")","category":"page"},{"location":"api/#Moffat","page":"API/Reference","title":"Moffat","text":"","category":"section"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"PSFModels.Moffat","category":"page"},{"location":"api/#PSFModels.Moffat","page":"API/Reference","title":"PSFModels.Moffat","text":"PSFModels.Moffat([T=Float64]; fwhm, x=0, y=0, amp=1, alpha=1, maxsize=3, extent=maxsize .* fwhm)\nPSFModels.Moffat([T=Float64]; fwhm, pos, amp=1, alpha=1, maxsize=3, extent=maxsize .* fwhm)\nPSFModels.Moffat([T=Float64]; fwhm, r, theta, amp=1, alpha=1, maxsize=3, extent=maxsize .* fwhm)\n\nTwo dimensional Moffat model. The position can be specified in (x, y) coordinates as a Tuple, AbstractVector, or as separate arguments. By default the model is placed at the origin. The position can also be given as a polar coordinate using r/ρ and theta/θ, optionally centered around origin.\n\nThe fwhm can be a scalar (isotropic) or a vector/tuple (diagonal). For efficient calculations, we recommend using StaticArrays. Here, maxsize is a multiple of the fwhm, and can be given as a scalar or as a tuple for each axis. The extent defines the bounding box for the model and is used for the default rendering size.\n\nFunctional form\n\nf(x | x̂, FWHM, α) = A / (1 + ||x - x̂|| / (FWHM / 2)^2)^α\n\nwhere x̂ and x are position vectors (indices) ||⋅|| represents the square-distance, and FWHM is the full width at half-maximum. If FWHM is a vector or tuple, the weighting is applied along each axis.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"model = Moffat(fwhm=10)\nplot(model; title=\"Moffat(fwhm=10)\")","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Fitting-a-PSF","page":"Examples","title":"Fitting a PSF","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here is a brief example which shows how to construct a loss function for fitting a PSFModel to some data.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using PSFModels: Gaussian\nusing HCIDatasets: BetaPictoris\nusing Plots\n\n# convenience function for plotting\nfunction imshow(data; kwargs...)\n    xlim = extrema(axes(data, 2))\n    ylim = extrema(axes(data, 1))\n    heatmap(data; xlim=xlim, ylim=ylim, aspect_ratio=1, kwargs...)\nend\n\n# get a PSF from HCIDatasets.jl;\n# you may be prompted to download the file\npsf = BetaPictoris[:psf]\n\nimshow(psf)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using LossFunctions\n\n# generative model\nfunction model(X::AbstractVector{T}) where T\n    x    =       X[1]   # position\n    y    =       X[2]\n    fwhm = @view X[3:4] # fwhm_x, fwhm_y\n    amp  =       X[5]   # amplitude\n    return Gaussian(T; x, y, fwhm, amp)\nend\n\n# objective function\nfunction loss(X::AbstractVector{T}, target) where T\n    # cheap way to enforce positivity\n    all(>(0), X) || return T(Inf)\n    # get generative model\n    m = model(X)\n    # l2-distance loss (χ² loss) (LossFunctions.jl) without cutting out\n    stamp = @view m[axes(target)...]\n    return value(L2DistLoss(), target, stamp, AggMode.Sum())\nend\n\n# params are [x, y, fwhm_x, fwhm_y, amp]\ntest_params = eltype(psf)[20, 20, 5, 5, 1]\nloss(test_params, psf)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The objective function can then be used with an optimization library like Optim.jl to find best-fitting parameters","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Optim\n\n# Fit our data using test_params as a starting point\n# uses Nelder-Mead optimization\nres = optimize(P -> loss(P, psf), test_params)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# utilize automatic differentiation (AD) to enable\n# advanced algorithms, like LBFGS\nres_ad = optimize(P -> loss(P, psf), test_params, LBFGS(); autodiff=:forward)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"we can see which result has the better loss, and then use the generative model to create a model that we can use elsewhere","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"best_res = minimum(res) < minimum(res_ad) ? res : res_ad\nbest_fit_params = Optim.minimizer(best_res)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"synth_psf = model(best_fit_params)\n\nplot(\n    imshow(psf, title=\"Data\"),\n    plot(synth_psf, axes(psf); title=\"Model\"),\n    cbar=false,\n    ticks=false,\n    layout=2,\n    size=(600, 300)\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PSFModels","category":"page"},{"location":"#PSFModels.jl","page":"Home","title":"PSFModels.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: GitHub) (Image: Build Status) (Image: PkgEval) (Image: Coverage) (Image: License)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PSFModels can be added from the Julia package manager","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia>]\n\n(@v1.6) pkg> add PSFModels","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To import the library","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using PSFModels","category":"page"},{"location":"","page":"Home","title":"Home","text":"None of the models are exported to avoid namespace clashes, but it can be verbose to continuously rewrite PSFModels. You can either import names directly","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using PSFModels: Gaussian\n\njulia> model = Gaussian(fwhm=8)","category":"page"},{"location":"","page":"Home","title":"Home","text":"or you can create an alias for PSFModels","category":"page"},{"location":"","page":"Home","title":"Home","text":"# julia version 1.5 or below\nusing PSFModels\nconst M = PSFModels\n# julia version 1.6 or above\nimport PSFModels as M\n\nmodel = M.Gaussian(fwhm=10)","category":"page"},{"location":"","page":"Home","title":"Home","text":"PSFModels","category":"page"},{"location":"#PSFModels.PSFModels","page":"Home","title":"PSFModels.PSFModels","text":"PSFModels\n\nStatistical models for constructing point-spread functions (PSFs). These models act like matrices but without allocating any memory, which makes them efficient to fit and apply.\n\nModels\n\nThe following models are currently implemented\n\nPSFModels.Gaussian/PSFModels.Normal\nPSFModels.AiryDisk\nPSFModels.Moffat\n\nParameters\n\nIn general, the PSFs have a position, a full-width at half-maximum (FWHM) measure, and an amplitude. The position follows a 1-based pixel coordinate system, where (1, 1) represents the center of the bottom left pixel. This matches the indexing style of Julia as well as DS9, IRAF, SourceExtractor, and WCS. If a position is not specified, it is set to (0, 0). The FWHM is a consistent scale parameter for the models. All models support a scalar (isotropic) FWHM and a FWHM for each axis (diagonal).\n\nUsage\n\nUsing the models should feel just like an array. In fact, PSFModels.PSFModel <: AbstractMatrix. However, no data is stored and no allocations have to be made. In other words, representing the models as matrices is merely a convenience, since typically astronomical data is stored in dense arrays. Another way of thinking of these is a lazy array that applies a function when indexed, rather than returning data stored in memory.\n\njulia> m = PSFModels.Gaussian(fwhm=3); # centered at (0, 0)\n\n\njulia> m[0, 0] # [x, y] for indexing\n1.0\n\njulia> m(0, 0) # (x, y) for evaluating\n1.0\n\nBecause the model is a matrix, it needs to have a size. Each model has a bounding box which can be controlled with the extent keyword. By default the extent is set by a scalar factor of the FWHM (e.g., maxsize * FWHM pixels), centered around the PSF, and rounded up. We can see how this alters the indices from a typical Matrix\n\njulia> size(m) # default 'stamp' size is fwhm * 3\n(11, 11)\n\njulia> axes(m)\n(-5:5, -5:5)\n\nif we want to collect the model into a dense matrix, regardless of the indexing (e.g. to prepare for cross-correlation), we can simply\n\njulia> stamp = collect(m);\n\n\nthese axes are merely a convenience for bounding the model, since they accept any real number as input.\n\njulia> m[100, 10000] # index-like inputs [x, y]\n0.0\n\njulia> m(2.4, 1.7) # valid for any real (x, y)\n0.0696156536973086\n\nBy bounding the model, we get a cutout which can be applied to arrays with much larger dimensions without having to iterate over the whole matrix\n\njulia> big_mat = ones(1001, 1001);\n\njulia> model = PSFModels.Gaussian(x=51, y=51, fwhm=2);\n\n\njulia> ax = map(intersect, axes(big_mat), axes(model))\n(48:54, 48:54)\n\njulia> cutout = @view big_mat[ax...]\n7×7 view(::Matrix{Float64}, 48:54, 48:54) with eltype Float64:\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0\n\njulia> stamp = @view model[ax...];\n\n\njulia> photsum = sum(cutout .* stamp)\n4.5322418212890625\n\nNice- we only had to reduce ~50 pixels instead of ~1,000,000 to calculate the aperture sum, all in under a microsecond (on my machine).\n\nSince the models are lazy, that means the type of the output can be specified, as long as it can be converted to from a real number (so no integer types).\n\njulia> mbig = PSFModels.Gaussian(BigFloat, fwhm=12);\n\n\njulia> sum(mbig)\n163.07467408408593885562554918859656805096847165259532630443572998046875\n\nfinally, we provide plotting recipes from RecipesBase.jl, which can be seen in use in the API/Reference section.\n\nusing Plots\nmodel = PSFModels.Gaussian(8)\nplot(model)              # default axes\nplot(model, 1:5, :)    # custom axes (x, y)\nplot(model, axes(other)) # use axes from other array\n\n\n\n\n\n","category":"module"},{"location":"#Benchmarks","page":"Home","title":"Benchmarks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The benchmarks can be found in the bench/ folder. To run them, first install the python dependencies","category":"page"},{"location":"","page":"Home","title":"Home","text":"$ cd bench\n$ poetry install\n$ poetry shell","category":"page"},{"location":"","page":"Home","title":"Home","text":"then get the Julia project set up","category":"page"},{"location":"","page":"Home","title":"Home","text":"$ PYTHON=$(which python) julia --project=@. -e 'using Pkg; Pkg.instantiate(); Pkg.build(\"PyCall\")'","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then run the benchmark","category":"page"},{"location":"","page":"Home","title":"Home","text":"$ julia --project=. bench.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"System Information","category":"page"},{"location":"","page":"Home","title":"Home","text":"Julia Version 1.6.0\nCommit f9720dc2eb* (2021-03-24 12:55 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin20.3.0)\n  CPU: Intel(R) Core(TM) i5-8259U CPU @ 2.30GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, skylake)\nEnvironment:\n  JULIA_NUM_THREADS = 1","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Evaluation-benchmark","page":"Home","title":"Evaluation benchmark","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This benchmark tests how long it takes to evaluate a single point in the PSF model. This may seem contrived, but we expect performance to scale directly from this measure: if it takes 1 microsecond to evaluate a single point, it should take ~1 second to evaluate a 1000x1000 image, with speedups potentially from multithreading or SIMD loop evaluation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CSV, DataFrames\nusing StatsPlots\nbenchdir(args...) = joinpath(\"..\", \"..\" ,\"bench\", args...);","category":"page"},{"location":"","page":"Home","title":"Home","text":"table = CSV.File(benchdir(\"results.csv\")) |> DataFrame","category":"page"},{"location":"","page":"Home","title":"Home","text":"@df table groupedbar(:name, [:psfmodels :astropy];\n    ylabel=\"time (s)\", yscale=:log10, leg=:outertopright,\n    label=[\"PSFModels.jl\" \"Astropy\"], size=(500, 300))","category":"page"}]
}
