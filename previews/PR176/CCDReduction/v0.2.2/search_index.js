var documenterSearchIndex = {"docs":
[{"location":"api/#API/Reference","page":"API/Reference","title":"API/Reference","text":"","category":"section"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"For now, here is a list of all documented functions.","category":"page"},{"location":"api/#Index","page":"API/Reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"","category":"page"},{"location":"api/#API/Reference-2","page":"API/Reference","title":"API/Reference","text":"","category":"section"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"Modules = [CCDReduction]","category":"page"},{"location":"api/#CCDReduction.AbstractCCDData","page":"API/Reference","title":"CCDReduction.AbstractCCDData","text":"AbstractCCDData{T}\n\nSupertype for CCDData based on AbstractMatrix interface.\n\nEvery subtype of this type should have methods data and hdr defined.\n\n\n\n\n\n","category":"type"},{"location":"api/#CCDReduction.CCDData","page":"API/Reference","title":"CCDReduction.CCDData","text":"CCDData(data::AbstractMatrix, [hdr::FITSHeader])\n\nStruct to store ImageHDU, derived from AbstractCCDData.\n\nCCDData acts like a matrix with a header associated.\n\nccd = CCDData(zeros(4, 4))\n\nccd[1]\n\nThis accesses the 1st element in matrix associated with ccd.\n\nccd[\"SIMPLE\"]\n\nOne can also access the header directly from ccd, the key can be Symbol as well.\n\nccd[:SIMPLE] = false\n\nHeader values can be directly modified from ccd.\n\nOne can perform arithmetic operations on it as well:\n\nccd1 = CCDData(zeros(4, 4))\n\nccd2 = CCDData(ones(4, 4))\n\nsum_ccd1 = ccd1 + ccd2\n\nsum_ccd2 = ccd2 + ccd1\n\nsum_ccd1 has the header of ccd1 whereas sum_ccd2 has the header ccd2.\n\nIf header is not provided in the CCDData constructor, default_header is used to generate the header.\n\n\n\n\n\n","category":"type"},{"location":"api/#CCDReduction.CCDData-Tuple{AbstractString}","page":"API/Reference","title":"CCDReduction.CCDData","text":"CCDData(path::AbstractString; hdu = 1)\n\nLoads HDU from hdu index in FITS file at path as CCDData.\n\n\n\n\n\n","category":"method"},{"location":"api/#CCDReduction.CCDData-Tuple{FITSIO.ImageHDU}","page":"API/Reference","title":"CCDReduction.CCDData","text":"CCDData(hdu::ImageHDU)\n\nLoads ImageHDU as CCDData.\n\n\n\n\n\n","category":"method"},{"location":"api/#CCDReduction.arrays","page":"API/Reference","title":"CCDReduction.arrays","text":"arrays(collection)\n\nGenerator for arrays of images of entries in data frame.\n\nIterates over collection using each path and hdu to load data into an Array.\n\nExamples\n\ncollection = fitscollection(\"~/data/tekdata\")\ndata = arrays(collection) |> collect\n\nThis returns all image arrays present in collection. This can also be used via a for-loop\n\ncollection = fitscollection(\"~/data/tekdata\")\nfor arr in arrays(collection)\n    @assert arr isa Array\n    println(size(arr))\nend\n\n# output\n(1048, 1068)\n(1048, 1068)\n...\n\n\n\n\n\n","category":"function"},{"location":"api/#CCDReduction.arrays-Tuple{Any, Any}","page":"API/Reference","title":"CCDReduction.arrays","text":"arrays(f,\n       collection;\n       path = nothing,\n       save_prefix = nothing,\n       save_suffix = nothing,\n       save = any(!isnothing, (save_prefix, path, save_suffix)),\n       save_delim = \"_\",\n       ext = r\"fits(\\.tar\\.gz)?\"i,\n       kwargs...)\n\nIterates over the image arrays of the collection applying function f at each step.\n\nThe output from f can be saved using the appropriate keyword arguments. The save_prefix argument will add a prefix to each filename delimited by save_delim. save_suffix will add a suffix prior to the extension, which can be manually provided via ext, similar to fitscollection. Files will be saved in the directory they are stored unless path is given. Finally, save will default to true if any of the previous arguments are set, but can be manually overridden (useful for testing). Files will be saved using CCDReduction.writefits.\n\nExamples\n\ncollection = fitscollection(\"~/data/tekdata\")\nprocessed_images = map(arrays(collection)) do arr\n    trim(arr, (:, 1040:1059))\nend\n\nThe above generates processed_images which consists of trimmed versions of image arrays present in collection. For saving the processed_images simultaneously with the operations performed\n\nprocessed_images = map(arrays(collection; path = \"~/data/tekdata\", save_prefix = \"trimmed\")) do img\n    trim(img, (:, 1040:1059))\nend\n\nThe trimmed image arrays are saved as trimmed_(original_name) (FITS files) at path = \"~/data/tekdata\" as specified by the user.\n\n\n\n\n\n","category":"method"},{"location":"api/#CCDReduction.ccds","page":"API/Reference","title":"CCDReduction.ccds","text":"ccds(collection)\n\nGenerator for CCDDatas of entries in data frame.\n\nIterates over collection using each path and hdu to load data into a CCDData.\n\nExamples\n\ncollection = fitscollection(\"~/data/tekdata\")\nfor hdu in ccds(collection)\n    @assert hdu isa CCDData\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#CCDReduction.ccds-Tuple{Any, Any}","page":"API/Reference","title":"CCDReduction.ccds","text":"ccds(f,\n     collection;\n     path = nothing,\n     save_prefix = nothing,\n     save_suffix = nothing,\n     save = any(!isnothing, (save_prefix, path, save_suffix)),\n     save_delim = \"_\",\n     ext = r\"fits(\\.tar\\.gz)?\"i,\n     kwargs...)\n\nIterates over the CCDDatas of the collection applying function f at each step.\n\nThe output from f can be saved using the appropriate keyword arguments. The save_prefix argument will add a prefix to each filename delimited by save_delim. save_suffix will add a suffix prior to the extension, which can be manually provided via ext, similar to fitscollection. Files will be saved in the directory they are stored unless path is given. Finally, save will default to true if any of the previous arguments are set, but can be manually overridden (useful for testing). Files will be saved using CCDReduction.writefits.\n\nExample\n\ncollection = fitscollection(\"~/data/tekdata\")\nprocessed_images = map(ccds(collection)) do img\n    trim(img, (:, 1040:1059))\nend\n\nThe above generates processed_images which consists of trimmed versions of images present in collection.\n\nFor saving the processed_images simultaneously with the operations performed\n\nprocessed_images = map(ccds(collection; path = \"~/data/tekdata\", save_prefix = \"trimmed\")) do img\n    trim(img, (:, 1040:1059))\nend\n\nThe trimmed images are saved as trimmed_(original_name) (FITS files) at path = \"~/data/tekdata\" as specified by the user.\n\n\n\n\n\n","category":"method"},{"location":"api/#CCDReduction.combine-Tuple{Vararg{AbstractArray{var\"#s2\", N} where {var\"#s2\"<:Number, N}, N} where N}","page":"API/Reference","title":"CCDReduction.combine","text":"combine(frames...; method = median, [hdu = 1], [header_hdu = 1])\ncombine(frames; method = median, [hdu = 1], [header_hdu = 1])\n\nCombine multiple frames using method. Multiple frames can also be passed in a vector or as generators for combining.\n\nTo pass a custom method, it must have a signature like method(::AbstractArray; dims).\n\nIf frames are strings, they will be loaded into CCDDatas first. The HDU indices can be specified with hdu as either an integer or a tuple corresponding to each file.\n\nHeader of output file (if applicable) is specified by header_hdu which by default is 1.\n\nExamples\n\njulia> frame = [reshape(1.0:4.0, (2, 2)) for i = 1:4];\n\njulia> combine(frame)\n2×2 Matrix{Float64}:\n 1.0  3.0\n 2.0  4.0\n\njulia> combine(frame, method = sum)\n2×2 Matrix{Float64}:\n 4.0  12.0\n 8.0  16.0\n\n\n\n\n\n\n","category":"method"},{"location":"api/#CCDReduction.crop-Tuple{Any, Any}","page":"API/Reference","title":"CCDReduction.crop","text":"crop(frame, shape; force_equal = true, [hdu = 1])\n\nCrops frame to the size specified by shape anchored by the frame center.\n\nThis will remove rows/cols of the frame equally on each side. When there is an uneven difference in sizes (e.g. size 9 -> 6 can't be removed equally) the default is to increase the output size (e.g. 6 -> 7) so there is equal removal on each side. To disable this, set force_equal=false, which will remove the extra slice from the end of the axis.\n\nIf frame is a string, it will be loaded into CCDData first. The HDU loaded can be specified by hdu which by default is 1.\n\nExamples\n\njulia> frame = reshape(1:25, (5, 5));\n\njulia> crop(frame, (3, 3))\n3×3 Matrix{Int64}:\n 7  12  17\n 8  13  18\n 9  14  19\n\njulia> crop(frame, (4, 3), force_equal = false)\n4×3 Matrix{Int64}:\n 6  11  16\n 7  12  17\n 8  13  18\n 9  14  19\n\n\nSee Also\n\ncropview\n\n\n\n\n\n","category":"method"},{"location":"api/#CCDReduction.cropview-Tuple{AbstractArray, Any}","page":"API/Reference","title":"CCDReduction.cropview","text":"cropview(frame, shape; force_equal = true)\n\nCrops frame to the size specified by shape anchored by the frame center.\n\nThis function is same as the crop function but returns a view of the frame.\n\nnote: Note\nThis function returns a view of the frame, so any modification to output array will result in modification of frame.\n\nSee Also\n\ncrop\n\n\n\n\n\n","category":"method"},{"location":"api/#CCDReduction.filenames","page":"API/Reference","title":"CCDReduction.filenames","text":"filenames(collection)\n\nGenerator for filenames of entries in data frame.\n\nIterates over collection using each path.\n\nExamples\n\ncollection = fitscollection(\"~/data/tekdata\")\nfor path in filenames(collection)\n    @assert path isa String\n    println(path)\nend\n\n# output\n\"~/data/tekdata/tek001.fits\"\n\"~/data/tekdata/tek002.fits\"\n...\n\n\n\n\n\n","category":"function"},{"location":"api/#CCDReduction.filenames-Tuple{Any, Any}","page":"API/Reference","title":"CCDReduction.filenames","text":"filenames(f,\n          collection;\n          path = nothing,\n          save_prefix = nothing,\n          save_suffix = nothing,\n          save = any(!isnothing, (save_prefix, path, save_suffix)),\n          save_delim = \"_\",\n          ext = r\"fits(\\.tar\\.gz)?\"i,\n          kwargs...)\n\nIterates over the file paths of the collection applying function f at each step.\n\nThe output from f can be saved using the appropriate keyword arguments. The save_prefix argument will add a prefix to each filename delimited by save_delim. save_suffix will add a suffix prior to the extension, which can be manually provided via ext, similar to fitscollection. Files will be saved in the directory they are stored unless path is given. Finally, save will default to true if any of the previous arguments are set, but can be manually overridden (useful for testing). Files will be saved using CCDReduction.writefits.\n\nExamples\n\ncollection = fitscollection(\"~/data/tekdata\")\ndata = map(filenames(collection)) do path\n    fh = FITS(path)\n    data = getdata(fh[1]) # assuming all 1-hdu are ImageHDUs\n    close(fh)\n    data\nend\n\nThe above generates data which consists of image arrays corresponding to 1st hdu of FITS file paths present in collection. For saving the data simultaneously with the operations performed\n\ndata = map(filenames(collection; path = \"~/data/tekdata\", save_prefix = \"retrieved_from_filename\")) do img\n    fh = FITS(path)\n    data = getdata(fh[1]) # assuming all 1-hdu are ImageHDUs\n    close(fh)\n    data\nend\n\nThe retrieved data is saved as retrieved_from_filename_(original_name) (FITS files) at path = \"~/data/tekdata\" as specified by the user.\n\n\n\n\n\n","category":"method"},{"location":"api/#CCDReduction.find_ccd-Tuple{Base.Broadcast.Broadcasted}","page":"API/Reference","title":"CCDReduction.find_ccd","text":"A = find_ccd(As) returns the first CCDData among the arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#CCDReduction.fitscollection-Tuple{String}","page":"API/Reference","title":"CCDReduction.fitscollection","text":"fitscollection(dir;\n               recursive=true,\n               abspath=true,\n               keepext=true,\n               ext=r\"fits(\\.tar\\.gz)?\",\n               exclude=nothing,\n               exclude_dir=nothing,\n               exclude_key=(\"\", \"HISTORY\"))\n\nWalk through dir collecting FITS files, scanning their headers, and culminating into a DataFrame that can be used with the generators for iterating over many files and processing them. If recursive is false, no subdirectories will be walked through.\n\nThe table returned will contain the path to the file, the name of the file, and index of the corresponding HDU, and each FITS header column and value. If two FITS files have distinct columns, they will both appear in the table with missing in the appropriate rows. \n\nnote: Duplicate Keys\nIn certain cases, there are multiple FITS headers with the same key, e.g., COMMENT. In these cases, only the first instance of the key-value pair will be stored.\n\nIf abspath is true, the path in the table will be absolute. If keepext is true, the name in the table will include the file extension, given by ext. ext will be used with endswith to filter for fits files compatible with FITSIO.FITS. exclude is a pattern that can be used with occursin to exclude certain filenames. For example, to exclude any files containing \"sky\",\n\nfitscollection(...; exclude=\"sky\")\n\nto exclude exact filenames, regex strings will prove powerful\n\nfitscollection(...; exclude=r\"^tek001\\d\")\n\nfinally, using external tools like Glob.jl allows further customization\n\nusing Glob\nfitscollection(...; exclude=fn\"tek001*.fits\") # same as regex match above\n\nSimilarly, exclude_dir allows excluding entire folders using pattern matching (e.g. skipping a backup folder exclude_dir=\"backup\"). exclude_key allows excluding certain entries in the header unit of ImageHDU in FITS files (e.g. skipping \"HISTORY\" and \"\" exclude_key = (\"HISTORY\", \"\")).\n\nFor more information about the file matching and path deconstruction, see the extended help (??fitscollection)\n\nExtended Help\n\nParts of a path\n\nLet's look at some file paths starting from \"/data\". Here are examples of how they would be parsed\n\n root  dir   base   ext\n[----][---][------][---]\n/data/test/tek0001.fits\n\n root    dir     base   ext\n[----][-------][------][---]\n/data/test/sci/tek0001.fits\n\nIf keepext is true, name=base * ext, otherwise it is just base. If abspath is true, the path will be root * dir * base * ext, otherwise it will be dir * base * ext. These options allow flexility in creating a table that can be easily saved and loaded to avoid having to manually filter files. Especially consider how abspath can allow keeping tables that will transfer easily between computers or between data sources with common structures.\n\n\n\n\n\n","category":"method"},{"location":"api/#CCDReduction.flat_correct!-Tuple{AbstractArray, AbstractArray}","page":"API/Reference","title":"CCDReduction.flat_correct!","text":"flat_correct!(frame, flat_frame; norm_value = mean(flat_frame), [hdu = 1])\n\nIn-place version of flat_correct\n\nSee Also\n\nflat_correct\n\n\n\n\n\n","category":"method"},{"location":"api/#CCDReduction.flat_correct-Union{Tuple{S}, Tuple{T}, Tuple{AbstractArray{T, N} where N, AbstractArray{S, N} where N}} where {T, S}","page":"API/Reference","title":"CCDReduction.flat_correct","text":"flat_correct(frame, flat_frame; norm_value = mean(flat_frame), [hdu = 1])\n\nCorrect frame for non-uniformity using the calibrated flat_frame.\n\nBy default, the flat_frame is normalized by its mean, but this can be changed by providing a custom norm_value.\n\nIf either are strings, they will be loaded into CCDData first. The HDU loaded can be specified by hdu as either an integer or a tuple corresponding to each file.\n\nnote: Note\nThis function may introduce non-finite values if flat_frame contains values very close to 0 due to dividing by zero. The default behavior will return Inf if the frame value is non-zero, and Nan if the frame value is 0.\n\nExamples\n\njulia> frame = ones(3, 3);\n\njulia> flat = fill(2.0, (3, 3));\n\njulia> flat_correct(frame, flat, norm_value = 1.0)\n3×3 Matrix{Float64}:\n 0.5  0.5  0.5\n 0.5  0.5  0.5\n 0.5  0.5  0.5\n\njulia> flat_correct(frame, flat)\n3×3 Matrix{Float64}:\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n\n\nSee Also\n\nflat_correct!\n\n\n\n\n\n","category":"method"},{"location":"api/#CCDReduction.getdata-Tuple{FITSIO.ImageHDU}","page":"API/Reference","title":"CCDReduction.getdata","text":"CCDReduction.getdata(::FITSIO.ImageHDU)\n\nLoads the given HDU as an Array, permuting the dimensions appropriately.\n\nFITSIO.jl takes over memory read in by cfitsio, which reads in row-major form, whereas when Julia takes that memory, it is assumed as column major. Therefore all data read by FITSIO.read is transposed. This function allows the user to read data in a consistent way to Array by transposing after reading.\n\n\n\n\n\n","category":"method"},{"location":"api/#CCDReduction.subtract_bias!-Tuple{AbstractArray, AbstractArray}","page":"API/Reference","title":"CCDReduction.subtract_bias!","text":"subtract_bias!(frame, bias_frame; [hdu = 1])\n\nIn-place version of subtract_bias\n\nSee Also\n\nsubtract_bias\n\n\n\n\n\n","category":"method"},{"location":"api/#CCDReduction.subtract_bias-Tuple{AbstractArray, AbstractArray}","page":"API/Reference","title":"CCDReduction.subtract_bias","text":"subtract_bias(frame, bias_frame; [hdu = 1])\n\nSubtract the bias_frame from frame.\n\nIf either are strings, they will be loaded into CCDData first. The HDU loaded can be specified by hdu as either an integer or a tuple corresponding to each file.\n\nExamples\n\njulia> frame = [1.0 2.2 3.3 4.5];\n\njulia> bias = [0.0 0.2 0.3 0.5];\n\njulia> subtract_bias(frame, bias)\n1×4 Matrix{Float64}:\n 1.0  2.0  3.0  4.0\n\n\nSee Also\n\nsubtract_bias!\n\n\n\n\n\n","category":"method"},{"location":"api/#CCDReduction.subtract_dark!-Tuple{AbstractArray, AbstractArray}","page":"API/Reference","title":"CCDReduction.subtract_dark!","text":"subtract_dark!(frame, dark_frame; data_exposure = 1, dark_exposure = 1, [hdu = 1])\n\nIn-place version of subtract_dark\n\nSee Also\n\nsubtract_dark\n\n\n\n\n\n","category":"method"},{"location":"api/#CCDReduction.subtract_dark-Union{Tuple{S}, Tuple{T}, Tuple{AbstractArray{T, N} where N, AbstractArray{S, N} where N}} where {T, S}","page":"API/Reference","title":"CCDReduction.subtract_dark","text":"subtract_dark(frame, dark_frame; data_exposure = 1, dark_exposure = 1, [hdu = 1])\n\nSubtract the dark_frame from frame.\n\nIf either are strings, they will be loaded into CCDData first. The HDU loaded can be specified by hdu as either an integer or a tuple corresponding to each file.\n\nExamples\n\njulia> frame = ones(3, 3);\n\njulia> dark_frame = ones(3, 3);\n\njulia> subtract_dark(frame, dark_frame)\n3×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\njulia> subtract_dark(frame, dark_frame, data_exposure = 1, dark_exposure = 4)\n3×3 Matrix{Float64}:\n 0.75  0.75  0.75\n 0.75  0.75  0.75\n 0.75  0.75  0.75\n\n\nSee Also\n\nsubtract_dark!\n\n\n\n\n\n","category":"method"},{"location":"api/#CCDReduction.subtract_overscan!-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Any}} where T","page":"API/Reference","title":"CCDReduction.subtract_overscan!","text":"subtract_overscan!(frame, idxs; dims = axes_min_length(idxs))\n\nIn-place version of subtract_overscan\n\nSee Also\n\nsubtract_overscan\n\n\n\n\n\n","category":"method"},{"location":"api/#CCDReduction.subtract_overscan-Tuple{Any, Any}","page":"API/Reference","title":"CCDReduction.subtract_overscan","text":"subtract_overscan(frame, idxs; dims = axes_min_length(idxs), [hdu = 1])\n\nSubtract the overscan frame from image.\n\ndims is the dimension along which overscan_frame is combined. The default value of dims is the axis with smaller length in overscan region. If idxs is a string it will be parsed as FITS-style indices.\n\nIf frame is a string, it will be loaded into CCDData first. The HDU loaded can be specified by hdu which by default is 1.\n\nExamples\n\njulia> frame = [4.0 2.0 3.0 1.0 1.0];\n\njulia> subtract_overscan(frame, (:, 4:5), dims = 2)\n1×5 Matrix{Float64}:\n 3.0  1.0  2.0  0.0  0.0\n\njulia> subtract_overscan(frame, \"[4:5, 1:1]\", dims = 2)\n1×5 Matrix{Float64}:\n 3.0  1.0  2.0  0.0  0.0\n\n\nSee Also\n\nsubtract_overscan!\n\n\n\n\n\n","category":"method"},{"location":"api/#CCDReduction.trim-Tuple{Any, Any}","page":"API/Reference","title":"CCDReduction.trim","text":"trim(frame, idxs; [hdu = 1])\n\nTrims the frame to remove the region specified by idxs.\n\nThis function trims the array in a manner such that final array should be rectangular. The indices follow standard Julia convention, so (:, 45:60) trims all columns from 45 to 60 and (1:20, :) trims all the rows from 1 to 20. The function also supports FITS-style indices.\n\nIf frame is a string, it will be loaded into CCDData first. The HDU loaded can be specified by hdu which by default is 1.\n\nExamples\n\njulia> frame = ones(5, 5);\n\njulia> trim(frame, (:, 2:5))\n5×1 Matrix{Float64}:\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n\njulia> trim(frame, \"[2:5, 1:5]\")\n5×1 Matrix{Float64}:\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n\n\nSee Also\n\ntrimview\n\n\n\n\n\n","category":"method"},{"location":"api/#CCDReduction.trimview-Tuple{AbstractArray, Any}","page":"API/Reference","title":"CCDReduction.trimview","text":"trimview(frame, idxs)\n\nTrims the frame to remove the region specified by idxs.\n\nThis function is same as the trim function but returns a view of the frame.\n\nnote: Note\nThis function returns a view of the frame, so any modification to output array will result in modification of frame.\n\nSee Also\n\ntrim\n\n\n\n\n\n","category":"method"},{"location":"api/#CCDReduction.writefits-Tuple{Any, Any}","page":"API/Reference","title":"CCDReduction.writefits","text":"CCDReduction.writefits(file_path, data; header = nothing)\nCCDReduction.writefits(file_path, ccd::CCDData)\n\nWrites data/ccd in FITS format at file_path.\n\nFITSIO takes over memory write in by cfitsio, which writes in row-major form, whereas when Julia gives that memory, it is assumed as column major. Therefore all data written by FITSIO.write is transposed. This function allows the user to write the data in a consistent way to FITS file by transposing before writing.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = CCDReduction","category":"page"},{"location":"#CCDReduction.jl","page":"Home","title":"CCDReduction.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides tools for basic reduction methods of CCD images.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: GitHub) (Image: Build Status) (Image: PkgEval) (Image: Codecov) (Image: License)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"From Julia enter Pkg mode","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia>]\n\n(1.3) pkg> add CCDReduction","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You'll recognize most of the familiar reduction operations allow us to quickly and easily operate on data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CCDReduction\n\nnoise = randn(512, 512)\nbias_frame = reshape(1:262144, 512, 512) |> collect\nimg = reshape(1:262144, 512, 512) .+ noise\n\nsubtract_bias(img, bias_frame)\nnothing; # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition to working on array-like data, we can directly load from a FITSIO.ImageHDU or from a filename","category":"page"},{"location":"","page":"Home","title":"Home","text":"using FITSIO\n\n# make fits file\nbias_frame = reshape(1:262144, 512, 512) |> collect\nFITS(\"master_bias.fits\", \"w\") do f\n    write(f, bias_frame)\nend\nimg = 10 .* randn(512, 512)\ndebiased = subtract_bias(img, \"master_bias.fits\")\nnothing; # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, we can use function chaining (or tools like Underscores.jl) for creating a simple processing pipeline!","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Underscores\n\n# 5 science frames\nimgs = (10 .* randn(512, 524) for _ in 1:5)\n\n# create pipeline using Underscores.jl\npipeline(img) = @_ img |>\n    subtract_overscan(__, (:, 513:524)) |>\n    trim(__, (:, 513:524)) |>\n    subtract_bias(__, \"master_bias.fits\")\n\n# apply pipeline to images using broadcast syntax\ncalib_imgs = pipeline.(imgs)\nnothing; # hide","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This work is distributed under the MIT \"expat\" license. See LICENSE for more information.","category":"page"}]
}
