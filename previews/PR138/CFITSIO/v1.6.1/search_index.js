var documenterSearchIndex = {"docs":
[{"location":"#CFITSIO.jl","page":"Home","title":"CFITSIO.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: GitHub) (Image: Build Status) (Image: PkgEval) (Image: Coverage)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This module provides an interface familiar to users of the CFITSIO C library. It can be used with","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CFITSIO","category":"page"},{"location":"","page":"Home","title":"Home","text":"The functions exported by this module operate on FITSFile objects, which is a thin wrapper around a pointer to a CFITSIO fitsfile. For the most part, the functions are thin wrappers around the CFITSIO routines of the same names. Typically, they:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Convert from Julia types to C types as necessary.\nCheck the returned status value and raise an appropriate exception if non-zero.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The following tables give the correspondances between CFITSIO \"types\", the BITPIX keyword and Julia types.","category":"page"},{"location":"#Type-Conversions","page":"Home","title":"Type Conversions","text":"","category":"section"},{"location":"#CFITSIO-Types","page":"Home","title":"CFITSIO Types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CODE CFITSIO Julia\n int Cint\n long Clong\n LONGLONG Int64","category":"page"},{"location":"#FITS-BITPIX","page":"Home","title":"FITS BITPIX","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CODE CFITSIO Julia\n8 BYTE_IMG UInt8\n16 SHORT_IMG Int16\n32 LONG_IMG Int32\n64 LONGLONG_IMG Int64\n-32 FLOAT_IMG Float32\n-64 DOUBLE_IMG Float64","category":"page"},{"location":"#CFITSIO-Aliases","page":"Home","title":"CFITSIO Aliases","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CODE CFITSIO Julia Comments\n10 SBYTE_IMG Int8 written as: BITPIX = 8, BSCALE = 1, BZERO = -128\n20 USHORT_IMG UInt16 written as: BITPIX = 16, BSCALE = 1, BZERO = 32768\n40 LONG_IMG UInt32 written as: BITPIX = 32, BSCALE = 1, BZERO = 2147483648\n80 ULONGLONG_IMG UInt64 written as: BITPIX = 64, BSCALE = 1, BZERO = 9223372036854775808","category":"page"},{"location":"#FITS-Table-Data-Types","page":"Home","title":"FITS Table Data Types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CODE CFITSIO Julia\n1 TBIT \n11 TBYTE Cuchar, UInt8\n12 TSBYTE Cchar, Int8\n14 TLOGICAL Bool\n16 TSTRING String\n20 TUSHORT Cushort\n21 TSHORT Cshort\n30 TUINT Cuint\n31 TINT Cint\n40 TULONG Culong\n41 TLONG Clong\n42 TFLOAT Cfloat\n80 TULONGLONG UInt64\n81 TLONGLONG Int64\n82 TDOUBLE Cdouble\n83 TCOMPLEX Complex{Cfloat}\n163 TDBLCOMPLEX Complex{Cdouble}","category":"page"},{"location":"#CFITSIO.bitpix_from_type","page":"Home","title":"CFITSIO.bitpix_from_type","text":"bitpix_from_type(::Type)::Cint\n\nReturn the FITS BITPIX code for the given Julia type\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.type_from_bitpix","page":"Home","title":"CFITSIO.type_from_bitpix","text":"type_from_bitpix(::Integer)::Type\n\nReturn the Julia type from the FITS BITPIX code\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.cfitsio_typecode","page":"Home","title":"CFITSIO.cfitsio_typecode","text":"cfitsio_typecode(::Type)::Cint\n\nReturn the CFITSIO type code for the given Julia type\n\n\n\n\n\n","category":"function"},{"location":"#File-access","page":"Home","title":"File access","text":"","category":"section"},{"location":"#CFITSIO.fits_create_file","page":"Home","title":"CFITSIO.fits_create_file","text":"fits_create_file(filename::AbstractString)\n\nCreate and open a new empty output FITSFile. This methods uses the extended file name syntax to create the file.\n\nSee also fits_create_diskfile which does not use the extended filename parser.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_create_diskfile","page":"Home","title":"CFITSIO.fits_create_diskfile","text":"fits_create_diskfile(filename::AbstractString)\n\nCreate and open a new empty output FITSFile. Unlike fits_create_file, this function does not use an extended filename parser and treats the string as is as the filename.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_clobber_file","page":"Home","title":"CFITSIO.fits_clobber_file","text":"fits_clobber_file(filename::AbstractString)\n\nLike fits_create_file, but overwrites filename if it exists.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_open_file","page":"Home","title":"CFITSIO.fits_open_file","text":"fits_open_file(filename::String, [mode = 0])\n\nOpen an existing data file.\n\nModes:\n\n0 : Read only (equivalently denoted by CFITSIO.READONLY or CFITSIO.R)\n1 : Read-write (equivalently denoted by CFITSIO.READWRITE or CFITSIO.RW)\n\nThis function uses the extended filename syntax to open the file. See also fits_open_diskfile that does not use the extended filename parser and uses filename as is as the name of the file.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_open_diskfile","page":"Home","title":"CFITSIO.fits_open_diskfile","text":"fits_open_diskfile(filename::String, [mode = 0])\n\nOpen an existing data file.\n\nModes:\n\n0 : Read only (equivalently denoted by CFITSIO.READONLY or CFITSIO.R)\n1 : Read-write (equivalently denoted by CFITSIO.READWRITE or CFITSIO.RW)\n\nThis function does not use the extended filename parser, and uses filename as is as the name of the file that is to be opened. See also fits_open_file which uses the extended filename syntax.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_open_table","page":"Home","title":"CFITSIO.fits_open_table","text":"fits_open_table(filename::String, [mode = 0])\n\nOpen an existing data file (like fits_open_file) and move to the first HDU containing either an ASCII or a binary table.\n\nModes:\n\n0 : Read only (equivalently denoted by CFITSIO.READONLY or CFITSIO.R)\n1 : Read-write (equivalently denoted by CFITSIO.READWRITE or CFITSIO.RW)\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_open_image","page":"Home","title":"CFITSIO.fits_open_image","text":"fits_open_image(filename::String, [mode = 0])\n\nOpen an existing data file (like fits_open_file) and move to the first HDU containing an image.\n\nModes:\n\n0 : Read only (equivalently denoted by CFITSIO.READONLY or CFITSIO.R)\n1 : Read-write (equivalently denoted by CFITSIO.READWRITE or CFITSIO.RW)\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_open_data","page":"Home","title":"CFITSIO.fits_open_data","text":"fits_open_data(filename::String, [mode = 0])\n\nOpen an existing data file (like fits_open_file) and move to the first HDU containing either an image or a table.\n\nModes:\n\n0 : Read only (equivalently denoted by CFITSIO.R)\n1 : Read-write (equivalently denoted by CFITSIO.RW)\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_close_file","page":"Home","title":"CFITSIO.fits_close_file","text":"fits_close_file(f::FITSFile)\n\nClose a previously opened FITS file.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_delete_file","page":"Home","title":"CFITSIO.fits_delete_file","text":"fits_delete_file(f::FITSFile)\n\nClose an opened FITS file (like fits_close_file) and removes it from the disk.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_file_name","page":"Home","title":"CFITSIO.fits_file_name","text":"fits_file_name(f::FITSFile)\n\nReturn the name of the file associated with object f.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_file_mode","page":"Home","title":"CFITSIO.fits_file_mode","text":"fits_file_mode(f::FITSFile)\n\nReturn the I/O mode of the FITS file, where 0 indicates a read-only mode and 1 indicates a read-write mode.\n\n\n\n\n\n","category":"function"},{"location":"#HDU-Routines","page":"Home","title":"HDU Routines","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The functions described in this section change the current HDU and to find their number and type. The following is a short example which shows how to use them:","category":"page"},{"location":"","page":"Home","title":"Home","text":"num = fits_get_num_hdus(f)\nprintln(\"Number of HDUs in the file: \", num)\n\nfor i = 1:num\n    hdu_type = fits_movabs_hdu(f, i)\n    println(i, \") hdu_type = \", hdu_type)\nend","category":"page"},{"location":"#CFITSIO.fits_get_num_hdus","page":"Home","title":"CFITSIO.fits_get_num_hdus","text":"fits_get_num_hdus(f::FITSFile)\n\nReturn the number of HDUs in the file.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_movabs_hdu","page":"Home","title":"CFITSIO.fits_movabs_hdu","text":"fits_movabs_hdu(f::FITSFile, hduNum::Integer)\n\nChange the current HDU to the value specified by hduNum, and return a symbol describing the type of the HDU.\n\nPossible symbols are: image_hdu, ascii_table, or binary_table. The value of hduNum must range between 1 and the value returned by fits_get_num_hdus.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_movrel_hdu","page":"Home","title":"CFITSIO.fits_movrel_hdu","text":"fits_movrel_hdu(f::FITSFile, hduNum::Integer)\n\nChange the current HDU by moving forward or backward by hduNum HDUs (positive means forward), and return the same as fits_movabs_hdu.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_movnam_hdu","page":"Home","title":"CFITSIO.fits_movnam_hdu","text":"fits_movnam_hdu(f::FITSFile, extname::String, extver::Integer=0,\n                hdu_type_int::Integer=-1)\n\nChange the current HDU by moving to the (first) HDU which has the specified extension type and EXTNAME and EXTVER keyword values (or HDUNAME and HDUVER keywords).\n\nIf extver is 0 (the default) then the EXTVER keyword is ignored and the first HDU with a matching EXTNAME (or HDUNAME) keyword will be found. If hdu_type_int is -1 (the default) only the extname and extver values will be used to locate the correct extension. If no matching HDU is found in the file, the current HDU will remain unchanged.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_copy_file","page":"Home","title":"CFITSIO.fits_copy_file","text":"fits_copy_file(fin::FITSFile, fout::FITSFile, previous::Bool, current::Bool, following::Bool)\n\nCopy all or a part of the HDUs from the input file fin, and append them to the output file fout. The flags previous, current and following specify which HDUs are to be copied.\n\nIf previous is true, all the HDUs prior to the current input HDU are copied.\nIf current is true, the current input HDU is copied.\nIf following is true, all the HDUs following the current input HDU are copied.\n\nThese flags may be combined, so if all are set to true then all the HDUs are copied from fin to fout.\n\nOn exit, the input is unchanged, and the last HDU in the output is set as the current HDU.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_copy_hdu","page":"Home","title":"CFITSIO.fits_copy_hdu","text":"fits_copy_hdu(fin::FITSFile, fout::FITSFile[, morekeys::Integer = 0])\n\nCopy the current HDU from the input file fin and append it to the output file fout. Space may be reserved for morekeys additional keywords in the output header.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_copy_data","page":"Home","title":"CFITSIO.fits_copy_data","text":"fits_copy_data(fin::FITSFile, fout::FITSFile)\n\nCopy the data (not the header) from the current HDU in fin to the current HDU in fout. This will overwrite pre-existing data in the output HDU.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_delete_hdu","page":"Home","title":"CFITSIO.fits_delete_hdu","text":"fits_delete_hdu(f::FITSFile)\n\nDelete the HDU from the FITS file and shift the following HDUs forward. If f is the primary HDU in the file then it'll be replaced by a null primary HDU with no data and minimal header information.\n\nReturn a symbol to indicate the type of the new current HDU. Possible symbols are: image_hdu, ascii_table, or binary_table. The value of hduNum must range between 1 and the value returned by fits_get_num_hdus.\n\n\n\n\n\n","category":"function"},{"location":"#Header-Keyword-Routines","page":"Home","title":"Header Keyword Routines","text":"","category":"section"},{"location":"#CFITSIO.fits_get_hdrspace","page":"Home","title":"CFITSIO.fits_get_hdrspace","text":"fits_get_hdrspace(f::FITSFile) -> (keysexist, morekeys)\n\nReturn the number of existing keywords (not counting the END keyword) and the amount of space currently available for more keywords.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_read_keyword","page":"Home","title":"CFITSIO.fits_read_keyword","text":"fits_read_keyword(f::FITSFile, keyname::String) -> (value, comment)\n\nyields the specified keyword value and commend (as a tuple of strings), throws and error if the keyword is not found.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_read_record","page":"Home","title":"CFITSIO.fits_read_record","text":"fits_read_record(f::FITSFile, keynum::Int)::String\n\nReturn the nth header record in the CHU. The first keyword in the header is at keynum = 1.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_read_keyn","page":"Home","title":"CFITSIO.fits_read_keyn","text":"fits_read_keyn(f::FITSFile, keynum::Int) -> (name, value, comment)\n\nReturn the nth header record in the CHU. The first keyword in the header is at keynum = 1.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_write_key","page":"Home","title":"CFITSIO.fits_write_key","text":"fits_write_key(f::FITSFile, keyname::String, value, comment::Union{String, Nothing} = nothing)\n\nWrite a keyword of the appropriate data type into the CHU. If comment is nothing, the keyword is written without a comment.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_write_record","page":"Home","title":"CFITSIO.fits_write_record","text":"fits_write_record(f::FITSFile, card::String)\n\nWrite a user specified keyword record into the CHU.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_delete_record","page":"Home","title":"CFITSIO.fits_delete_record","text":"fits_delete_record(f::FITSFile, keynum::Int)\n\nDelete the keyword record at the specified index.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_delete_key","page":"Home","title":"CFITSIO.fits_delete_key","text":"fits_delete_key(f::FITSFile, keyname::String)\n\nDelete the keyword named keyname.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_hdr2str","page":"Home","title":"CFITSIO.fits_hdr2str","text":"fits_hdr2str(f::FITSFile, nocomments::Bool=false)\n\nReturn the header of the CHDU as a string. If nocomments is true, comment cards are stripped from the output.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_copy_header","page":"Home","title":"CFITSIO.fits_copy_header","text":"fits_copy_header(fin::FITSFile, fout::FITSFile)\n\nCopy the header (not the data) associated with the current HDU from fin to fout. If the current HDU in fout is not empty, it will be closed and a new HDU will be appended. An empty output HDU will be created with the header but no data.\n\n\n\n\n\n","category":"function"},{"location":"#Image-HDU-Routines","page":"Home","title":"Image HDU Routines","text":"","category":"section"},{"location":"#CFITSIO.fits_get_img_dim","page":"Home","title":"CFITSIO.fits_get_img_dim","text":"fits_get_img_dim(f::FITSFile)\n\nReturn the number of dimensions in the current image HDU.\n\nSee also fits_get_img_type, fits_get_img_size and fits_get_img_param.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_get_img_size","page":"Home","title":"CFITSIO.fits_get_img_size","text":"fits_get_img_size(f::FITSFile)\n\nReturn the size along each dimension in the current Image HDU.\n\nSee also fits_get_img_type, fits_get_img_dim and fits_get_img_param.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_get_img_type","page":"Home","title":"CFITSIO.fits_get_img_type","text":"fits_get_img_type(f::FITSFile)\n\nReturn the datatype (bitpix) of the current image HDU. This may be converted to a Julia type by using the function type_from_bitpix.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_get_img_param","page":"Home","title":"CFITSIO.fits_get_img_param","text":"fits_get_img_param(f::FITSFile)\n\nReturn the bitpix, number of dimensions and the size along each dimension of the current image HDU.\n\nSee also fits_get_img_type, fits_get_img_dim and fits_get_img_size.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_create_img","page":"Home","title":"CFITSIO.fits_create_img","text":"fits_create_img(f::FITSFile, T::Type, naxes::Vector{<:Integer})\n\nCreate a new primary array or IMAGE extension with the specified data type T and size naxes.\n\n\n\n\n\nfits_create_img(f::FITSFile, A::AbstractArray)\n\nCreate a new primary array or IMAGE extension with the element type and size of A, that is capable of storing the entire array A.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_create_empty_img","page":"Home","title":"CFITSIO.fits_create_empty_img","text":"fits_create_empty_img(f::FITSFile)\n\nCreate an empty image HDU with no dimensions, and of type Int. See fits_create_img.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_insert_img","page":"Home","title":"CFITSIO.fits_insert_img","text":"fits_insert_img(f::FITSFile, T::Type,\n                naxes::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}; prepend_primary::Bool = false)\n\nInsert a new image extension immediately following the current HDU (CHDU), or insert a new primary array at the beginning of the file.\n\nA new primary array may be inserted at the beginning of the FITS file by calling fits_insert_img with prepend_primary set to true. In this case, the existing primary HDU is converted to an image extension, and the new primary array will become the CHDU.\n\nThe inserted array has an eltype T and size naxes.\n\nfits_insert_img(f::FITSFile, a::AbstractArray{<:Real}; prepend_primary::Bool = false)\n\nInsert a new image HDU with an element type of eltype(a) and a size of size(a) that is capable of storing the array a. The flag prepend_primary may be specified to insert a new primary array at the beginning of the FITS file.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_write_pix","page":"Home","title":"CFITSIO.fits_write_pix","text":"fits_write_pix(f::FITSFile,\n               fpixel::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}},\n               nelements::Integer, data::StridedArray)\n\nWrite nelements pixels from data into the FITS file starting from the pixel fpixel.\n\nnote: Note\ndata needs to be stored contiguously in memory.\n\nSee also: fits_write_pixnull\n\n\n\n\n\nfits_write_pix(f::FITSFile, data::StridedArray)\n\nWrite the entire array data into the FITS file.\n\nnote: Note\ndata needs to be stored contiguously in memory.\n\nSee also: fits_write_pixnull, fits_write_subset\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_write_pixnull","page":"Home","title":"CFITSIO.fits_write_pixnull","text":"fits_write_pixnull(f::FITSFile,\n                   fpixel::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}},\n                   nelements::Integer, data::StridedArray, nulval)\n\nWrite nelements pixels from data into the FITS file starting from the pixel fpixel. The argument nulval specifies the values that are to be considered as \"null values\", and replaced by appropriate numbers corresponding to the element type of data.\n\nnote: Note\ndata needs to be stored contiguously in memory.\n\nSee also: fits_write_pix\n\n\n\n\n\nfits_write_pixnull(f::FITSFile, data::StridedArray, nulval)\n\nWrite the entire array data into the FITS file. The argument nulval specifies the values that are to be considered as \"null values\", and replaced by appropriate numbers corresponding to the element type of data.\n\nnote: Note\ndata needs to be stored contiguously in memory.\n\nSee also: fits_write_pix\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_write_subset","page":"Home","title":"CFITSIO.fits_write_subset","text":"fits_write_subset(f::FITSFile,\n                  fpixel::V, lpixel::V,\n                  data::StridedArray) where {V<:Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}}\n\nWrite a rectangular section of the FITS image. The number of pixels to be written will be computed from the first and last pixels (specified as the fpixel and lpixel arguments respectively).\n\nnote: Note\nThe section to be written out must be contiguous in memory, so all the dimensions aside from the last one must span the entire axis range. The arguments fpixel and lpixel must account for this.\n\nSee also: fits_write_pix\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_read_pix","page":"Home","title":"CFITSIO.fits_read_pix","text":"fits_read_pix(f::FITSFile,\n              fpixel::NTuple{Vector{<:Integer}, Tuple{Vararg{Integer}}},\n              nelements::Integer, [nulval], data::StridedArray)\n\nRead nelements pixels from the FITS file into data starting from the pixel fpixel. If the optional argument nulval is specified and is non-zero, any null value present in the array will be replaced by it.\n\nnote: Note\ndata needs to be stored contiguously in memory.\n\nSee also: fits_read_pixnull, fits_read_subset\n\n\n\n\n\nfits_read_pix(f::FITSFile, data::StridedArray, [nulval])\n\nRead length(data) pixels from the FITS file into data starting from the first pixel. The optional argument nulval, if specified and non-zero, is used to replace any null value present in the array.\n\nnote: Note\ndata needs to be stored contiguously in memory.\n\nSee also: fits_read_pixnull\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_read_pixnull","page":"Home","title":"CFITSIO.fits_read_pixnull","text":"fits_read_pixnull(f::FITSFile,\n                  fpixel::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}},\n                  nelements::Integer, data::StridedArray, nullarray::Array{UInt8})\n\nRead nelements pixels from the FITS file into data starting from the pixel fpixel. At output, the indices of nullarray where data has a corresponding null value are set to 1.\n\nnote: Note\ndata needs to be stored contiguously in memory.\n\nSee also: fits_read_pix\n\n\n\n\n\nfits_read_pixnull(f::FITSFile, data::StridedArray, nullarray::Array{UInt8})\n\nRead length(data) pixels from the FITS file into data starting from the first pixel. At output, the indices of nullarray where data has a corresponding null value are set to 1.\n\nnote: Note\ndata needs to be stored contiguously in memory.\n\nSee also: fits_read_pix\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_read_subset","page":"Home","title":"CFITSIO.fits_read_subset","text":"fits_read_subset(f::FITSFile,\n                 fpixel::V, lpixel::V, inc::V,\n                 [nulval],\n                 data::StridedArray) where {V<:Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}}\n\nRead a rectangular section of the FITS image. The number of pixels to be read will be computed from the first and last pixels (specified as the fpixel and lpixel arguments respectively). The argument inc specifies the step-size in pixels along each dimension.\n\nIf the optional argument nulval is specified and is non-zero, null values in data will be replaced by it.\n\nnote: Note\ndata needs to be stored contiguously in memory, and will be populated contiguously with the pixels that are read in.\n\nSee also: fits_read_pix\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_read_imghdr","page":"Home","title":"CFITSIO.fits_read_imghdr","text":"fits_read_imghdr(f::FITSFile, maxdim::Integer = 99)\n\nRead the header of an image HDU, where maxdim represents the maximum number of dimensions to read. By default, maxdim == 99 will read the size along every dimension of the image. The function returns the values of SIMPLE::Bool, BITPIX::Int, NAXIS::Int, NAXES::Vector{Int}, PCOUNT::Int, GCOUNT::Int, and EXTEND::Bool. The length of NAXES is set equal to min(NAXIS, maxdim).\n\nThe BITPIX value indicates the data type of the image, and it may be converted to a Julia type using the type_from_bitpix function.\n\nnote: Note\nPCOUNT is typically 0 for image HDUs, and GCOUNT is typically 1 for modern files.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_copy_image_section","page":"Home","title":"CFITSIO.fits_copy_image_section","text":"fits_copy_image_section(fin::FITSFile, fout::FITSFile, section::String)\n\nCopy a rectangular section of an image from fin and write it to a new FITS primary image or image extension in fout. The section specifier is described on the CFITSIO website.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_write_null_img","page":"Home","title":"CFITSIO.fits_write_null_img","text":"fits_write_null_img(f::FITSFile, firstelem::Integer, nelements::Integer)\n\nSet a stretch of elements to the appropriate null value, starting from the pixel number firstelem and extending over nelements pixels.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_resize_img","page":"Home","title":"CFITSIO.fits_resize_img","text":"fits_resize_img(f::FITSFile, T::Type, naxis::Integer,\n                sz::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}})\n\nModify the size, dimensions and optionally the element type of the image in f. The new image will have an element type T, be a naxis-dimensional image with size sz. If the new image is larger than the existing one, it will be zero-padded at the end. If the new image is smaller, existing image data will be truncated.\n\nnote: Note\nThis method reinterprets the data instead of coercing the elements.\n\nExample\n\njulia> f = fits_clobber_file(tempname());\n\njulia> a = [1 2; 3 4];\n\njulia> fits_create_img(f, a);\n\njulia> fits_write_pix(f, a);\n\njulia> fits_get_img_size(f)\n2-element Vector{Int64}:\n 2\n 2\n\njulia> fits_resize_img(f, [3,3]);\n\njulia> fits_get_img_size(f)\n2-element Vector{Int64}:\n 3\n 3\n\njulia> b = similar(a, (3,3));\n\njulia> fits_read_pix(f, b); b\n3×3 Matrix{Int64}:\n 1  4  0\n 3  0  0\n 2  0  0\n\njulia> fits_resize_img(f, [4]);\n\njulia> b = similar(a, (4,));\n\njulia> fits_read_pix(f, b); b\n4-element Vector{Int64}:\n 1\n 3\n 2\n 4\n\n\n\n\n\nfits_resize_img(f::FITSFile, sz::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}})\n\nResize the image to the new size sz. The element type is preserved, and the number of dimensions is set equal to length(sz).\n\n\n\n\n\nfits_resize_img(f::FITSFile, T::Type)\n\nChange the element type of the image to T, leaving the size unchanged.\n\n\n\n\n\n","category":"function"},{"location":"#Table-Routines","page":"Home","title":"Table Routines","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are two functions to create a new HDU table extension: fits_create_ascii_table and fits_create_binary_table. In general, one should pick the second as binary tables require less space on the disk and are more efficient to read and write. (Moreover, a few datatypes are not supported in ASCII tables). In order to create a table, the programmer must specify the characteristics of each column by passing an array of tuples. Here is an example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"f = fits_create_file(\"!new.fits\")\ncoldefs = [(\"SPEED\", \"1D\", \"m/s\"),\n           (\"MASS\", \"1E\", \"kg\"),\n           (\"PARTICLE\", \"20A\", \"Name\")]\nfits_create_binary_tbl(f, 10, coldefs, \"PARTICLE\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"This example creates a table with room for 10 entries, each of them describing the characteristics of a particle: its speed, its mass, and its name (codified as a 20-character string). See the documentation of fits_create_ascii_tbl for more details.","category":"page"},{"location":"#CFITSIO.fits_create_ascii_tbl","page":"Home","title":"CFITSIO.fits_create_ascii_tbl","text":"fits_create_ascii_tbl(f::FITSFile, numrows::Integer,\n                      coldefs::Union{Array{NTuple{3,String}}, Array{NTuple{2,String}}},\n                      extname::Union{String, Nothing} = nothing)\n\nAppend a new HDU containing an ASCII table.\n\nThe table will have numrows rows (this parameter can be set to zero), each initialized with the default value. In order to create a table, the programmer must specify the characteristics of each column. The columns are specified by the coldefs variable, which is an array of tuples. Each tuple must have two or three string fields:\n\nThe name of the column.\nThe data type and the repetition count. It must be a string made by a number (the repetition count) followed by a letter specifying the type (in the example above, D stands for Float64, E stands for Float32, A stands for Char). Refer to the CFITSIO documentation for more information about the syntax of this parameter.\nThe unit of this field. This is used to set the corresponding TUNITn keywords. If coldefs is a two-tuple, the unit keywords are left unset. If the third field of a tuple is an empty string, the corresponding unit keyword is also left unset.\n\nThe value of extname sets the \"extended name\" of the table, i.e., a string that in some situations can be used to refer to the HDU itself. This may be omitted by setting extname to nothing (which is the default behavior).\n\nNote that, unlike for binary tables, CFITSIO puts some limitations to the types that can be used in an ASCII table column. Refer to the CFITSIO manual for further information.\n\nSee also fits_create_binary_tbl for a similar function which creates binary tables. In general, one should pick this function for creating tables in a new HDU, as binary tables require less space on the disk and are more efficient to read and write. (Moreover, a few datatypes are not supported in ASCII tables).\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_create_binary_tbl","page":"Home","title":"CFITSIO.fits_create_binary_tbl","text":"fits_create_binary_tbl(f::FITSFile, numrows::Integer,\n                       coldefs::Union{Array{NTuple{3,String}}, Array{NTuple{2,String}}},\n                       extname::Union{String, Nothing} = nothing)\n\nAppend a new HDU containing a binary table. The meaning of the parameters is the same as in a call to fits_create_ascii_tbl.\n\nIn general, one should pick this function for creating tables in a new HDU, as binary tables require less space on the disk and are more efficient to read and write. (Moreover, a few datatypes are not supported in ASCII tables).\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_get_coltype","page":"Home","title":"CFITSIO.fits_get_coltype","text":"fits_get_coltype(f::FITSFile, colnum::Integer)\n\nProvided that the current HDU contains either an ASCII or binary table, return information about the column at position colnum (counting from 1).\n\nReturn is a tuple containing\n\ntypecode: CFITSIO integer type code of the column.\nrepcount: Repetition count for the column.\nwidth: Width of an individual element.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_insert_rows","page":"Home","title":"CFITSIO.fits_insert_rows","text":"fits_insert_rows(f::FITSFile, firstrow::Integer, nrows::Integer)\n\nInsert a number of rows equal to nrows after the row number firstrow.\n\nThe elements in each row are initialized to their default value: you can modify them later using fits_write_col.\n\nSince the first row is at position 1, in order to insert rows before the first one firstrow must be equal to zero.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_delete_rows","page":"Home","title":"CFITSIO.fits_delete_rows","text":"fits_delete_rows(f::FITSFile, firstrow::integer, nrows::Integer)\n\nDelete nrows rows, starting from the one at position firstrow. The index of the first row is 1.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_read_col","page":"Home","title":"CFITSIO.fits_read_col","text":"fits_read_col(f, colnum, firstrow, firstelem, data)\n\nRead data from one column of an ASCII/binary table and convert the data into the specified type T.\n\nArguments\n\nf::FITSFile: the file to be read.\ncolnum::Integer: the column number, where the value of the first column is 1.\nfirstrow::Integer: the elements to be read start from this row.\nfirstelem::Integer: specifies which is the first element to be read, when each cell contains more than one element (i.e., the \"repetition count\" of the field is greater than one).\ndata::Array: at the end of the call, this will be filled with the elements read\n\nfrom the column. The length of the array gives the overall number of elements.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_write_col","page":"Home","title":"CFITSIO.fits_write_col","text":"fits_write_col(f, colnum, firstrow, firstelem, data)\n\nWrite some data in one column of a ASCII/binary table.\n\nIf there is no room for the elements, new rows will be created. (It is therefore useless to call fits_insert_rows if you only need to append elements to the end of a table.)\n\nf::FITSFile: the file in which data will be written.\ncolnum::Integer: the column number, where the value of the first column is 1.\nfirstrow::Integer: the data wil be written from this row onwards.\nfirstelem::Integer: specifies the position in the row where the first element will be written.\ndata::Array: contains the elements that are to be written to the column of the table.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_read_atblhdr","page":"Home","title":"CFITSIO.fits_read_atblhdr","text":"fits_read_atblhdr(f::FITSFile, maxdim::Integer = 99)\n\nRead the header of an ASCII table HDU, where maxdim represents the maximum number of columns to read. The function returns the length of a row in bytes, the number of rows, the number of columns, the column names as a Vector{String}, the byte offsets to each column, the TFORMn values as a Vector{String}, the TUNITn values as a Vector{String}, and the EXTNAME::String keyword, if any.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.fits_read_btblhdr","page":"Home","title":"CFITSIO.fits_read_btblhdr","text":"fits_read_btblhdr(f::FITSFile, maxdim::Integer = 99)\n\nRead the header of a binary table HDU, where maxdim represents the maximum number of columns to read. The function returns the number of rows, the number of columns, the column names as a Vector{String}, the TFORMn values  as a Vector{String}, the TUNITn values as a Vector{String}, and the EXTNAME::String and PCOUNT::Int keywords.\n\n\n\n\n\n","category":"function"},{"location":"#Miscellaneous","page":"Home","title":"Miscellaneous","text":"","category":"section"},{"location":"#CFITSIO.libcfitsio_version","page":"Home","title":"CFITSIO.libcfitsio_version","text":"libcfitsio_version()::VersionNumber\n\nReturn the version of the underlying CFITSIO library\n\nExample\n\njulia> libcfitsio_version()\nv\"3.37.0\"\n\n\n\n\n\n","category":"function"}]
}
