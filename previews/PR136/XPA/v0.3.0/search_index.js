var documenterSearchIndex = {"docs":
[{"location":"client/#Client-operations","page":"Client operations","title":"Client operations","text":"","category":"section"},{"location":"client/","page":"Client operations","title":"Client operations","text":"Client operations involve querying data from one or several XPA servers or sending data to one or several XPA servers.","category":"page"},{"location":"client/#Persistent-client-connection","page":"Client operations","title":"Persistent client connection","text":"","category":"section"},{"location":"client/","page":"Client operations","title":"Client operations","text":"To avoid reconnecting to the XPA server for each client request, XPA.jl maintains a per-task persistent connection to the server. The end-user should therefore not have to worry about creating persistent XPA client connections by calling XPA.Client() for its application. Persistent XPA client connections are automatically shutdown and related resources freed when tasks are garbage collected. The close() method can be applied to a persistent XPA client connection (if this is done for one of the memorized per-task connection, the connection will be automatically re-open if necessary). If needed, XPA.connection() yields the persistent XPA client of the calling task.","category":"page"},{"location":"client/#Identifying-XPA-servers","page":"Client operations","title":"Identifying XPA servers","text":"","category":"section"},{"location":"client/","page":"Client operations","title":"Client operations","text":"The utility XPA.list can be called to get a list of running XPA servers:","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"julia> XPA.list()\n2-element Vector{XPA.AccessPoint}:\n XPA.AccessPoint(class=\"DS9\", name=\"ds9\", address=\"/tmp/.xpa/DS9_ds9-8.7b1.17760\", user=\"eric\", access=\"gs\")\n XPA.AccessPoint(class=\"DS9\", name=\"ds9\", address=\"7f000001:43881\", user=\"eric\", access=\"gs\")","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"indicates that two XPA servers are available and that both are SAOImage-DS9, an astronomical tool to display images, the first one is using a Unix socket connection, the 2nd one an internet socket. The identities of XPA servers is the string $class:$name which can be matched by a template like $class:*. In this case, both servers are identified by \"DS9:ds9\" and matched by \"DS9:*\", to distinguish them, their address (which is unique) must be used. Using the address is thus the recommended way to identify a unique XPA server.","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"XPA.list may be called with a predicate function to filter the list of servers. This function is called with each XPA.AccessPoint of the running XPA servers and shall return a Boolean to indicate whether the server is to be selected. For example, using the do-block syntax:","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"julia> apts = XPA.list() do apt\n           apt.class == \"DS9\" && startswith(apt.address, \"/\")\n       end\n1-element Vector{XPA.AccessPoint}:\n XPA.AccessPoint(class=\"DS9\", name=\"ds9-8.7b1\", address=\"/tmp/.xpa/DS9_ds9-8.7b1.17760\", user=\"eric\", access=\"gs\")\n","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"lists the SAOImage/DS9 servers with a Unix socket connection while:","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"julia> apts = XPA.list() do apt\n           apt.class == \"DS9\" && startswith(apt.address, r\"[0-9a-fA-F]\")\n       end\n1-element Vector{XPA.AccessPoint}:\n XPA.AccessPoint(class=\"DS9\", name=\"ds9-8.7b1\", address=\"7f000001:43881\", user=\"eric\", access=\"gs\")\n","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"lists the SAOImage/DS9 servers with an internet socket connection. The method keyword may also be used to choose a specific connection type. See XPA.list documentation for more details and for other keywords.","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"In order to get the address of a unique XPA server, you may call XPA.find with a predicate function to filter the matching servers and a selection method to keep a single one among all matching servers. For example:","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"julia> apt = XPA.find(; select=first) do apt\n           apt.class == \"DS9\" && startswith(apt.name, \"ds9\")\n       end\nXPA.AccessPoint(class=\"DS9\", name=\"ds9-8.7b1\", address=\"/tmp/.xpa/DS9_ds9-8.7b1.17760\", user=\"eric\", access=\"gs\")\n","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"The select keyword may be a function (as above) or a symbol such as :interact to have an interactive menu for the user to choose one of the servers if there are more than one matching servers:","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"julia> apt = XPA.find(; select=:interact) do apt\n           apt.class == \"DS9\"\n       end\nPlease select one of:\n > (none)\n   DS9:ds9-8.7b1 [address=\"/tmp/.xpa/DS9_ds9-8.7b1.17760\", user=\"eric\"]\n   DS9:ds9-8.7b1 [address=\"7f000001:43881\", user=\"eric\"]","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"If there are no matching servers, XPA.find returns nothing unless the throwerrors keyword is true to throw an exception if no match is found. If there are more than one matching servers and no select method is specified or if it is not :interact, XPA.find throws an error.","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"The address of an XPA.AccessPoint instance apt is given by apt.address. See the documentation of XPA.AccessPoint for other properties of apt that can be used in the filter and select functions.","category":"page"},{"location":"client/#Getting-data-from-one-or-more-servers","page":"Client operations","title":"Getting data from one or more servers","text":"","category":"section"},{"location":"client/#Available-methods","page":"Client operations","title":"Available methods","text":"","category":"section"},{"location":"client/","page":"Client operations","title":"Client operations","text":"To query something from one or more XPA servers, call the XPA.get method:","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"XPA.get([conn,] apt, args...) -> rep","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"which uses the persistent client connection conn to retrieve data from one or more XPA access-points identified by apt as a result of the command build from arguments args.... Argument conn is optional, if it is not specified, a per-task persistent connection is used. The XPA access-point apt is an instance of XPA.AccessPoint or a string which can be a template name, a host:port string or the path to a Unix socket file. The arguments args... are converted into a single command string where the elements of args... are separated by a single space.","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"For example, to query the version number of up to 5 running SAOImage-DS9 servers:","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"julia> rep = XPA.get(\"DS9:*\", \"version\"; nmax=5)\nXPA.Reply (2 answers):\n  1: server = \"DS9:ds9-8.7b1 7f000001:43881\", message = \"\", data = \"ds9-8.7b1 8.7b1\\n\"\n  2: server = \"DS9:ds9-8.7b1 7f000001:36785\", message = \"\", data = \"ds9-8.7b1 8.7b1\\n\"\n","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"For best performances or to make sure to receive answers from a single server, a unique server address shall be used, not a template as above.","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"The answer, bound to variable rep in the above example, to the XPA.get request is an instance of XPA.Reply which is an abstract vector of answer(s). To access the different parts of the i-th answer, use its properties. Property rep[i].server yields the identifier and address of the server who sent the answer. Properties rep[i].has_message and rep[i].has_error indicate whether rep[i] has an associated message, respectively a normal one or an error one, which is given by rep[i].message (see the Messages section below). For example:","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"julia> rep[1].server\n\"DS9:ds9-8.7b1 7f000001:43881\"\n\njulia> rep[1].has_message\nfalse\n\njulia> rep[1].has_error\nfalse\n\njulia> rep[1].message\n\"\"\n","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"Usually the most interesting part of a particular answer is its data part and property rep[i].data is a callable object to access such data with the following syntax:","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"rep[i].data()                  # a vector of bytes\nrep[i].data(String)            # an ASCII string\nrep[i].data(T)                 # a value of type `T`\nrep[i].data(Vector{T})         # the largest possible vector with elements of type `T`\nrep[i].data(Array{T}, dims...) # an array of element type `T` and size `dims...`","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"For example:","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"julia> rep[1].data(String)\n\"ds9-8.7b1 8.7b1\\n\"\n","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"See the documentation of XPA.Reply for more details.","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"To avoid checking for errors for every answer to an XPA request, XPA.has_errors(rep) yields whether any of the answers in rep has an error. Otherwise, the XPA.get method has a throwerrors keyword that can be set true in order to automatically throw an exception if there are any errors in the answers.","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"The syntax rep[] can be used to index the unique answer in rep throwing an error if length(rep) != 1. If you are only interested in the data associated to a single answer, you may thus do:","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"XPA.get(apt, args...)[].data(T, dims...)","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"This is so common that the same result is obtained by directly specifying T and, optionally, dims as the leading arguments of a XPA.get call:","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"XPA.get(T, apt, args...)\nXPA.get(T, dims, apt, args...)","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"In this context, exactly one answer and no errors are expected from the request (as if nmax=1 and throwerrors=true were specified) and dims, if specified, must be a single integer or a tuple of integers.","category":"page"},{"location":"client/#Examples","page":"Client operations","title":"Examples","text":"","category":"section"},{"location":"client/","page":"Client operations","title":"Client operations","text":"The following examples assume that apt is the access-point or the unique address of a SAOImage-DS9 server. For instance:","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"using XPA\napt = XPA.find(apt -> apt.class == \"DS9\"; select=:interact)","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"To retrieve the version as a string:","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"julia> XPA.get(String, apt, \"version\")\n\"ds9-8.7b1 8.7b1\\n\"","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"To retrieve the about answer as (non-empty) lines:","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"julia> split(XPA.get(String, apt, \"about\"), r\"\\n|\\r\\n?\"; keepempty=false)\n10-element Vector{SubString{String}}:\n \"SAOImageDS9\"\n \"Version 8.7b1\"\n \"Authors\"\n \"William Joye (Smithsonian Astrophysical Observatory)\"\n \"Eric Mandel (Smithsonian Astrophysical Observatory)\"\n \"Steve Murray (Smithsonian Astrophysical Observatory)\"\n \"Development funding\"\n \"NASA's Applied Information Systems Research Program (NASA/ETSO)\"\n \"Chandra X-ray Science Center (CXC)\"\n \"High Energy Astrophysics Science Archive Center (NASA/HEASARC)\"\n","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"To retrieve the bits-per-pixel and the dimensions of the current image:","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"bitpix = parse(Int, XPA.get(String, apt, \"fits bitpix\"))\ndims = map(s -> parse(Int, s), split(XPA.get(String, apt, \"fits size\"); keepempty=false))","category":"page"},{"location":"client/#Sending-data-to-one-or-more-servers","page":"Client operations","title":"Sending data to one or more servers","text":"","category":"section"},{"location":"client/","page":"Client operations","title":"Client operations","text":"The XPA.set method is called to send a command and some optional data to a server. The general syntax is:","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"XPA.set([conn,] apt, args...; data=nothing) -> rep","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"which sends data to one or more XPA access-points identified by apt with arguments args.... As with XPA.get, arguments args... are converted into a string with a single space to separate them and the result rep is an abstract vector of answer(s) stored by an instance of XPA.Reply. The XPA.set method accepts the same keywords as XPA.get plus the data keyword used to specify the data to send to the server(s). The value of data may be nothing if there is no data to send (this is the default). Otherwise, the value of data may be an array, or an ASCII string. Arrays are sent as binary data, if the array data does not have contiguous elements (that is not a dense array), it is converted to an Array.","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"As an example, here is how to make SAOImage-DS9 server to quit:","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"XPA.set(apt, \"quit\");","category":"page"},{"location":"client/#Messages","page":"Client operations","title":"Messages","text":"","category":"section"},{"location":"client/","page":"Client operations","title":"Client operations","text":"If not empty, message strings associated with XPA answers are of the form:","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"XPA$ERROR message (class:name ip:port)","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"or","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"XPA$MESSAGE message (class:name ip:port)","category":"page"},{"location":"client/","page":"Client operations","title":"Client operations","text":"depending whether an error or an informative message has been set. When a message indicates an error, the corresponding data buffers may or may not be empty, depending on the particularities of the server.","category":"page"},{"location":"intro/#Using-the-XPA-messaging-system","page":"Using the XPA messaging system","title":"Using the XPA messaging system","text":"","category":"section"},{"location":"intro/","page":"Using the XPA messaging system","title":"Using the XPA messaging system","text":"In your Julia code/session, it is sufficient to do:","category":"page"},{"location":"intro/","page":"Using the XPA messaging system","title":"Using the XPA messaging system","text":"import XPA","category":"page"},{"location":"intro/","page":"Using the XPA messaging system","title":"Using the XPA messaging system","text":"or:","category":"page"},{"location":"intro/","page":"Using the XPA messaging system","title":"Using the XPA messaging system","text":"using XPA","category":"page"},{"location":"intro/","page":"Using the XPA messaging system","title":"Using the XPA messaging system","text":"This makes no differences as nothing is exported by the XPA module. This means that all methods or constants are prefixed by XPA.; but you may change the suffix, for instance:","category":"page"},{"location":"intro/","page":"Using the XPA messaging system","title":"Using the XPA messaging system","text":"import XPA as xpa","category":"page"},{"location":"intro/","page":"Using the XPA messaging system","title":"Using the XPA messaging system","text":"or in Julia version 1.5 or older:","category":"page"},{"location":"intro/","page":"Using the XPA messaging system","title":"Using the XPA messaging system","text":"using XPA\nconst xpa = XPA","category":"page"},{"location":"intro/","page":"Using the XPA messaging system","title":"Using the XPA messaging system","text":"The implemented methods are described in what follows, first the client side, then the server side and finally some utilities. More extensive XPA documentation can be found here.","category":"page"},{"location":"private/#Private-methods","page":"Private methods","title":"Private methods","text":"","category":"section"},{"location":"private/","page":"Private methods","title":"Private methods","text":"This page documents the internal methods for XPA.jl developers. Since these are not part of the public API, the page is hidden from the site navigation.","category":"page"},{"location":"private/","page":"Private methods","title":"Private methods","text":"warning: Warning\nThe functions documented here are internal to XPA.jl and should not be considered as being part of the stable/public API.","category":"page"},{"location":"private/#Types","page":"Private methods","title":"Types","text":"","category":"section"},{"location":"private/#XPA.SendBuffer","page":"Private methods","title":"XPA.SendBuffer","text":"XPA.SendBuffer\n\nAn instance of the XPA.SendBuffer structure is provided to send callbacks to record the addresses where to store the address and size of the data associated to the answer of an XPA.get request. A send callback shall use XPA.store! to set the buffer contents.\n\nSee also\n\nXPA.store!, XPA.get, XPA.Server and XPA.SendCallback.\n\n\n\n\n\n","category":"type"},{"location":"private/#XPA.ReceiveBuffer","page":"Private methods","title":"XPA.ReceiveBuffer","text":"An instance of the XPA.ReceiveBuffer structure is provided to receive callbacks to record the address and the size of the data sent by an XPA.set request. Methods pointer(buf) and sizeof(buf) can be used to query the address and the number of bytes of the buffer buf.\n\nSee also\n\nXPA.get, XPA.Server, and XPA.ReceiveCallback.\n\n\n\n\n\n","category":"type"},{"location":"private/#XPA.NullBuffer","page":"Private methods","title":"XPA.NullBuffer","text":"XPA.NullBuffer\n\nsingleton type representing an empty buffer when sending data to a server. Its length is 0 byte and its address is Ptr{Cvoid}(0).\n\n\n\n\n\n","category":"type"},{"location":"private/#XPA.TupleOf","page":"Private methods","title":"XPA.TupleOf","text":"XPA.TupleOf{T} represents a tuple of any number of elements of type T, it is an alias for Tuple{Vararg{T}}\n\n\n\n\n\n","category":"type"},{"location":"private/#XPA.CDefs-module","page":"Private methods","title":"XPA.CDefs module","text":"","category":"section"},{"location":"private/#XPA.CDefs","page":"Private methods","title":"XPA.CDefs","text":"Module XPA.CDefs provides Julia equivalents to constants and structures defined in C header xpa.h. These private definitions are put in a sub-module to make them not directly accessible.\n\n\n\n\n\n","category":"module"},{"location":"private/#XPA.CDefs.SelOn","page":"Private methods","title":"XPA.CDefs.SelOn","text":"abstract type SelOn\n\nWrapper around XPA's SelOn type:\n\ntypedef void (*SelOn)(void *client_data);\n\n\n\n\n\n","category":"type"},{"location":"private/#XPA.CDefs.SelOff","page":"Private methods","title":"XPA.CDefs.SelOff","text":"abstract type SelOff\n\nWrapper around XPA's SelOff type:\n\ntypedef void (*SelOff)(void *client_data);\n\n\n\n\n\n","category":"type"},{"location":"private/#XPA.CDefs.SelAdd","page":"Private methods","title":"XPA.CDefs.SelAdd","text":"abstract type SelAdd\n\nWrapper around XPA's SelAdd type:\n\ntypedef void *(*SelAdd)(void *client_data, int fd);\n\n\n\n\n\n","category":"type"},{"location":"private/#XPA.CDefs.SelDel","page":"Private methods","title":"XPA.CDefs.SelDel","text":"abstract type SelDel\n\nWrapper around XPA's SelDel type:\n\ntypedef void (*SelDel)(void *client_data);\n\n\n\n\n\n","category":"type"},{"location":"private/#XPA.CDefs.SendCb","page":"Private methods","title":"XPA.CDefs.SendCb","text":"SendCb\n\nWrapper around XPA's SendCb type:\n\ntypedef int (*SendCb)(void *client_data, void *call_data, char *paramlist,\n                      char **buf, size_t *len);\n\n\n\n\n\n","category":"type"},{"location":"private/#XPA.CDefs.ReceiveCb","page":"Private methods","title":"XPA.CDefs.ReceiveCb","text":"ReceiveCb\n\nWrapper around XPA's ReceiveCb type:\n\ntypedef int (*ReceiveCb)(void *client_data, void *call_data,\n                         char *paramlist, char *buf, size_t len);\n\n\n\n\n\n","category":"type"},{"location":"private/#XPA.CDefs.MyFree","page":"Private methods","title":"XPA.CDefs.MyFree","text":"MyFree\n\nWrapper around XPA's MyFree type:\n\ntypedef void (*MyFree)(void *buf);\n\n\n\n\n\n","category":"type"},{"location":"private/#XPA.CDefs.InfoCb","page":"Private methods","title":"XPA.CDefs.InfoCb","text":"InfoCb\n\nWrapper around XPA's InfoCb type:\n\ntypedef int (*InfoCb)(void *client_data, void *call_data, char *paramlist);\n\n\n\n\n\n","category":"type"},{"location":"private/#XPA.CDefs.XPACommRec","page":"Private methods","title":"XPA.CDefs.XPACommRec","text":"XPACommRec\n\nXPA communication structure for each connection.\n\n\n\n\n\n","category":"type"},{"location":"private/#XPA.CDefs.NSRec","page":"Private methods","title":"XPA.CDefs.NSRec","text":"abstract type NSRec\n\nOpaque structure for struct nsrec.\n\n\n\n\n\n","category":"type"},{"location":"private/#XPA.CDefs.ClipRec","page":"Private methods","title":"XPA.CDefs.ClipRec","text":"abstract type ClipRec\n\nOpaque structure for struct cliprec.\n\n\n\n\n\n","category":"type"},{"location":"private/#XPA.CDefs.XPAInputRec","page":"Private methods","title":"XPA.CDefs.XPAInputRec","text":"abstract type XPAInputRec\n\nOpaque structure for struct xpainputrec.\n\n\n\n\n\n","category":"type"},{"location":"private/#XPA.CDefs.XPAClientRec","page":"Private methods","title":"XPA.CDefs.XPAClientRec","text":"abstract type XPAClientRec\n\nOpaque structure for struct xpaclientrec.\n\n\n\n\n\n","category":"type"},{"location":"private/#XPA.CDefs.XPACmdRec","page":"Private methods","title":"XPA.CDefs.XPACmdRec","text":"abstract type XPACmdRec\n\nOpaque structure for struct xpacmdrec.\n\n\n\n\n\n","category":"type"},{"location":"library/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"library/","page":"Reference","title":"Reference","text":"The following provides detailled documentation about types and methods provided by the XPA package.  This information is also available from the REPL by typing ? followed by the name of a method or a type.","category":"page"},{"location":"library/#XPA-client-methods-and-types","page":"Reference","title":"XPA client methods and types","text":"","category":"section"},{"location":"library/#XPA.Client","page":"Reference","title":"XPA.Client","text":"XPA.Client\n\nAn instance of the mutable structure XPA.Client represents a client connection in the XPA Messaging System.\n\n\n\n\n\n","category":"type"},{"location":"library/#XPA.connection","page":"Reference","title":"XPA.connection","text":"XPA.connection()\n\nyields a persistent XPA client connection that is kept open for the calling task (a different connection is memorized for each Julia task).\n\nPer-task client connections are automatically open (or even re-open) and closed as needed.\n\n\n\n\n\n","category":"function"},{"location":"library/#XPA.get","page":"Reference","title":"XPA.get","text":"XPA.get([T, [dims,]] [conn,] apt, args...; kwds...)\n\nretrieves data from one or more XPA access-points apt with arguments args.... Argument apt is an instance of XPA.AccessPoint, a template name, a host:port string, or the path to a Unix socket file. Arguments args... are converted into a single string with elements of args... separated by a single space. Optional argument conn is a persistent XPA client connection created by XPA.Client; if omitted, a per-task connection is used (see XPA.connection). The returned value depends on the optional arguments T and dims.\n\nIf neither T nor dims are specified, an instance of XPA.Reply is returned with all the answer(s) from the XPA server(s).\n\nIf T and, possibly, dims are specified, a single answer and no errors are expected (as if nmax=1 and throwerrors=true) and the data part of the answer is converted according to T which must be a type and dims which is an optional array size:\n\nWith dims an N-dimensional array size and T an array type like Array{S} or Array{S,N}, the data is returned as an array of this type and size.\nWithout dims and if T is a vector type like Vector{S} or Memory{S}, the data is returned as a vector of type T with as many elements of type S that fit into the data.\nWithout dims and if T is String, a string interpreting the data as ASCII characters is returned.\nWithout dims and for any other types T, the sizeof(T) leading bytes of the data are returned as a single value of type T.\n\nExcept if T is String, trailing data bytes, if any, are ignored.\n\nKeywords\n\nKeyword nmax specifies the maximum number of answers. Specify nmax=-1 to use the maximum number of XPA hosts. This keyword is forced to be 1 if T is specified; otherwise, nmax=1 by default.\nKeyword throwerrors specifies whether to check for errors. If this keyword is set true, an exception is thrown for the first error message encountered in the list of answers. This keyword is forced to be true if T is specified; otherwise, throwerrors is false by default.\nKeyword mode specifies options in the form \"key1=value1,key2=value2\".\nKeyword users specifies the list of possible users owning the access-point. This (temporarily) overrides the settings in environment variable XPA_NSUSERS. By default and if the environment variable XPA_NSUSERS is not set, the access-point must be owned the caller (see Section Distinguishing Users in XPA documentation). The value is a string which may be a list of comma separated user names or \"*\" to access all users on a given machine.\n\nSee also\n\nXPA.Client, XPA.get_data, XPA.set, and XPA.verify.\n\n\n\n\n\n","category":"function"},{"location":"library/#XPA.Reply","page":"Reference","title":"XPA.Reply","text":"XPA.Reply\n\ntype of structure used to store the answer(s) of XPA.get and XPA.set requests.\n\nAssuming A is an instance of XPA.Reply, it can be used as an abstract vector and A[i] yields the i-th answer in A. The syntax A[] yields A[1] if A has a single answer and throws otherwise.\n\nA single answer A[i] implements the following properties:\n\nA[i].server       # identifier of the XPA server which sent the `i`-th answer\nA[i].data(...)    # data associated with `i`-th answer (see below)\nA[i].has_message  # whether `i`-th answer contains a message\nA[i].has_error    # whether `i`-th answer has an error\nA[i].message      # message or error message associated with `i`-th answer\n\nTo retrieve the data associated with a reply, the data property can be used as follows:\n\nA[i].data()                  # a vector of bytes\nA[i].data(String)            # a single ASCII string\nA[i].data(T)                 # a single value of type `T`\nA[i].data(Vector{T})         # the largest possible vector with elements of type `T`\nA[i].data(Array{T}, dims...) # an array of element type `T` and size `dims...`\n\nIf Base.Memory exists Vector{T} can be replaced by Memory{T}.\n\nSee also\n\nXPA.get, XPA.set, and XPA.has_errors.\n\n\n\n\n\n","category":"type"},{"location":"library/#XPA.get_data","page":"Reference","title":"XPA.get_data","text":"XPA.get_data([T, [dims,]] rep::XPA.Reply, i=1; take=false)\nXPA.get_data([T, [dims,]] rep[i]; take=false)\nrep[i].data([T, [dims,]]; take=false)\n\nyields the data associated with the i-th answer in XPA reply rep. The returned value depends on the optional leading arguments T and dims:\n\nIf neither T nor dims are specified, the data is returned as a vector of bytes (UInt8).\nWith dims an N-dimensional array size and T an array type like Array{S} or Array{S,N}, the data is returned as an array of this type and size.\nWithout dims and if T is a vector type like Vector{S} or Memory{S}, the data is returned as a vector of type T with as many elements of type S that fit into the data.\nWithout dims and if T is String, a string interpreting the data as ASCII characters is returned.\nWithout dims and for any other types T, the sizeof(T) leading bytes of the data are returned as a single value of type T.\n\nExcept if T is String, trailing data bytes, if any, are ignored.\n\nThe take keyword specifies whether the returned result may steal the internal data buffer in rep[i] thus saving some memory and copy but preventing other retrieval of the data by another call to XPA.get_data. This keyword is ignored if the result cannot directly use the internal buffer. By default, take=false.\n\nIn any cases, the type of the result is predictable, so there should be no type instability issue.\n\nnote: Note\nIn the future XPA.get_data will be deprecated; rep[i].data(...) is the recommended syntax.\n\nSee also\n\nXPA.get, XPA.get_message, and XPA.get_server.\n\n\n\n\n\n","category":"function"},{"location":"library/#XPA.get_server","page":"Reference","title":"XPA.get_server","text":"XPA.get_server(rep::XPA.Reply, i=1)\nXPA.get_server(rep[i])\nrep[i].server\n\nyields a string identifying the server who provided the i-th answer in XPA reply rep.\n\nnote: Note\nIn the future XPA.get_server will be deprecated; rep[i].server is the recommended syntax.\n\nSee also\n\nXPA.get, XPA.has_message, XPA.has_error, XPA.get_data and XPA.get_message.\n\n\n\n\n\n","category":"function"},{"location":"library/#XPA.get_message","page":"Reference","title":"XPA.get_message","text":"XPA.get_message(rep::XPA.Reply, i=1)\nXPA.get_message(rep[i])\nrep[i].message\n\nyields the message associated with the i-th answer in XPA reply rep. An empty string is returned if there is no message.\n\nnote: Note\nIn the future XPA.get_message will be deprecated; rep[i].message is the recommended syntax.\n\nSee also\n\nXPA.get, XPA.has_message, XPA.has_error, XPA.get_data and XPA.get_server.\n\n\n\n\n\n","category":"function"},{"location":"library/#XPA.has_error","page":"Reference","title":"XPA.has_error","text":"XPA.has_error(rep::XPA.Reply, i=1)\nXPA.has_error(rep[i])\nrep[i].has_error\n\nyields whether i-th answer in XPA reply rep has an error whose message is given by rep[i].message.\n\nnote: Note\nIn the future XPA.has_error will be deprecated; rep[i].has_error is the recommended syntax.\n\nSee also\n\nXPA.get, XPA.get_message, XPA.has_message, XPA.get_data, and XPA.get_server,\n\n\n\n\n\n","category":"function"},{"location":"library/#XPA.has_errors","page":"Reference","title":"XPA.has_errors","text":"XPA.has_errors(rep::Reply) -> Bool\n\nyields whether answer rep contains any error messages.\n\nSee also\n\nXPA.get, XPA.has_error, and XPA.get_message.\n\n\n\n\n\n","category":"function"},{"location":"library/#XPA.has_message","page":"Reference","title":"XPA.has_message","text":"XPA.has_message(rep::XPA.Reply, i=1)\nXPA.has_message(rep[i])\nrep[i].has_message\n\nyields whether i-th answer in XPA reply rep has an associated message that is given by rep[i].message.\n\nnote: Note\nIn the future XPA.has_message will be deprecated; rep[i].has_message is the recommended syntax.\n\nSee also\n\nXPA.get, XPA.get_message, XPA.has_error, XPA.get_data, and XPA.get_server,\n\n\n\n\n\n","category":"function"},{"location":"library/#XPA.join_arguments","page":"Reference","title":"XPA.join_arguments","text":"XPA.join_arguments(args) -> str::String\n\njoins a tuple of arguments into a single string where arguments are separated by a single space. It is implemented so as to be faster than join(args, \" \") when args has less than 2 arguments. It is intended to build XPA command string from arguments.\n\n\n\n\n\n","category":"function"},{"location":"library/#XPA.verify","page":"Reference","title":"XPA.verify","text":"XPA.verify(rep::Reply [, i]; throwerrors::Bool=false) -> Bool\n\nverifies whether answer(s) in the result rep from an XPA.get or XPA.set request has no errors. If index i is specified only that specific answer is considered; otherwise, all answers are verified. If keyword throwerrors is true, an exception is thrown for the first error found if any.\n\n\n\n\n\n","category":"function"},{"location":"library/#XPA.set","page":"Reference","title":"XPA.set","text":"XPA.set([conn,] apt, args...; data=nothing, kwds...) -> rep\n\nsends data to one or more XPA access-points identified by apt with arguments args... (automatically converted into a single string where the arguments are separated by a single space). The result is an instance of XPA.Reply. Optional argument conn is a persistent XPA client connection (created by XPA.Client); if omitted, a per-task connection is used (see XPA.connection).\n\nKeywords\n\ndata specifies the data to send, may be nothing, an array, or a string.\nnmax specifies the maximum number of recipients, nmax=1 by default. Specify nmax=-1 to use the maximum possible number of XPA hosts.\nmode specifies options in the form \"key1=value1,key2=value2\".\nthrowerrors specifies whether to check for errors. If this keyword is set true, an exception is thrown for the first error message encountered in the list of answers. By default, throwerrors is false.\nusers specifies the list of possible users owning the access-point. This (temporarily) overrides the settings in environment variable XPA_NSUSERS. By default and if the environment variable XPA_NSUSERS is not set, the access-point must be owned by the caller (see Section Distinguishing Users in XPA documentation). The value is a string which may be a list of comma separated user names or \"*\" to access all users on a given machine.\n\nSee also\n\nXPA.Client, XPA.get and XPA.verify.\n\n\n\n\n\n","category":"function"},{"location":"library/#XPA.buffer","page":"Reference","title":"XPA.buffer","text":"buf = XPA.buffer(data)\n\nyields an object buf representing the contents of data and which can be used as an argument to ccall. Argument data can be nothing, an array, or a string. If data is a dense array, buf is data. If data is another type of array, buf is data converted to an Array. If data is an ASCII string, buf is copy of data in a temporary byte buffer. If data is nothing, XPA.NullBuffer() is returned.\n\nStandard methods like pointer or sizeof can be applied to buf to retrieve the address and the size (in bytes) of the data and Base.unsafe_convert(Ptr{Cvoid}, buf) can also be used.\n\nSee also\n\nXPA.set.\n\n\n\n\n\n","category":"function"},{"location":"library/#XPA-server-methods-and-types","page":"Reference","title":"XPA server methods and types","text":"","category":"section"},{"location":"library/#XPA.Server","page":"Reference","title":"XPA.Server","text":"XPA.Server\n\nAn instance of the mutable structure XPA.Server represents a server connection in the XPA Messaging System.\n\n\n\n\n\n","category":"type"},{"location":"library/#XPA.SendCallback","page":"Reference","title":"XPA.SendCallback","text":"XPA.SendCallback <: XPA.Callback\n\nAn instance of the XPA.SendCallback structure represents a callback called to serve an XPA.get request.\n\n\n\n\n\n","category":"type"},{"location":"library/#XPA.store!","page":"Reference","title":"XPA.store!","text":"XPA.store!(buf, data)\nXPA.store!(buf, ptr, len)\n\nstore into the send buffer buf a dynamically allocated copy of the contents of data or of the len bytes at address ptr.\n\nwarning: Warning\nThis method is meant to be used in a send callback to store the result of an XPA.get request processed by an XPA server. Memory leaks are expected if used in another context.\n\nSee also\n\nXPA.Server, XPA.SendCallback, and XPA.get.\n\n\n\n\n\n","category":"function"},{"location":"library/#XPA.ReceiveCallback","page":"Reference","title":"XPA.ReceiveCallback","text":"XPA.ReceiveCallback <: XPA.Callback\n\nAn instance of the XPA.ReceiveCallback structure represents a callback called to serve an XPA.set request.\n\n\n\n\n\n","category":"type"},{"location":"library/#XPA.peek","page":"Reference","title":"XPA.peek","text":"XPA.peek(T, buf, i=1) -> val\n\nyields the i-th binary value of type T stored into receive buffer buf. Bounds checking is performed unless @inbounds is active.\n\nAnother usage of the XPA.peek method is to convert the contents of the receive buffer into an array:\n\nXPA.peek(Vector{T}, [len,] buf) -> vec\nXPA.peek(Array{T[,N]}, (dim1, ..., dimN), buf) -> arr\n\nyield a Julia vector vec or array arr whose elements are of type T and dimensions are len or (dim1, ..., dimN). For a vector, if the length is unspecified, the vector of maximal length that fits in the buffer is returned.\n\nIf keyword temporary is true, then unsafe_wrap is called (with option own=false) to wrap the buffer contents into a Julia array whose life-time cannot exceeds that of the callback. Otherwise, a copy of the buffer contents is returned.\n\nSee also\n\nXPA.ReceiveCallback.\n\n\n\n\n\n","category":"function"},{"location":"library/#Base.error-Tuple{XPA.Server, AbstractString}","page":"Reference","title":"Base.error","text":"error(srv, msg) -> XPA.FAILURE\n\nCommunicates error message msg to the client when serving a request by XPA server srv. This method shall only be used by the send/receive callbacks of an XPA server.\n\nSee also\n\nXPA.Server, XPA.message, XPA.SendCallback, and XPA.ReceiveCallback.\n\n\n\n\n\n","category":"method"},{"location":"library/#XPA.poll","page":"Reference","title":"XPA.poll","text":"XPA.poll(sec, maxreq)\n\npolls for XPA events. This method is meant to implement a polling event loop which checks for and processes XPA requests without blocking.\n\nArgument sec specifies a timeout in seconds (rounded to millisecond precision). If sec is positive, the method blocks no longer than this amount of time. If sec is strictly negative, the routine blocks until the occurrence of an event to be processed.\n\nArgument maxreq specifies how many requests will be processed. If maxreq < 0, then no events are processed, but instead, the returned value indicates the number of events that are pending. If maxreq == 0, then all currently pending requests will be processed. Otherwise, up to maxreq requests will be processed. The most usual values for maxreq are 0 to process all requests and 1 to process one request.\n\nThe following example implements a polling loop which has no noticeable impact on the consumption of CPU when no requests are emitted to the server:\n\nconst __running = Ref{Bool}(false)\n\nfunction run()\n    global __running\n    __running[] = true\n    while __running[]\n        XPA.poll(-1, 1)\n    end\nend\n\nHere the global variable __running is a reference to a boolean whose value indicates whether to continue to run the XPA server(s) created by the process. The idea is to pass the reference to the callbacks of the server (as their client data for instance) and let the callbacks stop the loop by setting the contents of the reference to false.\n\nAnother possibility is to use XPA.mainloop (which to see).\n\nTo let Julia performs other tasks, the polling method may be repeatedly called by a Julia timer. The following example does this. Calling resume starts polling for XPA events immediately and then every 100ms. Calling suspend suspends the processing of XPA events.\n\nconst __timer = Ref{Timer}()\n\nispolling() = (isdefined(__timer, 1) && isopen(__timer[]))\n\nresume() =\n    if ! ispolling()\n        __timer[] = Timer((tm) -> XPA.poll(0, 0), 0.0, interval=0.1)\n    end\n\nsuspend() =\n    ispolling() && close(__timer[])\n\nSee also\n\nXPA.Server and XPA.mainloop.\n\n\n\n\n\n","category":"function"},{"location":"library/#XPA.message","page":"Reference","title":"XPA.message","text":"XPA.message(srv, msg)\n\nsets a specific acknowledgment message back to the client. Argument srv is the XPA server serving the client and msg is the acknowledgment message. This method shall only be used by the receive callback of an XPA server.\n\nSee also\n\nXPA.Server, XPA.error, and XPA.ReceiveCallback.\n\n\n\n\n\n","category":"function"},{"location":"library/#XPA.mainloop","page":"Reference","title":"XPA.mainloop","text":"XPA.mainloop()\n\nruns XPA event loop which handles the requests sent to the server(s) created by this process. The loop runs until all servers created by this process have been closed.\n\nIn the following example, the receive callback function close the server when it receives a \"quit\" command:\n\nfunction rproc(::Nothing, srv::XPA.Server, params::String,\n               buf::Ptr{UInt8}, len::Integer)\n    status = XPA.SUCCESS\n    if params == \"quit\"\n        close(srv)\n    elseif params == ...\n        ...\n    end\n    return status\nend\n\nSee also\n\nXPA.Server and XPA.mainloop.\n\n\n\n\n\n","category":"function"},{"location":"library/#Utilities","page":"Reference","title":"Utilities","text":"","category":"section"},{"location":"library/#XPA.address","page":"Reference","title":"XPA.address","text":"XPA.address(apt) -> addr\n\nyields the address of XPA access-point apt which can be: an instance of XPA.AccessPoint, a string with a valid XPA server address or a server class:name identifier. In the latter case, XPA.find is called to find a matching server which is much longer.\n\n\n\n\n\n","category":"function"},{"location":"library/#XPA.list","page":"Reference","title":"XPA.list","text":"XPA.list(f = Returns(true); kwds...)\n\nyields a list of available XPA access-points. The result is a vector of XPA.AccessPoint instances. Optional argument f is a predicate function to filter which access-points to keep.\n\nFor example, to only keep the access-points owned by the user:\n\napts = XPA.list() do apt\n    apt.user == ENV[\"USER\"]\nend\n\nKeywords\n\nmethod is nothing (the default) or one of inet, unix (or local), or localhost as a symbol or a string to require a specific connection method.\non_error is a symbol indicating what to do in case of unexpected reply by the XPA name server; it can be :throw to throw an exception, :warn (the default) to print a warning, anything else to silently ignore the error.\nxpaget is to specify the method to contact the XPA name server; it can be a string with the path to the xpaget executable or a function behaving like XPA.get. Using XPA.get has fewer possibilities so, by default, the xpaget executable provided by XPA_jll artifact is used.\n\nSee also\n\nXPA.find to select a single access-point.\n\nXPA.AccessPoint for the properties of access-points that can be used in the predicate function f.\n\n\n\n\n\n","category":"function"},{"location":"library/#XPA.AccessPoint","page":"Reference","title":"XPA.AccessPoint","text":"apt = XPA.AccessPoint(str)\napt = XPA.AccessPoint(class, name, address, user, access)\napt = XPA.AccessPoint(; class=\"\", name=\"\", address=\"\", user=\"\", access=0)\n\nbuilds a structure representing an XPA server for a client. If single argument is a string str, it is parsed assuming the same format as the output of xpans. Otherwise the arguments/keywords reflect the properties of the object:\n\napt.class   # access-point class\napt.name    # access-point name\napt.address # server address (host:port for inet socket, path for unix socket)\napt.user    # access-point owner\napt.access  # allowed access\n\nAt least the address shall be provided.\n\nAll properties are strings except access which is an unsigned integer whose bits are set as follows:\n\n !iszero(apt.access & 1) # holds if `set` command allowed\n !iszero(apt.access & 2) # holds if `get` command allowed\n !iszero(apt.access & 4) # holds if `info` command allowed\n\nThe constructors also accept access as a string composed of characters 'g', 's', and 'i' respectively indicating whether get, set, and info commands are implemented by the server.\n\nMethod isopen(apt) yields whether address is not an empty string.\n\nSee also\n\nXPA.list to retrieve a vector of existing XPA servers possibly filtered by some provided function.\n\nXPA.find to obtain the access-point of a single XPA server.\n\n\n\n\n\n","category":"type"},{"location":"library/#XPA.find","page":"Reference","title":"XPA.find","text":"XPA.find(f = Returns(true); kwds...)\n\nyields the access-point of the XPA server matching the requirements implemented by the predicate function f and keywords kwds.... In principle, the result is either a single instance of XPA.AccessPoint or nothing if no matching server is found (this type assertion may only be invalidated by the function specified via the select keyword).\n\nKeywords\n\nIn addition to the keywords accepted by XPA.list, the following keyword(s) are available:\n\nselect specifies a strategy to apply if more than one access-point is found. select can be a function (like first or last to keep the first or last entry), the symbolic name :interact to ask the user to make the selection via a REPL menu, or anything else to throw an exception. The default is :throw. If select is a function, it is called with a vector of 2 or more matching instances of XPA.AccessPoint and the result of select is returned by XPA.find.\nthrowerrors specifies whether to throw an error if no matching servers are found instead of returning nothing.\n\nExample\n\napt = XPA.find(; interact = isinteractive(), method = :local)\n\nSee also\n\nXPA.list which is called to retrieve a list of access-points with the predicate function f.\n\nXPA.AccessPoint for the properties of access-points that can be used in the predicate function f.\n\n\n\n\n\n","category":"function"},{"location":"library/#XPA.getconfig","page":"Reference","title":"XPA.getconfig","text":"XPA.getconfig(key) -> val\n\nyields the value associated with configuration parameter key (a string or a symbol). The following parameters are available (see XPA doc. for more information):\n\nKey Name Default Value\n\"XPA_MAXHOSTS\" 100\n\"XPA_SHORT_TIMEOUT\" 15\n\"XPA_LONG_TIMEOUT\" 180\n\"XPA_CONNECT_TIMEOUT\" 10\n\"XPA_TMPDIR\" \"/tmp/.xpa\"\n\"XPA_VERBOSITY\" true\n\"XPA_IOCALLSXPA\" false\n\nAlso see XPA.setconfig!.\n\n\n\n\n\n","category":"function"},{"location":"library/#XPA.setconfig!","page":"Reference","title":"XPA.setconfig!","text":"XPA.setconfig!(key, val) -> oldval\n\nset the value associated with configuration parameter key to be val. The previous value is returned.\n\nAlso see XPA.getconfig.\n\n\n\n\n\n","category":"function"},{"location":"library/#XPA.preserve_state","page":"Reference","title":"XPA.preserve_state","text":"s = XPA.preserve_state(dict, key[, val])\n\nYield an object that can be used to restore the state of dictionary dict for entry key with XPA.restore_state. For improved type-stability, optional argument val may be specified with a substitute value of the same type as those stored in dict if key is not in dict.\n\nThe call:\n\nXPA.preserve_state(f::Function, dict, key[, val])\n\nis equivalent to:\n\nlet s = XPA.preserve_state(dict, key[, val])\n    try\n        f()\n    finally\n        XPA.restore_state(s)\n    end\nend\n\nwhich is suitable for the do-block syntax.\n\n\n\n\n\n","category":"function"},{"location":"library/#XPA.restore_state","page":"Reference","title":"XPA.restore_state","text":"XPA.restore_state(s)\n\nRestore the state saved in s by XPA.preserve_state.\n\n\n\n\n\n","category":"function"},{"location":"library/#Constants","page":"Reference","title":"Constants","text":"","category":"section"},{"location":"library/#XPA.SUCCESS","page":"Reference","title":"XPA.SUCCESS","text":"XPA.SUCCESS and XPA.FAILURE are the possible values returned by the callbacks of an XPA server.\n\n\n\n\n\n","category":"constant"},{"location":"library/#XPA.FAILURE","page":"Reference","title":"XPA.FAILURE","text":"XPA.SUCCESS and XPA.FAILURE are the possible values returned by the callbacks of an XPA server.\n\n\n\n\n\n","category":"constant"},{"location":"library/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"library/","page":"Reference","title":"Reference","text":"Pages = [\"library.md\"]","category":"page"},{"location":"misc/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"misc/","page":"Utilities","title":"Utilities","text":"The method:","category":"page"},{"location":"misc/","page":"Utilities","title":"Utilities","text":"XPA.list([xpa]) -> arr","category":"page"},{"location":"misc/","page":"Utilities","title":"Utilities","text":"returns a list of the existing XPA access points as an array of structured elements of type XPA.AccessPoint such that:","category":"page"},{"location":"misc/","page":"Utilities","title":"Utilities","text":"arr[i].class    # class of the access point\narr[i].name     # name of the access point\narr[i].address  # internet socket address or path to Unix socket file\narr[i].user     # user name of access point owner\narr[i].access   # allowed access (g=xpaget, s=xpaset, i=xpainfo)","category":"page"},{"location":"misc/","page":"Utilities","title":"Utilities","text":"all fields but access are strings, the addr field is the name of the socket used for the connection (either host:port for internet socket, or a file path for local unix socket), access is a combination of the bits XPA.GET, XPA.SET and/or XPA.INFO depending whether XPA.get(), XPA.set() and/or XPA.info() access are granted. Note that XPA.info() is not yet implemented.","category":"page"},{"location":"misc/","page":"Utilities","title":"Utilities","text":"XPA messaging system can be configured via environment variables. The methods XPA.getconfig and XPA.setconfig! provides means to get or set XPA settings:","category":"page"},{"location":"misc/","page":"Utilities","title":"Utilities","text":"XPA.getconfig(key) -> val","category":"page"},{"location":"misc/","page":"Utilities","title":"Utilities","text":"yields the current value of the XPA parameter key which is one of:","category":"page"},{"location":"misc/","page":"Utilities","title":"Utilities","text":"\"XPA_MAXHOSTS\"\n\"XPA_SHORT_TIMEOUT\"\n\"XPA_LONG_TIMEOUT\"\n\"XPA_CONNECT_TIMEOUT\"\n\"XPA_TMPDIR\"\n\"XPA_VERBOSITY\"\n\"XPA_IOCALLSXPA\"","category":"page"},{"location":"misc/","page":"Utilities","title":"Utilities","text":"The key may be a symbol or a string, the value of a parameter may be a boolean, an integer or a string. To set an XPA parameter, call the method:","category":"page"},{"location":"misc/","page":"Utilities","title":"Utilities","text":"XPA.setconfig!(key, val) -> old","category":"page"},{"location":"misc/","page":"Utilities","title":"Utilities","text":"which returns the previous value of the parameter.","category":"page"},{"location":"server/#Implementing-a-server","page":"Implementing a server","title":"Implementing a server","text":"","category":"section"},{"location":"server/#Create-an-XPA-server","page":"Implementing a server","title":"Create an XPA server","text":"","category":"section"},{"location":"server/","page":"Implementing a server","title":"Implementing a server","text":"To create a new XPA server, call the XPA.Server method:","category":"page"},{"location":"server/","page":"Implementing a server","title":"Implementing a server","text":"server = XPA.Server(class, name, help, send, recv)","category":"page"},{"location":"server/","page":"Implementing a server","title":"Implementing a server","text":"where class, name and help are strings while send and recv are callbacks created by the XPA.SendCallback and XPA.ReceiveCallback methods:","category":"page"},{"location":"server/","page":"Implementing a server","title":"Implementing a server","text":"send = XPA.SendCallback(sendfunc, senddata)\nrecv = XPA.ReceiveCallback(recvfunc, recvdata)","category":"page"},{"location":"server/","page":"Implementing a server","title":"Implementing a server","text":"where sendfunc and recvfunc are the Julia methods to call while senddata and recvdata are any data needed by the callback other than what is specified by the client request (if omitted, nothing is assumed).  The callbacks have the following forms:","category":"page"},{"location":"server/","page":"Implementing a server","title":"Implementing a server","text":"function sendfunc(senddata, xpa::Server, params::String,\n                  buf::Ptr{Ptr{UInt8}}, len::Ptr{Csize_t})\n    ...\n    return XPA.SUCCESS\nend","category":"page"},{"location":"server/","page":"Implementing a server","title":"Implementing a server","text":"The callbacks must return an integer status (of type Cint): either XPA.SUCCESS or XPA.FAILURE.  The methods XPA.seterror() and XPA.setmessage() can be used to specify a message accompanying the result.","category":"page"},{"location":"server/","page":"Implementing a server","title":"Implementing a server","text":"XPA.store!(...)\nXPA.get_send_mode(xpa)\nXPA.get_recv_mode(xpa)\nXPA.get_name(xpa)\nXPA.get_class(xpa)\nXPA.get_method(xpa)\nXPA.get_sendian(xpa)\nXPA.get_cmdfd(xpa)\nXPA.get_datafd(xpa)\nXPA.get_ack(xpa)\nXPA.get_status(xpa)\nXPA.get_cendian(xpa)","category":"page"},{"location":"server/#Manage-XPA-requests","page":"Implementing a server","title":"Manage XPA requests","text":"","category":"section"},{"location":"server/","page":"Implementing a server","title":"Implementing a server","text":"XPA.poll(msec, maxreq)","category":"page"},{"location":"server/","page":"Implementing a server","title":"Implementing a server","text":"or","category":"page"},{"location":"server/","page":"Implementing a server","title":"Implementing a server","text":"XPA.mainloop()","category":"page"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/#Installation-for-Julia-1.3","page":"Installation","title":"Installation for Julia ≥ 1.3","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Since version 0.1.0 and provided you use Julia version ≥ 1.3, XPA.jl uses XPA_jll artifact to provide the XPA dynamic library so it is sufficient to just install XPA.jl from Julia's package manager.","category":"page"},{"location":"install/#Installation-for-older-Julia-versions","page":"Installation","title":"Installation for older Julia versions","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"To use XPA.jl package, XPA dynamic library and header files must be installed on your computer.  If this is not the case, they may be available for your operating system.  Otherwise, you'll have to build it and install it yourself. Depending on this condition, there are two possibilities described below.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"The source code of XPA.jl is available here.","category":"page"},{"location":"install/#Eays-installation","page":"Installation","title":"Eays installation","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"The easiest installation is when your system provides XPA dynamic library and header files as a package.  For example, on Ubuntu, just do:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"sudo apt-get install xpa-tools libxpa-dev","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Then, to install XPA.jl package from Julia, just do:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"XPA\")","category":"page"},{"location":"install/#Custom-installation","page":"Installation","title":"Custom installation","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"If XPA dynamic library and header files are not provided by your system, you may install it manually.  That's easy but make sure that you compile and install the shared library of XPA since this is the one that will be used by Julia.  You have to download the source archive here, unpack it in some directory, build and install it.  For instance:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"cd \"$SRCDIR\"\nwget -O xpa-2.1.18.tar.gz https://github.com/ericmandel/xpa/archive/v2.1.18.tar.gz\ntar -zxvf xpa-2.1.18.tar.gz\ncd xpa-2.1.18\n./configure --prefix=\"$PREFIX\" --enable-shared\nmkdir -p \"$PREFIX/lib\" \"$PREFIX/include\" \"$PREFIX/bin\"\nmake install","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"where $SRCDIR is the directory where to download the archive and extract the source while $PREFIX is the directory where to install XPA library, header file(s) and executables.  You may consider other configuration options (run ./configure --help for a list) but make sure to have --enable-shared for building the shared library.  As of the current version of XPA (2.1.18), the installation script does not automatically build some destination directories, hence the mkdir -p ... command above.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"In order to use XPA.jl with a custom XPA installation, you may define the environment variables XPA_DEFS and XPA_LIBS to suitable values before building XPA package.  The environment variable XPA_DEFS specifies the C-preprocessor flags for finding the headers \"xpa.h\" and \"prsetup.h\" while the environment variable XPA_LIBS specifies the linker flags for linking with the XPA dynamic library.  If you have installed XPA as explained above, do:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"export XPA_DEFS=\"-I$PREFIX/include\"\nexport XPA_LIBS=\"-L$PREFIX/lib -lxpa\"","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"It may also be the case that you want to use a specific XPA dynamic library even though your system provides one.  Then define the environment variable XPA_DEFS as explained above and define the environment variable XPA_DLL with the full path to the dynamic library to use.  For instance:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"export XPA_DEFS=\"-I$PREFIX/include\"\nexport XPA_DLL=\"$PREFIX/lib/libxpa.so\"","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Note that if both XPA_LIBS and XPA_DLL are defined, the latter has precedence.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"These variables must be defined before launching Julia and cloning/building the XPA package.  You may also add the following lines in ~/.julia/config/startup.jl:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"ENV[\"XPA_DEFS\"] = \"-I/InstallDir/include\"\nENV[\"XPA_LIBS\"] = \"-L/InstallDir/lib -lxpa\"","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"or (depending on the situation):","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"ENV[\"XPA_DEFS\"] = \"-I/InstallDir/include\"\nENV[\"XPA_DLL\"] = \"/InstallDir/lib/libxpa.so\"","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"where InstallDir should be modified according to your specific installation.","category":"page"},{"location":"#The-XPA-package-for-Julia","page":"The XPA package for Julia","title":"The XPA package for Julia","text":"","category":"section"},{"location":"","page":"The XPA package for Julia","title":"The XPA package for Julia","text":"The XPA Messaging System provides seamless communication between many kinds of Unix/Windows programs, including X programs, Tcl/Tk programs. It is used to control some popular astronomical tools such as SAOImage-DS9.","category":"page"},{"location":"","page":"The XPA package for Julia","title":"The XPA package for Julia","text":"The XPA.jl package is a Julia interface to the XPA Messaging System. XPA.jl can be used to send data or commands to XPA servers, to query data from XPA servers, or to implement an XPA server. The package uses ccall to directly call the routines of the compiled XPA library.","category":"page"},{"location":"","page":"The XPA package for Julia","title":"The XPA package for Julia","text":"SAOImageDS9.jl is a Julia package that exploits XPA.jl to communicate with SAOImage-DS9.","category":"page"},{"location":"#Table-of-contents","page":"The XPA package for Julia","title":"Table of contents","text":"","category":"section"},{"location":"","page":"The XPA package for Julia","title":"The XPA package for Julia","text":"Pages = [\"intro.md\", \"client.md\", \"install.md\", \"misc.md\", \"server.md\", \"faq.md\", \"library.md\"]","category":"page"},{"location":"#Index","page":"The XPA package for Julia","title":"Index","text":"","category":"section"},{"location":"","page":"The XPA package for Julia","title":"The XPA package for Julia","text":"","category":"page"},{"location":"faq/#Frequently-asked-questions","page":"Frequently asked questions","title":"Frequently asked questions","text":"","category":"section"},{"location":"faq/#XPA.list()-or-XPA.find()-do-not-find-my-XPA-server","page":"Frequently asked questions","title":"XPA.list() or XPA.find() do not find my XPA server","text":"","category":"section"},{"location":"faq/","page":"Frequently asked questions","title":"Frequently asked questions","text":"In principle, XPA servers are able to automatically launch an XPA name-server for their type of connection (internet or Unix socket) if none is running. If an XPA name-server is killed or stop working, XPA servers registered by this name-server have to reconnect to another name-server. In SAOImage/DS9 server, this can be done by using the menu File > XPA > Disconnect and then File > XPA > Connect. If you have several SAOImage/DS9 servers, you may have to do this with each server.","category":"page"}]
}
