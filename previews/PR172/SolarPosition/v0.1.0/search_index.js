var documenterSearchIndex = {"docs":
[{"location":"refraction/#refraction-correction","page":"Refraction Correction","title":"Refraction Correction","text":"","category":"section"},{"location":"refraction/","page":"Refraction Correction","title":"Refraction Correction","text":"Atmospheric refraction causes the apparent position of the sun to differ from its true geometric position. This effect is most pronounced near the horizon and can be corrected using various atmospheric models.","category":"page"},{"location":"refraction/","page":"Refraction Correction","title":"Refraction Correction","text":"The correction formula for elevation is:","category":"page"},{"location":"refraction/","page":"Refraction Correction","title":"Refraction Correction","text":"e_apparent = e_true + R","category":"page"},{"location":"refraction/","page":"Refraction Correction","title":"Refraction Correction","text":"Where:","category":"page"},{"location":"refraction/","page":"Refraction Correction","title":"Refraction Correction","text":"e_apparent is the apparent solar elevation angle (degrees)\ne_true is the true solar elevation angle (degrees)\nR is the refraction correction (degrees), calculated based on the chosen refraction model","category":"page"},{"location":"refraction/","page":"Refraction Correction","title":"Refraction Correction","text":"(Image: Refraction correction comparison) Figure 1: Atmospheric refraction causes the sun to appear higher in the sky than its true position, especially near the horizon. Image source: Wikimedia Commons.","category":"page"},{"location":"refraction/","page":"Refraction Correction","title":"Refraction Correction","text":"SolarPosition.jl includes several refraction correction algorithms. Below is a summary of the available algorithms:","category":"page"},{"location":"refraction/","page":"Refraction Correction","title":"Refraction Correction","text":"Algorithm Reference Atmospheric Parameters Status\nHUGHES [Hug85] Pressure, Temperature ✅\nARCHER [ABO80] None ✅\nBENNETT [Ben82] Pressure, Temperature ✅\nMICHALSKY [Mic88] None ✅\nSG2 [BW12] Pressure, Temperature ✅\nSPARefraction [RA04] Pressure, Temperature ✅","category":"page"},{"location":"refraction/","page":"Refraction Correction","title":"Refraction Correction","text":"To calculate refraction, we can use the refraction function:","category":"page"},{"location":"refraction/#SolarPosition.Refraction.refraction","page":"Refraction Correction","title":"SolarPosition.Refraction.refraction","text":"refraction(model::RefractionAlgorithm, elevation::T) where {T<:AbstractFloat}\n\nApply atmospheric refraction correction to the given elevation angle(s).\n\nArguments\n\nmodel::RefractionAlgorithm: Refraction model to use (e.g., HUGHES())\nelevation::T: True (unrefracted) solar elevation angle in degrees\n\nReturns\n\nRefraction correction in degrees to be added to the elevation angle\n\nExamples\n\nusing SolarPosition\nhughes = HUGHES(101325.0, 15.0)  # 15°C temperature\nelevation = 30.0  # 30 degrees\ncorrection = refraction(hughes, elevation)\napparent_elevation = elevation + correction\n\n\n\n\n\n","category":"function"},{"location":"refraction/","page":"Refraction Correction","title":"Refraction Correction","text":"This function is typically used internally by the solar_position function when a refraction algorithm is specified, but is also a publicly available method.","category":"page"},{"location":"refraction/","page":"Refraction Correction","title":"Refraction Correction","text":"info: Info\nWhen using a refraction algorithm like HUGHES, the solar_position function returns an ApparentSolPos struct containing both true and apparent angles.","category":"page"},{"location":"refraction/#SolarPosition.Refraction.NoRefraction","page":"Refraction Correction","title":"SolarPosition.Refraction.NoRefraction","text":"struct NoRefraction <: RefractionAlgorithm\n\nIndicates that no atmospheric refraction correction should be applied.\n\nThis is the default refraction setting for solar position calculations. When used, only basic solar position (azimuth, elevation, zenith) is computed.\n\n\n\n\n\n","category":"type"},{"location":"refraction/","page":"Refraction Correction","title":"Refraction Correction","text":"info: Info\nWhen using NoRefraction (the default), the solar_position function returns a SolPos struct containing only the true geometric angles (azimuth, elevation, zenith). In this case, no refraction correction is applied.","category":"page"},{"location":"refraction/#Default-refraction-model","page":"Refraction Correction","title":"Default refraction model","text":"","category":"section"},{"location":"refraction/","page":"Refraction Correction","title":"Refraction Correction","text":"The DefaultRefraction type is a special marker that indicates to use the default refraction behavior for the selected solar position algorithm. For most algorithms, this means no refraction correction (i.e., equivalent to NoRefraction).","category":"page"},{"location":"refraction/#SolarPosition.Refraction.DefaultRefraction","page":"Refraction Correction","title":"SolarPosition.Refraction.DefaultRefraction","text":"struct DefaultRefraction <: RefractionAlgorithm\n\nDefault refraction model used when no specific model is provided.\n\nThis will depend on the solar position algorithm being used.\n\n\n\n\n\n","category":"type"},{"location":"refraction/#Comparison-of-Refraction-Models","page":"Refraction Correction","title":"Comparison of Refraction Models","text":"","category":"section"},{"location":"refraction/","page":"Refraction Correction","title":"Refraction Correction","text":"Several different refraction models have been proposed in the literature. SolarPosition.jl only implements a subset of them but PRs are always welcome! To compare the different refraction models, the refraction angle is calculated in the range -1 to 90 degree solar elevation in steps of 0.1 degrees.","category":"page"},{"location":"refraction/","page":"Refraction Correction","title":"Refraction Correction","text":"using SolarPosition\nusing CairoMakie\n\n# Define models and elevation range\nmodels = [(\"Archer\", SolarPosition.Refraction.ARCHER()), (\"Bennett\", SolarPosition.Refraction.BENNETT()),\n          (\"Hughes\", SolarPosition.Refraction.HUGHES()), (\"Michalsky\", SolarPosition.Refraction.MICHALSKY()),\n          (\"SG2\", SolarPosition.Refraction.SG2()), (\"SPA\", SolarPosition.Refraction.SPARefraction())]\nelevation = -1.5:0.1:90.0\n\n# Create figure with two subplots\nfig = Figure(size = (800, 400), backgroundcolor = :transparent, textcolor = \"#f5ab35\")\nax1 = Axis(fig[1, 1], xlabel = \"True elevation [degrees]\",\n    ylabel = \"Refraction correction [degrees]\", title = \"Near Horizon\",\n    backgroundcolor = :transparent, xticks = -1:1:4)\nax2 = Axis(fig[1, 2], xlabel = \"True elevation [degrees]\",\n    ylabel = \"Refraction correction [degrees]\", title = \"Full Range (Log Scale)\", yscale = log10, backgroundcolor = :transparent)\n\n# Plot refraction for each model\nfor (name, model) in models\n    ref = [SolarPosition.Refraction.refraction(model, e) for e in elevation]\n    lines!(ax1, elevation, ref, label = name)\n    mask = ref .> 0\n    lines!(ax2, elevation[mask], ref[mask])\nend\n\nxlims!(ax1, -1.5, 4); ylims!(ax1, 0, 1.0)\nxlims!(ax2, -1.5, 90); ylims!(ax2, 1e-3, 1.0)\n\nLegend(fig[0, :], ax1, orientation = :horizontal, framevisible = false,\n    tellwidth = false, tellheight = true, nbanks = 1)\nfig","category":"page"},{"location":"refraction/","page":"Refraction Correction","title":"Refraction Correction","text":"A comparison of the refraction models is visualized above. The plot on the left shows refraction for solar elevation angles near sunrise/sunset, where refraction is most significant. The plot on the right shows the refraction angles for the entire range of solar elevation angles. Note that for the right plot, the y-axis is a log scale, which emphasizes the difference between the models.","category":"page"},{"location":"refraction/#hughes-refraction","page":"Refraction Correction","title":"Hughes","text":"","category":"section"},{"location":"refraction/","page":"Refraction Correction","title":"Refraction Correction","text":"The Hughes refraction model accounts for atmospheric pressure and temperature effects.","category":"page"},{"location":"refraction/","page":"Refraction Correction","title":"Refraction Correction","text":"This model was developed by [Hug85] and is used in the SUNAEP software [Zim81]. It's also the basis for the refraction correction in NOAA's solar position calculator (using fixed pressure of 101325 Pa and temperature of 10°C).","category":"page"},{"location":"refraction/#SolarPosition.Refraction.HUGHES","page":"Refraction Correction","title":"SolarPosition.Refraction.HUGHES","text":"struct HUGHES{T} <: RefractionAlgorithm\n\nHughes refraction model.\n\nThis function was developed by G. Hughes [1] and was used in the SUNAEP software [2].\n\nIt is also used to calculate the refraction correction in the NOAA solar position algorithm using a fixed pressure of 101325 Pa and a temperature of 10 degrees Celsius.\n\nFields\n\npressure::Any: Annual average atmospheric pressure [Pascal]\ntemperature::Any: Annual average temperature [°C]\n\nConstructor\n\nHUGHES(): Uses default parameters: pressure = 101325 Pa, temperature = 12 °C\nHUGHES(pressure, temperature): Specify custom pressure [Pa] and temperature [°C]\n\nNotes\n\nThe equation to calculate the refraction correction is given by:\n\nFor 5° < elevation ≤ 90°:\n\nfrac581tan(el) - frac007tan(el)^3 + frac86 times 10^-5tan(el)^5\n\nFor -0.575° < elevation ≤ 5°:\n\nel cdot (-5182 + el cdot (1034 + el cdot (-1279 + el cdot 0711))) + 1735\n\nFor elevation ≤ -0.575°:\n\nfrac-20774tan(el)\n\nwhere el is the true (unrefracted) solar elevation angle.\n\nThe result is then corrected for temperature and pressure:\n\ntextRefract times frac283273 + T times fracP101325 times frac13600\n\nLiterature\n\nThis function was developed by [Hug85] and was used in the SUNAEP software [Zim81]. It is also used to calculate the refraction correction in the NOAA solar position algorithm using a fixed pressure of 101325 Pa and a temperature of 10 degrees Celsius.\n\nExample\n\nusing SolarPosition\n\n# Create Hughes refraction model with default parameters\nhughes = HUGHES()\n\n# Or specify custom atmospheric conditions\nhughes_custom = HUGHES(101325.0, 25.0)  # 25°C temperature\n\n# Apply refraction correction to elevation angle\nelevation = 30.0  # degrees\nrefraction_correction = refraction(hughes, elevation)\napparent_elevation = elevation + refraction_correction\n\n\n\n\n\n","category":"type"},{"location":"refraction/#archer-refraction","page":"Refraction Correction","title":"Archer","text":"","category":"section"},{"location":"refraction/","page":"Refraction Correction","title":"Refraction Correction","text":"The Archer refraction model is a cosine-based correction that does not require atmospheric parameters.","category":"page"},{"location":"refraction/","page":"Refraction Correction","title":"Refraction Correction","text":"This simplified model from [ABO80] computes refraction based on the zenith angle using trigonometric relationships. It's useful when atmospheric data is not available.","category":"page"},{"location":"refraction/#SolarPosition.Refraction.ARCHER","page":"Refraction Correction","title":"SolarPosition.Refraction.ARCHER","text":"struct ARCHER <: RefractionAlgorithm\n\nArcher refraction model.\n\nAtmospheric refraction correction based on the Archer algorithm.\n\nThis function calculates the atmospheric refraction correction of the solar elevation angle using the method described by Archer [1]. The method was originally developed to be used with the Walraven solar position algorithm [2].\n\nFields\n\nConstructor\n\nARCHER(): Creates an Archer refraction model instance\n\nNotes\n\nThe equation to calculate the refraction correction is given by:\n\nbeginaligned\nC = cos(Z) + 00083 cdot left(frac10955 + (20267 cdot cos(Z)) - 0047121 right)\nZ_a = arccos(C)\ntextrefraction = Z - Z_a\nendaligned\n\nwhere Z is the true solar zenith angle and Z_a is the apparent zenith angle.\n\nLiterature\n\nThis method was described by [ABO80] and was originally developed to be used with the Walraven solar position algorithm [Wal78].\n\nExample\n\nusing SolarPosition\n\n# Create Archer refraction model\narcher = ARCHER()\n\n# Apply refraction correction to elevation angle\nelevation = 30.0  # degrees\nrefraction_correction = refraction(archer, elevation)\napparent_elevation = elevation + refraction_correction\n\n\n\n\n\n","category":"type"},{"location":"refraction/#bennett-refraction","page":"Refraction Correction","title":"Bennett","text":"","category":"section"},{"location":"refraction/","page":"Refraction Correction","title":"Refraction Correction","text":"The Bennett refraction model is widely used in marine navigation and accounts for atmospheric conditions.","category":"page"},{"location":"refraction/","page":"Refraction Correction","title":"Refraction Correction","text":"Developed by [Ben82], this model provides accurate refraction corrections with adjustments for atmospheric pressure and temperature. It's particularly effective for low elevation angles.","category":"page"},{"location":"refraction/#SolarPosition.Refraction.BENNETT","page":"Refraction Correction","title":"SolarPosition.Refraction.BENNETT","text":"struct BENNETT{T} <: RefractionAlgorithm\n\nBennett refraction model.\n\nAtmospheric refraction correction based on the Bennett algorithm.\n\nCalculation of atmospheric refraction correction of the solar elevation angle using the method developed by Bennett [1].\n\nFields\n\npressure::Any: Annual average atmospheric pressure [Pascal]\ntemperature::Any: Annual average temperature [°C]\n\nConstructor\n\nBENNETT(): Uses default parameters: pressure = 101325 Pa, temperature = 12 °C\nBENNETT(pressure, temperature): Specify custom pressure [Pa] and temperature [°C]\n\nNotes\n\nThe equation to calculate the refraction correction is given by:\n\ntextref = frac028 cdot PT+273 cdot frac0016667tan(el + 731  (el+44))\n\nwhere P is the local air pressure in hPa, T is the local air temperature in °C, and el is the true (uncorrected) solar elevation angle.\n\nLiterature\n\nThis method was described by [Ben82].\n\nExample\n\nusing SolarPosition\n\n# Create Bennett refraction model with default parameters\nbennett = BENNETT()\n\n# Or specify custom atmospheric conditions\nbennett_custom = BENNETT(101325.0, 25.0)  # 25°C temperature\n\n# Apply refraction correction to elevation angle\nelevation = 30.0  # degrees\nrefraction_correction = refraction(bennett, elevation)\napparent_elevation = elevation + refraction_correction\n\n\n\n\n\n","category":"type"},{"location":"refraction/#michalsky-refraction","page":"Refraction Correction","title":"Michalsky","text":"","category":"section"},{"location":"refraction/","page":"Refraction Correction","title":"Refraction Correction","text":"The Michalsky refraction model uses a rational polynomial approximation.","category":"page"},{"location":"refraction/","page":"Refraction Correction","title":"Refraction Correction","text":"From [Mic88], this algorithm is part of the Astronomical Almanac's method for approximate solar position calculations. It includes special handling for very low elevation angles.","category":"page"},{"location":"refraction/#SolarPosition.Refraction.MICHALSKY","page":"Refraction Correction","title":"SolarPosition.Refraction.MICHALSKY","text":"struct MICHALSKY <: RefractionAlgorithm\n\nMichalsky refraction model.\n\nAtmospheric refraction correction based on the Michalsky algorithm.\n\nThis function calculates the atmospheric refraction correction of the solar elevation angle using the method described by Michalsky [1].\n\nFields\n\nConstructor\n\nMICHALSKY(): Creates a Michalsky refraction model instance\n\nNotes\n\nThe equation to calculate the refraction correction is given by:\n\ntextref = frac351561 cdot (01594 + 00196 cdot el + 000002 cdot el^2)1 + 0505 cdot el + 00845 cdot el^2\n\nwhere el is the true (uncorrected) solar elevation angle.\n\nNote that 3.51561 = 1013.2 mb / 288.2 °C.\n\nFor elevation angles below -0.56°, the refraction correction is clamped to 0.56°.\n\nLiterature\n\nThis method was described by [Mic88].\n\nExample\n\nusing SolarPosition\n\n# Create Michalsky refraction model\nmichalsky = MICHALSKY()\n\n# Apply refraction correction to elevation angle\nelevation = 30.0  # degrees\nrefraction_correction = refraction(michalsky, elevation)\napparent_elevation = elevation + refraction_correction\n\n\n\n\n\n","category":"type"},{"location":"refraction/#sg2-refraction","page":"Refraction Correction","title":"SG2","text":"","category":"section"},{"location":"refraction/","page":"Refraction Correction","title":"Refraction Correction","text":"The SG2 (Second Generation) refraction algorithm is optimized for fast computation over multi-decadal periods.","category":"page"},{"location":"refraction/","page":"Refraction Correction","title":"Refraction Correction","text":"Developed by [BW12], this algorithm uses a two-regime approach with different formulas for elevations above and below a threshold. It accounts for atmospheric pressure and temperature.","category":"page"},{"location":"refraction/#SolarPosition.Refraction.SG2","page":"Refraction Correction","title":"SolarPosition.Refraction.SG2","text":"struct SG2{T} <: RefractionAlgorithm\n\nSG2 refraction model.\n\nAtmospheric refraction correction based on the algorithm in SG2.\n\nThis function calculates the atmospheric refraction correction of the solar elevation angle using the method developed by Ph. Blanc and L. Wald [1].\n\nFields\n\npressure::Any: Annual average atmospheric pressure [Pascal]\ntemperature::Any: Annual average temperature [°C]\n\nConstructor\n\nSG2(): Uses default parameters: pressure = 101325 Pa, temperature = 12 °C\nSG2(pressure, temperature): Specify custom pressure [Pa] and temperature [°C]\n\nNotes\n\nThe equation to calculate the refraction correction is given by:\n\nFor el  -001 radians:\n\nfracP1010 cdot frac283273+T cdot frac296706 times 10^-4tan(el+00031376 cdot (el+0089186)^-1)\n\nFor el leq -001 radians:\n\n-fracP1010 cdot frac283273+T cdot frac1005516 times 10^-4tan(el)\n\nwhere el is the true solar elevation angle, P is the local air pressure in hPa, and T is the local air temperature in °C.\n\nLiterature\n\nThis method was described by [BW12].\n\nExample\n\nusing SolarPosition\n\n# Create SG2 refraction model with default parameters\nsg2 = SG2()\n\n# Or specify custom atmospheric conditions\nsg2_custom = SG2(101325.0, 25.0)  # 25°C temperature\n\n# Apply refraction correction to elevation angle\nelevation = 30.0  # degrees\nrefraction_correction = refraction(sg2, elevation)\napparent_elevation = elevation + refraction_correction\n\n\n\n\n\n","category":"type"},{"location":"refraction/#spa-refraction","page":"Refraction Correction","title":"SPARefraction","text":"","category":"section"},{"location":"refraction/","page":"Refraction Correction","title":"Refraction Correction","text":"The SPARefraction (Solar Position Algorithm) refraction model is part of NREL's high-accuracy solar position algorithm.","category":"page"},{"location":"refraction/","page":"Refraction Correction","title":"Refraction Correction","text":"From [RA04], this is the refraction correction used in NREL's SPA algorithm, which is accurate to ±0.0003° over the years -2000 to 6000. It includes a configurable refraction limit for below-horizon calculations.","category":"page"},{"location":"refraction/#SolarPosition.Refraction.SPARefraction","page":"Refraction Correction","title":"SolarPosition.Refraction.SPARefraction","text":"struct SPARefraction{T} <: RefractionAlgorithm\n\nSPARefraction - SPA (Solar Position Algorithm) refraction model.\n\nAtmospheric refraction correction from the SPA algorithm.\n\nThis function calculates the atmospheric refraction correction of the solar elevation angle using the method described in Reda and Andreas's [1] Solar Position Algorithm (SPA).\n\nFields\n\npressure::Any: Annual average atmospheric pressure [Pascal]\ntemperature::Any: Annual average temperature [°C]\nrefraction_limit::Any: Minimum elevation angle for refraction correction [degrees]\n\nConstructor\n\nSPARefraction(): Uses default parameters: pressure = 101325 Pa, temperature = 12 °C, refraction_limit = -0.5667°\nSPARefraction(pressure, temperature): Specify custom pressure [Pa] and temperature [°C], uses default refraction_limit\nSPARefraction(pressure, temperature, refraction_limit): Also specify refraction limit [degrees]\n\nNotes\n\nThe equation to calculate the refraction correction is given by:\n\ntextref = fracP1010 cdot frac283273 + T cdot frac10260 cdot tan(el + 103(el + 511))\n\nwhere el is the true solar elevation angle, P is the annual average local air pressure in hPa/mbar, and T is the annual average local air temperature in °C.\n\nThe refraction limit parameter determines the solar elevation angle below which refraction is not applied, as the sun is assumed to be below horizon. Note that the sun diameter (0.26667°) is added to this limit.\n\nLiterature\n\nThis method was described by [RA04].\n\nExample\n\nusing SolarPosition\n\n# Create SPARefraction model with default parameters\nspa = SPARefraction()\n\n# Or specify custom atmospheric conditions\nspa_custom = SPARefraction(101325.0, 25.0)  # 25°C temperature\n\n# With custom refraction limit\nspa_limit = SPARefraction(101325.0, 12.0, -1.0)  # Don't correct below -1°\n\n# Apply refraction correction to elevation angle\nelevation = 30.0  # degrees\nrefraction_correction = refraction(spa, elevation)\napparent_elevation = elevation + refraction_correction\n\n\n\n\n\n","category":"type"},{"location":"examples/getting-started/#getting-started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"examples/getting-started/","page":"Getting Started","title":"Getting Started","text":"In this tutorial, we introduduce the basics of using SolarPosition.jl to calculate solar positions.","category":"page"},{"location":"examples/getting-started/","page":"Getting Started","title":"Getting Started","text":"First, we need to import the SolarPosition.jl package along with some supporting packages which we need for handling dates and time zones. We also load DataFrames.jl because it makes it easy to work with tabular data.","category":"page"},{"location":"examples/getting-started/","page":"Getting Started","title":"Getting Started","text":"info: Info\nThe DateTime type in Julia's standard library does not contain time zone information. When using DateTime, it is assumed to be in UTC. Although not necessary, it is safer to work with time zone-aware ZonedDateTime from the TimeZones.jl package.","category":"page"},{"location":"examples/getting-started/","page":"Getting Started","title":"Getting Started","text":"# mandatory\nusing SolarPosition\nusing Dates\n\n# supporting packages\nusing TimeZones\nusing DataFrames","category":"page"},{"location":"examples/getting-started/#Defining-a-location","page":"Getting Started","title":"Defining a location","text":"","category":"section"},{"location":"examples/getting-started/","page":"Getting Started","title":"Getting Started","text":"We can observe the sun from anywhere on earth. To define an observer location, we use the Observer struct, which takes latitude, longitude, and optionally altitude (in meters) as arguments.","category":"page"},{"location":"examples/getting-started/","page":"Getting Started","title":"Getting Started","text":"obs = Observer(52.35888, 4.88185, 100.0)  # Van Gogh Museum, Amsterdam","category":"page"},{"location":"examples/getting-started/#Computing-the-solar-vector","page":"Getting Started","title":"Computing the solar vector","text":"","category":"section"},{"location":"examples/getting-started/","page":"Getting Started","title":"Getting Started","text":"Finally, we can calculate the solar position for a specific date and time using the solar_position function. The time should be provided as a ZonedDateTime to ensure correct handling of time zones.","category":"page"},{"location":"examples/getting-started/","page":"Getting Started","title":"Getting Started","text":"tz = TimeZone(\"Europe/Brussels\")\nzdt = ZonedDateTime(2023, 6, 21, 12, 0, 0, tz)  # Summer solstice noon\nposition = solar_position(obs, zdt)","category":"page"},{"location":"examples/getting-started/#Choosing-a-Solar-Position-Algorithm","page":"Getting Started","title":"Choosing a Solar Position Algorithm","text":"","category":"section"},{"location":"examples/getting-started/","page":"Getting Started","title":"Getting Started","text":"By default, solar_position uses the PSA (Plataforma Solar de Almería) algorithm, which has a decent tradeoff between complexity and accuracy. You can choose other algorithms as described in the Solar Positioning Algorithms section.","category":"page"},{"location":"examples/getting-started/","page":"Getting Started","title":"Getting Started","text":"First, we repeat the previous calculation using the default PSA algorithm:","category":"page"},{"location":"examples/getting-started/","page":"Getting Started","title":"Getting Started","text":"position_psa = solar_position(obs, zdt, PSA())","category":"page"},{"location":"examples/getting-started/","page":"Getting Started","title":"Getting Started","text":"Next, we compute the solar position using the NOAA algorithm:","category":"page"},{"location":"examples/getting-started/","page":"Getting Started","title":"Getting Started","text":"position_noaa = solar_position(obs, zdt, NOAA())","category":"page"},{"location":"examples/getting-started/","page":"Getting Started","title":"Getting Started","text":"As you can see, the results are very similar. With a claimed accuracy of ±0.0083° for PSA and ±0.0167° for NOAA, the differences should be small:","category":"page"},{"location":"examples/getting-started/","page":"Getting Started","title":"Getting Started","text":"delta_azimuth = abs(position_psa.azimuth - position_noaa.azimuth)\ndelta_elevation = abs(position_psa.elevation - position_noaa.elevation)\nprintln(\"Difference in Azimuth: $(round(delta_azimuth, digits=4))°\")\nprintln(\"Difference in Elevation: $(round(delta_elevation, digits=4))°\")","category":"page"},{"location":"examples/getting-started/","page":"Getting Started","title":"Getting Started","text":"Whether the differences are significant depends on your application and required accuracy.","category":"page"},{"location":"examples/getting-started/#Computing-multiple-timestamps-simultaneously","page":"Getting Started","title":"Computing multiple timestamps simultaneously","text":"","category":"section"},{"location":"examples/getting-started/","page":"Getting Started","title":"Getting Started","text":"For more demanding applications, it is often necessary to compute solar positions for multiple timestamps at once. SolarPosition.jl supports this by passing a vector of ZonedDateTime or DateTime objects to the solar_position function. Here, we demonstrate this by calculating solar positions for every hour of a full year.","category":"page"},{"location":"examples/getting-started/","page":"Getting Started","title":"Getting Started","text":"# generate hourly timestamps for a whole year\ndts = collect(ZonedDateTime(DateTime(2023), tz):Hour(1):ZonedDateTime(DateTime(2024), tz))\npositions = solar_position(obs, dts)","category":"page"},{"location":"examples/getting-started/","page":"Getting Started","title":"Getting Started","text":"info: Info\nThe returned datastructure is a StructArray from the StructArrays.jl package, which behaves similarly to a vector of SolPos  structs but is more convenient to work with.","category":"page"},{"location":"examples/getting-started/","page":"Getting Started","title":"Getting Started","text":"The returned StructArray can be easily converted to a DataFrame for inspection:","category":"page"},{"location":"examples/getting-started/","page":"Getting Started","title":"Getting Started","text":"df = DataFrame(positions)\ndf.datetime = dts  # add datetime information\nfirst(df, 5)  # show first 5 entries","category":"page"},{"location":"examples/getting-started/#Broadcasting-Over-Multiple-Locations","page":"Getting Started","title":"Broadcasting Over Multiple Locations","text":"","category":"section"},{"location":"examples/getting-started/","page":"Getting Started","title":"Getting Started","text":"Thanks to Julia's broadcasting syntax it is trivial to calculate solar positions for multiple locations simultaneously. This can be useful for example when analyzing solar irradiance over a geographic region with multiple measurement stations.","category":"page"},{"location":"examples/getting-started/","page":"Getting Started","title":"Getting Started","text":"# Create observers at different latitudes\nobservers = Observer.([10.0, 20.0, 30.0], 10.0)\n\n# Calculate solar position for all locations at a specific time\ndt = DateTime(2020)\npositions_broadcast = solar_position.(observers, dt)","category":"page"},{"location":"deltat/#deltat","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"","category":"section"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"Delta T (ΔT) is the difference between Terrestrial Dynamical Time (TD) and Universal Time (UT):","category":"page"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"Delta T = TD - UT","category":"page"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"This correction is essential for accurate astronomical calculations because Earth's rotation rate is not constant. It varies due to tidal braking from the Moon, changes in Earth's moment of inertia, and other geophysical factors.","category":"page"},{"location":"deltat/#Implementation","page":"Delta T (ΔT)","title":"Implementation","text":"","category":"section"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"SolarPosition.jl implements ΔT calculation using polynomial expressions fitted to historical observations and modern measurements from atomic clocks, based on [NAS25] and [MS04]:","category":"page"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"Historical data (-500 to 1950): Based on eclipse observations\nModern era (1950-2005): Direct measurements from atomic clocks and radio observations\nFuture (2005-2050): Extrapolation based on recent trends\nFar past/future: Parabolic extrapolation formula","category":"page"},{"location":"deltat/#Usage","page":"Delta T (ΔT)","title":"Usage","text":"","category":"section"},{"location":"deltat/#SolarPosition.Positioning.calculate_deltat","page":"Delta T (ΔT)","title":"SolarPosition.Positioning.calculate_deltat","text":"calculate_deltat(year::Real, month::Real) -> Any\n\n\nCompute ΔT (Delta T), the difference between Terrestrial Dynamical Time (TD) and Universal Time (UT).\n\nΔT = TD - UT\n\nThis value is needed to convert between civil time (UT) and the uniform time scale used in astronomical calculations (TD). The value changes over time due to variations in Earth's rotation rate caused by tidal braking and other factors.\n\nArguments\n\nyear::Real: Calendar year (supports -1999 to 3000, with warnings outside this range)\nmonth::Real: Month as a real number (1-12, fractional values supported for interpolation)\n\nReturns\n\nFloat64: ΔT in seconds\n\nExamples\n\njulia> using SolarPosition.Positioning: calculate_deltat\n\njulia> calculate_deltat(2020, 6)\n71.85030032812497\n\njulia> using Dates\n\njulia> calculate_deltat(Date(2020, 6, 15))\n71.87173085145835\n\njulia> calculate_deltat(DateTime(2020, 6, 15, 12, 30))\n71.87173085145835\n\nLiterature\n\nThe polynomial expressions for ΔT are from [NAS25], based on the work by [MS04].\n\n\n\n\n\n","category":"function"},{"location":"deltat/#Examples","page":"Delta T (ΔT)","title":"Examples","text":"","category":"section"},{"location":"deltat/#Basic-Usage","page":"Delta T (ΔT)","title":"Basic Usage","text":"","category":"section"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"Calculate ΔT for a specific year and month:","category":"page"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"using SolarPosition.Positioning: calculate_deltat\n\n# Calculate ΔT for June 2020\ndt = calculate_deltat(2020, 6)\nprintln(\"ΔT ≈ $(round(dt, digits=2)) seconds\")","category":"page"},{"location":"deltat/#Using-Date-Objects","page":"Delta T (ΔT)","title":"Using Date Objects","text":"","category":"section"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"For more convenient usage with date objects:","category":"page"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"using SolarPosition.Positioning: calculate_deltat\nusing Dates\n\n# Using Date\ndate = Date(2020, 6, 15)\ndt1 = calculate_deltat(date)\n\n# Using DateTime\ndatetime = DateTime(2020, 6, 15, 12, 30, 45)\ndt2 = calculate_deltat(datetime)\n\n# Using ZonedDateTime\nusing TimeZones\nzdt = ZonedDateTime(2020, 6, 15, 12, 30, 45, tz\"UTC\")\ndt3 = calculate_deltat(zdt)\n\nprintln(\"Date: ΔT ≈ $(round(dt1, digits=2)) seconds\")\nprintln(\"DateTime: ΔT ≈ $(round(dt2, digits=2)) seconds\")\nprintln(\"ZonedDateTime: ΔT ≈ $(round(dt3, digits=2)) seconds\")","category":"page"},{"location":"deltat/#Historical-Values","page":"Delta T (ΔT)","title":"Historical Values","text":"","category":"section"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"Calculate ΔT for historical dates:","category":"page"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"using SolarPosition.Positioning: calculate_deltat\n\n# Ancient Rome (year 0)\ndt_ancient = calculate_deltat(0, 6)\nprintln(\"Year 0: ΔT ≈ $(round(dt_ancient, digits=0)) seconds\")\n\n# Early telescope era (1650)\ndt_1650 = calculate_deltat(1650, 6)\nprintln(\"Year 1650: ΔT ≈ $(round(dt_1650, digits=1)) seconds\")\n\n# Near zero around 1900\ndt_1900 = calculate_deltat(1900, 6)\nprintln(\"Year 1900: ΔT ≈ $(round(dt_1900, digits=1)) seconds\")","category":"page"},{"location":"deltat/#Plotting-Historical-Trend","page":"Delta T (ΔT)","title":"Plotting Historical Trend","text":"","category":"section"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"Visualize how ΔT has changed over time, similar to the measured values derived from telescopic observations:","category":"page"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"using SolarPosition.Positioning: calculate_deltat\nusing CairoMakie\n\n# Calculate ΔT for years 1600-2000 (historical measurements)\nyears = 1600:1:2000\ndeltat_values = [calculate_deltat(year, 6) for year in years]\n\n# Create plot with transparent background\nfig = Figure(size=(800, 500), backgroundcolor=:transparent, textcolor=\"#f5ab35\")\nax = Axis(fig[1, 1],\n    xlabel = \"Year\",\n    ylabel = \"ΔT (seconds)\",\n    title = \"Historical Values of the Earth's Clock Error\",\n    backgroundcolor=:transparent,\n    xgridvisible = false,\n    ygridvisible = false,\n    xticks = 1500:100:2000,\n    xminorticks = IntervalsBetween(5),\n    xminorticksvisible = true,\n    yminorticks = IntervalsBetween(5),\n    yminorticksvisible = true\n)\n\n# Plot the measured/calculated values\nlines!(ax, years, deltat_values,\n    linewidth=2.5,\n    color=:steelblue,\n    label=\"calculated\"\n)\n\n# Add a very long-term parabolic trend line\n# Using the formula: ΔT ≈ -20 + 32 * ((year - 1820) / 100)^2\n# This represents the parabolic trend centered around 1820-1825\ntrend_years = 1560:10:2050\ntrend_values = [-20 + 32 * ((y - 1820) / 100)^2 for y in trend_years]\nlines!(ax, trend_years, trend_values,\n    linewidth=2,\n    color=:steelblue,\n    linestyle=:dash,\n    label=\"very long-term trend\"\n)\n\naxislegend(ax, position=:lb, backgroundcolor=:transparent)\nxlims!(ax, 1500, 2000)\nylims!(ax, -50, 200)\n\nfig","category":"page"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"This plot is an attempt to reproduce the result of [MS04, Fig 1., page 329] and shows the measured values of ΔT derived from astronomical observations since 1600 CE.","category":"page"},{"location":"deltat/#Accuracy","page":"Delta T (ΔT)","title":"Accuracy","text":"","category":"section"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"The accuracy of ΔT calculations varies depending on the time period:","category":"page"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"Modern era (1950-2025): Very accurate (< 1 second)\nHistorical (1600-1950): Accurate to a few seconds\nMedieval (500-1600): Accuracy decreases to ~10-30 seconds\nAncient (< 500): Accuracy decreases significantly (~50-500 seconds)\nFuture predictions: Uncertainty increases with time","category":"page"},{"location":"deltat/","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"The uncertainty in ΔT arises because Earth's rotation is affected by unpredictable factors like atmospheric circulation, ocean currents, and tectonic events. For more details on the polynomial expressions and methodology, see [NAS25] and [MS04].","category":"page"},{"location":"examples/plotting/#plotting-examples","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"","category":"section"},{"location":"examples/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"SolarPosition.jl provides a plotting extension for Makie.jl.","category":"page"},{"location":"examples/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"To use it, simply import both the SolarPosition and Makie packages:","category":"page"},{"location":"examples/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"using SolarPosition\nusing CairoMakie\n\n# supporting packages\nusing Dates\nusing TimeZones\nusing DataFrames","category":"page"},{"location":"examples/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"This example notebook is based on the pvlib sun path example.","category":"page"},{"location":"examples/plotting/#Basic-Sun-Path-Plotting","page":"Plotting with Makie.jl","title":"Basic Sun Path Plotting","text":"","category":"section"},{"location":"examples/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"Let's start by defining an observer location and calculating solar positions for a whole year:","category":"page"},{"location":"examples/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"# Define observer location (New Delhi, India)\n# Parameters: latitude, longitude, altitude in meters\ntz = tz\"Asia/Kolkata\"\nobs = Observer(28.6, 77.2, 0.0)\n\n# Generate hourly timestamps for a whole year\ntimes = collect(ZonedDateTime(DateTime(2019), tz):Hour(1):ZonedDateTime(DateTime(2020), tz))\n\n# This returns a StructVector with solar position data\npositions = solar_position(obs, times)\n\n# For plotting, we need to create a DataFrame that includes the timestamps\ndf = DataFrame(positions)\ndf.datetime = times\n\n# We can inspect the first few entries\nfirst(df, 5)","category":"page"},{"location":"examples/plotting/#Simple-Sun-Path-Plot-in-Cartesian-Coordinates","page":"Plotting with Makie.jl","title":"Simple Sun Path Plot in Cartesian Coordinates","text":"","category":"section"},{"location":"examples/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"We can visualize solar positions in cartesian coordinates using the sunpathplot function:","category":"page"},{"location":"examples/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"fig = Figure(backgroundcolor = (:white, 0.0), textcolor= \"#f5ab35\")\nax = Axis(fig[1, 1], backgroundcolor = (:white, 0.0))\nsunpathplot!(ax, df, hour_labels = false)\nfig","category":"page"},{"location":"examples/plotting/#Polar-Coordinates-with-Hour-Labels","page":"Plotting with Makie.jl","title":"Polar Coordinates with Hour Labels","text":"","category":"section"},{"location":"examples/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"We can also work directly with a DataFrame. Note that for plotting we need to include the datetime information, so we add it to the DataFrame.","category":"page"},{"location":"examples/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"Plotting in polar coordinates with sunpathpolarplot may yield a more intuitive representation of the solar path. Here, we also enable hourly labels for better readability:","category":"page"},{"location":"examples/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"fig2 = Figure(backgroundcolor = :transparent, textcolor= \"#f5ab35\", size = (800, 600))\nax2 = PolarAxis(fig2[1, 1], backgroundcolor = \"#1f2424\")\nsunpathpolarplot!(ax2, df, hour_labels = true)\n\n# Draw individual days\nline_objects = []\nfor (date, label) in [(Date(\"2019-03-21\"), \"Mar 21\"),\n                      (Date(\"2019-06-21\"), \"Jun 21\"),\n                      (Date(\"2019-12-21\"), \"Dec 21\")]\n    times = collect(ZonedDateTime(DateTime(date), tz):Minute(5):ZonedDateTime(DateTime(date) + Day(1), tz))\n    solpos = solar_position(obs, times)\n    above_horizon = solpos.elevation .> 0\n    day_df = DataFrame(solpos)\n    day_df.datetime = times\n    day_filtered = day_df[above_horizon, :]\n    line_obj = lines!(ax2, deg2rad.(day_filtered.azimuth), day_filtered.zenith,\n                      linewidth = 2, label = label)\n    push!(line_objects, line_obj)\nend\n\n# Add legend below the plot\nfig2[2, 1] = Legend(fig2, line_objects, [\"Mar 21\", \"Jun 21\", \"Dec 21\"],\n                    orientation = :horizontal, tellheight = true, backgroundcolor = :transparent)\nfig2","category":"page"},{"location":"examples/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"The figure-8 patterns are known as analemmas, which represent the sun's position at the same time of day throughout the year.","category":"page"},{"location":"examples/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"Note that in polar coordinates, the radial distance from the center represents the zenith angle (90° - elevation). Thus, points closer to the center indicate higher elevations. Conversely, a zenith angle of more than 90° (negative elevation) indicates that the sun is below the horizon. Tracing a path from right to left corresponds to the sun's movement from east to west.","category":"page"},{"location":"examples/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"It tells us when the sun rises, reaches its highest point, and sets. And hence also the length of the day. From the figure we can also read that in June the days are longest, while in December they are shortest.","category":"page"},{"location":"examples/plotting/#Plotting-without-a-custom-axis","page":"Plotting with Makie.jl","title":"Plotting without a custom axis","text":"","category":"section"},{"location":"examples/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"Finally, we can also create plots without explicitly defining an axis beforehand. This is a more concise way to create plots, but it offers less customization:","category":"page"},{"location":"examples/plotting/","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"sunpathpolarplot(df, hour_labels = true, colorbar = true)","category":"page"},{"location":"contributing/#contributing","page":"Contributing guidelines","title":"Contributing guidelines","text":"","category":"section"},{"location":"contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"First of all, thanks for the interest!","category":"page"},{"location":"contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"We welcome all kinds of contribution, including, but not limited to code, documentation, examples, configuration, issue creating, etc.","category":"page"},{"location":"contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"Be polite and respectful.","category":"page"},{"location":"contributing/#Bug-reports-and-discussions","page":"Contributing guidelines","title":"Bug reports and discussions","text":"","category":"section"},{"location":"contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"If you think you found a bug, feel free to open an issue. Focused suggestions and requests can also be opened as issues. Before opening a pull request, start an issue or a discussion on the topic, please.","category":"page"},{"location":"contributing/#Working-on-an-issue","page":"Contributing guidelines","title":"Working on an issue","text":"","category":"section"},{"location":"contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"If you found an issue that interests you, comment on that issue what your plans are. If the solution to the issue is clear, you can immediately create a pull request (see below). Otherwise, say what your proposed solution is and wait for a discussion around it.","category":"page"},{"location":"contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"tip: Tip\nFeel free to ping us after a few days if there are no responses.","category":"page"},{"location":"reference/#reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"reference/","page":"API reference","title":"API reference","text":"This page provides comprehensive documentation for all functions and types in SolarPosition.jl.","category":"page"},{"location":"reference/#Contents","page":"API reference","title":"Contents","text":"","category":"section"},{"location":"reference/","page":"API reference","title":"API reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#Index","page":"API reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"API reference","title":"API reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#Core-Functions","page":"API reference","title":"Core Functions","text":"","category":"section"},{"location":"reference/#SolarPosition.Positioning.solar_position","page":"API reference","title":"SolarPosition.Positioning.solar_position","text":"solar_position(obs::Observer, dt::DateTime, alg::SolarAlgorithm=PSA(), refraction::RefractionAlgorithm=NoRefraction())\nsolar_position(obs::Observer, dt::ZonedDateTime, alg::SolarAlgorithm=PSA(), refraction::RefractionAlgorithm=NoRefraction())\nsolar_position(obs::Observer, dts::AbstractVector{DateTime}, alg::SolarAlgorithm=PSA(), refraction::RefractionAlgorithm=NoRefraction())\nsolar_position(obs::Observer, dts::AbstractVector{ZonedDateTime}, alg::SolarAlgorithm=PSA(), refraction::RefractionAlgorithm=NoRefraction())\n\nCalculate solar position(s) for given observer location(s) and time(s).\n\nThis function computes the solar position (azimuth, elevation, and zenith angles) based on an observer's geographic location and timestamp(s). It supports multiple input formats and automatically handles time zone conversions.\n\nArguments\n\nobs::Observer: Observer location with latitude, longitude, and altitude\ndt::DateTime or dt::ZonedDateTime: Single timestamp\ndts::AbstractVector: Vector of timestamps (DateTime or ZonedDateTime)\nalg::SolarAlgorithm: Solar positioning algorithm (default: PSA())\nrefraction::RefractionAlgorithm: Atmospheric refraction correction (default: NoRefraction())\n\nReturns\n\nFor single timestamps:\nSolPos struct when refraction = DefaultRefraction() (default)\nApparentSolPos struct when a refraction algorithm is provided\nFor multiple timestamps: StructVector of solar position data\n\n\n\nAngles Convention\n\nAll returned angles are in degrees:\n\nAzimuth: 0° = North, positive clockwise, range [-180°, 180°]\nElevation: angle above horizon, range [-90°, 90°]\nZenith: angle from zenith (90° - elevation), range [0°, 180°]\nApparent Elevation/Zenith: Only in ApparentSolPos, includes atmospheric refraction\n\n\n\nExamples\n\nSingle timestamp calculation (basic position)\n\nusing SolarPosition, Dates, TimeZones\n\n# Define observer location (San Francisco)\nobs = Observer(37.7749, -122.4194, 100.0)\n\n# Calculate position at specific time\ndt = ZonedDateTime(2023, 6, 21, 12, 0, 0, tz\"America/Los_Angeles\")\npos = solar_position(obs, dt)\n\nprintln(\"Azimuth: $(pos.azimuth)°\")\nprintln(\"Elevation: $(pos.elevation)°\")\nprintln(\"Zenith: $(pos.zenith)°\")\n\nWith refraction correction\n\n# Use a refraction algorithm (when implemented)\n# pos_apparent = solar_position(obs, dt, PSA(), MyRefractionAlg())\n# println(\"Apparent Elevation: $(pos_apparent.apparent_elevation)°\")\n\nMultiple timestamps calculation\n\n# Generate hourly timestamps for a day\ntimes = collect(DateTime(2023, 6, 21):Hour(1):DateTime(2023, 6, 22))\npositions = solar_position(obs, times)\n\n# Access as StructVector (acts like array of structs)\nprintln(\"First position: \", positions[1])\nprintln(\"All azimuths: \", positions.azimuth)\n\nUsing different algorithms\n\n# Use NOAA algorithm instead of default PSA\npos_noaa = solar_position(obs, dt, NOAA())\n\nSupported Input Types\n\nObserver: Observer{T} struct with lat/lon/altitude\nSingle time: DateTime, ZonedDateTime\nMultiple times: Vector{DateTime}, Vector{ZonedDateTime}\nAlgorithm: Any SolarAlgorithm subtype\nRefraction: Any RefractionAlgorithm subtype (default: NoRefraction())\n\nTime Zone Handling\n\nDateTime inputs are assumed to be in UTC\nZonedDateTime inputs are automatically converted to UTC\nFor local solar time calculations, use appropriate time zones\n\nPerformance Notes\n\nVectorized operations are optimized for multiple timestamps\nType-stable implementations for both Float32 and Float64\nBroadcasting-friendly for large datasets\n\nSee also: solar_position!, Observer, PSA, NOAA\n\n\n\n\n\n","category":"function"},{"location":"reference/#SolarPosition.Positioning.solar_position!","page":"API reference","title":"SolarPosition.Positioning.solar_position!","text":"solar_position!(table, obs::Observer; dt_col::Symbol=:datetime, alg::SolarAlgorithm=PSA(), refraction::RefractionAlgorithm=NoRefraction(), kwargs...)\nsolar_position!(table; latitude::AbstractFloat, longitude::AbstractFloat,\n                altitude::AbstractFloat=0.0, alg::SolarAlgorithm=PSA(), refraction::RefractionAlgorithm=NoRefraction(), kwargs...)\n\nCompute solar positions for all times in a table and add the results as new columns.\n\nArguments\n\ntable : Table-like object with datetime column (must support Tables.jl interface).\nobs::Observer : Observer location (latitude, longitude, altitude).\nlatitude, longitude, altitude : Specify observer location directly.\ndt_col::Symbol : Name of the datetime column (default: :datetime).\nalg::SolarAlgorithm : Algorithm to use (default: PSA()).\nrefraction::RefractionAlgorithm : Refraction correction (default: NoRefraction()).\nkwargs... : Additional keyword arguments forwarded to the algorithm.\n\nReturns\n\nModified table with added columns: azimuth, elevation, zenith.\nIf refraction is applied: also adds apparent_elevation, apparent_zenith.\n\nNotes\n\nThe input table is modified in-place by adding new columns.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Observer-and-Position-Types","page":"API reference","title":"Observer and Position Types","text":"","category":"section"},{"location":"reference/#SolarPosition.Positioning.Observer","page":"API reference","title":"SolarPosition.Positioning.Observer","text":"struct Observer{T<:AbstractFloat}\n\nObserver location (deg  rees, meters). Accepts a type parameter T for the floating point type to use (e.g. Float32, Float64).\n\n\n\nFields\n\nlatitude::AbstractFloat: Geodetic latitude (+N)\nlongitude::AbstractFloat: Longitude (+E)\naltitude::AbstractFloat: Altitude above mean sea level (meters)\nlatitude_rad::AbstractFloat: Latitude in radians\nlongitude_rad::AbstractFloat: Longitude in radians\nsin_lat::AbstractFloat: sin(latitude)\ncos_lat::AbstractFloat: cos(latitude)\n\n\n\n\n\n","category":"type"},{"location":"reference/#SolarPosition.Positioning.SolPos","page":"API reference","title":"SolarPosition.Positioning.SolPos","text":"struct SolPos{T} <: SolarPosition.Positioning.AbstractSolPos\n\nRepresents a single solar position calculated for a given observer and time.\n\n\n\nFields\n\nazimuth::Any: Azimuth (degrees, 0=N, +clockwise, range [-180, 180])\nelevation::Any: Elevation (degrees, range [-90, 90])\nzenith::Any: Zenith = 90 - elevation (degrees, range [0, 180])\n\n\n\n\n\n","category":"type"},{"location":"reference/#SolarPosition.Positioning.ApparentSolPos","page":"API reference","title":"SolarPosition.Positioning.ApparentSolPos","text":"struct ApparentSolPos{T} <: SolarPosition.Positioning.AbstractSolPos\n\nRepresents a single solar position calculated for a given observer and time. Also includes apparent elevation and zenith angles.\n\n\n\nFields\n\nazimuth::Any: Azimuth (degrees, 0=N, +clockwise, range [-180, 180])\nelevation::Any: Elevation (degrees, range [-90, 90])\nzenith::Any: Zenith = 90 - elevation (degrees, range [0, 180])\napparent_elevation::Any: Apparent elevation (degrees, range [-90, 90])\napparent_zenith::Any: Apparent zenith (degrees, range [0, 180])\n\n\n\n\n\n","category":"type"},{"location":"reference/#SolarPosition.Positioning.SPASolPos","page":"API reference","title":"SolarPosition.Positioning.SPASolPos","text":"struct SPASolPos{T} <: SolarPosition.Positioning.AbstractSolPos\n\nSolar position result from SPA algorithm including equation of time.\n\n\n\nFields\n\nazimuth::Any: Azimuth (degrees, 0=N, +clockwise, range [-180, 180])\nelevation::Any: Elevation (degrees, range [-90, 90])\nzenith::Any: Zenith = 90 - elevation (degrees, range [0, 180])\napparent_elevation::Any: Apparent elevation (degrees, range [-90, 90])\napparent_zenith::Any: Apparent zenith (degrees, range [0, 180])\nequation_of_time::Any: Equation of time (minutes)\n\n\n\n\n\n","category":"type"},{"location":"reference/#SolarPosition.Positioning.SPAObserver","page":"API reference","title":"SolarPosition.Positioning.SPAObserver","text":"struct SPAObserver{T<:AbstractFloat}\n\nnote: Internal Implementation\nThis is an internal optimization type not exported to users. Use Observer instead.\n\nOptimized observer type for SPA algorithm with pre-computed location-dependent values. Will cache terms that depend only on observer location to speed up calculations for multiple times at the same location.\n\nInternal Fields\n\nlatitude::AbstractFloat: Geodetic latitude (+N)\nlongitude::AbstractFloat: Longitude (+E)\naltitude::AbstractFloat: Altitude above mean sea level (meters)\nlatitude_rad::AbstractFloat: Latitude in radians\nlongitude_rad::AbstractFloat: Longitude in radians\nsin_lat::AbstractFloat: sin(latitude)\ncos_lat::AbstractFloat: cos(latitude)\nu::AbstractFloat: Cached u term for parallax (reduced latitude)\nx::AbstractFloat: Cached x term for parallax correction\ny::AbstractFloat: Cached y term for parallax correction\n\n\n\n\n\n","category":"type"},{"location":"reference/#Algorithm-Base-Types","page":"API reference","title":"Algorithm Base Types","text":"","category":"section"},{"location":"reference/","page":"API reference","title":"API reference","text":"SolarPosition.jl uses a type hierarchy for algorithms:","category":"page"},{"location":"reference/#SolarPosition.Positioning.SolarAlgorithm","page":"API reference","title":"SolarPosition.Positioning.SolarAlgorithm","text":"abstract type SolarAlgorithm\n\nAbstract base type for all solar position algorithms.\n\nAll concrete solar position algorithm types must inherit from this type.\n\nExamples\n\nstruct MyAlgorithm <: SolarAlgorithm end\n\n\n\n\n\n","category":"type"},{"location":"reference/#SolarPosition.Refraction.RefractionAlgorithm","page":"API reference","title":"SolarPosition.Refraction.RefractionAlgorithm","text":"abstract type RefractionAlgorithm\n\nAbstract base type for atmospheric refraction correction algorithms.\n\nRefraction algorithms compute the apparent position of the sun by correcting for atmospheric refraction effects.\n\nExamples\n\nstruct MyRefraction <: RefractionAlgorithm end\n\n\n\n\n\n","category":"type"},{"location":"reference/#Modules","page":"API reference","title":"Modules","text":"","category":"section"},{"location":"reference/#SolarPosition.Positioning","page":"API reference","title":"SolarPosition.Positioning","text":"Positioning\n\nThis module provides the core solar position calculation algorithms, observer location handling, and result types for SolarPosition.jl. It includes implementations of various solar position algorithms such as PSA and NOAA, with support for optional atmospheric refraction corrections.\n\nExported Types\n\nObserver: Geographic observer location\nSolPos: Basic solar position result\nApparentSolPos: Solar position with atmospheric corrections\nPSA: PSA algorithm implementation\nNOAA: NOAA algorithm implementation\nRefractionAlgorithm: Base type for refraction algorithms\nNoRefraction: No refraction correction (default)\n\nExported Functions\n\nsolar_position: Calculate solar positions\nsolar_position!: In-place solar position calculation\n\n\n\n\n\n","category":"module"},{"location":"reference/#SolarPosition.Refraction","page":"API reference","title":"SolarPosition.Refraction","text":"Refraction\n\nAtmospheric refraction models.\n\nExported Types\n\nHUGHES: Hughes atmospheric refraction model\nARCHER: Archer atmospheric refraction model\nBENNETT: Bennett atmospheric refraction model\nMICHALSKY: Michalsky atmospheric refraction model\nSG2: Saemundsson-Garfinkel atmospheric refraction model\nSPA: Solar Position Algorithm refraction model\n\nExported Functions\n\nrefraction: Apply refraction correction to elevation angle(s)\n\n\n\n\n\n","category":"module"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"#SolarPosition.jl","page":"Home","title":"SolarPosition.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Development documentation) (Image: Test workflow status) (Image: Coverage) (Image: Lint workflow Status) (Image: Docs workflow Status) (Image: Aqua QA) (Image: tested with JET.jl)","category":"page"},{"location":"","page":"Home","title":"Home","text":"SolarPosition.jl provides a simple, unified interface to a collection of validated solar position algorithms written in pure, performant julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Solar positioning algorithms are commonly used to calculate the solar zenith and azimuth angles, which are essential for various applications where the sun is important, such as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Solar energy systems\nBuilding design\nClimate studies\nAstronomy","category":"page"},{"location":"#Acknowledgement","page":"Home","title":"Acknowledgement","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is based on the work done by readers in the field of solar photovoltaics in the packages solposx and pvlib-python. In particular the positioning and refraction methods have been adapted from solposx, while the SPA algorithm and the deltat calculation are ported from pvlib-python. These packages also provide validation data necessary to ensure correctness of the algorithm implementations.","category":"page"},{"location":"#Example-Usage","page":"Home","title":"Example Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using SolarPosition, Dates\n\n# define observer location (latitude, longitude, altitude in meters)\nobs = Observer(52.35888, 4.88185, 100.0)  # Van Gogh Museum, Amsterdam\n\n# a few hours of timestamps\ntimes = collect(DateTime(2023, 6, 21, 10):Hour(1):DateTime(2023, 6, 21, 15));\n\n# compute solar positions for all timestamps\npositions = solar_position(obs, times)","category":"page"},{"location":"#Solar-positioning-algorithms","page":"Home","title":"Solar positioning algorithms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here we provide an overview of the solar positioning algorithms currently implemented in SolarPosition.jl. Each algorithm is described with its reference paper, claimed accuracy and implementation status.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Algorithm Reference Accuracy Default Refraction Status\nPSA Blanco-Muriel et al. ±0.0083° None ✅\nNOAA Global Monitoring Laboratory ±0.0167° HUGHES ✅\nWalraven Walraven, 1978 ±0.0100° None ✅\nUSNO U.S. Naval Observatory ±0.0500° None ✅\nSPA Reda & Andreas, 2004 ±0.0003° Built-in ✅","category":"page"},{"location":"#Refraction-correction-algorithms","page":"Home","title":"Refraction correction algorithms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Atmospheric refraction correction algorithms available in SolarPosition.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Algorithm Reference Atmospheric Parameters Status\nHUGHES Hughes, 1985 Pressure, Temperature ✅\nARCHER Archer et al., 1980 None ✅\nBENNETT Bennett, 1982 Pressure, Temperature ✅\nMICHALSKY Michalsky, 1988 None ✅\nSG2 Blanc & Wald, 2012 Pressure, Temperature ✅\nSPARefraction Reda & Andreas, 2004 Pressure, Temperature ✅","category":"page"},{"location":"#How-to-Cite","page":"Home","title":"How to Cite","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use SolarPosition.jl in your work, please cite using the reference given in CITATION.cff.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you want to make contributions of any kind, please first that a look into our contributing guide directly on GitHub or the contributing page on the website","category":"page"},{"location":"literature/#Literature","page":"Literature","title":"Literature","text":"","category":"section"},{"location":"literature/","page":"Literature","title":"Literature","text":"C. B. Archer, W. E. Brockett and C. A. Oakes. Collector Control System Simulation. Solar Energy Technology Conference (1980). Conference paper.\n\n\n\nG. G. Bennett. The Calculation of Astronomical Refraction in Marine Navigation. Journal of Navigation 35, 255–259 (1982).\n\n\n\nP. Blanc and L. Wald. The SG2 algorithm for a fast and accurate computation of the position of the Sun for multi-decadal time period. Solar Energy 86, 3072–3083 (2012).\n\n\n\nM. J. Blanco, K. Milidonis and A. M. Bonanos. Updating the PSA sun position algorithm. Solar Energy 212, 339–341 (2020).\n\n\n\nM. Blanco-Muriel, D. C. Alarcón-Padilla, T. López-Moratalla and M. Lara-Coira. Computing the solar vector. Solar Energy 70, 431–441 (2001).\n\n\n\nD. Haputhanthri, D. De Silva, S. Sierla, D. Alahakoon, R. Nawaratne, A. Jennings and V. Vyatkin. Solar irradiance nowcasting for virtual power plants using multimodal long short-term memory networks. Frontiers in Energy Research 9, 722212 (2021).\n\n\n\nG. W. Hughes. Engineering Astronomy (Sandia Laboratories, 1985).\n\n\n\nJ. Meeus. Astronomical Algorithms. 1st Edition (Willmann-Bell, 1991).\n\n\n\nJ. J. Michalsky. The Astronomical Almanac's algorithm for approximate solar position (1950–2050). Solar Energy 40, 227–235 (1988).\n\n\n\nL. V. Morrison and F. R. Stephenson. Historical values of the Earth's clock error DeltaT and the calculation of eclipses. Journal for the History of Astronomy 35, 327–336 (2004).\n\n\n\nI. Reda and A. Andreas. Solar position algorithm for solar radiation applications. Solar Energy 76, 577–589 (2004). Revised 2008.\n\n\n\nJ. W. Spencer. Comments on The Astronomical Almanac's Algorithm for Approximate Solar Position (1950–2050). Solar Energy 42, 353 (1989).\n\n\n\nR. Walraven. Calculating the position of the sun. Solar Energy 20, 393–397 (1978).\n\n\n\nR. Walraven. Erratum. Solar Energy 22, 195 (1979).\n\n\n\nJ. C. Zimmerman. Sun-pointing programs and their accuracy. Technical Report SAND-81-0761 (Sandia National Laboratories, 1981).\n\n\n\nNASA Goddard Space Flight Center. Polynomial Expressions for Delta T (DeltaT) (2025). Accessed: 2025-10-15.\n\n\n\nNOAA Global Monitoring Laboratory. Solar Position Calculator (2025). Accessed: 2025-10-15.\n\n\n\nU.S. Naval Observatory. Computing Altitude and Azimuth from Greenwich Apparent Sidereal Time (2025). Accessed: 2025-10-19.\n\n\n\nWikimedia Commons contributors. Atmospheric refraction: sunset and sunrise, https://upload.wikimedia.org/wikipedia/commons/3/39/Atmospheric_refraction_-_sunset_and_sunrise.png (2016). Image retrieved from Wikimedia Commons.\n\n\n\n","category":"page"},{"location":"positioning/#solar-positioning-algorithms","page":"Solar Positioning","title":"Solar Positioning","text":"","category":"section"},{"location":"positioning/","page":"Solar Positioning","title":"Solar Positioning","text":"All solar position algorithms available in SolarPosition.jl  return solar zenith, elevation, and azimuth angles. Algorithms that include an atmospheric refraction model also return “apparent” (refraction-corrected) values by default. This behavior can be modified by specifying a different refraction algorithm or passing NoRefraction no refraction correction is desired. See the Refraction Correction page for more details on refraction models.","category":"page"},{"location":"positioning/","page":"Solar Positioning","title":"Solar Positioning","text":"(Image: Solar position visualization) Figure 1: Visualization of solar position angles: azimuth and zenith. Image source: Haputhanthri et al..","category":"page"},{"location":"positioning/","page":"Solar Positioning","title":"Solar Positioning","text":"The solar azimuth angle is typically measured clockwise from true north. The solar zenith angle is the angle between the sun and the vertical direction directly overhead. The solar elevation angle is the complement of the zenith angle (i.e., elevation = 90°- zenith).","category":"page"},{"location":"positioning/","page":"Solar Positioning","title":"Solar Positioning","text":"Typically solar position algorithms can take the following set of inputs:","category":"page"},{"location":"positioning/","page":"Solar Positioning","title":"Solar Positioning","text":"Observer location: latitude, longitude, and altitude\nDate and time: in UTC or local time with timezone information\nOptional atmospheric parameters: pressure and temperature (for refraction correction)","category":"page"},{"location":"positioning/","page":"Solar Positioning","title":"Solar Positioning","text":"As an example, we plot the longest day of the year solar path for an observer located at the Van Gogh museum in Amsterdam (52.35888°N, 4.88185°E) on June 21, 2023:","category":"page"},{"location":"positioning/","page":"Solar Positioning","title":"Solar Positioning","text":"\nusing SolarPosition, Dates, CairoMakie\n\n# define observer location (latitude, longitude, altitude in meters)\nobs = Observer(52.35888, 4.88185, 100.0)  # Van Gogh Museum, Amsterdam\ntimes = collect(DateTime(2023, 6, 21, 0):Minute(5):DateTime(2023, 6, 21, 23, 55));\npositions = solar_position(obs, times, PSA(), HUGHES());\n\n# plot elevation and azimuth over the day\nfig = Figure(backgroundcolor = :transparent, textcolor= \"#f5ab35\", size = (800, 400))\nax1 = Axis(fig[1, 1], xlabel = \"Time (hours)\", ylabel = \"Elevation (degrees)\",\n    title = \"Solar Elevation on June 21, 2023 - Amsterdam\", backgroundcolor = :transparent,\n    xticks = 0:3:24)\nax2 = Axis(fig[1, 2], xlabel = \"Time (hours)\", ylabel = \"Azimuth (degrees)\",\n    title = \"Solar Azimuth on June 21, 2023 - Amsterdam\", backgroundcolor = :transparent,\n    xticks = 0:3:24)\ntimes_hours = [Dates.hour(t) + Dates.minute(t)/60 for t in times]\nlines!(ax1, times_hours, positions.elevation, color = \"#f5ab35\")\nlines!(ax2, times_hours, positions.azimuth, color = \"#f5ab35\")\nfig","category":"page"},{"location":"positioning/#Available-Algorithms","page":"Solar Positioning","title":"Available Algorithms","text":"","category":"section"},{"location":"positioning/","page":"Solar Positioning","title":"Solar Positioning","text":"The following solar position algorithms are currently implemented in SolarPosition.jl:","category":"page"},{"location":"positioning/","page":"Solar Positioning","title":"Solar Positioning","text":"Algorithm Reference Accuracy Default Refraction Status\nPSA [BALL01] ±0.0083° None ✅\nNOAA [NOA25] ±0.0167° HUGHES ✅\nWalraven [Wal78] ±0.0100° None ✅\nUSNO [U.S25] ±0.0500° None ✅\nSPA [RA04] ±0.0003° Built-in ✅","category":"page"},{"location":"positioning/#psa-algorithm","page":"Solar Positioning","title":"PSA","text":"","category":"section"},{"location":"positioning/","page":"Solar Positioning","title":"Solar Positioning","text":"The PSA (Plataforma Solar de Almería) algorithm is the default high-accuracy solar position algorithm.","category":"page"},{"location":"positioning/","page":"Solar Positioning","title":"Solar Positioning","text":"The algorithm was originally published by [BALL01] and was later updated by [BMB20] with new coefficients for improved accuracy.","category":"page"},{"location":"positioning/#SolarPosition.Positioning.PSA","page":"Solar Positioning","title":"SolarPosition.Positioning.PSA","text":"struct PSA <: SolarPosition.Positioning.SolarAlgorithm\n\nPSA (Plataforma Solar de Almería) solar position algorithm. This algorithm computes the solar position with high accuracy using empirical coefficients. Two coefficient sets are available: 2001 (range 1999-2015) and 2020 (range 2020-2050).\n\nAccuracy\n\nClaimed accuracy: ±0.004° for 2020 coefficients, ±0.01° for 2001 coefficients.\n\nLiterature\n\nThis algorithm is based on the work by [BALL01] and was updated for 2020 coefficients in [BMB20].\n\nFields\n\ncoeffs::Int64: Coefficient set year (2001 or 2020)\n\n\n\n\n\n","category":"type"},{"location":"positioning/#noaa-algorithm","page":"Solar Positioning","title":"NOAA","text":"","category":"section"},{"location":"positioning/","page":"Solar Positioning","title":"Solar Positioning","text":"The NOAA (National Oceanic and Atmospheric Administration) algorithm provides an alternative implementation based on [NOA25].","category":"page"},{"location":"positioning/#SolarPosition.Positioning.NOAA","page":"Solar Positioning","title":"SolarPosition.Positioning.NOAA","text":"struct NOAA <: SolarPosition.Positioning.SolarAlgorithm\n\nNOAA (National Oceanic and Atmospheric Administration) solar position algorithm. This algorithm is based on NOAA's Solar Position Calculator implementation. The algorithm is from \"Astronomical Algorithms\" by Jean Meeus.\n\nBy default, the NOAA algorithm uses the HUGHES atmospheric refraction model which is in accordance with the NOAA solar position calculator.\n\nAccuracy\n\nClaimed accuracy: ±0.0167° from years -2000 to +3000 for latitudes within ±72°. For latitudes outside this range, the accuracy is ±0.167°.\n\nLiterature\n\nBased on the NOAA solar position calculator [NOA25] and the work by [Mee91].\n\nFields\n\ndelta_t::Union{Nothing, Float64}: Difference between terrestrial time and UT1 [seconds]. If nothing, uses automatic calculation.\n\n\n\n\n\n","category":"type"},{"location":"positioning/#walraven-algorithm","page":"Solar Positioning","title":"Walraven","text":"","category":"section"},{"location":"positioning/","page":"Solar Positioning","title":"Solar Positioning","text":"The Walraven algorithm is a solar position algorithm published in 1978 with stated accuracy of ±0.0100°.","category":"page"},{"location":"positioning/","page":"Solar Positioning","title":"Solar Positioning","text":"The algorithm was originally published by [Wal78] with corrections from the 1979 Erratum [Wal79] and azimuth quadrant correction from [Spe89].","category":"page"},{"location":"positioning/#SolarPosition.Positioning.Walraven","page":"Solar Positioning","title":"SolarPosition.Positioning.Walraven","text":"struct Walraven <: SolarPosition.Positioning.SolarAlgorithm\n\nWalraven solar position algorithm. The implementation accounts for the 1979 Erratum and correct azimuth quadrant selection.\n\nAccuracy\n\nClaimed accuracy is ±0.0100°.\n\nLiterature\n\nThis algorithm is based on [Wal78] with corrections from the 1979 Erratum [Wal79] and azimuth quadrant correction from [Spe89].\n\n\n\n\n\n","category":"type"},{"location":"positioning/#usno-algorithm","page":"Solar Positioning","title":"USNO","text":"","category":"section"},{"location":"positioning/","page":"Solar Positioning","title":"Solar Positioning","text":"The USNO (U.S. Naval Observatory) algorithm provides solar position calculations based on formulas from the USNO's Astronomical Applications Department.","category":"page"},{"location":"positioning/","page":"Solar Positioning","title":"Solar Positioning","text":"The algorithm offers two options for calculating Greenwich mean sidereal time, providing flexibility for different accuracy requirements.","category":"page"},{"location":"positioning/#SolarPosition.Positioning.USNO","page":"Solar Positioning","title":"SolarPosition.Positioning.USNO","text":"struct USNO <: SolarPosition.Positioning.SolarAlgorithm\n\nUSNO (U.S. Naval Observatory) solar position algorithm. This algorithm provides solar position calculations based on the USNO's Astronomical Applications Department formulas.\n\nAccuracy\n\nThe accuracy is typically within a few arcminutes for most practical applications. This algorithm is suitable for general-purpose solar position calculations.\n\nLiterature\n\nThe U.S. Naval Observatory (USNO) algorithm is provided in [U.S25].\n\nFields\n\ndelta_t::Union{Nothing, Float64}: Difference between terrestrial time and UT1 [seconds]. If nothing, uses automatic calculation.\ngmst_option::Int64: Option for calculating Greenwich mean sidereal time (1 or 2)\n\n\n\n\n\n","category":"type"},{"location":"positioning/#spa-algorithm","page":"Solar Positioning","title":"SPA","text":"","category":"section"},{"location":"positioning/","page":"Solar Positioning","title":"Solar Positioning","text":"The SPA (Solar Position Algorithm) is the highest-accuracy algorithm available in this package, with uncertainty of ±0.0003° for years between -2000 and 6000.","category":"page"},{"location":"positioning/","page":"Solar Positioning","title":"Solar Positioning","text":"The algorithm was published by the National Renewable Energy Laboratory (NREL) in [RA04] and implements a complete heliocentric, geocentric, and topocentric solar position calculation with periodic terms for Earth heliocentric longitude and latitude.","category":"page"},{"location":"positioning/#SolarPosition.Positioning.SPA","page":"Solar Positioning","title":"SolarPosition.Positioning.SPA","text":"struct SPA <: SolarPosition.Positioning.SolarAlgorithm\n\nSPA (Solar Position Algorithm) from NREL. This is the most accurate algorithm for solar position calculation, suitable for high-precision applications.\n\nThe algorithm implements the complete NREL Solar Position Algorithm as described in Reda and Andreas (2004, 2007). It accounts for:\n\nHeliocentric position of Earth\nNutation and aberration\nGeocentric and topocentric corrections\nAtmospheric refraction\nParallax effects\n\nAccuracy\n\nClaimed accuracy: ±0.0003° (±1 arcsecond) for years -2000 to 6000.\n\nLiterature\n\nThis algorithm is based on [RA04] with corrections from the 2007 corrigendum.\n\nFields\n\ndelta_t::Union{Nothing, Float64}: Difference between terrestrial time and UT1 [seconds]. If nothing, uses automatic calculation.\npressure::Float64: Annual average air pressure [Pa]\ntemperature::Float64: Annual average air temperature [°C]\natmos_refract::Float64: Approximate atmospheric refraction at sunrise/sunset [degrees]\n\n\n\n\n\n","category":"type"}]
}
