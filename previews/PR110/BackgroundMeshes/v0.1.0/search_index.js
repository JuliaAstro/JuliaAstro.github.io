var documenterSearchIndex = {"docs":
[{"location":"examples/2_background_estimation/#2.-Background-Estimation-on-Real-Data","page":"2. Background Estimation on Real Data","title":"2. Background Estimation on Real Data","text":"","category":"section"},{"location":"examples/2_background_estimation/","page":"2. Background Estimation on Real Data","title":"2. Background Estimation on Real Data","text":"Estimating backgrounds is an important step in performing photometry. Ideally, we could perfectly describe the background with a scalar value or with some distribution. Unfortunately, it's impossible for us to precisely separate the background and foreground signals. Here, we use mixture of robust statistical estimators and meshing to let us get the spatially varying background from an astronomical photo.","category":"page"},{"location":"examples/2_background_estimation/","page":"2. Background Estimation on Real Data","title":"2. Background Estimation on Real Data","text":"Let's show an example:","category":"page"},{"location":"examples/2_background_estimation/","page":"2. Background Estimation on Real Data","title":"2. Background Estimation on Real Data","text":"using AstroImages\nusing BackgroundMeshes\nusing FITSIO\nusing Plots\n\n# Download our image, courtesy of astropy\nurl = \"https://rawcdn.githack.com/astropy/photutils-datasets/8c97b4fa3a6c9e6ea072faeed2d49a20585658ba/data/M6707HH.fits\"\nhdu = FITS(download(url))\nimage = read(hdu[1])\n\n# Plot\nfunction imshow(image; kwargs...)\n    xs, ys = axes(image)\n    data = transpose(image)\n    heatmap(xs, ys, data;\n        aspect_ratio = 1,\n        xlim = extrema(xs),\n        ylim = extrema(ys),\n        kwargs...\n    )\nend\n\nimshow(image)","category":"page"},{"location":"examples/2_background_estimation/","page":"2. Background Estimation on Real Data","title":"2. Background Estimation on Real Data","text":"Now let's try and estimate the background using estimate_background. First, we'll sigma-clip to try and remove the signals from the stars. Then, the background is broken down into boxes, in this case of size (50, 50). Within each box, the given statistical estimators get the background value and RMS. By default, we use SourceExtractorBackground and StdRMS. This creates a low-resolution image, which we then need to resize. We can accomplish this using an interpolator, by default a cubic-spline interpolator via ZoomInterpolator. The end result is a smooth estimate of the spatially varying background and background RMS.","category":"page"},{"location":"examples/2_background_estimation/","page":"2. Background Estimation on Real Data","title":"2. Background Estimation on Real Data","text":"# Sigma-clip\nclipped = sigma_clip(image, 1; fill=NaN)\n\n# Get background and background rms with box-size (50, 50)\nbkg, bkg_rms = estimate_background(clipped, 50)\n\n# Plot\nplot(\n    imshow(image; title=\"Original\"),\n    imshow(clipped; title=\"Sigma-Clipped\"),\n    imshow(bkg; title=\"Background\"),\n    imshow(bkg_rms; title=\"Background RMS\");\n    layout = (2, 2),\n    ticks = false,\n)","category":"page"},{"location":"examples/2_background_estimation/","page":"2. Background Estimation on Real Data","title":"2. Background Estimation on Real Data","text":"We could apply a median filter, too, by specifying filter_size:","category":"page"},{"location":"examples/2_background_estimation/","page":"2. Background Estimation on Real Data","title":"2. Background Estimation on Real Data","text":"# Get background and background rms with box-size (50, 50) and filter_size (5, 5)\nbkg_f, bkg_rms_f = estimate_background(clipped, 50; filter_size = 5)\n\n# Plot\nplot(\n    imshow(bkg; title=\"Unfiltered\", ylabel=\"Background\"),\n    imshow(bkg_f; title=\"Filtered\"),\n    imshow(bkg_rms; ylabel=\"RMS\"),\n    imshow(bkg_rms_f);\n    layout = (2, 2),\n    ticks = false,\n)","category":"page"},{"location":"examples/2_background_estimation/","page":"2. Background Estimation on Real Data","title":"2. Background Estimation on Real Data","text":"Now we can see our image after subtracting the filtered background and ready for further analysis!","category":"page"},{"location":"examples/2_background_estimation/","page":"2. Background Estimation on Real Data","title":"2. Background Estimation on Real Data","text":"subt = image .- bkg_f[axes(image)...]\n\n# Plot\nplot(\n    imshow(image; title=\"Original\", colorbar=false),\n    imshow(subt; title=\"Subtracted\");\n    layout = (1, 2),\n    size = (600, 260),\n    xlims = (400, 800),\n    ylims = ( 400, 800),\n    clims = (minimum(subt), maximum(image)),\n    ticks = false,\n    aspect_ratio = 1,\n)","category":"page"},{"location":"examples/2_background_estimation/#IDW-Interpolator","page":"2. Background Estimation on Real Data","title":"IDW Interpolator","text":"","category":"section"},{"location":"examples/2_background_estimation/","page":"2. Background Estimation on Real Data","title":"2. Background Estimation on Real Data","text":"Here is a quick example using the IDWInterpolator:","category":"page"},{"location":"examples/2_background_estimation/","page":"2. Background Estimation on Real Data","title":"2. Background Estimation on Real Data","text":"b1, r1 = estimate_background(clipped, 50; filter_size=5)\nb2, r2 = estimate_background(clipped, 50; itp=IDWInterpolator(50), filter_size=5)\n\n# Plot\nplot(\n    imshow(b1; title=\"ZoomInterpolator\", ylabel=\"Background\"),\n    imshow(b2; title=\"IDWInterpolator\"),\n    imshow(r1; ylabel=\"RMS\"),\n    imshow(r2);\n    layout = (2, 2),\n    ticks = false,\n)","category":"page"},{"location":"api/#API/Reference","page":"API/Reference","title":"API/Reference","text":"","category":"section"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"","category":"page"},{"location":"api/#General","page":"API/Reference","title":"General","text":"","category":"section"},{"location":"api/#BackgroundMeshes.estimate_background","page":"API/Reference","title":"BackgroundMeshes.estimate_background","text":"estimate_background(data;\n    location=SourceExtractorBackground(),\n    rms=StdRMS(),\n    dims=:)\n\nPerform scalar background estimation using the given estimators.\n\nThe value returned will be two values corresponding to the estimated background and the estimated background RMS. The dimensionality will depend on the dims keyword.\n\nlocation and rms can be anything that is callable, for example median, or one of the estimators we provide in Background Estimators.\n\nExamples\n\njulia> data = ones(3, 5);\n\njulia> bkg, bkg_rms = estimate_background(data)\n(1.0, 0.0)\n\njulia> using Statistics: median\n\njulia> bkg, bkg_rms = estimate_background(data; location=median, rms=MADStdRMS())\n(1.0, 0.0)\n\nSee Also\n\nLocation Estimators, RMS Estimators\n\n\n\n\n\nestimate_background(data, box_size;\n    location=SourceExtractorBackground(),\n    rms=StdRMS(),\n    itp=ZoomInterpolator(box_size),\n    edge_method=:pad,\n    [filter_size])\n\nPerform 2D background estimation using the given estimators mapped over windows of the data..\n\nThis function will estimate backgrounds in boxes of size box_size. When size(data) is not an integer multiple of the box size, there are two edge methods: :pad and :crop. The default is to pad (and is recommend to avoid losing image data). If box_size is an integer, the implicit shape will be square (eg. box_size=4 is equivalent to box_size=(4,4)).\n\nFor evaluating the meshes, each box will be passed into location to estimate the background and then into rms to estimate the background root-mean-square value. These can be anything that is callable, like median or one of our Background Estimators.\n\nOnce the meshes are created they will be median filtered if filter_size is given. filter_size can be either an integer or a tuple, with the integer being converted to a tuple the same way box_size is. Filtering is done via ImageFiltering.MapWindow.mapwindow. filter_size must be odd.\n\nAfter filtering (if applicable), the meshes are passed to the itp to recreate a low-order estimate of the background at the same resolution as the input.\n\nnote: Note\nIf your box_size is not an integer multiple of the input size, the output background and rms arrays will not have the same size.\n\nSee Also\n\nLocation Estimators, RMS Estimators, Interpolators\n\n\n\n\n\n","category":"function"},{"location":"api/#BackgroundMeshes.sigma_clip","page":"API/Reference","title":"BackgroundMeshes.sigma_clip","text":"sigma_clip(x, sigma; fill=:clamp, center=median(x), std=std(x, corrected=false))\nsigma_clip(x, sigma_low, sigma_high; fill=:clamp, center=median(x), std=std(x, corrected=false))\n\nThis function returns sigma-clipped values of the input x.\n\nSpecify the upper and lower bounds with sigma_low and sigma_high, otherwise assume they are equal. center and std are optional keyword arguments which are functions for finding central element and standard deviation.\n\nIf fill === :clamp, this will clamp values in x lower than center - sigma_low * std and values higher than center + sigma_high * std. Otherwise, they will be replaced with fill.\n\nExamples\n\njulia> x = randn(rng, 100_000); # rng is a pre-defined generator for reproducibility\n\njulia> extrema(x)\n(-4.308034628060624, 4.082248634424802)\n\n\njulia> x_clip = sigma_clip(x, 1);\n\njulia> extrema(x_clip) # should be close to (-1, 1)\n(-0.9912911763341569, 1.0077955853440512)\n\n\n\n\n\n","category":"function"},{"location":"api/#BackgroundMeshes.sigma_clip!","page":"API/Reference","title":"BackgroundMeshes.sigma_clip!","text":"sigma_clip!(x, sigma; fill=:clamp, center=median(x), std=std(x))\nsigma_clip!(x, sigma_low, sigma_high; fill=:clamp, center=median(x), std=std(x))\n\nIn-place version of sigma_clip\n\nwarning: Warning\nsigma_clip! mutates the element in place and mutation cannot lead to change in type. Please be considerate of your input type, because if you are using Int64 and we try to clip it to 0.5 an InexactError will be thrown.To avoid this, we recommend converting to float before clipping, or using sigma_clip which does this internally.\n\n\n\n\n\n","category":"function"},{"location":"api/#Background-Estimators","page":"API/Reference","title":"Background Estimators","text":"","category":"section"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"All of these estimators are subtypes of BackgroundMeshes.LocationEstimator or BackgroundMeshes.RMSEstimator and are derived using various statistical and image processing methods.","category":"page"},{"location":"api/#Location-Estimators-API","page":"API/Reference","title":"Location Estimators","text":"","category":"section"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"These estimators are used for estimating the background using some form of a central statistic.","category":"page"},{"location":"api/#BackgroundMeshes.LocationEstimator","page":"API/Reference","title":"BackgroundMeshes.LocationEstimator","text":"BackgroundMeshes.LocationEstimator\n\nThis abstract type embodies the possible background estimation algorithms for dispatch with estimate_background.\n\nTo implement a new estimator, you must define the struct and define a method like (::MyEstimator)(data::AbstractArray; dims=:).\n\nSee Also\n\nLocation Estimators\n\n\n\n\n\n","category":"type"},{"location":"api/#BackgroundMeshes.MMMBackground","page":"API/Reference","title":"BackgroundMeshes.MMMBackground","text":"MMMBackground(median_factor=3, mean_factor=2)\n\nEstimate the background using a mode estimator of the form median_factor * median - mean_factor * mean. This algorithm is based on the MMMBackground routine originally implemented in DAOPHOT. MMMBackground uses factors of median_factor=3 and mean_factor=2 by default. This estimator assumes that contaminated sky pixel values overwhelmingly display positive departures from the true value.\n\nExamples\n\njulia> x = ones(3, 5);\n\njulia> MMMBackground()(x)\n1.0\n\njulia> MMMBackground(median_factor=4, mean_factor=3)(x, dims = 1)\n1×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0\n\nSee Also\n\nSourceExtractorBackground\n\n\n\n\n\n","category":"type"},{"location":"api/#BackgroundMeshes.SourceExtractorBackground","page":"API/Reference","title":"BackgroundMeshes.SourceExtractorBackground","text":"SourceExtractorBackground()\n\nThis estimator returns the background of the input using the SourceExtractorBackground algorithm.\n\nThe background is calculated using a mode estimator of the form (2.5 * median) - (1.5 * mean).\n\nIf (mean - median) / std > 0.3 then the median is used and if std = 0 then the mean is used.\n\nExamples\n\njulia> data = ones(3, 5);\n\njulia> SourceExtractorBackground()(data)\n1.0\n\njulia> SourceExtractorBackground()(data, dims=1)\n1×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"api/#BackgroundMeshes.BiweightLocationBackground","page":"API/Reference","title":"BackgroundMeshes.BiweightLocationBackground","text":"BiweightLocationBackground(c = 6.0, M = nothing)\n\nEstimate the background using the robust biweight location statistic.\n\nSee BiweightStats.jl for more information.\n\nExamples\n\njulia> x = ones(3,5);\n\njulia> BiweightLocationBackground()(x)\n1.0\n\njulia> BiweightLocationBackground(c=5.5)(x; dims = 1)\n1×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"api/#RMS-Estimators-API","page":"API/Reference","title":"RMS Estimators","text":"","category":"section"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"These estimators are used for estimating the root-mean-square (RMS) of the background using some form of a deviation statistic.","category":"page"},{"location":"api/#BackgroundMeshes.RMSEstimator","page":"API/Reference","title":"BackgroundMeshes.RMSEstimator","text":"BackgroundMeshes.RMSEstimator\n\nThis abstract type embodies the possible background RMS estimation algorithms for dispatch with estimate_background.\n\nTo implement a new estimator, you must define the struct and define a method like (::MyRMSEstimator)(data::AbstractArray; dims=:).\n\nSee Also\n\nRMS Estimators\n\n\n\n\n\n","category":"type"},{"location":"api/#BackgroundMeshes.StdRMS","page":"API/Reference","title":"BackgroundMeshes.StdRMS","text":"StdRMS()\n\nUses the standard deviation statistic for background RMS estimation.\n\nExamples\n\njulia> data = ones(3, 5);\n\njulia> StdRMS()(data)\n0.0\n\njulia> StdRMS()(data, dims=1)\n1×5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0\n\n\n\n\n\n","category":"type"},{"location":"api/#BackgroundMeshes.MADStdRMS","page":"API/Reference","title":"BackgroundMeshes.MADStdRMS","text":"MADStdRMS()\n\nUses the standard median absolute deviation (MAD) statistic for background RMS estimation.\n\nThis is typically given as\n\nsigma approx 14826 cdot textMAD\n\nExamples\n\njulia> data = ones(3, 5);\n\njulia> MADStdRMS()(data)\n0.0\n\njulia> MADStdRMS()(data, dims=1)\n1×5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0\n\n\n\n\n\n","category":"type"},{"location":"api/#BackgroundMeshes.BiweightScaleRMS","page":"API/Reference","title":"BackgroundMeshes.BiweightScaleRMS","text":"BiweightScaleRMS(c=9.0, M=nothing)\n\nUses the robust biweight scale statistic for background RMS estimation.\n\nThe biweight scale is the square root of the biweight midvariance. The biweight midvariance uses a tuning constant, c, and an optional initial guess of the central value M.\n\nSee BiweightStats.jl for more information.\n\nExamples\n\njulia> data = ones(3, 5);\n\njulia> BiweightScaleRMS()(data)\n0.0\n\njulia> BiweightScaleRMS(c=3.0)(data, dims=1)\n1×5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0\n\n\n\n\n\n","category":"type"},{"location":"api/#Background-Interpolators","page":"API/Reference","title":"Background Interpolators","text":"","category":"section"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"Background interpolators provide a method for converting a low-resolution mesh into a low-order high-resolution image.","category":"page"},{"location":"api/#BackgroundMeshes.BackgroundInterpolator","page":"API/Reference","title":"BackgroundMeshes.BackgroundInterpolator","text":"BackgroundInterpolator\n\nThis abstract type embodies the different ways of converting a low-resolution mesh into a high-resolution image, especially for dispatch with estimate_background\n\nTo implement a new interpolation scheme, you must define the struct and define a method like (::MyInterpolator)(mesh)\n\nSee Also\n\nInterpolators\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolators","page":"API/Reference","title":"Interpolators","text":"","category":"section"},{"location":"api/#BackgroundMeshes.ZoomInterpolator","page":"API/Reference","title":"BackgroundMeshes.ZoomInterpolator","text":"ZoomInterpolator(factors)\n\nUse a cubic-spline interpolation scheme to increase resolution of a mesh.\n\nfactors represents the level of \"zoom\", so an input mesh of size (10, 10) with factors (2, 2) will have an output size of (20, 20). If only an integer is provided, it will be used as the factor for every axis.\n\nExamples\n\njulia> ZoomInterpolator(2)([1 0; 0 1])\n4×4 Matrix{Float64}:\n  1.0          0.75   0.25   -2.77556e-17\n  0.75         0.625  0.375   0.25\n  0.25         0.375  0.625   0.75\n -5.55112e-17  0.25   0.75    1.0\n\njulia> ZoomInterpolator(3, 1)([1 0; 0 1])\n6×2 Matrix{Float64}:\n  1.0          -2.77556e-17\n  1.0          -2.77556e-17\n  0.666667      0.333333\n  0.333333      0.666667\n -5.55112e-17   1.0\n -5.55112e-17   1.0\n\n\n\n\n\n\n","category":"type"},{"location":"api/#BackgroundMeshes.IDWInterpolator","page":"API/Reference","title":"BackgroundMeshes.IDWInterpolator","text":"IDWInterpolator(factors; leafsize=10, k=8, power=1, reg=0, conf_dist=1e-12)\n\nUse Shepard Inverse Distance Weighing interpolation scheme to increase resolution of a mesh.\n\nfactors represents the level of \"zoom\", so an input mesh of size (10, 10) with factors (2, 2) will have an output size of (20, 20). If only an integer is provided, it will be used as the factor for every axis.\n\nThe interpolator can be called with some additional parameters:\n\nleaf_size determines at what number of points to stop splitting the tree further,\nk which is the number of nearest neighbors to be considered,\npower is the exponent for distance in the weighing factor,\nreg is the offset for the weighing factor in denominator,\nconf_dist is the distance below which two points would be considered as the same point.\n\nExamples\n\njulia> IDWInterpolator(2, k=2)([1 0; 0 1])\n4×4 Matrix{Float64}:\n 1.0   0.75      0.25      0.0\n 0.75  0.690983  0.309017  0.25\n 0.25  0.309017  0.690983  0.75\n 0.0   0.25      0.75      1.0\n\njulia> IDWInterpolator(3, 1; k=2, power=4)([1 0; 0 1])\n6×2 Matrix{Float64}:\n 1.0        0.0\n 1.0        0.0\n 0.941176   0.0588235\n 0.0588235  0.941176\n 0.0        1.0\n 0.0        1.0\n\n\n\n\n\n","category":"type"},{"location":"examples/1_basics/#1.-Basics","page":"1. Basics","title":"1. Basics","text":"","category":"section"},{"location":"examples/1_basics/","page":"1. Basics","title":"1. Basics","text":"Let's dig into the basics of how these background meshes work. Let's start by creating some data. For this image, we'll create a 2-D polynomial gradient across a 1000x1000 image:","category":"page"},{"location":"examples/1_basics/","page":"1. Basics","title":"1. Basics","text":"using AstroImages\nusing BackgroundMeshes\nusing Random\nusing Statistics\nusing Plots\nrng = Random.seed!(125512)\n\nxs = range(0, 1; length=1000)\nys = xs'\ndata = xs .* ys\nimplot(data)","category":"page"},{"location":"examples/1_basics/#Mesh-size","page":"1. Basics","title":"Mesh size","text":"","category":"section"},{"location":"examples/1_basics/","page":"1. Basics","title":"1. Basics","text":"Background meshes are defined by a grid of sub-images across the original data. Within these sub-images we use various statistics to estimate the background signal. Here we show directly how the sub-image size (i.e., mesh size) affects the background estimation:","category":"page"},{"location":"examples/1_basics/","page":"1. Basics","title":"1. Basics","text":"box_sizes = (10, 50, 100)\nbackgrounds = map(n -> first(estimate_background(data, n; location=mean)), box_sizes)\nplot(\n    implot(backgrounds[1]; title=\"N=10\", cbar=false),\n    implot(backgrounds[2]; title=\"N=50\", cbar=false),\n    implot(backgrounds[3]; title=\"N=100\", cbar=false);\n    layout=(1, 3),\n)","category":"page"},{"location":"examples/1_basics/#Location-Estimators","page":"1. Basics","title":"Location Estimators","text":"","category":"section"},{"location":"examples/1_basics/","page":"1. Basics","title":"1. Basics","text":"As mentioned above, statistics are calculated inside each of the sub-images. Depending on your workflow and data quality, you can choose between a variety of estimators:","category":"page"},{"location":"examples/1_basics/","page":"1. Basics","title":"1. Basics","text":"mean or median from Statistics\nSourceExtractorBackground\nMMMBackground\nBiweightLocationBackground","category":"page"},{"location":"examples/1_basics/","page":"1. Basics","title":"1. Basics","text":"See the LocationEstimator docs for more information about each estimator. Let's create some data with outliers and look at how each estimator handles the outliers:","category":"page"},{"location":"examples/1_basics/","page":"1. Basics","title":"1. Basics","text":"true_background = 10\nsub_img = randn(rng, 100, 100) .+ true_background\n\n# Add in hot pixels\nx_idxs = rand(rng, axes(sub_img, 1), 50)\ny_idxs = rand(rng, axes(sub_img, 2), 50)\nfor (x, y) in zip(x_idxs, y_idxs)\n    sub_img[x, y] = 2^16\nend\n\nimplot(sub_img; clims=zscale(sub_img))","category":"page"},{"location":"examples/1_basics/","page":"1. Basics","title":"1. Basics","text":"Let's see how each estimator compares:","category":"page"},{"location":"examples/1_basics/","page":"1. Basics","title":"1. Basics","text":"bkgs = [\n    \"mean\" => mean(sub_img),\n    \"median\" => median(sub_img),\n    \"source extractor\" => SourceExtractorBackground()(sub_img),\n    \"MMM\" => MMMBackground()(sub_img),\n    \"biweight location\" => BiweightLocationBackground()(sub_img),\n]\nscatter(first.(bkgs), last.(bkgs); lab=\"\")\nhline!([true_background]; c=:black, ls=:dash, lab=\"true value\")","category":"page"},{"location":"examples/1_basics/","page":"1. Basics","title":"1. Basics","text":"Here we see that median and BiweightLocationBackground do a good job of estimating the background despite the outliers, however the outliers can be removed ahead of time with a tool like LACosmic.jl.","category":"page"},{"location":"examples/1_basics/#RMS-Estimators","page":"1. Basics","title":"RMS Estimators","text":"","category":"section"},{"location":"examples/1_basics/","page":"1. Basics","title":"1. Basics","text":"Within each sub-image we also calulate the root-mean-square (RMS) estimate of noise, which can be forward propagated in your analysis.","category":"page"},{"location":"examples/1_basics/","page":"1. Basics","title":"1. Basics","text":"StdRMS\nMADStdRMS\nBiweightScaleRMS","category":"page"},{"location":"examples/1_basics/","page":"1. Basics","title":"1. Basics","text":"See the RMSEstimator docs for more information about each estimator. Let's create some data with outliers and look at how each estimator handles the outliers:","category":"page"},{"location":"examples/1_basics/","page":"1. Basics","title":"1. Basics","text":"# Use same data before N(10, 1)\ntrue_rms = 1\nrmss = [\n    \"std\" => StdRMS()(sub_img),\n    \"MAD\" => MADStdRMS()(sub_img),\n    \"biweight scale\" => BiweightScaleRMS()(sub_img),\n]\nscatter(first.(rmss), last.(rmss); lab=\"\")\nhline!([true_rms]; c=:black, ls=:dash, lab=\"true value\")","category":"page"},{"location":"examples/1_basics/","page":"1. Basics","title":"1. Basics","text":"Again, we see the median-based MADStdRMS as well as the BiweightScaleRMS do well despite the outliers.","category":"page"},{"location":"#BackgroundMeshes.jl","page":"Home","title":"BackgroundMeshes.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Code) (Image: Stable) (Image: Dev)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: CI) (Image: Coverage) (Image: License)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Create meshes for estimating the background in astronomical images. Originally a submodule of Photometry.jl.","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently, this package is unregistered and must be installed directly from this repository using the built-in package manager","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]\n# Or, using Pkg; Pkg.add(url = \"https://github.com/JuliaAstro/BackgroundMeshes.jl\")\npkg> add https://github.com/JuliaAstro/BackgroundMeshes.jl\njulia> using BackgroundMeshes","category":"page"},{"location":"#Contributing-and-Support","page":"Home","title":"Contributing and Support","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you would like to contribute, feel free to open a pull request. If you want to discuss something before contributing, head over to discussions and join or open a new topic. If you're having problems with something, please open an issue.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The work derived from astropy/photutils is BSD 3-clause. All other work uses the MIT license. Therefore, this work as a whole is BSD 3-clause. LICENSE contains all licenses and any files using derived work are noted at the top of the file.","category":"page"}]
}
