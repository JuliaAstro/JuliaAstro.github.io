[{"id":3,"pagetitle":"Home","title":"Home","ref":"/previews/PR43/AstroImages/stable/#Home","content":" Home GitHub link AstroImage.jl  allows you to plot images from an astronomical  FITS  file using the popular  Images.jl  and  Plots.jl  Julia packages.  AstroImage.jl  uses  FITSIO.jl  to read FITS files."},{"id":6,"pagetitle":"API","title":"API Documentation","ref":"/previews/PR43/AstroImages/stable/api/#API-Documentation","content":" API Documentation"},{"id":7,"pagetitle":"API","title":"FileIO.load","ref":"/previews/PR43/AstroImages/stable/api/#FileIO.load","content":" FileIO.load  —  Function load(filename)  loads the contents of a formatted file, trying to infer the format from  filename  and/or magic bytes in the file (see  query ). load(strm)  loads from an  IOStream  or similar object. In this case, there is no filename extension, so we rely on the magic bytes for format identification. load(File{format\"PNG\"}(filename))  specifies the format directly, and bypasses the format  query . load(Stream{format\"PNG\"}(io))  specifies the format directly, and bypasses the format  query . load(f; options...)  passes keyword arguments on to the loader."},{"id":8,"pagetitle":"API","title":"FileIO.save","ref":"/previews/PR43/AstroImages/stable/api/#FileIO.save","content":" FileIO.save  —  Function save(filename, data...)  saves the contents of a formatted file, trying to infer the format from  filename . save(Stream{format\"PNG\"}(io), data...)  specifies the format directly, and bypasses the format  query . save(File{format\"PNG\"}(filename), data...)  specifies the format directly, and bypasses the format  query . save(f, data...; options...)  passes keyword arguments on to the saver."},{"id":9,"pagetitle":"API","title":"AstroImages.AstroImage","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.AstroImage","content":" AstroImages.AstroImage  —  Type Provides access to a FITS image along with its accompanying  header and WCS information, if applicable. source"},{"id":10,"pagetitle":"API","title":"AstroImages.imview","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.imview","content":" AstroImages.imview  —  Function imview(img; clims=Percent(99.5), stretch=identity, cmap=:magma, contrast=1.0, bias=0.5) Create a read only view of an array or AstroImageMat mapping its data values to Colors according to  clims ,  stretch , and  cmap . The data is first clamped to  clims , which can either be a tuple of (min, max) values or a function accepting an iterator of pixel values that returns (min, max). By default,  clims=extrema  i.e. the minimum and maximum of  img . Convenient functions to use for  clims  are:  extrema ,  zscale , and  percent(p) Next, the data is rescaled to [0,1] and remapped according to the function  stretch . Stretch can be any monotonic fuction mapping values in the range [0,1] to some range [a,b]. Note that  log(0)  is not defined so is not directly supported. For a list of convenient stretch functions, see:  logstretch ,  powstretch ,  squarestretch ,  asinhstretch ,  sinhstretch ,  powerdiststretch Finally the data is mapped to RGB values according to  cmap . If cmap is  nothing , grayscale is used. ColorSchemes.jl defines hundreds of colormaps. A few nice ones for images include:  :viridis ,  :magma ,  :plasma ,  :thermal , and  :turbo . Crucially, this function returns a view over the underlying data. If  img  is updated then those changes will be reflected by this view with the exception of  clims  which is not recalculated. Note: if clims or stretch is a function, the pixel values passed in are first filtered to remove non-finite or missing values. Defaults The default values of  clims ,  stretch , and  cmap  are  extrema ,  identity , and  nothing  respectively. You may alter these defaults using  AstroImages.set_clims! ,   AstroImages.set_stretch! , and  AstroImages.set_cmap! . Automatic Display Arrays wrapped by  AstroImageMat()  get displayed as images automatically by calling   imview  on them with the default settings when using displays that support showing PNG images. Missing data Pixels that are  NaN  or  missing  will be displayed as transparent when  cmap  is set or black if. +/- Inf will be displayed as black or white respectively. Exporting Images The view returned by  imview  can be saved using general  FileIO.save  methods. Example: v = imview(data, cmap=:magma, stretch=asinhstretch, clims=percent(95))\nsave(\"output.png\", v) source imview(img::AbstractArray{<:Complex}; ...) When applied to an image with complex values, display the magnitude of the pixels using  imview  and display the phase angle as a panel below using a cyclical color map. For more customatization, you can create a view like this yourself: vcat(\n    imview(abs.(img)),\n    imview(angle.(img)),\n) source"},{"id":11,"pagetitle":"API","title":"AstroImages.implot","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.implot","content":" AstroImages.implot  —  Function implot(\n    img::AbstractArray;\n    clims=Percent(99.5),\n    stretch=identity,\n    cmap=:magma,\n    bias=0.5,\n    contrast=1,\n    wcsticks=true,\n    grid=true,\n    platescale=1\n) Create a read only view of an array or AstroImageMat mapping its data values to an array of Colors. Equivalent to: implot(\n    imview(\n        img::AbstractArray;\n        clims=Percent(99.5),\n        stretch=identity,\n        cmap=:magma,\n        bias=0.5,\n        contrast=1,\n    ),\n    wcsn=1,\n    wcsticks=true,\n    wcstitle=true,\n    grid=true,\n    platescale=1\n) Image Rendering See  imview  for how data is mapped to RGBA pixel values. WCS & Image Coordinates If provided with an AstroImage that has WCS headers set, the tick marks and plot grid are calculated using WCS.jl. By default, use the first WCS coordinate system. The underlying pixel coordinates are those returned by  dims(img)  multiplied by  platescale . This allows you to overplot lines, regions, etc. using pixel coordinates. If you wish to compute the pixel coordinate of a point in world coordinates, see  world_to_pix . wcsn  (default  1 ) select which WCS transform in the headers to use for ticks & grid wcsticks  (default  true  if WCS headers present) display ticks and labels, and title using world coordinates wcstitle  (default  true  if WCS headers present and  length(refdims(img))>0 ). When slicing a cube, display the location along unseen axes in world coordinates instead of pixel coordinates. grid  (default  true ) show a grid over the plot. Uses WCS coordinates if  wcsticks  is true, otherwise pixel coordinates multiplied by  platescale . platescale  (default  1 ). Scales the underlying pixel coordinates to ease overplotting, etc. If  wcsticks  is false, the displayed pixel coordinates are also scaled. Defaults The default values of  clims ,  stretch , and  cmap  are  extrema ,  identity , and  nothing  respectively. You may alter these defaults using  AstroImages.set_clims! ,   AstroImages.set_stretch! , and  AstroImages.set_cmap! . source"},{"id":12,"pagetitle":"API","title":"DimensionalData.Dimensions.dims","ref":"/previews/PR43/AstroImages/stable/api/#DimensionalData.Dimensions.dims","content":" DimensionalData.Dimensions.dims  —  Function dims(x, [dims::Tuple]) => Tuple{Vararg{<:Dimension}}\ndims(x, dim) => Dimension Return a tuple of  Dimension s for an object, in the order that matches the axes or columns of the underlying data. dims  can be  Dimension ,  Dimension  types, or  Symbols  for  Dim{Symbol} . The default is to return  nothing ."},{"id":13,"pagetitle":"API","title":"DimensionalData.Dimensions.refdims","ref":"/previews/PR43/AstroImages/stable/api/#DimensionalData.Dimensions.refdims","content":" DimensionalData.Dimensions.refdims  —  Function refdims(x, [dims::Tuple]) => Tuple{Vararg{<:Dimension}}\nrefdims(x, dim) => Dimension Reference dimensions for an array that is a slice or view of another array with more dimensions. slicedims(a, dims)  returns a tuple containing the current new dimensions and the new reference dimensions. Refdims can be stored in a field or disgarded, as it is mostly to give context to plots. Ignoring refdims will simply leave some captions empty. The default is to return an empty  Tuple () ."},{"id":14,"pagetitle":"API","title":"AstroImages.Comment","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.Comment","content":" AstroImages.Comment  —  Type Index for accessing a comment associated with a header keyword or COMMENT entry. Example: img = AstroImage(randn(10,10))\nimg[\"ABC\"] = 1\nimg[\"ABC\", Comment] = \"A comment describing this key\"\n\npush!(img, Comment, \"The purpose of this file is to demonstrate comments\")\nimg[Comment] # [\"The purpose of this file is to demonstrate comments\")] source"},{"id":15,"pagetitle":"API","title":"AstroImages.History","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.History","content":" AstroImages.History  —  Type Allows accessing and setting HISTORY header entries img = AstroImage(randn(10,10)) push!(img, History, \"2023-04-19: Added history entry.\") img[History] # [\"2023-04-19: Added history entry.\"] source"},{"id":16,"pagetitle":"API","title":"WCS.pix_to_world","ref":"/previews/PR43/AstroImages/stable/api/#WCS.pix_to_world","content":" WCS.pix_to_world  —  Function pix_to_world(wcs, pixcoords) Convert the array of pixel coordinates  pixcoords  to world coordinates according to the WCSTransform  wcs .  pixcoords  should be a 2-d array where \"pixcoords[:, i]\" is the i-th set of coordinates, or a 1-d array representing a single set of coordinates. The return value is the same shape as  pixcoords . pix_to_world(img::AstroImage, pixcoords; all=false) Given an astro image, look up the world coordinates of the pixels given  by  pixcoords . World coordinates are resolved using WCS.jl and a WCSTransform calculated from any FITS header present in  img . If no WCS information is in the header, or the axes are all linear, this will just return pixel coordinates. pixcoords  should be the coordinates in your current selection of the image. For example, if you select a slice like this: julia> cube = load(\"some-3d-cube.fits\")\njulia> slice = cube[10:20, 30:40, 5] Then to look up the coordinates of the pixel in the bottom left corner of  slice , run: julia> world_coords = pix_to_world(img, [1, 1])\n[10, 30] If WCS information was present in the header of  cube , then those coordinates would be resolved using axis 1, 2, and 3 respectively. To include world coordinates in all axes, pass  all=true julia> world_coords = pix_to_world(img, [1, 1], all=true)\n[10, 30, 5] !! Coordinates must be provided in the order of  dims(img) . If you transpose  an image, the order you pass the coordinates should not change. source"},{"id":17,"pagetitle":"API","title":"WCS.world_to_pix","ref":"/previews/PR43/AstroImages/stable/api/#WCS.world_to_pix","content":" WCS.world_to_pix  —  Function world_to_pix(wcs, worldcoords) Convert the array of world coordinates  worldcoords  to pixel coordinates according to the WCSTransform  wcs .  worldcoords  is a 2-d array where \"worldcoords[:, i]\" is the i-th set of coordinates, or a 1-d array representing a single set of coordinates. The return value is the same size as  worldcoords ."},{"id":18,"pagetitle":"API","title":"DimensionalData.Dimensions.X","ref":"/previews/PR43/AstroImages/stable/api/#DimensionalData.Dimensions.X","content":" DimensionalData.Dimensions.X  —  Type X <: XDim\n\nX(val=:) X  Dimension .  X <: XDim <: IndependentDim Example: xdim = X(2:2:10)\n# Or\nval = A[X(1)]\n# Or\nmean(A; dims=X)"},{"id":19,"pagetitle":"API","title":"DimensionalData.Dimensions.Y","ref":"/previews/PR43/AstroImages/stable/api/#DimensionalData.Dimensions.Y","content":" DimensionalData.Dimensions.Y  —  Type Y <: YDim\n\nY(val=:) Y  Dimension .  Y <: YDim <: DependentDim Example: ydim = Y(['a', 'b', 'c'])\n# Or\nval = A[Y(1)]\n# Or\nmean(A; dims=Y)"},{"id":20,"pagetitle":"API","title":"DimensionalData.Dimensions.Z","ref":"/previews/PR43/AstroImages/stable/api/#DimensionalData.Dimensions.Z","content":" DimensionalData.Dimensions.Z  —  Type Z <: ZDim\n\nZ(val=:) Z  Dimension .  Z <: ZDim <: Dimension Example: zdim = Z(10:10:100)\n# Or\nval = A[Z(1)]\n# Or\nmean(A; dims=Z)"},{"id":21,"pagetitle":"API","title":"DimensionalData.Dimensions.Dim","ref":"/previews/PR43/AstroImages/stable/api/#DimensionalData.Dimensions.Dim","content":" DimensionalData.Dimensions.Dim  —  Type Dim{S}(val=:) A generic dimension. For use when custom dims are required when loading data from a file. Can be used as keyword arguments for indexing. Dimension types take precedence over same named  Dim  types when indexing with symbols, or e.g. creating Tables.jl keys. using DimensionalData\n\ndim = Dim{:custom}(['a', 'b', 'c'])\n\n# output\n\nDim{:custom} Char[a, b, c]"},{"id":22,"pagetitle":"API","title":"DimensionalData.Dimensions.LookupArrays.At","ref":"/previews/PR43/AstroImages/stable/api/#DimensionalData.Dimensions.LookupArrays.At","content":" DimensionalData.Dimensions.LookupArrays.At  —  Type At <: Selector\n\nAt(x, atol, rtol)\nAt(x; atol=nothing, rtol=nothing) Selector that exactly matches the value on the passed-in dimensions, or throws an error. For ranges and arrays, every intermediate value must match an existing value - not just the end points. x  can be any value or  Vector  of values. atol  and  rtol  are passed to  isapprox . For  Number rtol  will be set to  Base.rtoldefault , otherwise  nothing , and wont be used. Example using DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))\nA[X(At(20)), Y(At(6))]\n\n# output\n\n5"},{"id":23,"pagetitle":"API","title":"DimensionalData.Dimensions.LookupArrays.Near","ref":"/previews/PR43/AstroImages/stable/api/#DimensionalData.Dimensions.LookupArrays.Near","content":" DimensionalData.Dimensions.LookupArrays.Near  —  Type Near <: Selector\n\nNear(x) Selector that selects the nearest index to  x . With  Points  this is simply the index values nearest to the  x , however with  Intervals  it is the interval  center  nearest to  x . This will be offset from the index value for  Start  and  End  loci. Example using DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))\nA[X(Near(23)), Y(Near(5.1))]\n\n# output\n4"},{"id":24,"pagetitle":"API","title":"AstroImages.header","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.header","content":" AstroImages.header  —  Function header(img::AstroImage) Return the underlying FITSIO.FITSHeader object wrapped by an AstroImage. Note that this object has less flexible getindex and setindex methods. Indexing by symbol, Comment, History, etc are not supported. source header(array::AbstractArray) Returns an empty FITSIO.FITSHeader object when called with a non-AstroImage abstract array. source"},{"id":25,"pagetitle":"API","title":"AstroImages.wcs","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.wcs","content":" AstroImages.wcs  —  Function wcs(img) Computes and returns a list of World Coordinate System WCSTransform objects from WCS.jl. The resultss are cached after the first call, so subsequent calls are fast. Modifying a WCS header invalidates this cache automatically, so users should call  wcs(...)  each time rather than keeping the WCSTransform object around. source wcs(img, index) Computes and returns a World Coordinate System WCSTransform objects from WCS.jl by index. This is to support files with multiple WCS transforms specified.  wcs(img,1)  is useful for selecting selecting the first WCSTranform object. The resultss are cached after the first call, so subsequent calls are fast. Modifying a WCS header invalidates this cache automatically, so users should call  wcs(...)  each time rather than keeping the WCSTransform object around. source wcs(array) Returns a list with a single basic WCSTransform object when called with a non-AstroImage abstract array. source"},{"id":26,"pagetitle":"API","title":"AstroImages.WCSGrid","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.WCSGrid","content":" AstroImages.WCSGrid  —  Type WCSGrid(img::AstroImageMat, ax=(1,2), coords=(first(axes(img,ax[1])),first(axes(img,ax[2])))) Given an AstroImageMat, return information necessary to plot WCS gridlines in physical coordinates against the image's pixel coordinates. This function has to work on both plotted axes at once to handle rotation and general curvature of the WCS grid projected on the image coordinates. source"},{"id":27,"pagetitle":"API","title":"AstroImages.composecolors","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.composecolors","content":" AstroImages.composecolors  —  Function composecolors(\n    images,\n    cmap=[\"#F00\", \"#0F0\", \"#00F\"];\n    clims,\n    stretch,\n    contrast,\n    bias,\n    multiplier\n) Create a color composite of multiple images by applying  imview  and blending  the results. This function can be used to create RGB composites using any number of channels (e.g. red, green, blue, and hydrogen alpha) as well as more exotic images like blending radio and optical data using two different colormaps. cmap  should be a list of colorants, named colors (see Colors.jl), or colorschemes (see ColorSchemes.jl).  clims ,  stretch ,  contrast , and  bias  are passed on to  imview . They can be a single value or a list of different values for each image. Examples: # Basic RGB\ncomposecolors([redimage, greenimage, blueimage])\n# Non-linear stretch before blending\ncomposecolors([redimage, greenimage, blueimage], stretch=asinhstretch)\n# More than three channels are allowed (H alpha in pink)\ncomposecolors(\n    [antred, antgreen, antblue, anthalp],\n    [\"red\", \"green\", \"blue\", \"maroon1\"],\n    multiplier=[1,2,1,1]\n)\n# Can mix \ncomposecolors([radioimage, xrayimage], [:ice, :magma], clims=extrema)\ncomposecolors([radioimage, xrayimage], [:magma, :viridis], clims=[Percent(99), Zscale()]) source"},{"id":28,"pagetitle":"API","title":"AstroImages.Zscale","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.Zscale","content":" AstroImages.Zscale  —  Type Zscale(options)(data) Wraps PlotUtils.zscale in a callable with default parameters. This is a common algorithm for agressively stretching astronomical data to see faint structure that originated in IRAF: https://iraf.net/forum/viewtopic.php?showtopic=134139 but is now seen in many other applications/libraries (DS9, Astropy, etc.) Usage: imview(img, clims=Zscale())\nimplot(img, clims=Zscale(contrast=0.1)) Default parameters: nsamples::Int=1000\ncontrast::Float64=0.25\nmax_reject::Float64=0.5\nmin_npixels::Float64=5\nk_rej::Float64=2.5\nmax_iterations::Int=5 source"},{"id":29,"pagetitle":"API","title":"AstroImages.Percent","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.Percent","content":" AstroImages.Percent  —  Type Percent(99.5) Returns a callable that calculates display limits that include the given  percent of the image data. Reproduces the behaviour of the SAO DS9 scale menu. Example: julia> imview(img, clims=Percent(90)) This will set the limits to be the 5th percentile to the 95th percentile. source"},{"id":30,"pagetitle":"API","title":"AstroImages.logstretch","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.logstretch","content":" AstroImages.logstretch  —  Function logstretch(num,a=1000) A log-stretch as defined by the SAO DS9 application: http://ds9.si.edu/doc/ref/how.html source"},{"id":31,"pagetitle":"API","title":"AstroImages.powstretch","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.powstretch","content":" AstroImages.powstretch  —  Function powstretch(num, a=1000) A power-stretch as defined by the SAO DS9 application: http://ds9.si.edu/doc/ref/how.html source"},{"id":32,"pagetitle":"API","title":"AstroImages.sqrtstretch","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.sqrtstretch","content":" AstroImages.sqrtstretch  —  Function sqrtstretch(num) A square root stretch (simply defined as Base.sqrt) source"},{"id":33,"pagetitle":"API","title":"AstroImages.squarestretch","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.squarestretch","content":" AstroImages.squarestretch  —  Function squarestretch(num) A squarestretch-stretch as defined by the SAO DS9 application: http://ds9.si.edu/doc/ref/how.html source"},{"id":34,"pagetitle":"API","title":"AstroImages.asinhstretch","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.asinhstretch","content":" AstroImages.asinhstretch  —  Function asinhstretch(num) A hyperbolic arcsin stretch as defined by the SAO DS9 application: http://ds9.si.edu/doc/ref/how.html. source"},{"id":35,"pagetitle":"API","title":"AstroImages.sinhstretch","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.sinhstretch","content":" AstroImages.sinhstretch  —  Function sinhstretch(num) A hyperbolic sin stretch as defined by the SAO DS9 application: http://ds9.si.edu/doc/ref/how.html source"},{"id":36,"pagetitle":"API","title":"AstroImages.powerdiststretch","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.powerdiststretch","content":" AstroImages.powerdiststretch  —  Function logstretch(num,a=1000) A power distance stretch as defined by astropy. source"},{"id":37,"pagetitle":"API","title":"AstroImages.copyheader","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.copyheader","content":" AstroImages.copyheader  —  Function copyheader(img::AstroImage, data) -> imgnew Create a new image copying the header of  img  but using the data of the AbstractArray  data . Note that changing the header of  imgnew  does not affect the header of  img . See also:  shareheader . source"},{"id":38,"pagetitle":"API","title":"AstroImages.shareheader","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.shareheader","content":" AstroImages.shareheader  —  Function shareheader(img::AstroImage, data) -> imgnew Create a new image reusing the header dictionary of  img  but using the data of the AbstractArray  data . The two images have synchronized header; modifying one also affects the other. See also:  copyheader . source"},{"id":41,"pagetitle":"Contours","title":"Contours","ref":"/previews/PR43/AstroImages/stable/guide/contours/#Contours","content":" Contours This guide shows a few different ways to measure and visualize contours of images."},{"id":42,"pagetitle":"Contours","title":"Using Plots","ref":"/previews/PR43/AstroImages/stable/guide/contours/#Using-Plots","content":" Using Plots The most basic way to create a contour plot is simply to use Plots.jl  contour  and  contourf  functions on your image. Let's see how that works: using AstroImages, Plots\n\n\n# First load a FITS file of interest\nfname = download(\n    \"http://www.astro.uvic.ca/~wthompson/astroimages/fits/herca/herca_radio.fits\",\n    \"herca-radio.fits\"\n)\n\nherca = load(\"herca-radio.fits\") Create a contour plot contour(herca)"},{"id":45,"pagetitle":"Blurring & Filtering Images","title":"Image Filtering","ref":"/previews/PR43/AstroImages/stable/guide/image-filtering/#Image-Filtering","content":" Image Filtering The package  ImageFiltering.jl  makes it easy to apply arbitrary filters to images."},{"id":46,"pagetitle":"Blurring & Filtering Images","title":"Gaussian Blurs","ref":"/previews/PR43/AstroImages/stable/guide/image-filtering/#Gaussian-Blurs","content":" Gaussian Blurs Let's start by downloading a radio image of Hercules A: using AstroImages\nusing ImageFiltering\n\nfname = download(\n    \"http://www.astro.uvic.ca/~wthompson/astroimages/fits/herca/herca_radio.fits\",\n    \"herca-radio.fits\"\n)\n\nherca = load(\"herca-radio.fits\") Let's now apply a Gaussian blur (aka a low pass filter) using the  imfilter  function: herca_blur_20 = imfilter(herca, Kernel.gaussian(20.0)) The image has been smoothed out by convolving it with a wide Gaussian. Let's now do the opposite and perform a high-pass filter. This will bring out faint variations in structure. We can do this by subtracting a blurred image from the original: herca_blur_4 = imfilter(herca, Kernel.gaussian(4.0))\nherca_highpass = herca .- herca_blur_4 We now see lots of faint structure inside the jets! Finally, let's adjust how the image is displayed and apply a non-linear stretch: imview(\n    herca_highpass,\n    cmap=:seaborn_rocket_gradient,\n    clims=(-50,1500),\n    stretch=asinhstretch\n) If you have Plots loaded, we can add a colorbar and coordinate axes by switching to  implot : using Plots\nimplot(\n    herca_highpass,\n    cmap=:seaborn_rocket_gradient,\n    clims=(-50,1500),\n    stretch=asinhstretch\n)"},{"id":47,"pagetitle":"Blurring & Filtering Images","title":"Median Filtering","ref":"/previews/PR43/AstroImages/stable/guide/image-filtering/#Median-Filtering","content":" Median Filtering In addition to linear filters using  imfilter , ImageFiltering.jl also includes a great function called  mapwindow . This functions allows you to map an arbitrary function over a patch of an image.  Let's use  mapwindow  to perform a median filter. This is a great way to suppress salt and pepper noise, or remove stars from some images. We'll use a Hubble picture of the Eagle nebula: using AstroImages\nusing ImageFiltering\n\nfname = download(\n    \"http://www.astro.uvic.ca/~wthompson/astroimages/fits/eagle/673nmos.fits\",\n    \"eagle-673nmos.fits\"\n)\n\neagle673 = load(\"eagle-673nmos.fits\") The data is originally from https://esahubble.org/projects/fits_liberator/eagledata/. We can apply a median filter using  mapwindow . Make sure the patch size is an odd number in each direction! using Statistics\nmedfilt = copyheader(eagle673, mapwindow(median, eagle673, (11,11))) We use  copyheader  here since  mapwindow  returns a plain array and drops the image meta data. We can put this side by side with the original to see how some of the faint stars have been removed from the image: imview([eagle673[1:800,1:800]; medfilt[1:800,1:800]])"},{"id":50,"pagetitle":"Transforming Images","title":"Image Transformations","ref":"/previews/PR43/AstroImages/stable/guide/image-transformations/#Image-Transformations","content":" Image Transformations The  ImageTransformations.jl  package contains many useful functions for manipulating astronomical images. Note however that many of these functions drop the AstroImage wrapper and return plain arrays or OffsetArrays. They can be re-wrapped using  copyheader  or  shareheader  if you'd like to preserve the FITS header, dimension labels, WCS information, etc. You can install ImageTransformations by running  ] add ImageTransformations  at the REPL. For these examples, we'll download an image of the Antenae galaxies from Hubble: using AstroImages\nusing ImageTransformations\n\nfname = download(\n    \"http://www.astro.uvic.ca/~wthompson/astroimages/fits/antenae/blue.fits\",\n    \"ant-blue.fits\"\n)\n\nantblue = load(\"ant-blue.fits\")\n\n# We'll change the defaults to avoid setting them each time\nAstroImages.set_clims!(Percent(99))\nAstroImages.set_cmap!(:ice)\nAstroImages.set_stretch!(asinhstretch)\n\nimview(antblue)"},{"id":51,"pagetitle":"Transforming Images","title":"Rotations","ref":"/previews/PR43/AstroImages/stable/guide/image-transformations/#Rotations","content":" Rotations We can rotate images using the  imrotate  function. imrotate(antblue, 3π/4) |> imview The rotation angle is in radians, but you can use the function  rad2deg  to convert from degrees."},{"id":52,"pagetitle":"Transforming Images","title":"Resizing","ref":"/previews/PR43/AstroImages/stable/guide/image-transformations/#Resizing","content":" Resizing We can resize images using the  imresize  function: imresize(antblue, ratio=0.2) |> imview"},{"id":53,"pagetitle":"Transforming Images","title":"Arbitrary Transformations","ref":"/previews/PR43/AstroImages/stable/guide/image-transformations/#Arbitrary-Transformations","content":" Arbitrary Transformations Arbitrary transformations can be performed using ImageTransformation's  warp  function. See the documentation linked above for more details."},{"id":54,"pagetitle":"Transforming Images","title":"Mapping from One Coordinate System to Another","ref":"/previews/PR43/AstroImages/stable/guide/image-transformations/#Mapping-from-One-Coordinate-System-to-Another","content":" Mapping from One Coordinate System to Another For transforming an image from one coordiante system (say, RA & DEC) to another (e.g., galactic lattitude & logitude), see  Reprojecting Images ."},{"id":57,"pagetitle":"Extracting Photometry","title":"Photometry","ref":"/previews/PR43/AstroImages/stable/guide/photometry/#Photometry","content":" Photometry The following examples are adapted from  Photometry.jl  to show the same examples combined with AstroImages.jl. To learn how to measure background levels, perform aperture photometry, etc see the  Photometry.jl documentation ."},{"id":58,"pagetitle":"Extracting Photometry","title":"Background Estimation","ref":"/previews/PR43/AstroImages/stable/guide/photometry/#Background-Estimation","content":" Background Estimation From Photometry.jl: Estimating backgrounds is an important step in performing photometry. Ideally, we could perfectly describe the background with a scalar value or with some distribution. Unfortunately, it's impossible for us to precisely separate the background and foreground signals. Here, we use mixture of robust statistical estimators and meshing to let us get the spatially varying background from an astronomical photo. Let's show an example Now let's try and estimate the background using estimate_background. First, we'll si gma-clip to try and remove the signals from the stars. Then, the background is broken down into boxes, in this case of size (50, 50). Within each box, the given statistical estimators get the background value and RMS. By default, we use SourceExtractorBackground and StdRMS. This creates a low-resolution image, which we then need to resize. We can accomplish this using an interpolator, by default a cubic-spline interpolator via ZoomInterpolator. The end result is a smooth estimate of the spatially varying background and background RMS. using Photometry\nusing AstroImages\nusing Plots # optional, for implot functionality\n\n# Download our image, courtesy of astropy\nimage = AstroImage(download(\"https://rawcdn.githack.com/astropy/photutils-datasets/8c97b4fa3a6c9e6ea072faeed2d49a20585658ba/data/M6707HH.fits\"))\n\n# sigma-clip\nclipped = sigma_clip(image, 1, fill=NaN)\n\n# get background and background rms with box-size (50, 50)\nbkg, bkg_rms = estimate_background(clipped, 50)\n\nimview(image)\nimview(clipped)\nimview(bkg)\nimview(bkg_rms) Or, if you have Plots loaded: using Plots\n\n    AstroImages.set_clims!(Percent(99.5))\n    AstroImages.set_cmap!(:magma)\n    AstroImages.set_stretch!(identity)\nplot(\n    implot(image, title=\"Original\"),\n    implot(clipped, title=\"Sigma-Clipped\"),\n    implot(bkg, title=\"Background\"),\n    implot(bkg_rms, title=\"Background RMS\"),\n    layout=(2, 2)\n) We could apply a median filter, too, by specifying filter_size # get background and background rms with box-size (50, 50) and filter_size (5, 5)\nbkg_f, bkg_rms_f = estimate_background(clipped, 50, filter_size=5)\n\n# plot\nplot(\n    implot(bkg, title=\"Unfiltered\", ylabel=\"Background\"),\n    implot(bkg_f, title=\"Filtered\"),\n    implot(bkg_rms, ylabel=\"RMS\"),\n    implot(bkg_rms_f);\n    layout=(2, 2),) Now we can see our image after subtracting the filtered background and ready for Aperture Photometry! subt = image .- bkg_f[axes(image)...]\nclims = extrema(vcat(vec(image), vec(subt)))\nplot(\n    implot(image; title=\"Original\", clims),\n    implot(subt; title=\"Subtracted\", clims),\n    size=(1600,1000)\n)"},{"id":59,"pagetitle":"Extracting Photometry","title":"Source Extraction","ref":"/previews/PR43/AstroImages/stable/guide/photometry/#Source-Extraction","content":" Source Extraction From the background-subtracted image, we can detect all sources in the image: # We specify the uncertainty in the pixel data. We'll set it equal to zero.\nerrs = zeros(axes(subt))\nsources = extract_sources(PeakMesh(), subt, errs, true) # sort from brightest to darkest Table with 3 columns and 60924 rows:\n      x     y     value\n    ┌────────────────────\n 1  │ 255   226   9762.42\n 2  │ 940   681   9661.5\n 3  │ 219   924   9653.78\n 4  │ 38    678   9647.93\n 5  │ 245   85    9637.55\n 6  │ 44    1001  9633.13\n 7  │ 503   904   9627.34\n 8  │ 819   775   9625.92\n 9  │ 610   62    9617.79\n 10 │ 133   110   9616.88\n 11 │ 592   123   9614.86\n 12 │ 1055  248   9612.46\n 13 │ 424   86    9611.86\n 14 │ 558   125   9585.93\n 15 │ 125   1021  9582.11\n 16 │ 112   637   9579.71\n 17 │ 196   2     9579.49\n ⋮  │  ⋮     ⋮       ⋮ There's over 60,000 sources! We'll define a circular apperture for each source: aps = CircularAperture.(sources.x, sources.y, 6)[1:1000] # just brightest thousand point sources 1000-element Vector{CircularAperture{Int64}}:\n CircularAperture(255, 226, r=6)\n CircularAperture(940, 681, r=6)\n CircularAperture(219, 924, r=6)\n CircularAperture(38, 678, r=6)\n CircularAperture(245, 85, r=6)\n CircularAperture(44, 1001, r=6)\n CircularAperture(503, 904, r=6)\n CircularAperture(819, 775, r=6)\n CircularAperture(610, 62, r=6)\n CircularAperture(133, 110, r=6)\n ⋮\n CircularAperture(697, 975, r=6)\n CircularAperture(703, 599, r=6)\n CircularAperture(893, 878, r=6)\n CircularAperture(291, 457, r=6)\n CircularAperture(660, 855, r=6)\n CircularAperture(711, 920, r=6)\n CircularAperture(708, 271, r=6)\n CircularAperture(701, 273, r=6)\n CircularAperture(710, 273, r=6) We can overplot them on our original image. The coordinate sytem used by the Photometry.jl plot recipes (but not the actual return values) doesn't match AstroImages, so we must transpose our image: implot(subt', colorbar=false)\nplot!(aps)"},{"id":60,"pagetitle":"Extracting Photometry","title":"Measuring Photometry","ref":"/previews/PR43/AstroImages/stable/guide/photometry/#Measuring-Photometry","content":" Measuring Photometry Finally we can extract the source photometry  table = photometry(aps, subt) Table with 3 columns and 1000 rows:\n      xcenter  ycenter  aperture_sum\n    ┌───────────────────────────────\n 1  │ 255      226      20542.4\n 2  │ 940      681      7125.3\n 3  │ 219      924      14741.0\n 4  │ 38       678      31056.4\n 5  │ 245      85       -910.308\n 6  │ 44       1001     2792.62\n 7  │ 503      904      6954.07\n 8  │ 819      775      -3136.61\n 9  │ 610      62       4338.13\n 10 │ 133      110      22219.0\n 11 │ 592      123      18562.2\n 12 │ 1055     248      3277.33\n 13 │ 424      86       255299.0\n 14 │ 558      125      6659.03\n 15 │ 125      1021     11524.1\n 16 │ 112      637      1349.78\n 17 │ 196      2        -797.491\n ⋮  │    ⋮        ⋮          ⋮ And plot them:  scatter(\n    table.xcenter,\n    table.ycenter,\n    aspectratio=1,\n    marker_z=table.aperture_sum,\n    markerstrokewidth=0,\n    label=\"\",\n    framestyle=:box,\n    background_inside=:black,\n    color=:white\n)"},{"id":63,"pagetitle":"Reprojecting Images","title":"Reprojecting Images","ref":"/previews/PR43/AstroImages/stable/guide/reproject/#Reprojecting-Images","content":" Reprojecting Images Integration with the  Reproject.jl  package is not yet complete."},{"id":66,"pagetitle":"Conventions","title":"Conventions","ref":"/previews/PR43/AstroImages/stable/manual/conventions/#Conventions","content":" Conventions In the Julia Astro ecosystem, images follow the following conventions."},{"id":67,"pagetitle":"Conventions","title":"Axes","ref":"/previews/PR43/AstroImages/stable/manual/conventions/#Axes","content":" Axes For simple 2D images, the first axis is the horizontal axis and the second axis is the vertical axis. So images are indexed by  img[xi, yi] . The origin is at the bottom left of the image, so  img[1,1]  refers to the bottom left corner as does  img[begin,begin] .  img[end,end]  is the top right corner,  img[begin,end]  is the top left, etc. Note that this is transposed and flipped from how how Julia prints arrays at the REPL, "},{"id":68,"pagetitle":"Conventions","title":"Pixels","ref":"/previews/PR43/AstroImages/stable/manual/conventions/#Pixels","content":" Pixels This library considers the exact location of  img[1,1]  to be the center of the pixel in the bottom left corner. This means that plot limits should have the  1  tick slightly away from the left/bottom spines of the image. The default plot limits for  implot  are  -0.5  to  end+0.5  along both axes.  There is a  known bug  with the Plots.jl GR backend that leads ticks to be slightly offset. PyPlot and Plotly backends show the correct tick locations."},{"id":71,"pagetitle":"Converting from RGB","title":"Converting From RGB Images","ref":"/previews/PR43/AstroImages/stable/manual/converting-from-rgb/#Converting-From-RGB-Images","content":" Converting From RGB Images If you encouter an image in a standard graphics format (e.g. PNG, JPG) that you want to analyze or store in an AstroImage, it will likely contain RGB (or similar) pixels.  It is possible to store RGB data in an AstroImage. Let's see how that works: using AstroImages\ndownload(\"http://www.astro.uvic.ca/~wthompson/astroimages/fits/mw-crop2-small.png\",\"mw-crop2-small.png\")\n\n# First we load it from the PNG file\nmw_png = load(\"mw-crop2-small.png\") You will need the Images.jl package installed to load formats like PNG. Once the RGB image is loaded, we can store it in an AstroImage if we'd like: mw_ai = AstroImage(mw_png) However, we may want to extract the RGB channels first. We can do this using  Images.channelview . Images.channelview  returns a view into the RGB data as a 3 × X × Y dimension cube. Unfortunately, we will have to permute the dimensions slightly. using Images\nmw_png = load(\"mw-crop2-small.png\")\nmw_chan_view = channelview(mw_png)\nmw_rgb_cube = AstroImage(\n    permutedims(mw_chan_view, (3, 2, 1))[:,end:-1:begin,:],\n    # Optional:\n    (X=:, Y=:, Spec=[:R,:G,:B])\n) 2596×1440×3 AstroImage{N0f8,3} with dimensions: \n  X ,\n  Y ,\n  Dim{:Spec} Categorical Symbol[R, G, B] ReverseOrdered\n[:, :, 1]\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n ⋮                        ⋮              ⋱            ⋮                   \n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n[and 2 more slices...] Here we chose to mark the third axis as a spectral axis with keys  :R ,  :G , and  :B . We can now visualize each channel: mw_rgb_cube[Spec=At(:R)] # Or just: mw_rgb_cube[:,:,1] imview(\n    mw_rgb_cube[Spec=At(:R)],\n    cmap=nothing # Grayscale mode\n) using Plots\nimplot(mw_rgb_cube[Spec=At(:B)])"},{"id":74,"pagetitle":"Converting to RGB","title":"Converting to RGB","ref":"/previews/PR43/AstroImages/stable/manual/converting-to-rgb/#Converting-to-RGB","content":" Converting to RGB If you have two or more images of the same scene taken at different wavelengths, you may wish to combine them to create a colour composite. For ultimate control, you can do this manually using  imview . Simply map your channels to  RGB  values using  imview  and then sum the results. For convenience, AstroImages.jl provides the function  composecolors ."},{"id":75,"pagetitle":"Converting to RGB","title":"Using composecolors","ref":"/previews/PR43/AstroImages/stable/manual/converting-to-rgb/#Using-composecolors","content":" Using  composecolors We'll demonstrate  composecolors  using Hubble images of the Antenae colliding galaxies. One can be very scientific about this process, but often the goal of producing color composites is aesthetic or about highlighting certain features for public consumption.  I'll set the default color map to grayscale to avoid confusion. using AstroImages\n\nAstroImages.set_cmap!(nothing) Let's start by downloading the separate color channel FITS files: antred = AstroImage(download(\"http://www.astro.uvic.ca/~wthompson/astroimages/fits/antenae/red.fits\")) antgreen = AstroImage(download(\"http://www.astro.uvic.ca/~wthompson/astroimages/fits/antenae/green.fits\")) antblue = AstroImage(download(\"http://www.astro.uvic.ca/~wthompson/astroimages/fits/antenae/blue.fits\")) anthalph = AstroImage(download(\"http://www.astro.uvic.ca/~wthompson/astroimages/fits/antenae/hydrogen.fits\")); # Hydrogen-Alpha; we'll revisit later The images will have to be aligned and cropped to the same size before making a color composite. In order to compose these images, we'll have to match the relative intensity scales and clip outlying values. Thankfully,  composecolors  handles most of these details automatically. rgb1 = composecolors([antred, antgreen, antblue]) It's a start! By default, if you provide three images these are mapped to the color channels red, green, and blue. The intensities are limited to  Percent(99.5) . We can now tweak these defaults to our tastes. We could try clamping the intensities more agressively to bring out more of the galaxy structure: rgb2 = composecolors(\n    [antred, antgreen, antblue],\n    clims=Percent(97)\n) This looks okay but saturates the galaxy cores. Let's take care of that gash through the image by just blanking it out. mask = antgreen .== antgreen[end,begin]\n# remove holes in the mask\nusing ImageFiltering, Statistics\nmask = BitMatrix(mapwindow(median, mask, (3,3)))\nimview(mask) antred[mask] .= NaN\nantgreen[mask] .= NaN\nantblue[mask] .= NaN\nanthalph[mask] .= NaN; 92228-element view(::Vector{Float32}, [39, 40, 41, 42, 43, 44, 45, 46, 47, 48  …  1119338, 1119339, 1119340, 1119341, 1119342, 1119343, 1119344, 1119345, 1119346, 1119347]) with eltype Float32:\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN\n   ⋮\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN Typically we need to perform a \"gamma correction\" aka non-lienar stretch to map the wide dynamic range of astronomical images into a narrower human visible range. We can do this using the  stretch  keyword. An  asinhstretch  is typically recommended when preparing RGB images: rgb3 = composecolors(\n    [antred, antgreen, antblue],\n    stretch=asinhstretch\n) Keywords like  strech ,  clims , etc can be either a single value for all channels or a list of separate values/functions per channel. The green channel appears to be quite faint compared to the red and blue channels. We can modify that by adjusting the relative intensities of the channels.  We could also do this using a combination of the  contrast  and  bias  keywords. rgb4 = composecolors(\n    [antred, antgreen, antblue],\n    stretch=asinhstretch,\n    multiplier=[1,1.7,1]\n) That's better! Let's go one step further, and incorporate a fourth chanel: Hydrogen Alpha. Hydrogen Alpha is a narrow filter centered around one of the emission lines of Hydrogen atoms. It traces locations with hot gas; mostly star-formation regions in this case. imview(anthalph, cmap=:magma, clims=Zscale()) We'll now need to specify the color channels we want to use for each wavelength since we can't use just the default three RGB. We can use any named color or julia ColorScheme. rgb5 = composecolors(\n    [antred, antgreen, antblue, anthalph],\n    [\"red\", \"green\", \"blue\", \"maroon1\"],\n    stretch=asinhstretch,\n    multiplier=[1,1.7,1,0.8]\n) Additionally, I'd like to just show the brightest areas of Hydrogen alpha emission rather than adding a diffuse pink glow. We can turn off the stretch for this one channel: rgb6 = composecolors(\n    [antred, antgreen, antblue, anthalph],\n    [\"red\", \"green\", \"blue\", \"maroon1\"],\n    stretch=[\n        asinhstretch,\n        asinhstretch,\n        asinhstretch,\n        identity,\n    ],\n    multiplier=[1,1.7,1,0.8]\n) Finally, we can crop the image and save it as a PNG. crop = rgb6[200:end-100,50:end-50] save(\"antenae-composite.png\", crop) If you want to save it in a format like  JPG  that doesn't support transparent pixels, you could replace the masked area with zeros instead of  NaN ."},{"id":78,"pagetitle":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","ref":"/previews/PR43/AstroImages/stable/manual/dimensions-and-world-coordinates/#Dimensions-and-World-Coordinates","content":" Dimensions and World Coordinates AstroImages are based on  Dimensional Data . Each axis is assigned a dimension name and the indices are tracked."},{"id":79,"pagetitle":"Dimensions and World Coordinates","title":"World Coordinates","ref":"/previews/PR43/AstroImages/stable/manual/dimensions-and-world-coordinates/#World-Coordinates","content":" World Coordinates FITS files with world coordinate system (WCS) headers contain all the information necessary to map a pixel location into celestial coordinates & back. Let's see how this works with a 2D image with RA & DEC coordinates. using AstroImages\nusing Plots\n\n# Download a Hubble image of the Eagle nebula\ndownload(\n    \"http://www.astro.uvic.ca/~wthompson/astroimages/fits/656nmos.fits\",\n    \"eagle-656nmos.fits\"\n);\neagle = AstroImage(\"eagle-656nmos.fits\") This image contains world coordinate system headers. AstroImages.jl uses WCS.jl (and wcslib under the hood) to parse these headers. We can generate a WCSTransform object to inspect: wcs(eagle, 1) # specify which coordinate system WCSTransform(naxis=2,cdelt=[1.0, 1.0],crval=[274.71149247724, -13.816384007184],crpix=[386.5, 396.0]) Note that we specify with an index which coordinate system we'd like to use. Most images just contain one, but some contain multiple systems. We can lookup a coordinate from the image: world = pix_to_world(eagle, [1, 1]) # Bottom left corner 2-element Vector{Float64}:\n 274.712299241082\n -13.801135972688115 Or convert back from world coordinates to pixel coordinates: We can lookup a coordinate from the image: world_to_pix(eagle, world) # Bottom left corner 2-element Vector{Float64}:\n 1.000000000336172\n 0.9999999992196535 These pixel coordinates do not necessarily have to lie within the bounds of the original image, and in general lie at a fractional pixel position. If an image contains WCS headers, we can visualize them using  implot : implot(eagle) We can adjust the color of the grid: implot(eagle, gridcolor=:cyan) If these aren't desired, we can turn off the grid or the WCS tick marks: plot(\n  implot(eagle, grid=false),\n  implot(eagle, wcsticks=false),\n  size=(900,300),\n  bottommargin=10Plots.mm\n) Since AstroImages are based on DimensionalData's AbstractDimArray, the mapping between pixel coordinates and world coordinates are preserved when slicing an AstroImage: slice1 = eagle[1:800,1:800]\nslice2 = eagle[800:1600,1:800]\nplot(\n  implot(slice1),\n  implot(slice2),\n  size=(900,300),\n  bottommargin=10Plots.mm\n) World coordinate queries from that slice are aware of their position in the parent image: @show pix_to_world(slice1, [1,1])\n@show pix_to_world(slice2, [1,1]) 2-element Vector{Float64}:\n 274.7277517847315\n -13.817350009028138 Note  that you can query the dimensions of an image using the  dims  function from DimensionalData: dims(slice2) X Sampled 800:1600 ForwardOrdered Regular Points,\nY Sampled 1:800 ForwardOrdered Regular Points"},{"id":80,"pagetitle":"Dimensions and World Coordinates","title":"Named Dimensions","ref":"/previews/PR43/AstroImages/stable/manual/dimensions-and-world-coordinates/#Named-Dimensions","content":" Named Dimensions Each dimension of an AstroImage is named. The automatic dimension names are  X ,  Y ,  Z ,  Dim{4} ,  Dim{5} , and so on; however you can pass in other names or orders to the load function and/or AstroImage contructor: julia> img = load(\"eagle-656nmos.fits\",1,(Y,Z))\n1600×1600 AstroImage{Float32,2} with dimensions:\n  Y Sampled 1:1600 ForwardOrdered Regular Points,\n  Z Sampled 1:1600 ForwardOrdered Regular Points Other useful dimension names are  Spec  for spectral axes,  Pol  for polarization data, and  Ti  for time axes. These are tracked the same was as the automatic dimension names and interact smoothly with any WCS headers. You can give an arbitrary name using as a  Dim{Symbol} , e.g.  Dim{:Velocity} . You can access AstroImages using dimension names: eagle[X=100] 1600-element AstroImage{Float32,1} with dimensions: \n  Y Sampled Base.OneTo(1600) ForwardOrdered Regular Points\nand reference dimensions: \n  X Sampled 100:100 ForwardOrdered Regular Points\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n ⋮\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0 When indexing into a slice out of a larger parent image or cube, this named access refers to the  parent  dimensions: slice1 = eagle[600:800,600:800]\nslice1[X=At(700),Y=At(700)] == eagle[X=At(700),Y=At(700)] == eagle[700,700] true"},{"id":81,"pagetitle":"Dimensions and World Coordinates","title":"Cubes","ref":"/previews/PR43/AstroImages/stable/manual/dimensions-and-world-coordinates/#Cubes","content":" Cubes Let's see how this works with a 3D cube. using AstroImages\n\nHIcube = AstroImage(download(\"http://www.astro.uvic.ca/~wthompson/astroimages/fits/HIdat.fits\")) 150×150×450 AstroImage{Float32,3} with dimensions: \n  X Sampled Base.OneTo(150) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(150) ForwardOrdered Regular Points,\n  Z Sampled Base.OneTo(450) ForwardOrdered Regular Points\n[:, :, 1]\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN  …  NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN  …  NaN  NaN  NaN  NaN  NaN  NaN  NaN\n   ⋮                        ⋮            ⋱              ⋮                 \n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN  …  NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n[and 449 more slices...] Notice how the cube is not displayed automatically. We have to pick a specific slice: HIcube[Z=228] Using  implot , the world coordinates are displayed automatically: implot(HIcube[Z=228], cmap=:turbo) The plot automatically reflects the world coordinates embeded in the file. It displays the x axis in galactic longitude, the y-axis in galactic latitude, and even shows the curved projection from pixel coordinates to galactic coordinates. The title is automatically set to the world coordinate along the Z axis in units of velocity. It also picks up the unit of the data (Kelvins) to display on the colorbar. If we pick another slice, the title updates accordingly: implot(HIcube[Z=308], cmap=:turbo) This works for other slices through the cube as well: implot(HIcube[Y=45],  cmap=:turbo, aspectratio=0.3)"},{"id":82,"pagetitle":"Dimensions and World Coordinates","title":"Custom Dimensions","ref":"/previews/PR43/AstroImages/stable/manual/dimensions-and-world-coordinates/#Custom-Dimensions","content":" Custom Dimensions julia> img = load(\"img.fits\",1,(Y=1:1600,Z=1:1600))\n1600×1600 AstroImage{Float32,2} with dimensions:\n  Y Sampled 1:1600 ForwardOrdered Regular Points,\n  Z Sampled 1:1600 ForwardOrdered Regular Points Other useful dimension names are  Spec  for spectral axes,  Pol  for polarization data, and  Ti  for time axes. These are tracked the same was as the automatic dimension names and interact smoothly with any WCS headers. Often times we have images or cubes that we want to index with physical coordinates where setting up a full WCS transform is overkill. In these cases, it's easier to leverage custom dimensions. For example, one may wish to  julia> img = load(\"img.fits\",1,(X=801:2400,Y=1:2:3200))\n1600×1600 AstroImage{Float32,2} with dimensions:\n  X Sampled 801:2400 ForwardOrdered Regular Points,\n  Y Sampled 1:2:3199 ForwardOrdered Regular Points\n... Unlike OffsetArrays, the usual indexing remains so  img[1,1]  is still the bottom left of the image; however, data can be looked up according to the offset dimensions using specifiers: julia> img[X=Near(2000),Y=1..100]\n50-element AstroImage{Float32,1} with dimensions:\n  Y Sampled 1:2:99 ForwardOrdered Regular Points\nand reference dimensions:\n  X Sampled 2000:2000 ForwardOrdered Regular Points\n  0.0 You can adjust the center of an image's dimensions using  recenter : eagle_cen = recenter(eagle, 801, 801); Unlike an OffsetArray,  eagle_cen[1,1]  still refers to the bottom left of the image. This also has no effect on broadcasting,  eagle_cen .+ ones(1600,1600)  is perfectly valid. However, we see the new centered dimensions when we go to plot the image: implot(eagle_cen, wcsticks=false) And we can query positions using the offset dimensions: implot(eagle_cen[X=-300..300, Y=-300..300], wcsticks=false)"},{"id":85,"pagetitle":"Displaying Images","title":"Displaying Images","ref":"/previews/PR43/AstroImages/stable/manual/displaying-images/#Displaying-Images","content":" Displaying Images The  imview  and  implot  functions are very similar.  Both allow any abstract array of numbers to be rendered into an image or a Plots.jl image series.  implot  is largely a superset of  imview  because it also supports colorbars, tick marks, WCS grid lines, overplotting other data & shapes, and automatic axis and title naming (from the FITS header if available)."},{"id":86,"pagetitle":"Displaying Images","title":"imview","ref":"/previews/PR43/AstroImages/stable/manual/displaying-images/#imview","content":" imview Any AbstractArray (including an AstroImage) can be displayed using  imview . This function renders an arbitrary array into an array of  RGBA  values using a number of parameters. If the input is an AstroImage{<:Number}, an AstroImage{RGBA} will be returned that retains headers, WCS information, etc. The defaults for the  imview  function are: img = randn(50,50);\nimview(img; clims=Percent(99.5), cmap=:magma, stretch=identity, contrast=1.0, bias=0.5) We can adjust the color limits explicitly: imview(img; clims=(-1, 1)) Or pass a function/callable object to calculate them for us: imview(img; clims=Zscale()) We can turn off the colormap and use it in grayscale mode: imview(img; cmap=nothing) Pass any color scheme from ColorSchemes.jl: imview(img; cmap=:ice) imview(img; cmap=:seaborn_rocket_gradient) Or an RGB or named color value: imview(img; cmap=\"#F00\")\nimview(img; cmap=\"red\") Let's now switch to an astronomical image: fname = download(\n    \"http://www.astro.uvic.ca/~wthompson/astroimages/fits/656nmos.fits\",\n    \"eagle-656nmos.fits\"\n);\neagle = AstroImage(\"eagle-656nmos.fits\") We can apply a non-linear stretch like a log-scale, power-scale, or asinh stretch: imview(eagle, stretch=asinhstretch) Once rendered, we can also tweak the bias and contrast: imview(eagle, stretch=asinhstretch, contrast=1.5) imview(eagle, stretch=asinhstretch, contrast=1.5, bias=0.6) These are the parameters that change when you click and drag in some applications like DS9. Once rendered via  imview , the resulting image can be saved in traditional image formats like PNG, JPG, GIF, etc: save(\"out.png\", imview(eagle, cmap=:viridis)) Very large Images are automatically downscaled to ensure consistent performance using  restrict  from Images.jl. This function filters the data before downscaling to prevent aliasing, so it may take a moment for truly huge images. In these cases, a faster method that doesn't prevent aliasing would be  imview(img[begin:10:end, begin:10:end])  or similar. imview  is called automatically on  AstroImage{<:Number}  when using a Julia environment with rich graphical IO capabilities (e.g. VSCode, Jupyter, Pluto, etc.). The defaults for this case can be modified using  AstroImages.set_clims!(...) ,  AstroImages.set_cmap!(...) , and  AstroImages.set_stretch!(...) ."},{"id":87,"pagetitle":"Displaying Images","title":"Note on Views","ref":"/previews/PR43/AstroImages/stable/manual/displaying-images/#Note-on-Views","content":" Note on Views The function  imview  has its name because it produces a \"view\" into the image. The result from calling  imview  is an object that lazily maps data values into RGBA colors on the fly. This means that if you change the underlying data array, the view will update (the next time it is shown). If you have many data files to render, you may find it faster to create a single  imview  and then mutate the data in the underlying array. This is faster since  imview  only has to resolve colormaps and compute limits once. For example: data = randn(100,100)\niv = imview(data)\ndisplay(iv)\ndata[1:50,1:50] .= 0\ndisplay(iv) iv  will reflect the changes to  data  when it is displayed the second time."},{"id":88,"pagetitle":"Displaying Images","title":"implot","ref":"/previews/PR43/AstroImages/stable/manual/displaying-images/#implot","content":" implot implot   is a Plots.jl recipe, which means before you can use it you first have to load  Plots.jl : using Plots implot  accepts all the arguments  imview  does for controlling how data is rendered to the screen. implot(img; clims=Percent(99.5), cmap=:magma, stretch=identity, contrast=1.0, bias=0.5)"},{"id":91,"pagetitle":"Getting Started","title":"Getting Started","ref":"/previews/PR43/AstroImages/stable/manual/getting-started/#Getting-Started","content":" Getting Started To get started, you will first need to install AstroImages. After starting Julia, enter package-mode by typing  ]  and then pkg> add AstroImages To display images and save them in traditional graphics formats like PNG, JPG, GIF, etc., you will also need to add the  ImageIO  package. Once installed, this package doesn't need to be loaded explicitly. For some of the more advanced visualizations you may also want  Plots : pkg> add Plots To load the package, run: using AstroImages\n# And if desired:\nusing Plots"},{"id":94,"pagetitle":"Headers","title":"Headers","ref":"/previews/PR43/AstroImages/stable/manual/headers/#Headers","content":" Headers FITS files consist of one or more HDUs (header data units), and each HDU can contain an N-dimensional image or table. Before the data is a  header . Headers contain (key, value, comment) groups as well as dedicated long-form COMMENT and HISTORY sections used to document, for example, the series of post-processing steps applied to an image."},{"id":95,"pagetitle":"Headers","title":"Accessing Headers","ref":"/previews/PR43/AstroImages/stable/manual/headers/#Accessing-Headers","content":" Accessing Headers Here are some examples of how to set and read keys, comments, and history. Well start by making a blank image. img = AstroImage(zeros(10,10))\n# Set keys to values with different data types\nimg[\"KEY1\"] = 2   # Integer\nimg[\"KEY2\"] = 2.0 # Float\nimg[\"KEY3\"] = \"STRING\"\nimg[\"KEY4\"] = true\nimg[\"KEY5\"] = false\nimg[\"KEY6\"] = nothing\n\n# Set comments\nimg[\"KEY1\", Comment] = \"A key with an integer value\"\n\n# Read keys\na = img[\"KEY3\"]\n\n# Read comment\ncom = img[\"KEY1\", Comment]\n\n# Add long-form COMMENT\npush!(img, Comment, \"\"\"\nWe now describe how to add a long form comment to the end of a header.\n\"\"\")\n\n# Add HISTORY entry\npush!(img, History, \"\"\"\nWe now describe how to add a long form history to the end of a header.\n\"\"\")\n\n# Retrieve long form comments/ history\ncomment_strings = img[Comment]\nhistory_strings = img[History] Note that floating point values are formatted as ASCII strings when written to the FITS files, so the precision may be limited.  AstroImage  objects wrap a FITSIO.jl  FITSHeader . If necessary, you can recover it using  header(img) ; however, in most cases you can access header keywords directly from the image. API docs:  Comment History header"},{"id":98,"pagetitle":"Loading & Saving Images","title":"Loading Images","ref":"/previews/PR43/AstroImages/stable/manual/loading-images/#Loading-Images","content":" Loading Images FITS (Flexible Image Transport System) files can be loaded and saved using AstroImages thanks to the FITSIO package. AstroImages is registered with  FileIO , so if you have FileIO and AstroImages installed you can get started with the  load  function. When you pass a file name with the appropriate file extension (\".fits\", \".fit\", etc.) FileIO will import AstroImages automatically. Alternatively, you can use the  AstroImage  contructor instead of load. This will work on fits files with any file extension, including compressed files (e.g. \".fits.gz\"). julia> img = load(\"myfitsimg.fits\")\n1600×1600 AstroImage{Float32,2} with dimensions:\n  X Sampled Base.OneTo(1600) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(1600) ForwardOrdered Regular Points\n 0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n ⋮                        ⋱\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0 Note: if you are in an interactive environment like VSCode, Jupyter, or Pluto, instead of a REPL, AstroImages are automatically rendered to images and displayed. You can see this plain text output by explicitly calling:  show(stdout, MIME(\"text/plain\"), img) . Or:  julia> img = AstroImage(\"myfitsimg.fits.gz\")\n1600×1600 AstroImage{Float32,2} with dimensions:\n  X Sampled Base.OneTo(1600) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(1600) ForwardOrdered Regular Points\n 0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n ⋮                        ⋱\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0 A FITS file can contain multiple N-dimensional images and tables. When you call load or AstroImage with a file name and no other arguments, the package will search through the file and return the first image HDU. That is, it will skip any FITS tables or empty HDUs with only headers. You can also specify an HDU number explicitly: julia> img = load(\"myfitsimg.fits\",1)\n1600×1600 AstroImage{Float32,2} with dimensions:\n  X Sampled Base.OneTo(1600) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(1600) ForwardOrdered Regular Points\n... This way, you can load specific images from multi-extension files. You can load all HDUs simultaneously by passing  : : julia> hdus = load(\"multiext.fits\", :);\njulia> hdus[2] # Second HDU as an AstroImage\n10×10 AstroImage{Float64,2} with dimensions:\n  X Sampled Base.OneTo(10) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(10) ForwardOrdered Regular Points\n -0.777315  -1.36683   -0.580179     1.39629      …  -2.14298     0.450059   0.432065\n -1.09619    0.789249   0.938415     0.959903        -0.88995    -1.29406   -0.4291\n  0.47427   -1.41855    0.814823    -1.15975          0.0427149  -1.20116   -0.0920709\n -0.179858  -1.60228    1.09648     -0.497927        -1.31824    -0.156529  -0.0223846\n  2.64162    0.131437   0.320476     0.331197        -0.914713   -1.55162   -0.18862\n  0.209669  -1.17923   -0.656512     0.000775311  …   0.377461   -0.24278    0.967202\n  1.01442   -0.762895  -2.13238     -0.456932        -0.415733   -1.21416   -1.6108\n  0.385626   0.389335  -0.00726015   0.309936        -0.533175    0.157878   0.100876\n -1.24799    0.461216  -0.868826    -0.255654        -0.37151     0.49479   -1.87129\n  1.39356    2.29254    0.0548325    1.50674         -0.0880865   0.580978  -1.81629\njulia> # Or:\njulia> hdu1, hdu2, hdu3 = load(\"multiext.fits\", :); There is also limited support for table HDUs. In this case, a bare-bones Tables.jl compatible  object is returned."},{"id":99,"pagetitle":"Loading & Saving Images","title":"Dimension Names","ref":"/previews/PR43/AstroImages/stable/manual/loading-images/#Dimension-Names","content":" Dimension Names You may have noticed the entries above the image array: 10×10 AstroImage{Float64,2} with dimensions:\n  X Sampled Base.OneTo(10) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(10) ForwardOrdered Regular Points AstroImages are based on  Dimensional Data . Each axis is assigned a dimension name and the indices are tracked. The automatic dimension names are  X ,  Y ,  Z ,  Dim{4} ,  Dim{5} , and so on; however you can pass in other names or orders to the load function and/or AstroImage contructor: julia> img = load(\"img.fits\",1,(Y=1:1600,Z=1:1600))\n1600×1600 AstroImage{Float32,2} with dimensions:\n  Y Sampled 1:1600 ForwardOrdered Regular Points,\n  Z Sampled 1:1600 ForwardOrdered Regular Points Other useful dimension names are  Spec  for spectral axes,  Pol  for polarization data, and  Ti  for time axes. These will be further discussed in Dimensions and World Coordinates."},{"id":100,"pagetitle":"Loading & Saving Images","title":"Saving Images","ref":"/previews/PR43/AstroImages/stable/manual/loading-images/#Saving-Images","content":" Saving Images You can save one or more AstroImages and tables to a FITS file using the  save  function: julia> save(\"abc.fits\", astroimage1, astroimage2, table1) You can also save individual images to traditional graphics formats by first rendering them with  imview  (for more on imview, see Displaying Images). julia> save(\"abc.png\", imview(astroimage1)) You can save animated GIFs by saving a 3D datacube that has been rendered with imview: julia> cube =  imview(AstroImage(randn(100,100,10)));\njulia> save(\"abc.gif\", cube, fps=10)\n\njulia> # Or a more complex example (changing color schemes each frame)\njulia> img = randn(10,10)\njulia> cube2 = [imview(img1, cmap=:magma) ;;; imview(img2, cmap=:plasma) ;;; imview(img3, cmap=:viridis)]\njulia> # Alternative syntax:\njulia> cube2 = cat(imview(img1, cmap=:magma), imview(img2, cmap=:plasma), imview(img3, cmap=:viridis), dims=3)\njulia> save(\"abc.gif\", cube, fps=10)"},{"id":105,"pagetitle":"Preserving Wrapper","title":"Preserving the AstroImage Wrapper","ref":"/previews/PR43/AstroImages/stable/manual/preserving-wrapper/#Preserving-the-AstroImage-Wrapper","content":" Preserving the AstroImage Wrapper Wherever possible, overloads have been added to DimensionalData and AstroImages so that common operations retain the  AstroImage  wrapper with associated dimensions, FITS header, and WCS information. Most of the time this works automatically if libraries follow good patterns like allocating outputs using  Base.similar . However, some other library functions may follow patterns like allocating a plain  Array  of the correct size and then filling it.  To make it easier to work with these libraries, AstroImages exports two functions  copyheader  and  shareheader .  These functions wrap an AbstractArray in an AstroImage while copying over the header, dimensions, and WCS info. Consider the function: function badfunc(arr)\n    out = zeros(size(arr)) # instead of similar(arr)\n    out .= arr.^2\n    return out\nend Calling  badfunc(astroimg)  will return a plain  Array  . We can use  copyheader  to retain the  AstroImage  wrapper: copyheader(astroimg, badfunc(astroimg)) For particularly incompatible functions that require an Array (not subtype of AbstractArray) we can go one step further: copyheader(astroimg, worsefunc(parent(astroimg)))\n# Or:\ncopyheader(astroimg, worsefunc(collect(astroimg)))"},{"id":112,"pagetitle":"Introduction","title":"FITSIO.jl","ref":"/previews/PR43/FITSIO/stable/#FITSIO.jl","content":" FITSIO.jl A  Julia  package for reading and writing Flexible Image Transport System (FITS) files, based on the  cfitsio  library. The interface is inspired by Erin Sheldon's  fitsio  Python package. Warning The  Libcfitsio  submodule has been moved to  CFITSIO.jl  and will be deprecated in a future release."},{"id":113,"pagetitle":"Introduction","title":"Installation","ref":"/previews/PR43/FITSIO/stable/#Installation","content":" Installation FITSIO.jl  can be installed using the built-in package manager pkg> add FITSIO"},{"id":114,"pagetitle":"Introduction","title":"Usage","ref":"/previews/PR43/FITSIO/stable/#Usage","content":" Usage To open an existing file for reading: julia> using FITSIO\n\njulia> f = FITS(\"file.fits\")\nFile: file.fits\nMode: \"w\" (read-write)\nHDUs: Num  Name  Type\n      1          Image\n      2          Table (At the REPL, information about the file contents is shown.) A FITS file consists of one or more header-data units (HDUs), concatenated one after the other. The  FITS  object therefore is represented as a collection of these HDUs. Get information about the first HDU: julia> f[1]\nFile: file.fits\nHDU: 1\nType: Image\nDatatype: Float64\nDatasize: (800, 800) Iterate over HDUs in the file: julia> for hdu in f; println(typeof(hdu)); end\nFITSIO.ImageHDU\nFITSIO.TableHDU Each HDU can contain image data, or table data (either binary or ASCII-formatted). For image extensions, get the size of the image without reading it: julia> ndims(f[1])\n    2\n\njulia> size(f[1])\n(800,800)\n\njulia> size(f[1], 2)\n800 Read an image from disk: julia> data = read(f[1]);  # read an image from disk\n\njulia> data = read(f[1], :, 790:end);  # read just a subset of image Show info about a binary table: julia> f[2]\nFile: file.fits\nHDU: 2\nType: Table\nRows: 20\nColumns: Name  Size  Type    TFORM\n         col2        String  5A\n         col1        Int64   1K Read a column from the table: julia> data = read(f[2], \"col1\") Table HDUs implement the  Tables.jl  interface, so you can load them into other table types, like  DataFrames . julia> df = DataFrame(f[2]) Variable length columns are not supported by the Tables.jl interface, and  Tables  methods will ignore them. Read the entire header into memory and get values from it: julia> header = read_header(f[1]);  # read the entire header from disk\n\njulia> length(header)  # total number of records in header\n17\n\njulia> haskey(header, \"NAXIS1\")  # check if a key exists\ntrue\n\njulia> header[\"NAXIS1\"]  # get value by keyword\n800\n\njulia> header[4]  # get value by position\n800\n\njulia> get_comment(header, \"NAXIS\")  # get comment for a given keyword\n\"length of data axis 1\" Read just a single header record without reading the entire header: julia> read_key(f[1], 4)  # by position\n(\"NAXIS1\",800,\"length of data axis 1\")\n\njulia> read_key(f[1], \"NAXIS1\")  # read by keyword\n(800,\"length of data axis 1\") Manipulate a header in memory: julia> header[\"NEWKEY\"] = 10  # change or add a keyword\n\njulia> set_comment!(header, \"NEWKEY\", \"this is a comment\") Close the file: julia> close(f) ( FITS  objects are also closed automatically when garbage collected.) Open a new file for writing: julia> f = FITS(\"newfile.fits\", \"w\"); The second argument can be  \"r\"  (read-only; default),  \"r+\"  (read-write) or  \"w\"  (write). In \"write\" mode, any existing file of the same name is overwritten. Write an image to the file: julia> data = reshape([1:100;], 5, 20)\n\njulia> write(f, data)  # Write a new image extension with the data\njulia> close(f) To write some header keywords in the new extension, pass a  FITSHeader  instance as a keyword:  write(f, data; header=header) Overwrite image data in an existing file: julia> f = FITS(\"newfile.fits\", \"r+\")  # Reopen the file in read-write mode\njulia> data = reshape([101:200;], 5, 20)  # Prepare new image data\njulia> image_hdu = f[1]\njulia> write(image_hdu, data)  # Overwrite the image Write a table to the file: julia> data = Dict(\"col1\"=>[1., 2., 3.], \"col2\"=>[1, 2, 3]);\n\njulia> write(f, data)  # write a new binary table to a new extension Compressed storage Setting the file extension to  .gz  will automatically use GZIP compression and save on storage space. julia> FITS(\"abc.fits\", \"w\") do f # save the image uncompressed\n           write(f, ones(200,200))\n       end\n\njulia> filesize(\"abc.fits\")\n325440\n\njulia> FITS(\"abc.fits.gz\", \"w\") do f # save the image compressed\n            write(f, ones(200,200))\n       end\n\njulia> filesize(\"abc.fits.gz\")\n2117 Alternately the compression algorithm might be specified in square brackets after the filename. Check the  CFITSIO website  for the details of this usage. julia> FITS(\"abc.fits[compress R 100,100]\", \"w\") do f # Rice algorithm with a 100 x 100 pixel tile size\n           write(f, ones(200,200))\n       end\n\njulia> filesize(\"abc.fits\")\n8640 Warn Compression is \"loss-less\" for images with integer pixel values, and might be lossy for floating-point images."},{"id":117,"pagetitle":"API Reference","title":"API Reference","ref":"/previews/PR43/FITSIO/stable/api/#API-Reference","content":" API Reference"},{"id":118,"pagetitle":"API Reference","title":"File operations","ref":"/previews/PR43/FITSIO/stable/api/#File-operations","content":" File operations"},{"id":119,"pagetitle":"API Reference","title":"FITSIO.FITS","ref":"/previews/PR43/FITSIO/stable/api/#FITSIO.FITS","content":" FITSIO.FITS  —  Type FITS(filename::String[, mode::String = \"r\"]; extendedparser = true) Open or create a FITS file.  mode  can be one of  \"r\"  (read-only),  \"r+\"  (read-write) or  \"w\"  (write). In \"write\" mode, any existing file of the same name is overwritten. A  FITS  object is a collection of \"Header-Data Units\" (HDUs) and supports the following operations: f[i] : Return the  i -th HDU. f[name]  or  f[name, ver] : Return the HDU containing the given the given EXTNAME (or HDUNAME) keyword (a String), and optionally the given EXTVER (or HDUVER) number (an Integer). Iteration: for hdu in f\n    ...\nend The keyword argument  extendedparser  may be used to enable or disable the  extended filename parser . If disabled,  filename  is treated exactly as the name of the file and is not tokenized into parameters. source"},{"id":120,"pagetitle":"API Reference","title":"Base.length","ref":"/previews/PR43/FITSIO/stable/api/#Base.length","content":" Base.length  —  Function length(f::FITS) Number of HDUs in the file. source length(hdr::FITSHeader) Number of records in header of HDU. source length(hdu::ImageHDU) Get total number of pixels in image (product of  size(hdu) ). source"},{"id":121,"pagetitle":"API Reference","title":"Base.close","ref":"/previews/PR43/FITSIO/stable/api/#Base.close","content":" Base.close  —  Function close(f::FITS) Close the file. Subsequent attempts to operate on  f  will result in an error.  FITS  objects are also automatically closed when they are garbage collected. source"},{"id":122,"pagetitle":"API Reference","title":"Base.deleteat!","ref":"/previews/PR43/FITSIO/stable/api/#Base.deleteat!","content":" Base.deleteat!  —  Function deleteat!(f::FITS, i::Integer) Delete the HDU at index  i  in the FITS file. If  i == 1 , this deletes the primary HDU and replaces it with a bare HDU with no data and a minimal header. If  i > 1 , this removes the HDU at index  i  and moves the following HDUs forward. source"},{"id":123,"pagetitle":"API Reference","title":"Header operations","ref":"/previews/PR43/FITSIO/stable/api/#Header-operations","content":" Header operations"},{"id":124,"pagetitle":"API Reference","title":"FITSIO.read_key","ref":"/previews/PR43/FITSIO/stable/api/#FITSIO.read_key","content":" FITSIO.read_key  —  Function read_key(hdu::HDU, key::String) -> (value, comment) Read the HDU header record specified by keyword and return a tuple where  value  is the keyword parsed value (of type  String ,  Bool ,  Int ,  Float64  or  Nothing ),  comment  is the keyword comment (as a string). Throw an error if  key  is not found. source read_key(hdu::HDU, key::Integer) -> (keyname, value, comment) Same as  above  but FITS card is specified by its position and returns a 3 element tuple where  keyname  is the keyword name (a string). source"},{"id":125,"pagetitle":"API Reference","title":"FITSIO.write_key","ref":"/previews/PR43/FITSIO/stable/api/#FITSIO.write_key","content":" FITSIO.write_key  —  Function write_key(hdu::HDU, key::String, value[, comment]) Write a keyword value the HDU's header.  value  can be a standard header type ( String ,  Bool ,  Integer ,  AbstractFloat ) or  nothing , in which case the value part of the record will be empty. If the keyword already exists, the value will be overwritten. The comment will only be overwritten if given. If the keyword does not already exist, a new record will be appended at the end of the header. source"},{"id":126,"pagetitle":"API Reference","title":"FITSIO.read_header","ref":"/previews/PR43/FITSIO/stable/api/#FITSIO.read_header","content":" FITSIO.read_header  —  Function read_header(filename::AbstractString, hduindex = 1) -> FITSHeader Convenience function to read the entire header corresponding to the HDU at index  hduindex  contained in the FITS file named  filename . Functionally  read_header(filename, hduindex)  is equivalent to FITS(filename, \"r\") do f\n    read_header(f[hduindex])\nend source read_header(hdu::HDU) -> FITSHeader Read the entire header from the given HDU and return a  FITSHeader  object. The value of each header record is parsed as  Int ,  Float64 ,  String ,  Bool  or  nothing  according to the FITS standard. If the value cannot be parsed according to the FITS standard, the value is stored as the raw unparsed  String . source read_header(hdu::HDU, String) -> String Read the entire header from the given HDU as a single string. source"},{"id":127,"pagetitle":"API Reference","title":"FITSIO.FITSHeader","ref":"/previews/PR43/FITSIO/stable/api/#FITSIO.FITSHeader","content":" FITSIO.FITSHeader  —  Type FITSHeader(keys::Vector{String}, values::Vector, comments::Vector{String}) An in-memory representation of the header of an HDU. It stores the (key, value, comment) information for each 80-character \"card\" in a header. Note that this structure is not linked to a FITS file in any way; it is just a convenient structure for storing the header contents after reading from a file. (This is similar to how an  Array  returned by  read(f[1])  is not linked to the FITS file  f .)  Manipulating a  FITSHeader  will therefore have no immediate impact on any file, even if it was created by  read_header(::HDU) .  You can, however, write a  FITSHeader  to a file using the  write(::FITS, ...)  methods that append a new HDU to a file. source"},{"id":128,"pagetitle":"API Reference","title":"Base.length","ref":"/previews/PR43/FITSIO/stable/api/#Base.length-Tuple{FITSHeader}","content":" Base.length  —  Method length(hdr::FITSHeader) Number of records in header of HDU. source"},{"id":129,"pagetitle":"API Reference","title":"Base.haskey","ref":"/previews/PR43/FITSIO/stable/api/#Base.haskey-Tuple{FITSHeader, String}","content":" Base.haskey  —  Method haskey(hdr::FITSHeader, key::String) Returns true if  key  exists in header, otherwise false. source"},{"id":130,"pagetitle":"API Reference","title":"Base.keys","ref":"/previews/PR43/FITSIO/stable/api/#Base.keys-Tuple{FITSHeader}","content":" Base.keys  —  Method keys(hdr::FITSHeader) Array of keywords in header of HDU (not a copy). source"},{"id":131,"pagetitle":"API Reference","title":"Base.values","ref":"/previews/PR43/FITSIO/stable/api/#Base.values-Tuple{FITSHeader}","content":" Base.values  —  Method values(hdr::FITSHeader) Array of values in header of HDU (not a copy). source"},{"id":132,"pagetitle":"API Reference","title":"FITSIO.get_comment","ref":"/previews/PR43/FITSIO/stable/api/#FITSIO.get_comment","content":" FITSIO.get_comment  —  Function get_comment(hdr::FITSHeader, key_or_index::Union{String,Integer}) Get the comment based on keyword or index. source"},{"id":133,"pagetitle":"API Reference","title":"FITSIO.set_comment!","ref":"/previews/PR43/FITSIO/stable/api/#FITSIO.set_comment!","content":" FITSIO.set_comment!  —  Function set_comment!(hdr::FITSHeader, key_or_index::Union{String,Integer}, comment::String) Set the comment based on keyword or index. source"},{"id":134,"pagetitle":"API Reference","title":"FITSIO.default_header","ref":"/previews/PR43/FITSIO/stable/api/#FITSIO.default_header","content":" FITSIO.default_header  —  Function default_header(data::AbstractArray) Creates a default header for the given array with the  SIMPLE ,  BITPIX ,  NAXIS ,  NAXIS* , and  EXTEND  entries. source"},{"id":135,"pagetitle":"API Reference","title":"Image operations","ref":"/previews/PR43/FITSIO/stable/api/#Image-operations","content":" Image operations"},{"id":136,"pagetitle":"API Reference","title":"Base.read","ref":"/previews/PR43/FITSIO/stable/api/#Base.read-Tuple{ImageHDU}","content":" Base.read  —  Method read(hdu::ImageHDU)\nread(hdu::ImageHDU, range...) Read the data array or a subset thereof from disk. The first form reads the entire data array. The second form reads a slice of the array given by the specified ranges or integers. Dimensions specified by integers will be dropped in the returned array, while those specified by ranges will be retained. Note Julia follows a column-major array indexing convention, so the indices provided must account for this. In particular this means that FITS files created externally following a row-major convention (eg. using astropy) will have the sequence of axes flipped when read in using FITSIO. source"},{"id":137,"pagetitle":"API Reference","title":"Base.read!","ref":"/previews/PR43/FITSIO/stable/api/#Base.read!","content":" Base.read!  —  Function read!(hdu::ImageHDU, A::StridedArray)\nread!(hdu::ImageHDU, A::StridedArray, range...) Read the data or a subset thereof from disk, and save it in a pre-allocated output array  A . The first form reads the entire data from disk. The second form reads a slice of the array given by the specified ranges or integers. The array  A  needs to have the same length as the number of elements to be read in. Additionally  A  needs to be stored contiguously in memory. Note Julia follows a column-major array indexing convention, so the indices provided must account for this. In particular this means that FITS files created externally following a row-major convention (eg. using astropy) will have the sequence of the axes flipped when read in using FITSIO. source"},{"id":138,"pagetitle":"API Reference","title":"FITSIO.fitsread","ref":"/previews/PR43/FITSIO/stable/api/#FITSIO.fitsread","content":" FITSIO.fitsread  —  Function fitsread(filename::AbstractString[, hduindex = 1[, arrayindices...]]; extendedparser = true) Convenience function to read in an image corresponding to the HDU at index  hduindex  contained in the FITS file named  filename . If  arrayindices  are provided, only a slice of the image corresponding to the indices is read in. Functionally  fitsread(filename, hduindex, arrayindices...; extendedparser)  is equivalent to FITS(filename, \"r\"; extendedparser = extendedparser) do f\n    read(f[hduindex], arrayindices...)\nend The keyword argument  extendedparser  may be used to enable or disable the  extended filename parser . If disabled,  filename  is treated exactly as the name of the file and is not tokenized into parameters. Note Julia follows a column-major array indexing convention, so the indices provided must account for this. In particular this means that FITS files created externally following a row-major convention (eg. using astropy) will have the sequence of axes flipped when read in using FITSIO. See also:  read source"},{"id":139,"pagetitle":"API Reference","title":"Base.write","ref":"/previews/PR43/FITSIO/stable/api/#Base.write-Tuple{FITS, StridedArray{<:Real}}","content":" Base.write  —  Method write(f::FITS, data::StridedArray{<:Real}; header=nothing, name=nothing, ver=nothing) Add a new image HDU to FITS file  f  with contents  data . The following array element types are supported:  UInt8 ,  Int8 ,  UInt16 ,  Int16 ,  UInt32 ,  Int32 ,  Int64 ,  Float32 ,  Float64 . If a  FITSHeader  object is passed as the  header  keyword argument, the header will also be added to the new HDU. The data to be written out must be stored contiguously in memory. Unsupported element types It might be possible to write out an array with an element type other than those mentioned above by  reinterpret ing it as one that is supported. For example, to write out a  Complex  array and read it back in, we may use julia> a = rand(ComplexF64, 2)\n2-element Array{Complex{Float64},1}:\n 0.4943325325752195 + 0.2034650017475852im\n 0.2495752009567498 + 0.819163869249041im\n\n# We may write this out as Float64\njulia> FITSIO.fitswrite(\"temp.fits\", reinterpret(Float64, a))\n\n# reinterpret it back as a complex one while reading it in\njulia> reinterpret(ComplexF64, FITSIO.fitsread(\"temp.fits\"))\n2-element reinterpret(Complex{Float64}, ::Array{Float64,1}):\n 0.4943325325752195 + 0.2034650017475852im\n 0.2495752009567498 + 0.819163869249041im While this often works in practice, such a workaround is not officially supported by FITSIO, and care must be taken to ensure the correctness of data. source"},{"id":140,"pagetitle":"API Reference","title":"Base.write","ref":"/previews/PR43/FITSIO/stable/api/#Base.write-Tuple{ImageHDU, StridedArray{<:Real}}","content":" Base.write  —  Method write(hdu::ImageHDU, data::StridedArray{<:Real}) Write data to an existing image HDU. The data to be written out must be stored contiguously in memory. source"},{"id":141,"pagetitle":"API Reference","title":"FITSIO.fitswrite","ref":"/previews/PR43/FITSIO/stable/api/#FITSIO.fitswrite","content":" FITSIO.fitswrite  —  Function fitswrite(filename::AbstractString, data; extendedparser = true, kwargs...) Convenience function to write the image array  data  to a file named  filename . Functionally  fitswrite(filename, data; extendedparser, kwargs...)  is equivalent to FITS(filename, \"w\"; extendedparser = extendedparser) do f\n    write(f, data; kwargs...)\nend The keyword argument  extendedparser  may be used to enable or disable the  extended filename parser . If disabled,  filename  is treated exactly as the name of the file and is not tokenized into parameters. Warning Existing files with the same name will be overwritten. See also:  write source"},{"id":142,"pagetitle":"API Reference","title":"Base.eltype","ref":"/previews/PR43/FITSIO/stable/api/#Base.eltype-Tuple{ImageHDU}","content":" Base.eltype  —  Method eltype(hdu::ImageHDU) Return the element type of the image in  hdu . source"},{"id":143,"pagetitle":"API Reference","title":"Base.ndims","ref":"/previews/PR43/FITSIO/stable/api/#Base.ndims-Tuple{ImageHDU}","content":" Base.ndims  —  Method ndims(hdu::ImageHDU) Get number of image dimensions, without reading the image into memory. source"},{"id":144,"pagetitle":"API Reference","title":"Base.size","ref":"/previews/PR43/FITSIO/stable/api/#Base.size-Tuple{ImageHDU}","content":" Base.size  —  Method size(hdu::ImageHDU)\nsize(hdu::ImageHDU, i) Get image dimensions (or  i th dimension), without reading the image into memory. source"},{"id":145,"pagetitle":"API Reference","title":"Base.length","ref":"/previews/PR43/FITSIO/stable/api/#Base.length-Tuple{ImageHDU}","content":" Base.length  —  Method length(hdu::ImageHDU) Get total number of pixels in image (product of  size(hdu) ). source"},{"id":146,"pagetitle":"API Reference","title":"FITSIO.copy_section","ref":"/previews/PR43/FITSIO/stable/api/#FITSIO.copy_section","content":" FITSIO.copy_section  —  Function copy_section(hdu, dest, r...) Copy a rectangular section of an image and write it to a new FITS primary image or image extension in  FITS  object  dest . The new image HDU is appended to the end of  dest . All the keywords in the input image will be copied to the output image. The common WCS keywords will be updated if necessary to correspond to the coordinates of the section. Examples Copy the lower-left 200 x 200 pixel section of the image in  hdu  to an open file,  f copy_section(hdu, f, 1:200, 1:200) Same as above but only copy odd columns in y: copy_section(hdu, f, 1:200, 1:2:200) source"},{"id":147,"pagetitle":"API Reference","title":"Table operations","ref":"/previews/PR43/FITSIO/stable/api/#Table-operations","content":" Table operations"},{"id":148,"pagetitle":"API Reference","title":"FITSIO.colnames","ref":"/previews/PR43/FITSIO/stable/api/#FITSIO.colnames","content":" FITSIO.colnames  —  Function colnames(hdu) -> Vector{String} Return the names of columns in a table HDU. source"},{"id":149,"pagetitle":"API Reference","title":"Base.write","ref":"/previews/PR43/FITSIO/stable/api/#Base.write-Tuple{FITS, Dict{String}}","content":" Base.write  —  Method write(f::FITS, data::Dict;\n      hdutype=TableHDU, name=nothing, ver=nothing,\n      header=nothing, units=nothing, varcols=nothing) Create a new table extension and write data to it. If the FITS file is currently empty then a dummy primary array will be created before appending the table extension to it.  data  should be a dictionary with String keys (giving the column names) and Array values (giving data to write to each column). The following types are supported in binary tables:  UInt8 ,  Int8 ,  UInt16 ,  Int16 ,  UInt32 ,  Int32 ,  UInt64 ,  Int64 ,  Float32 ,  Float64 ,  Complex{Float32} ,  Complex{Float64} ,  String ,  Bool . Optional inputs: hdutype : Type of table extension to create. Can be either  TableHDU  (binary table) or  ASCIITableHDU  (ASCII table). name : Name of extension. ver : Version of extension (Int). header : FITSHeader instance to write to new extension. units : Dictionary mapping column name to units (as a string). varcols : An array giving the column names or column indicies to write as \"variable-length columns\". Variable length columns Variable length columns allow a column's row entries to contain arrays of different lengths. They can potentially save diskspace when the rows of a column vary greatly in length, as the column data is all written to a contiguous heap area at the end of the table. Only column data of type  Vector{String}  or types such as  Vector{Vector{UInt8}}  can be written as variable length columns. In the second case, ensure that the column data type is a  leaf type . That is, the type cannot be  Vector{Vector{T}} , which would be an array of arrays having potentially non-uniform element types (which would not be writable as a FITS table column). source"},{"id":150,"pagetitle":"API Reference","title":"Base.write","ref":"/previews/PR43/FITSIO/stable/api/#Base.write-Tuple{FITS, Vector{String}, Vector}","content":" Base.write  —  Method write(f::FITS, colnames, coldata;\n      hdutype=TableHDU, name=nothing, ver=nothing,\n      header=nothing, units=nothing, varcols=nothing) Same as  write(f::FITS, data::Dict; ...)  but providing column names and column data as a separate arrays. This is useful for specifying the order of the columns. Column names must be  Vector{String}  and column data must be a vector of arrays. source"},{"id":151,"pagetitle":"API Reference","title":"Base.read","ref":"/previews/PR43/FITSIO/stable/api/#Base.read-Tuple{TableHDU, String}","content":" Base.read  —  Method read(hdu::TableHDU, colname; case_sensitive=true) Read a column as an array from the given table HDU. The column name may contain wild card characters ( * ,  ? , or  # ). The  *  wild card character matches any sequence of characters (including zero characters) and the  ?  character matches any single character. The  #  wildcard will match any consecutive string of decimal digits (0-9). The string must match a unique column.  The optional boolean keyword  case_sensitive ,  true  by default, specifies whether the column name is to be considered case sensitive. Array order Julia arrays are column-major (like Fortran), not row-major (like C and numpy), so elements of multi-dimensional columns will be the transpose of what you get with astropy. source"},{"id":154,"pagetitle":"Home","title":"CFITSIO.jl","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.jl","content":" CFITSIO.jl This module provides an interface familiar to users of the  CFITSIO  C library. It can be used with using CFITSIO The functions exported by this module operate on  FITSFile  objects, which is a thin wrapper around a pointer to a CFITSIO  fitsfile .  For the most part, the functions are thin wrappers around the CFITSIO routines of the same names. Typically, they: Convert from Julia types to C types as necessary. Check the returned status value and raise an appropriate exception if non-zero. The following tables give the correspondances between CFITSIO \"types\", the BITPIX keyword and Julia types."},{"id":155,"pagetitle":"Home","title":"Type Conversions","ref":"/previews/PR43/CFITSIO/stable/#Type-Conversions","content":" Type Conversions"},{"id":156,"pagetitle":"Home","title":"CFITSIO Types","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO-Types","content":" CFITSIO Types CODE CFITSIO Julia int Cint long Clong LONGLONG Int64"},{"id":157,"pagetitle":"Home","title":"FITS BITPIX","ref":"/previews/PR43/CFITSIO/stable/#FITS-BITPIX","content":" FITS BITPIX CODE CFITSIO Julia 8 BYTE_IMG Uint8 16 SHORT_IMG Int16 32 LONG_IMG Int32 64 LONGLONG_IMG Int64 -32 FLOAT_IMG Float32 -64 DOUBLE_IMG Float64"},{"id":158,"pagetitle":"Home","title":"CFITSIO Aliases","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO-Aliases","content":" CFITSIO Aliases CODE CFITSIO Julia Comments 10 SBYTE_IMG Int8 written as: BITPIX = 8, BSCALE = 1, BZERO = -128 20 USHORT_IMG Uint16 written as: BITPIX = 16, BSCALE = 1, BZERO = 32768 40 LONG_IMG Uint32 written as: BITPIX = 32, BSCALE = 1, BZERO = 2147483648"},{"id":159,"pagetitle":"Home","title":"FITS Table Data Types","ref":"/previews/PR43/CFITSIO/stable/#FITS-Table-Data-Types","content":" FITS Table Data Types CODE CFITSIO Julia 1 TBIT 11 TBYTE Cuchar ,  Uint8 12 TSBYTE Cchar ,  Int8 14 TLOGICAL Bool 16 TSTRING String 20 TUSHORT Cushort 21 TSHORT Cshort 30 TUINT Cuint 31 TINT Cint 40 TULONG Culong 41 TLONG Clong 42 TFLOAT Cfloat 81 TLONGLONG Int64 82 TDOUBLE Cdouble 83 TCOMPLEX Complex{Cfloat} 163 TDBLCOMPLEX Complex{Cdouble}"},{"id":160,"pagetitle":"Home","title":"CFITSIO.bitpix_from_type","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.bitpix_from_type","content":" CFITSIO.bitpix_from_type  —  Function bitpix_from_type(::Type) -> Cint Return the FITS BITPIX code for the given Julia type source"},{"id":161,"pagetitle":"Home","title":"CFITSIO.type_from_bitpix","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.type_from_bitpix","content":" CFITSIO.type_from_bitpix  —  Function type_from_bitpix(::Integer) -> Type Return the Julia type from the FITS BITPIX code source"},{"id":162,"pagetitle":"Home","title":"CFITSIO.cfitsio_typecode","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.cfitsio_typecode","content":" CFITSIO.cfitsio_typecode  —  Function cfitsio_typecode(::Type) -> Cint Return the CFITSIO type code for the given Julia type source"},{"id":163,"pagetitle":"Home","title":"File access","ref":"/previews/PR43/CFITSIO/stable/#File-access","content":" File access"},{"id":164,"pagetitle":"Home","title":"CFITSIO.fits_create_file","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_create_file","content":" CFITSIO.fits_create_file  —  Function fits_create_file(filename::AbstractString) Create and open a new empty output  FITSFile . This methods uses the  extended file name syntax  to create the file. See also  fits_create_diskfile  which does not use the extended filename parser. source"},{"id":165,"pagetitle":"Home","title":"CFITSIO.fits_create_diskfile","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_create_diskfile","content":" CFITSIO.fits_create_diskfile  —  Function fits_create_diskfile(filename::AbstractString) Create and open a new empty output  FITSFile . Unlike  fits_create_file , this function does not use an extended filename parser and treats the string as is as the filename. source"},{"id":166,"pagetitle":"Home","title":"CFITSIO.fits_clobber_file","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_clobber_file","content":" CFITSIO.fits_clobber_file  —  Function fits_clobber_file(filename::AbstractString) Like  fits_create_file , but overwrites  filename  if it exists. source"},{"id":167,"pagetitle":"Home","title":"CFITSIO.fits_open_file","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_open_file","content":" CFITSIO.fits_open_file  —  Function fits_open_file(filename::String, [mode = 0]) Open an existing data file. Modes: 0 : Read only (equivalently denoted by  CFITSIO.R ) 1 : Read-write (equivalently denoted by  CFITSIO.RW ) This function uses the extended filename syntax to open the file. See also  fits_open_diskfile  that does not use the extended filename parser and uses  filename  as is as the name of the file. source"},{"id":168,"pagetitle":"Home","title":"CFITSIO.fits_open_diskfile","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_open_diskfile","content":" CFITSIO.fits_open_diskfile  —  Function fits_open_diskfile(filename::String, [mode = 0]) Open an existing data file. Modes: 0 : Read only (equivalently denoted by  CFITSIO.R ) 1 : Read-write (equivalently denoted by  CFITSIO.RW ) This function does not use the extended filename parser, and uses  filename  as is as the name of the file that is to be opened. See also  fits_open_file  which uses the extended filename syntax. source"},{"id":169,"pagetitle":"Home","title":"CFITSIO.fits_open_table","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_open_table","content":" CFITSIO.fits_open_table  —  Function fits_open_table(filename::String, [mode = 0]) Open an existing data file (like  fits_open_file ) and move to the first HDU containing either an ASCII or a binary table. Modes: 0 : Read only (equivalently denoted by  CFITSIO.R ) 1 : Read-write (equivalently denoted by  CFITSIO.RW ) source"},{"id":170,"pagetitle":"Home","title":"CFITSIO.fits_open_image","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_open_image","content":" CFITSIO.fits_open_image  —  Function fits_open_image(filename::String, [mode = 0]) Open an existing data file (like  fits_open_file ) and move to the first HDU containing an image. Modes: 0 : Read only (equivalently denoted by  CFITSIO.R ) 1 : Read-write (equivalently denoted by  CFITSIO.RW ) source"},{"id":171,"pagetitle":"Home","title":"CFITSIO.fits_open_data","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_open_data","content":" CFITSIO.fits_open_data  —  Function fits_open_data(filename::String, [mode = 0]) Open an existing data file (like  fits_open_file ) and move to the first HDU containing either an image or a table. Modes: 0 : Read only (equivalently denoted by  CFITSIO.R ) 1 : Read-write (equivalently denoted by  CFITSIO.RW ) source"},{"id":172,"pagetitle":"Home","title":"CFITSIO.fits_close_file","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_close_file","content":" CFITSIO.fits_close_file  —  Function fits_close_file(f::FITSFile) Close a previously opened FITS file. source"},{"id":173,"pagetitle":"Home","title":"CFITSIO.fits_delete_file","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_delete_file","content":" CFITSIO.fits_delete_file  —  Function fits_delete_file(f::FITSFile) Close an opened FITS file (like  fits_close_file ) and removes it from the disk. source"},{"id":174,"pagetitle":"Home","title":"CFITSIO.fits_file_name","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_file_name","content":" CFITSIO.fits_file_name  —  Function fits_file_name(f::FITSFile) Return the name of the file associated with object  f . source"},{"id":175,"pagetitle":"Home","title":"CFITSIO.fits_file_mode","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_file_mode","content":" CFITSIO.fits_file_mode  —  Function fits_file_mode(f::FITSFile) Return the I/O mode of the FITS file, where 0 indicates a read-only mode and 1 indicates a read-write mode. source"},{"id":176,"pagetitle":"Home","title":"HDU Routines","ref":"/previews/PR43/CFITSIO/stable/#HDU-Routines","content":" HDU Routines The functions described in this section change the current HDU and to find their number and type. The following is a short example which shows how to use them: num = fits_get_num_hdus(f)\nprintln(\"Number of HDUs in the file: \", num)\n\nfor i = 1:num\n    hdu_type = fits_movabs_hdu(f, i)\n    println(i, \") hdu_type = \", hdu_type)\nend"},{"id":177,"pagetitle":"Home","title":"CFITSIO.fits_get_num_hdus","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_get_num_hdus","content":" CFITSIO.fits_get_num_hdus  —  Function fits_get_num_hdus(f::FITSFile) Return the number of HDUs in the file. source"},{"id":178,"pagetitle":"Home","title":"CFITSIO.fits_movabs_hdu","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_movabs_hdu","content":" CFITSIO.fits_movabs_hdu  —  Function fits_movabs_hdu(f::FITSFile, hduNum::Integer) Change the current HDU to the value specified by  hduNum , and return a symbol describing the type of the HDU. Possible symbols are:  image_hdu ,  ascii_table , or  binary_table . The value of  hduNum  must range between 1 and the value returned by  fits_get_num_hdus . source"},{"id":179,"pagetitle":"Home","title":"CFITSIO.fits_movrel_hdu","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_movrel_hdu","content":" CFITSIO.fits_movrel_hdu  —  Function fits_movrel_hdu(f::FITSFile, hduNum::Integer) Change the current HDU by moving forward or backward by  hduNum  HDUs (positive means forward), and return the same as  fits_movabs_hdu . source"},{"id":180,"pagetitle":"Home","title":"CFITSIO.fits_movnam_hdu","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_movnam_hdu","content":" CFITSIO.fits_movnam_hdu  —  Function fits_movnam_hdu(f::FITSFile, extname::String, extver::Integer=0,\n      hdu_type_int::Integer=-1) Change the current HDU by moving to the (first) HDU which has the specified extension type and EXTNAME and EXTVER keyword values (or HDUNAME and HDUVER keywords). If  extver  is 0 (the default) then the EXTVER keyword is ignored and the first HDU with a matching EXTNAME (or HDUNAME) keyword will be found. If  hdu_type_int  is -1 (the default) only the extname and extver values will be used to locate the correct extension. If no matching HDU is found in the file, the current HDU will remain unchanged. source"},{"id":181,"pagetitle":"Home","title":"CFITSIO.fits_delete_hdu","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_delete_hdu","content":" CFITSIO.fits_delete_hdu  —  Function fits_delete_hdu(f::FITSFile) Delete the HDU from the FITS file and shift the following HDUs forward. If  f  is the primary HDU in the file then it'll be replaced by a null primary HDU with no data and minimal header information. Return a symbol to indicate the type of the new current HDU. Possible symbols are:  image_hdu ,  ascii_table , or  binary_table . The value of  hduNum  must range between 1 and the value returned by  fits_get_num_hdus . source"},{"id":182,"pagetitle":"Home","title":"Header Keyword Routines","ref":"/previews/PR43/CFITSIO/stable/#Header-Keyword-Routines","content":" Header Keyword Routines"},{"id":183,"pagetitle":"Home","title":"CFITSIO.fits_get_hdrspace","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_get_hdrspace","content":" CFITSIO.fits_get_hdrspace  —  Function fits_get_hdrspace(f::FITSFile) -> (keysexist, morekeys) Return the number of existing keywords (not counting the END keyword) and the amount of space currently available for more keywords. source"},{"id":184,"pagetitle":"Home","title":"CFITSIO.fits_read_keyword","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_read_keyword","content":" CFITSIO.fits_read_keyword  —  Function fits_read_keyword(f::FITSFile, keyname::String) -> (value, comment) yields the specified keyword value and commend (as a tuple of strings), throws and error if the keyword is not found. source"},{"id":185,"pagetitle":"Home","title":"CFITSIO.fits_read_record","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_read_record","content":" CFITSIO.fits_read_record  —  Function fits_read_record(f::FITSFile, keynum::Int) -> String Return the nth header record in the CHU. The first keyword in the header is at  keynum = 1 . source"},{"id":186,"pagetitle":"Home","title":"CFITSIO.fits_read_keyn","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_read_keyn","content":" CFITSIO.fits_read_keyn  —  Function fits_read_keyn(f::FITSFile, keynum::Int) -> (name, value, comment) Return the nth header record in the CHU. The first keyword in the header is at  keynum = 1 . source"},{"id":187,"pagetitle":"Home","title":"CFITSIO.fits_write_key","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_write_key","content":" CFITSIO.fits_write_key  —  Function fits_write_key(f::FITSFile, keyname::String, value, comment::String) Write a keyword of the appropriate data type into the CHU. source"},{"id":188,"pagetitle":"Home","title":"CFITSIO.fits_write_record","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_write_record","content":" CFITSIO.fits_write_record  —  Function fits_write_record(f::FITSFile, card::String) Write a user specified keyword record into the CHU. source"},{"id":189,"pagetitle":"Home","title":"CFITSIO.fits_delete_record","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_delete_record","content":" CFITSIO.fits_delete_record  —  Function fits_delete_record(f::FITSFile, keynum::Int) Delete the keyword record at the specified index. source"},{"id":190,"pagetitle":"Home","title":"CFITSIO.fits_delete_key","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_delete_key","content":" CFITSIO.fits_delete_key  —  Function fits_delete_key(f::FITSFile, keyname::String) Delete the keyword named  keyname . source"},{"id":191,"pagetitle":"Home","title":"CFITSIO.fits_hdr2str","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_hdr2str","content":" CFITSIO.fits_hdr2str  —  Function fits_hdr2str(f::FITSFile, nocomments::Bool=false) Return the header of the CHDU as a string. If  nocomments  is  true , comment cards are stripped from the output. source"},{"id":192,"pagetitle":"Home","title":"Image HDU Routines","ref":"/previews/PR43/CFITSIO/stable/#Image-HDU-Routines","content":" Image HDU Routines"},{"id":193,"pagetitle":"Home","title":"CFITSIO.fits_get_img_size","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_get_img_size","content":" CFITSIO.fits_get_img_size  —  Function fits_get_img_size(f::FITSFile) Get the dimensions of the image. source"},{"id":194,"pagetitle":"Home","title":"CFITSIO.fits_create_img","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_create_img","content":" CFITSIO.fits_create_img  —  Function fits_create_img(f::FITSFile, T::Type, naxes::Vector{<:Integer}) Create a new primary array or IMAGE extension with the specified data type  T  and size  naxes . source fits_create_img(f::FITSFile, A::AbstractArray) Create a new primary array or IMAGE extension with the element type and size of  A , that is capable of storing the entire array  A . source"},{"id":195,"pagetitle":"Home","title":"CFITSIO.fits_insert_img","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_insert_img","content":" CFITSIO.fits_insert_img  —  Function fits_insert_img(f::FITSFile, T::Type, naxes::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}) Insert a new image extension immediately following the CHDU, or insert a new Primary Array at the beginning of the file. source"},{"id":196,"pagetitle":"Home","title":"CFITSIO.fits_write_pix","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_write_pix","content":" CFITSIO.fits_write_pix  —  Function fits_write_pix(f::FITSFile, fpixel::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}, nelements::Integer, data::StridedArray) Write  nelements  pixels from  data  into the FITS file starting from the pixel  fpixel . Note data  needs to be stored contiguously in memory. See also:  fits_write_pixnull source fits_write_pix(f::FITSFile, data::StridedArray) Write the entire array  data  into the FITS file. Note data  needs to be stored contiguously in memory. See also:  fits_write_pixnull ,  fits_write_subset source"},{"id":197,"pagetitle":"Home","title":"CFITSIO.fits_write_pixnull","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_write_pixnull","content":" CFITSIO.fits_write_pixnull  —  Function fits_write_pixnull(f::FITSFile, fpixel::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}, nelements::Integer, data::StridedArray, nulval) Write  nelements  pixels from  data  into the FITS file starting from the pixel  fpixel . The argument  nulval  specifies the values that are to be considered as \"null values\", and replaced by appropriate numbers corresponding to the element type of  data . Note data  needs to be stored contiguously in memory. See also:  fits_write_pix source fits_write_pixnull(f::FITSFile, data::StridedArray, nulval) Write the entire array  data  into the FITS file. The argument  nulval  specifies the values that are to be considered as \"null values\", and replaced by appropriate numbers corresponding to the element type of  data . Note data  needs to be stored contiguously in memory. See also:  fits_write_pix source"},{"id":198,"pagetitle":"Home","title":"CFITSIO.fits_write_subset","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_write_subset","content":" CFITSIO.fits_write_subset  —  Function fits_write_subset(f::FITSFile, fpixel::V, lpixel::V, data::StridedArray) where {V<:Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}} Write a rectangular section of the FITS image. The number of pixels to be written will be computed from the first and last pixels (specified as the  fpixel  and  lpixel  arguments respectively). Note The section to be written out must be contiguous in memory, so all the dimensions aside from the last one must span the entire axis range. The arguments  fpixel  and  lpixel  must account for this. See also:  fits_write_pix source"},{"id":199,"pagetitle":"Home","title":"CFITSIO.fits_read_pix","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_read_pix","content":" CFITSIO.fits_read_pix  —  Function fits_read_pix(f::FITSFile, fpixel::NTuple{Vector{<:Integer}, Tuple{Vararg{Integer}}}, nelements::Integer, [nulval], data::StridedArray) Read  nelements  pixels from the FITS file into  data  starting from the pixel  fpixel . If the optional argument  nulval  is specified and is non-zero, any null value present in the array will be replaced by it. Note data  needs to be stored contiguously in memory. See also:  fits_read_pixnull ,  fits_read_subset source fits_read_pix(f::FITSFile, data::StridedArray, [nulval]) Read  length(data)  pixels from the FITS file into  data  starting from the first pixel. The optional argument  nulval , if specified and non-zero, is used to replace any null value present in the array. Note data  needs to be stored contiguously in memory. See also:  fits_read_pixnull source"},{"id":200,"pagetitle":"Home","title":"CFITSIO.fits_read_pixnull","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_read_pixnull","content":" CFITSIO.fits_read_pixnull  —  Function fits_read_pixnull(f::FITSFile, fpixel::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}, nelements::Integer, data::StridedArray, nullarray::Array{UInt8}) Read  nelements  pixels from the FITS file into  data  starting from the pixel  fpixel . At output, the indices of  nullarray  where  data  has a corresponding null value are set to  1 . Note data  needs to be stored contiguously in memory. See also:  fits_read_pix source fits_read_pixnull(f::FITSFile, data::StridedArray, nullarray::Array{UInt8}) Read  length(data)  pixels from the FITS file into  data  starting from the first pixel. At output, the indices of  nullarray  where  data  has a corresponding null value are set to  1 . Note data  needs to be stored contiguously in memory. See also:  fits_read_pix source"},{"id":201,"pagetitle":"Home","title":"CFITSIO.fits_read_subset","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_read_subset","content":" CFITSIO.fits_read_subset  —  Function fits_read_subset(f::FITSFile, fpixel::V, lpixel::V, inc::V, [nulval], data::StridedArray) where {V<:Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}} Read a rectangular section of the FITS image. The number of pixels to be read will be computed from the first and last pixels (specified as the  fpixel  and  lpixel  arguments respectively). The argument  inc  specifies the step-size in pixels along each dimension. If the optional argument  nulval  is specified and is non-zero, null values in  data  will be replaced by it. Note data  needs to be stored contiguously in memory, and will be populated contiguously with the pixels that are read in. See also:  fits_read_pix source"},{"id":202,"pagetitle":"Home","title":"CFITSIO.fits_copy_image_section","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_copy_image_section","content":" CFITSIO.fits_copy_image_section  —  Function fits_copy_image_section(fin::FITSFile, fout::FITSFile, section::String) Copy a rectangular section of an image from  fin  and write it to a new FITS primary image or image extension in  fout . The section specifier is described on the  CFITSIO website . source"},{"id":203,"pagetitle":"Home","title":"CFITSIO.fits_write_null_img","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_write_null_img","content":" CFITSIO.fits_write_null_img  —  Function fits_write_null_img(f::FITSFile, firstelem::Integer, nelements::Integer) Set a stretch of elements to the appropriate null value, starting from the pixel number  firstelem  and extending over  nelements  pixels. source"},{"id":204,"pagetitle":"Home","title":"CFITSIO.fits_resize_img","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_resize_img","content":" CFITSIO.fits_resize_img  —  Function fits_resize_img(f::FITSFile, T::Type, naxis::Integer, sz::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}) Modify the size, dimensions and optionally the element type of the image in  f . The new image will have an element type  T , be a  naxis -dimensional image with size  sz . If the new image is larger than the existing one, it will be zero-padded at the end. If the new image is smaller, existing image data will be truncated. fits_resize_img(f::FITSFile, sz::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}) Resize the image to the new size  sz . The element type is preserved, and the number of dimensions is set equal to  length(sz) . fits_resize_img(f::FITSFile, T::Type) Change the element type of the image to  T , leaving the size unchanged. Note This method reinterprets the data instead of coercing the elements. Example julia> f = fits_clobber_file(tempname());\n\njulia> a = [1 2; 3 4];\n\njulia> fits_create_img(f, a);\n\njulia> fits_write_pix(f, a);\n\njulia> fits_get_img_size(f)\n2-element Vector{Int64}:\n 2\n 2\n\njulia> fits_resize_img(f, [3,3]);\n\njulia> fits_get_img_size(f)\n2-element Vector{Int64}:\n 3\n 3\n\njulia> b = similar(a, (3,3));\n\njulia> fits_read_pix(f, b); b\n3×3 Matrix{Int64}:\n 1  4  0\n 3  0  0\n 2  0  0\n\njulia> fits_resize_img(f, [4]);\n\njulia> b = similar(a, (4,));\n\njulia> fits_read_pix(f, b); b\n4-element Vector{Int64}:\n 1\n 3\n 2\n 4 source"},{"id":205,"pagetitle":"Home","title":"Table Routines","ref":"/previews/PR43/CFITSIO/stable/#Table-Routines","content":" Table Routines There are two functions to create a new HDU table extension:  fits_create_ascii_table  and  fits_create_binary_table . In general, one should pick the second as binary tables require less space on the disk and are more efficient to read and write. (Moreover, a few datatypes are not supported in ASCII tables). In order to create a table, the programmer must specify the characteristics of each column by passing an array of tuples. Here is an example: f = fits_create_file(\"!new.fits\")\ncoldefs = [(\"SPEED\", \"1D\", \"m/s\"),\n           (\"MASS\", \"1E\", \"kg\"),\n           (\"PARTICLE\", \"20A\", \"Name\")]\nfits_create_binary_tbl(f, 10, coldefs, \"PARTICLE\") This example creates a table with room for 10 entries, each of them describing the characteristics of a particle: its speed, its mass, and its name (codified as a 20-character string). See the documentation of  fits_create_ascii_tbl  for more details."},{"id":206,"pagetitle":"Home","title":"CFITSIO.fits_create_ascii_tbl","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_create_ascii_tbl","content":" CFITSIO.fits_create_ascii_tbl  —  Function fits_create_ascii_tbl(f::FITSFile, numrows::Integer, coldefs::Array{CFITSIO.ColumnDef},\n            extname::String) Append a new HDU containing an ASCII table. The table will have  numrows  rows (this parameter can be set to zero), each initialized with the default value. In order to create a table, the programmer must specify the characteristics of each column. The columns are specified by the  coldefs  variable, which is an array of tuples. Each tuple must have three string fields: The name of the column. The data type and the repetition count. It must be a string made by a number (the repetition count) followed by a letter specifying the type (in the example above,  D  stands for  Float64 ,  E  stands for  Float32 ,  A  stands for  Char ). Refer to the CFITSIO documentation for more information about the syntax of this parameter. The measure unit of this field. This is used only as a comment. The value of  extname  sets the \"extended name\" of the table, i.e., a string that in some situations can be used to refer to the HDU itself. Note that, unlike for binary tables, CFITSIO puts some limitations to the types that can be used in an ASCII table column. Refer to the CFITSIO manual for further information. See also  fits_create_binary_tbl  for a similar function which creates binary tables. source"},{"id":207,"pagetitle":"Home","title":"CFITSIO.fits_create_binary_tbl","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_create_binary_tbl","content":" CFITSIO.fits_create_binary_tbl  —  Function fits_create_binary_tbl(f::FITSFile, numrows::Integer, coldefs::Array{ColumnDef},\n             extname::String) Append a new HDU containing a binary table. The meaning of the parameters is the same as in a call to  fits_create_ascii_tbl . In general, one should pick this function for creating tables in a new HDU, as binary tables require less space on the disk and are more efficient to read and write. (Moreover, a few datatypes are not supported in ASCII tables). source"},{"id":208,"pagetitle":"Home","title":"CFITSIO.fits_get_coltype","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_get_coltype","content":" CFITSIO.fits_get_coltype  —  Function fits_get_coltype(f::FITSFile, colnum::Integer) Provided that the current HDU contains either an ASCII or binary table, return information about the column at position  colnum  (counting from 1). Return is a tuple containing typecode : CFITSIO integer type code of the column. repcount : Repetition count for the column. width : Width of an individual element. source"},{"id":209,"pagetitle":"Home","title":"CFITSIO.fits_insert_rows","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_insert_rows","content":" CFITSIO.fits_insert_rows  —  Function fits_insert_rows(f::FITSFile, firstrow::Integer, nrows::Integer) Insert a number of rows equal to  nrows  after the row number  firstrow . The elements in each row are initialized to their default value: you can modify them later using  fits_write_col . Since the first row is at position 1, in order to insert rows  before  the first one  firstrow  must be equal to zero. source"},{"id":210,"pagetitle":"Home","title":"CFITSIO.fits_delete_rows","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_delete_rows","content":" CFITSIO.fits_delete_rows  —  Function fits_delete_rows(f::FITSFile, firstrow::integer, nrows::Integer) Delete  nrows  rows, starting from the one at position  firstrow . The index of the first row is 1. source"},{"id":211,"pagetitle":"Home","title":"CFITSIO.fits_read_col","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_read_col","content":" CFITSIO.fits_read_col  —  Function fits_read_col(f, colnum, firstrow, firstelem, data) Read data from one column of an ASCII/binary table and convert the data into the specified type  T . Arguments f::FITSFile : the file to be read. colnum::Integer : the column number, where the value of the first column is  1 . firstrow::Integer : the elements to be read start from this row. firstelem::Integer : specifies which is the first element to be read, when each cell contains more than one element (i.e., the \"repetition count\" of the field is greater than one). data::Array : at the end of the call, this will be filled with the elements read from the column. The length of the array gives the overall number of elements. source"},{"id":212,"pagetitle":"Home","title":"CFITSIO.fits_write_col","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_write_col","content":" CFITSIO.fits_write_col  —  Function fits_write_col(f, colnum, firstrow, firstelem, data) Write some data in one column of a ASCII/binary table. If there is no room for the elements, new rows will be created. (It is therefore useless to call  fits_insert_rows  if you only need to  append  elements to the end of a table.) f::FITSFile : the file in which data will be written. colnum::Integer : the column number, where the value of the first column is  1 . firstrow::Integer : the data wil be written from this row onwards. firstelem::Integer : specifies the position in the row where the first element will be written. data::Array : contains the elements that are to be written to the column of the table. source"},{"id":213,"pagetitle":"Home","title":"Miscellaneous","ref":"/previews/PR43/CFITSIO/stable/#Miscellaneous","content":" Miscellaneous"},{"id":214,"pagetitle":"Home","title":"CFITSIO.libcfitsio_version","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.libcfitsio_version","content":" CFITSIO.libcfitsio_version  —  Function libcfitsio_version() -> VersionNumber Return the version of the underlying CFITSIO library Example julia> libcfitsio_version()\nv\"3.37.0\" source"},{"id":219,"pagetitle":"Home","title":"Home","ref":"/previews/PR43/AstroImages/stable/#Home","content":" Home GitHub link AstroImage.jl  allows you to plot images from an astronomical  FITS  file using the popular  Images.jl  and  Plots.jl  Julia packages.  AstroImage.jl  uses  FITSIO.jl  to read FITS files."},{"id":222,"pagetitle":"API","title":"API Documentation","ref":"/previews/PR43/AstroImages/stable/api/#API-Documentation","content":" API Documentation"},{"id":223,"pagetitle":"API","title":"FileIO.load","ref":"/previews/PR43/AstroImages/stable/api/#FileIO.load","content":" FileIO.load  —  Function load(filename)  loads the contents of a formatted file, trying to infer the format from  filename  and/or magic bytes in the file (see  query ). load(strm)  loads from an  IOStream  or similar object. In this case, there is no filename extension, so we rely on the magic bytes for format identification. load(File{format\"PNG\"}(filename))  specifies the format directly, and bypasses the format  query . load(Stream{format\"PNG\"}(io))  specifies the format directly, and bypasses the format  query . load(f; options...)  passes keyword arguments on to the loader."},{"id":224,"pagetitle":"API","title":"FileIO.save","ref":"/previews/PR43/AstroImages/stable/api/#FileIO.save","content":" FileIO.save  —  Function save(filename, data...)  saves the contents of a formatted file, trying to infer the format from  filename . save(Stream{format\"PNG\"}(io), data...)  specifies the format directly, and bypasses the format  query . save(File{format\"PNG\"}(filename), data...)  specifies the format directly, and bypasses the format  query . save(f, data...; options...)  passes keyword arguments on to the saver."},{"id":225,"pagetitle":"API","title":"AstroImages.AstroImage","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.AstroImage","content":" AstroImages.AstroImage  —  Type Provides access to a FITS image along with its accompanying  header and WCS information, if applicable. source"},{"id":226,"pagetitle":"API","title":"AstroImages.imview","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.imview","content":" AstroImages.imview  —  Function imview(img; clims=Percent(99.5), stretch=identity, cmap=:magma, contrast=1.0, bias=0.5) Create a read only view of an array or AstroImageMat mapping its data values to Colors according to  clims ,  stretch , and  cmap . The data is first clamped to  clims , which can either be a tuple of (min, max) values or a function accepting an iterator of pixel values that returns (min, max). By default,  clims=extrema  i.e. the minimum and maximum of  img . Convenient functions to use for  clims  are:  extrema ,  zscale , and  percent(p) Next, the data is rescaled to [0,1] and remapped according to the function  stretch . Stretch can be any monotonic fuction mapping values in the range [0,1] to some range [a,b]. Note that  log(0)  is not defined so is not directly supported. For a list of convenient stretch functions, see:  logstretch ,  powstretch ,  squarestretch ,  asinhstretch ,  sinhstretch ,  powerdiststretch Finally the data is mapped to RGB values according to  cmap . If cmap is  nothing , grayscale is used. ColorSchemes.jl defines hundreds of colormaps. A few nice ones for images include:  :viridis ,  :magma ,  :plasma ,  :thermal , and  :turbo . Crucially, this function returns a view over the underlying data. If  img  is updated then those changes will be reflected by this view with the exception of  clims  which is not recalculated. Note: if clims or stretch is a function, the pixel values passed in are first filtered to remove non-finite or missing values. Defaults The default values of  clims ,  stretch , and  cmap  are  extrema ,  identity , and  nothing  respectively. You may alter these defaults using  AstroImages.set_clims! ,   AstroImages.set_stretch! , and  AstroImages.set_cmap! . Automatic Display Arrays wrapped by  AstroImageMat()  get displayed as images automatically by calling   imview  on them with the default settings when using displays that support showing PNG images. Missing data Pixels that are  NaN  or  missing  will be displayed as transparent when  cmap  is set or black if. +/- Inf will be displayed as black or white respectively. Exporting Images The view returned by  imview  can be saved using general  FileIO.save  methods. Example: v = imview(data, cmap=:magma, stretch=asinhstretch, clims=percent(95))\nsave(\"output.png\", v) source imview(img::AbstractArray{<:Complex}; ...) When applied to an image with complex values, display the magnitude of the pixels using  imview  and display the phase angle as a panel below using a cyclical color map. For more customatization, you can create a view like this yourself: vcat(\n    imview(abs.(img)),\n    imview(angle.(img)),\n) source"},{"id":227,"pagetitle":"API","title":"AstroImages.implot","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.implot","content":" AstroImages.implot  —  Function implot(\n    img::AbstractArray;\n    clims=Percent(99.5),\n    stretch=identity,\n    cmap=:magma,\n    bias=0.5,\n    contrast=1,\n    wcsticks=true,\n    grid=true,\n    platescale=1\n) Create a read only view of an array or AstroImageMat mapping its data values to an array of Colors. Equivalent to: implot(\n    imview(\n        img::AbstractArray;\n        clims=Percent(99.5),\n        stretch=identity,\n        cmap=:magma,\n        bias=0.5,\n        contrast=1,\n    ),\n    wcsn=1,\n    wcsticks=true,\n    wcstitle=true,\n    grid=true,\n    platescale=1\n) Image Rendering See  imview  for how data is mapped to RGBA pixel values. WCS & Image Coordinates If provided with an AstroImage that has WCS headers set, the tick marks and plot grid are calculated using WCS.jl. By default, use the first WCS coordinate system. The underlying pixel coordinates are those returned by  dims(img)  multiplied by  platescale . This allows you to overplot lines, regions, etc. using pixel coordinates. If you wish to compute the pixel coordinate of a point in world coordinates, see  world_to_pix . wcsn  (default  1 ) select which WCS transform in the headers to use for ticks & grid wcsticks  (default  true  if WCS headers present) display ticks and labels, and title using world coordinates wcstitle  (default  true  if WCS headers present and  length(refdims(img))>0 ). When slicing a cube, display the location along unseen axes in world coordinates instead of pixel coordinates. grid  (default  true ) show a grid over the plot. Uses WCS coordinates if  wcsticks  is true, otherwise pixel coordinates multiplied by  platescale . platescale  (default  1 ). Scales the underlying pixel coordinates to ease overplotting, etc. If  wcsticks  is false, the displayed pixel coordinates are also scaled. Defaults The default values of  clims ,  stretch , and  cmap  are  extrema ,  identity , and  nothing  respectively. You may alter these defaults using  AstroImages.set_clims! ,   AstroImages.set_stretch! , and  AstroImages.set_cmap! . source"},{"id":228,"pagetitle":"API","title":"DimensionalData.Dimensions.dims","ref":"/previews/PR43/AstroImages/stable/api/#DimensionalData.Dimensions.dims","content":" DimensionalData.Dimensions.dims  —  Function dims(x, [dims::Tuple]) => Tuple{Vararg{<:Dimension}}\ndims(x, dim) => Dimension Return a tuple of  Dimension s for an object, in the order that matches the axes or columns of the underlying data. dims  can be  Dimension ,  Dimension  types, or  Symbols  for  Dim{Symbol} . The default is to return  nothing ."},{"id":229,"pagetitle":"API","title":"DimensionalData.Dimensions.refdims","ref":"/previews/PR43/AstroImages/stable/api/#DimensionalData.Dimensions.refdims","content":" DimensionalData.Dimensions.refdims  —  Function refdims(x, [dims::Tuple]) => Tuple{Vararg{<:Dimension}}\nrefdims(x, dim) => Dimension Reference dimensions for an array that is a slice or view of another array with more dimensions. slicedims(a, dims)  returns a tuple containing the current new dimensions and the new reference dimensions. Refdims can be stored in a field or disgarded, as it is mostly to give context to plots. Ignoring refdims will simply leave some captions empty. The default is to return an empty  Tuple () ."},{"id":230,"pagetitle":"API","title":"AstroImages.Comment","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.Comment","content":" AstroImages.Comment  —  Type Index for accessing a comment associated with a header keyword or COMMENT entry. Example: img = AstroImage(randn(10,10))\nimg[\"ABC\"] = 1\nimg[\"ABC\", Comment] = \"A comment describing this key\"\n\npush!(img, Comment, \"The purpose of this file is to demonstrate comments\")\nimg[Comment] # [\"The purpose of this file is to demonstrate comments\")] source"},{"id":231,"pagetitle":"API","title":"AstroImages.History","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.History","content":" AstroImages.History  —  Type Allows accessing and setting HISTORY header entries img = AstroImage(randn(10,10)) push!(img, History, \"2023-04-19: Added history entry.\") img[History] # [\"2023-04-19: Added history entry.\"] source"},{"id":232,"pagetitle":"API","title":"WCS.pix_to_world","ref":"/previews/PR43/AstroImages/stable/api/#WCS.pix_to_world","content":" WCS.pix_to_world  —  Function pix_to_world(wcs, pixcoords) Convert the array of pixel coordinates  pixcoords  to world coordinates according to the WCSTransform  wcs .  pixcoords  should be a 2-d array where \"pixcoords[:, i]\" is the i-th set of coordinates, or a 1-d array representing a single set of coordinates. The return value is the same shape as  pixcoords . pix_to_world(img::AstroImage, pixcoords; all=false) Given an astro image, look up the world coordinates of the pixels given  by  pixcoords . World coordinates are resolved using WCS.jl and a WCSTransform calculated from any FITS header present in  img . If no WCS information is in the header, or the axes are all linear, this will just return pixel coordinates. pixcoords  should be the coordinates in your current selection of the image. For example, if you select a slice like this: julia> cube = load(\"some-3d-cube.fits\")\njulia> slice = cube[10:20, 30:40, 5] Then to look up the coordinates of the pixel in the bottom left corner of  slice , run: julia> world_coords = pix_to_world(img, [1, 1])\n[10, 30] If WCS information was present in the header of  cube , then those coordinates would be resolved using axis 1, 2, and 3 respectively. To include world coordinates in all axes, pass  all=true julia> world_coords = pix_to_world(img, [1, 1], all=true)\n[10, 30, 5] !! Coordinates must be provided in the order of  dims(img) . If you transpose  an image, the order you pass the coordinates should not change. source"},{"id":233,"pagetitle":"API","title":"WCS.world_to_pix","ref":"/previews/PR43/AstroImages/stable/api/#WCS.world_to_pix","content":" WCS.world_to_pix  —  Function world_to_pix(wcs, worldcoords) Convert the array of world coordinates  worldcoords  to pixel coordinates according to the WCSTransform  wcs .  worldcoords  is a 2-d array where \"worldcoords[:, i]\" is the i-th set of coordinates, or a 1-d array representing a single set of coordinates. The return value is the same size as  worldcoords ."},{"id":234,"pagetitle":"API","title":"DimensionalData.Dimensions.X","ref":"/previews/PR43/AstroImages/stable/api/#DimensionalData.Dimensions.X","content":" DimensionalData.Dimensions.X  —  Type X <: XDim\n\nX(val=:) X  Dimension .  X <: XDim <: IndependentDim Example: xdim = X(2:2:10)\n# Or\nval = A[X(1)]\n# Or\nmean(A; dims=X)"},{"id":235,"pagetitle":"API","title":"DimensionalData.Dimensions.Y","ref":"/previews/PR43/AstroImages/stable/api/#DimensionalData.Dimensions.Y","content":" DimensionalData.Dimensions.Y  —  Type Y <: YDim\n\nY(val=:) Y  Dimension .  Y <: YDim <: DependentDim Example: ydim = Y(['a', 'b', 'c'])\n# Or\nval = A[Y(1)]\n# Or\nmean(A; dims=Y)"},{"id":236,"pagetitle":"API","title":"DimensionalData.Dimensions.Z","ref":"/previews/PR43/AstroImages/stable/api/#DimensionalData.Dimensions.Z","content":" DimensionalData.Dimensions.Z  —  Type Z <: ZDim\n\nZ(val=:) Z  Dimension .  Z <: ZDim <: Dimension Example: zdim = Z(10:10:100)\n# Or\nval = A[Z(1)]\n# Or\nmean(A; dims=Z)"},{"id":237,"pagetitle":"API","title":"DimensionalData.Dimensions.Dim","ref":"/previews/PR43/AstroImages/stable/api/#DimensionalData.Dimensions.Dim","content":" DimensionalData.Dimensions.Dim  —  Type Dim{S}(val=:) A generic dimension. For use when custom dims are required when loading data from a file. Can be used as keyword arguments for indexing. Dimension types take precedence over same named  Dim  types when indexing with symbols, or e.g. creating Tables.jl keys. using DimensionalData\n\ndim = Dim{:custom}(['a', 'b', 'c'])\n\n# output\n\nDim{:custom} Char[a, b, c]"},{"id":238,"pagetitle":"API","title":"DimensionalData.Dimensions.LookupArrays.At","ref":"/previews/PR43/AstroImages/stable/api/#DimensionalData.Dimensions.LookupArrays.At","content":" DimensionalData.Dimensions.LookupArrays.At  —  Type At <: Selector\n\nAt(x, atol, rtol)\nAt(x; atol=nothing, rtol=nothing) Selector that exactly matches the value on the passed-in dimensions, or throws an error. For ranges and arrays, every intermediate value must match an existing value - not just the end points. x  can be any value or  Vector  of values. atol  and  rtol  are passed to  isapprox . For  Number rtol  will be set to  Base.rtoldefault , otherwise  nothing , and wont be used. Example using DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))\nA[X(At(20)), Y(At(6))]\n\n# output\n\n5"},{"id":239,"pagetitle":"API","title":"DimensionalData.Dimensions.LookupArrays.Near","ref":"/previews/PR43/AstroImages/stable/api/#DimensionalData.Dimensions.LookupArrays.Near","content":" DimensionalData.Dimensions.LookupArrays.Near  —  Type Near <: Selector\n\nNear(x) Selector that selects the nearest index to  x . With  Points  this is simply the index values nearest to the  x , however with  Intervals  it is the interval  center  nearest to  x . This will be offset from the index value for  Start  and  End  loci. Example using DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))\nA[X(Near(23)), Y(Near(5.1))]\n\n# output\n4"},{"id":240,"pagetitle":"API","title":"AstroImages.header","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.header","content":" AstroImages.header  —  Function header(img::AstroImage) Return the underlying FITSIO.FITSHeader object wrapped by an AstroImage. Note that this object has less flexible getindex and setindex methods. Indexing by symbol, Comment, History, etc are not supported. source header(array::AbstractArray) Returns an empty FITSIO.FITSHeader object when called with a non-AstroImage abstract array. source"},{"id":241,"pagetitle":"API","title":"AstroImages.wcs","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.wcs","content":" AstroImages.wcs  —  Function wcs(img) Computes and returns a list of World Coordinate System WCSTransform objects from WCS.jl. The resultss are cached after the first call, so subsequent calls are fast. Modifying a WCS header invalidates this cache automatically, so users should call  wcs(...)  each time rather than keeping the WCSTransform object around. source wcs(img, index) Computes and returns a World Coordinate System WCSTransform objects from WCS.jl by index. This is to support files with multiple WCS transforms specified.  wcs(img,1)  is useful for selecting selecting the first WCSTranform object. The resultss are cached after the first call, so subsequent calls are fast. Modifying a WCS header invalidates this cache automatically, so users should call  wcs(...)  each time rather than keeping the WCSTransform object around. source wcs(array) Returns a list with a single basic WCSTransform object when called with a non-AstroImage abstract array. source"},{"id":242,"pagetitle":"API","title":"AstroImages.WCSGrid","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.WCSGrid","content":" AstroImages.WCSGrid  —  Type WCSGrid(img::AstroImageMat, ax=(1,2), coords=(first(axes(img,ax[1])),first(axes(img,ax[2])))) Given an AstroImageMat, return information necessary to plot WCS gridlines in physical coordinates against the image's pixel coordinates. This function has to work on both plotted axes at once to handle rotation and general curvature of the WCS grid projected on the image coordinates. source"},{"id":243,"pagetitle":"API","title":"AstroImages.composecolors","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.composecolors","content":" AstroImages.composecolors  —  Function composecolors(\n    images,\n    cmap=[\"#F00\", \"#0F0\", \"#00F\"];\n    clims,\n    stretch,\n    contrast,\n    bias,\n    multiplier\n) Create a color composite of multiple images by applying  imview  and blending  the results. This function can be used to create RGB composites using any number of channels (e.g. red, green, blue, and hydrogen alpha) as well as more exotic images like blending radio and optical data using two different colormaps. cmap  should be a list of colorants, named colors (see Colors.jl), or colorschemes (see ColorSchemes.jl).  clims ,  stretch ,  contrast , and  bias  are passed on to  imview . They can be a single value or a list of different values for each image. Examples: # Basic RGB\ncomposecolors([redimage, greenimage, blueimage])\n# Non-linear stretch before blending\ncomposecolors([redimage, greenimage, blueimage], stretch=asinhstretch)\n# More than three channels are allowed (H alpha in pink)\ncomposecolors(\n    [antred, antgreen, antblue, anthalp],\n    [\"red\", \"green\", \"blue\", \"maroon1\"],\n    multiplier=[1,2,1,1]\n)\n# Can mix \ncomposecolors([radioimage, xrayimage], [:ice, :magma], clims=extrema)\ncomposecolors([radioimage, xrayimage], [:magma, :viridis], clims=[Percent(99), Zscale()]) source"},{"id":244,"pagetitle":"API","title":"AstroImages.Zscale","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.Zscale","content":" AstroImages.Zscale  —  Type Zscale(options)(data) Wraps PlotUtils.zscale in a callable with default parameters. This is a common algorithm for agressively stretching astronomical data to see faint structure that originated in IRAF: https://iraf.net/forum/viewtopic.php?showtopic=134139 but is now seen in many other applications/libraries (DS9, Astropy, etc.) Usage: imview(img, clims=Zscale())\nimplot(img, clims=Zscale(contrast=0.1)) Default parameters: nsamples::Int=1000\ncontrast::Float64=0.25\nmax_reject::Float64=0.5\nmin_npixels::Float64=5\nk_rej::Float64=2.5\nmax_iterations::Int=5 source"},{"id":245,"pagetitle":"API","title":"AstroImages.Percent","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.Percent","content":" AstroImages.Percent  —  Type Percent(99.5) Returns a callable that calculates display limits that include the given  percent of the image data. Reproduces the behaviour of the SAO DS9 scale menu. Example: julia> imview(img, clims=Percent(90)) This will set the limits to be the 5th percentile to the 95th percentile. source"},{"id":246,"pagetitle":"API","title":"AstroImages.logstretch","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.logstretch","content":" AstroImages.logstretch  —  Function logstretch(num,a=1000) A log-stretch as defined by the SAO DS9 application: http://ds9.si.edu/doc/ref/how.html source"},{"id":247,"pagetitle":"API","title":"AstroImages.powstretch","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.powstretch","content":" AstroImages.powstretch  —  Function powstretch(num, a=1000) A power-stretch as defined by the SAO DS9 application: http://ds9.si.edu/doc/ref/how.html source"},{"id":248,"pagetitle":"API","title":"AstroImages.sqrtstretch","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.sqrtstretch","content":" AstroImages.sqrtstretch  —  Function sqrtstretch(num) A square root stretch (simply defined as Base.sqrt) source"},{"id":249,"pagetitle":"API","title":"AstroImages.squarestretch","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.squarestretch","content":" AstroImages.squarestretch  —  Function squarestretch(num) A squarestretch-stretch as defined by the SAO DS9 application: http://ds9.si.edu/doc/ref/how.html source"},{"id":250,"pagetitle":"API","title":"AstroImages.asinhstretch","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.asinhstretch","content":" AstroImages.asinhstretch  —  Function asinhstretch(num) A hyperbolic arcsin stretch as defined by the SAO DS9 application: http://ds9.si.edu/doc/ref/how.html. source"},{"id":251,"pagetitle":"API","title":"AstroImages.sinhstretch","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.sinhstretch","content":" AstroImages.sinhstretch  —  Function sinhstretch(num) A hyperbolic sin stretch as defined by the SAO DS9 application: http://ds9.si.edu/doc/ref/how.html source"},{"id":252,"pagetitle":"API","title":"AstroImages.powerdiststretch","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.powerdiststretch","content":" AstroImages.powerdiststretch  —  Function logstretch(num,a=1000) A power distance stretch as defined by astropy. source"},{"id":253,"pagetitle":"API","title":"AstroImages.copyheader","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.copyheader","content":" AstroImages.copyheader  —  Function copyheader(img::AstroImage, data) -> imgnew Create a new image copying the header of  img  but using the data of the AbstractArray  data . Note that changing the header of  imgnew  does not affect the header of  img . See also:  shareheader . source"},{"id":254,"pagetitle":"API","title":"AstroImages.shareheader","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.shareheader","content":" AstroImages.shareheader  —  Function shareheader(img::AstroImage, data) -> imgnew Create a new image reusing the header dictionary of  img  but using the data of the AbstractArray  data . The two images have synchronized header; modifying one also affects the other. See also:  copyheader . source"},{"id":257,"pagetitle":"Contours","title":"Contours","ref":"/previews/PR43/AstroImages/stable/guide/contours/#Contours","content":" Contours This guide shows a few different ways to measure and visualize contours of images."},{"id":258,"pagetitle":"Contours","title":"Using Plots","ref":"/previews/PR43/AstroImages/stable/guide/contours/#Using-Plots","content":" Using Plots The most basic way to create a contour plot is simply to use Plots.jl  contour  and  contourf  functions on your image. Let's see how that works: using AstroImages, Plots\n\n\n# First load a FITS file of interest\nfname = download(\n    \"http://www.astro.uvic.ca/~wthompson/astroimages/fits/herca/herca_radio.fits\",\n    \"herca-radio.fits\"\n)\n\nherca = load(\"herca-radio.fits\") Create a contour plot contour(herca)"},{"id":261,"pagetitle":"Blurring & Filtering Images","title":"Image Filtering","ref":"/previews/PR43/AstroImages/stable/guide/image-filtering/#Image-Filtering","content":" Image Filtering The package  ImageFiltering.jl  makes it easy to apply arbitrary filters to images."},{"id":262,"pagetitle":"Blurring & Filtering Images","title":"Gaussian Blurs","ref":"/previews/PR43/AstroImages/stable/guide/image-filtering/#Gaussian-Blurs","content":" Gaussian Blurs Let's start by downloading a radio image of Hercules A: using AstroImages\nusing ImageFiltering\n\nfname = download(\n    \"http://www.astro.uvic.ca/~wthompson/astroimages/fits/herca/herca_radio.fits\",\n    \"herca-radio.fits\"\n)\n\nherca = load(\"herca-radio.fits\") Let's now apply a Gaussian blur (aka a low pass filter) using the  imfilter  function: herca_blur_20 = imfilter(herca, Kernel.gaussian(20.0)) The image has been smoothed out by convolving it with a wide Gaussian. Let's now do the opposite and perform a high-pass filter. This will bring out faint variations in structure. We can do this by subtracting a blurred image from the original: herca_blur_4 = imfilter(herca, Kernel.gaussian(4.0))\nherca_highpass = herca .- herca_blur_4 We now see lots of faint structure inside the jets! Finally, let's adjust how the image is displayed and apply a non-linear stretch: imview(\n    herca_highpass,\n    cmap=:seaborn_rocket_gradient,\n    clims=(-50,1500),\n    stretch=asinhstretch\n) If you have Plots loaded, we can add a colorbar and coordinate axes by switching to  implot : using Plots\nimplot(\n    herca_highpass,\n    cmap=:seaborn_rocket_gradient,\n    clims=(-50,1500),\n    stretch=asinhstretch\n)"},{"id":263,"pagetitle":"Blurring & Filtering Images","title":"Median Filtering","ref":"/previews/PR43/AstroImages/stable/guide/image-filtering/#Median-Filtering","content":" Median Filtering In addition to linear filters using  imfilter , ImageFiltering.jl also includes a great function called  mapwindow . This functions allows you to map an arbitrary function over a patch of an image.  Let's use  mapwindow  to perform a median filter. This is a great way to suppress salt and pepper noise, or remove stars from some images. We'll use a Hubble picture of the Eagle nebula: using AstroImages\nusing ImageFiltering\n\nfname = download(\n    \"http://www.astro.uvic.ca/~wthompson/astroimages/fits/eagle/673nmos.fits\",\n    \"eagle-673nmos.fits\"\n)\n\neagle673 = load(\"eagle-673nmos.fits\") The data is originally from https://esahubble.org/projects/fits_liberator/eagledata/. We can apply a median filter using  mapwindow . Make sure the patch size is an odd number in each direction! using Statistics\nmedfilt = copyheader(eagle673, mapwindow(median, eagle673, (11,11))) We use  copyheader  here since  mapwindow  returns a plain array and drops the image meta data. We can put this side by side with the original to see how some of the faint stars have been removed from the image: imview([eagle673[1:800,1:800]; medfilt[1:800,1:800]])"},{"id":266,"pagetitle":"Transforming Images","title":"Image Transformations","ref":"/previews/PR43/AstroImages/stable/guide/image-transformations/#Image-Transformations","content":" Image Transformations The  ImageTransformations.jl  package contains many useful functions for manipulating astronomical images. Note however that many of these functions drop the AstroImage wrapper and return plain arrays or OffsetArrays. They can be re-wrapped using  copyheader  or  shareheader  if you'd like to preserve the FITS header, dimension labels, WCS information, etc. You can install ImageTransformations by running  ] add ImageTransformations  at the REPL. For these examples, we'll download an image of the Antenae galaxies from Hubble: using AstroImages\nusing ImageTransformations\n\nfname = download(\n    \"http://www.astro.uvic.ca/~wthompson/astroimages/fits/antenae/blue.fits\",\n    \"ant-blue.fits\"\n)\n\nantblue = load(\"ant-blue.fits\")\n\n# We'll change the defaults to avoid setting them each time\nAstroImages.set_clims!(Percent(99))\nAstroImages.set_cmap!(:ice)\nAstroImages.set_stretch!(asinhstretch)\n\nimview(antblue)"},{"id":267,"pagetitle":"Transforming Images","title":"Rotations","ref":"/previews/PR43/AstroImages/stable/guide/image-transformations/#Rotations","content":" Rotations We can rotate images using the  imrotate  function. imrotate(antblue, 3π/4) |> imview The rotation angle is in radians, but you can use the function  rad2deg  to convert from degrees."},{"id":268,"pagetitle":"Transforming Images","title":"Resizing","ref":"/previews/PR43/AstroImages/stable/guide/image-transformations/#Resizing","content":" Resizing We can resize images using the  imresize  function: imresize(antblue, ratio=0.2) |> imview"},{"id":269,"pagetitle":"Transforming Images","title":"Arbitrary Transformations","ref":"/previews/PR43/AstroImages/stable/guide/image-transformations/#Arbitrary-Transformations","content":" Arbitrary Transformations Arbitrary transformations can be performed using ImageTransformation's  warp  function. See the documentation linked above for more details."},{"id":270,"pagetitle":"Transforming Images","title":"Mapping from One Coordinate System to Another","ref":"/previews/PR43/AstroImages/stable/guide/image-transformations/#Mapping-from-One-Coordinate-System-to-Another","content":" Mapping from One Coordinate System to Another For transforming an image from one coordiante system (say, RA & DEC) to another (e.g., galactic lattitude & logitude), see  Reprojecting Images ."},{"id":273,"pagetitle":"Extracting Photometry","title":"Photometry","ref":"/previews/PR43/AstroImages/stable/guide/photometry/#Photometry","content":" Photometry The following examples are adapted from  Photometry.jl  to show the same examples combined with AstroImages.jl. To learn how to measure background levels, perform aperture photometry, etc see the  Photometry.jl documentation ."},{"id":274,"pagetitle":"Extracting Photometry","title":"Background Estimation","ref":"/previews/PR43/AstroImages/stable/guide/photometry/#Background-Estimation","content":" Background Estimation From Photometry.jl: Estimating backgrounds is an important step in performing photometry. Ideally, we could perfectly describe the background with a scalar value or with some distribution. Unfortunately, it's impossible for us to precisely separate the background and foreground signals. Here, we use mixture of robust statistical estimators and meshing to let us get the spatially varying background from an astronomical photo. Let's show an example Now let's try and estimate the background using estimate_background. First, we'll si gma-clip to try and remove the signals from the stars. Then, the background is broken down into boxes, in this case of size (50, 50). Within each box, the given statistical estimators get the background value and RMS. By default, we use SourceExtractorBackground and StdRMS. This creates a low-resolution image, which we then need to resize. We can accomplish this using an interpolator, by default a cubic-spline interpolator via ZoomInterpolator. The end result is a smooth estimate of the spatially varying background and background RMS. using Photometry\nusing AstroImages\nusing Plots # optional, for implot functionality\n\n# Download our image, courtesy of astropy\nimage = AstroImage(download(\"https://rawcdn.githack.com/astropy/photutils-datasets/8c97b4fa3a6c9e6ea072faeed2d49a20585658ba/data/M6707HH.fits\"))\n\n# sigma-clip\nclipped = sigma_clip(image, 1, fill=NaN)\n\n# get background and background rms with box-size (50, 50)\nbkg, bkg_rms = estimate_background(clipped, 50)\n\nimview(image)\nimview(clipped)\nimview(bkg)\nimview(bkg_rms) Or, if you have Plots loaded: using Plots\n\n    AstroImages.set_clims!(Percent(99.5))\n    AstroImages.set_cmap!(:magma)\n    AstroImages.set_stretch!(identity)\nplot(\n    implot(image, title=\"Original\"),\n    implot(clipped, title=\"Sigma-Clipped\"),\n    implot(bkg, title=\"Background\"),\n    implot(bkg_rms, title=\"Background RMS\"),\n    layout=(2, 2)\n) We could apply a median filter, too, by specifying filter_size # get background and background rms with box-size (50, 50) and filter_size (5, 5)\nbkg_f, bkg_rms_f = estimate_background(clipped, 50, filter_size=5)\n\n# plot\nplot(\n    implot(bkg, title=\"Unfiltered\", ylabel=\"Background\"),\n    implot(bkg_f, title=\"Filtered\"),\n    implot(bkg_rms, ylabel=\"RMS\"),\n    implot(bkg_rms_f);\n    layout=(2, 2),) Now we can see our image after subtracting the filtered background and ready for Aperture Photometry! subt = image .- bkg_f[axes(image)...]\nclims = extrema(vcat(vec(image), vec(subt)))\nplot(\n    implot(image; title=\"Original\", clims),\n    implot(subt; title=\"Subtracted\", clims),\n    size=(1600,1000)\n)"},{"id":275,"pagetitle":"Extracting Photometry","title":"Source Extraction","ref":"/previews/PR43/AstroImages/stable/guide/photometry/#Source-Extraction","content":" Source Extraction From the background-subtracted image, we can detect all sources in the image: # We specify the uncertainty in the pixel data. We'll set it equal to zero.\nerrs = zeros(axes(subt))\nsources = extract_sources(PeakMesh(), subt, errs, true) # sort from brightest to darkest Table with 3 columns and 60924 rows:\n      x     y     value\n    ┌────────────────────\n 1  │ 255   226   9762.42\n 2  │ 940   681   9661.5\n 3  │ 219   924   9653.78\n 4  │ 38    678   9647.93\n 5  │ 245   85    9637.55\n 6  │ 44    1001  9633.13\n 7  │ 503   904   9627.34\n 8  │ 819   775   9625.92\n 9  │ 610   62    9617.79\n 10 │ 133   110   9616.88\n 11 │ 592   123   9614.86\n 12 │ 1055  248   9612.46\n 13 │ 424   86    9611.86\n 14 │ 558   125   9585.93\n 15 │ 125   1021  9582.11\n 16 │ 112   637   9579.71\n 17 │ 196   2     9579.49\n ⋮  │  ⋮     ⋮       ⋮ There's over 60,000 sources! We'll define a circular apperture for each source: aps = CircularAperture.(sources.x, sources.y, 6)[1:1000] # just brightest thousand point sources 1000-element Vector{CircularAperture{Int64}}:\n CircularAperture(255, 226, r=6)\n CircularAperture(940, 681, r=6)\n CircularAperture(219, 924, r=6)\n CircularAperture(38, 678, r=6)\n CircularAperture(245, 85, r=6)\n CircularAperture(44, 1001, r=6)\n CircularAperture(503, 904, r=6)\n CircularAperture(819, 775, r=6)\n CircularAperture(610, 62, r=6)\n CircularAperture(133, 110, r=6)\n ⋮\n CircularAperture(697, 975, r=6)\n CircularAperture(703, 599, r=6)\n CircularAperture(893, 878, r=6)\n CircularAperture(291, 457, r=6)\n CircularAperture(660, 855, r=6)\n CircularAperture(711, 920, r=6)\n CircularAperture(708, 271, r=6)\n CircularAperture(701, 273, r=6)\n CircularAperture(710, 273, r=6) We can overplot them on our original image. The coordinate sytem used by the Photometry.jl plot recipes (but not the actual return values) doesn't match AstroImages, so we must transpose our image: implot(subt', colorbar=false)\nplot!(aps)"},{"id":276,"pagetitle":"Extracting Photometry","title":"Measuring Photometry","ref":"/previews/PR43/AstroImages/stable/guide/photometry/#Measuring-Photometry","content":" Measuring Photometry Finally we can extract the source photometry  table = photometry(aps, subt) Table with 3 columns and 1000 rows:\n      xcenter  ycenter  aperture_sum\n    ┌───────────────────────────────\n 1  │ 255      226      20542.4\n 2  │ 940      681      7125.3\n 3  │ 219      924      14741.0\n 4  │ 38       678      31056.4\n 5  │ 245      85       -910.308\n 6  │ 44       1001     2792.62\n 7  │ 503      904      6954.07\n 8  │ 819      775      -3136.61\n 9  │ 610      62       4338.13\n 10 │ 133      110      22219.0\n 11 │ 592      123      18562.2\n 12 │ 1055     248      3277.33\n 13 │ 424      86       255299.0\n 14 │ 558      125      6659.03\n 15 │ 125      1021     11524.1\n 16 │ 112      637      1349.78\n 17 │ 196      2        -797.491\n ⋮  │    ⋮        ⋮          ⋮ And plot them:  scatter(\n    table.xcenter,\n    table.ycenter,\n    aspectratio=1,\n    marker_z=table.aperture_sum,\n    markerstrokewidth=0,\n    label=\"\",\n    framestyle=:box,\n    background_inside=:black,\n    color=:white\n)"},{"id":279,"pagetitle":"Reprojecting Images","title":"Reprojecting Images","ref":"/previews/PR43/AstroImages/stable/guide/reproject/#Reprojecting-Images","content":" Reprojecting Images Integration with the  Reproject.jl  package is not yet complete."},{"id":282,"pagetitle":"Conventions","title":"Conventions","ref":"/previews/PR43/AstroImages/stable/manual/conventions/#Conventions","content":" Conventions In the Julia Astro ecosystem, images follow the following conventions."},{"id":283,"pagetitle":"Conventions","title":"Axes","ref":"/previews/PR43/AstroImages/stable/manual/conventions/#Axes","content":" Axes For simple 2D images, the first axis is the horizontal axis and the second axis is the vertical axis. So images are indexed by  img[xi, yi] . The origin is at the bottom left of the image, so  img[1,1]  refers to the bottom left corner as does  img[begin,begin] .  img[end,end]  is the top right corner,  img[begin,end]  is the top left, etc. Note that this is transposed and flipped from how how Julia prints arrays at the REPL, "},{"id":284,"pagetitle":"Conventions","title":"Pixels","ref":"/previews/PR43/AstroImages/stable/manual/conventions/#Pixels","content":" Pixels This library considers the exact location of  img[1,1]  to be the center of the pixel in the bottom left corner. This means that plot limits should have the  1  tick slightly away from the left/bottom spines of the image. The default plot limits for  implot  are  -0.5  to  end+0.5  along both axes.  There is a  known bug  with the Plots.jl GR backend that leads ticks to be slightly offset. PyPlot and Plotly backends show the correct tick locations."},{"id":287,"pagetitle":"Converting from RGB","title":"Converting From RGB Images","ref":"/previews/PR43/AstroImages/stable/manual/converting-from-rgb/#Converting-From-RGB-Images","content":" Converting From RGB Images If you encouter an image in a standard graphics format (e.g. PNG, JPG) that you want to analyze or store in an AstroImage, it will likely contain RGB (or similar) pixels.  It is possible to store RGB data in an AstroImage. Let's see how that works: using AstroImages\ndownload(\"http://www.astro.uvic.ca/~wthompson/astroimages/fits/mw-crop2-small.png\",\"mw-crop2-small.png\")\n\n# First we load it from the PNG file\nmw_png = load(\"mw-crop2-small.png\") You will need the Images.jl package installed to load formats like PNG. Once the RGB image is loaded, we can store it in an AstroImage if we'd like: mw_ai = AstroImage(mw_png) However, we may want to extract the RGB channels first. We can do this using  Images.channelview . Images.channelview  returns a view into the RGB data as a 3 × X × Y dimension cube. Unfortunately, we will have to permute the dimensions slightly. using Images\nmw_png = load(\"mw-crop2-small.png\")\nmw_chan_view = channelview(mw_png)\nmw_rgb_cube = AstroImage(\n    permutedims(mw_chan_view, (3, 2, 1))[:,end:-1:begin,:],\n    # Optional:\n    (X=:, Y=:, Spec=[:R,:G,:B])\n) 2596×1440×3 AstroImage{N0f8,3} with dimensions: \n  X ,\n  Y ,\n  Dim{:Spec} Categorical Symbol[R, G, B] ReverseOrdered\n[:, :, 1]\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n ⋮                        ⋮              ⋱            ⋮                   \n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n[and 2 more slices...] Here we chose to mark the third axis as a spectral axis with keys  :R ,  :G , and  :B . We can now visualize each channel: mw_rgb_cube[Spec=At(:R)] # Or just: mw_rgb_cube[:,:,1] imview(\n    mw_rgb_cube[Spec=At(:R)],\n    cmap=nothing # Grayscale mode\n) using Plots\nimplot(mw_rgb_cube[Spec=At(:B)])"},{"id":290,"pagetitle":"Converting to RGB","title":"Converting to RGB","ref":"/previews/PR43/AstroImages/stable/manual/converting-to-rgb/#Converting-to-RGB","content":" Converting to RGB If you have two or more images of the same scene taken at different wavelengths, you may wish to combine them to create a colour composite. For ultimate control, you can do this manually using  imview . Simply map your channels to  RGB  values using  imview  and then sum the results. For convenience, AstroImages.jl provides the function  composecolors ."},{"id":291,"pagetitle":"Converting to RGB","title":"Using composecolors","ref":"/previews/PR43/AstroImages/stable/manual/converting-to-rgb/#Using-composecolors","content":" Using  composecolors We'll demonstrate  composecolors  using Hubble images of the Antenae colliding galaxies. One can be very scientific about this process, but often the goal of producing color composites is aesthetic or about highlighting certain features for public consumption.  I'll set the default color map to grayscale to avoid confusion. using AstroImages\n\nAstroImages.set_cmap!(nothing) Let's start by downloading the separate color channel FITS files: antred = AstroImage(download(\"http://www.astro.uvic.ca/~wthompson/astroimages/fits/antenae/red.fits\")) antgreen = AstroImage(download(\"http://www.astro.uvic.ca/~wthompson/astroimages/fits/antenae/green.fits\")) antblue = AstroImage(download(\"http://www.astro.uvic.ca/~wthompson/astroimages/fits/antenae/blue.fits\")) anthalph = AstroImage(download(\"http://www.astro.uvic.ca/~wthompson/astroimages/fits/antenae/hydrogen.fits\")); # Hydrogen-Alpha; we'll revisit later The images will have to be aligned and cropped to the same size before making a color composite. In order to compose these images, we'll have to match the relative intensity scales and clip outlying values. Thankfully,  composecolors  handles most of these details automatically. rgb1 = composecolors([antred, antgreen, antblue]) It's a start! By default, if you provide three images these are mapped to the color channels red, green, and blue. The intensities are limited to  Percent(99.5) . We can now tweak these defaults to our tastes. We could try clamping the intensities more agressively to bring out more of the galaxy structure: rgb2 = composecolors(\n    [antred, antgreen, antblue],\n    clims=Percent(97)\n) This looks okay but saturates the galaxy cores. Let's take care of that gash through the image by just blanking it out. mask = antgreen .== antgreen[end,begin]\n# remove holes in the mask\nusing ImageFiltering, Statistics\nmask = BitMatrix(mapwindow(median, mask, (3,3)))\nimview(mask) antred[mask] .= NaN\nantgreen[mask] .= NaN\nantblue[mask] .= NaN\nanthalph[mask] .= NaN; 92228-element view(::Vector{Float32}, [39, 40, 41, 42, 43, 44, 45, 46, 47, 48  …  1119338, 1119339, 1119340, 1119341, 1119342, 1119343, 1119344, 1119345, 1119346, 1119347]) with eltype Float32:\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN\n   ⋮\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN Typically we need to perform a \"gamma correction\" aka non-lienar stretch to map the wide dynamic range of astronomical images into a narrower human visible range. We can do this using the  stretch  keyword. An  asinhstretch  is typically recommended when preparing RGB images: rgb3 = composecolors(\n    [antred, antgreen, antblue],\n    stretch=asinhstretch\n) Keywords like  strech ,  clims , etc can be either a single value for all channels or a list of separate values/functions per channel. The green channel appears to be quite faint compared to the red and blue channels. We can modify that by adjusting the relative intensities of the channels.  We could also do this using a combination of the  contrast  and  bias  keywords. rgb4 = composecolors(\n    [antred, antgreen, antblue],\n    stretch=asinhstretch,\n    multiplier=[1,1.7,1]\n) That's better! Let's go one step further, and incorporate a fourth chanel: Hydrogen Alpha. Hydrogen Alpha is a narrow filter centered around one of the emission lines of Hydrogen atoms. It traces locations with hot gas; mostly star-formation regions in this case. imview(anthalph, cmap=:magma, clims=Zscale()) We'll now need to specify the color channels we want to use for each wavelength since we can't use just the default three RGB. We can use any named color or julia ColorScheme. rgb5 = composecolors(\n    [antred, antgreen, antblue, anthalph],\n    [\"red\", \"green\", \"blue\", \"maroon1\"],\n    stretch=asinhstretch,\n    multiplier=[1,1.7,1,0.8]\n) Additionally, I'd like to just show the brightest areas of Hydrogen alpha emission rather than adding a diffuse pink glow. We can turn off the stretch for this one channel: rgb6 = composecolors(\n    [antred, antgreen, antblue, anthalph],\n    [\"red\", \"green\", \"blue\", \"maroon1\"],\n    stretch=[\n        asinhstretch,\n        asinhstretch,\n        asinhstretch,\n        identity,\n    ],\n    multiplier=[1,1.7,1,0.8]\n) Finally, we can crop the image and save it as a PNG. crop = rgb6[200:end-100,50:end-50] save(\"antenae-composite.png\", crop) If you want to save it in a format like  JPG  that doesn't support transparent pixels, you could replace the masked area with zeros instead of  NaN ."},{"id":294,"pagetitle":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","ref":"/previews/PR43/AstroImages/stable/manual/dimensions-and-world-coordinates/#Dimensions-and-World-Coordinates","content":" Dimensions and World Coordinates AstroImages are based on  Dimensional Data . Each axis is assigned a dimension name and the indices are tracked."},{"id":295,"pagetitle":"Dimensions and World Coordinates","title":"World Coordinates","ref":"/previews/PR43/AstroImages/stable/manual/dimensions-and-world-coordinates/#World-Coordinates","content":" World Coordinates FITS files with world coordinate system (WCS) headers contain all the information necessary to map a pixel location into celestial coordinates & back. Let's see how this works with a 2D image with RA & DEC coordinates. using AstroImages\nusing Plots\n\n# Download a Hubble image of the Eagle nebula\ndownload(\n    \"http://www.astro.uvic.ca/~wthompson/astroimages/fits/656nmos.fits\",\n    \"eagle-656nmos.fits\"\n);\neagle = AstroImage(\"eagle-656nmos.fits\") This image contains world coordinate system headers. AstroImages.jl uses WCS.jl (and wcslib under the hood) to parse these headers. We can generate a WCSTransform object to inspect: wcs(eagle, 1) # specify which coordinate system WCSTransform(naxis=2,cdelt=[1.0, 1.0],crval=[274.71149247724, -13.816384007184],crpix=[386.5, 396.0]) Note that we specify with an index which coordinate system we'd like to use. Most images just contain one, but some contain multiple systems. We can lookup a coordinate from the image: world = pix_to_world(eagle, [1, 1]) # Bottom left corner 2-element Vector{Float64}:\n 274.712299241082\n -13.801135972688115 Or convert back from world coordinates to pixel coordinates: We can lookup a coordinate from the image: world_to_pix(eagle, world) # Bottom left corner 2-element Vector{Float64}:\n 1.000000000336172\n 0.9999999992196535 These pixel coordinates do not necessarily have to lie within the bounds of the original image, and in general lie at a fractional pixel position. If an image contains WCS headers, we can visualize them using  implot : implot(eagle) We can adjust the color of the grid: implot(eagle, gridcolor=:cyan) If these aren't desired, we can turn off the grid or the WCS tick marks: plot(\n  implot(eagle, grid=false),\n  implot(eagle, wcsticks=false),\n  size=(900,300),\n  bottommargin=10Plots.mm\n) Since AstroImages are based on DimensionalData's AbstractDimArray, the mapping between pixel coordinates and world coordinates are preserved when slicing an AstroImage: slice1 = eagle[1:800,1:800]\nslice2 = eagle[800:1600,1:800]\nplot(\n  implot(slice1),\n  implot(slice2),\n  size=(900,300),\n  bottommargin=10Plots.mm\n) World coordinate queries from that slice are aware of their position in the parent image: @show pix_to_world(slice1, [1,1])\n@show pix_to_world(slice2, [1,1]) 2-element Vector{Float64}:\n 274.7277517847315\n -13.817350009028138 Note  that you can query the dimensions of an image using the  dims  function from DimensionalData: dims(slice2) X Sampled 800:1600 ForwardOrdered Regular Points,\nY Sampled 1:800 ForwardOrdered Regular Points"},{"id":296,"pagetitle":"Dimensions and World Coordinates","title":"Named Dimensions","ref":"/previews/PR43/AstroImages/stable/manual/dimensions-and-world-coordinates/#Named-Dimensions","content":" Named Dimensions Each dimension of an AstroImage is named. The automatic dimension names are  X ,  Y ,  Z ,  Dim{4} ,  Dim{5} , and so on; however you can pass in other names or orders to the load function and/or AstroImage contructor: julia> img = load(\"eagle-656nmos.fits\",1,(Y,Z))\n1600×1600 AstroImage{Float32,2} with dimensions:\n  Y Sampled 1:1600 ForwardOrdered Regular Points,\n  Z Sampled 1:1600 ForwardOrdered Regular Points Other useful dimension names are  Spec  for spectral axes,  Pol  for polarization data, and  Ti  for time axes. These are tracked the same was as the automatic dimension names and interact smoothly with any WCS headers. You can give an arbitrary name using as a  Dim{Symbol} , e.g.  Dim{:Velocity} . You can access AstroImages using dimension names: eagle[X=100] 1600-element AstroImage{Float32,1} with dimensions: \n  Y Sampled Base.OneTo(1600) ForwardOrdered Regular Points\nand reference dimensions: \n  X Sampled 100:100 ForwardOrdered Regular Points\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n ⋮\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0 When indexing into a slice out of a larger parent image or cube, this named access refers to the  parent  dimensions: slice1 = eagle[600:800,600:800]\nslice1[X=At(700),Y=At(700)] == eagle[X=At(700),Y=At(700)] == eagle[700,700] true"},{"id":297,"pagetitle":"Dimensions and World Coordinates","title":"Cubes","ref":"/previews/PR43/AstroImages/stable/manual/dimensions-and-world-coordinates/#Cubes","content":" Cubes Let's see how this works with a 3D cube. using AstroImages\n\nHIcube = AstroImage(download(\"http://www.astro.uvic.ca/~wthompson/astroimages/fits/HIdat.fits\")) 150×150×450 AstroImage{Float32,3} with dimensions: \n  X Sampled Base.OneTo(150) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(150) ForwardOrdered Regular Points,\n  Z Sampled Base.OneTo(450) ForwardOrdered Regular Points\n[:, :, 1]\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN  …  NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN  …  NaN  NaN  NaN  NaN  NaN  NaN  NaN\n   ⋮                        ⋮            ⋱              ⋮                 \n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN  …  NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n[and 449 more slices...] Notice how the cube is not displayed automatically. We have to pick a specific slice: HIcube[Z=228] Using  implot , the world coordinates are displayed automatically: implot(HIcube[Z=228], cmap=:turbo) The plot automatically reflects the world coordinates embeded in the file. It displays the x axis in galactic longitude, the y-axis in galactic latitude, and even shows the curved projection from pixel coordinates to galactic coordinates. The title is automatically set to the world coordinate along the Z axis in units of velocity. It also picks up the unit of the data (Kelvins) to display on the colorbar. If we pick another slice, the title updates accordingly: implot(HIcube[Z=308], cmap=:turbo) This works for other slices through the cube as well: implot(HIcube[Y=45],  cmap=:turbo, aspectratio=0.3)"},{"id":298,"pagetitle":"Dimensions and World Coordinates","title":"Custom Dimensions","ref":"/previews/PR43/AstroImages/stable/manual/dimensions-and-world-coordinates/#Custom-Dimensions","content":" Custom Dimensions julia> img = load(\"img.fits\",1,(Y=1:1600,Z=1:1600))\n1600×1600 AstroImage{Float32,2} with dimensions:\n  Y Sampled 1:1600 ForwardOrdered Regular Points,\n  Z Sampled 1:1600 ForwardOrdered Regular Points Other useful dimension names are  Spec  for spectral axes,  Pol  for polarization data, and  Ti  for time axes. These are tracked the same was as the automatic dimension names and interact smoothly with any WCS headers. Often times we have images or cubes that we want to index with physical coordinates where setting up a full WCS transform is overkill. In these cases, it's easier to leverage custom dimensions. For example, one may wish to  julia> img = load(\"img.fits\",1,(X=801:2400,Y=1:2:3200))\n1600×1600 AstroImage{Float32,2} with dimensions:\n  X Sampled 801:2400 ForwardOrdered Regular Points,\n  Y Sampled 1:2:3199 ForwardOrdered Regular Points\n... Unlike OffsetArrays, the usual indexing remains so  img[1,1]  is still the bottom left of the image; however, data can be looked up according to the offset dimensions using specifiers: julia> img[X=Near(2000),Y=1..100]\n50-element AstroImage{Float32,1} with dimensions:\n  Y Sampled 1:2:99 ForwardOrdered Regular Points\nand reference dimensions:\n  X Sampled 2000:2000 ForwardOrdered Regular Points\n  0.0 You can adjust the center of an image's dimensions using  recenter : eagle_cen = recenter(eagle, 801, 801); Unlike an OffsetArray,  eagle_cen[1,1]  still refers to the bottom left of the image. This also has no effect on broadcasting,  eagle_cen .+ ones(1600,1600)  is perfectly valid. However, we see the new centered dimensions when we go to plot the image: implot(eagle_cen, wcsticks=false) And we can query positions using the offset dimensions: implot(eagle_cen[X=-300..300, Y=-300..300], wcsticks=false)"},{"id":301,"pagetitle":"Displaying Images","title":"Displaying Images","ref":"/previews/PR43/AstroImages/stable/manual/displaying-images/#Displaying-Images","content":" Displaying Images The  imview  and  implot  functions are very similar.  Both allow any abstract array of numbers to be rendered into an image or a Plots.jl image series.  implot  is largely a superset of  imview  because it also supports colorbars, tick marks, WCS grid lines, overplotting other data & shapes, and automatic axis and title naming (from the FITS header if available)."},{"id":302,"pagetitle":"Displaying Images","title":"imview","ref":"/previews/PR43/AstroImages/stable/manual/displaying-images/#imview","content":" imview Any AbstractArray (including an AstroImage) can be displayed using  imview . This function renders an arbitrary array into an array of  RGBA  values using a number of parameters. If the input is an AstroImage{<:Number}, an AstroImage{RGBA} will be returned that retains headers, WCS information, etc. The defaults for the  imview  function are: img = randn(50,50);\nimview(img; clims=Percent(99.5), cmap=:magma, stretch=identity, contrast=1.0, bias=0.5) We can adjust the color limits explicitly: imview(img; clims=(-1, 1)) Or pass a function/callable object to calculate them for us: imview(img; clims=Zscale()) We can turn off the colormap and use it in grayscale mode: imview(img; cmap=nothing) Pass any color scheme from ColorSchemes.jl: imview(img; cmap=:ice) imview(img; cmap=:seaborn_rocket_gradient) Or an RGB or named color value: imview(img; cmap=\"#F00\")\nimview(img; cmap=\"red\") Let's now switch to an astronomical image: fname = download(\n    \"http://www.astro.uvic.ca/~wthompson/astroimages/fits/656nmos.fits\",\n    \"eagle-656nmos.fits\"\n);\neagle = AstroImage(\"eagle-656nmos.fits\") We can apply a non-linear stretch like a log-scale, power-scale, or asinh stretch: imview(eagle, stretch=asinhstretch) Once rendered, we can also tweak the bias and contrast: imview(eagle, stretch=asinhstretch, contrast=1.5) imview(eagle, stretch=asinhstretch, contrast=1.5, bias=0.6) These are the parameters that change when you click and drag in some applications like DS9. Once rendered via  imview , the resulting image can be saved in traditional image formats like PNG, JPG, GIF, etc: save(\"out.png\", imview(eagle, cmap=:viridis)) Very large Images are automatically downscaled to ensure consistent performance using  restrict  from Images.jl. This function filters the data before downscaling to prevent aliasing, so it may take a moment for truly huge images. In these cases, a faster method that doesn't prevent aliasing would be  imview(img[begin:10:end, begin:10:end])  or similar. imview  is called automatically on  AstroImage{<:Number}  when using a Julia environment with rich graphical IO capabilities (e.g. VSCode, Jupyter, Pluto, etc.). The defaults for this case can be modified using  AstroImages.set_clims!(...) ,  AstroImages.set_cmap!(...) , and  AstroImages.set_stretch!(...) ."},{"id":303,"pagetitle":"Displaying Images","title":"Note on Views","ref":"/previews/PR43/AstroImages/stable/manual/displaying-images/#Note-on-Views","content":" Note on Views The function  imview  has its name because it produces a \"view\" into the image. The result from calling  imview  is an object that lazily maps data values into RGBA colors on the fly. This means that if you change the underlying data array, the view will update (the next time it is shown). If you have many data files to render, you may find it faster to create a single  imview  and then mutate the data in the underlying array. This is faster since  imview  only has to resolve colormaps and compute limits once. For example: data = randn(100,100)\niv = imview(data)\ndisplay(iv)\ndata[1:50,1:50] .= 0\ndisplay(iv) iv  will reflect the changes to  data  when it is displayed the second time."},{"id":304,"pagetitle":"Displaying Images","title":"implot","ref":"/previews/PR43/AstroImages/stable/manual/displaying-images/#implot","content":" implot implot   is a Plots.jl recipe, which means before you can use it you first have to load  Plots.jl : using Plots implot  accepts all the arguments  imview  does for controlling how data is rendered to the screen. implot(img; clims=Percent(99.5), cmap=:magma, stretch=identity, contrast=1.0, bias=0.5)"},{"id":307,"pagetitle":"Getting Started","title":"Getting Started","ref":"/previews/PR43/AstroImages/stable/manual/getting-started/#Getting-Started","content":" Getting Started To get started, you will first need to install AstroImages. After starting Julia, enter package-mode by typing  ]  and then pkg> add AstroImages To display images and save them in traditional graphics formats like PNG, JPG, GIF, etc., you will also need to add the  ImageIO  package. Once installed, this package doesn't need to be loaded explicitly. For some of the more advanced visualizations you may also want  Plots : pkg> add Plots To load the package, run: using AstroImages\n# And if desired:\nusing Plots"},{"id":310,"pagetitle":"Headers","title":"Headers","ref":"/previews/PR43/AstroImages/stable/manual/headers/#Headers","content":" Headers FITS files consist of one or more HDUs (header data units), and each HDU can contain an N-dimensional image or table. Before the data is a  header . Headers contain (key, value, comment) groups as well as dedicated long-form COMMENT and HISTORY sections used to document, for example, the series of post-processing steps applied to an image."},{"id":311,"pagetitle":"Headers","title":"Accessing Headers","ref":"/previews/PR43/AstroImages/stable/manual/headers/#Accessing-Headers","content":" Accessing Headers Here are some examples of how to set and read keys, comments, and history. Well start by making a blank image. img = AstroImage(zeros(10,10))\n# Set keys to values with different data types\nimg[\"KEY1\"] = 2   # Integer\nimg[\"KEY2\"] = 2.0 # Float\nimg[\"KEY3\"] = \"STRING\"\nimg[\"KEY4\"] = true\nimg[\"KEY5\"] = false\nimg[\"KEY6\"] = nothing\n\n# Set comments\nimg[\"KEY1\", Comment] = \"A key with an integer value\"\n\n# Read keys\na = img[\"KEY3\"]\n\n# Read comment\ncom = img[\"KEY1\", Comment]\n\n# Add long-form COMMENT\npush!(img, Comment, \"\"\"\nWe now describe how to add a long form comment to the end of a header.\n\"\"\")\n\n# Add HISTORY entry\npush!(img, History, \"\"\"\nWe now describe how to add a long form history to the end of a header.\n\"\"\")\n\n# Retrieve long form comments/ history\ncomment_strings = img[Comment]\nhistory_strings = img[History] Note that floating point values are formatted as ASCII strings when written to the FITS files, so the precision may be limited.  AstroImage  objects wrap a FITSIO.jl  FITSHeader . If necessary, you can recover it using  header(img) ; however, in most cases you can access header keywords directly from the image. API docs:  Comment History header"},{"id":314,"pagetitle":"Loading & Saving Images","title":"Loading Images","ref":"/previews/PR43/AstroImages/stable/manual/loading-images/#Loading-Images","content":" Loading Images FITS (Flexible Image Transport System) files can be loaded and saved using AstroImages thanks to the FITSIO package. AstroImages is registered with  FileIO , so if you have FileIO and AstroImages installed you can get started with the  load  function. When you pass a file name with the appropriate file extension (\".fits\", \".fit\", etc.) FileIO will import AstroImages automatically. Alternatively, you can use the  AstroImage  contructor instead of load. This will work on fits files with any file extension, including compressed files (e.g. \".fits.gz\"). julia> img = load(\"myfitsimg.fits\")\n1600×1600 AstroImage{Float32,2} with dimensions:\n  X Sampled Base.OneTo(1600) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(1600) ForwardOrdered Regular Points\n 0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n ⋮                        ⋱\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0 Note: if you are in an interactive environment like VSCode, Jupyter, or Pluto, instead of a REPL, AstroImages are automatically rendered to images and displayed. You can see this plain text output by explicitly calling:  show(stdout, MIME(\"text/plain\"), img) . Or:  julia> img = AstroImage(\"myfitsimg.fits.gz\")\n1600×1600 AstroImage{Float32,2} with dimensions:\n  X Sampled Base.OneTo(1600) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(1600) ForwardOrdered Regular Points\n 0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n ⋮                        ⋱\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0 A FITS file can contain multiple N-dimensional images and tables. When you call load or AstroImage with a file name and no other arguments, the package will search through the file and return the first image HDU. That is, it will skip any FITS tables or empty HDUs with only headers. You can also specify an HDU number explicitly: julia> img = load(\"myfitsimg.fits\",1)\n1600×1600 AstroImage{Float32,2} with dimensions:\n  X Sampled Base.OneTo(1600) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(1600) ForwardOrdered Regular Points\n... This way, you can load specific images from multi-extension files. You can load all HDUs simultaneously by passing  : : julia> hdus = load(\"multiext.fits\", :);\njulia> hdus[2] # Second HDU as an AstroImage\n10×10 AstroImage{Float64,2} with dimensions:\n  X Sampled Base.OneTo(10) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(10) ForwardOrdered Regular Points\n -0.777315  -1.36683   -0.580179     1.39629      …  -2.14298     0.450059   0.432065\n -1.09619    0.789249   0.938415     0.959903        -0.88995    -1.29406   -0.4291\n  0.47427   -1.41855    0.814823    -1.15975          0.0427149  -1.20116   -0.0920709\n -0.179858  -1.60228    1.09648     -0.497927        -1.31824    -0.156529  -0.0223846\n  2.64162    0.131437   0.320476     0.331197        -0.914713   -1.55162   -0.18862\n  0.209669  -1.17923   -0.656512     0.000775311  …   0.377461   -0.24278    0.967202\n  1.01442   -0.762895  -2.13238     -0.456932        -0.415733   -1.21416   -1.6108\n  0.385626   0.389335  -0.00726015   0.309936        -0.533175    0.157878   0.100876\n -1.24799    0.461216  -0.868826    -0.255654        -0.37151     0.49479   -1.87129\n  1.39356    2.29254    0.0548325    1.50674         -0.0880865   0.580978  -1.81629\njulia> # Or:\njulia> hdu1, hdu2, hdu3 = load(\"multiext.fits\", :); There is also limited support for table HDUs. In this case, a bare-bones Tables.jl compatible  object is returned."},{"id":315,"pagetitle":"Loading & Saving Images","title":"Dimension Names","ref":"/previews/PR43/AstroImages/stable/manual/loading-images/#Dimension-Names","content":" Dimension Names You may have noticed the entries above the image array: 10×10 AstroImage{Float64,2} with dimensions:\n  X Sampled Base.OneTo(10) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(10) ForwardOrdered Regular Points AstroImages are based on  Dimensional Data . Each axis is assigned a dimension name and the indices are tracked. The automatic dimension names are  X ,  Y ,  Z ,  Dim{4} ,  Dim{5} , and so on; however you can pass in other names or orders to the load function and/or AstroImage contructor: julia> img = load(\"img.fits\",1,(Y=1:1600,Z=1:1600))\n1600×1600 AstroImage{Float32,2} with dimensions:\n  Y Sampled 1:1600 ForwardOrdered Regular Points,\n  Z Sampled 1:1600 ForwardOrdered Regular Points Other useful dimension names are  Spec  for spectral axes,  Pol  for polarization data, and  Ti  for time axes. These will be further discussed in Dimensions and World Coordinates."},{"id":316,"pagetitle":"Loading & Saving Images","title":"Saving Images","ref":"/previews/PR43/AstroImages/stable/manual/loading-images/#Saving-Images","content":" Saving Images You can save one or more AstroImages and tables to a FITS file using the  save  function: julia> save(\"abc.fits\", astroimage1, astroimage2, table1) You can also save individual images to traditional graphics formats by first rendering them with  imview  (for more on imview, see Displaying Images). julia> save(\"abc.png\", imview(astroimage1)) You can save animated GIFs by saving a 3D datacube that has been rendered with imview: julia> cube =  imview(AstroImage(randn(100,100,10)));\njulia> save(\"abc.gif\", cube, fps=10)\n\njulia> # Or a more complex example (changing color schemes each frame)\njulia> img = randn(10,10)\njulia> cube2 = [imview(img1, cmap=:magma) ;;; imview(img2, cmap=:plasma) ;;; imview(img3, cmap=:viridis)]\njulia> # Alternative syntax:\njulia> cube2 = cat(imview(img1, cmap=:magma), imview(img2, cmap=:plasma), imview(img3, cmap=:viridis), dims=3)\njulia> save(\"abc.gif\", cube, fps=10)"},{"id":321,"pagetitle":"Preserving Wrapper","title":"Preserving the AstroImage Wrapper","ref":"/previews/PR43/AstroImages/stable/manual/preserving-wrapper/#Preserving-the-AstroImage-Wrapper","content":" Preserving the AstroImage Wrapper Wherever possible, overloads have been added to DimensionalData and AstroImages so that common operations retain the  AstroImage  wrapper with associated dimensions, FITS header, and WCS information. Most of the time this works automatically if libraries follow good patterns like allocating outputs using  Base.similar . However, some other library functions may follow patterns like allocating a plain  Array  of the correct size and then filling it.  To make it easier to work with these libraries, AstroImages exports two functions  copyheader  and  shareheader .  These functions wrap an AbstractArray in an AstroImage while copying over the header, dimensions, and WCS info. Consider the function: function badfunc(arr)\n    out = zeros(size(arr)) # instead of similar(arr)\n    out .= arr.^2\n    return out\nend Calling  badfunc(astroimg)  will return a plain  Array  . We can use  copyheader  to retain the  AstroImage  wrapper: copyheader(astroimg, badfunc(astroimg)) For particularly incompatible functions that require an Array (not subtype of AbstractArray) we can go one step further: copyheader(astroimg, worsefunc(parent(astroimg)))\n# Or:\ncopyheader(astroimg, worsefunc(collect(astroimg)))"},{"id":338,"pagetitle":"Package library","title":"SAOImageDS9.get","ref":"/previews/PR43/SAOImageDS9/stable/library/#SAOImageDS9.get","content":" SAOImageDS9.get  —  Function . SAOImageDS9.get([T, [dims,]] args...) sends a \"get\" request to the SAOImage/DS9 server.  The request is made of arguments  args...  converted into strings and merged with separating spaces. An exception is thrown in case of error. The returned value depends on the optional arguments  T  and  dims : If neither  T  nor  dims  are specified, an instance of  XPA.Reply  is returned with at most one answer (see documentation for  XPA.get  for more details). If only  T  is specified, it can be: String  to return the answer as a single string; Vector{String}}  or  Tuple{Vararg{String}}  to return the answer split in words as a vector or as a tuple of strings; T  where  T<:Real  to return a value of type  T  obtained by parsing the textual answer. Tuple{Vararg{T}}  where  T<:Real  to return a value of type  T  obtained by parsing the textual answer; Vector{T}  where  T  is not  String  to return the binary contents of the answer as a vector of type  T ; If both  T  and  dims  are specified,  T  can be an array type like  Array{S}  or  Array{S,N}  and  dims  a list of  N  dimensions to retrieve the binary contents of the answer as an array of type  Array{S,N} . As a special case: SAOImageDS9.get(Array; endian=:native) -> arr yields the contents of current SAOImage/DS9 frame as an array (or as  nothing  if the frame is empty). Keyword  endian  can be used to specify the byte order of the received values (see  SAOImageDS9.byte_order ). To retrieve the version of the SAOImage/DS9 program: SAOImageDS9.get(VersionNumber) See also  SAOImageDS9.connect ,  SAOImageDS9.set  and  XPA.get . source"},{"id":339,"pagetitle":"Package library","title":"SAOImageDS9.set","ref":"/previews/PR43/SAOImageDS9/stable/library/#SAOImageDS9.set","content":" SAOImageDS9.set  —  Function . SAOImageDS9.set(args...; data=nothing) sends command and/or data to the SAOImage/DS9 server.  The command is made of arguments  args...  converted into strings and merged with a separating spaces. Keyword  data  can be used to specify the data to send.  An exception is thrown in case of error. As a special case: SAOImageDS9.set(arr; mask=false, new=false, endian=:native) set the contents of the current SAOImage/DS9 frame to be array  arr .  Keyword  new  can be set true to create a new frame for displyaing the array.  Keyword  endian  can be used to specify the byte order of the values in  arr  (see  SAOImageDS9.byte_order . See also  SAOImageDS9.connect ,  SAOImageDS9.get  and  XPA.set . source Connection"},{"id":340,"pagetitle":"Package library","title":"SAOImageDS9.connect","ref":"/previews/PR43/SAOImageDS9/stable/library/#SAOImageDS9.connect","content":" SAOImageDS9.connect  —  Function . SAOImageDS9.connect(ident=\"DS9:*\") -> apt set the access point for further SAOImage/DS9 commands.  Argument  ident  identifies the XPA access point, it can be a template string like  \"DS9:*\"  which is the default value or a regular expression.  The returned value is the name of the access point. To retrieve the name of the current SAOImage/DS9 access point, call the  SAOImageDS9.accesspoint  method. source"},{"id":341,"pagetitle":"Package library","title":"SAOImageDS9.accesspoint","ref":"/previews/PR43/SAOImageDS9/stable/library/#SAOImageDS9.accesspoint","content":" SAOImageDS9.accesspoint  —  Function . SAOImageDS9.accesspoint() yields the XPA access point which identifies the SAOImage/DS9 server.  This access point can be set by calling the  SAOImageDS9.connect  method. An empty string is returned if no access point has been chosen.  To automatically connect to SAOImage/DS9 if not yet done, you can do: if SAOImageDS9.accesspoint() == \"\"; SAOImageDS9.connect(); end See also  SAOImageDS9.connect  and  SAOImageDS9.accesspoint . source Drawing"},{"id":342,"pagetitle":"Package library","title":"SAOImageDS9.draw","ref":"/previews/PR43/SAOImageDS9/stable/library/#SAOImageDS9.draw","content":" SAOImageDS9.draw  —  Function . SAOImageDS9.draw(args...; kwds...) draws something in SAOImage/DS9 application.  The operation depends on the type of the arguments. SAOImageDS9.draw(img; kwds...) displays image  img  (a 2-dimensional Julia array) in SAOImage/DS9. The following keywords are possible: Keyword  frame  can be used to specify the frame number. Keyword  cmap  can be used to specify the name of the colormap.  For instance,  cmap=\"gist_stern\" . Keyword  zoom  can be used to specify the zoom factor. Keywords  min  and/or  max  can be used to specify the scale limits. SAOImageDS9.draw(pnt; kwds...) draws  pnt  as point(s) in SAOImage/DS9,  pnt  is a  Point , an array or a tuple of  Point . SAOImageDS9.draw(box; kwds...) draws  box  as rectangle(s) in SAOImage/DS9,  box  is a  BoundingBox , an array or a tuple of  BoundingBox . source Utilities"},{"id":343,"pagetitle":"Package library","title":"SAOImageDS9.bitpix_of","ref":"/previews/PR43/SAOImageDS9/stable/library/#SAOImageDS9.bitpix_of","content":" SAOImageDS9.bitpix_of  —  Function . SAOImageDS9.bitpix_of(x) -> bp yields FITS bits-per-pixel (BITPIX) value for  x  which can be an array or a type.  A value of 0 is returned if  x  is not of a supported type. See also  SAOImageDS9.bitpix_to_type . source"},{"id":344,"pagetitle":"Package library","title":"SAOImageDS9.bitpix_to_type","ref":"/previews/PR43/SAOImageDS9/stable/library/#SAOImageDS9.bitpix_to_type","content":" SAOImageDS9.bitpix_to_type  —  Function . SAOImageDS9.bitpix_to_type(bp) -> T yields Julia type corresponding to FITS bits-per-pixel (BITPIX) value  bp . The value  Nothing  is returned if  bp  is unknown. See also  SAOImageDS9.bitpix_of . source"},{"id":345,"pagetitle":"Package library","title":"SAOImageDS9.byte_order","ref":"/previews/PR43/SAOImageDS9/stable/library/#SAOImageDS9.byte_order","content":" SAOImageDS9.byte_order  —  Function . SAOImageDS9.byte_order(endian) yields the byte order for retrieving the elements of a SAOImage/DS9 array. Argument can be one of the strings (or the equivalent symbol):  \"big\"  for most significant byte first,  \"little\"  for least significant byte first or  \"native\"  to yield the byte order of the machine. See also  SAOImageDS9.get ,  SAOImageDS9.set . source Previous Examples"},{"id":354,"pagetitle":"Home","title":"CCDReduction.jl","ref":"/previews/PR43/CCDReduction/stable/#CCDReduction.jl","content":" CCDReduction.jl This package provides tools for basic reduction methods of CCD images."},{"id":355,"pagetitle":"Home","title":"Installation","ref":"/previews/PR43/CCDReduction/stable/#Installation","content":" Installation From Julia enter Pkg mode julia>]\n\n(1.3) pkg> add CCDReduction"},{"id":356,"pagetitle":"Home","title":"Usage","ref":"/previews/PR43/CCDReduction/stable/#Usage","content":" Usage You'll recognize most of the familiar reduction operations allow us to quickly and easily operate on data. using CCDReduction\n\nnoise = randn(512, 512)\nbias_frame = reshape(1:262144, 512, 512) |> collect\nimg = reshape(1:262144, 512, 512) .+ noise\n\nsubtract_bias(img, bias_frame) In addition to working on array-like data, we can directly load from a  FITSIO.ImageHDU  or from a filename using FITSIO\n\n# make fits file\nbias_frame = reshape(1:262144, 512, 512) |> collect\nFITS(\"master_bias.fits\", \"w\") do f\n    write(f, bias_frame)\nend\nimg = 10 .* randn(512, 512)\ndebiased = subtract_bias(img, \"master_bias.fits\") Finally, we can use function chaining (or tools like  Underscores.jl ) for creating a simple processing pipeline! using Underscores\n\n# 5 science frames\nimgs = (10 .* randn(512, 524) for _ in 1:5)\n\n# create pipeline using Underscores.jl\npipeline(img) = @_ img |>\n    subtract_overscan(__, (:, 513:524)) |>\n    trim(__, (:, 513:524)) |>\n    subtract_bias(__, \"master_bias.fits\")\n\n# apply pipeline to images using broadcast syntax\ncalib_imgs = pipeline.(imgs)"},{"id":357,"pagetitle":"Home","title":"License","ref":"/previews/PR43/CCDReduction/stable/#License","content":" License This work is distributed under the MIT \"expat\" license. See  LICENSE  for more information."},{"id":360,"pagetitle":"API/Reference","title":"API/Reference","ref":"/previews/PR43/CCDReduction/stable/api/#API/Reference","content":" API/Reference For now, here is a list of all documented functions."},{"id":361,"pagetitle":"API/Reference","title":"Index","ref":"/previews/PR43/CCDReduction/stable/api/#Index","content":" Index CCDReduction.AbstractCCDData CCDReduction.CCDData CCDReduction.CCDData CCDReduction.CCDData CCDReduction.arrays CCDReduction.arrays CCDReduction.ccds CCDReduction.ccds CCDReduction.combine CCDReduction.crop CCDReduction.cropview CCDReduction.filenames CCDReduction.filenames CCDReduction.find_ccd CCDReduction.fitscollection CCDReduction.flat_correct CCDReduction.flat_correct! CCDReduction.getdata CCDReduction.subtract_bias CCDReduction.subtract_bias! CCDReduction.subtract_dark CCDReduction.subtract_dark! CCDReduction.subtract_overscan CCDReduction.subtract_overscan! CCDReduction.trim CCDReduction.trimview CCDReduction.writefits"},{"id":362,"pagetitle":"API/Reference","title":"API/Reference","ref":"/previews/PR43/CCDReduction/stable/api/#API/Reference-2","content":" API/Reference"},{"id":363,"pagetitle":"API/Reference","title":"CCDReduction.AbstractCCDData","ref":"/previews/PR43/CCDReduction/stable/api/#CCDReduction.AbstractCCDData","content":" CCDReduction.AbstractCCDData  —  Type AbstractCCDData{T} Supertype for  CCDData  based on  AbstractMatrix  interface. Every subtype of this type should have methods  data  and  hdr  defined. source"},{"id":364,"pagetitle":"API/Reference","title":"CCDReduction.CCDData","ref":"/previews/PR43/CCDReduction/stable/api/#CCDReduction.CCDData","content":" CCDReduction.CCDData  —  Type CCDData(data::AbstractMatrix, [hdr::FITSHeader]) Struct to store  ImageHDU , derived from  AbstractCCDData . CCDData  acts like a matrix with a header associated. ccd = CCDData(zeros(4, 4))\n\nccd[1] This accesses the 1st element in matrix associated with  ccd . ccd[\"SIMPLE\"] One can also access the header directly from  ccd , the key can be  Symbol  as well. ccd[:SIMPLE] = false Header values can be directly modified from  ccd . One can perform arithmetic operations on it as well: ccd1 = CCDData(zeros(4, 4))\n\nccd2 = CCDData(ones(4, 4))\n\nsum_ccd1 = ccd1 + ccd2\n\nsum_ccd2 = ccd2 + ccd1 sum_ccd1  has the header of  ccd1  whereas  sum_ccd2  has the header  ccd2 . If header is not provided in the  CCDData  constructor,  default_header  is used to generate the header. source"},{"id":365,"pagetitle":"API/Reference","title":"CCDReduction.CCDData","ref":"/previews/PR43/CCDReduction/stable/api/#CCDReduction.CCDData-Tuple{AbstractString}","content":" CCDReduction.CCDData  —  Method CCDData(path::AbstractString; hdu = 1) Loads HDU from  hdu  index in  FITS  file at  path  as  CCDData . source"},{"id":366,"pagetitle":"API/Reference","title":"CCDReduction.CCDData","ref":"/previews/PR43/CCDReduction/stable/api/#CCDReduction.CCDData-Tuple{FITSIO.ImageHDU}","content":" CCDReduction.CCDData  —  Method CCDData(hdu::ImageHDU) Loads  ImageHDU  as  CCDData . source"},{"id":367,"pagetitle":"API/Reference","title":"CCDReduction.arrays","ref":"/previews/PR43/CCDReduction/stable/api/#CCDReduction.arrays","content":" CCDReduction.arrays  —  Function arrays(collection) Generator for arrays of images of entries in data frame. Iterates over  collection  using each  path  and  hdu  to load data into an  Array . Examples collection = fitscollection(\"~/data/tekdata\")\ndata = arrays(collection) |> collect This returns all image arrays present in  collection . This can also be used via a for-loop collection = fitscollection(\"~/data/tekdata\")\nfor arr in arrays(collection)\n    @assert arr isa Array\n    println(size(arr))\nend\n\n# output\n(1048, 1068)\n(1048, 1068)\n... source"},{"id":368,"pagetitle":"API/Reference","title":"CCDReduction.arrays","ref":"/previews/PR43/CCDReduction/stable/api/#CCDReduction.arrays-Tuple{Any, Any}","content":" CCDReduction.arrays  —  Method arrays(f,\n       collection;\n       path = nothing,\n       save_prefix = nothing,\n       save_suffix = nothing,\n       save = any(!isnothing, (save_prefix, path, save_suffix)),\n       save_delim = \"_\",\n       ext = r\"fits(\\.tar\\.gz)?\"i,\n       kwargs...) Iterates over the image arrays of the collection applying function  f  at each step. The output from  f  can be saved using the appropriate keyword arguments. The  save_prefix  argument will add a prefix to each filename delimited by  save_delim .  save_suffix  will add a suffix prior to the extension, which can be manually provided via  ext , similar to  fitscollection . Files will be saved in the directory they are stored unless  path  is given. Finally,  save  will default to  true  if any of the previous arguments are set, but can be manually overridden (useful for testing). Files will be saved using  CCDReduction.writefits . Examples collection = fitscollection(\"~/data/tekdata\")\nprocessed_images = map(arrays(collection)) do arr\n    trim(arr, (:, 1040:1059))\nend The above generates  processed_images  which consists of trimmed versions of image arrays present in  collection . For saving the  processed_images  simultaneously with the operations performed processed_images = map(arrays(collection; path = \"~/data/tekdata\", save_prefix = \"trimmed\")) do img\n    trim(img, (:, 1040:1059))\nend The trimmed image arrays are saved as  trimmed_(original_name)  (FITS files) at  path = \"~/data/tekdata\"  as specified by the user. source"},{"id":369,"pagetitle":"API/Reference","title":"CCDReduction.ccds","ref":"/previews/PR43/CCDReduction/stable/api/#CCDReduction.ccds","content":" CCDReduction.ccds  —  Function ccds(collection) Generator for  CCDData s of entries in data frame. Iterates over  collection  using each  path  and  hdu  to load data into a  CCDData . Examples collection = fitscollection(\"~/data/tekdata\")\nfor hdu in ccds(collection)\n    @assert hdu isa CCDData\nend source"},{"id":370,"pagetitle":"API/Reference","title":"CCDReduction.ccds","ref":"/previews/PR43/CCDReduction/stable/api/#CCDReduction.ccds-Tuple{Any, Any}","content":" CCDReduction.ccds  —  Method ccds(f,\n     collection;\n     path = nothing,\n     save_prefix = nothing,\n     save_suffix = nothing,\n     save = any(!isnothing, (save_prefix, path, save_suffix)),\n     save_delim = \"_\",\n     ext = r\"fits(\\.tar\\.gz)?\"i,\n     kwargs...) Iterates over the  CCDData s of the collection applying function  f  at each step. The output from  f  can be saved using the appropriate keyword arguments. The  save_prefix  argument will add a prefix to each filename delimited by  save_delim .  save_suffix  will add a suffix prior to the extension, which can be manually provided via  ext , similar to  fitscollection . Files will be saved in the directory they are stored unless  path  is given. Finally,  save  will default to  true  if any of the previous arguments are set, but can be manually overridden (useful for testing). Files will be saved using  CCDReduction.writefits . Example collection = fitscollection(\"~/data/tekdata\")\nprocessed_images = map(ccds(collection)) do img\n    trim(img, (:, 1040:1059))\nend The above generates  processed_images  which consists of trimmed versions of images present in  collection . For saving the  processed_images  simultaneously with the operations performed processed_images = map(ccds(collection; path = \"~/data/tekdata\", save_prefix = \"trimmed\")) do img\n    trim(img, (:, 1040:1059))\nend The trimmed images are saved as  trimmed_(original_name)  (FITS files) at  path = \"~/data/tekdata\"  as specified by the user. source"},{"id":371,"pagetitle":"API/Reference","title":"CCDReduction.combine","ref":"/previews/PR43/CCDReduction/stable/api/#CCDReduction.combine-Tuple{Vararg{AbstractArray{var\"#s2\", N} where {var\"#s2\"<:Number, N}, N} where N}","content":" CCDReduction.combine  —  Method combine(frames...; method = median, [hdu = 1], [header_hdu = 1])\ncombine(frames; method = median, [hdu = 1], [header_hdu = 1]) Combine multiple frames using  method . Multiple frames can also be passed in a vector or as generators for combining. To pass a custom method, it must have a signature like  method(::AbstractArray; dims) . If  frames  are strings, they will be loaded into  CCDData s first. The HDU indices can be specified with  hdu  as either an integer or a tuple corresponding to each file. Header of output file (if applicable) is specified by  header_hdu  which by default is 1. Examples julia> frame = [reshape(1.0:4.0, (2, 2)) for i = 1:4];\n\njulia> combine(frame)\n2×2 Matrix{Float64}:\n 1.0  3.0\n 2.0  4.0\n\njulia> combine(frame, method = sum)\n2×2 Matrix{Float64}:\n 4.0  12.0\n 8.0  16.0\n source"},{"id":372,"pagetitle":"API/Reference","title":"CCDReduction.crop","ref":"/previews/PR43/CCDReduction/stable/api/#CCDReduction.crop-Tuple{Any, Any}","content":" CCDReduction.crop  —  Method crop(frame, shape; force_equal = true, [hdu = 1]) Crops  frame  to the size specified by  shape  anchored by the frame center. This will remove rows/cols of the  frame  equally on each side. When there is an uneven difference in sizes (e.g. size 9 -> 6 can't be removed equally) the default is to increase the output size (e.g. 6 -> 7) so there is equal removal on each side. To disable this, set  force_equal=false , which will remove the extra slice from the end of the axis. If  frame  is a string, it will be loaded into  CCDData  first. The HDU loaded can be specified by  hdu  which by default is 1. Examples julia> frame = reshape(1:25, (5, 5));\n\njulia> crop(frame, (3, 3))\n3×3 Matrix{Int64}:\n 7  12  17\n 8  13  18\n 9  14  19\n\njulia> crop(frame, (4, 3), force_equal = false)\n4×3 Matrix{Int64}:\n 6  11  16\n 7  12  17\n 8  13  18\n 9  14  19\n See Also cropview source"},{"id":373,"pagetitle":"API/Reference","title":"CCDReduction.cropview","ref":"/previews/PR43/CCDReduction/stable/api/#CCDReduction.cropview-Tuple{AbstractArray, Any}","content":" CCDReduction.cropview  —  Method cropview(frame, shape; force_equal = true) Crops  frame  to the size specified by  shape  anchored by the frame center. This function is same as the  crop  function but returns a view of the frame. Note This function returns a view of the frame, so any modification to output array will result in modification of frame. See Also crop source"},{"id":374,"pagetitle":"API/Reference","title":"CCDReduction.filenames","ref":"/previews/PR43/CCDReduction/stable/api/#CCDReduction.filenames","content":" CCDReduction.filenames  —  Function filenames(collection) Generator for filenames of entries in data frame. Iterates over  collection  using each  path . Examples collection = fitscollection(\"~/data/tekdata\")\nfor path in filenames(collection)\n    @assert path isa String\n    println(path)\nend\n\n# output\n\"~/data/tekdata/tek001.fits\"\n\"~/data/tekdata/tek002.fits\"\n... source"},{"id":375,"pagetitle":"API/Reference","title":"CCDReduction.filenames","ref":"/previews/PR43/CCDReduction/stable/api/#CCDReduction.filenames-Tuple{Any, Any}","content":" CCDReduction.filenames  —  Method filenames(f,\n          collection;\n          path = nothing,\n          save_prefix = nothing,\n          save_suffix = nothing,\n          save = any(!isnothing, (save_prefix, path, save_suffix)),\n          save_delim = \"_\",\n          ext = r\"fits(\\.tar\\.gz)?\"i,\n          kwargs...) Iterates over the file paths of the collection applying function  f  at each step. The output from  f  can be saved using the appropriate keyword arguments. The  save_prefix  argument will add a prefix to each filename delimited by  save_delim .  save_suffix  will add a suffix prior to the extension, which can be manually provided via  ext , similar to  fitscollection . Files will be saved in the directory they are stored unless  path  is given. Finally,  save  will default to  true  if any of the previous arguments are set, but can be manually overridden (useful for testing). Files will be saved using  CCDReduction.writefits . Examples collection = fitscollection(\"~/data/tekdata\")\ndata = map(filenames(collection)) do path\n    fh = FITS(path)\n    data = getdata(fh[1]) # assuming all 1-hdu are ImageHDUs\n    close(fh)\n    data\nend The above generates  data  which consists of image arrays corresponding to 1st hdu of FITS file paths present in  collection . For saving the  data  simultaneously with the operations performed data = map(filenames(collection; path = \"~/data/tekdata\", save_prefix = \"retrieved_from_filename\")) do img\n    fh = FITS(path)\n    data = getdata(fh[1]) # assuming all 1-hdu are ImageHDUs\n    close(fh)\n    data\nend The retrieved data is saved as  retrieved_from_filename_(original_name)  (FITS files) at  path = \"~/data/tekdata\"  as specified by the user. source"},{"id":376,"pagetitle":"API/Reference","title":"CCDReduction.find_ccd","ref":"/previews/PR43/CCDReduction/stable/api/#CCDReduction.find_ccd-Tuple{Base.Broadcast.Broadcasted}","content":" CCDReduction.find_ccd  —  Method A = find_ccd(As)  returns the first CCDData among the arguments. source"},{"id":377,"pagetitle":"API/Reference","title":"CCDReduction.fitscollection","ref":"/previews/PR43/CCDReduction/stable/api/#CCDReduction.fitscollection-Tuple{String}","content":" CCDReduction.fitscollection  —  Method fitscollection(dir;\n               recursive=true,\n               abspath=true,\n               keepext=true,\n               ext=r\"fits(\\.tar\\.gz)?\",\n               exclude=nothing,\n               exclude_dir=nothing,\n               exclude_key=(\"\", \"HISTORY\")) Walk through  dir  collecting FITS files, scanning their headers, and culminating into a  DataFrame  that can be used with the generators for iterating over many files and processing them. If  recursive  is false, no subdirectories will be walked through. The table returned will contain the path to the file, the name of the file, and index of the corresponding HDU, and each FITS header column and value. If two FITS files have distinct columns, they will both appear in the table with  missing  in the appropriate rows.  Duplicate Keys In certain cases, there are multiple FITS headers with the same key, e.g.,  COMMENT . In these cases, only the first instance of the key-value pair will be stored. If  abspath  is true, the path in the table will be absolute. If  keepext  is true, the name in the table will include the file extension, given by  ext .  ext  will be used with  endswith  to filter for fits files compatible with  FITSIO.FITS .  exclude  is a pattern that can be used with  occursin  to exclude certain filenames. For example, to exclude any files containing \"sky\", fitscollection(...; exclude=\"sky\") to exclude exact filenames,  regex strings  will prove powerful fitscollection(...; exclude=r\"^tek001\\d\") finally, using external tools like  Glob.jl  allows further customization using Glob\nfitscollection(...; exclude=fn\"tek001*.fits\") # same as regex match above Similarly,  exclude_dir  allows excluding entire folders using pattern matching (e.g. skipping a backup folder  exclude_dir=\"backup\" ).  exclude_key  allows excluding certain entries in the header unit of  ImageHDU  in FITS files (e.g. skipping  \"HISTORY\"  and  \"\" exclude_key = (\"HISTORY\", \"\") ). For more information about the file matching and path deconstruction, see the extended help ( ??fitscollection ) Extended Help Parts of a path Let's look at some file paths starting from  \"/data\" . Here are examples of how they would be parsed  root  dir   base   ext\n[----][---][------][---]\n/data/test/tek0001.fits\n\n root    dir     base   ext\n[----][-------][------][---]\n/data/test/sci/tek0001.fits If  keepext  is  true ,  name=base * ext , otherwise it is just  base . If  abspath  is  true , the path will be  root * dir * base * ext , otherwise it will be  dir * base * ext . These options allow flexility in creating a table that can be easily saved and loaded to avoid having to manually filter files. Especially consider how  abspath  can allow keeping tables that will transfer easily between computers or between data sources with common structures. source"},{"id":378,"pagetitle":"API/Reference","title":"CCDReduction.flat_correct!","ref":"/previews/PR43/CCDReduction/stable/api/#CCDReduction.flat_correct!-Tuple{AbstractArray, AbstractArray}","content":" CCDReduction.flat_correct!  —  Method flat_correct!(frame, flat_frame; norm_value = mean(flat_frame), [hdu = 1]) In-place version of  flat_correct See Also flat_correct source"},{"id":379,"pagetitle":"API/Reference","title":"CCDReduction.flat_correct","ref":"/previews/PR43/CCDReduction/stable/api/#CCDReduction.flat_correct-Union{Tuple{S}, Tuple{T}, Tuple{AbstractArray{T, N} where N, AbstractArray{S, N} where N}} where {T, S}","content":" CCDReduction.flat_correct  —  Method flat_correct(frame, flat_frame; norm_value = mean(flat_frame), [hdu = 1]) Correct  frame  for non-uniformity using the calibrated  flat_frame . By default, the  flat_frame  is normalized by its mean, but this can be changed by providing a custom  norm_value . If either are strings, they will be loaded into  CCDData  first. The HDU loaded can be specified by  hdu  as either an integer or a tuple corresponding to each file. Note This function may introduce non-finite values if  flat_frame  contains values very close to  0  due to dividing by zero. The default behavior will return  Inf  if the frame value is non-zero, and  Nan  if the frame value is  0 . Examples julia> frame = ones(3, 3);\n\njulia> flat = fill(2.0, (3, 3));\n\njulia> flat_correct(frame, flat, norm_value = 1.0)\n3×3 Matrix{Float64}:\n 0.5  0.5  0.5\n 0.5  0.5  0.5\n 0.5  0.5  0.5\n\njulia> flat_correct(frame, flat)\n3×3 Matrix{Float64}:\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n See Also flat_correct! source"},{"id":380,"pagetitle":"API/Reference","title":"CCDReduction.getdata","ref":"/previews/PR43/CCDReduction/stable/api/#CCDReduction.getdata-Tuple{FITSIO.ImageHDU}","content":" CCDReduction.getdata  —  Method CCDReduction.getdata(::FITSIO.ImageHDU) Loads the given HDU as an  Array , permuting the dimensions appropriately. FITSIO.jl takes over memory read in by cfitsio, which reads in row-major form, whereas when Julia takes that memory, it is assumed as column major. Therefore all data read by  FITSIO.read  is transposed. This function allows the user to read data in a consistent way to  Array  by transposing after reading. source"},{"id":381,"pagetitle":"API/Reference","title":"CCDReduction.subtract_bias!","ref":"/previews/PR43/CCDReduction/stable/api/#CCDReduction.subtract_bias!-Tuple{AbstractArray, AbstractArray}","content":" CCDReduction.subtract_bias!  —  Method subtract_bias!(frame, bias_frame; [hdu = 1]) In-place version of  subtract_bias See Also subtract_bias source"},{"id":382,"pagetitle":"API/Reference","title":"CCDReduction.subtract_bias","ref":"/previews/PR43/CCDReduction/stable/api/#CCDReduction.subtract_bias-Tuple{AbstractArray, AbstractArray}","content":" CCDReduction.subtract_bias  —  Method subtract_bias(frame, bias_frame; [hdu = 1]) Subtract the  bias_frame  from  frame . If either are strings, they will be loaded into  CCDData  first. The HDU loaded can be specified by  hdu  as either an integer or a tuple corresponding to each file. Examples julia> frame = [1.0 2.2 3.3 4.5];\n\njulia> bias = [0.0 0.2 0.3 0.5];\n\njulia> subtract_bias(frame, bias)\n1×4 Matrix{Float64}:\n 1.0  2.0  3.0  4.0\n See Also subtract_bias! source"},{"id":383,"pagetitle":"API/Reference","title":"CCDReduction.subtract_dark!","ref":"/previews/PR43/CCDReduction/stable/api/#CCDReduction.subtract_dark!-Tuple{AbstractArray, AbstractArray}","content":" CCDReduction.subtract_dark!  —  Method subtract_dark!(frame, dark_frame; data_exposure = 1, dark_exposure = 1, [hdu = 1]) In-place version of  subtract_dark See Also subtract_dark source"},{"id":384,"pagetitle":"API/Reference","title":"CCDReduction.subtract_dark","ref":"/previews/PR43/CCDReduction/stable/api/#CCDReduction.subtract_dark-Union{Tuple{S}, Tuple{T}, Tuple{AbstractArray{T, N} where N, AbstractArray{S, N} where N}} where {T, S}","content":" CCDReduction.subtract_dark  —  Method subtract_dark(frame, dark_frame; data_exposure = 1, dark_exposure = 1, [hdu = 1]) Subtract the  dark_frame  from  frame . If either are strings, they will be loaded into  CCDData  first. The HDU loaded can be specified by  hdu  as either an integer or a tuple corresponding to each file. Examples julia> frame = ones(3, 3);\n\njulia> dark_frame = ones(3, 3);\n\njulia> subtract_dark(frame, dark_frame)\n3×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\njulia> subtract_dark(frame, dark_frame, data_exposure = 1, dark_exposure = 4)\n3×3 Matrix{Float64}:\n 0.75  0.75  0.75\n 0.75  0.75  0.75\n 0.75  0.75  0.75\n See Also subtract_dark! source"},{"id":385,"pagetitle":"API/Reference","title":"CCDReduction.subtract_overscan!","ref":"/previews/PR43/CCDReduction/stable/api/#CCDReduction.subtract_overscan!-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Any}} where T","content":" CCDReduction.subtract_overscan!  —  Method subtract_overscan!(frame, idxs; dims = axes_min_length(idxs)) In-place version of  subtract_overscan See Also subtract_overscan source"},{"id":386,"pagetitle":"API/Reference","title":"CCDReduction.subtract_overscan","ref":"/previews/PR43/CCDReduction/stable/api/#CCDReduction.subtract_overscan-Tuple{Any, Any}","content":" CCDReduction.subtract_overscan  —  Method subtract_overscan(frame, idxs; dims = axes_min_length(idxs), [hdu = 1]) Subtract the overscan frame from image. dims  is the dimension along which  overscan_frame  is combined. The default value of  dims  is the axis with smaller length in overscan region. If  idxs  is a string it will be parsed as FITS-style indices. If  frame  is a string, it will be loaded into  CCDData  first. The HDU loaded can be specified by  hdu  which by default is 1. Examples julia> frame = [4.0 2.0 3.0 1.0 1.0];\n\njulia> subtract_overscan(frame, (:, 4:5), dims = 2)\n1×5 Matrix{Float64}:\n 3.0  1.0  2.0  0.0  0.0\n\njulia> subtract_overscan(frame, \"[4:5, 1:1]\", dims = 2)\n1×5 Matrix{Float64}:\n 3.0  1.0  2.0  0.0  0.0\n See Also subtract_overscan! source"},{"id":387,"pagetitle":"API/Reference","title":"CCDReduction.trim","ref":"/previews/PR43/CCDReduction/stable/api/#CCDReduction.trim-Tuple{Any, Any}","content":" CCDReduction.trim  —  Method trim(frame, idxs; [hdu = 1]) Trims the  frame  to remove the region specified by idxs. This function trims the array in a manner such that final array should be rectangular. The indices follow standard Julia convention, so  (:, 45:60)  trims all columns from 45 to 60 and  (1:20, :)  trims all the rows from 1 to 20. The function also supports FITS-style indices. If  frame  is a string, it will be loaded into  CCDData  first. The HDU loaded can be specified by  hdu  which by default is 1. Examples julia> frame = ones(5, 5);\n\njulia> trim(frame, (:, 2:5))\n5×1 Matrix{Float64}:\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n\njulia> trim(frame, \"[2:5, 1:5]\")\n5×1 Matrix{Float64}:\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n See Also trimview source"},{"id":388,"pagetitle":"API/Reference","title":"CCDReduction.trimview","ref":"/previews/PR43/CCDReduction/stable/api/#CCDReduction.trimview-Tuple{AbstractArray, Any}","content":" CCDReduction.trimview  —  Method trimview(frame, idxs) Trims the  frame  to remove the region specified by idxs. This function is same as the  trim  function but returns a view of the frame. Note This function returns a view of the frame, so any modification to output array will result in modification of frame. See Also trim source"},{"id":389,"pagetitle":"API/Reference","title":"CCDReduction.writefits","ref":"/previews/PR43/CCDReduction/stable/api/#CCDReduction.writefits-Tuple{Any, Any}","content":" CCDReduction.writefits  —  Method CCDReduction.writefits(file_path, data; header = nothing)\nCCDReduction.writefits(file_path, ccd::CCDData) Writes  data / ccd  in FITS format at  file_path . FITSIO  takes over memory write in by  cfitsio , which writes in row-major form, whereas when Julia gives that memory, it is assumed as column major. Therefore all data written by  FITSIO.write  is transposed. This function allows the user to write the data in a consistent way to FITS file by transposing before writing. source"},{"id":394,"pagetitle":"Home","title":"LACosmic.jl","ref":"/previews/PR43/LACosmic/stable/#LACosmic.jl","content":" LACosmic.jl Laplacian cosmic-ray detection (L.A.Cosmic) in pure Julia."},{"id":395,"pagetitle":"Home","title":"Installation","ref":"/previews/PR43/LACosmic/stable/#Installation","content":" Installation To use the LACosmic library, first install it using  Pkg julia> ]add LACosmic"},{"id":396,"pagetitle":"Home","title":"Usage","ref":"/previews/PR43/LACosmic/stable/#Usage","content":" Usage To import the library using LACosmic there is one exported function:  lacosmic clean_image, mask = lacosmic(image)"},{"id":397,"pagetitle":"Home","title":"Contributing and Support","ref":"/previews/PR43/LACosmic/stable/#Contributing-and-Support","content":" Contributing and Support If you would like to contribute, feel free to open a  pull request . If you want to discuss something before contributing, head over to  discussions  and join or open a new topic. If you're having problems with something, please open an  issue ."},{"id":400,"pagetitle":"API/Reference","title":"API/Reference","ref":"/previews/PR43/LACosmic/stable/api/#API/Reference","content":" API/Reference LACosmic.lacosmic LACosmic.subsample"},{"id":401,"pagetitle":"API/Reference","title":"LACosmic.lacosmic","ref":"/previews/PR43/LACosmic/stable/api/#LACosmic.lacosmic-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","content":" LACosmic.lacosmic  —  Method lacosmic(data::AbstractMatrix; \n    noise=nothing,\n    gain=1,\n    background=0,\n    readnoise=0,\n    mask=falses(size(data)),\n    sigma_clip=4.5,\n    contrast=5,\n    neighbor_thresh=0.3,\n    maxiter=4,\n    saturation_level=2^16,\n    block_size=2) Laplacian cosmic ray detection (LACosmic). This algorithm implements the algorithm presented in  lacosmicx . The return values are the cleaned image and the bad pixel mask. The image cleaning is done via median interpolation. Parameters noise  is the pre-determined estimate of the data noise (square root of variance), if any gain  is the image gain in electrons per data number background  is pre-determined image background, if any readnoise  is the read noise of the image in electrons mask  is an input bad pixel mask, where  true  represents a bad pixel sigma_clip  is the Laplacian signal-to-noise ratio for flagging bad pixels contrast  is the minimum contrast required to flag a bad pixel in the ratio of the Laplacian image to the fine-structure image neighbor_thresh  is the fractional detection limit for cosmic rays surrounding other cosmic rays. Should be a number between 0 and 1. maxiter  is the maximum number of iterations used for detecting bad pixels saturation_level  is the saturation value in electrons block_size  is the subsampling factor for the Laplacian filter image. Examples julia> image = 100 .* randn(1001, 1001) .+ 1000;\n\njulia> clean_image, mask = lacosmic(image, gain=4); References van Dokkum, P.G. (2001)  - \"Cosmic-Ray Rejection by Laplacian Edge Detection\" source"},{"id":402,"pagetitle":"API/Reference","title":"LACosmic.subsample","ref":"/previews/PR43/LACosmic/stable/api/#LACosmic.subsample","content":" LACosmic.subsample  —  Function LACosmic.subsample(array, block_size=2) Subsample  array  by the given factor without copying or allocating. This effectively treats each pixel as  block_size  x  block_size  pixels. The value of each pixel is not normalized or averaged. This is a view into the parent array, and if the data was changed this view would change subsequently. Examples julia> arr = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> sub = LACosmic.subsample(arr)\n4×4 LACosmic.SubsampledArray{Int64, 2, Matrix{Int64}}:\n 1  1  2  2\n 1  1  2  2\n 3  3  4  4\n 3  3  4  4\n\njulia> all(sub[1:2, 1:2] .=== arr[1, 1])\ntrue\n\njulia> sub[3, 3] = 5;\n\njulia> sub\n4×4 LACosmic.SubsampledArray{Int64, 2, Matrix{Int64}}:\n 1  1  2  2\n 1  1  2  2\n 3  3  5  5\n 3  3  5  5 source"},{"id":405,"pagetitle":"Examples","title":"Examples","ref":"/previews/PR43/LACosmic/stable/examples/#Examples","content":" Examples"},{"id":406,"pagetitle":"Examples","title":"Setup","ref":"/previews/PR43/LACosmic/stable/examples/#Setup","content":" Setup You will need the following packages installed to replicate this tutorial julia> ]add Distributions LACosmic Plots PSFModels"},{"id":407,"pagetitle":"Examples","title":"Removing bad pixels with LACosmic.jl","ref":"/previews/PR43/LACosmic/stable/examples/#Removing-bad-pixels-with-LACosmic.jl","content":" Removing bad pixels with LACosmic.jl First, let's create some fake data with Gaussian sources using Distributions\nusing PSFModels: Gaussian\nusing Random\n\nfunction make_data(rng, N; N_sources=20, N_cosmics=20)\n    imdata = fill(200.0, (N, N))\n\n    # Add some fake sources\n    for _ in 1:N_sources\n        x = rand(rng, Uniform(1, N + 1))\n        y = rand(rng, Uniform(1, N + 1))\n        brightness = rand(rng, Uniform(1000, 30000)) / (2π * 3.5^2)\n\t\tmodel = Gaussian(;x, y, fwhm=3.5, amp=brightness)\n        imdata .+= model[axes(imdata)...]\n\tend\n\n    # Add the poisson noise\n    imdata .= rand.(rng, Poisson.(imdata))\n\n    # Add readnoise\n    imdata .+= rand(rng, Normal(0, 10), (N, N))\n\n    clean_image = copy(imdata)\n\n    # Add Nc fake cosmic rays\n    crmask = falses((N, N))\n\tfor i in 1:N_cosmics\n    \tcr_x = round(Int, rand(rng, Uniform(6, N - 5)))\n    \tcr_y = round(Int, rand(rng, Uniform(6, N - 5)))\n    \tcr_brightnesses = rand(rng, Uniform(1000, 30000))\n    \timdata[cr_y, cr_x] += cr_brightnesses\n    \tcrmask[cr_y, cr_x] = true\n\tend\n\n    # Make a mask where the detected cosmic rays should be\n    return (image=imdata, clean_image, mask=crmask)\nend\n\nrng = MersenneTwister(808)\ndata = make_data(rng, 201) (image = [188.58170768150052 214.09362006840362 … 204.15202016042792 174.58109503250085; 202.09914267128877 183.6972497338309 … 203.6666879254898 204.72346481491394; … ; 193.09513217045617 166.82428246193842 … 163.70511533689998 183.12325388575027; 228.6225661704681 189.5528435387213 … 202.46161451180063 199.53550046618867], clean_image = [188.58170768150052 214.09362006840362 … 204.15202016042792 174.58109503250085; 202.09914267128877 183.6972497338309 … 203.6666879254898 204.72346481491394; … ; 193.09513217045617 166.82428246193842 … 163.70511533689998 183.12325388575027; 228.6225661704681 189.5528435387213 … 202.46161451180063 199.53550046618867], mask = Bool[0 0 … 0 0; 0 0 … 0 0; … ; 0 0 … 0 0; 0 0 … 0 0]) let's inspect it using Plots\n\nfunction imshow(image; kwargs...)\n\taxy, axx = axes(image)\n\theatmap(axy, axx, image;\n        aspect_ratio=1,\n        ticks=false,\n        xlim=extrema(axx),\n        ylim=extrema(axy),\n        kwargs...)\nend\n\nplot(\n    imshow(log10.(data.clean_image), title=\"original image\"),\n    imshow(log10.(data.image), title=\"image w/cosmics\"),\n    size=(775, 350)\n) now we can clean it using  lacosmic using LACosmic\n\nclean_image, mask = lacosmic(data.image, sigma_clip=6, contrast=5, neighbor_thresh=1)\n\nplot(\n    imshow(log10.(data.clean_image), title=\"original image\"),\n    imshow(log10.(clean_image), title=\"cleaned image\"),\n    size=(775, 350)\n) plot(\n    imshow(data.mask, title=\"true cosmics\", cbar=false),\n    imshow(mask, title=\"detected cosmics\", cbar=false),\n    size=(700, 400)\n) data.mask == mask true"},{"id":412,"pagetitle":"Home","title":"Photometry.jl","ref":"/previews/PR43/Photometry/stable/#Photometry.jl","content":" Photometry.jl"},{"id":413,"pagetitle":"Home","title":"Installation","ref":"/previews/PR43/Photometry/stable/#Installation","content":" Installation To install from the REPL, enter Pkg-mode ( ] ) pkg> add Photometry"},{"id":414,"pagetitle":"Home","title":"Getting Started","ref":"/previews/PR43/Photometry/stable/#Getting-Started","content":" Getting Started Here is a basic example to do some aperture photometry using  CircularAperture . The  photometry  function performs the photometry using a given method. using Photometry\ndata = ones(100, 100)\nerr = ones(100, 100)\n\nap1 = CircularAperture(50, 50, 3)\n# partial overlap\nap2 = CircularAperture(0.5, 0.5, 5)\n\nresults = photometry([ap1, ap2], data, err)\n@assert results.aperture_sum[1] ≈ 9π\n@assert results.aperture_sum[2] ≈ 25π / 4\n\nresults Table with 4 columns and 2 rows:\n     xcenter  ycenter  aperture_sum  aperture_sum_err\n   ┌─────────────────────────────────────────────────\n 1 │ 50.0     50.0     28.2743       5.31736\n 2 │ 0.5      0.5      19.635        4.43113"},{"id":415,"pagetitle":"Home","title":"Contributing","ref":"/previews/PR43/Photometry/stable/#Contributing","content":" Contributing If you're interested in contributing, go ahead and check out the  issues  or make a  pull request . If you add a new feature, please write appropriate unit tests for it and bump the package's minor version."},{"id":416,"pagetitle":"Home","title":"License","ref":"/previews/PR43/Photometry/stable/#License","content":" License The work derived from  astropy/photutils  is BSD 3-clause and the work derived from  kbarbary/sep  is BSD 3-clause. All other work is considered MIT expat. Therefore this work as a whole is BSD 3-clause.  LICENSE  contains all licenses and any files using derived work are noted at the top of the file."},{"id":419,"pagetitle":"Getting Started","title":"Aperture Photometry","ref":"/previews/PR43/Photometry/stable/apertures/#Aperture-Photometry","content":" Aperture Photometry"},{"id":420,"pagetitle":"Getting Started","title":"Introduction","ref":"/previews/PR43/Photometry/stable/apertures/#Introduction","content":" Introduction Aperture photometry uses  Apertures  to cut out and sum values in an image. A very basic mask might be a square of pixels at a certain position. We can model this as a matrix of ones and zeros like ⎡0 0 0 0 0⎤\n⎢0 1 1 1 0⎥\n⎢0 1 1 1 0⎥\n⎢0 1 1 1 0⎥\n⎣0 0 0 0 0⎦ If we have some data like ⎡7 9 6 0 8⎤\n⎢8 5 8 7 9⎥\n⎢5 6 2 2 7⎥\n⎢9 7 3 4 1⎥\n⎣7 8 0 9 8⎦ then the result of our aperture photometry looks like ⎡0 0 0 0 0⎤    ⎡7 9 6 0 8⎤     ⎡0 0 0 0 0⎤\n⎢0 1 1 1 0⎥    ⎢8 5 8 7 9⎥     ⎢0 5 8 7 0⎥\n⎢0 1 1 1 0⎥ .* ⎢5 6 2 2 7⎥  =  ⎢0 6 2 2 0⎥\n⎢0 1 1 1 0⎥    ⎢9 7 3 4 1⎥     ⎢0 7 3 4 0⎥\n⎣0 0 0 0 0⎦    ⎣7 8 0 9 8⎦     ⎣0 0 0 0 0⎦\n\nsum(result) = 44 This module uses the above principal with common aperture shapes in a fast and precise manner, including exact overlaps between apertures and pixels. The majority of the lifting is done with the  photometry  function with common shapes being described in  Apertures . It is possible to create a custom aperture by sub-typing the  Aperture.AbstractAperture  class, although it may be easier to perform PSF photometry instead."},{"id":421,"pagetitle":"Getting Started","title":"Pixel Convention","ref":"/previews/PR43/Photometry/stable/apertures/#Pixel-Convention","content":" Pixel Convention Photometry.jl  follows the same convention as FITS, WCS, IRAF, DS9, and SourceExtractor with  (1, 1)  being the  center  on the bottom-left pixel. This means the exact bottom-left corner is at  (0.5, 0.5) . Pixels increase up and to the right until  axis_length + 0.5 ."},{"id":422,"pagetitle":"Getting Started","title":"API/Reference","ref":"/previews/PR43/Photometry/stable/apertures/#API/Reference","content":" API/Reference"},{"id":423,"pagetitle":"Getting Started","title":"Photometry.Aperture.photometry","ref":"/previews/PR43/Photometry/stable/apertures/#Photometry.Aperture.photometry","content":" Photometry.Aperture.photometry  —  Function photometry(::AbstractAperture, data::AbstractMatrix, [error])\nphotometry(::AbstractVector{<:AbstractAperture}, data::AbstractMatrix, [error]) Perform aperture photometry on  data  given aperture(s). If  error  (the pixel-wise standard deviation) is provided, will calculate sum error. If a list of apertures is provided the output will be a  TypedTables.Table , otherwise a  NamedTuple . Tip This code is automatically multi-threaded. To take advantage of this please make sure  JULIA_NUM_THREADS  is set before starting your runtime. source"},{"id":424,"pagetitle":"Getting Started","title":"Performance","ref":"/previews/PR43/Photometry/stable/apertures/#Performance","content":" Performance Below are some benchmarks comparing the aperture photometry capabilities of  Photometry.jl  with the  photutils  asropy package. The benchmark code can be found in the  bench  folder . Note that for the multi-threaded examples my machine has 4 physical cores with 8 threads. julia> versioninfo()\nJulia Version 1.5.0\nCommit 96786e22cc (2020-08-01 23:44 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin18.7.0)\n  CPU: Intel(R) Core(TM) i5-8259U CPU @ 2.30GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-9.0.1 (ORCJIT, skylake)"},{"id":425,"pagetitle":"Getting Started","title":"Number of Apertures","ref":"/previews/PR43/Photometry/stable/apertures/#Number-of-Apertures","content":" Number of Apertures This benchmark shows how performance scales as we increase the number of apertures. The apertures are distributed randomly across the image with a fixed radius of 10. The image size is (512, 512). We see an improvement of ~10-100x (depending on multithreading) over photutils."},{"id":426,"pagetitle":"Getting Started","title":"Size of Apertures","ref":"/previews/PR43/Photometry/stable/apertures/#Size-of-Apertures","content":" Size of Apertures This benchmark analyzes how the aperture size affects performance. Theoretically it should increase with  O(n^2)  complexity. For aperture sizes increasing from 1 to 200,  located in the center of a an image of size (512, 512)."},{"id":429,"pagetitle":"Apertures","title":"Apertures","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Apertures","content":" Apertures All apertures will rely on a position and the shape parameters. aperture = Aperture(x0, y0, shape_params...) The position can be pixels or sky coordinates. The sky coordinate positions utilize  SkyCoords.jl  and  WCS.jl  for conversion. Warning Sky coordinates are not supported yet. Note See  Pixel Convention  - The origin is the bottom-left with  (1, 1)  being the center of the pixel."},{"id":430,"pagetitle":"Apertures","title":"API/Reference","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#API/Reference","content":" API/Reference"},{"id":431,"pagetitle":"Apertures","title":"Photometry.Aperture.AbstractAperture","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.AbstractAperture","content":" Photometry.Aperture.AbstractAperture  —  Type AbstractAperture{T} <: AbstractMatrix{T} The abstract super-type for Apertures. Apertures can be thought of as a cutout or stamp of a geometric shape with shading applied. For example, a circular aperture with a diameter of 3 pixels will require a 5x5 pixel grid (when perfectly on-grid) to represent. julia> ap = CircularAperture(3, 3, 2.5)\n5×5 CircularAperture{Float64} with indices 1:5×1:5:\n 0.136857  0.769325  0.983232  0.769325  0.136857\n 0.769325  1.0       1.0       1.0       0.769325\n 0.983232  1.0       1.0       1.0       0.983232\n 0.769325  1.0       1.0       1.0       0.769325\n 0.136857  0.769325  0.983232  0.769325  0.136857 This is a useful way of thinking about apertures: if we have some data, we can weight the data with the aperture. julia> data = fill(2, 5, 5);\n\njulia> idxs = map(intersect, axes(ap), axes(data)) |> CartesianIndices;\n\njulia> weighted_cutout = data[idxs] .* ap[idxs]\n5×5 Matrix{Float64}:\n 0.273713  1.53865  1.96646  1.53865  0.273713\n 1.53865   2.0      2.0      2.0      1.53865\n 1.96646   2.0      2.0      2.0      1.96646\n 1.53865   2.0      2.0      2.0      1.53865\n 0.273713  1.53865  1.96646  1.53865  0.273713 Performing aperture photometry is merely summing the weighted cutout shown above. julia> flux = sum(weighted_cutout)\n39.269908169872416\n\njulia> flux ≈ (π * 2.5^2) * 2 # area of circle times intensity of 2\ntrue What's interesting about the implementation of apertures, though, is they are lazy. This means there is no stored matrix of aperture values; rather, they are calculated on the fly as needed. julia> axes(ap)\n(1:5, 1:5)\n\njulia> ap[-10, -10] # out-of-bounds, but calculated on the fly\n0.0\n\njulia> ap .* ones(5, 7) # broadcasts to eachindex(data), regardless of ap bound\n5×7 Matrix{Float64}:\n 0.136857  0.769325  0.983232  0.769325  0.136857  0.0  0.0\n 0.769325  1.0       1.0       1.0       0.769325  0.0  0.0\n 0.983232  1.0       1.0       1.0       0.983232  0.0  0.0\n 0.769325  1.0       1.0       1.0       0.769325  0.0  0.0\n 0.136857  0.769325  0.983232  0.769325  0.136857  0.0  0.0 This allows extremely efficient computation of aperture photometry from small to medium sized apertures. julia> using BenchmarkTools\n\njulia> @btime sum(idx -> $ap[idx] * $data[idx], $idxs)\n  1.097 μs (0 allocations: 0 bytes)\n39.26990816987243 This is essentially the full implementation of  photometry , save for the packing of additional information into a tabular form. source"},{"id":432,"pagetitle":"Apertures","title":"Photometry.Aperture.Subpixel","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.Subpixel","content":" Photometry.Aperture.Subpixel  —  Type Subpixel(ap, N=1) <: AbstractAperture Use a subpixel quadrature approximation for pixel shading instead of exact geometric methods. For any pixel laying on the border of  ap , this alters the shading algorithm by breaking the border pixel up into  (N, N)  subpixels. The shading value is the fraction of these subpixels within the geometric border of  ap . Using a subpixel shading method is sometimes faster than exact methods at the cost of accuracy. For  CircularAperture  the subpixel method is only faster than the exact method for  N  ~ 7. for  EllipticalAperture  the cutoff is  N  ~ 12, and for  RectangularAperture  the cutoff is  N  ~ 20. Examples julia> ap = CircularAperture(3, 3, 2.5)\n5×5 CircularAperture{Float64} with indices 1:5×1:5:\n 0.136857  0.769325  0.983232  0.769325  0.136857\n 0.769325  1.0       1.0       1.0       0.769325\n 0.983232  1.0       1.0       1.0       0.983232\n 0.769325  1.0       1.0       1.0       0.769325\n 0.136857  0.769325  0.983232  0.769325  0.136857\n\njulia> sub_ap = Subpixel(ap, 5)\n5×5 Subpixel{Float64, CircularAperture{Float64}} with indices 1:5×1:5:\n 0.12  0.76  1.0  0.76  0.12\n 0.76  1.0   1.0  1.0   0.76\n 1.0   1.0   1.0  1.0   1.0\n 0.76  1.0   1.0  1.0   0.76\n 0.12  0.76  1.0  0.76  0.12 Note photutils  offers a  center  shading method which is equivalent to using the  Subpixel  method with 1 subpixel. To avoid unneccessary namespace cluttering, we simply instruct users to use  Subpixel(ap)  instead. source"},{"id":433,"pagetitle":"Apertures","title":"Photometry.Aperture.area_arc","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.area_arc","content":" Photometry.Aperture.area_arc  —  Function Area of a circular segment above a chord between two points with circle radius  r Reference source"},{"id":434,"pagetitle":"Apertures","title":"Photometry.Aperture.circular_overlap_core","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.circular_overlap_core","content":" Photometry.Aperture.circular_overlap_core  —  Function Core of circular overlap routine source"},{"id":435,"pagetitle":"Apertures","title":"Photometry.Aperture.circular_overlap_single_exact","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.circular_overlap_single_exact","content":" Photometry.Aperture.circular_overlap_single_exact  —  Function Area of overlap between a rectangle and a circle source"},{"id":436,"pagetitle":"Apertures","title":"Photometry.Aperture.inside_ellipse","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.inside_ellipse","content":" Photometry.Aperture.inside_ellipse  —  Function inside_ellipse(x, y, h, k, cxx, cyy, cxy) x: x coordinate of the test point y: y coordinate of the test point h: x coordinate of the center of ellipse k: y coordinate of the center of ellipse cxx, cyy, cxy: coefficients of equation of ellipse Utility function to find whether a point is inside ellipse or not. If point inside ellipse: Returns true else returns false General equation of ellipse:     cxx * (x - h)^2 + cxy * (x - h) * (y - k) + cyy * (y - k)^2 = 1 source"},{"id":437,"pagetitle":"Apertures","title":"Base.size","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Base.size-Tuple{Photometry.Aperture.AbstractAperture}","content":" Base.size  —  Method size(::AbstractAperture) Return ( ny ,  nx ) of the aperture. source"},{"id":438,"pagetitle":"Apertures","title":"Photometry.Aperture.area_triangle","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.area_triangle","content":" Photometry.Aperture.area_triangle  —  Function Area of a triangle defined by three vertices source"},{"id":439,"pagetitle":"Apertures","title":"Photometry.Aperture.inside_rectangle","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.inside_rectangle","content":" Photometry.Aperture.inside_rectangle  —  Function intersection with rectangular using implicit Lamé curve source"},{"id":440,"pagetitle":"Apertures","title":"Photometry.Aperture.bounds","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.bounds","content":" Photometry.Aperture.bounds  —  Function bounds(::AbstractAperture) Return the ( xlow ,  xhigh ,  ylow ,  yhigh ) bounds for a given Aperture. source"},{"id":441,"pagetitle":"Apertures","title":"Circular Apertures","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Circular-Apertures","content":" Circular Apertures These apertures are parameterized by radius."},{"id":442,"pagetitle":"Apertures","title":"Photometry.Aperture.CircularAperture","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.CircularAperture","content":" Photometry.Aperture.CircularAperture  —  Type CircularAperture(x, y, r)\nCircularAperture(position, r) A circular aperture. A circular aperture with radius  r .  r  must be greater than or equal to 0. Examples julia> ap = CircularAperture(0, 0, 10)\n21×21 CircularAperture{Int64} with indices -10:10×-10:10:\n 0          0         0           …  0           0         0\n 0          0         0              0           0         0\n 0          0         0              0           0         0\n 0          0         0.00571026     0.00571026  0         0\n 0          0         0.491844       0.491844    0         0\n 0          0.170878  0.982952    …  0.982952    0.170878  0\n 0          0.659735  1              1           0.659735  0\n 0.0590655  0.975524  1              1           0.975524  0.0590655\n 0.293527   1         1              1           1         0.293527\n 0.445643   1         1              1           1         0.445643\n ⋮                                ⋱                        ⋮\n 0.293527   1         1              1           1         0.293527\n 0.0590655  0.975524  1              1           0.975524  0.0590655\n 0          0.659735  1              1           0.659735  0\n 0          0.170878  0.982952    …  0.982952    0.170878  0\n 0          0         0.491844       0.491844    0         0\n 0          0         0.00571026     0.00571026  0         0\n 0          0         0              0           0         0\n 0          0         0              0           0         0\n 0          0         0           …  0           0         0 source"},{"id":443,"pagetitle":"Apertures","title":"Photometry.Aperture.CircularAnnulus","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.CircularAnnulus","content":" Photometry.Aperture.CircularAnnulus  —  Type CircularAnnulus(x, y, r_in, r_out)\nCircularAnnulus(position, r_in, r_out) A circular annulus with inner radius  r_in  and outer radius  r_out . 0 ≤  r_in  ≤  r_out . Examples julia> ap = CircularAnnulus(0, 0, 5, 10)\n21×21 CircularAnnulus{Int64} with indices -10:10×-10:10:\n 0          0         0           …  0           0         0\n 0          0         0              0           0         0\n 0          0         0              0           0         0\n 0          0         0.00571026     0.00571026  0         0\n 0          0         0.491844       0.491844    0         0\n 0          0.170878  0.982952    …  0.982952    0.170878  0\n 0          0.659735  1              1           0.659735  0\n 0.0590655  0.975524  1              1           0.975524  0.0590655\n 0.293527   1         1              1           1         0.293527\n 0.445643   1         1              1           1         0.445643\n ⋮                                ⋱                        ⋮\n 0.293527   1         1              1           1         0.293527\n 0.0590655  0.975524  1              1           0.975524  0.0590655\n 0          0.659735  1              1           0.659735  0\n 0          0.170878  0.982952    …  0.982952    0.170878  0\n 0          0         0.491844       0.491844    0         0\n 0          0         0.00571026     0.00571026  0         0\n 0          0         0              0           0         0\n 0          0         0              0           0         0\n 0          0         0           …  0           0         0 source"},{"id":444,"pagetitle":"Apertures","title":"Elliptical Apertures","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Elliptical-Apertures","content":" Elliptical Apertures These apertures are parameterized by the semi-major axis  a , semi-minor axis  b  and position angle in degrees counter-clockwise from the positive x-axis  θ"},{"id":445,"pagetitle":"Apertures","title":"Photometry.Aperture.EllipticalAperture","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.EllipticalAperture","content":" Photometry.Aperture.EllipticalAperture  —  Type EllipticalAperture(x, y, a, b, θ=0)\nEllipticalAperture(position, a, b, θ=0) An elliptical aperture with semi-major axis  a , semi-minor axis  b , and position angle  θ .  a  and  b  must be ≥ 0,  θ  is measured in degrees counter-clockwise the standard x-axis. Examples julia> ap = EllipticalAperture(0, 0, 4, 2, 35)\n7×5 EllipticalAperture{Int64} with indices -3:3×-2:2:\n 0.873382  0.844185  0.324917  0         0\n 1         1         0.997821  0.435284  0\n 1         1         1         0.990119  0.23968\n 0.796137  1         1         1         0.796137\n 0.23968   0.990119  1         1         1\n 0         0.435284  0.997821  1         1\n 0         0         0.324917  0.844185  0.873382 source"},{"id":446,"pagetitle":"Apertures","title":"Photometry.Aperture.EllipticalAnnulus","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.EllipticalAnnulus","content":" Photometry.Aperture.EllipticalAnnulus  —  Type EllipticalAnnulus(x, y, a_in, a_out, b_out, θ=0)\nEllipticalAnnulus(position, a_in, a_out, b_out, θ=0) An elliptical annulus with inner semi-major axis  a_in , outer semi-major axis  a_out , outer semi-minor axis  b_out , and position angle  θ .  a_out  ≥  a_in  ≥ 0 and  b_out  must be ≥ 0,  θ  is measured in degrees counter-clockwise the standard x-axis. b_in  will automatically be calculated from  (a_in / a_out) * b_out . Note this may cause a type instability. Examples julia> ap = EllipticalAnnulus(0, 0, 4, 10, 5, 45)\n15×15 EllipticalAnnulus{Float64} with indices -7:7×-7:7:\n 0.594853   1.0       1.0       1.0         …  0.0       0.0       0.0\n 1.0        1.0       1.0       1.0            0.0       0.0       0.0\n 1.0        1.0       1.0       1.0            0.0       0.0       0.0\n 1.0        1.0       1.0       1.0            0.0       0.0       0.0\n 1.0        1.0       1.0       1.0            0.0       0.0       0.0\n 0.814163   1.0       1.0       1.0         …  0.414163  0.0       0.0\n 0.369432   1.0       1.0       1.0            0.975704  0.193728  0.0\n 0.0112571  0.809079  1.0       1.0            1.0       0.809079  0.0112571\n 0.0        0.193728  0.975704  1.0            1.0       1.0       0.369432\n 0.0        0.0       0.414163  1.0            1.0       1.0       0.814163\n 0.0        0.0       0.0       0.546165    …  1.0       1.0       1.0\n 0.0        0.0       0.0       0.00252321     1.0       1.0       1.0\n 0.0        0.0       0.0       0.0            1.0       1.0       1.0\n 0.0        0.0       0.0       0.0            1.0       1.0       1.0\n 0.0        0.0       0.0       0.0            1.0       1.0       0.594853 source"},{"id":447,"pagetitle":"Apertures","title":"Rectangular Apertures","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Rectangular-Apertures","content":" Rectangular Apertures These apertures are parameterized by width  w , height  h , and position angle in degrees counter-clockwise from the positive x-axis  θ ."},{"id":448,"pagetitle":"Apertures","title":"Photometry.Aperture.RectangularAperture","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.RectangularAperture","content":" Photometry.Aperture.RectangularAperture  —  Type RectangularAperture(x, y, w, h, θ=0)\nRectangularAperture(position, w, h, θ=0) A rectangular aperture. A rectangular aperture with width  w , height  h , and position angle  θ  in degrees. Examples julia> ap = RectangularAperture(0, 0, 10, 4, 0)\n11×5 RectangularAperture{Int64} with indices -5:5×-2:2:\n 0.25  0.5  0.5  0.5  0.25\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.25  0.5  0.5  0.5  0.25 source"},{"id":449,"pagetitle":"Apertures","title":"Photometry.Aperture.RectangularAnnulus","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.RectangularAnnulus","content":" Photometry.Aperture.RectangularAnnulus  —  Type RectangularAnnulus(x, y, w_in, w_out, h_out, θ=0)\nRectangularAnnulus(position, w_in, w_out, h_out, θ=0) A rectangular annulus with inner width  w_in , outer width  w_out , outer height  h_out , and position angle  θ  in degrees.  h_in  is automatically calculated from  w_in / w_out * h_out . Note that  w_out ≥ w_in > 0 . Examples julia> ap = RectangularAnnulus(0, 0, 5, 10, 8, 45)\n13×13 RectangularAnnulus{Float64} with indices -6:6×-6:6:\n 0.0       0.0       0.0         …  0.0         0.0       0.0\n 0.0       0.0       0.0            0.0         0.0       0.0\n 0.0       0.0       0.00252532     0.0         0.0       0.0\n 0.0       0.0       0.568542       0.0         0.0       0.0\n 0.0       0.568542  1.0            0.215729    0.0       0.0\n 0.528175  1.0       1.0         …  1.0         0.215729  0.0\n 0.215729  1.0       1.0            1.0         1.0       0.215729\n 0.0       0.215729  1.0            1.0         1.0       0.528175\n 0.0       0.0       0.215729       1.0         0.568542  0.0\n 0.0       0.0       0.0            0.568542    0.0       0.0\n 0.0       0.0       0.0         …  0.00252532  0.0       0.0\n 0.0       0.0       0.0            0.0         0.0       0.0\n 0.0       0.0       0.0            0.0         0.0       0.0 source"},{"id":452,"pagetitle":"Examples","title":"Examples","ref":"/previews/PR43/Photometry/stable/apertures/examples/#Examples","content":" Examples"},{"id":453,"pagetitle":"Examples","title":"Plotting","ref":"/previews/PR43/Photometry/stable/apertures/examples/#Plotting","content":" Plotting We have recipes for all our aperture types, so you can easily create overlays on your images. using Photometry\nusing Plots\n\nplot(CircularAperture(2, 3, 4), c=1, xlims=(-1, 12), ylims=(0, 9))\nplot!(CircularAnnulus(5, 5, 2.1, 3), c=2)\nplot!(EllipticalAperture(0, 0, 10, 1, 32), c=3)\nplot!(EllipticalAnnulus(5, 5, 4, 5, 2, -32), c=4)\nplot!(RectangularAperture(0, 0, 4, 4, 4), c=5)\nplot!(RectangularAnnulus(5, 1, 3, 4, 4, 4), c=6)"},{"id":454,"pagetitle":"Examples","title":"Simple Stars","ref":"/previews/PR43/Photometry/stable/apertures/examples/#Simple-Stars","content":" Simple Stars Here is an example where we will find aperture fluxes for stars from M67. The dataset is provided as part of the  astropy/photutils-datasets  repository. Let's start by downloading and showing our image using Photometry\nusing Plots\nusing FITSIO\n\n# Load data in\nurl = \"https://rawcdn.githack.com/astropy/photutils-datasets/8c97b4fa3a6c9e6ea072faeed2d49a20585658ba/data/M6707HH.fits\"\nhdu = FITS(download(url))\nchunk = read(hdu[1], 81:155, 71:150)\n\n# Plot\nfunction imshow(image; kwargs...)\n    xs, ys = axes(image)\n    data = transpose(image)\n    heatmap(xs, ys, data; aspect_ratio=1, xlim=extrema(xs), ylim=extrema(ys), kwargs...)\nend\n\nimshow(chunk) Now let's add some apertures! positions = [\n    [47.5 , 67.5],\n    [29.5 , 62.5],\n    [23.5 , 48.5],\n    [17.5 , 29.5],\n    [13.25, 10.5],\n    [65.5 , 14.0]\n]\n\nradii = [3, 3, 2.7, 2, 2.7, 3]\n\naps = CircularAperture.(positions, radii) 6-element Vector{CircularAperture{Float64}}:\n CircularAperture(47.5, 67.5, r=3.0)\n CircularAperture(29.5, 62.5, r=3.0)\n CircularAperture(23.5, 48.5, r=2.7)\n CircularAperture(17.5, 29.5, r=2.0)\n CircularAperture(13.25, 10.5, r=2.7)\n CircularAperture(65.5, 14.0, r=3.0) now let's plot them up imshow(chunk)\nplot!(aps, c=:white) and finally let's get our output table for the photometry table = photometry(aps, chunk) Table with 3 columns and 6 rows:\n     xcenter  ycenter  aperture_sum\n   ┌───────────────────────────────\n 1 │ 47.5     67.5     2.48267e5\n 2 │ 29.5     62.5     2.25989e5\n 3 │ 23.5     48.5     1.49979e5\n 4 │ 17.5     29.5     72189.4\n 5 │ 13.25    10.5     1.48118e5\n 6 │ 65.5     14.0     2.02803e5"},{"id":455,"pagetitle":"Examples","title":"Stars with Spatial Background Subtraction","ref":"/previews/PR43/Photometry/stable/apertures/examples/#Stars-with-Spatial-Background-Subtraction","content":" Stars with Spatial Background Subtraction This example will be the same as  Simple Stars  but will add background estimation using the tools in  Background Estimation clipped = sigma_clip(chunk, 1, fill=NaN)\n# Estimate 2D spatial background using boxes of size (5, 5)\nbkg, bkg_rms = estimate_background(clipped, 5)\n\nplot(\n    imshow(chunk, title=\"Original\"),\n    imshow(clipped, title=\"Sigma-Clipped\"),\n    imshow(bkg, title=\"Background\"),\n    imshow(bkg_rms, title=\"Background RMS\");\n    layout=(2, 2), size=(600, 600), ticks=false\n) Now, using the same apertures, let's find the output using the background-subtracted image plot(\n    imshow(chunk, title=\"Original\"),\n    imshow(chunk .- bkg, title=\"Subtracted\");\n    layout=2, size=(600, 260), ticks=false, colorbar=false\n)\nplot!(aps, c=:white, subplot=1)\nplot!(aps, c=:white, subplot=2) table = photometry(aps, chunk .- bkg, bkg_rms) Table with 4 columns and 6 rows:\n     xcenter  ycenter  aperture_sum  aperture_sum_err\n   ┌─────────────────────────────────────────────────\n 1 │ 47.5     67.5     2.13534e5     431.48\n 2 │ 29.5     62.5     114217.0      887.37\n 3 │ 23.5     48.5     59230.7       1061.28\n 4 │ 17.5     29.5     23159.6       697.556\n 5 │ 13.25    10.5     54638.1       1048.67\n 6 │ 65.5     14.0     91179.1       1168.71"},{"id":458,"pagetitle":"Getting Started","title":"Background Estimation","ref":"/previews/PR43/Photometry/stable/background/#Background-Estimation","content":" Background Estimation The module provides tools and algorithms for estimating the background of astronomical data."},{"id":459,"pagetitle":"Getting Started","title":"Usage","ref":"/previews/PR43/Photometry/stable/background/#Usage","content":" Usage Estimating backgrounds is an important step in performing photometry. Ideally, we could perfectly describe the background with a scalar value or with some distribution. Unfortunately, it's impossible for us to precisely separate the background and foreground signals. Here, we use mixture of robust statistical estimators and meshing to let us get the spatially varying background from an astronomical photo. Let's show an example using Photometry\nusing FITSIO\nusing Plots\n\n# Download our image, courtesy of astropy\nurl = \"https://rawcdn.githack.com/astropy/photutils-datasets/8c97b4fa3a6c9e6ea072faeed2d49a20585658ba/data/M6707HH.fits\"\nhdu = FITS(download(url))\nimage = read(hdu[1])\n\n# Plot\nfunction imshow(image; kwargs...)\n    xs, ys = axes(image)\n    data = transpose(image)\n    heatmap(xs, ys, data;\n            aspect_ratio=1,\n            xlim=extrema(xs), ylim=extrema(ys),\n            kwargs...)\nend\n\nimshow(image) Now let's try and estimate the background using  estimate_background . First, we'll sigma-clip to try and remove the signals from the stars. Then, the background is broken down into boxes, in this case of size  (50, 50) . Within each box, the given statistical estimators get the background value and RMS. By default, we use  SourceExtractorBackground  and  StdRMS . This creates a low-resolution image, which we then need to resize. We can accomplish this using an interpolator, by default a cubic-spline interpolator via  ZoomInterpolator . The end result is a smooth estimate of the spatially varying background and background RMS. # sigma-clip\nclipped = sigma_clip(image, 1, fill=NaN)\n\n# get background and background rms with box-size (50, 50)\nbkg, bkg_rms = estimate_background(clipped, 50)\n\n# plot\nplot(\n    imshow(image, title=\"Original\"),\n    imshow(clipped, title=\"Sigma-Clipped\"),\n    imshow(bkg, title=\"Background\"),\n    imshow(bkg_rms, title=\"Background RMS\"),\n    layout=(2, 2), ticks=false,\n) We could apply a median filter, too, by specifying  filter_size # get background and background rms with box-size (50, 50) and filter_size (5, 5)\nbkg_f, bkg_rms_f = estimate_background(clipped, 50, filter_size=5)\n\n# plot\nplot(\n    imshow(bkg, title=\"Unfiltered\", ylabel=\"Background\"),\n    imshow(bkg_f, title=\"Filtered\"),\n    imshow(bkg_rms, ylabel=\"RMS\"),\n    imshow(bkg_rms_f);\n    layout=(2, 2), ticks=false,\n) Now we can see our image after subtracting the filtered background and ready for  Aperture Photometry ! subt = image .- bkg_f[axes(image)...]\nplot(\n    imshow(image, title=\"Original\", colorbar=false),\n    imshow(subt, title=\"Subtracted\");\n    layout=(1, 2), size=(600, 260),\n    xlims=(400, 800), ylims=(400, 800),\n    clims=(minimum(subt), maximum(image)),\n    ticks=false, aspect_ratio=1,\n)"},{"id":460,"pagetitle":"Getting Started","title":"IDW Interpolator","ref":"/previews/PR43/Photometry/stable/background/#IDW-Interpolator","content":" IDW Interpolator Here is a quick example using the  IDWInterpolator b1, r1 = estimate_background(clipped, 50, filter_size=5)\nb2, r2 = estimate_background(clipped, 50, itp=IDWInterpolator(50), filter_size=5)\n\nplot(\n    imshow(b1, title=\"ZoomInterpolator\", ylabel=\"Background\"),\n    imshow(b2, title=\"IDWInterpolator\"),\n    imshow(r1, ylabel=\"RMS\"),\n    imshow(r2);\n    layout=(2, 2), ticks=false,\n)"},{"id":461,"pagetitle":"Getting Started","title":"API/Reference","ref":"/previews/PR43/Photometry/stable/background/#API/Reference","content":" API/Reference"},{"id":462,"pagetitle":"Getting Started","title":"Photometry.Background.estimate_background","ref":"/previews/PR43/Photometry/stable/background/#Photometry.Background.estimate_background","content":" Photometry.Background.estimate_background  —  Function estimate_background(data;\n    location=SourceExtractorBackground(),\n    rms=StdRMS(),\n    dims=:) Perform scalar background estimation using the given estimators. The value returned will be two values corresponding to the estimated background and the estimated background RMS. The dimensionality will depend on the  dims  keyword. location  and  rms  can be anything that is callable, for example  median , or one of the estimators we provide in  Background Estimators . Examples julia> data = ones(3, 5);\n\njulia> bkg, bkg_rms = estimate_background(data)\n(1.0, 0.0)\n\njulia> using Statistics: median\n\njulia> bkg, bkg_rms = estimate_background(data; location=median, rms=MADStdRMS())\n(1.0, 0.0) See Also Location Estimators ,  RMS Estimators source estimate_background(data, box_size;\n    location=SourceExtractorBackground(),\n    rms=StdRMS(),\n    itp=ZoomInterpolator(box_size),\n    edge_method=:pad,\n    [filter_size]) Perform 2D background estimation using the given estimators mapped over windows of the data. This function will estimate backgrounds in boxes of size  box_size . When  size(data)  is not an integer multiple of the box size, there are two edge methods:  :pad  and  :crop . The default is to pad (and is recommend to avoid losing image data). If  box_size  is an integer, the implicit shape will be square (eg.  box_size=4  is equivalent to  box_size=(4,4) ). For evaluating the meshes, each box will be passed into  location  to estimate the background and then into  rms  to estimate the background root-mean-square value. These can be anything that is callable, like  median  or one of our  Background Estimators . Once the meshes are created they will be median filtered if  filter_size  is given.  filter_size  can be either an integer or a tuple, with the integer being converted to a tuple the same way  box_size  is. Filtering is done via  ImageFiltering.MapWindow.mapwindow .  filter_size  must be odd. After filtering (if applicable), the meshes are passed to the  itp  to recreate a low-order estimate of the background at the same resolution as the input. Note If your  box_size  is not an integer multiple of the input size, the output background and rms arrays will not have the same size. See Also Location Estimators ,  RMS Estimators ,  Interpolators source"},{"id":463,"pagetitle":"Getting Started","title":"Photometry.Background.sigma_clip","ref":"/previews/PR43/Photometry/stable/background/#Photometry.Background.sigma_clip","content":" Photometry.Background.sigma_clip  —  Function sigma_clip(x, sigma; fill=:clamp, center=median(x), std=std(x, corrected=false))\nsigma_clip(x, sigma_low, sigma_high; fill=:clamp, center=median(x), std=std(x, corrected=false)) This function returns sigma-clipped values of the input  x . Specify the upper and lower bounds with  sigma_low  and  sigma_high , otherwise assume they are equal.  center  and  std  are optional keyword arguments which are functions for finding central element and standard deviation. If  fill === :clamp , this will clamp values in  x  lower than  center - sigma_low * std  and values higher than  center + sigma_high * std . Otherwise, they will be replaced with  fill . Examples julia> x = randn(100_000);\n\njulia> extrema(x)\n(-4.496308951466683, 4.080724496910187)\n\njulia> x_clip = sigma_clip(x, 1);\n\njulia> extrema(x_clip) # should be close to (-1, 1)\n(-1.0042721545326967, 0.9957463910682249) source"},{"id":464,"pagetitle":"Getting Started","title":"Photometry.Background.sigma_clip!","ref":"/previews/PR43/Photometry/stable/background/#Photometry.Background.sigma_clip!","content":" Photometry.Background.sigma_clip!  —  Function sigma_clip!(x, sigma; fill=:clamp, center=median(x), std=std(x))\nsigma_clip!(x, sigma_low, sigma_high; fill=:clamp, center=median(x), std=std(x)) In-place version of  sigma_clip Warning sigma_clip!  mutates the element in place and mutation cannot lead to change in type. Please be considerate of your input type, because if you are using  Int64  and we try to clip it to  0.5  an  InexactError  will be thrown. To avoid this, we recommend converting to float before clipping, or using  sigma_clip  which does this internally. source"},{"id":465,"pagetitle":"Getting Started","title":"Photometry.Background.validate_SE","ref":"/previews/PR43/Photometry/stable/background/#Photometry.Background.validate_SE","content":" Photometry.Background.validate_SE  —  Function Utility function for SourceExtractorBackground algorithm source"},{"id":468,"pagetitle":"Background Estimators","title":"Background Estimators","ref":"/previews/PR43/Photometry/stable/background/estimators/#Background-Estimators","content":" Background Estimators All of these estimators are subtypes of  Background.LocationEstimator  or  Background.RMSEstimator  and are derived using various statistical and image processing methods."},{"id":469,"pagetitle":"Background Estimators","title":"Location Estimators","ref":"/previews/PR43/Photometry/stable/background/estimators/#Location-Estimators","content":" Location Estimators These estimators are used for estimating the background using some form of a central statistic."},{"id":470,"pagetitle":"Background Estimators","title":"Photometry.Background.LocationEstimator","ref":"/previews/PR43/Photometry/stable/background/estimators/#Photometry.Background.LocationEstimator","content":" Photometry.Background.LocationEstimator  —  Type Background.LocationEstimator This abstract type embodies the possible background estimation algorithms for dispatch with  estimate_background . To implement a new estimator, you must define the struct and define a method like  (::MyEstimator)(data::AbstractArray; dims=:) . See Also Location Estimators source"},{"id":471,"pagetitle":"Background Estimators","title":"Photometry.Background.MMMBackground","ref":"/previews/PR43/Photometry/stable/background/estimators/#Photometry.Background.MMMBackground","content":" Photometry.Background.MMMBackground  —  Type MMMBackground(median_factor=3, mean_factor=2) Estimate the background using a mode estimator of the form  median_factor * median - mean_factor * mean . This algorithm is based on the  MMMBackground  routine originally implemented in DAOPHOT.  MMMBackground  uses factors of  median_factor=3  and  mean_factor=2  by default. This estimator assumes that contaminated sky pixel values overwhelmingly display positive departures from the true value. Examples julia> x = ones(3, 5);\n\njulia> MMMBackground()(x)\n1.0\n\njulia> MMMBackground(median_factor=4, mean_factor=3)(x, dims = 1)\n1×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0 See Also SourceExtractorBackground source"},{"id":472,"pagetitle":"Background Estimators","title":"Photometry.Background.SourceExtractorBackground","ref":"/previews/PR43/Photometry/stable/background/estimators/#Photometry.Background.SourceExtractorBackground","content":" Photometry.Background.SourceExtractorBackground  —  Type SourceExtractorBackground() This estimator returns the background of the input using the SourceExtractorBackground algorithm. The background is calculated using a mode estimator of the form  (2.5 * median) - (1.5 * mean) . If  (mean - median) / std > 0.3  then the median is used and if  std = 0  then the mean is used. Examples julia> data = ones(3, 5);\n\njulia> SourceExtractorBackground()(data)\n1.0\n\njulia> SourceExtractorBackground()(data, dims=1)\n1×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0 source"},{"id":473,"pagetitle":"Background Estimators","title":"Photometry.Background.BiweightLocationBackground","ref":"/previews/PR43/Photometry/stable/background/estimators/#Photometry.Background.BiweightLocationBackground","content":" Photometry.Background.BiweightLocationBackground  —  Type BiweightLocationBackground(c = 6.0, M = nothing) Estimate the background using the robust biweight location statistic. \\[ξ_{biloc} = M + \\frac{∑_{|uᵢ|<1}{(xᵢ - M)(1 - uᵢ²)²}}{∑_{|uᵢ|<1}{(1-uᵢ²)²}}\\] \\[u_i = \\frac{(x_i - M)}{c⋅\\mathrm{MAD}(x)}\\] Where  $\\mathrm{MAD}(x)$  is median absolute deviation of  x . Examples julia> x = ones(3,5);\n\njulia> BiweightLocationBackground()(x)\n1.0\n\njulia> BiweightLocationBackground(c=5.5)(x; dims = 1)\n1×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0 source"},{"id":474,"pagetitle":"Background Estimators","title":"RMS Estimators","ref":"/previews/PR43/Photometry/stable/background/estimators/#RMS-Estimators","content":" RMS Estimators These estimators are used for estimating the root-mean-square (RMS) of the background using some form of a deviation statistic."},{"id":475,"pagetitle":"Background Estimators","title":"Photometry.Background.RMSEstimator","ref":"/previews/PR43/Photometry/stable/background/estimators/#Photometry.Background.RMSEstimator","content":" Photometry.Background.RMSEstimator  —  Type Background.RMSEstimator This abstract type embodies the possible background RMS estimation algorithms for dispatch with  estimate_background . To implement a new estimator, you must define the struct and define a method like  (::MyRMSEstimator)(data::AbstractArray; dims=:) . See Also RMS Estimators source"},{"id":476,"pagetitle":"Background Estimators","title":"Photometry.Background.StdRMS","ref":"/previews/PR43/Photometry/stable/background/estimators/#Photometry.Background.StdRMS","content":" Photometry.Background.StdRMS  —  Type StdRMS() Uses the standard deviation statistic for background RMS estimation. Examples julia> data = ones(3, 5);\n\njulia> StdRMS()(data)\n0.0\n\njulia> StdRMS()(data, dims=1)\n1×5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0 source"},{"id":477,"pagetitle":"Background Estimators","title":"Photometry.Background.MADStdRMS","ref":"/previews/PR43/Photometry/stable/background/estimators/#Photometry.Background.MADStdRMS","content":" Photometry.Background.MADStdRMS  —  Type MADStdRMS() Uses the standard median absolute deviation (MAD) statistic for background RMS estimation. This is typically given as $σ ≈ 1.4826 ⋅ \\mathrm{MAD}$ Examples julia> data = ones(3, 5);\n\njulia> MADStdRMS()(data)\n0.0\n\njulia> MADStdRMS()(data, dims=1)\n1×5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0 source"},{"id":478,"pagetitle":"Background Estimators","title":"Photometry.Background.BiweightScaleRMS","ref":"/previews/PR43/Photometry/stable/background/estimators/#Photometry.Background.BiweightScaleRMS","content":" Photometry.Background.BiweightScaleRMS  —  Type BiweightScaleRMS(c=9.0, M=nothing) Uses the robust biweight scale statistic for background RMS estimation. The biweight scale is the square root of the biweight midvariance. The biweight midvariance uses a tuning constant,  c , and an optional initial guess of the central value  M . \\[ζ²_{biscl} = \\frac{n ∑_{|uᵢ|<1}{(xᵢ - M)²(1 - uᵢ²)⁴}}{\\left[∑_{|uᵢ|<1}{(1-uᵢ²)(1-5uᵢ²)}\\right]²}\\] \\[uᵢ = \\frac{(xᵢ - M)}{c⋅\\mathrm{MAD}(x)}\\] Where  $\\mathrm{MAD}(x)$  is median absolute deviation of  x . Examples julia> data = ones(3, 5);\n\njulia> BiweightScaleRMS()(data)\n0.0\n\njulia> BiweightScaleRMS(c=3.0)(data, dims=1)\n1×5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0 source"},{"id":481,"pagetitle":"Background Interpolators","title":"Background Interpolators","ref":"/previews/PR43/Photometry/stable/background/interpolators/#Background-Interpolators","content":" Background Interpolators Background interpolators provide a method for converting a low-resolution mesh into a low-order high-resolution image."},{"id":482,"pagetitle":"Background Interpolators","title":"Photometry.Background.BackgroundInterpolator","ref":"/previews/PR43/Photometry/stable/background/interpolators/#Photometry.Background.BackgroundInterpolator","content":" Photometry.Background.BackgroundInterpolator  —  Type Background.BackgroundInterpolator This abstract type embodies the different ways of converting a low-resolution mesh into a high-resolution image, especially for dispatch with  estimate_background To implement a new interpolation scheme, you must define the struct and define a method like  (::MyInterpolator)(mesh) See Also Interpolators source"},{"id":483,"pagetitle":"Background Interpolators","title":"Interpolators","ref":"/previews/PR43/Photometry/stable/background/interpolators/#Interpolators","content":" Interpolators"},{"id":484,"pagetitle":"Background Interpolators","title":"Photometry.Background.ZoomInterpolator","ref":"/previews/PR43/Photometry/stable/background/interpolators/#Photometry.Background.ZoomInterpolator","content":" Photometry.Background.ZoomInterpolator  —  Type ZoomInterpolator(factors) Use a cubic-spline interpolation scheme to increase resolution of a mesh. factors  represents the level of \"zoom\", so an input mesh of size  (10, 10)  with factors  (2, 2)  will have an output size of  (20, 20) . If only an integer is provided, it will be used as the factor for every axis. Examples julia> ZoomInterpolator(2)([1 0; 0 1])\n4×4 Matrix{Float64}:\n  1.0          0.75   0.25   -2.77556e-17\n  0.75         0.625  0.375   0.25\n  0.25         0.375  0.625   0.75\n -5.55112e-17  0.25   0.75    1.0\n\njulia> ZoomInterpolator(3, 1)([1 0; 0 1])\n6×2 Matrix{Float64}:\n  1.0          -2.77556e-17\n  1.0          -2.77556e-17\n  0.666667      0.333333\n  0.333333      0.666667\n -5.55112e-17   1.0\n -5.55112e-17   1.0\n source"},{"id":485,"pagetitle":"Background Interpolators","title":"Photometry.Background.IDWInterpolator","ref":"/previews/PR43/Photometry/stable/background/interpolators/#Photometry.Background.IDWInterpolator","content":" Photometry.Background.IDWInterpolator  —  Type IDWInterpolator(factors; leafsize=10, k=8, power=1, reg=0, conf_dist=1e-12) Use Shepard Inverse Distance Weighing interpolation scheme to increase resolution of a mesh. factors  represents the level of \"zoom\", so an input mesh of size  (10, 10)  with factors  (2, 2)  will have an output size of  (20, 20) . If only an integer is provided, it will be used as the factor for every axis. The interpolator can be called with some additional parameters: leaf_size  determines at what number of points to stop splitting the tree further, k  which is the number of nearest neighbors to be considered, power  is the exponent for distance in the weighing factor, reg  is the offset for the weighing factor in denominator, conf_dist  is the distance below which two points would be considered as the same point. Examples julia> IDWInterpolator(2, k=2)([1 0; 0 1])\n4×4 Matrix{Float64}:\n 1.0   0.75      0.25      0.0\n 0.75  0.690983  0.309017  0.25\n 0.25  0.309017  0.690983  0.75\n 0.0   0.25      0.75      1.0\n\njulia> IDWInterpolator(3, 1; k=2, power=4)([1 0; 0 1])\n6×2 Matrix{Float64}:\n 1.0        0.0\n 1.0        0.0\n 0.941176   0.0588235\n 0.0588235  0.941176\n 0.0        1.0\n 0.0        1.0 source"},{"id":488,"pagetitle":"Getting Started","title":"Source Detection","ref":"/previews/PR43/Photometry/stable/detection/#Source-Detection","content":" Source Detection The module provides tools and algorithms for detecting and extracting point-like sources."},{"id":489,"pagetitle":"Getting Started","title":"API/Reference","ref":"/previews/PR43/Photometry/stable/detection/#API/Reference","content":" API/Reference"},{"id":490,"pagetitle":"Getting Started","title":"Photometry.Detection.extract_sources","ref":"/previews/PR43/Photometry/stable/detection/#Photometry.Detection.extract_sources","content":" Photometry.Detection.extract_sources  —  Function extract_sources(::SourceFinder, data, [error]; sorted=true) Uses  method  to find and extract point-like sources. Returns a  TypedTables.Table  with positions and information related to the  method . For instance, using  PeakMesh  returns a table a column for the peak values. data  is assumed to be background-subtracted. If  error  is provided it will be propagated into the detection algorithm. If  sorted  is  true  the sources will be sorted by their amplitude. See Also Source Detection Algorithms source"},{"id":493,"pagetitle":"Algorithms","title":"Source Detection Algorithms","ref":"/previews/PR43/Photometry/stable/detection/algs/#Source-Detection-Algorithms","content":" Source Detection Algorithms"},{"id":494,"pagetitle":"Algorithms","title":"Photometry.Detection.SourceFinder","ref":"/previews/PR43/Photometry/stable/detection/algs/#Photometry.Detection.SourceFinder","content":" Photometry.Detection.SourceFinder  —  Type Detection.SourceFinder Abstract super type for source detection algorithms used with  extract_sources . source"},{"id":495,"pagetitle":"Algorithms","title":"API/Reference","ref":"/previews/PR43/Photometry/stable/detection/algs/#API/Reference","content":" API/Reference"},{"id":496,"pagetitle":"Algorithms","title":"Photometry.Detection.PeakMesh","ref":"/previews/PR43/Photometry/stable/detection/algs/#Photometry.Detection.PeakMesh","content":" Photometry.Detection.PeakMesh  —  Type PeakMesh(box_size=(3, 3), nsigma=3.0) Detect sources by finding peaks above a threshold in grids across the image. This creates a pixel-wise threshold for sources by calculating  error * nsigma  when used with  extract_sources . The peaks are found by searching the image in boxes of size  box_size . If the maximum value in that box is greater than the threshold set above, the point is extracted. source"},{"id":499,"pagetitle":"Home","title":"PSFModels.jl","ref":"/previews/PR43/PSFModels/stable/#PSFModels.jl","content":" PSFModels.jl"},{"id":500,"pagetitle":"Home","title":"Installation","ref":"/previews/PR43/PSFModels/stable/#Installation","content":" Installation PSFModels can be added from the Julia package manager julia> ] # pressing ']' should drop you into pkg-mode\npkg> add PSFModels"},{"id":501,"pagetitle":"Home","title":"Getting Started","ref":"/previews/PR43/PSFModels/stable/#Getting-Started","content":" Getting Started To import the library julia> using PSFModels None of the models are exported to avoid namespace clashes, but it can be verbose to continuously rewrite  PSFModels . You can either import names directly julia> using PSFModels: gaussian\n\njulia> model = gaussian(x=0, y=0, fwhm=8) or you can create an alias for  PSFModels # julia version 1.5 or below\nusing PSFModels\nconst M = PSFModels\n# julia version 1.6 or above\nimport PSFModels as M\n\nmodel = M.gaussian(x=0, y=0, fwhm=10)"},{"id":502,"pagetitle":"Home","title":"Contributing and Support","ref":"/previews/PR43/PSFModels/stable/#Contributing-and-Support","content":" Contributing and Support If you would like to contribute, feel free to open a  pull request . If you want to discuss something before contributing, head over to  discussions  and join or open a new topic. If you're having problems with something, please open an  issue ."},{"id":505,"pagetitle":"API/Reference","title":"API/Reference","ref":"/previews/PR43/PSFModels/stable/api/#API/Reference","content":" API/Reference PSFModels.airydisk PSFModels.fit PSFModels.gaussian PSFModels.moffat PSFModels.normal"},{"id":506,"pagetitle":"API/Reference","title":"Gaussian","ref":"/previews/PR43/PSFModels/stable/api/#Gaussian","content":" Gaussian"},{"id":507,"pagetitle":"API/Reference","title":"PSFModels.gaussian","ref":"/previews/PR43/PSFModels/stable/api/#PSFModels.gaussian","content":" PSFModels.gaussian  —  Function gaussian([T=Float64], point; x, y, fwhm, amp=1, theta=0, bkg=0)\ngaussian([T=Float64], px, py; x, y, fwhm, amp=1, theta=0, bkg=0) An unnormalized bivariate Gaussian distribution. The position can be specified in  (x, y)  coordinates as a  Tuple ,  AbstractVector , or as separate arguments. If  theta  is given, the PSF will be rotated by  theta  degrees counter-clockwise from the x-axis. If  bkg  is given it will be added as a scalar to the PSF. The  fwhm  can be a scalar (isotropic) or a vector/tuple (diagonal). Keep in mind that  theta  has no effect for isotropic distributions and is degenerate with the  fwhm  parameters (i.e., theta=90 is the same as reversing the  fwhm  tuple) Functional form \\[f(x | x̂, \\mathrm{FWHM}) = \\exp[-4 \\ln(2) ⋅ ||x - x̂|| / \\mathrm{FWHM}^2]\\] where  x̂  and  x  are position vectors (indices)  ||⋅||  represents the square-distance, and  FWHM  is the full width at half-maximum. If  FWHM  is a scalar, the Gaussian distribution will be isotropic. If  FWHM  is a vector or tuple, the weighting is applied along each axis (diagonal). source"},{"id":508,"pagetitle":"API/Reference","title":"PSFModels.normal","ref":"/previews/PR43/PSFModels/stable/api/#PSFModels.normal","content":" PSFModels.normal  —  Function normal An alias for  gaussian source gauss = gaussian(x=0, y=0, fwhm=10)\npsfplot(gauss, -50:50, -50:50; title=\"gaussian(fwhm=10)\",\n        colorbar_scale=:log10, clims=(1e-5, 1))"},{"id":509,"pagetitle":"API/Reference","title":"Airy Disk","ref":"/previews/PR43/PSFModels/stable/api/#Airy-Disk","content":" Airy Disk"},{"id":510,"pagetitle":"API/Reference","title":"PSFModels.airydisk","ref":"/previews/PR43/PSFModels/stable/api/#PSFModels.airydisk","content":" PSFModels.airydisk  —  Function airydisk([T=Float64], point; x, y, fwhm, ratio=0, amp=1, theta=0, bkg=0)\nairydisk([T=Float64], px, py; x, y, fwhm, ratio=0, amp=1, theta=0, bkg=0) An unnormalized Airy disk. The position can be specified in  (x, y)  coordinates as a  Tuple ,  AbstractVector , or as separate arguments. If  theta  is given, the PSF will be rotated by  theta  degrees counter-clockwise from the x-axis. If  bkg  is given it will be added as a scalar to the PSF. The  fwhm  can be a scalar (isotropic) or a vector/tuple (diagonal). Keep in mind that  theta  has no effect for isotropic distributions and is degenerate with the  fwhm  parameters (i.e., theta=90 is the same as reversing the  fwhm  tuple) If  ratio  is supplied, this will be the Airy pattern for a centrally-obscured aperture (e.g., a Newtonian telescope). This has a slightly expanded functional form, and in general the central Airy disk will be smaller and the first Airy ring will be brighter. Functional form The Airy disk is a distribution over the radius  r  (the square-Euclidean distance) \\[f(x | x̂, \\mathrm{FWHM}) = [ 2J₁(q) / q ]^2\\] where  J₁  is the first-order Bessel function of the first kind and \\[q ≈ π r D / λ ≈ π r / (0.973 × \\mathrm{FWHM})\\] If user a non-zero central obscuration via  ratio , the functional form becomes \\[f(x | x̂, \\mathrm{FWHM}, ϵ) = [ 2J₁(q) / q - 2ϵJ₁(ϵq) / q ]^2 / (1 - ϵ^2)^2\\] where  $ϵ$  is the ratio ( $0 ≤ ϵ < 1$ ). source airy = airydisk(x=0, y=0, fwhm=10)\npsfplot(airy, -50:50, -50:50; title=\"airydisk(fwhm=10)\",\n        colorbar_scale=:log10, clims=(1e-5, 1)) airy_obscured = airydisk(x=0, y=0, fwhm=10, ratio=0.3)\npsfplot(airy_obscured, -50:50, -50:50; title=\"airydisk(fwhm=10, ratio=0.3)\",\n        colorbar_scale=:log10, clims=(1e-5, 1))"},{"id":511,"pagetitle":"API/Reference","title":"Moffat","ref":"/previews/PR43/PSFModels/stable/api/#Moffat","content":" Moffat"},{"id":512,"pagetitle":"API/Reference","title":"PSFModels.moffat","ref":"/previews/PR43/PSFModels/stable/api/#PSFModels.moffat","content":" PSFModels.moffat  —  Function moffat([T=Float64], point; x, y, fwhm, alpha=1, amp=1, theta=0, bkg=0)\nmoffat([T=Float64], px, py; x, y, fwhm, alpha=1, amp=1, theta=0, bkg=0) Two dimensional Moffat model. The position can be specified in  (x, y)  coordinates as a  Tuple ,  AbstractVector , or as separate arguments. If  theta  is given, the PSF will be rotated by  theta  degrees counter-clockwise from the x-axis. If  bkg  is given it will be added as a scalar to the PSF. The  fwhm  can be a scalar (isotropic) or a vector/tuple (diagonal). Keep in mind that  theta  has no effect for isotropic distributions and is degenerate with the  fwhm  parameters (i.e., theta=90 is the same as reversing the  fwhm  tuple) Functional form \\[f(x | x̂, \\mathrm{FWHM}, α) = A (1 + (||x - x̂|| / \\mathrm{FWHM} / 2)^2)^{-α}\\] where  x̂  and  x  are position vectors (indices)  ||⋅||  represents the distance, and  FWHM  is the full width at half-maximum. If  fwhm  is a vector or tuple, the weighting is applied along each axis. Note that this function technically uses the half width at half-maximum, defined as  $\\mathrm{HWHM} = \\mathrm{FWHM}/2$ , but for compatibility with the other models,  fwhm  is used as an input parameter instead. source moff = moffat(x=0, y=0, fwhm=10)\npsfplot(moff, -50:50, -50:50; title=\"moffat(fwhm=10)\",\n        colorbar_scale=:log10, clims=(1e-5, 1)) moff2 = moffat(x=0, y=0, fwhm=10, alpha=2)\npsfplot(moff2, -50:50, -50:50; title=\"moffat(fwhm=10, alpha=2)\",\n        colorbar_scale=:log10, clims=(1e-5, 1))"},{"id":513,"pagetitle":"API/Reference","title":"Comparison","ref":"/previews/PR43/PSFModels/stable/api/#Comparison","content":" Comparison xs = range(0, 50, length=1000)\nplot(\n    xs, [gauss.(xs, 0) airy.(xs, 0) moff.(xs, 0)],\n    label=[\"gaussian\" \"airydisk\" \"moffat\"], yscale=:log10,\n    xlabel=\"x\", ylabel=\"I\", ylims=(1e-5, 1)\n)"},{"id":514,"pagetitle":"API/Reference","title":"Fitting","ref":"/previews/PR43/PSFModels/stable/api/#Fitting","content":" Fitting"},{"id":515,"pagetitle":"API/Reference","title":"PSFModels.fit","ref":"/previews/PR43/PSFModels/stable/api/#PSFModels.fit","content":" PSFModels.fit  —  Function PSFModels.fit(model, params, image, inds=axes(image);\n              func_kwargs=(;), loss=abs2, maxfwhm=Inf, alg=LBFGS(),\n              kwargs...) Fit a PSF model ( model ) defined by the given  params  as a named tuple of the parameters to fit and their default values. This model is fit to the data in  image  at the specified  inds  (by default, the entire array). To pass extra keyword arguments to the  model  (i.e., to \"freeze\" a parameter), pass them in a named tuple to  func_kwargs . The default loss function is the chi-squared loss, which uses the the square of the difference (i.e., the L2 norm). You can change this to the L1 norm, for example, by passing  loss=abs . The maximum FWHM can be set with  maxfwhm  as a number or tuple. Additional keyword arguments, as well as the fitting algorithm  alg , are passed to  Optim.optimize . By default we use forward-mode auto-differentiation (AD) to derive Jacobians for the  Newton with Trust Region  optimization algorithm. Refer to the  Optim.jl documentation  for more information. Choosing parameters The  fit  function is very powerful because it gives you a great amount of flexibility in the way you fit your models. To demonstrate this, let's start with a simple isotropic  gaussian . model = gaussian\n# match params to arguments of PSF\nparams = (x=20, y=20, fwhm=3, amp=1) Note that  params  can follow any order params = (amp=1, x=20, y=20, fwhm=3) Now, to extend this interface to the bivariate PSF case, where  fwhm  is two values, all you need to do is use a tuple or vector params = (x=20, y=20, fwhm=(3, 3)) and, again, the order does not matter model = moffat\nparams = (alpha=1, x=20, y=20, fwhm=3, amp=10) Fitting a PSF After selecting your model and parameters, fitting data is easy P = (x=12, y=13, fwhm=13.2, amp=0.1)\npsf = gaussian.(CartesianIndicies(1:25, 1:15); P...)\n\nparams, synthpsf = PSFModels.fit(gaussian, P, psf) here  params  is a named tuple of the best fitting parameters. It will not include any fixed parameters. synthpsf  is the best-fitting model, for direct comparison with the input data. psf_fit = synthpsf.(CartesianIndicies(psf)) To alter parameters without fitting them (i.e., \"freeze\" them) use  func_kwargs P = (x=12, y=13, fwhm=(12.4, 13.2), amp=0.1)\nfunc_kwargs = (alpha=2)\nparams, synthpsf = PSFModels.fit(moffat, P, psf; func_kwargs) source"},{"id":518,"pagetitle":"Benchmarks","title":"Benchmarks","ref":"/previews/PR43/PSFModels/stable/bench/#Benchmarks","content":" Benchmarks The benchmarks can be found in the  bench/  folder. To run them, first instantiate the environment $ julia --project=bench -e \"using Pkg; Pkg.instantiate()\" then execute the  bench/bench.jl  file $ julia --project=bench bench/bench.jl System Information Julia Version 1.10.4\nCommit 48d4fd48430 (2024-06-04 10:41 UTC)\nBuild Info:\n  Official https://julialang.org/ release\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 16 × 13th Gen Intel(R) Core(TM) i5-1340P\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-15.0.7 (ORCJIT, goldmont)\nThreads: 1 default, 0 interactive, 1 GC (on 16 virtual cores)"},{"id":519,"pagetitle":"Benchmarks","title":"Evaluation benchmark","ref":"/previews/PR43/PSFModels/stable/bench/#Evaluation-benchmark","content":" Evaluation benchmark This benchmark tests how long it takes to evaluate a single point in the PSF model. This may seem contrived, but we expect performance to scale directly from this measure: if it takes 1 microsecond to evaluate a single point, it should take ~1 second to evaluate a 1000×1000 image, with speedups potentially from multithreading or SIMD loop evaluation. table = CSV.read(benchdir(\"evaluation_results.csv\"), DataFrame) 3×3 DataFrame\n Row │ name      psfmodels   astropy\n     │ String15  Float64     Float64\n─────┼─────────────────────────────────\n   1 │ Gaussian  2.33112e-8  7.1579e-5\n   2 │ AiryDisk  1.9672e-8   5.7172e-5\n   3 │ Moffat    2.33253e-8  5.3287e-5 @df table groupedbar(\n    :name, [:psfmodels :astropy];\n    ylabel=\"time (s)\", yscale=:log10, legend=:outertopright,\n    label=[\"PSFModels.jl\" \"Astropy\"], size=(500, 300),\n)"},{"id":520,"pagetitle":"Benchmarks","title":"Fitting benchmark","ref":"/previews/PR43/PSFModels/stable/bench/#Fitting-benchmark","content":" Fitting benchmark This benchmark tests how long it takes to fit a PSF Model to a stamp with size (39, 39). In all cases, we use equivalently complex models, the default fitters for PSFModels.jl, and the default  LevMarLSQFit  fitter for astropy. table = CSV.read(benchdir(\"fitting_results.csv\"), DataFrame) 3×3 DataFrame\n Row │ name      psfmodels   astropy\n     │ String15  Float64     Float64\n─────┼──────────────────────────────────\n   1 │ Gaussian  0.00349649  0.00731791\n   2 │ AiryDisk  0.00849787  0.00952454\n   3 │ Moffat    0.00393968  0.00754826 @df table groupedbar(\n    :name, [:psfmodels :astropy];\n    ylabel=\"time (s)\", yscale=:log10, legend=:outertopright,\n    label=[\"PSFModels.jl\" \"Astropy\"], size=(500, 300),\n)"},{"id":523,"pagetitle":"Examples","title":"Examples","ref":"/previews/PR43/PSFModels/stable/examples/#Examples","content":" Examples"},{"id":524,"pagetitle":"Examples","title":"Fitting a PSF","ref":"/previews/PR43/PSFModels/stable/examples/#Fitting-a-PSF","content":" Fitting a PSF Here is a brief example which shows how to construct a loss function for fitting a  PSFModel  to some data. using PSFModels\nusing PSFModels: fit\nusing HCIDatasets: BetaPictoris\nusing Plots\nusing Statistics\n\n# convenience function for plotting\nfunction imshow(data; kwargs...)\n    xlim = extrema(axes(data, 1))\n    ylim = extrema(axes(data, 2))\n    heatmap(transpose(data); xlim=xlim, ylim=ylim,\n            aspect_ratio=1, clims=(1e-5, Inf), kwargs...)\nend\n\n# get a PSF from HCIDatasets.jl;\n# you may be prompted to download the file\npsf = BetaPictoris[:psf]\ninds = CartesianIndices(psf)\n\nimshow(psf) We can fit this data with a variety of models, here showcasing the flexible  PSFModels.fit  function."},{"id":525,"pagetitle":"Examples","title":"Gaussian","ref":"/previews/PR43/PSFModels/stable/examples/#Gaussian","content":" Gaussian Using  gaussian params = (x=20, y=20, fwhm=5, amp=0.1)\nP_gauss, mod_gauss = fit(gaussian, params, psf)\npairs(P_gauss) pairs(::NamedTuple) with 4 entries:\n  :x    => 20.0191\n  :y    => 20.01\n  :fwhm => 4.80293\n  :amp  => 0.100216 plot(\n    imshow(psf, title=\"Data\"),\n    imshow(mod_gauss.(inds), title=\"Model\"),\n    cbar=false,\n    ticks=false,\n    layout=2,\n    size=(600, 300)\n) and now using a rotated, elliptical Gaussian params = (x=20, y=20, fwhm=(5, 5), amp=0.1, theta=0)\nP_ellip, mod_ellip = fit(gaussian, params, psf)\npairs(P_ellip) pairs(::NamedTuple) with 5 entries:\n  :x     => 20.0183\n  :y     => 20.01\n  :fwhm  => (4.76706, 4.83663)\n  :amp   => 0.100243\n  :theta => 0.0 plot(\n    imshow(psf, title=\"Data\"),\n    imshow(mod_ellip.(inds), title=\"Model\"),\n    cbar=false,\n    ticks=false,\n    layout=2,\n    size=(600, 300)\n)"},{"id":526,"pagetitle":"Examples","title":"Airy disk","ref":"/previews/PR43/PSFModels/stable/examples/#Airy-disk","content":" Airy disk Now with  airydisk params = (x=20, y=20, fwhm=5, amp=0.1, ratio=0.3)\nP_airy, mod_airy = fit(airydisk, params, psf)\npairs(P_airy) pairs(::NamedTuple) with 5 entries:\n  :x     => 19.9891\n  :y     => 20.0062\n  :fwhm  => 5.05739\n  :amp   => 0.139425\n  :ratio => 0.375189 plot(\n    imshow(psf, title=\"Data\"),\n    imshow(mod_airy.(inds), title=\"Model\"),\n    cbar=false,\n    ticks=false,\n    layout=2,\n    size=(600, 300)\n)"},{"id":527,"pagetitle":"Examples","title":"Moffat","ref":"/previews/PR43/PSFModels/stable/examples/#Moffat","content":" Moffat And finally, with  moffat params = (x=20, y=20, fwhm=(5, 5), amp=0.1, theta=0, alpha=2)\nP_moff, mod_moff = fit(moffat, params, psf)\npairs(P_moff) pairs(::NamedTuple) with 6 entries:\n  :x     => 20.0366\n  :y     => 20.0154\n  :fwhm  => (3.95567, 3.78329)\n  :amp   => 0.11638\n  :theta => 42.3939\n  :alpha => 1.46268 plot(\n    imshow(psf, title=\"Data\"),\n    imshow(mod_moff.(inds), title=\"Model\"),\n    cbar=false,\n    ticks=false,\n    layout=2,\n    size=(600, 300)\n)"},{"id":528,"pagetitle":"Examples","title":"Changing optimization parameters","ref":"/previews/PR43/PSFModels/stable/examples/#Changing-optimization-parameters","content":" Changing optimization parameters Any keyword arguments get passed on to  Optim.optimize , and you can change the algorithm used with the  alg  keyword # load Optim.jl to use the Newton method\nusing Optim\n\nparams = (x=20, y=20, fwhm=(5, 5), amp=0.1, theta=0, alpha=2)\nP_moff, mod_moff = fit(moffat, params, psf; alg=Newton())\npairs(P_moff) pairs(::NamedTuple) with 6 entries:\n  :x     => 20.0359\n  :y     => 20.0151\n  :fwhm  => (3.87008, 3.8665)\n  :amp   => 0.116352\n  :theta => 0.0\n  :alpha => 1.46154 We can also \"freeze\" parameters by creating a named tuple and passing it to  func_kwargs params = (;x=10, y=20, fwhm=(5, 5), amp=0.1)\nfunc_kwargs = (;alpha=2)\nP_moff2, mod_moff2 = fit(moffat, params, psf; func_kwargs)\npairs(P_moff2) pairs(::NamedTuple) with 4 entries:\n  :x    => 20.0349\n  :y    => 20.0144\n  :fwhm => (4.19137, 4.19478)\n  :amp  => 0.110515 plot(\n    imshow(psf, title=\"Data\"),\n    imshow(mod_moff2.(inds), title=\"Model\"),\n    cbar=false,\n    ticks=false,\n    layout=2,\n    size=(600, 300)\n)"},{"id":531,"pagetitle":"Introduction","title":"Introduction","ref":"/previews/PR43/PSFModels/stable/introduction/#Introduction","content":" Introduction Statistical models for constructing point-spread functions (PSFs)."},{"id":532,"pagetitle":"Introduction","title":"Models","ref":"/previews/PR43/PSFModels/stable/introduction/#Models","content":" Models The following models are currently implemented gaussian / normal airydisk moffat"},{"id":533,"pagetitle":"Introduction","title":"Parameters","ref":"/previews/PR43/PSFModels/stable/introduction/#Parameters","content":" Parameters In general, the PSFs have a position, a full-width at half-maximum (FWHM) measure, and an amplitude. The position follows a 1-based pixel coordinate system, where  (1, 1)  represents the  center  of the bottom left pixel. This matches the indexing style of Julia as well as DS9, IRAF, SourceExtractor, and WCS. The FWHM is a consistent scale parameter for the models. That means a  gaussian  with a FWHM of 5 will be visually similar to an  airydisk  with a FWHM of 5. All models support a scalar (isotropic) FWHM and a FWHM for each axis (diagonal), as well as arbitrarily rotating the PSF. Pixel-convention The pixel convention adopted here is that the bottom-left pixel  center  is  (1, 1) . The column-major memory layout of julia puts the  x  axis as the rows of a matrix and the  y  axis as the columns. In other words, the axes unpack like xs, ys = axes(image)"},{"id":534,"pagetitle":"Introduction","title":"Usage","ref":"/previews/PR43/PSFModels/stable/introduction/#Usage","content":" Usage"},{"id":535,"pagetitle":"Introduction","title":"Evaluating models","ref":"/previews/PR43/PSFModels/stable/introduction/#Evaluating-models","content":" Evaluating models Directly evaluating the functions is the most straightforward way to use this package julia> gaussian(0, 0; x=0, y=0, fwhm=3)\n1.0\n\njulia> gaussian(BigFloat, 0, 0; x=0, y=0, fwhm=3, amp=0.1, bkg=1)\n1.100000000000000088817841970012523233890533447265625 We also provide \"curried\" versions of the functions, which allow you to specify the parameters and evaluate the PSF later julia> model = gaussian(x=0, y=0, fwhm=3);\n\njulia> model(0, 0)\n1.0 If we want to collect the model into a dense matrix, simply iterate over indices julia> inds = CartesianIndices((-2:2, -2:2));\n\njulia> model.(inds) # broadcasting\n5×5 Matrix{Float64}:\n 0.0850494  0.214311  0.291632  0.214311  0.0850494\n 0.214311   0.54003   0.734867  0.54003   0.214311\n 0.291632   0.734867  1.0       0.734867  0.291632\n 0.214311   0.54003   0.734867  0.54003   0.214311\n 0.0850494  0.214311  0.291632  0.214311  0.0850494 This makes it very easy to evaluate the PSF on the same axes as an image (array) julia> img = randn(5, 5);\n\njulia> model.(CartesianIndices(img))\n5×5 Matrix{Float64}:\n 0.54003      0.214311     0.0459292    0.00531559   0.000332224\n 0.214311     0.0850494    0.018227     0.00210949   0.000131843\n 0.0459292    0.018227     0.00390625   0.000452087  2.82555e-5\n 0.00531559   0.00210949   0.000452087  5.2322e-5    3.27013e-6\n 0.000332224  0.000131843  2.82555e-5   3.27013e-6   2.04383e-7 this is trivially expanded to fit \"stamps\" in images julia> big_img = randn(1000, 1000);\n\njulia> stamp_inds = (750:830, 400:485);\n\njulia> stamp = @view big_img[stamp_inds...];\n\njulia> stamp_model = model.(CartesianIndices(stamp_inds)); or we can create a loss function for fitting PSFs without allocating any memory. We are simply iterating over the image array! julia> using Statistics\n\njulia> mse = mean(I -> (big_img[I] - model(I))^2, CartesianIndices(stamp_inds));"},{"id":536,"pagetitle":"Introduction","title":"Fitting data","ref":"/previews/PR43/PSFModels/stable/introduction/#Fitting-data","content":" Fitting data There exists a simple, yet powerful, API for fitting data with  PSFModels.fit . # `fit` is not exported to avoid namespace clashes\nusing PSFModels: fit\n\ndata = # load data\nstamp_inds = # optionally choose indices to \"cutout\"\n\n# use an isotropic Gaussian\nparams, synthpsf = fit(gaussian, (x=12, y=13, fwhm=3.2, amp=0.1),\n                       data, stamp_inds)\n\n# elliptical, rotated Gaussian\nparams, synthpsf = fit(gaussian, (x=12, y=13, fwhm=(3.2, 3.2), amp=0.1, theta=0)\n                       data, stamp_inds)\n\n# obscured Airy disk\nparams, synthpsf = fit(airydisk, (x=12, y=13, fwhm=3.2, amp=0.1, ratio=0.3),\n                       data, stamp_inds)\n\n# bivariate Moffat with arbitrary alpha\nparams, synthpsf = fit(moffat, (x=12, y=13, fwhm=(3.2, 3.2), amp=0.1, alpha=1),\n                       data, stamp_inds)"},{"id":537,"pagetitle":"Introduction","title":"Plotting","ref":"/previews/PR43/PSFModels/stable/introduction/#Plotting","content":" Plotting Finally, we provide plotting recipes ( psfplot / psfplot! ) from  RecipesBase.jl , which can be seen in use in the  API/Reference  section. using PSFModels # hide\nusing Plots\n\nmodel = gaussian(x=0, y=0, fwhm=(8, 10), theta=12)\npsfplot(model, -30:30, -30:30, colorbar_scale=:log10)"},{"id":540,"pagetitle":"Home","title":"AstroAngles.jl","ref":"/previews/PR43/AstroAngles/stable/#AstroAngles.jl","content":" AstroAngles.jl Lightweight string parsing and representation of angles."},{"id":541,"pagetitle":"Home","title":"Installation","ref":"/previews/PR43/AstroAngles/stable/#Installation","content":" Installation To install use  Pkg . From the REPL, press  ]  to enter Pkg-mode pkg> add AstroAngles If you want to use the most up-to-date version of the code, check it out from  main pkg> add AstroAngles#main"},{"id":542,"pagetitle":"Home","title":"Usage","ref":"/previews/PR43/AstroAngles/stable/#Usage","content":" Usage"},{"id":543,"pagetitle":"Home","title":"Angle Parsing Utilities","ref":"/previews/PR43/AstroAngles/stable/#Angle-Parsing-Utilities","content":" Angle Parsing Utilities String representations of angles in both \"degree:arcmin:arcsec\" and  \"hour:min:sec\" format can be parsed using a variety of delimiters, which can be mixed together (e.g. can use  °  after degrees but  :  after the arcminutes). The directions \"S\" and \"W\" are considered negative and \"-1:0:0S\" is 1 degree North, for example."},{"id":544,"pagetitle":"Home","title":"dms formats","ref":"/previews/PR43/AstroAngles/stable/#dms-formats","content":" dms formats \"[+-]xx:xx:xx.x[NESW]\"\n\"[+-]xx xx xx.x[NESW]\"\n\"[+-]xxdxxmxx.xs[NESW]\"\n\"[+-]xx°xx'xx.x\\\"[NESW]\"\n\"[+-]xx°xx′xx.x″[NESW]\" # \\prime, \\pprime"},{"id":545,"pagetitle":"Home","title":"hms formats","ref":"/previews/PR43/AstroAngles/stable/#hms-formats","content":" hms formats \"[+-]xx:xx:xx.x[NESW]\"\n\"[+-]xx xx xx.x[NESW]\"\n\"[+-]xxhxxmxx.xs[NESW]\"\n\"[+-]xxhxx'xx.x\\\"[NESW]\"\n\"[+-]xx°xx′xx.x″[NESW]\" the simplest way to convert is to use the  @dms_str  and  @hms_str  macros, which allows you to choose the output angle type julia> dms\"12:17:25.3\"\n0.21450726764795752\n\njulia> dms\"12:17:25.3\"rad # default\n0.21450726764795752\n\njulia> dms\"12:17:25.3\"deg\n12.29036111111111\n\njulia> dms\"12:17:25.3\"ha\n0.8193574074074074 here is a showcase of the variety of ways to parse inputs julia> dms\"10.2345d\"deg\n10.2345\n\njulia> dms\"1:2:30.43\"deg\n1.041786111111111\n\njulia> hms\"1 2 0\"ha\n1.0333333333333334\n\njulia> dms\"1°2′3″\"deg\n1.0341666666666667\n\njulia> dms\"1°2′3″N\"deg\n1.0341666666666667\n\njulia> dms\"1d2m3.4s\"deg\n1.0342777777777779\n\njulia> dms\"1d2m3.4sS\"deg\n-1.0342777777777779\n\njulia> hms\"-1h2m3s\"ha\n-1.0341666666666667\n\njulia> hms\"-1h2m3sW\"ha\n1.0341666666666667 for more control on the output, you can use the  parse_dms  and  parse_hms  methods, which returns a tuple of the parsed  dms  or  hms  values parse_dms # string -> (deg, arcmin, arcsec)\nparse_hms # string -> (hours, mins, secs) julia> parse_dms(\"12:17:25.3\")\n(12.0, 17.0, 25.3)\n\njulia> parse_hms(\"-4:4:6\")\n(-4.0, 4.0, 6.0)"},{"id":546,"pagetitle":"Home","title":"Angle Conversion Utilities","ref":"/previews/PR43/AstroAngles/stable/#Angle-Conversion-Utilities","content":" Angle Conversion Utilities The following methods are added for converting to and from hour angles deg2ha # degrees -> hour angles\nrad2ha # radians -> hour angles\nha2deg # hour angles -> degrees\nha2rad # hour angles -> radians The following methods convert from angles as a single number to tuples consistent with sexagesimal deg2dms # degrees -> (deg, arcmin, arcsec)\nrad2dms # radians -> (deg, arcmin, arcsec)\nha2dms  # hour angles -> (deg, arcmin, arcsec)\n\ndeg2hms # degrees -> (hours, mins, secs)\nrad2hms # radians -> (hours, mins, secs)\nha2hms  # hour angles -> (hours, mins, secs) and the inverse dms2deg # (deg, arcmin, arcsec) -> degrees\ndms2rad # (deg, arcmin, arcsec) -> radians\ndms2ha  # (deg, arcmin, arcsec) -> hour angles\n\nhms2deg # (hours, mins, secs) -> degrees\nhms2rad # (hours, mins, secs) -> radians\nhms2ha  # (hours, mins, secs) -> hour angles the above functions can take a string as input and will automatically parse it (using  parse_dms  or  parse_hms , respectively) before converting."},{"id":547,"pagetitle":"Home","title":"Formatting angles","ref":"/previews/PR43/AstroAngles/stable/#Formatting-angles","content":" Formatting angles Lastly, we have some simple methods for formatting angles into strings, although for more fine-tuned control we recommend using  Printf  or a package like  Format.jl .  format_angle  takes parts (like from  deg2dms  or  rad2hms ) and a delimiter (or collection of 3 delimiters for each value). julia> format_angle(deg2dms(45.0))\n\"45:0:0.0\"\n\njulia> format_angle(deg2hms(-65.0); delim=[\"h\", \"m\", \"s\"])\n\"-4h19m59.999999999998934s\""},{"id":548,"pagetitle":"Home","title":"Example: reading coordinates from a table","ref":"/previews/PR43/AstroAngles/stable/#Example:-reading-coordinates-from-a-table","content":" Example: reading coordinates from a table Here's an example of reading sky coordinates from a CSV formatted target list and converting them to degrees: julia> using AstroAngles, CSV, DataFrames\n\njulia> table = CSV.File(\"target_list.csv\") |> DataFrame;\n\njulia> [table.ra table.dec]\n203×2 Matrix{String}:\n \"00 05 01.42\"  \"40 03 35.82\"\n \"00 05 07.52\"  \"73 13 11.34\"\n \"00 36 01.40\"  \"-11 12 13.00\"\n[...]\n\njulia> ra_d = @. hms2deg(table.ra)\n203-element Vector{Float64}:\n   1.2559166666666666\n   1.2813333333333332\n   9.005833333333333\n[...]\n\njulia> dec_d = @. dms2deg(table.dec)\n203-element Vector{Float64}:\n  40.05995\n  73.21981666666667\n -11.203611111111112\n[...]"},{"id":549,"pagetitle":"Home","title":"Contributing/Support","ref":"/previews/PR43/AstroAngles/stable/#Contributing/Support","content":" Contributing/Support To contribute, feel free to open a  pull request . If you run into problems, please open an  issue . To discuss ideas, usage, or to plan contributions, open a new  discussion ."},{"id":550,"pagetitle":"Home","title":"License","ref":"/previews/PR43/AstroAngles/stable/#License","content":" License This code is MIT licensed. For more information, see the LICENSE file in the AstroAngles.jl repository."},{"id":553,"pagetitle":"API Reference","title":"API Reference","ref":"/previews/PR43/AstroAngles/stable/api/#API-Reference","content":" API Reference"},{"id":554,"pagetitle":"API Reference","title":"AstroAngles.deg2dms","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.deg2dms-Tuple{Any}","content":" AstroAngles.deg2dms  —  Method deg2dms(angle) Convert degrees to (degrees, arcminutes, arcseconds) tuple source"},{"id":555,"pagetitle":"API Reference","title":"AstroAngles.deg2ha","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.deg2ha-Tuple{Any}","content":" AstroAngles.deg2ha  —  Method deg2ha(angle) Convert degrees to hour angles source"},{"id":556,"pagetitle":"API Reference","title":"AstroAngles.deg2hms","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.deg2hms-Tuple{Any}","content":" AstroAngles.deg2hms  —  Method deg2hms(angle) Convert degrees to (hours, minutes, seconds) tuple source"},{"id":557,"pagetitle":"API Reference","title":"AstroAngles.dms2deg","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.dms2deg-Tuple{Any, Any, Any}","content":" AstroAngles.dms2deg  —  Method dms2deg(degrees, arcmin, arcsec)\ndms2deg(parts)\ndms2deg(input::AbstractString) Convert (degrees, arcminutes, arcseconds) tuple to degrees. If a string is given, will parse with  parse_dms  first. If an angle is input will treat as a no-op. source"},{"id":558,"pagetitle":"API Reference","title":"AstroAngles.dms2ha","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.dms2ha-Tuple{Any, Any, Any}","content":" AstroAngles.dms2ha  —  Method dms2ha(degrees, arcmin, arcsec)\ndms2ha(parts)\ndms2ha(input::AbstractString) Convert (degrees, arcminutes, arcseconds) tuple to hour angles. If a string is given, will parse with  parse_dms  first. If an angle is input will treat as a no-op. source"},{"id":559,"pagetitle":"API Reference","title":"AstroAngles.dms2rad","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.dms2rad-Tuple{Any, Any, Any}","content":" AstroAngles.dms2rad  —  Method dms2rad(degrees, arcmin, arcsec)\ndms2rad(parts)\ndms2rad(input::AbstractString) Convert (degrees, arcminutes, arcseconds) tuple to radians. If a string is given, will parse with  parse_dms  first. If an angle is input will treat as a no-op. source"},{"id":560,"pagetitle":"API Reference","title":"AstroAngles.format_angle","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.format_angle-Tuple{Any}","content":" AstroAngles.format_angle  —  Method format_angle(parts; delim=':') Given the  (whole, minutes, seconds)  parts of an angle, will format into a string with the given delimiter(s). These parts can be generated by the  xxx2dms  and  xxx2hms  methods, for sexagesimal and  hour:minute:second  outputs. Multiple delimiters can be given in a tuple or vector placed after their respective values. For more control over formatting, consider using  Printf  or a package like  Format.jl . Examples julia> ang = 45.0; # degrees\n\njulia> format_angle(deg2dms(ang))\n\"45:0:0.0\"\n\njulia> format_angle(deg2hms(ang))\n\"3:0:0.0\"\n\njulia> format_angle(rad2hms(1.5), delim=[\"h\", \"m\", \"s\"])\n\"5h43m46.48062470963538s\" See also deg2dms ,  deg2hms ,  rad2dms ,  rad2hms ,  ha2dms ,  ha2hms source"},{"id":561,"pagetitle":"API Reference","title":"AstroAngles.ha2deg","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.ha2deg-Tuple{Any}","content":" AstroAngles.ha2deg  —  Method ha2deg(angle) Convert hour angles to degrees source"},{"id":562,"pagetitle":"API Reference","title":"AstroAngles.ha2dms","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.ha2dms-Tuple{Any}","content":" AstroAngles.ha2dms  —  Method ha2dms(angle) Convert hour angles to (degrees, arcminutes, arcseconds) tuple source"},{"id":563,"pagetitle":"API Reference","title":"AstroAngles.ha2hms","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.ha2hms-Tuple{Any}","content":" AstroAngles.ha2hms  —  Method ha2hms(angle) Convert hour angles to (hours, minutes, seconds) tuple source"},{"id":564,"pagetitle":"API Reference","title":"AstroAngles.ha2rad","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.ha2rad-Tuple{Any}","content":" AstroAngles.ha2rad  —  Method ha2rad(angle) Convert hour angles to radians source"},{"id":565,"pagetitle":"API Reference","title":"AstroAngles.hms2deg","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.hms2deg-Tuple{Any, Any, Any}","content":" AstroAngles.hms2deg  —  Method hms2deg(hours, mins, secs)\nhms2deg(parts)\nhms2deg(input::AbstractString) Convert (hours, minutes, seconds) tuple to degrees. If a string is given, will parse with  parse_hms  first. If an angle is input will treat as a no-op. source"},{"id":566,"pagetitle":"API Reference","title":"AstroAngles.hms2ha","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.hms2ha-Tuple{Any, Any, Any}","content":" AstroAngles.hms2ha  —  Method hms2ha(hours, mins, secs)\nhms2ha(parts)\nhms2ha(input::AbstractString) Convert (hours, minutes, seconds) tuple to hour angles. If a string is given, will parse with  parse_hms  first. If an angle is input will treat as a no-op. source"},{"id":567,"pagetitle":"API Reference","title":"AstroAngles.hms2rad","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.hms2rad-Tuple{Any, Any, Any}","content":" AstroAngles.hms2rad  —  Method hms2rad(hours, mins, secs)\nhms2rad(parts)\nhms2rad(input::AbstractString) Convert (hours, minutes, seconds) tuple to radians. If a string is given, will parse with  parse_hms  first. If an angle is input will treat as a no-op. source"},{"id":568,"pagetitle":"API Reference","title":"AstroAngles.parse_dms","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.parse_dms-Tuple{Any}","content":" AstroAngles.parse_dms  —  Method parse_dms(input) Parses a string input in \"deg:arcmin:arcsec\" format to the tuple  (degrees, arcminutes, arcseconds) . The following delimiters will all work and can be mixed together (the last delimiter is optional): \"[+-]xx[°d: ]xx['′m: ]xx[\\\"″s][NESW]\" if the direction is provided, \"S\" and \"E\" are considered negative (and \"-1:0:0S\" is 1 degree North) source"},{"id":569,"pagetitle":"API Reference","title":"AstroAngles.parse_hms","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.parse_hms-Tuple{Any}","content":" AstroAngles.parse_hms  —  Method parse_hms(input) Parses a string input in \"ha:min:sec\" format to the tuple  (hours, minutes, seconds) . The following delimiters will all work and can be mixed together (the last delimiter is optional): \"[+-]xx[h ]xx['′m: ]xx[\\\"″s][EW]\" if the direction is provided, \"S\" and \"E\" are considered negative (and \"-1:0:0W\" is 1 degree East) source"},{"id":570,"pagetitle":"API Reference","title":"AstroAngles.rad2dms","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.rad2dms-Tuple{Any}","content":" AstroAngles.rad2dms  —  Method rad2dms(angle) Convert radians to (degrees, arcminutes, arcseconds) tuple source"},{"id":571,"pagetitle":"API Reference","title":"AstroAngles.rad2ha","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.rad2ha-Tuple{Any}","content":" AstroAngles.rad2ha  —  Method rad2ha(angle) Convert radians to hour angles source"},{"id":572,"pagetitle":"API Reference","title":"AstroAngles.rad2hms","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.rad2hms-Tuple{Any}","content":" AstroAngles.rad2hms  —  Method rad2hms(angle) Convert radians to (hours, minutes, seconds) tuple source"},{"id":573,"pagetitle":"API Reference","title":"AstroAngles.@dms_str","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.@dms_str","content":" AstroAngles.@dms_str  —  Macro @dms_str Parse a string in  \"deg:arcmin:arcsec\"  format directly to an angle. By default, it will be parsed as radians, but the angle can be chosen by adding a flag to the end of the string dms\"...\"rad  -> radians (default) dms\"...\"deg  -> degrees dms\"...\"ha  -> hour angles Examples julia> dms\"12:17:25.3\"\n0.21450726764795752\n\njulia> dms\"12:17:25.3\"rad # default\n0.21450726764795752\n\njulia> dms\"12:17:25.3\"deg\n12.29036111111111\n\njulia> dms\"12:17:25.3\"ha\n0.8193574074074074 See also parse_dms source"},{"id":574,"pagetitle":"API Reference","title":"AstroAngles.@hms_str","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.@hms_str","content":" AstroAngles.@hms_str  —  Macro @hms_str Parse a string in  \"ha:min:sec\"  format directly to an angle. By default, it will be parsed as radians, but the angle can be chosen by adding a flag to the end of the string hms\"...\"rad  -> radians (default) hms\"...\"deg  -> degrees hms\"...\"ha  -> hour angles Examples julia> hms\"12:17:25.3\"\n3.2176090147193626\n\njulia> hms\"12:17:25.3\"rad # default\n3.2176090147193626\n\njulia> hms\"12:17:25.3\"deg\n184.35541666666666\n\njulia> hms\"12:17:25.3\"ha\n12.29036111111111 See also parse_hms source"},{"id":577,"pagetitle":"Home","title":"AstroTime","ref":"/previews/PR43/AstroTime/stable/#AstroTime","content":" AstroTime Astronomical time keeping in Julia AstroTime.jl provides a high-precision, time-scale aware,  DateTime -like data type which supports all commonly used astronomical time scales."},{"id":578,"pagetitle":"Home","title":"Installation","ref":"/previews/PR43/AstroTime/stable/#Installation","content":" Installation The package can be installed through Julia's package manager: julia> import Pkg; Pkg.add(\"AstroTime\")"},{"id":579,"pagetitle":"Home","title":"Quickstart","ref":"/previews/PR43/AstroTime/stable/#Quickstart","content":" Quickstart # Create an Epoch based on the TT (Terrestial Time) scale\ntt = TTEpoch(\"2018-01-01T12:00:00\")\n\n# Transform to TAI (International Atomic Time)\ntai = TAIEpoch(tt)\n\n# Transform to TDB (Barycentric Dynamical Time)\ntdb = TDBEpoch(tai)\n\n# Shift an Epoch by one day\nanother_day = tt + 1days"},{"id":580,"pagetitle":"Home","title":"Next Steps","ref":"/previews/PR43/AstroTime/stable/#Next-Steps","content":" Next Steps Follow the  Tutorial  to get an in-depth look at AstroTime.jl's functionality."},{"id":583,"pagetitle":"Epochs","title":"Epochs","ref":"/previews/PR43/AstroTime/stable/api/epochs/#Epochs","content":" Epochs"},{"id":584,"pagetitle":"Epochs","title":"AstroTime.Epochs.Epoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.Epoch","content":" AstroTime.Epochs.Epoch  —  Type Epoch(str[, format]) Construct an  Epoch  from a string  str . Optionally a  format  definition can be passed as a  DateFormat  object or as a string. In addition to the character codes supported by  DateFormat  the character code  D  is supported which is parsed as \"day of year\" (see the example below) and the character code  t  which is parsed as the time scale.  The default format is  yyyy-mm-ddTHH:MM:SS.sss ttt . Note:  Please be aware that this constructor requires that the time scale is part of  str , e.g.  2018-02-06T00:00 TAI . Otherwise use an explicit constructor, e.g.  Epoch{TAI} . Example julia> Epoch(\"2018-02-06T20:45:00.0 TAI\")\n2018-02-06T20:45:00.000 TAI\n\njulia> Epoch(\"2018-037T00:00 TAI\", \"yyyy-DDDTHH:MM ttt\")\n2018-02-06T00:00:00.000 TAI source"},{"id":585,"pagetitle":"Epochs","title":"AstroTime.Epochs.Epoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.Epoch-Union{Tuple{AbstractString}, Tuple{S}, Tuple{AbstractString, Dates.DateFormat}} where S","content":" AstroTime.Epochs.Epoch  —  Method Epoch{S}(str[, format]) where S Construct an  Epoch  with time scale  S  from a string  str . Optionally a  format  definition can be passed as a  DateFormat  object or as a string. In addition to the character codes supported by  DateFormat  the code  D  can be used which is parsed as \"day of year\" (see the example below).  The default format is  yyyy-mm-ddTHH:MM:SS.sss . Example julia> Epoch{InternationalAtomicTime}(\"2018-02-06T20:45:00.0\")\n2018-02-06T20:45:00.000 TAI\n\njulia> Epoch{InternationalAtomicTime}(\"February 6, 2018\", \"U d, y\")\n2018-02-06T00:00:00.000 TAI\n\njulia> Epoch{InternationalAtomicTime}(\"2018-037T00:00\", \"yyyy-DDDTHH:MM\")\n2018-02-06T00:00:00.000 TAI source"},{"id":586,"pagetitle":"Epochs","title":"AstroTime.Epochs.Epoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.Epoch-Union{Tuple{Epoch{S1, T} where T}, Tuple{S2}, Tuple{S1}} where {S1<:TimeScale, S2<:TimeScale}","content":" AstroTime.Epochs.Epoch  —  Method Epoch{S2}(ep::Epoch{S1}) where {S1, S2} Convert  ep , an  Epoch  with time scale  S1 , to an  Epoch  with time scale  S2 . Examples julia> ep = TTEpoch(2000,1,1)\n2000-01-01T00:00:00.000 TT\n\njulia> TAIEpoch(ep)\n1999-12-31T23:59:27.816 TAI source"},{"id":587,"pagetitle":"Epochs","title":"AstroTime.Epochs.Epoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.Epoch-Union{Tuple{Int64, Int64, Int64}, NTuple{4, Int64}, NTuple{5, Int64}, Tuple{S}, Tuple{Int64, Int64, Int64, Int64, Int64, Float64, Vararg{Any, N} where N}} where S","content":" AstroTime.Epochs.Epoch  —  Method Epoch{S}(year, month, day, hour=0, minute=0, second=0.0) where S Construct an  Epoch  with time scale  S  from date and time components. Example julia> Epoch{InternationalAtomicTime}(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TAI\n\njulia> Epoch{InternationalAtomicTime}(2018, 2, 6)\n2018-02-06T00:00:00.000 TAI source"},{"id":588,"pagetitle":"Epochs","title":"AstroTime.Epochs.Epoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.Epoch-Union{Tuple{S2}, Tuple{S1}, Tuple{Any, Epoch{S1, T} where T}} where {S1<:TimeScale, S2<:TimeScale}","content":" AstroTime.Epochs.Epoch  —  Method Epoch{S}(Δtai, ep::TAIEpoch) where S Convert  ep , a  TAIEpoch , to an  Epoch  with time scale  S  by overriding the offset between  S2  and  TAI  with  Δtai . Examples julia> ep = TAIEpoch(2000,1,1)\n2000-01-01T00:00:00.000 TAI\n\njulia> TTEpoch(32.184, ep)\n2000-01-01T00:00:32.184 TT source"},{"id":589,"pagetitle":"Epochs","title":"AstroTime.Epochs.Epoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.Epoch-Union{Tuple{S2}, Tuple{S1}, Tuple{Epoch{S1, T} where T, S2}} where {S1<:TimeScale, S2<:TimeScale}","content":" AstroTime.Epochs.Epoch  —  Method Epoch(ep::Epoch{S1}, scale::S2) where {S1, S2} Convert  ep , an  Epoch  with time scale  S1 , to an  Epoch  with time scale  S2 . Examples julia> ep = TTEpoch(2000,1,1)\n2000-01-01T00:00:00.000 TT\n\njulia> Epoch(ep, TAI)\n1999-12-31T23:59:27.816 TAI source"},{"id":590,"pagetitle":"Epochs","title":"AstroTime.Epochs.Epoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.Epoch-Union{Tuple{T}, Tuple{S}, Tuple{T, T, Vararg{Any, N} where N}} where {S, T<:AstroPeriod}","content":" AstroTime.Epochs.Epoch  —  Method Epoch{S}(jd1::T, jd2::T=zero(T); origin=:j2000) where {S, T<:AstroPeriod} Construct an  Epoch  with time scale  S  from a Julian date (optionally split into  jd1  and  jd2 ).  origin  determines the variant of Julian date that is used. Possible values are: :j2000 : J2000 Julian date, starts at  2000-01-01T12:00 :julian : Julian date, starts at  -4712-01-01T12:00 :modified_julian : Modified Julian date, starts at  1858-11-17T00:00 Examples julia> Epoch{InternationalAtomicTime}(0.0days, 0.5days)\n2000-01-02T00:00:00.000 TAI\n\njulia> Epoch{InternationalAtomicTime}(2.451545e6days, origin=:julian)\n2000-01-01T12:00:00.000 TAI source"},{"id":591,"pagetitle":"Epochs","title":"AstroTime.Epochs.TAIEpoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.TAIEpoch-Tuple{AbstractString}","content":" AstroTime.Epochs.TAIEpoch  —  Method TAIEpoch(str[, format]) Construct a TAIEpoch from a string  str . Optionally a  format  definition can be passed as a  DateFormat  object or as a string. In addition to the character codes supported by  DateFormat  the code  D  is supported which is parsed as \"day of year\" (see the example below). The default format is  yyyy-mm-ddTHH:MM:SS.sss . Example julia> TAIEpoch(\"2018-02-06T20:45:00.0\")\n2018-02-06T20:45:00.000 TAI\n\njulia> TAIEpoch(\"February 6, 2018\", \"U d, y\")\n2018-02-06T00:00:00.000 TAI\n\njulia> TAIEpoch(\"2018-37T00:00\", \"yyyy-DDDTHH:MM\")\n2018-02-06T00:00:00.000 TAI source"},{"id":592,"pagetitle":"Epochs","title":"AstroTime.Epochs.TAIEpoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.TAIEpoch-Tuple{Int64, Int64, Int64}","content":" AstroTime.Epochs.TAIEpoch  —  Method TAIEpoch(year, month, day, hour=0, minute=0, second=0.0) Construct a TAIEpoch from date and time components. Example julia> TAIEpoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TAI\n\njulia> TAIEpoch(2018, 2, 6)\n2018-02-06T00:00:00.000 TAI source"},{"id":593,"pagetitle":"Epochs","title":"AstroTime.Epochs.TAIEpoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.TAIEpoch-Tuple{Number, Number}","content":" AstroTime.Epochs.TAIEpoch  —  Method TAIEpoch(jd1::T, jd2::T=zero(T); origin=:j2000) where T<:AstroPeriod Construct a TAIEpoch from a Julian date (optionally split into  jd1  and  jd2 ).  origin  determines the variant of Julian date that is used. Possible values are: :j2000 : J2000 Julian date, starts at  2000-01-01T12:00 :julian : Julian date, starts at  -4712-01-01T12:00 :modified_julian : Modified Julian date, starts at  1858-11-17T00:00 Examples julia> TAIEpoch(0.0days, 0.5days)\n2000-01-02T00:00:00.000 TAI\n\njulia> TAIEpoch(2.451545e6days, origin=:julian)\n2000-01-01T12:00:00.000 TAI source"},{"id":594,"pagetitle":"Epochs","title":"AstroTime.Epochs.TCBEpoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.TCBEpoch-Tuple{AbstractString}","content":" AstroTime.Epochs.TCBEpoch  —  Method TCBEpoch(str[, format]) Construct a TCBEpoch from a string  str . Optionally a  format  definition can be passed as a  DateFormat  object or as a string. In addition to the character codes supported by  DateFormat  the code  D  is supported which is parsed as \"day of year\" (see the example below). The default format is  yyyy-mm-ddTHH:MM:SS.sss . Example julia> TCBEpoch(\"2018-02-06T20:45:00.0\")\n2018-02-06T20:45:00.000 TCB\n\njulia> TCBEpoch(\"February 6, 2018\", \"U d, y\")\n2018-02-06T00:00:00.000 TCB\n\njulia> TCBEpoch(\"2018-37T00:00\", \"yyyy-DDDTHH:MM\")\n2018-02-06T00:00:00.000 TCB source"},{"id":595,"pagetitle":"Epochs","title":"AstroTime.Epochs.TCBEpoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.TCBEpoch-Tuple{Int64, Int64, Int64}","content":" AstroTime.Epochs.TCBEpoch  —  Method TCBEpoch(year, month, day, hour=0, minute=0, second=0.0) Construct a TCBEpoch from date and time components. Example julia> TCBEpoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TCB\n\njulia> TCBEpoch(2018, 2, 6)\n2018-02-06T00:00:00.000 TCB source"},{"id":596,"pagetitle":"Epochs","title":"AstroTime.Epochs.TCBEpoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.TCBEpoch-Tuple{Number, Number}","content":" AstroTime.Epochs.TCBEpoch  —  Method TCBEpoch(jd1::T, jd2::T=zero(T); origin=:j2000) where T<:AstroPeriod Construct a TCBEpoch from a Julian date (optionally split into  jd1  and  jd2 ).  origin  determines the variant of Julian date that is used. Possible values are: :j2000 : J2000 Julian date, starts at  2000-01-01T12:00 :julian : Julian date, starts at  -4712-01-01T12:00 :modified_julian : Modified Julian date, starts at  1858-11-17T00:00 Examples julia> TCBEpoch(0.0days, 0.5days)\n2000-01-02T00:00:00.000 TCB\n\njulia> TCBEpoch(2.451545e6days, origin=:julian)\n2000-01-01T12:00:00.000 TCB source"},{"id":597,"pagetitle":"Epochs","title":"AstroTime.Epochs.TCGEpoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.TCGEpoch-Tuple{AbstractString}","content":" AstroTime.Epochs.TCGEpoch  —  Method TCGEpoch(str[, format]) Construct a TCGEpoch from a string  str . Optionally a  format  definition can be passed as a  DateFormat  object or as a string. In addition to the character codes supported by  DateFormat  the code  D  is supported which is parsed as \"day of year\" (see the example below). The default format is  yyyy-mm-ddTHH:MM:SS.sss . Example julia> TCGEpoch(\"2018-02-06T20:45:00.0\")\n2018-02-06T20:45:00.000 TCG\n\njulia> TCGEpoch(\"February 6, 2018\", \"U d, y\")\n2018-02-06T00:00:00.000 TCG\n\njulia> TCGEpoch(\"2018-37T00:00\", \"yyyy-DDDTHH:MM\")\n2018-02-06T00:00:00.000 TCG source"},{"id":598,"pagetitle":"Epochs","title":"AstroTime.Epochs.TCGEpoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.TCGEpoch-Tuple{Int64, Int64, Int64}","content":" AstroTime.Epochs.TCGEpoch  —  Method TCGEpoch(year, month, day, hour=0, minute=0, second=0.0) Construct a TCGEpoch from date and time components. Example julia> TCGEpoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TCG\n\njulia> TCGEpoch(2018, 2, 6)\n2018-02-06T00:00:00.000 TCG source"},{"id":599,"pagetitle":"Epochs","title":"AstroTime.Epochs.TCGEpoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.TCGEpoch-Tuple{Number, Number}","content":" AstroTime.Epochs.TCGEpoch  —  Method TCGEpoch(jd1::T, jd2::T=zero(T); origin=:j2000) where T<:AstroPeriod Construct a TCGEpoch from a Julian date (optionally split into  jd1  and  jd2 ).  origin  determines the variant of Julian date that is used. Possible values are: :j2000 : J2000 Julian date, starts at  2000-01-01T12:00 :julian : Julian date, starts at  -4712-01-01T12:00 :modified_julian : Modified Julian date, starts at  1858-11-17T00:00 Examples julia> TCGEpoch(0.0days, 0.5days)\n2000-01-02T00:00:00.000 TCG\n\njulia> TCGEpoch(2.451545e6days, origin=:julian)\n2000-01-01T12:00:00.000 TCG source"},{"id":600,"pagetitle":"Epochs","title":"AstroTime.Epochs.TDBEpoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.TDBEpoch-Tuple{AbstractString}","content":" AstroTime.Epochs.TDBEpoch  —  Method TDBEpoch(str[, format]) Construct a TDBEpoch from a string  str . Optionally a  format  definition can be passed as a  DateFormat  object or as a string. In addition to the character codes supported by  DateFormat  the code  D  is supported which is parsed as \"day of year\" (see the example below). The default format is  yyyy-mm-ddTHH:MM:SS.sss . Example julia> TDBEpoch(\"2018-02-06T20:45:00.0\")\n2018-02-06T20:45:00.000 TDB\n\njulia> TDBEpoch(\"February 6, 2018\", \"U d, y\")\n2018-02-06T00:00:00.000 TDB\n\njulia> TDBEpoch(\"2018-37T00:00\", \"yyyy-DDDTHH:MM\")\n2018-02-06T00:00:00.000 TDB source"},{"id":601,"pagetitle":"Epochs","title":"AstroTime.Epochs.TDBEpoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.TDBEpoch-Tuple{Int64, Int64, Int64}","content":" AstroTime.Epochs.TDBEpoch  —  Method TDBEpoch(year, month, day, hour=0, minute=0, second=0.0) Construct a TDBEpoch from date and time components. Example julia> TDBEpoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TDB\n\njulia> TDBEpoch(2018, 2, 6)\n2018-02-06T00:00:00.000 TDB source"},{"id":602,"pagetitle":"Epochs","title":"AstroTime.Epochs.TDBEpoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.TDBEpoch-Tuple{Number, Number}","content":" AstroTime.Epochs.TDBEpoch  —  Method TDBEpoch(jd1::T, jd2::T=zero(T); origin=:j2000) where T<:AstroPeriod Construct a TDBEpoch from a Julian date (optionally split into  jd1  and  jd2 ).  origin  determines the variant of Julian date that is used. Possible values are: :j2000 : J2000 Julian date, starts at  2000-01-01T12:00 :julian : Julian date, starts at  -4712-01-01T12:00 :modified_julian : Modified Julian date, starts at  1858-11-17T00:00 Examples julia> TDBEpoch(0.0days, 0.5days)\n2000-01-02T00:00:00.000 TDB\n\njulia> TDBEpoch(2.451545e6days, origin=:julian)\n2000-01-01T12:00:00.000 TDB source"},{"id":603,"pagetitle":"Epochs","title":"AstroTime.Epochs.TTEpoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.TTEpoch-Tuple{AbstractString}","content":" AstroTime.Epochs.TTEpoch  —  Method TTEpoch(str[, format]) Construct a TTEpoch from a string  str . Optionally a  format  definition can be passed as a  DateFormat  object or as a string. In addition to the character codes supported by  DateFormat  the code  D  is supported which is parsed as \"day of year\" (see the example below). The default format is  yyyy-mm-ddTHH:MM:SS.sss . Example julia> TTEpoch(\"2018-02-06T20:45:00.0\")\n2018-02-06T20:45:00.000 TT\n\njulia> TTEpoch(\"February 6, 2018\", \"U d, y\")\n2018-02-06T00:00:00.000 TT\n\njulia> TTEpoch(\"2018-37T00:00\", \"yyyy-DDDTHH:MM\")\n2018-02-06T00:00:00.000 TT source"},{"id":604,"pagetitle":"Epochs","title":"AstroTime.Epochs.TTEpoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.TTEpoch-Tuple{Int64, Int64, Int64}","content":" AstroTime.Epochs.TTEpoch  —  Method TTEpoch(year, month, day, hour=0, minute=0, second=0.0) Construct a TTEpoch from date and time components. Example julia> TTEpoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TT\n\njulia> TTEpoch(2018, 2, 6)\n2018-02-06T00:00:00.000 TT source"},{"id":605,"pagetitle":"Epochs","title":"AstroTime.Epochs.TTEpoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.TTEpoch-Tuple{Number, Number}","content":" AstroTime.Epochs.TTEpoch  —  Method TTEpoch(jd1::T, jd2::T=zero(T); origin=:j2000) where T<:AstroPeriod Construct a TTEpoch from a Julian date (optionally split into  jd1  and  jd2 ).  origin  determines the variant of Julian date that is used. Possible values are: :j2000 : J2000 Julian date, starts at  2000-01-01T12:00 :julian : Julian date, starts at  -4712-01-01T12:00 :modified_julian : Modified Julian date, starts at  1858-11-17T00:00 Examples julia> TTEpoch(0.0days, 0.5days)\n2000-01-02T00:00:00.000 TT\n\njulia> TTEpoch(2.451545e6days, origin=:julian)\n2000-01-01T12:00:00.000 TT source"},{"id":606,"pagetitle":"Epochs","title":"AstroTime.Epochs.UT1Epoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.UT1Epoch-Tuple{AbstractString}","content":" AstroTime.Epochs.UT1Epoch  —  Method UT1Epoch(str[, format]) Construct a UT1Epoch from a string  str . Optionally a  format  definition can be passed as a  DateFormat  object or as a string. In addition to the character codes supported by  DateFormat  the code  D  is supported which is parsed as \"day of year\" (see the example below). The default format is  yyyy-mm-ddTHH:MM:SS.sss . Example julia> UT1Epoch(\"2018-02-06T20:45:00.0\")\n2018-02-06T20:45:00.000 UT1\n\njulia> UT1Epoch(\"February 6, 2018\", \"U d, y\")\n2018-02-06T00:00:00.000 UT1\n\njulia> UT1Epoch(\"2018-37T00:00\", \"yyyy-DDDTHH:MM\")\n2018-02-06T00:00:00.000 UT1 source"},{"id":607,"pagetitle":"Epochs","title":"AstroTime.Epochs.UT1Epoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.UT1Epoch-Tuple{Int64, Int64, Int64}","content":" AstroTime.Epochs.UT1Epoch  —  Method UT1Epoch(year, month, day, hour=0, minute=0, second=0.0) Construct a UT1Epoch from date and time components. Example julia> UT1Epoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 UT1\n\njulia> UT1Epoch(2018, 2, 6)\n2018-02-06T00:00:00.000 UT1 source"},{"id":608,"pagetitle":"Epochs","title":"AstroTime.Epochs.UT1Epoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.UT1Epoch-Tuple{Number, Number}","content":" AstroTime.Epochs.UT1Epoch  —  Method UT1Epoch(jd1::T, jd2::T=zero(T); origin=:j2000) where T<:AstroPeriod Construct a UT1Epoch from a Julian date (optionally split into  jd1  and  jd2 ).  origin  determines the variant of Julian date that is used. Possible values are: :j2000 : J2000 Julian date, starts at  2000-01-01T12:00 :julian : Julian date, starts at  -4712-01-01T12:00 :modified_julian : Modified Julian date, starts at  1858-11-17T00:00 Examples julia> UT1Epoch(0.0days, 0.5days)\n2000-01-02T00:00:00.000 UT1\n\njulia> UT1Epoch(2.451545e6days, origin=:julian)\n2000-01-01T12:00:00.000 UT1 source"},{"id":609,"pagetitle":"Epochs","title":"AstroTime.AstroDates.fractionofday","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.AstroDates.fractionofday-Tuple{Epoch}","content":" AstroTime.AstroDates.fractionofday  —  Method fractionofday(ep::Epoch) Get the time of the day of the epoch  ep  as a fraction. source"},{"id":610,"pagetitle":"Epochs","title":"AstroTime.AstroDates.fractionofsecond","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.AstroDates.fractionofsecond-Tuple{Epoch}","content":" AstroTime.AstroDates.fractionofsecond  —  Method fractionofsecond(ep::Epoch) Get the fraction of the current second of the epoch  ep . source"},{"id":611,"pagetitle":"Epochs","title":"AstroTime.AstroDates.j2000","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.AstroDates.j2000-Tuple{Epoch}","content":" AstroTime.AstroDates.j2000  —  Method j2000(ep) Return the J2000 Julian Date for epoch  ep . Example julia> j2000(TAIEpoch(2000, 1, 1, 12))\n0.0 days source"},{"id":612,"pagetitle":"Epochs","title":"AstroTime.AstroDates.julian","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.AstroDates.julian-Tuple{Epoch}","content":" AstroTime.AstroDates.julian  —  Method julian(ep) Return the Julian Date for epoch  ep . Example julia> julian(TAIEpoch(2000, 1, 1, 12))\n2.451545e6 days source"},{"id":613,"pagetitle":"Epochs","title":"AstroTime.AstroDates.julian_twopart","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.AstroDates.julian_twopart-Tuple{Epoch}","content":" AstroTime.AstroDates.julian_twopart  —  Method julian_twopart(ep) Return the two-part Julian Date for epoch  ep , which is a tuple consisting of the Julian day number and the fraction of the day. Example julia> julian_twopart(TAIEpoch(2000, 1, 2))\n(2.451545e6 days, 0.5 days) source"},{"id":614,"pagetitle":"Epochs","title":"AstroTime.AstroDates.subsecond","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.AstroDates.subsecond-Tuple{Epoch, Any}","content":" AstroTime.AstroDates.subsecond  —  Method subsecond(ep::Epoch, n) Get the number of fractional seconds with the unit  $s * \\frac{1}{10^n}$ , e.g.  subsecond(ep, 3)  for milliseconds, of the epoch  ep .  n  must be divisible by 3. source"},{"id":615,"pagetitle":"Epochs","title":"AstroTime.Epochs.from_utc","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.from_utc","content":" AstroTime.Epochs.from_utc  —  Function from_utc(str::AbstractString, dateformat::Dates.DateFormat; scale=TAI)\nfrom_utc(dt::Dates.DateTime; scale=TAI)\nfrom_utc(year, month, day, hour=0, minute=0, second=0, fraction=0.0; scale=TAI)\nfrom_utc(year, month, day, hour, minute, seconds; scale=TAI) Create an  Epoch  in  scale  based on a UTC timestamp,  Dates.DateTime  or date and time components. Examples julia> from_utc(2016, 12, 31, 23, 59, 60, 0.0)\n2017-01-01T00:00:36.000 TAI\n\njulia> from_utc(2016, 12, 31, 23, 59, 60.0)\n2017-01-01T00:00:36.000 TAI\n\njulia> from_utc(\"2016-12-31T23:59:60.0\")\n2017-01-01T00:00:36.000 TAI\n\njulia> from_utc(\"2016-12-31T23:59:60.0\", scale=TDB)\n2017-01-01T00:01:08.183 TDB source"},{"id":616,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset","content":" AstroTime.Epochs.getoffset  —  Function getoffset(UT1, TAI, second, fraction[, eop]) Return the offset between  UT1  and  TAI  for the current epoch ( second  after J2000 and  fraction ) in seconds. Optionally, a custom Earth orientation data struct  eop  can be provided, see  EarthOrientation.jl . Example julia> getoffset(UT1, TAI, 0, 0.0)\n31.644974965344606 source"},{"id":617,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset","content":" AstroTime.Epochs.getoffset  —  Function getoffset(TAI, UT1, second, fraction[, eop]) Return the offset between  TAI  and  UT1  for the current epoch ( second  after J2000 and  fraction ) in seconds. Optionally, a custom Earth orientation data struct  eop  can be provided, see  EarthOrientation.jl . Example julia> getoffset(TAI, UT1, 0, 0.0)\n-31.644974644349812 source"},{"id":618,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Tuple{BarycentricCoordinateTime, BarycentricDynamicalTime, Any, Any}","content":" AstroTime.Epochs.getoffset  —  Method getoffset(TCB, TDB, second, fraction) Return the linear offset between  TCB  and  TDB  for the current epoch ( second  after J2000 and  fraction ) in seconds. Example julia> getoffset(TCB, TDB, 0, 0.0)\n-11.253721593757295 source"},{"id":619,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Tuple{BarycentricDynamicalTime, BarycentricCoordinateTime, Any, Any}","content":" AstroTime.Epochs.getoffset  —  Method getoffset(TDB, TCB, second, fraction) Return the linear offset between  TDB  and  TCB  for the current epoch ( second  after J2000 and  fraction ) in seconds. Example julia> getoffset(TDB, TCB, 0, 0.0)\n11.253721768248475 source"},{"id":620,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Tuple{BarycentricDynamicalTime, TerrestrialTime, Any, Any, Any, Any, Any}","content":" AstroTime.Epochs.getoffset  —  Method getoffset(TDB, TT, second, fraction[, eop]) Return the offset between  TDB  and  TT  for the current epoch ( second  after J2000 and  fraction ) for an observer on earth in seconds. Arguments second ,  fraction : Current epoch elong : Longitude (east positive, radians) u : Distance from Earth's spin axis (km) v : Distance north of equatorial plane (km) Example julia> getoffset(TDB, TT, 0, 0.0, π, 6371.0, 0.0)\n9.928419814106208e-5 References ERFA source"},{"id":621,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Tuple{BarycentricDynamicalTime, TerrestrialTime, Any, Any}","content":" AstroTime.Epochs.getoffset  —  Method getoffset(TDB, TT, second, fraction[, eop]) Return the offset between  TDB  and  TT  for the current epoch ( second  after J2000 and  fraction ) in seconds. This routine is accurate to ~40 microseconds over the interval 1900-2100. Note An accurate transformation between TDB and TT depends on the trajectory of the observer. For two observers fixed on Earth's surface the quantity TDB-TT can differ by as much as ~4 microseconds. See  here . Example julia> getoffset(TDB, TT, 0, 0.0)\n7.273677616693264e-5 References https://www.cv.nrao.edu/~rfisher/Ephemerides/times.html#TDB Issue #26 source"},{"id":622,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Tuple{GeocentricCoordinateTime, TerrestrialTime, Any, Any}","content":" AstroTime.Epochs.getoffset  —  Method getoffset(TCG, TT, second, fraction) Return the linear offset between  TCG  and  TT  for the current epoch ( second  after J2000 and  fraction ) in seconds. Example julia> getoffset(TCG, TT, 0, 0.0)\n-0.5058332856685995 source"},{"id":623,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Tuple{InternationalAtomicTime, TerrestrialTime, Vararg{Any, N} where N}","content":" AstroTime.Epochs.getoffset  —  Method getoffset(TAI, TT, args...) Return the fixed offset between  TAI  and  TT  in seconds. Example julia> getoffset(TAI, TT)\n32.184 source"},{"id":624,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Tuple{TerrestrialTime, BarycentricDynamicalTime, Any, Any, Any, Any, Any}","content":" AstroTime.Epochs.getoffset  —  Method getoffset(TT, TDB, second, fraction[, eop]) Return the offset between  TT  and  TDB  for the current epoch ( second  after J2000 and  fraction ) for an observer on earth in seconds. Arguments second ,  fraction : Current epoch elong : Longitude (east positive, radians) u : Distance from Earth's spin axis (km) v : Distance north of equatorial plane (km) Example julia> getoffset(TT, TDB, 0, 0.0, π, 6371.0, 0.0)\n-9.928419818977206e-5 References ERFA source"},{"id":625,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Tuple{TerrestrialTime, BarycentricDynamicalTime, Any, Any}","content":" AstroTime.Epochs.getoffset  —  Method getoffset(TT, TDB, second, fraction[, eop]) Return the offset between  TT  and  TDB  for the current epoch ( second  after J2000 and  fraction ) in seconds. This routine is accurate to ~40 microseconds over the interval 1900-2100. Note An accurate transformation between TDB and TT depends on the trajectory of the observer. For two observers fixed on Earth's surface the quantity TDB-TT can differ by as much as ~4 microseconds. See  here . Example julia> getoffset(TT, TDB, 0, 0.0)\n-7.273677619130569e-5 References https://www.cv.nrao.edu/~rfisher/Ephemerides/times.html#TDB Issue #26 source"},{"id":626,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Tuple{TerrestrialTime, GeocentricCoordinateTime, Any, Any}","content":" AstroTime.Epochs.getoffset  —  Method getoffset(TT, TCG, second, fraction) Return the linear offset between  TT  and  TCG  for the current epoch ( second  after J2000 and  fraction ) in seconds. Example julia> getoffset(TT, TCG, 0, 0.0)\n0.5058332860211293 source"},{"id":627,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Tuple{TerrestrialTime, InternationalAtomicTime, Vararg{Any, N} where N}","content":" AstroTime.Epochs.getoffset  —  Method getoffset(TT, TAI, args...) Return the fixed offset between  TT  and  TAI  in seconds. Example julia> getoffset(TT, TAI)\n-32.184 source"},{"id":628,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Union{Tuple{S}, Tuple{Epoch{S, T} where T, TimeScale, Vararg{Any, N} where N}} where S<:TimeScale","content":" AstroTime.Epochs.getoffset  —  Method getoffset(ep::Epoch, scale::TimeScale) For a given epoch  ep  return the offset between its time scale and another time  scale  in seconds. Example julia> tai = TAIEpoch(2000, 1, 1)\n2000-01-01T00:00:00.000 TAI\n\njulia> getoffset(tai, TT)\n32.184 source"},{"id":629,"pagetitle":"Epochs","title":"AstroTime.Epochs.julian_period","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.julian_period-Tuple{Epoch}","content":" AstroTime.Epochs.julian_period  —  Method julian_period([T,] ep::Epoch; origin=:j2000, scale=timescale(ep), unit=days) Return the period since Julian Epoch  origin  within the time scale  scale  expressed in  unit  for a given epoch  ep . The result is an  AstroPeriod  object by default. If the type argument  T  is present, the result is converted to  T  instead. Example julia> ep = TAIEpoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TAI\n\njulia> julian_period(ep; scale=TT)\n6611.364955833334 days\n\njulia> julian_period(ep; unit=years)\n18.100929728496464 years\n\njulia> julian_period(Float64, ep)\n6611.364583333333 source"},{"id":630,"pagetitle":"Epochs","title":"AstroTime.Epochs.modified_julian","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.modified_julian-Tuple{Epoch}","content":" AstroTime.Epochs.modified_julian  —  Method modified_julian(ep) Return the Modified Julian Date for epoch  ep . Example julia> modified_julian(TAIEpoch(2000, 1, 1, 12))\n51544.5 days source"},{"id":631,"pagetitle":"Epochs","title":"AstroTime.Epochs.timescale","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.timescale-Tuple{Epoch}","content":" AstroTime.Epochs.timescale  —  Method timescale(ep) Return the time scale of epoch  ep . Example julia> ep = TTEpoch(2000, 1, 1)\n2000-01-01T00:00:00.000 TT\n\njulia> timescale(ep)\nTT source"},{"id":632,"pagetitle":"Epochs","title":"AstroTime.Epochs.to_utc","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.to_utc","content":" AstroTime.Epochs.to_utc  —  Function to_utc(ep)\nto_utc(::Type{DateTime}, ep)\nto_utc(::Type{Dates.DateTime}, ep)\nto_utc(::Type{String}, ep, dateformat=Dates.default_format(DateTime)) Create a UTC timestamp or  Dates.DateTime  from an  Epoch ep . Examples julia> tai = from_utc(Dates.DateTime(2018, 2, 6, 20, 45, 0, 0))\n2018-02-06T20:45:37.000 TAI\n\njulia> to_utc(tai)\n\"2018-02-06T20:45:00.000\"\n\njulia> to_utc(String, tai, Dates.dateformat\"yyyy-mm-dd\")\n\"2018-02-06\"\n\njulia> to_utc(Dates.DateTime, tai)\n2018-02-06T20:45:00 source"},{"id":633,"pagetitle":"Epochs","title":"Base.:-","ref":"/previews/PR43/AstroTime/stable/api/epochs/#Base.:--Union{Tuple{S}, Tuple{Epoch{S, T} where T, Epoch{S, T} where T}} where S<:TimeScale","content":" Base.:-  —  Method -(a::Epoch, b::Epoch) Return the duration between epoch  a  and epoch  b . Examples julia> TAIEpoch(2018, 2, 6, 20, 45, 20.0) - TAIEpoch(2018, 2, 6, 20, 45, 0.0)\n20.0 seconds source"},{"id":634,"pagetitle":"Epochs","title":"Dates.day","ref":"/previews/PR43/AstroTime/stable/api/epochs/#Dates.day-Tuple{Epoch}","content":" Dates.day  —  Method day(ep::Epoch) Get the day of the epoch  ep . source"},{"id":635,"pagetitle":"Epochs","title":"Dates.dayofyear","ref":"/previews/PR43/AstroTime/stable/api/epochs/#Dates.dayofyear-Tuple{Epoch}","content":" Dates.dayofyear  —  Method dayofyear(ep::Epoch) Get the day of the year of the epoch  ep . source"},{"id":636,"pagetitle":"Epochs","title":"Dates.hour","ref":"/previews/PR43/AstroTime/stable/api/epochs/#Dates.hour-Tuple{Epoch}","content":" Dates.hour  —  Method hour(ep::Epoch) Get the hour of the epoch  ep . source"},{"id":637,"pagetitle":"Epochs","title":"Dates.microsecond","ref":"/previews/PR43/AstroTime/stable/api/epochs/#Dates.microsecond-Tuple{Epoch}","content":" Dates.microsecond  —  Method microsecond(ep::Epoch) Get the number of microseconds of the epoch  ep . source"},{"id":638,"pagetitle":"Epochs","title":"Dates.millisecond","ref":"/previews/PR43/AstroTime/stable/api/epochs/#Dates.millisecond-Tuple{Epoch}","content":" Dates.millisecond  —  Method millisecond(ep::Epoch) Get the number of milliseconds of the epoch  ep . source"},{"id":639,"pagetitle":"Epochs","title":"Dates.minute","ref":"/previews/PR43/AstroTime/stable/api/epochs/#Dates.minute-Tuple{Epoch}","content":" Dates.minute  —  Method minute(ep::Epoch) Get the minute of the epoch  ep . source"},{"id":640,"pagetitle":"Epochs","title":"Dates.month","ref":"/previews/PR43/AstroTime/stable/api/epochs/#Dates.month-Tuple{Epoch}","content":" Dates.month  —  Method month(ep::Epoch) Get the month of the epoch  ep . source"},{"id":641,"pagetitle":"Epochs","title":"Dates.nanosecond","ref":"/previews/PR43/AstroTime/stable/api/epochs/#Dates.nanosecond-Tuple{Epoch}","content":" Dates.nanosecond  —  Method nanosecond(ep::Epoch) Get the number of nanoseconds of the epoch  ep . source"},{"id":642,"pagetitle":"Epochs","title":"Dates.now","ref":"/previews/PR43/AstroTime/stable/api/epochs/#Dates.now-Union{Tuple{Type{Epoch{S, T} where T}}, Tuple{S}} where S","content":" Dates.now  —  Method now(::Type{Epoch})\nnow(::Type{Epoch{S}}) where S<:TimeScale Get the current date and time as an  Epoch . The default time scale is TAI. Example julia> now(Epoch)\n2021-04-11T13:20:29.160 TAI\n\njulia> now(TDBEpoch)\n2021-04-11T13:21:21.518 TDB source"},{"id":643,"pagetitle":"Epochs","title":"Dates.second","ref":"/previews/PR43/AstroTime/stable/api/epochs/#Dates.second-Tuple{Any, Epoch}","content":" Dates.second  —  Method second(type, ep::Epoch) Get the second of the epoch  ep  as a  type . source"},{"id":644,"pagetitle":"Epochs","title":"Dates.second","ref":"/previews/PR43/AstroTime/stable/api/epochs/#Dates.second-Tuple{Epoch}","content":" Dates.second  —  Method second(ep::Epoch) -> Int Get the second of the epoch  ep  as an  Int . source"},{"id":645,"pagetitle":"Epochs","title":"Dates.year","ref":"/previews/PR43/AstroTime/stable/api/epochs/#Dates.year-Tuple{Epoch}","content":" Dates.year  —  Method year(ep::Epoch) Get the year of the epoch  ep . source"},{"id":646,"pagetitle":"Epochs","title":"Dates.yearmonthday","ref":"/previews/PR43/AstroTime/stable/api/epochs/#Dates.yearmonthday-Tuple{Epoch}","content":" Dates.yearmonthday  —  Method yearmonthday(ep::Epoch) Get the year, month, and day of the epoch  ep  as a tuple. source"},{"id":647,"pagetitle":"Epochs","title":"AstroTime.AstroDates.DateTime","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.AstroDates.DateTime","content":" AstroTime.AstroDates.DateTime  —  Type DateTime(ep::Epoch) Convert the epoch  ep  to an  AstroDates.DateTime . source"},{"id":648,"pagetitle":"Epochs","title":"AstroTime.AstroDates.Date","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.AstroDates.Date","content":" AstroTime.AstroDates.Date  —  Type Date(ep::Epoch) Get the  Date  of the epoch  ep . source"},{"id":649,"pagetitle":"Epochs","title":"AstroTime.AstroDates.Time","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.AstroDates.Time","content":" AstroTime.AstroDates.Time  —  Type Time(ep::Epoch) Get the  Time  of the epoch  ep . source"},{"id":652,"pagetitle":"Periods","title":"Periods","ref":"/previews/PR43/AstroTime/stable/api/periods/#Periods","content":" Periods"},{"id":653,"pagetitle":"Periods","title":"AstroTime.Periods.AstroPeriod","ref":"/previews/PR43/AstroTime/stable/api/periods/#AstroTime.Periods.AstroPeriod","content":" AstroTime.Periods.AstroPeriod  —  Type AstroPeriod{U, T}(unit, Δt) where {U<:TimeUnit, T} An  AstroPeriod  object represents a time interval of  Δt  with a  TimeUnit  of  unit .  Periods should be constructed via the shorthand syntax shown in the examples below. Examples julia> 3.0seconds\n3.0 seconds\n\njulia> 1.0minutes\n1.0 minutes\n\njulia> 12hours\n12.0 hours\n\njulia> days_per_year = 365\n365\njulia> days_per_year * days\n365.0 days\n\njulia> 10.0years\n10.0 years\n\njulia> 1centuries\n1.0 centuries source"},{"id":654,"pagetitle":"Periods","title":"AstroTime.Periods.TimeUnit","ref":"/previews/PR43/AstroTime/stable/api/periods/#AstroTime.Periods.TimeUnit","content":" AstroTime.Periods.TimeUnit  —  Type All time units are subtypes of the abstract type  TimeUnit . The following time units are defined: Second Minute Hour Day Year Century source"},{"id":655,"pagetitle":"Periods","title":"AstroTime.Periods.unit","ref":"/previews/PR43/AstroTime/stable/api/periods/#AstroTime.Periods.unit-Tuple{AstroPeriod}","content":" AstroTime.Periods.unit  —  Method unit(p::AstroPeriod) Return the unit of the period  p . Examples julia> unit(3.0seconds)\nAstroTime.Periods.Second() source"},{"id":656,"pagetitle":"Periods","title":"AstroTime.Periods.value","ref":"/previews/PR43/AstroTime/stable/api/periods/#AstroTime.Periods.value-Tuple{AstroPeriod}","content":" AstroTime.Periods.value  —  Method value(p::AstroPeriod) Return the unitless value of the period  p . Examples julia> value(3.0seconds)\n3.0 source"},{"id":659,"pagetitle":"Time Scales","title":"Time Scales","ref":"/previews/PR43/AstroTime/stable/api/timescales/#Time-Scales","content":" Time Scales"},{"id":660,"pagetitle":"Time Scales","title":"AstroTime.update","ref":"/previews/PR43/AstroTime/stable/api/timescales/#AstroTime.update","content":" AstroTime.update  —  Function AstroTime.update() Download up-to-date IERS tables from the internet to enable transformations to and from the  UT1  time scale. source"},{"id":661,"pagetitle":"Time Scales","title":"AstroTime.@timescale","ref":"/previews/PR43/AstroTime/stable/api/timescales/#AstroTime.@timescale","content":" AstroTime.@timescale  —  Macro @timescale scale [parent[, oneway]] Define a new time scale and the corresponding  Epoch  type alias. Arguments scale : The name of the time scale parent : The \"parent\" time scale to which it should be linked (optional) oneway : If  true , only the transformation from  parent  to  scale  is   registered (optional, default:  false ) Example julia> @timescale GMT TAI\n\njulia> GMT isa TimeScale\ntrue\n\njulia> GMTEpoch\nEpoch{GMTScale, T} where T\n\njulia> find_path(TT, GMT)\n3-element Vector{TimeScale}:\n TT\n TAI\n GMT source"},{"id":662,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.TAI","ref":"/previews/PR43/AstroTime/stable/api/timescales/#AstroTime.TimeScales.TAI","content":" AstroTime.TimeScales.TAI  —  Constant TAI The singleton instance of the  InternationalAtomicTime  type representing the International Atomic Time (TAI) time scale. References Wikipedia source"},{"id":663,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.TCB","ref":"/previews/PR43/AstroTime/stable/api/timescales/#AstroTime.TimeScales.TCB","content":" AstroTime.TimeScales.TCB  —  Constant TCB The singleton instance of the  BarycentricCoordinateTime  type representing the Barycentric Coordinate Time (TCB) time scale. References Wikipedia source"},{"id":664,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.TCG","ref":"/previews/PR43/AstroTime/stable/api/timescales/#AstroTime.TimeScales.TCG","content":" AstroTime.TimeScales.TCG  —  Constant TCG The singleton instance of the  GeocentricCoordinateTime  type representing the Geocentric Coordinate Time (TCG) time scale. References Wikipedia source"},{"id":665,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.TDB","ref":"/previews/PR43/AstroTime/stable/api/timescales/#AstroTime.TimeScales.TDB","content":" AstroTime.TimeScales.TDB  —  Constant TDB The singleton instance of the  BarycentricDynamicalTime  type representing the Barycentric Dynamical Time (TDB) time scale. References Wikipedia source"},{"id":666,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.TT","ref":"/previews/PR43/AstroTime/stable/api/timescales/#AstroTime.TimeScales.TT","content":" AstroTime.TimeScales.TT  —  Constant TT The singleton instance of the  TerrestrialTime  type representing the Terrestrial Time (TT) time scale. References Wikipedia source"},{"id":667,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.UT1","ref":"/previews/PR43/AstroTime/stable/api/timescales/#AstroTime.TimeScales.UT1","content":" AstroTime.TimeScales.UT1  —  Constant UT1 The singleton instance of the  UniversalTime  type representing the Universal Time (UT1) time scale. References Wikipedia source"},{"id":668,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.BarycentricCoordinateTime","ref":"/previews/PR43/AstroTime/stable/api/timescales/#AstroTime.TimeScales.BarycentricCoordinateTime","content":" AstroTime.TimeScales.BarycentricCoordinateTime  —  Type BarycentricCoordinateTime A type representing the Barycentric Coordinate Time (TCB) time scale. References Wikipedia source"},{"id":669,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.BarycentricDynamicalTime","ref":"/previews/PR43/AstroTime/stable/api/timescales/#AstroTime.TimeScales.BarycentricDynamicalTime","content":" AstroTime.TimeScales.BarycentricDynamicalTime  —  Type BarycentricDynamicalTime A type representing the Barycentric Dynamical Time (TDB) time scale. References Wikipedia source"},{"id":670,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.GeocentricCoordinateTime","ref":"/previews/PR43/AstroTime/stable/api/timescales/#AstroTime.TimeScales.GeocentricCoordinateTime","content":" AstroTime.TimeScales.GeocentricCoordinateTime  —  Type GeocentricCoordinateTime A type representing the Geocentric Coordinate Time (TCG) time scale. References Wikipedia source"},{"id":671,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.InternationalAtomicTime","ref":"/previews/PR43/AstroTime/stable/api/timescales/#AstroTime.TimeScales.InternationalAtomicTime","content":" AstroTime.TimeScales.InternationalAtomicTime  —  Type InternationalAtomicTime A type representing the International Atomic Time (TAI) time scale. References Wikipedia source"},{"id":672,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.TerrestrialTime","ref":"/previews/PR43/AstroTime/stable/api/timescales/#AstroTime.TimeScales.TerrestrialTime","content":" AstroTime.TimeScales.TerrestrialTime  —  Type TerrestrialTime A type representing the Terrestrial Time (TT) time scale. References Wikipedia source"},{"id":673,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.TimeScale","ref":"/previews/PR43/AstroTime/stable/api/timescales/#AstroTime.TimeScales.TimeScale","content":" AstroTime.TimeScales.TimeScale  —  Type All timescales are subtypes of the abstract type  TimeScale . The following timescales are defined: UT1  — Universal Time TAI  — International Atomic Time TT  — Terrestrial Time TCG  — Geocentric Coordinate Time TCB  — Barycentric Coordinate Time TDB  — Barycentric Dynamical Time source"},{"id":674,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.UniversalTime","ref":"/previews/PR43/AstroTime/stable/api/timescales/#AstroTime.TimeScales.UniversalTime","content":" AstroTime.TimeScales.UniversalTime  —  Type UniversalTime A type representing the Universal Time (UT1) time scale. References Wikipedia source"},{"id":679,"pagetitle":"Tutorial","title":"Tutorial","ref":"/previews/PR43/AstroTime/stable/tutorial/#Tutorial","content":" Tutorial This tutorial will walk you through the features and functionality of AstroTime.jl. Everything in this package revolves around the  Epoch  data type.  Epochs  are a high-precision, time-scale aware version of the  DateTime  type from Julia's standard library. This means that while  DateTime  timestamps are always assumed to be based on Universal Time (UT),  Epochs  can be created in several pre-defined time scales or custom user-defined time scales."},{"id":680,"pagetitle":"Tutorial","title":"Creating Epochs","ref":"/previews/PR43/AstroTime/stable/tutorial/#Creating-Epochs","content":" Creating Epochs You construct  Epoch  instances similar to  DateTime  instances, for example by using date and time components. The main difference is that you need to supply the time scale to be used. Out of the box, the following time scales are defined: TAI :  International Atomic Time UT1 :  Universal Time [1] TT :  Terrestrial Time TCG :  Geocentric Coordinate Time TCB :  Barycentric Coordinate Time TDB :  Barycentric Dynamical Time Conspicuously missing from this list is  Coordinated Universal Time (UTC) . While AstroTime.jl does support UTC, it requires special treatment due to the discontinuities in the time scale from the introduction of leap seconds. See  UTC and Leap Seconds  for more details. using AstroTime\n\nep = Epoch{InternationalAtomicTime}(2018, 2, 6, 20, 45, 0.0)\n\n# The following shorthand syntax also works\nep = TAIEpoch(2018, 2, 6, 20, 45, 0.0)\n\n# Or in another time scale\nep = TTEpoch(2018, 2, 6, 20, 45, 0.0)\n\n# Or use UTC with leap second handling\nep = from_utc(2018, 2, 6, 20, 45, 0.0) You can also parse an  Epoch  from a string. AstroTime.jl uses the  DateFormat  type and specification language from the  Dates  module from Julia's standard library. For example: ep = TAIEpoch(\"2018-02-06T20:45:00.000\", \"yyyy-mm-ddTHH:MM:SS.fff\")\n\n# The format string above `yyyy-mm-ddTHH:MM:SS.fff` is also the default format.\n# Thus, this also works...\nep = TAIEpoch(\"2018-02-06T20:45:00.000\")\n\nimport Dates\n\n# You can also reuse the format string\ndf = Dates.dateformat\"dd.mm.yyyy HH:MM\"\n\nutc = from_utc(\"06.02.2018 20:45\", df)\ntai = TAIEpoch(\"06.02.2018 20:45\", df) There are three additional character codes supported. f : This character code is parsed as the fraction of the current second and supports an arbitrary number of decimal places. t : This character code is parsed as the time scale. D : This character code is parsed as the day number within a year. # The time scale can be omitted from the constructor because it is already\n# defined in the input string\njulia> Epoch(\"2018-02-06T20:45:00.000 TAI\", \"yyyy-mm-ddTHH:MM:SS.fff ttt\")\n2018-02-06T20:45:00.000 TAI\n\n# February 6 is the 37th day of the year\njulia> TAIEpoch(\"2018-037T20:45:00.000\", \"yyyy-DDDTHH:MM:SS.fff\")\n2018-02-06T20:45:00.000 TAI When printing  Epochs , you can format the output in the same way. julia> ep = TAIEpoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TAI\njulia> AstroTime.format(ep, \"dd.mm.yyyy HH:MM ttt\")\n06.02.2018 20:45 TAI"},{"id":681,"pagetitle":"Tutorial","title":"Working with Epochs and Periods","ref":"/previews/PR43/AstroTime/stable/tutorial/#Working-with-Epochs-and-Periods","content":" Working with Epochs and Periods You can shift an  Epoch  in time by adding or subtracting an  AstroPeriod  to it. AstroTime.jl provides a convenient way to construct periods by multiplying a value with a time unit. julia> 23 * seconds\n23 seconds\n\njulia> 1hours # You can use Julia's factor juxtaposition syntax and omit the `*`\n1 hour The following time units are available: seconds minutes hours days years centuries To shift an  Epoch  forward in time add an  AstroPeriod  to it. julia> ep = TAIEpoch(2000, 1, 1)\n2000-01-01T00:00:00.000 TAI\n\njulia> ep + 1days\n2000-01-02T00:00:00.000 TAI Or subtract it to shift the  Epoch  backwards. julia> ep = TAIEpoch(2000, 1, 1)\n2000-01-01T00:00:00.000 TAI\n\njulia> ep - 1days\n1999-12-31T00:00:00.000 TAI If you subtract two epochs you will receive the time between them as an  AstroPeriod . julia> ep1 = TAIEpoch(2000, 1, 1)\n2000-01-01T00:00:00.000 TAI\n\njulia> ep2 = TAIEpoch(2000, 1, 2)\n2000-01-02T00:00:00.000 TAI\n\njulia> ep2 - ep1\n86400.0 seconds You can also construct an  AstroPeriod  with a different time unit from another  AstroPeriod . julia> dt = 86400.0seconds\n86400.0 seconds\n\njulia> days(dt)\n1.0 days To access the raw value of a period, i.e. without a unit, use the  value  function. julia> dt = 86400.0seconds\n86400.0 seconds\n\njulia> value(days(dt))\n1.0"},{"id":682,"pagetitle":"Tutorial","title":"Ranges","ref":"/previews/PR43/AstroTime/stable/tutorial/#Ranges","content":" Ranges You can also construct ranges of  Epoch s. The default step size one second. julia> TAIEpoch(2021, 7, 30, 17, 34, 30.0):TAIEpoch(2021, 7, 30, 17, 34, 31.0)\n2021-07-30T17:34:30.000 TAI:1.0 seconds:2021-07-30T17:34:31.000 TAI Or you can adjust the step size with any of the units supported. julia> collect(TAIEpoch(2000, 1, 1):1days:TAIEpoch(2000, 1, 5))\n5-element Vector{TAIEpoch{Float64}}:\n 2000-01-01T00:00:00.000 TAI\n 2000-01-02T00:00:00.000 TAI\n 2000-01-03T00:00:00.000 TAI\n 2000-01-04T00:00:00.000 TAI\n 2000-01-05T00:00:00.000 TAI"},{"id":683,"pagetitle":"Tutorial","title":"Converting Between Time Scales","ref":"/previews/PR43/AstroTime/stable/tutorial/#Converting-Between-Time-Scales","content":" Converting Between Time Scales You convert an  Epoch  to another time scale by constructing a new  Epoch  with the target time scale from it. julia> tai = TAIEpoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TAI\n\njulia> tt = TTEpoch(tai) # Convert to TT\n2018-02-06T20:45:32.184 TT"},{"id":684,"pagetitle":"Tutorial","title":"UTC and Leap Seconds","ref":"/previews/PR43/AstroTime/stable/tutorial/#UTC-and-Leap-Seconds","content":" UTC and Leap Seconds UTC is the primary civil time standard and aims to provide a time scale based on TAI and uniform SI seconds that is at the same time aligned with UT1 which is based on solar time and governed by the rotation of the Earth. The problem is that Earth's rotation speed is much more irregular compared to atomic clocks which define the SI second. Over the past decades, Earth's rotation has continuously slowed and thus TAI has been running ahead of UT1. Leap seconds are inserted into the UTC time scale to keep it within 0.9 seconds of UT1. This introduces ambiguities in AstroTime.jl's data model (see  #50 ). As a consequence,  UTCEpoch s are not supported. Nevertheless, UTC is supported as an I/O format for timestamps through the  from_utc  and  to_utc  functions. The last leap second was introduced at the end of December 31, 2016. You can create a  TAIEpoch  (or other  Epoch s) from a UTC date with proper leap second handling: julia> from_utc(2016, 12, 31, 23, 59, 60.0)\n2017-01-01T00:00:36.000 TAI\n\njulia> from_utc(\"2016-12-31T23:59:60.0\")\n2017-01-01T00:00:36.000 TAI\n\njulia> from_utc(\"2016-12-31T23:59:60.0\", scale=TDB)\n2017-01-01T00:01:08.183 TDB You can also use  Dates.DateTime  but note that you cannot represent a leap second date with it. julia> tai = from_utc(Dates.DateTime(2018, 2, 6, 20, 45, 0, 0))\n2018-02-06T20:45:37.000 TAI And go back to UTC: julia> to_utc(tai)\n\"2018-02-06T20:45:00.000\"\n\njulia> to_utc(String, tai, Dates.dateformat\"yyyy-mm-dd\")\n\"2018-02-06\"\n\njulia> to_utc(Dates.DateTime, tai)\n2018-02-06T20:45:00"},{"id":685,"pagetitle":"Tutorial","title":"High-Precision Conversions and Custom Offsets","ref":"/previews/PR43/AstroTime/stable/tutorial/#High-Precision-Conversions-and-Custom-Offsets","content":" High-Precision Conversions and Custom Offsets Some time scale transformations depend on measured quantities which cannot be accurately predicted (e.g. UT1) or there are different algorithms which offer variable levels of accuracy. For the former, AstroTime.jl can download the required data automatically from the internet. You need to run  AstroTime.update()  periodically (weekly) to keep this data up-to-date. For the latter, AstroTime.jl will use the alogrithm which provides the best trade-off between accuracy and performance for most applications. If you cannot use the internet or want to use a different data source, e.g. a time ephemeris, to obtain the offset between time scales, you can use the following constructor for epochs which overrides the default algorithms. # AstroTime.jl provides a higher precision TDB<->TT transformation that is dependent on\n# the position of the observer on Earth\n\ntt = TTEpoch(2018, 2, 6, 20, 46, 9.184)\ndt = getoffset(tt, TDB, elong, u, v)\n\n# Use the custom offset for the transformation\ntdb = TDBEpoch(dt, tt)"},{"id":686,"pagetitle":"Tutorial","title":"Working with Julian Dates","ref":"/previews/PR43/AstroTime/stable/tutorial/#Working-with-Julian-Dates","content":" Working with Julian Dates Epochs can be converted to and from  Julian Dates . Three different base epochs are supported: The (default) J2000 date which starts at January 1, 2000, at 12h, the standard Julian date which starts at January 1, 4712BC, at 12h, and the Modified Julian date which starts at November 17, 1858, at midnight. You can get Julian date in days from an  Epoch  like this: julia> ep = TTEpoch(2000,1,2)\n2000-01-02T00:00:00.000 TT\n\njulia> j2000(ep)\n0.5 days\n\njulia> julian(ep)\n2.4515455e6 days\n\njulia> modified_julian(ep)\n51545.0 days To construct an  Epoch  from a Julian date do this: julia> TTEpoch(0.5days) # J2000 is the default\n2000-01-02T00:00:00.000 TT\n\njulia> TTEpoch(0.5days, origin=:j2000)\n2000-01-02T00:00:00.000 TT\n\njulia> TTEpoch(2.4515455e6days, origin=:julian)\n2000-01-02T00:00:00.000 TT\n\njulia> TTEpoch(51545.0days, origin=:modified_julian)\n2000-01-02T00:00:00.000 TT\n\njulia> TTEpoch(86400.0seconds, origin=:j2000)\n2000-01-02T12:00:00.000 TT Some libraries (such as  ERFA ) expect a two-part Julian date as input. You can use  julian_twopart(ep)  in this case. If you need more control over the output, have a look at the  julian_period  function. Warning You should not convert an  Epoch  to a Julian date to do arithmetic because this will result in a loss of accuracy."},{"id":687,"pagetitle":"Tutorial","title":"Converting to Standard Library Types","ref":"/previews/PR43/AstroTime/stable/tutorial/#Converting-to-Standard-Library-Types","content":" Converting to Standard Library Types Epoch  instances satisfy the  AbstractDateTime  interface specified in the  Dates  module of Julia's standard library.  Thus, you should be able to pass them to other libraries which expect a standard  DateTime . Please open an issue on  the issue tracker  if you encounter any problems with this. It is nevertheless possible to convert an  Epoch  to a  DateTime  if it should become necessary. Please note that the time scale information will be lost in the process. julia> ep = TTEpoch(2000,1,1)\n2000-01-01T00:00:00.000 TT\n\njulia> import Dates; Dates.DateTime(ep)\n2000-01-01T00:00:00"},{"id":688,"pagetitle":"Tutorial","title":"Defining Custom Time Scales","ref":"/previews/PR43/AstroTime/stable/tutorial/#Defining-Custom-Time-Scales","content":" Defining Custom Time Scales AstroTime.jl enables you to create your own first-class time scales via the  @timescale  macro. The macro will define the necessary structs and register the new time scale. Let's start with a simple example and assume that you want to define  EphemerisTime  as an alias for  TDB . You need to provide the name of the time scale and optionally a \"parent\" time scale to which it is linked. @timescale EphemerisTime TDB At this point, you can already use the new time scale to create epochs. julia> EphemerisTime\nEphemerisTime\n\njulia> typeof(EphemerisTime)\nEphemerisTimeScale\n\njulia> et = EphemerisTimeEpoch(2000, 1, 1)\n2000-01-01T00:00:00.000 EphemerisTime Conversion to other  Epoch  types will not yet work for the newly created time because you need to provide the necessary methods for  getoffset . If you are unsure which methods are needed, you can try to transform the epoch and the resulting error message will provide a hint. julia> TDBEpoch(et)\nERROR: No conversion 'EphemerisTime->TDB' available. If one of these is a custom time scale,\nyou may need to define `AstroTime.Epochs.getoffset(::EphemerisTimeScale, ::BarycentricDynamicalTime, second, fraction, args...)`. To enable transformations between  EphemerisTime  and  TDB  in both directions you need to define the following methods. Since  EphemerisTime  and  TDB  are identical, the offset between them is zero. AstroTime.Epochs.getoffset(::EphemerisTimeType, ::CoordinatedUniversalTime, second, fraction) = 0.0\nAstroTime.Epochs.getoffset(::CoordinatedUniversalTime, ::EphemerisTimeType, second, fraction) = 0.0 You can now use  EphemerisTimeEpoch  like any other epoch type, e.g. julia> ep = TDBEpoch(2000, 1, 1)\n2000-01-01T00:00:00.000 TDB\n\njulia> EphemerisTimeEpoch(ep)\n2000-01-01T00:00:00.000 EphemerisTime For a more complex example, let's reimplement the Geocentric Coordinate Time (TCG) scale. It is a linear transformation from Terrestrial Time (TT), i.e. the transformation is dependent on the point in time in the current time scale (the  second  and  fraction  arguments to  getoffset ). @timescale CustomTCG TT\n\n# The reference point\nconst JD77_SEC = -7.25803167816e8\n# The linear rate of change\nconst LG_RATE = 6.969290134e-10\n\nfunction getoffset(::CustomTCGScale, ::TerrestrialTime, second, fraction)\n    # `second` is the number of full seconds since 2000-01-01\n    # `fraction` is the fraction of the current second\n    dt = second - JD77_SEC + fraction\n    return -LG_RATE * dt\nend\n\nfunction getoffset(::TerrestrialTime, ::CustomTCGScale, second, fraction)\n    # The inverse rate for the backwards transformation\n    rate = LG_RATE / (1.0 - LG_RATE)\n    dt = second - JD77_SEC + fraction\n    return rate * dt\nend\n Let's assume that you want to define a time scale that determines the  Spacecraft Event Time  which takes the one-way light time into account. You could use the following definitions adding the  distance  parameter which is the distance of the spacecraft from Earth. const speed_of_light = 299792458.0 # m/s\n\n@timescale SCET TAI\n\nfunction AstroTime.Epochs.getoffset(::SCETScale, ::InternationalAtomicTime,\n                                    second, fraction, distance)\n    return distance / speed_of_light\nend\nfunction AstroTime.Epochs.getoffset(::InternationalAtomicTime, ::SCETScale,\n                                    second, fraction, distance)\n    return -distance / speed_of_light\nend If you want to convert another epoch to  SCET , you now need to pass this additional parameter. For example, for a spacecraft that is one astronomical unit away from Earth: julia> astronomical_unit = 149597870700.0 # m\n149597870700.0\n\njulia> ep = TAIEpoch(2000, 1, 1)\n2000-01-01T00:00:00.000 TAI\n\njulia> SCETEpoch(ep, astronomical_unit)\n1999-12-31T23:51:40.995 SCET Note At this time, custom epochs with additional parameters cannot be parsed from strings. You can also introduce time scales that are disjoint from AstroTime.jl's default graph of time scales by defining a time scale without a parent. julia> @timescale Disjoint\n\njulia> typeof(Disjoint)\nDisjointScale By defining additional time scales connected to this scale and the appropriate  getoffset  methods, you can create your own graph of time scales that is completely independent of the defaults provided by the library. 1 Transformations to and from UT1 depend on the measured quantity ΔUT1 which is published in  IERS  tables on a weekly basis. AstroTime.jl can automatically fetch these tables by running  AstroTime.update() . If you work with  UT1 , you need to run this function periodically."},{"id":691,"pagetitle":"Home","title":"SkyCoords.jl","ref":"/previews/PR43/SkyCoords/stable/#SkyCoords.jl","content":" SkyCoords.jl SkyCoords.jl provides a type system for astronomical coordinate systems with appropriate conversions between them."},{"id":692,"pagetitle":"Home","title":"Installation","ref":"/previews/PR43/SkyCoords/stable/#Installation","content":" Installation From the Julia REPL (v1.6) pkg> add SkyCoords\n\njulia> using SkyCoords"},{"id":693,"pagetitle":"Home","title":"Usage","ref":"/previews/PR43/SkyCoords/stable/#Usage","content":" Usage There are currently three supported coordinate systems. The following immutable types are used to represent coordinates in each system: ICRSCoords : ICRS coordinates system GalCoords : Galactic coordinates system FK5Coords : FK5 coordinates system (with arbitrary equinox) EclipticCoords : Ecliptic coordinates system Each type holds a longitude and latitude, and each is a subtype of  AbstractSkyCoords . julia> c1 = ICRSCoords(0.0, 0.0)  # inputs are ra, dec in radians\nICRSCoords{Float64}(0.0, 0.0)\n\njulia> c1.ra # access ra, dec individually\n0.0\n\njulia> c2 = convert(GalCoords, c1) # convert to a different system\nGalCoords{Float64}(1.6814027872278692, -1.0504884034813007)\n\njulia> c2.l # Note that galactic coordinate fields are l, b\n1.6814027872278692\n\njulia> c1 |> FK5Coords{2000} # Can use piping syntax for conversion\nFK5Coords{2000, Float64}(1.1102233723050067e-7, 4.411803426976326e-8)"},{"id":694,"pagetitle":"Home","title":"Units","ref":"/previews/PR43/SkyCoords/stable/#Units","content":" Units There is built-in support for units via  Unitful.jl julia> using Unitful\n\njulia> c = ICRSCoords(0.11255u\"°\", 0.00091u\"rad\")\nICRSCoords{Float64}(0.0019643680731196178, 0.00091)\n\njulia> c2 = FK5Coords{2000}(0.1u\"rad\", 0.5)\nFK5Coords{2000, Float64}(0.1, 0.5)\n\njulia> SkyCoords.lat(u\"μrad\", c)\n910.0 μrad"},{"id":695,"pagetitle":"Home","title":"Parsing from strings","ref":"/previews/PR43/SkyCoords/stable/#Parsing-from-strings","content":" Parsing from strings The  AstroAngles.jl  package provides convenient string parsing utilities julia> using AstroAngles\n\njulia> c3 = ICRSCoords(hms\"05:34:31.94\", dms\"+22:00:52.2\")\nICRSCoords{Float64}(1.4596726677614607, 0.3842255081802917) for example, to load coordinates from a target list julia> using CSV, DataFrames\n\njulia> table = CSV.File(\"target_list.csv\") |> DataFrame;\n\njulia> [table.ra table.dec]\n203×2 Matrix{String}:\n \"00 05 01.42\"  \"40 03 35.82\"\n \"00 05 07.52\"  \"73 13 11.34\"\n \"00 36 01.40\"  \"-11 12 13.00\"\n[...]\n\njulia> coords = @. ICRSCoords(hms2rad(table.ra), dms2rad(table.dec))\n203-element Vector{ICRSCoords{Float64}}:\n ICRSCoords{Float64}(0.021919880964005448, 0.6991780256843024)\n ICRSCoords{Float64}(0.022363485482220672, 1.277926878539953)\n ICRSCoords{Float64}(0.15718144355252264, -0.19553990200190915)\n[...]"},{"id":696,"pagetitle":"Home","title":"Angular Separation between Coordinates","ref":"/previews/PR43/SkyCoords/stable/#Angular-Separation-between-Coordinates","content":" Angular Separation between Coordinates The  separation  function allows you to compute the angular (great-circle) distance between two coordinates, in radians, using the  Vincenty formula .  The coordinates can be also given in different systems.  For example, according to SIMBAD the  FK5Coords{2000}  coordinates of  Mizar  are julia> mizar = FK5Coords{2000}(3.507787, 0.958628)\nFK5Coords{2000, Float64}(3.507787, 0.958628) while the  GalCoords  coordinates of Alcor are julia> alcor = GalCoords(1.968189, 1.072829)\nGalCoords{Float64}(1.968189, 1.072829) Their angular separation is given by julia> separation(mizar, alcor) # Radians\n0.003435309169452965\n\njulia> rad2deg(separation(mizar, alcor)) * 60 # Arcminutes\n11.809723003934822 with an angle julia> position_angle(mizar, alcor) # radians\n1.2446024012417884\n\njulia> position_angle(mizar, alcor) |> rad2deg # degrees\n71.31046476300233\n"},{"id":697,"pagetitle":"Home","title":"Accuracy","ref":"/previews/PR43/SkyCoords/stable/#Accuracy","content":" Accuracy All the supported conversions have been compared to the results of  astropy.coordinates  (to better than 0.0001 arcsec agreement for  Float64 ). In turn,  astropy.coordinates  has been tested against many other tools."},{"id":698,"pagetitle":"Home","title":"Performance","ref":"/previews/PR43/SkyCoords/stable/#Performance","content":" Performance For small and moderate numbers of coordinates, conversions are much faster than  astropy.coordinates  in Python. The following plot shows the performance for converting ICRS coordinates to various other systems (Galactic, FK5J2000 and FK5J1975), using  astropy.coordinates  ( py_*  labels) and SkyCoords.jl ( jl_*  labels). The x axis denotes the number of coordinates being simultaneously converted, with 1 corresponding to scalar coordinates. Specs CPU Intel core i5-8259U @ 2.3GHz (4 cores) RAM 16GB Julia Version 1.2 Python Version 3.7 Astropy Version 3.1.2 For scalar coordinates, SkyCoords.jl is up to 100,000 times faster. For very large vectors of one million coordinates or more, SkyCoords.jl is 2-4 times faster.  The source code for these benchmarks can be found in  bench/ ."},{"id":699,"pagetitle":"Home","title":"Contributing","ref":"/previews/PR43/SkyCoords/stable/#Contributing","content":" Contributing If you would like to contribute to SkyCoords please head over to the  GitHub page  and file an issue or open a pull request!"},{"id":702,"pagetitle":"API/Reference","title":"API/Reference","ref":"/previews/PR43/SkyCoords/stable/api/#API/Reference","content":" API/Reference"},{"id":703,"pagetitle":"API/Reference","title":"Index","ref":"/previews/PR43/SkyCoords/stable/api/#Index","content":" Index SkyCoords.AbstractSkyCoords SkyCoords.EclipticCoords SkyCoords.FK5Coords SkyCoords.GalCoords SkyCoords.ICRSCoords SkyCoords.SuperGalCoords SkyCoords.offset SkyCoords.position_angle SkyCoords.separation"},{"id":704,"pagetitle":"API/Reference","title":"Types","ref":"/previews/PR43/SkyCoords/stable/api/#Types","content":" Types"},{"id":705,"pagetitle":"API/Reference","title":"SkyCoords.AbstractSkyCoords","ref":"/previews/PR43/SkyCoords/stable/api/#SkyCoords.AbstractSkyCoords","content":" SkyCoords.AbstractSkyCoords  —  Type The supertype for all sky coordinate systems. source"},{"id":706,"pagetitle":"API/Reference","title":"SkyCoords.ICRSCoords","ref":"/previews/PR43/SkyCoords/stable/api/#SkyCoords.ICRSCoords","content":" SkyCoords.ICRSCoords  —  Type ICRSCoords(ra, dec) International Celestial Reference System This is the current standard adopted by the International Astronomical Union notably due to its high level of accuracy compared to standard equatorial coordinate systems. What sets this apart from  FK5Coords  is that it is completely defined using extragalactic radio sources rather than a geocentric frame, which means the reference frame will not change due to Earth's motion. Coordinates ra  - Right ascension in radians (0, 2π) dec  - Declination in radians (-π/2, π/2) source"},{"id":707,"pagetitle":"API/Reference","title":"SkyCoords.GalCoords","ref":"/previews/PR43/SkyCoords/stable/api/#SkyCoords.GalCoords","content":" SkyCoords.GalCoords  —  Type GalCoords(l, b) Galactic Coordinate System This coordinate system is defined based on the projection of the Milky Way galaxy onto our celestial sphere, with (0, 0) being approximately the center of our galaxy. Coordinates l  - Galactic longitude in radians (-π, π) b  - Galactic latitude in radians (-π/2, π/2) source"},{"id":708,"pagetitle":"API/Reference","title":"SkyCoords.SuperGalCoords","ref":"/previews/PR43/SkyCoords/stable/api/#SkyCoords.SuperGalCoords","content":" SkyCoords.SuperGalCoords  —  Type SuperGalCoords(l, b) Supergalactic Coordinate System The supergalactic plane is part of a reference frame for the supercluster of galaxies that contains the Milky Way galaxy. The supergalactic plane as so-far observed is more or less perpendicular to the plane of the Milky Way, the angle is 84.5 degrees. Viewed from the Earth, the plane traces a great circle across the sky through the constellations  Coordinates l  - SuperGalCoords longitude in radians (-π, π) b  - SuperGalCoords latitude in radians (-π/2, π/2) source"},{"id":709,"pagetitle":"API/Reference","title":"SkyCoords.FK5Coords","ref":"/previews/PR43/SkyCoords/stable/api/#SkyCoords.FK5Coords","content":" SkyCoords.FK5Coords  —  Type FK5Coords{equinox}(ra, dec) Equatorial Coordinate System This coordinate system maps the celestial sphere based on a geocentric observer. Historically the oldest, this coordinate system has been shown to be inaccurate due to its definitions based on the Earth, which has long-scale precession causing the reference frame to change. Because of this, an equinox must be provided (typically 2000, commonly known as J2000) which defines the reference frame. Coordinates ra  - Right ascension in radians (0, 2π) dec  - Declination in radians (-π/2, π/2) source"},{"id":710,"pagetitle":"API/Reference","title":"SkyCoords.EclipticCoords","ref":"/previews/PR43/SkyCoords/stable/api/#SkyCoords.EclipticCoords","content":" SkyCoords.EclipticCoords  —  Type EclipticCoords{equinox}(lon, lat) Ecliptic Coordinate System This coordinate system is geocentric with the ecliptic plane as the xy-plane with x oriented according to the equinox specified by  equinox . Coordinates lon  - Longitude in radians (0, 2π) lat  - Latitude in radians (-π/2, π/2) source"},{"id":711,"pagetitle":"API/Reference","title":"Conversion","ref":"/previews/PR43/SkyCoords/stable/api/#Conversion","content":" Conversion To convert between types, there are three (equivalent) methods of doing so. julia> c1 = ICRSCoords(0., 0.)\nICRSCoords{Float64}(0.0, 0.0) using  convert julia> convert(GalCoords, c1)\nGalCoords{Float64}(1.6814027872278692, -1.0504884034813007) using constructors julia> GalCoords(c1)\nGalCoords{Float64}(1.6814027872278692, -1.0504884034813007) using  |> julia> c1 |> GalCoords\nGalCoords{Float64}(1.6814027872278692, -1.0504884034813007)"},{"id":712,"pagetitle":"API/Reference","title":"Functions","ref":"/previews/PR43/SkyCoords/stable/api/#Functions","content":" Functions"},{"id":713,"pagetitle":"API/Reference","title":"SkyCoords.separation","ref":"/previews/PR43/SkyCoords/stable/api/#SkyCoords.separation","content":" SkyCoords.separation  —  Function separation(c1::AbstractSkyCoords, c2::AbstractSkyCoords) -> distance Return angular separation between two sky coordinates, in radians. The angular separation is calculated using the  Vincenty formula , which is slightly more complex and computationally expensive than some alternatives, but is stable at at all distances, including the poles and antipodes. source"},{"id":714,"pagetitle":"API/Reference","title":"SkyCoords.position_angle","ref":"/previews/PR43/SkyCoords/stable/api/#SkyCoords.position_angle","content":" SkyCoords.position_angle  —  Function position_angle(c1::AbstractSkyCoords, c2::AbstractSkyCoords) -> angle Return position angle between two sky coordinates, in positive radians. Examples julia> c1 = ICRSCoords(0, 0); c2 = ICRSCoords(deg2rad(1), 0);\n\njulia> position_angle(c1, c2) |> rad2deg\n90.0 source"},{"id":715,"pagetitle":"API/Reference","title":"SkyCoords.offset","ref":"/previews/PR43/SkyCoords/stable/api/#SkyCoords.offset","content":" SkyCoords.offset  —  Function offset(::AbstractSkyCoords, separation, pa) -> coordinate Offset a coordinate by a given angular separation,  separation , in radians and position angle,  pa , in radians. Uses the sine and cosine rules in spherical coordinates with corrections for the antipodes. Returns a sky coordinate of the same type as input. Examples julia> c1 = ICRSCoords(0, 0);\n\njulia> c2 = offset(c1, deg2rad(1), deg2rad(90))\nICRSCoords{Float64}(0.017453292519943295, 1.0686516840418957e-18)\n\njulia> offset(c1, c2) .|> rad2deg\n(1.0, 90.0) See Also separation ,  position_angle source offset(::AbstractSkyCoords, AbstractSkyCoords) -> angle, angle Return the separation and position angle in radians between two sky coordinates. Examples julia> c1 = ICRSCoords(0, 0); c2 = ICRSCoords(deg2rad(1), 0);\n\njulia> offset(c1, c2) .|> rad2deg\n(1.0, 90.0) See Also separation ,  position_angle source"},{"id":720,"pagetitle":"API","title":"SPICE.SpiceCharCell","ref":"/previews/PR43/SPICE/stable/api/#SPICE.SpiceCharCell","content":" SPICE.SpiceCharCell  —  Type . SpiceCharCell(size, length) Create a SpiceCharCell that can contain up to  size  strings with  length  characters. source"},{"id":721,"pagetitle":"API","title":"SPICE.SpiceDoubleCell","ref":"/previews/PR43/SPICE/stable/api/#SPICE.SpiceDoubleCell","content":" SPICE.SpiceDoubleCell  —  Type . SpiceDoubleCell(size) Create a SpiceDoubleCell that can contain up to  size  elements. source"},{"id":722,"pagetitle":"API","title":"SPICE.SpiceIntCell","ref":"/previews/PR43/SPICE/stable/api/#SPICE.SpiceIntCell","content":" SPICE.SpiceIntCell  —  Type . SpiceIntCell(size) Create a SpiceIntCell that can contain up to  size  elements. source"},{"id":723,"pagetitle":"API","title":"Base.append!","ref":"/previews/PR43/SPICE/stable/api/#Base.append!-Tuple{SPICE.SpiceCell,Any}","content":" Base.append!  —  Method . append!(cell, collection) Append all items from  collection  to the char/double/integer SpiceCell  cell . source"},{"id":724,"pagetitle":"API","title":"Base.copy","ref":"/previews/PR43/SPICE/stable/api/#Base.copy-Union{Tuple{SPICE.SpiceCell{T,T1,N} where N where T1}, Tuple{T}} where T","content":" Base.copy  —  Method . copy(cell::SpiceCell) Duplicate the SpiceCell  cell . source"},{"id":725,"pagetitle":"API","title":"Base.diff","ref":"/previews/PR43/SPICE/stable/api/#Base.diff-Union{Tuple{T}, Tuple{SPICE.SpiceCell{T,T1,N} where N where T1,SPICE.SpiceCell{T,T1,N} where N where T1}} where T","content":" Base.diff  —  Method . diff(a::T, b::T) where T <: SpiceCell Compute the difference of two sets of any data type to form a third set. Arguments a : First input set b : Second input set Output Returns a cell containing the difference of  a  and  b . References NAIF Documentation source"},{"id":726,"pagetitle":"API","title":"Base.length","ref":"/previews/PR43/SPICE/stable/api/#Base.length-Tuple{SPICE.SpiceCell}","content":" Base.length  —  Method . length(cell) Returns the cardinality (number of elements) of  cell . source"},{"id":727,"pagetitle":"API","title":"Base.push!","ref":"/previews/PR43/SPICE/stable/api/#Base.push!-Tuple{SPICE.SpiceCell,Vararg{Any,N} where N}","content":" Base.push!  —  Method . push!(cell, items...) Insert one or more  items  at the end of the char/double/integer SpiceCell  cell . source"},{"id":728,"pagetitle":"API","title":"Base.union","ref":"/previews/PR43/SPICE/stable/api/#Base.union-Union{Tuple{T}, Tuple{SPICE.SpiceCell{T,T1,N} where N where T1,SPICE.SpiceCell{T,T1,N} where N where T1}} where T","content":" Base.union  —  Method . union(a::T, b::T) where T <: SpiceCell Compute the union of two sets of any data type to form a third set. Arguments a : First input set b : Second input set Output Returns a cell containing the union of  a  and  b . References NAIF Documentation source"},{"id":729,"pagetitle":"API","title":"SPICE.appnd","ref":"/previews/PR43/SPICE/stable/api/#SPICE.appnd-Tuple{Any,SPICE.SpiceCell{UInt8,T,N} where N where T}","content":" SPICE.appnd  —  Method . appnd(item, cell) Append an  item  to the char/double/integer SpiceCell  cell . References appndc - NAIF Documentation appndd - NAIF Documentation appndi - NAIF Documentation source"},{"id":730,"pagetitle":"API","title":"SPICE.axisar","ref":"/previews/PR43/SPICE/stable/api/#SPICE.axisar-Tuple{Any,Any}","content":" SPICE.axisar  —  Method . axisar(axis, angle) Construct a rotation matrix that rotates vectors by a specified  angle  about a specified  axis . Arguments axis : Rotation axis angle : Rotation angle in radians Output Rotation matrix corresponding to  axis  and  angle References NAIF Documentation source"},{"id":731,"pagetitle":"API","title":"SPICE.b1900","ref":"/previews/PR43/SPICE/stable/api/#SPICE.b1900-Tuple{}","content":" SPICE.b1900  —  Method . b1900() Returns the Julian Date corresponding to Besselian date 1900.0. References NAIF Documentation source"},{"id":732,"pagetitle":"API","title":"SPICE.b1950","ref":"/previews/PR43/SPICE/stable/api/#SPICE.b1950-Tuple{}","content":" SPICE.b1950  —  Method . b1950() Returns the Julian Date corresponding to Besselian date 1950.0. References NAIF Documentation source"},{"id":733,"pagetitle":"API","title":"SPICE.badkpv","ref":"/previews/PR43/SPICE/stable/api/#SPICE.badkpv-NTuple{6,Any}","content":" SPICE.badkpv  —  Method . badkpv(caller, name, comp, size, divby, typ) Determine if a kernel pool variable is present and if so that it has the correct size and type. Arguments caller : Name of the routine calling this routine name : Name of a kernel pool variable comp : Comparison operator size : Expected size of the kernel pool variable divby : A divisor of the size of the kernel pool variable type : Expected type of the kernel pool variable Output The function returns  false  if the kernel pool variable is OK otherwise an exception is thrown. References NAIF Documentation source"},{"id":734,"pagetitle":"API","title":"SPICE.bltfrm","ref":"/previews/PR43/SPICE/stable/api/#SPICE.bltfrm-Tuple{Any}","content":" SPICE.bltfrm  —  Method . bltfrm(frmcls) Return a SPICE set containing the frame IDs of all built-in frames of a specified class. Arguments frmcls : Frame class Output idset : Set of ID codes of frames of the specified class References NAIF Documentation source"},{"id":735,"pagetitle":"API","title":"SPICE.bodc2n","ref":"/previews/PR43/SPICE/stable/api/#SPICE.bodc2n-Tuple{Any}","content":" SPICE.bodc2n  —  Method . bodc2n(code) Translate the SPICE integer code of a body into a common name for that body. Arguments code : Integer ID code to be translated into a name Output A common name for the body identified by code or  nothing  if none was found. References NAIF Documentation source"},{"id":736,"pagetitle":"API","title":"SPICE.bodc2s","ref":"/previews/PR43/SPICE/stable/api/#SPICE.bodc2s-Tuple{Any}","content":" SPICE.bodc2s  —  Method . bodc2s(code) Translate a body ID code to either the corresponding name or if no name to ID code mapping exists, the string representation of the body ID value. Arguments code : Integer ID code to translate to a string Output Returns a string corresponding to  code References NAIF Documentation source"},{"id":737,"pagetitle":"API","title":"SPICE.boddef","ref":"/previews/PR43/SPICE/stable/api/#SPICE.boddef-Tuple{Any,Any}","content":" SPICE.boddef  —  Method . boddef(name, code) Define a body name/ID code pair for later translation via  bodn2c  or  bodc2n . Arguments name : Common name of some body code : Integer code for that body References NAIF Documentation source"},{"id":738,"pagetitle":"API","title":"SPICE.bodfnd","ref":"/previews/PR43/SPICE/stable/api/#SPICE.bodfnd-Tuple{Any,Any}","content":" SPICE.bodfnd  —  Method . bodfnd(body, item) Determine whether values exist for some item for any body in the kernel pool. Arguments body : ID code of body item : Item to find (\"RADII\", \"NUT AMP RA\", etc.) Output Returns  true  if the item is in the kernel pool and  false  if it is not. References NAIF Documentation source"},{"id":739,"pagetitle":"API","title":"SPICE.bodn2c","ref":"/previews/PR43/SPICE/stable/api/#SPICE.bodn2c-Tuple{Any}","content":" SPICE.bodn2c  —  Method . bodn2c(name) Translate the name of a body or object to the corresponding SPICE integer ID code. Arguments name : Body name to be translated into a SPICE ID code Output Return the SPICE integer ID code for the named body or  nothing  if none was found. References NAIF Documentation source"},{"id":740,"pagetitle":"API","title":"SPICE.bods2c","ref":"/previews/PR43/SPICE/stable/api/#SPICE.bods2c-Tuple{Any}","content":" SPICE.bods2c  —  Method . bods2c(name) Translate a string containing a body name or ID code to an integer code. Arguments name : String to be translated to an ID code Output Retunrs the integer ID code corresponding to  name  or  nothing  if none as found. References NAIF Documentation source"},{"id":741,"pagetitle":"API","title":"SPICE.bodvcd","ref":"/previews/PR43/SPICE/stable/api/#SPICE.bodvcd","content":" SPICE.bodvcd  —  Function . bodvcd(bodyid, item) Fetch from the kernel pool the double precision values of an item associated with a body, where the body is specified by an integer ID code. Arguments bodyid : Body ID code item : Item for which values are desired. (\"RADII\", \"NUT PREC ANGLES\", etc.) maxn : Maximum number of values that may be returned (default: 100) Output Returns the requested values. References NAIF Documentation source"},{"id":742,"pagetitle":"API","title":"SPICE.bodvrd","ref":"/previews/PR43/SPICE/stable/api/#SPICE.bodvrd","content":" SPICE.bodvrd  —  Function . bodvrd(bodynm, item) Fetch from the kernel pool the double precision values of an item associated with a body. Arguments bodynm : Body name item : Item for which values are desired. (\"RADII\", \"NUT PREC ANGLES\", etc.) maxn : Maximum number of values that may be returned (default: 100) Output values : Values References NAIF Documentation source"},{"id":743,"pagetitle":"API","title":"SPICE.brcktd","ref":"/previews/PR43/SPICE/stable/api/#SPICE.brcktd","content":" SPICE.brcktd  —  Function . brcktd(number, e1, e2) Deprecated Use  clamp  from Julia's standard library instead. source"},{"id":744,"pagetitle":"API","title":"SPICE.brckti","ref":"/previews/PR43/SPICE/stable/api/#SPICE.brckti","content":" SPICE.brckti  —  Function . brckti(number, e1, e2) Deprecated Use  clamp  from Julia's standard library instead. source"},{"id":745,"pagetitle":"API","title":"SPICE.bschoc","ref":"/previews/PR43/SPICE/stable/api/#SPICE.bschoc","content":" SPICE.bschoc  —  Function . bschoc(value, array, order) Deprecated Use  findfirst(array .== value)  instead. source"},{"id":746,"pagetitle":"API","title":"SPICE.bschoi","ref":"/previews/PR43/SPICE/stable/api/#SPICE.bschoi","content":" SPICE.bschoi  —  Function . bschoi(value, array, order) Deprecated Use  findfirst(array .== value)  instead. source"},{"id":747,"pagetitle":"API","title":"SPICE.bsrchc","ref":"/previews/PR43/SPICE/stable/api/#SPICE.bsrchc","content":" SPICE.bsrchc  —  Function . bsrchc(value, array) Deprecated Use  findfirst(array .== value)  instead. source"},{"id":748,"pagetitle":"API","title":"SPICE.bsrchd","ref":"/previews/PR43/SPICE/stable/api/#SPICE.bsrchd","content":" SPICE.bsrchd  —  Function . bsrchd(value, array) Deprecated Use  findfirst(array .== value)  instead. source"},{"id":749,"pagetitle":"API","title":"SPICE.bsrchi","ref":"/previews/PR43/SPICE/stable/api/#SPICE.bsrchi","content":" SPICE.bsrchi  —  Function . bsrchi(value, array) Deprecated Use  findfirst(array .== value)  instead. source"},{"id":750,"pagetitle":"API","title":"SPICE.card","ref":"/previews/PR43/SPICE/stable/api/#SPICE.card-Tuple{SPICE.SpiceCell}","content":" SPICE.card  —  Method . card(cell) Returns the cardinality (number of elements) of  cell . source"},{"id":751,"pagetitle":"API","title":"SPICE.ccifrm","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ccifrm-Tuple{Any,Any}","content":" SPICE.ccifrm  —  Method . ccifrm(frclss, clssid) Return the frame name, frame ID, and center associated with a given frame class and class ID. Arguments frclss : Class of frame clssid : Class ID of frame Output Returns  nothing  if no frame was found or frcode : ID code of the frame frname : Name of the frame center : ID code of the center of the frame References NAIF Documentation source"},{"id":752,"pagetitle":"API","title":"SPICE.cgv2el","ref":"/previews/PR43/SPICE/stable/api/#SPICE.cgv2el-Tuple{Any,Any,Any}","content":" SPICE.cgv2el  —  Method . cgv2el(center, vec1, vec2) Form an ellipse from a center vector and two generating vectors. Arguments center : Center vector vec1 : Generating vector vec2 : Generating vector Output Returns the ellipse defined by the input vectors. References NAIF Documentation source"},{"id":753,"pagetitle":"API","title":"SPICE.chbder","ref":"/previews/PR43/SPICE/stable/api/#SPICE.chbder-NTuple{4,Any}","content":" SPICE.chbder  —  Method . chbder(cp, x2s, x, nderiv) Given the coefficients for the Chebyshev expansion of a polynomial, this returns the value of the polynomial and its first  nderiv  derivatives evaluated at the input  x . Arguments cp : Chebyshev polynomial coefficients x2s : Transformation parameters of polynomial x : Value for which the polynomial is to be evaluated nderiv : The number of derivatives to compute Output Returns the derivatives of the polynomial. References NAIF Documentation source"},{"id":754,"pagetitle":"API","title":"SPICE.cidfrm","ref":"/previews/PR43/SPICE/stable/api/#SPICE.cidfrm-Tuple{Any}","content":" SPICE.cidfrm  —  Method . cidfrm(cent) Retrieve frame ID code and name to associate with a frame center. Arguments cent : ID code for an object for which there is a preferred reference frame Output Returns  nothing  if no frame was found or frcode : The ID code of the frame associated with  cent frname : The name of the frame with ID  frcode References NAIF Documentation source"},{"id":755,"pagetitle":"API","title":"SPICE.ckcls","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ckcls-Tuple{Any}","content":" SPICE.ckcls  —  Method . ckcls(handle) Close an open CK file. Arguments handle : Handle of the CK file to be closed References NAIF Documentation source"},{"id":756,"pagetitle":"API","title":"SPICE.ckcov!","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ckcov!-NTuple{7,Any}","content":" SPICE.ckcov!  —  Method . ckcov!(ck, idcode, needav, level, tol, timsys, cover) Find the coverage window for a specified object in a specified CK file. Arguments ck : Name of CK file idcode : ID code of object needav : Flag indicating whether angular velocity is needed level : Coverage level:  \"SEGMENT\" OR \"INTERVAL\" tol : Tolerance in ticks timsys : Time system used to represent coverage cover : Window giving coverage for  idcode . Data already present in  cover    will be combined with coverage found for the object designated by  idcode    in the file  ck . References NAIF Documentation source"},{"id":757,"pagetitle":"API","title":"SPICE.ckcov","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ckcov-NTuple{6,Any}","content":" SPICE.ckcov  —  Method . ckcov(ck, idcode, needav, level, tol, timsys) Find the coverage window for a specified object in a specified CK file. Arguments ck : Name of CK file idcode : ID code of object needav : Flag indicating whether angular velocity is needed level : Coverage level:  \"SEGMENT\" OR \"INTERVAL\" tol : Tolerance in ticks timsys : Time system used to represent coverage Output Window giving coverage for  idcode References NAIF Documentation source"},{"id":758,"pagetitle":"API","title":"SPICE.ckgp","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ckgp-NTuple{4,Any}","content":" SPICE.ckgp  —  Method . ckgp(inst, sclkdp, tol, ref) Get pointing (attitude) for a specified spacecraft clock time. Arguments inst : NAIF ID of instrument, spacecraft, or structure sclkdp : Encoded spacecraft clock time tol : Time tolerance ref : Reference frame Outputs Returns  nothing  if the requested pointing is not available or cmat : C-matrix pointing data clkout : Output encoded spacecraft clock time References NAIF Documentation source"},{"id":759,"pagetitle":"API","title":"SPICE.ckgpav","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ckgpav-NTuple{4,Any}","content":" SPICE.ckgpav  —  Method . ckgpav(inst, sclkdp, tol, ref) Get pointing (attitude) and angular velocity for a specified spacecraft clock time. Arguments inst : NAIF ID of instrument, spacecraft, or structure sclkdp : Encoded spacecraft clock time tol : Time tolerance ref : Reference frame Outputs Returns  nothing  if the requested pointing is not available or cmat : C-matrix pointing data av : Angular velocity vector clkout : Output encoded spacecraft clock time References NAIF Documentation source"},{"id":760,"pagetitle":"API","title":"SPICE.cklpf","ref":"/previews/PR43/SPICE/stable/api/#SPICE.cklpf-Tuple{Any}","content":" SPICE.cklpf  —  Method . cklpf(filename) Load a CK pointing file for use by the CK readers.  Return that file's handle, to be used by other CK routines to refer to the file. Arguments filename : Name of the CK file to be loaded Output Loaded file's handle References NAIF Documentation source"},{"id":761,"pagetitle":"API","title":"SPICE.ckobj!","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ckobj!-Tuple{Any,Any}","content":" SPICE.ckobj!  —  Method . ckobj!(ck, ids) Find the set of ID codes of all objects in a specified CK file. Arguments ck : Name of CK file ids : Set of ID codes of objects in CK file. Data already present in    ids  will be combined with ID code set found for the file  ck . References NAIF Documentation source"},{"id":762,"pagetitle":"API","title":"SPICE.ckobj","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ckobj-Tuple{Any}","content":" SPICE.ckobj  —  Method . ckobj(ck) Find the set of ID codes of all objects in a specified CK file. Arguments ck : Name of CK file Output Set of ID codes of objects in CK file. References NAIF Documentation source"},{"id":763,"pagetitle":"API","title":"SPICE.ckopn","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ckopn","content":" SPICE.ckopn  —  Function . ckopn(fname, ifname=\"CK_file\", ncomch=0) Open a new CK file, returning the handle of the opened file. Arguments fname : The name of the CK file to be opened ifname : The internal filename for the CK (default: \"CK_file\") ncomch : The number of characters to reserve for comments (default: 0) Output handle : The handle of the opened CK file References NAIF Documentation source"},{"id":764,"pagetitle":"API","title":"SPICE.ckupf","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ckupf-Tuple{Any}","content":" SPICE.ckupf  —  Method . ckupf(handle) Unload a CK pointing file so that it will no longer be searched by the readers. Arguments handle : Handle of CK file to be unloaded References NAIF Documentation source"},{"id":765,"pagetitle":"API","title":"SPICE.ckw01","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ckw01","content":" SPICE.ckw01  —  Function . ckw01(handle, begtim, endtim, inst, ref, segid, sclkdp, quats, avvs=[zeros(3)]) Add a type 1 segment to a C-kernel. Arguments handle : Handle of an open CK file begtim : The beginning encoded SCLK of the segment endtim : The ending encoded SCLK of the segment inst : The NAIF instrument ID code ref : The reference frame of the segment segid : Segment identifier sclkdp : Encoded SCLK times quats : Quaternions representing instrument pointing avvs : Angular velocity vectors (optional) References NAIF Documentation source"},{"id":766,"pagetitle":"API","title":"SPICE.ckw02","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ckw02-NTuple{11,Any}","content":" SPICE.ckw02  —  Method . ckw02(handle, begtim, endtim, inst, ref, segid, start, stop, quats, avvs, rates) Write a type 2 segment to a C-kernel. Arguments handle : Handle of an open CK file begtim : The beginning encoded SCLK of the segment endtim : The ending encoded SCLK of the segment inst : The NAIF instrument ID code ref : The reference frame of the segment segid : Segment identifier start : Encoded SCLK interval start times stop : Encoded SCLK interval stop times quats : Quaternions representing instrument pointing avvs : Angular velocity vectors rates : Number of seconds per tick for each interval References NAIF Documentation source"},{"id":767,"pagetitle":"API","title":"SPICE.ckw03","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ckw03","content":" SPICE.ckw03  —  Function . ckw03(handle, begtim, endtim, inst, ref, segid, sclkdp, quats, starts, avvs=[zeros(3)]) Add a type 3 segment to a C-kernel. Arguments handle : Handle of an open CK file begtim : The beginning encoded SCLK of the segment endtim : The ending encoded SCLK of the segment inst : The NAIF instrument ID code ref : The reference frame of the segment segid : Segment identifier sclkdp : Encoded SCLK times quats : Quaternions representing instrument pointing starts : Encoded SCLK interval start times avvs : Angular velocity vectors (optional) References NAIF Documentation source"},{"id":768,"pagetitle":"API","title":"SPICE.ckw05","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ckw05-NTuple{14,Any}","content":" SPICE.ckw05  —  Method . ckw05(handle, subtyp, degree, begtim, endtim, inst, ref, avflag, segid, sclkdp, packts,\n      rate, nints, starts) Write a type 5 segment to a CK file. Arguments handle : Handle of an open CK file subtyp : CK type 5 subtype code degree : Degree of interpolating polynomials begtim : The beginning encoded SCLK of the segment endtim : The ending encoded SCLK of the segment inst : The NAIF instrument ID code ref : The reference frame of the segment avflag : True if the segment will contain angular velocity segid : Segment identifier sclkdp : Encoded SCLK times packts : Array of packets rate : Nominal SCLK rate in seconds per tick nints : Number of intervals starts : Encoded SCLK interval start times References NAIF Documentation source"},{"id":769,"pagetitle":"API","title":"SPICE.cleard","ref":"/previews/PR43/SPICE/stable/api/#SPICE.cleard","content":" SPICE.cleard  —  Function . cleard(array) Deprecated Use  empty!(array)  instead. source"},{"id":770,"pagetitle":"API","title":"SPICE.clight","ref":"/previews/PR43/SPICE/stable/api/#SPICE.clight-Tuple{}","content":" SPICE.clight  —  Method . clight() Returns the speed of light in vacuo (km/sec). References NAIF Documentation source"},{"id":771,"pagetitle":"API","title":"SPICE.clpool","ref":"/previews/PR43/SPICE/stable/api/#SPICE.clpool-Tuple{}","content":" SPICE.clpool  —  Method . clpool() Remove all variables from the kernel pool. Watches on kernel variables are retained. References NAIF Documentation source"},{"id":772,"pagetitle":"API","title":"SPICE.cmprss","ref":"/previews/PR43/SPICE/stable/api/#SPICE.cmprss-Tuple{Any,Any,Any}","content":" SPICE.cmprss  —  Method . cmprss(delim, n, input) Compress a character string by removing occurrences of more than  n  consecutive occurrences of a specified character. Arguments delim : Delimiter to be compressed n : Maximum consecutive occurrences of delim input : Input string Output Returns the compressed string. References NAIF Documentation source"},{"id":773,"pagetitle":"API","title":"SPICE.cnmfrm","ref":"/previews/PR43/SPICE/stable/api/#SPICE.cnmfrm","content":" SPICE.cnmfrm  —  Function . cnmfrm(cname) Retrieve frame ID code and name to associate with an object. Arguments cname : Name of the object to find a frame for Output Returns a tuple of the ID code and the name of the frame associated with  cname  or  nothing  if no frame is found. References NAIF Documentation source"},{"id":774,"pagetitle":"API","title":"SPICE.conics","ref":"/previews/PR43/SPICE/stable/api/#SPICE.conics-Tuple{Any,Any}","content":" SPICE.conics  —  Method . conics(elts, et) Determine the state (position, velocity) of an orbiting body from a set of elliptic, hyperbolic, or parabolic orbital elements. Arguments elts : Conic elements et : Input time Output Returns the state of orbiting body at  et . References NAIF Documentation source"},{"id":775,"pagetitle":"API","title":"SPICE.convrt","ref":"/previews/PR43/SPICE/stable/api/#SPICE.convrt-Tuple{Any,Any,Any}","content":" SPICE.convrt  —  Method . convrt(x, in, out) Take a measurement  x , the units associated with  x , and units to which  x  should be converted; return  y  - the value of the measurement in the output units. Arguments x : Number representing a measurement in some units in : The units in which x is measured out : Desired units for the measurement Output Returns the measurement in the desired units. References NAIF Documentation source"},{"id":776,"pagetitle":"API","title":"SPICE.cpos","ref":"/previews/PR43/SPICE/stable/api/#SPICE.cpos-Tuple{Any,Any,Any}","content":" SPICE.cpos  —  Method . cpos(str, chars, start) Find the first occurrence in a string of a character belonging to a collection of characters, starting at a specified location, searching forward. Arguments str : Any character string chars : A collection of characters start : Position to begin looking for one of chars Output Returns the index of the first character of  str  that is one of the characters in string  chars . Returns -1 if none of the characters was found. References NAIF Documentation source"},{"id":777,"pagetitle":"API","title":"SPICE.cposr","ref":"/previews/PR43/SPICE/stable/api/#SPICE.cposr-Tuple{Any,Any,Any}","content":" SPICE.cposr  —  Method . cposr(str, chars, start) Find the first occurrence in a string of a character belonging to a collection of characters, starting at a specified location, searching in reverse. Arguments str : Any character string chars : A collection of characters start : Position to begin looking for one of chars Output Returns the index of the last character of  str  that is one of the characters in string  chars . Returns -1 if none of the characters was found. References NAIF Documentation source"},{"id":778,"pagetitle":"API","title":"SPICE.cvpool","ref":"/previews/PR43/SPICE/stable/api/#SPICE.cvpool-Tuple{Any}","content":" SPICE.cvpool  —  Method . cvpool(agent) Indicate whether or not any watched kernel variables that have a specified agent on their notification list have been updated. Arguments agent : Name of the agent to check for notices Output Returns  true  if variables for  agent  have been updated. References NAIF Documentation source"},{"id":779,"pagetitle":"API","title":"SPICE.cyllat","ref":"/previews/PR43/SPICE/stable/api/#SPICE.cyllat-Tuple{Any,Any,Any}","content":" SPICE.cyllat  —  Method . cyllat(r, lonc, z) Convert from cylindrical to latitudinal coordinates. Arguments r : Distance of point from z axis lonc : Cylindrical angle of point from XZ plane (radians) z : Height of point above XY plane Output radius : Radius lon : Longitude (radians) lat : Latitude (radians) References NAIF Documentation source"},{"id":780,"pagetitle":"API","title":"SPICE.cylrec","ref":"/previews/PR43/SPICE/stable/api/#SPICE.cylrec-Tuple{Any,Any,Any}","content":" SPICE.cylrec  —  Method . cylrec(r, lon, z) Convert from cylindrical to rectangular coordinates. Arguments r : Distance of the point of interest from z axis lon : Cylindrical angle (in radians) of the point of interest from XZ plane z : Height of the point above XY plane Output Returns rectangular coordinates of the point of interest. References NAIF Documentation source"},{"id":781,"pagetitle":"API","title":"SPICE.cylsph","ref":"/previews/PR43/SPICE/stable/api/#SPICE.cylsph-Tuple{Any,Any,Any}","content":" SPICE.cylsph  —  Method . cylsph(r, lonc, z) Convert from cylindrical to spherical coordinates. Arguments r : Distance of point from z axis lonc : Angle (radians) of point from XZ plane z : Height of point above XY plane Output radius : Distance of the point from the origin colat : Polar angle (co-latitude in radians) lon : Azimuthal angle (longitude) References NAIF Documentation source"},{"id":782,"pagetitle":"API","title":"SPICE.dafac","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dafac-Tuple{Any,Any}","content":" SPICE.dafac  —  Method . dafac(handle, buffer) Add comments from a buffer of character strings to the comment area of a binary DAF file, appending them to any comments which are already present in the file's comment area. Arguments handle : Handle of a DAF opened with write access buffer : Buffer of comments to put into the comment area References NAIF Documentation source"},{"id":783,"pagetitle":"API","title":"SPICE.dafbbs","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dafbbs-Tuple{Any}","content":" SPICE.dafbbs  —  Method . dafbbs(handle) Begin a backward search for arrays in a DAF. Arguments handle : Handle of DAF to be searched References NAIF Documentation source"},{"id":784,"pagetitle":"API","title":"SPICE.dafbfs","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dafbfs-Tuple{Any}","content":" SPICE.dafbfs  —  Method . dafbfs(handle) Begin a forward search for arrays in a DAF. Arguments handle : Handle of DAF to be searched References NAIF Documentation source"},{"id":785,"pagetitle":"API","title":"SPICE.dafcls","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dafcls-Tuple{Any}","content":" SPICE.dafcls  —  Method . dafcls(handle) Close the DAF associated with a given handle. Arguments handle : Handle of DAF to be closed Output Returns the handle of the closed file. References NAIF Documentation source"},{"id":786,"pagetitle":"API","title":"SPICE.dafcs","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dafcs-Tuple{Any}","content":" SPICE.dafcs  —  Method . dafcs(handle) Select a DAF that already has a search in progress as the one to continue searching. Arguments handle : Handle of DAF to continue searching References NAIF Documentation source"},{"id":787,"pagetitle":"API","title":"SPICE.dafdc","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dafdc-Tuple{Any}","content":" SPICE.dafdc  —  Method . dafdc(handle) Delete the entire comment area of a specified DAF file. Arguments handle : The handle of a binary DAF opened for writing References NAIF Documentation source"},{"id":788,"pagetitle":"API","title":"SPICE.dafec","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dafec-Tuple{Any}","content":" SPICE.dafec  —  Method . dafec(handle; bufsiz=256, lenout=1024) Extract comments from the comment area of a binary DAF. Arguments handle : Handle of binary DAF opened with read access bufsiz : Maximum size, in lines, of buffer (default: 256) lenout : Length of strings in output buffer (default: 1024) Output Returns a buffer where extracted comment lines are placed. References NAIF Documentation source"},{"id":789,"pagetitle":"API","title":"SPICE.daffna","ref":"/previews/PR43/SPICE/stable/api/#SPICE.daffna-Tuple{}","content":" SPICE.daffna  —  Method . daffna() Find the next (forward) array in the current DAF. Output Returns  true  if an array was found. References NAIF Documentation source"},{"id":790,"pagetitle":"API","title":"SPICE.daffpa","ref":"/previews/PR43/SPICE/stable/api/#SPICE.daffpa-Tuple{}","content":" SPICE.daffpa  —  Method . daffpa() Find the previous (backward) array in the current DAF. Output Returns  true  if an array was found. References NAIF Documentation source"},{"id":791,"pagetitle":"API","title":"SPICE.dafgda","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dafgda-Tuple{Any,Any,Any}","content":" SPICE.dafgda  —  Method . dafgda(handle, start, stop) Read the double precision data bounded by two addresses within a DAF. Arguments handle : Handle of a DAF start, stop : Initial, final address within file Output Returns the data contained between  start  and  stop . References NAIF Documentation source"},{"id":792,"pagetitle":"API","title":"SPICE.dafgh","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dafgh-Tuple{}","content":" SPICE.dafgh  —  Method . dafgh() Return (get) the handle of the DAF currently being searched. References NAIF Documentation source"},{"id":793,"pagetitle":"API","title":"SPICE.dafgn","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dafgn","content":" SPICE.dafgn  —  Function . dafgn(lenout=128) Return (get) the name for the current array in the current DAF. Arguments lenout : Length of array name string (default: 128) Output Returns the name of the current array. References NAIF Documentation source"},{"id":794,"pagetitle":"API","title":"SPICE.dafgs","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dafgs","content":" SPICE.dafgs  —  Function . dafgs(lenout=125) Return (get) the summary for the current array in the current DAF. Arguments lenout : The maximum length of the summary array Output Returns the summary for the current array. References NAIF Documentation source"},{"id":795,"pagetitle":"API","title":"SPICE.dafgsr","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dafgsr-NTuple{4,Any}","content":" SPICE.dafgsr  —  Method . Read a portion of the contents of a summary record in a DAF file. Arguments handle : Handle of DAF recno : Record number start : First word to read from record stop : Last word to read from record Output Returns the contents of the record or  nothing  if none was found. References NAIF Documentation source"},{"id":796,"pagetitle":"API","title":"SPICE.dafopr","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dafopr-Tuple{Any}","content":" SPICE.dafopr  —  Method . dafopr(fname) Open a DAF for subsequent read requests. Arguments fname : Name of DAF to be opened Output Returns the handle assigned to DAF. References NAIF Documentation source"},{"id":797,"pagetitle":"API","title":"SPICE.dafopw","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dafopw-Tuple{Any}","content":" SPICE.dafopw  —  Method . dafopw(fname) Open a DAF for subsequent write requests. Arguments fname : Name of DAF to be opened Output Returns the handle assigned to DAF. References NAIF Documentation source"},{"id":798,"pagetitle":"API","title":"SPICE.dafps","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dafps-Tuple{Any,Any}","content":" SPICE.dafps  —  Method . dafps(dc, ic) Pack (assemble) an array summary from its double precision and integer components. Arguments dc : Double precision components ic : Integer components Output Returns the array summary. References NAIF Documentation source"},{"id":799,"pagetitle":"API","title":"SPICE.dafrfr","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dafrfr","content":" SPICE.dafrfr  —  Function . dafrfr(handle, lenout=128) Read the contents of the file record of a DAF. Arguments handle : Handle of an open DAF file lenout : Available room in the output string `ifname' (default: 128) Output nd : Number of double precision components in summaries ni : Number of integer components in summaries ifname : Internal file name fward : Forward list pointer bward : Backward list pointer free : Free address pointer References NAIF Documentation source"},{"id":800,"pagetitle":"API","title":"SPICE.dafrs","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dafrs-Tuple{Any}","content":" SPICE.dafrs  —  Method . dafrs(sum) Change the summary for the current array in the current DAF. Arguments sum : New summary for current array References NAIF Documentation source"},{"id":801,"pagetitle":"API","title":"SPICE.dafus","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dafus-Tuple{Any,Any,Any}","content":" SPICE.dafus  —  Method . dafus(sum, nd, ni) Unpack an array summary into its double precision and integer components. Arguments sum : Array summary nd : Number of double precision components ni : Number of integer components Output dc : Double precision components ic : Integer components References NAIF Documentation source"},{"id":802,"pagetitle":"API","title":"SPICE.dasac","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dasac-Tuple{Any,Any}","content":" SPICE.dasac  —  Method . dasac(handle, buffer) Add comments from a buffer of character strings to the comment area of a binary DAS file, appending them to any comments which are already present in the file's comment area. Arguments handle : Handle of a DAS opened with write access buffer : Buffer of comments to put into the comment area References NAIF Documentation source"},{"id":803,"pagetitle":"API","title":"SPICE.dascls","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dascls-Tuple{Any}","content":" SPICE.dascls  —  Method . dascls(handle) Close the DAS associated with a given handle. Arguments handle : Handle of DAS to be closed Output Returns the handle of the closed file. References NAIF Documentation source"},{"id":804,"pagetitle":"API","title":"SPICE.dasdc","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dasdc-Tuple{Any}","content":" SPICE.dasdc  —  Method . dasdc(handle) Delete the entire comment area of a specified DAS file. Arguments handle : The handle of a binary DAS opened for writing References NAIF Documentation source"},{"id":805,"pagetitle":"API","title":"SPICE.dasec","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dasec-Tuple{Any}","content":" SPICE.dasec  —  Method . dasec(handle; bufsiz=256, lenout=1024) Extract comments from the comment area of a binary DAS. Arguments handle : Handle of binary DAS opened with read access bufsiz : Maximum size, in lines, of buffer (default: 256) lenout : Length of strings in output buffer (default: 1024) Output Returns a buffer where extracted comment lines are placed. References NAIF Documentation source"},{"id":806,"pagetitle":"API","title":"SPICE.dashfn","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dashfn","content":" SPICE.dashfn  —  Function . dashfn(handle, namelen=256) Return the name of the DAS file associated with a handle. Arguments handle : Handle of a DAS file namlen : Length of output file name string (default: 256) Output Returns the corresponding file name. References NAIF Documentation source"},{"id":807,"pagetitle":"API","title":"SPICE.dasopr","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dasopr-Tuple{Any}","content":" SPICE.dasopr  —  Method . dasopr(fname) Open a DAS for subsequent read requests. Arguments fname : Name of DAS to be opened Output Returns the handle assigned to DAS. References NAIF Documentation source"},{"id":808,"pagetitle":"API","title":"SPICE.dasopw","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dasopw-Tuple{Any}","content":" SPICE.dasopw  —  Method . dasopw(fname) Open a DAS for subsequent write requests. Arguments fname : Name of DAS to be opened Output Returns the handle assigned to DAS. References NAIF Documentation source"},{"id":809,"pagetitle":"API","title":"SPICE.dasrfr","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dasrfr","content":" SPICE.dasrfr  —  Function . dasrfr(handle, idwlen=128, ifnlen=256) Read the contents of the file record of a DAS. Arguments handle : DAS file handle idwlen : Length of ID word string (default: 128) ifnlen : Length of internal file name string (default: 256) Output idword : ID word ifname : DAS internal file name nresvr : Number of reserved records in file nresvc : Number of characters in use in reserved records area ncomr : Number of comment records in file ncomc : Number of characters in use in comment area References NAIF Documentation source"},{"id":810,"pagetitle":"API","title":"SPICE.dcyldr","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dcyldr-Tuple{Any,Any,Any}","content":" SPICE.dcyldr  —  Method . dcyldr(x, y, z) Compute the Jacobian of the transformation from rectangular to cylindrical coordinates. Arguments x : X-coordinate of point y : Y-coordinate of point z : Z-coordinate of point Output Returns the matrix of partial derivatives. References NAIF Documentation source"},{"id":811,"pagetitle":"API","title":"SPICE.deltet","ref":"/previews/PR43/SPICE/stable/api/#SPICE.deltet-Tuple{Any,Any}","content":" SPICE.deltet  —  Method . deltet(epoch, eptype) Return the value of ΔET (ET-UTC) for an input epoch. Arguments epoch : Input epoch (seconds past J2000) eptype : Type of input epoch (\"UTC\" or \"ET\") Output Returns ΔET (ET-UTC) at input epoch. References NAIF Documentation source"},{"id":812,"pagetitle":"API","title":"SPICE.dgeodr","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dgeodr-NTuple{5,Any}","content":" SPICE.dgeodr  —  Method . dgeodr(x, y, z, re, f) Compute the Jacobian of the transformation from rectangular to geodetic coordinates. Arguments x : X-coordinate of point y : Y-coordinate of point z : Z-coordinate of point re : Equatorial radius of the reference spheroid f : Flattening coefficient Output Returns the matrix of partial derivatives. References NAIF Documentation source"},{"id":813,"pagetitle":"API","title":"SPICE.diags2","ref":"/previews/PR43/SPICE/stable/api/#SPICE.diags2-Tuple{Any}","content":" SPICE.diags2  —  Method . diags2(symmat) Diagonalize a symmetric 2x2 matrix. Arguments symmat : A symmetric 2x2 matrix Output diag : A diagonal matrix similar to  symmat rotate : A rotation used as the similarity transformation References NAIF Documentation source"},{"id":814,"pagetitle":"API","title":"SPICE.dlabbs","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dlabbs-Tuple{Any}","content":" SPICE.dlabbs  —  Method . dlabbs(handle) Begin a backward segment search in a DLA file. Arguments handle : Handle of open DLA file Output Returns the descriptor of the last segment in the DLA file or  nothing  if none was found. References NAIF Documentation source"},{"id":815,"pagetitle":"API","title":"SPICE.dlabfs","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dlabfs-Tuple{Any}","content":" SPICE.dlabfs  —  Method . dlabfs(handle) Begin a forward segment search in a DLA file. Arguments handle : Handle of open DLA file Output Returns the descriptor of the first segment in the DLA file or  nothing  if none was found. References NAIF Documentation source"},{"id":816,"pagetitle":"API","title":"SPICE.dlafns","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dlafns-Tuple{Any,Any}","content":" SPICE.dlafns  —  Method . dlafns(handle, descr) Find the segment following a specified segment in a DLA file. Arguments handle : Handle of open DLA file descr : Descriptor of a DLA segment Output Returns the descriptor of the next segment in the DLA file or  nothing  if none was found. References NAIF Documentation source"},{"id":817,"pagetitle":"API","title":"SPICE.dlafps","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dlafps-Tuple{Any,Any}","content":" SPICE.dlafps  —  Method . dlafps(handle, descr) Find the segment preceding a specified segment in a DLA file. Arguments handle : Handle of open DLA file descr : Descriptor of a DLA segment Output Returns the descriptor of the previous segment in the DLA file or  nothing  if none was found. References NAIF Documentation source"},{"id":818,"pagetitle":"API","title":"SPICE.dlatdr","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dlatdr-Tuple{Any,Any,Any}","content":" SPICE.dlatdr  —  Method . dlatdr(x, y, z) Compute the Jacobian of the transformation from rectangular to latitudinal coordinates. Arguments x : X-coordinate of point y : Y-coordinate of point z : Z-coordinate of point Output Returns the matrix of partial derivatives. References NAIF Documentation source"},{"id":819,"pagetitle":"API","title":"SPICE.dp2hx","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dp2hx","content":" SPICE.dp2hx  —  Function . dp2hx(number, lenout=128) Convert a double precision number to an equivalent character string using base 16 \"scientific notation.\" Arguments number : Number to be converted lenout : Available space for output string Output Returns the equivalent character string, left justified. References NAIF Documentation source"},{"id":820,"pagetitle":"API","title":"SPICE.dpgrdr","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dpgrdr-NTuple{6,Any}","content":" SPICE.dpgrdr  —  Method . dpgrdr(x, y, z, re, f) Compute the Jacobian of the transformation from rectangular to planetographic coordinates. Arguments body : Body with which coordinate system is associated x : X-coordinate of point y : Y-coordinate of point z : Z-coordinate of point re : Equatorial radius of the reference spheroid f : Flattening coefficient Output Returns the matrix of partial derivatives. References NAIF Documentation source"},{"id":821,"pagetitle":"API","title":"SPICE.dpmax","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dpmax","content":" SPICE.dpmax  —  Function . dpmax() Deprecated Use  prevfloat(typemax(Float64))  instead. source"},{"id":822,"pagetitle":"API","title":"SPICE.dpmin","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dpmin","content":" SPICE.dpmin  —  Function . dpmin() Deprecated Use  nextfloat(typemin(Float64))  instead. source"},{"id":823,"pagetitle":"API","title":"SPICE.dpr","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dpr","content":" SPICE.dpr  —  Function . dpr() Deprecated Use  rad2deg(1.0)  instead. source"},{"id":824,"pagetitle":"API","title":"SPICE.drdcyl","ref":"/previews/PR43/SPICE/stable/api/#SPICE.drdcyl-Tuple{Any,Any,Any}","content":" SPICE.drdcyl  —  Method . drdcyl(r, lon, z) Compute the Jacobian of the transformation from cylindrical to rectangular coordinates. Arguments r : Distance of a point from the origin lon : Angle of the point from the xz plane in radians z : Height of the point above the xy plane Output Returns the matrix of partial derivatives. References NAIF Documentation source"},{"id":825,"pagetitle":"API","title":"SPICE.drdgeo","ref":"/previews/PR43/SPICE/stable/api/#SPICE.drdgeo-NTuple{5,Any}","content":" SPICE.drdgeo  —  Method . drdgeo(lon, lat, alt, re, f) Compute the Jacobian of the transformation from geodetic to rectangular coordinates. Arguments lon : Geodetic longitude of point (radians) lat : Geodetic latitude of point (radians) alt : Altitude of point above the reference spheroid re : Equatorial radius of the reference spheroid f : Flattening coefficient Output Returns the matrix of partial derivatives. References NAIF Documentation source"},{"id":826,"pagetitle":"API","title":"SPICE.drdlat","ref":"/previews/PR43/SPICE/stable/api/#SPICE.drdlat-Tuple{Any,Any,Any}","content":" SPICE.drdlat  —  Method . drdlat(radius, lon, lat) Compute the Jacobian of the transformation from latitudinal to rectangular coordinates. Arguments radius : Distance of a point from the origin lon : Angle of the point from the XZ plane in radians lat : Angle of the point from the XY plane in radians Output Returns the matrix of partial derivatives. References NAIF Documentation source"},{"id":827,"pagetitle":"API","title":"SPICE.drdpgr","ref":"/previews/PR43/SPICE/stable/api/#SPICE.drdpgr-NTuple{6,Any}","content":" SPICE.drdpgr  —  Method . drdpgr(body, lon, lat, alt, re, f) Compute the Jacobian matrix of the transformation from planetographic to rectangular coordinates. Arguments body : Name of body with which coordinates are associated lon : Planetographic longitude of a point (radians) lat : Planetographic latitude of a point (radians) alt : Altitude of a point above reference spheroid re : Equatorial radius of the reference spheroid f : Flattening coefficient Output Returns the matrix of partial derivatives. References NAIF Documentation source"},{"id":828,"pagetitle":"API","title":"SPICE.drdsph","ref":"/previews/PR43/SPICE/stable/api/#SPICE.drdsph-Tuple{Any,Any,Any}","content":" SPICE.drdsph  —  Method . drdsph(r, colat, lon) Compute the Jacobian of the transformation from latitudinal to rectangular coordinates. Arguments r : Distance of a point from the origin colat : Angle of the point from the positive z-axis lon : Angle of the point from the xy plane Output Returns the matrix of partial derivatives. References NAIF Documentation source"},{"id":829,"pagetitle":"API","title":"SPICE.dskb02","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dskb02-Tuple{Any,Any}","content":" SPICE.dskb02  —  Method . dskb02(handle, dladsc) Return bookkeeping data from a DSK type 2 segment. Arguments handle : DSK file handle dladsc : DLA descriptor Output nv : Number of vertices in model np : Number of plates in model nvxtot : Number of voxels in fine grid vtxbds : Vertex bounds voxsiz : Fine voxel edge length voxori : Fine voxel grid origin vgrext : Fine voxel grid exent cgscal : Coarse voxel grid scale vtxnpl : Size of vertex-plate correspondence list voxnpt : Size of voxel-plate pointer list voxnpl : Size of voxel-plate correspondence list References NAIF Documentation source"},{"id":830,"pagetitle":"API","title":"SPICE.dskcls","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dskcls","content":" SPICE.dskcls  —  Function . dskcls(handle, optmiz=true) Close a DSK file. Arguments handle : Handle assigned to the opened DSK file optmiz : Flag indicating whether to segregate the DSK (default:  true ) References NAIF Documentation source"},{"id":831,"pagetitle":"API","title":"SPICE.dskd02","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dskd02-NTuple{5,Any}","content":" SPICE.dskd02  —  Method . dskd02(handle, dladsc, item, start, room) Fetch double precision data from a type 2 DSK segment. Arguments handle : DSK file handle dladsc : DLA descriptor item : Keyword identifying item to fetch start : Start index room : Amount of room in output array Output Returns an array containing the requested item. References NAIF Documentation source"},{"id":832,"pagetitle":"API","title":"SPICE.dskgd","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dskgd-Tuple{Any,Any}","content":" SPICE.dskgd  —  Method . dskgd(handle, dladsc) Return the DSK descriptor from a DSK segment identified by a DAS handle and DLA descriptor. Arguments handle : Handle of a DSK file dladsc : DLA segment descriptor Output Returns the DSK segment descriptor. References NAIF Documentation source"},{"id":833,"pagetitle":"API","title":"SPICE.dskgtl","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dskgtl-Tuple{Any}","content":" SPICE.dskgtl  —  Method . dskgtl(keywrd) Retrieve the value of a specified DSK tolerance or margin parameter. Arguments keywrd : Code specifying parameter to retrieve Output Returns the value of the parameter. References NAIF Documentation source"},{"id":834,"pagetitle":"API","title":"SPICE.dski02","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dski02-NTuple{5,Any}","content":" SPICE.dski02  —  Method . dski02(handle, dladsc, item, start, room) Fetch integer data from a type 2 DSK segment. Arguments handle : DSK file handle dladsc : DLA descriptor item : Keyword identifying item to fetch start : Start index room : Amount of room in output array Output Returns an array containing the requested item. References NAIF Documentation source"},{"id":835,"pagetitle":"API","title":"SPICE.dskmi2","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dskmi2-NTuple{9,Any}","content":" SPICE.dskmi2  —  Method . dskmi2(vrtces, plates, finscl, corscl, worksz, voxpsz, voxlsz, makvtl, spaisz) Make spatial index for a DSK type 2 segment. Arguments vrtces : Vertices plates : Plates finscl : Fine voxel scale corscl : Coarse voxel scale worksz : Workspace size voxpsz : Voxel-plate pointer array size voxlsz : Voxel-plate list array size makvtl : Vertex-plate list flag spxisz : Spatial index integer component size Output spaixd : Double precision component of spatial index. spaixi : Integer component of spatial index. References NAIF Documentation source"},{"id":836,"pagetitle":"API","title":"SPICE.dskn02","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dskn02-Tuple{Any,Any,Any}","content":" SPICE.dskn02  —  Method . dskn02(handle, dladsc, plid) Compute the unit normal vector for a specified plate from a type 2 DSK segment. Arguments handle : DSK file handle dladsc : DLA descriptor plid : Plate ID Output Return the plate's unit normal vector. References NAIF Documentation source"},{"id":837,"pagetitle":"API","title":"SPICE.dskobj!","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dskobj!-Tuple{Any,Any}","content":" SPICE.dskobj!  —  Method . dskobj!(set, dsk) Find the set of body ID codes of all objects for which topographic data are provided in a specified DSK file. Arguments dsk : Name of DSK file set  or  len : Either a preallocated  SpiceIntCell  or the  size  of the output set. Output Returns the set of ID codes of objects in the DSK file. References NAIF Documentation source"},{"id":838,"pagetitle":"API","title":"SPICE.dskopn","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dskopn-Tuple{Any,Any,Any}","content":" SPICE.dskopn  —  Method . dskopn(fname, ifname, ncomch) Open a new DSK file for subsequent write operations. Arguments fname : Name of a DSK file to be opened ifname : Internal file name ncomch : Number of comment characters to allocate Output Returns the handle assigned to the opened DSK file. References NAIF Documentation source"},{"id":839,"pagetitle":"API","title":"SPICE.dskp02","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dskp02-NTuple{4,Any}","content":" SPICE.dskp02  —  Method . dskp02(handle, dladsc, start, room) Fetch triangular plates from a type 2 DSK segment. Arguments handle : DSK file handle dladsc : DLA descriptor start : Start index room : Amount of room in output array Output Returns an array of plates. References NAIF Documentation source"},{"id":840,"pagetitle":"API","title":"SPICE.dskrb2","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dskrb2-NTuple{4,Any}","content":" SPICE.dskrb2  —  Method . dskrb2(vrtces, plates, corsys, corpar) Determine range bounds for a set of triangular plates to be stored in a type 2 DSK segment. Arguments vrtces : Vertices plates : Plates corsys : DSK coordinate system code corpar : DSK coordinate system parameters Output mncor3 : Lower bound on range of third coordinate mxcor3 : Upper bound on range of third coordinate References NAIF Documentation source"},{"id":841,"pagetitle":"API","title":"SPICE.dsksrf!","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dsksrf!-Tuple{Any,Any,Any}","content":" SPICE.dsksrf!  —  Method . dsksrf!(set, dsk) Find the set of surface ID codes of all objects for which topographic data are provided in a specified DSK file. Arguments dsk : Name of DSK file set  or  len : Either a preallocated  SpiceIntCell  or the  size  of the output set. Output Returns the set of ID codes of surfaces in the DSK file. References NAIF Documentation source"},{"id":842,"pagetitle":"API","title":"SPICE.dskstl","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dskstl-Tuple{Any,Any}","content":" SPICE.dskstl  —  Method . dskstl(keywrd) Set the value of a specified DSK tolerance or margin parameter. Arguments keywrd : Code specifying parameter to retrieve dpval : Value of parameter References NAIF Documentation source"},{"id":843,"pagetitle":"API","title":"SPICE.dskv02","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dskv02-NTuple{4,Any}","content":" SPICE.dskv02  —  Method . dskv02(handle, dladsc, start, room) Fetch vertices from a type 2 DSK segment. Arguments handle : DSK file handle dladsc : DLA descriptor start : Start index room : Amount of room in output array Output Returns an array of vertices. References NAIF Documentation source"},{"id":844,"pagetitle":"API","title":"SPICE.dskw02","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dskw02-NTuple{19,Any}","content":" SPICE.dskw02  —  Method . dskw02(handle, center, surfid, dclass, frame, corsys, corpar, mncor1, mxcor1,\n       mncor2, mxcor2, mncor3, mxcor3, first, last, vrtces, plates, spaixd, spaixi) Write a type 2 segment to a DSK file. Arguments handle : Handle assigned to the opened DSK file center : Central body ID code surfid : Surface ID code dclass : Data class frame : Reference frame corsys : Coordinate system code corpar : Coordinate system parameters mncor1 : Minimum value of first coordinate mxcor1 : Maximum value of first coordinate mncor2 : Minimum value of second coordinate mxcor2 : Maximum value of second coordinate mncor3 : Minimum value of third coordinate mxcor3 : Maximum value of third coordinate first : Coverage start time last : Coverage stop time nv : Number of vertices vrtces : Vertices np : Number of plates plates : Plates spaixd : Double precision component of spatial index spaixi : Integer component of spatial index References NAIF Documentation source"},{"id":845,"pagetitle":"API","title":"SPICE.dskx02","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dskx02-NTuple{4,Any}","content":" SPICE.dskx02  —  Method . dskx02(handle, dladsc, vertex, raydir) Determine the plate ID and body-fixed coordinates of the intersection of a specified ray with the surface defined by a type 2 DSK plate model. Arguments handle : Handle of DSK kernel containing plate model dladsc : DLA descriptor of plate model segment vertex : Ray vertex in the body fixed frame raydir : Ray direction in the body fixed frame Output Returns  nothing  if no intercept exists or plid : ID code of the plate intersected by the ray xpt : Intercept References NAIF Documentation source"},{"id":846,"pagetitle":"API","title":"SPICE.dskxsi","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dskxsi","content":" SPICE.dskxsi  —  Function . dskxsi(pri, target, nsurf, srflst, et, fixref, vertex, raydir, maxd=1, maxi=1) Compute a ray-surface intercept using data provided by multiple loaded DSK segments. Return information about the source of the data defining the surface on which the intercept was found: DSK handle, DLA and DSK descriptors, and DSK data type-dependent parameters. Arguments pri : Data prioritization flag target : Target body name srflst : Surface ID list et : Epoch, expressed as seconds past J2000 TDB fixref : Name of target body-fixed reference frame vertex : Vertex of ray raydir : Direction vector of ray maxd : Size of DC array (default: 1) maxi : Size of IC array (default: 1) Output Returns  nothing  if no intercept exists or xpt : Intercept point handle : Handle of segment contributing surface data dladsc : DLA descriptor of segment dskdsc : DSK descriptor of segment dc : Double precision component of source info ic : Integer component of source info References NAIF Documentation source"},{"id":847,"pagetitle":"API","title":"SPICE.dskxv","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dskxv-NTuple{7,Any}","content":" SPICE.dskxv  —  Method . dskxv(pri, target, srflst, et, fixref, nrays, vtxarr, dirarr) Compute ray-surface intercepts for a set of rays, using data provided by multiple loaded DSK segments. Arguments pri : Data prioritization flag target : Target body name srflst : Surface ID list et : Epoch, expressed as seconds past J2000 TDB fixref : Name of target body-fixed reference frame nrays : Number of rays vtxarr : Array of vertices of rays dirarr : Array of direction vectors of rays Output xptarr : Intercept point array fndarr : Found flag array References NAIF Documentation source"},{"id":848,"pagetitle":"API","title":"SPICE.dskz02","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dskz02-Tuple{Any,Any}","content":" SPICE.dskz02  —  Method . dskz02(handle, dladsc) Return plate model size parameters - plate count and vertex count - for a type 2 DSK segment. Arguments handle : DSK file handle dladsc : DLA descriptor Output nv : Number of vertices np : Number of plates References NAIF Documentation source"},{"id":849,"pagetitle":"API","title":"SPICE.dsphdr","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dsphdr-Tuple{Any,Any,Any}","content":" SPICE.dsphdr  —  Method . dsphdr(x, y, z) Compute the Jacobian of the transformation from rectangular to spherical coordinates. Arguments x : X-coordinate of point y : Y-coordinate of point z : Z-coordinate of point Output Returns the matrix of partial derivatives. References NAIF Documentation source"},{"id":850,"pagetitle":"API","title":"SPICE.dtpool","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dtpool-Tuple{Any}","content":" SPICE.dtpool  —  Method . dtpool(name) Return the data about a kernel pool variable. Arguments name : Name of the variable whose value is to be returned Output Returns the tuple  (n ,vartype) . n : Number of values returned for name vartype : Type of the variable :C  if the data is character data :N  if the data is numeric :X  if there is no variable name in the pool References NAIF Documentation source"},{"id":851,"pagetitle":"API","title":"SPICE.ducrss","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ducrss-Tuple{Any,Any}","content":" SPICE.ducrss  —  Method . ducrss(s1, s2) Compute the unit vector parallel to the cross product of two 3-dimensional vectors and the derivative of this unit vector. Arguments s1 : Left hand state for cross product and derivative s2 : Right hand state for cross product and derivative Output Returns the unit vector and derivative of the cross product. References NAIF Documentation source"},{"id":852,"pagetitle":"API","title":"SPICE.dvcrss","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dvcrss-Tuple{Any,Any}","content":" SPICE.dvcrss  —  Method . dvcrss(s1, s2) Compute the cross product of two 3-dimensional vectors and the derivative of this cross product. Arguments s1 : Left hand state for cross product and derivative s2 : Right hand state for cross product and derivative Output Returns the cross product and its derivative. References NAIF Documentation source"},{"id":853,"pagetitle":"API","title":"SPICE.dvdot","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dvdot-Tuple{Any,Any}","content":" SPICE.dvdot  —  Method . dvdot(s1, s2) Compute the derivative of the dot product of two double precision position vectors. Arguments s1 : First state vector in the dot product s2 : Second state vector in the dot product Output Returns the derivative of the dot product  s1 ⋅ s2 . References NAIF Documentation source"},{"id":854,"pagetitle":"API","title":"SPICE.dvhat","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dvhat-Tuple{Any}","content":" SPICE.dvhat  —  Method . dvhat(s1) Find the unit vector corresponding to a state vector and the derivative of the unit vector. Arguments s1 : State to be normalized Output Returns the unit vector  s1 / |s1| , and its time derivative. References NAIF Documentation source"},{"id":855,"pagetitle":"API","title":"SPICE.dvnorm","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dvnorm-Tuple{Any}","content":" SPICE.dvnorm  —  Method . dvnorm(state) Function to calculate the derivative of the norm of a 3-vector. Arguments state : A 6-vector composed of three coordinates and their derivatives. Output Returns the derivative of the norm of  state . References NAIF Documentation source"},{"id":856,"pagetitle":"API","title":"SPICE.dvpool","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dvpool-Tuple{Any}","content":" SPICE.dvpool  —  Method . dvpool(name) Delete a variable from the kernel pool. Arguments name : Name of the kernel variable to be deleted References NAIF Documentation source"},{"id":857,"pagetitle":"API","title":"SPICE.dvsep","ref":"/previews/PR43/SPICE/stable/api/#SPICE.dvsep-Tuple{Any,Any}","content":" SPICE.dvsep  —  Method . dvsep(s1, s2) Calculate the time derivative of the separation angle between two input states,  s1  and  s2 . Arguments s1 : State vector of the first body s2 : State vector of the second  body Output Returns the value of the time derivative of the angular separation between  s1  and  s2 . References NAIF Documentation source"},{"id":858,"pagetitle":"API","title":"SPICE.edlimb","ref":"/previews/PR43/SPICE/stable/api/#SPICE.edlimb-NTuple{4,Any}","content":" SPICE.edlimb  —  Method . edlimb(a, b, c, viewpt) Find the limb of a triaxial ellipsoid, viewed from a specified point. Arguments a : Length of ellipsoid semi-axis lying on the x-axis b : Length of ellipsoid semi-axis lying on the y-axis c : Length of ellipsoid semi-axis lying on the z-axis viewpt : Location of viewing point Output Returns the limb of the ellipsoid as seen from the viewing point. References NAIF Documentation source"},{"id":859,"pagetitle":"API","title":"SPICE.edterm","ref":"/previews/PR43/SPICE/stable/api/#SPICE.edterm-NTuple{8,Any}","content":" SPICE.edterm  —  Method . edterm(trmtyp, source, target, et, fixref, abcorr, obsrvr, npts) Compute a set of points on the umbral or penumbral terminator of a specified target body, where the target shape is modeled as an ellipsoid. Arguments trmtyp : Terminator type source : Light source target : Target body et : Observation epoch fixref : Body-fixed frame associated with target abcorr : Aberration correction obsrvr : Observer npts : Number of points in terminator set Output trgepc : Epoch associated with target center obspos : Position of observer in body-fixed frame trmpts : Terminator point set References NAIF Documentation source"},{"id":860,"pagetitle":"API","title":"SPICE.ekacec","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekacec-NTuple{6,Any}","content":" SPICE.ekacec  —  Method . ekacec(handle, segno, recno, column, cvals, isnull) Add data to a character column in a specified EK record. Arguments handle : EK file handle segno : Index of segment containing record recno : Record to which data is to be added column : Column name cvals : Character values to add to column isnull : Flag indicating whether column entry is null References NAIF Documentation source"},{"id":861,"pagetitle":"API","title":"SPICE.ekaced","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekaced-NTuple{6,Any}","content":" SPICE.ekaced  —  Method . ekaced(handle, segno, recno, column, dvals, isnull) Add data to an double precision column in a specified EK record. Arguments handle : EK file handle segno : Index of segment containing record recno : Record to which data is to be added column : Column name dvals : Double precision values to add to column isnull : Flag indicating whether column entry is null References NAIF Documentation source"},{"id":862,"pagetitle":"API","title":"SPICE.ekacei","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekacei-NTuple{6,Any}","content":" SPICE.ekacei  —  Method . ekacei(handle, segno, recno, column, ivals, isnull) Add data to an integer column in a specified EK record. Arguments handle : EK file handle segno : Index of segment containing record recno : Record to which data is to be added column : Column name ivals : Integer values to add to column isnull : Flag indicating whether column entry is null References NAIF Documentation source"},{"id":863,"pagetitle":"API","title":"SPICE.ekaclc","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekaclc-NTuple{6,Any}","content":" SPICE.ekaclc  —  Method . ekaclc(handle, segno, column, cvals, nlflgs, rcptrs) Add an entire character column to an EK segment. Arguments handle : EK file handle. segno : Number of segment to add column to. column : Column name. cvals : Character values to add to column. nlflgs : Array of null flags for column entries. rcptrs : Record pointers for segment. References NAIF Documentation source"},{"id":864,"pagetitle":"API","title":"SPICE.ekacld","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekacld-NTuple{6,Any}","content":" SPICE.ekacld  —  Method . ekacld(handle, segno, column, dvals, nlflgs, rcptrs) Add an entire double precision column to an EK segment. Arguments handle : EK file handle segno : Number of segment to add column to column : Column name dvals : Double precision values to add to column nlflgs : Array of null flags for column entries rcptrs : Record pointers for segment References NAIF Documentation source"},{"id":865,"pagetitle":"API","title":"SPICE.ekacli","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekacli-NTuple{6,Any}","content":" SPICE.ekacli  —  Method . ekacli(handle, segno, column, ivals, nlflgs, rcptrs) Add an entire integer column to an EK segment. Arguments handle : EK file handle segno : Number of segment to add column to column : Column name ivals : Integer values to add to column nlflgs : Array of null flags for column entries rcptrs : Record pointers for segment References NAIF Documentation source"},{"id":866,"pagetitle":"API","title":"SPICE.ekappr","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekappr-Tuple{Any,Any}","content":" SPICE.ekappr  —  Method . ekappr(handle, segno) Append a new, empty record at the end of a specified E-kernel segment. Arguments handle : File handle segno : Segment number Output Returns the number of appended record. References NAIF Documentation source"},{"id":867,"pagetitle":"API","title":"SPICE.ekbseg","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekbseg-NTuple{4,Any}","content":" SPICE.ekbseg  —  Method . ekbseg(handle, tabnam, cnames, decls) Start a new segment in an E-kernel. Arguments handle : File handle tabnam : Table name cnames : Names of columns decls : Declarations of columns Output Returns the segment number. References NAIF Documentation source"},{"id":868,"pagetitle":"API","title":"SPICE.ekccnt","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekccnt-Tuple{Any}","content":" SPICE.ekccnt  —  Method . ekccnt(table) Return the number of distinct columns in a specified, currently loaded table Arguments table : Name of table Output Returns the count of distinct, currently loaded columns. References NAIF Documentation source"},{"id":869,"pagetitle":"API","title":"SPICE.ekcii","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekcii","content":" SPICE.ekcii  —  Function . ekcii(table, cindex, lenout=256) Return attribute information about a column belonging to a loaded EK table, specifying the column by table and index. Arguments table : Name of table containing column cindex : Index of column whose attributes are to be found lenout : Maximum allowed length of column name (default: 256) Output column : Name of column attdsc : Column attribute descriptor References NAIF Documentation source"},{"id":870,"pagetitle":"API","title":"SPICE.ekcls","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekcls-Tuple{Any}","content":" SPICE.ekcls  —  Method . ekcls(handle) Close an E-kernel. Arguments handle : EK file handle References NAIF Documentation source"},{"id":871,"pagetitle":"API","title":"SPICE.ekdelr","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekdelr-Tuple{Any,Any,Any}","content":" SPICE.ekdelr  —  Method . ekdelr(handle, segno, recno) Delete a specified record from a specified E-kernel segment. Arguments handle : File handle segno : Segment number recno : Record number References NAIF Documentation source"},{"id":872,"pagetitle":"API","title":"SPICE.ekffld","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekffld-Tuple{Any,Any,Any}","content":" SPICE.ekffld  —  Method . ekffld(handle, segno, rcptrs) Complete a fast write operation on a new E-kernel segment. Arguments handle : File handle segno : Segment number rcptrs : Record pointers References NAIF Documentation source"},{"id":873,"pagetitle":"API","title":"SPICE.ekfind","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekfind","content":" SPICE.ekfind  —  Function . ekfind(query, lenout=256) Find E-kernel data that satisfy a set of constraints. Arguments query : Query specifying data to be found. lenout : Declared length of output error message string (default: 256) Output Returns the number of matching rows. References NAIF Documentation source"},{"id":874,"pagetitle":"API","title":"SPICE.ekgc","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekgc","content":" SPICE.ekgc  —  Function . ekgc(selidx, row, elment, lenout=256) Return an element of an entry in a column of character type in a specified row. Arguments selidx : Index of parent column in SELECT clause row : Row to fetch from elment : Index of element, within column entry, to fetch lenout : Maximum length of column element (default: 256) Output Returns the character string element of column entry or  missing  if it was null or  nothing  if the column was not found. References NAIF Documentation source"},{"id":875,"pagetitle":"API","title":"SPICE.ekgd","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekgd-Tuple{Any,Any,Any}","content":" SPICE.ekgd  —  Method . ekgd(selidx, row, element) Return an element of an entry in a column of double precision type in a specified row. Arguments selidx : Index of parent column in SELECT clause row : Row to fetch from elment : Index of element, within column entry, to fetch Output Returns the double precision element of column entry or  missing  if it was null or  nothing  if the column was not found. References NAIF Documentation source"},{"id":876,"pagetitle":"API","title":"SPICE.ekgi","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekgi-Tuple{Any,Any,Any}","content":" SPICE.ekgi  —  Method . ekgi(selidx, row, element) Return an element of an entry in a column of integer type in a specified row. Arguments selidx : Index of parent column in SELECT clause row : Row to fetch from elment : Index of element, within column entry, to fetch Output Returns the integer element of column entry or  missing  if it was null or  nothing  if the column was not found. References NAIF Documentation source"},{"id":877,"pagetitle":"API","title":"SPICE.ekifld","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekifld-NTuple{5,Any}","content":" SPICE.ekifld  —  Method . ekifld(handle, tabnam, nrows, cnames, decls) Initialize a new E-kernel segment to allow fast writing. Arguments handle : File handle tabnam : Table name nrows : Number of rows in the segment cnames : Names of columns decls : Declarations of columns Output segno : Segment number rcptrs : Array of record pointers References NAIF Documentation source"},{"id":878,"pagetitle":"API","title":"SPICE.ekinsr","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekinsr-Tuple{Any,Any,Any}","content":" SPICE.ekinsr  —  Method . ekinsr(handle, segno, recno) Add a new, empty record to a specified E-kernel segment at a specified index. Arguments handle : File handle segno : Segment number recno : Record number References NAIF Documentation source"},{"id":879,"pagetitle":"API","title":"SPICE.eklef","ref":"/previews/PR43/SPICE/stable/api/#SPICE.eklef-Tuple{Any}","content":" SPICE.eklef  —  Method . eklef(fname) Load an EK file, making it accessible to the EK readers. Arguments fname : Name of EK file to load Output Returns the file handle of loaded EK file. References NAIF Documentation source"},{"id":880,"pagetitle":"API","title":"SPICE.eknelt","ref":"/previews/PR43/SPICE/stable/api/#SPICE.eknelt-Tuple{Any,Any}","content":" SPICE.eknelt  —  Method . eknelt(selidx, row) Return the number of elements in a specified column entry in the current row. Arguments selidx : Index of parent column in SELECT clause row : Row containing element Output Returns the number of elements in entry in current row. References NAIF Documentation source"},{"id":881,"pagetitle":"API","title":"SPICE.eknseg","ref":"/previews/PR43/SPICE/stable/api/#SPICE.eknseg-Tuple{Any}","content":" SPICE.eknseg  —  Method . eknseg(handle) Return the number of segments in a specified EK. Arguments handle : EK file handle Output Returns the number of segments in the specified E-kernel. References NAIF Documentation source"},{"id":882,"pagetitle":"API","title":"SPICE.ekntab","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekntab-Tuple{}","content":" SPICE.ekntab  —  Method . ekntab() Return the number of loaded EK tables. References NAIF Documentation source"},{"id":883,"pagetitle":"API","title":"SPICE.ekopn","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekopn-Tuple{Any,Any,Any}","content":" SPICE.ekopn  —  Method . ekopn(fname, ifname, ncomch) Open a new E-kernel file and prepare the file for writing. Arguments fname : Name of EK file ifname : Internal file name ncomch : The number of characters to reserve for comments Output Return the handle attached to the new EK file. References NAIF Documentation source"},{"id":884,"pagetitle":"API","title":"SPICE.ekopr","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekopr-Tuple{Any}","content":" SPICE.ekopr  —  Method . ekopr(fname) Open an existing E-kernel file for reading. Arguments fname : Name of EK file Output Returns the handle attached to the EK file. References NAIF Documentation source"},{"id":885,"pagetitle":"API","title":"SPICE.ekops","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekops-Tuple{}","content":" SPICE.ekops  —  Method . ekops() Open a scratch (temporary) E-kernel file and prepare the file for writing. Output Returns the handle attached to the EK file. References NAIF Documentation source"},{"id":886,"pagetitle":"API","title":"SPICE.ekopw","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekopw-Tuple{Any}","content":" SPICE.ekopw  —  Method . ekopw(fname) Open an existing E-kernel file for writing. Arguments fname : Name of EK file Output Returns the handle attached to the EK file. References NAIF Documentation source"},{"id":887,"pagetitle":"API","title":"SPICE.ekpsel","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekpsel","content":" SPICE.ekpsel  —  Function . ekpsel(query, msglen=256, tablen=256, collen=256) Parse the SELECT clause of an EK query, returning full particulars concerning each selected item. Arguments query : EK query msglen : Available space in the output error message string (default: 256) tablen : Length of strings in `tabs' output array (default: 256) collen : Length of strings in `cols' output array (default: 256) Output xbegs : Begin positions of expressions in SELECT clause xends : End positions of expressions in SELECT clause xtypes : Data types of expressions xclass : Classes of expressions tabs : Names of tables qualifying SELECT columns cols : Names of columns in SELECT clause of query References NAIF Documentation source"},{"id":888,"pagetitle":"API","title":"SPICE.ekrcec","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekrcec","content":" SPICE.ekrcec  —  Function . ekrcec(handle, segno, recno, column, lenout=256, nelts=100) Read data from a character column in a specified EK record. Arguments handle : Handle attached to EK file segno : Index of segment containing record recno : Record from which data is to be read column : Column name lenout : Maximum length of output strings nelts : Maximum number of elements to return (default: 100) Output Returns the character values in column entry or  missing  if they are null. References NAIF Documentation source"},{"id":889,"pagetitle":"API","title":"SPICE.ekrced","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekrced","content":" SPICE.ekrced  —  Function . ekrced(handle, segno, recno, column, nelts=100) Read data from a double precision column in a specified EK record. Arguments handle : Handle attached to EK file segno : Index of segment containing record recno : Record from which data is to be read column : Column name nelts : Maximum number of elements to return (default: 100) Output Returns the values in column entry. References NAIF Documentation source"},{"id":890,"pagetitle":"API","title":"SPICE.ekrcei","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekrcei","content":" SPICE.ekrcei  —  Function . ekrcei(handle, segno, recno, column, nelts=100) Read data from an integer column in a specified EK record. Arguments handle : Handle attached to EK file segno : Index of segment containing record recno : Record from which data is to be read column : Column name nelts : Maximum number of elements to return (default: 100) Output Returns the values in column entry. References NAIF Documentation source"},{"id":891,"pagetitle":"API","title":"SPICE.ekssum","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekssum-Tuple{Any,Any}","content":" SPICE.ekssum  —  Method . ekssum(handle, segno) Return summary information for a specified segment in a specified EK. Arguments handle : Handle of EK segno : Number of segment to be summarized Output Returns the EK segment summary. References NAIF Documentation source"},{"id":892,"pagetitle":"API","title":"SPICE.ektnam","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ektnam","content":" SPICE.ektnam  —  Function . ektnam(n, lenout=256) Return the name of a specified, loaded table. Arguments n : Index of table lenout : Maximum table name length (default: 256) Output Returns the name of table. References NAIF Documentation source"},{"id":893,"pagetitle":"API","title":"SPICE.ekucec","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekucec-NTuple{6,Any}","content":" SPICE.ekucec  —  Method . ekucec(handle, segno, recno, column, cvals, isnull) Update a character column entry in a specified EK record. Arguments handle : EK file handle segno : Index of segment containing record recno : Record to which data is to be updated column : Column name cvals : Character values comprising new column entry isnull : Flag indicating whether column entry is null References NAIF Documentation source"},{"id":894,"pagetitle":"API","title":"SPICE.ekuced","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekuced-NTuple{6,Any}","content":" SPICE.ekuced  —  Method . ekuced(handle, segno, recno, column, dvals, isnull) Update a double precision column entry in a specified EK record. Arguments handle : Handle attached to EK file segno : Index of segment containing record recno : Record in which entry is to be updated column : Column name dvals : Double precision values comprising new column entry isnull : Flag indicating whether column entry is null References NAIF Documentation source"},{"id":895,"pagetitle":"API","title":"SPICE.ekucei","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekucei-NTuple{6,Any}","content":" SPICE.ekucei  —  Method . ekucei(handle, segno, recno, column, dvals, isnull) Update an integer column entry in a specified EK record. Arguments handle : Handle attached to EK file segno : Index of segment containing record recno : Record in which entry is to be updated column : Column name ivals : Integer values comprising new column entry isnull : Flag indicating whether column entry is null References NAIF Documentation source"},{"id":896,"pagetitle":"API","title":"SPICE.ekuef","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ekuef-Tuple{Any}","content":" SPICE.ekuef  —  Method . ekuef(handle) Unload an EK file, making its contents inaccessible to the EK reader routines, and clearing space in order to allow other EK files to be loaded. Arguments handle : Handle of EK file References NAIF Documentation source"},{"id":897,"pagetitle":"API","title":"SPICE.el2cgv","ref":"/previews/PR43/SPICE/stable/api/#SPICE.el2cgv-Tuple{Any}","content":" SPICE.el2cgv  —  Method . Convert an ellipse to a center vector and two generating vectors. The selected generating vectors are semi-axes of the ellipse. Arguments ellipse : An ellipse Output Returns the center and semi-axes of ellipse. References NAIF Documentation source"},{"id":898,"pagetitle":"API","title":"SPICE.elemc","ref":"/previews/PR43/SPICE/stable/api/#SPICE.elemc","content":" SPICE.elemc  —  Function . elem[c/d/i](item, cell) Deprecated Use  item in cell  instead. source"},{"id":899,"pagetitle":"API","title":"SPICE.eqncpv","ref":"/previews/PR43/SPICE/stable/api/#SPICE.eqncpv-NTuple{5,Any}","content":" SPICE.eqncpv  —  Method . eqncpv(et, epoch, eqel, rapol, decpol) Compute the state (position and velocity of an object whose trajectory is described via equinoctial elements relative to some fixed plane (usually the equatorial plane of some planet). Arguments et : Epoch in seconds past J2000 to find state epoch : Epoch of elements in seconds past J2000 eqel : Array of equinoctial elements rapol : Right Ascension of the pole of the reference plane decpol : Declination of the pole of the reference plane Output Returns the state of the object described by  eqel . References NAIF Documentation source"},{"id":900,"pagetitle":"API","title":"SPICE.eqstr","ref":"/previews/PR43/SPICE/stable/api/#SPICE.eqstr-Tuple{Any,Any}","content":" SPICE.eqstr  —  Method . eqstr(a, b) Determine whether two strings are equivalent. Arguments a ,  b : Arbitrary character strings Output Returns  true  if  a  and  b  are equivalent. References NAIF Documentation source"},{"id":901,"pagetitle":"API","title":"SPICE.esrchc","ref":"/previews/PR43/SPICE/stable/api/#SPICE.esrchc-Tuple{Any,Any}","content":" SPICE.esrchc  —  Method . esrchc(value, array) Search for a given value within a character string array. Arguments value : Key value to be found in array array : Character string array to search Output Returns the index of the first equivalent array entry, or -1 if no equivalent element is found. References NAIF Documentation source"},{"id":902,"pagetitle":"API","title":"SPICE.et2lst","ref":"/previews/PR43/SPICE/stable/api/#SPICE.et2lst","content":" SPICE.et2lst  —  Function . et2lst(et, body, lon, typ, timlen=128, ampmlen=128) Given an ephemeris epoch, compute the local solar time for an object on the surface of a body at a specified longitude. Arguments et : Epoch in seconds past J2000 epoch body : ID-code of the body of interest lon : Longitude of surface point (radians) typ : Type of longitude \"PLANETOCENTRIC\", etc timlen : Available room in output time string (default: 128) ampmlen : Available room in output `ampm' string (default: 128) Output hr : Local hour on a \"24 hour\" clock mn : Minutes past the hour sc : Seconds past the minute time : String giving local time on 24 hour clock ampm : String giving time on A.M./ P.M. scale References NAIF Documentation source"},{"id":903,"pagetitle":"API","title":"SPICE.et2utc","ref":"/previews/PR43/SPICE/stable/api/#SPICE.et2utc-Tuple{Any,Any,Any}","content":" SPICE.et2utc  —  Method . et2utc(et, format, prec) Convert an input time from ephemeris seconds past J2000 to Calendar, Day-of-Year, or Julian Date format, UTC. Arguments et : Input epoch, given in ephemeris seconds past J2000 format : Format of output epoch. It may be any of the following: :C : Calendar format, UTC :D : Day-of-Year format, UTC :J : Julian Date format, UTC :ISOC : ISO Calendar format, UTC :ISOD : ISO Day-of-Year format, UTC prec : Digits of precision in fractional seconds or days Output Returns an output time string equivalent to the input epoch, in the specified format. References NAIF Documentation source"},{"id":904,"pagetitle":"API","title":"SPICE.etcal","ref":"/previews/PR43/SPICE/stable/api/#SPICE.etcal","content":" SPICE.etcal  —  Function . etcal(et, lenout=128) Convert from an ephemeris epoch measured in seconds past the epoch of J2000 to a calendar string format using a formal calendar free of leapseconds. Arguments et : Ephemeris time measured in seconds past J2000 lenout : Length of output string (default: 128) Output Returns a standard calendar representation of  et . References NAIF Documentation source"},{"id":905,"pagetitle":"API","title":"SPICE.eul2m","ref":"/previews/PR43/SPICE/stable/api/#SPICE.eul2m-NTuple{6,Any}","content":" SPICE.eul2m  —  Method . eul2m(angle3, angle2, angle1, axis3, axis2, axis1) Construct a rotation matrix from a set of Euler angles. Arguments angle3 ,  angle2 ,  angle1 : Rotation angles about third, second, and first rotation axes (radians) axis3 ,  axis2 ,  axis1 : Axis numbers of third, second, and first rotation axes Output A rotation matrix corresponding to the product of the 3 rotations. References NAIF Documentation source"},{"id":906,"pagetitle":"API","title":"SPICE.eul2xf","ref":"/previews/PR43/SPICE/stable/api/#SPICE.eul2xf-NTuple{4,Any}","content":" SPICE.eul2xf  —  Method . eul2xf(eulang, axisa, axisb, axisc) Compute a state transformation from an Euler angle factorization of a rotation and the derivatives of those Euler angles. Arguments eulang : An array of Euler angles and their derivatives axisa : Axis A of the Euler angle factorization axisb : Axis B of the Euler angle factorization axisc : Axis C of the Euler angle factorization Output Returns a state transformation matrix. References NAIF Documentation source"},{"id":907,"pagetitle":"API","title":"SPICE.expool","ref":"/previews/PR43/SPICE/stable/api/#SPICE.expool-Tuple{Any}","content":" SPICE.expool  —  Method . expool(name) Confirm the existence of a kernel variable in the kernel pool. Arguments name : Name of the variable whose value is to be returned Output Returns  true  when the variable is in the pool. References NAIF Documentation source"},{"id":908,"pagetitle":"API","title":"SPICE.fovray","ref":"/previews/PR43/SPICE/stable/api/#SPICE.fovray-NTuple{6,Any}","content":" SPICE.fovray  —  Method . fovray(inst, raydir, rframe, abcorr, observer, et) Determine if a specified ray is within the field-of-view (FOV) of a specified instrument at a given time. Arguments inst : Name or ID code string of the instrument raydir : Ray's direction vector rframe : Body-fixed, body-centered frame for target body abcorr : Aberration correction flag observer : Name or ID code string of the observer et : Time of the observation (seconds past J2000) Output Returns  true  if the ray is visible. References NAIF Documentation source"},{"id":909,"pagetitle":"API","title":"SPICE.fovtrg","ref":"/previews/PR43/SPICE/stable/api/#SPICE.fovtrg-NTuple{7,Any}","content":" SPICE.fovtrg  —  Method . fovtrg(inst, target, tshape, tframe, abcorr, obsrvr, et) Determine if a specified ephemeris object is within the field-of-view (FOV) of a specified instrument at a given time. Arguments inst : Name or ID code string of the instrument. target : Name or ID code string of the target. tshape : Type of shape model used for the target. tframe : Body-fixed, body-centered frame for target body. abcorr : Aberration correction flag. obsrvr : Name or ID code string of the observer. et : Time of the observation (seconds past J2000). Output Returns  true  if the object is visible. References NAIF Documentation source"},{"id":910,"pagetitle":"API","title":"SPICE.frame","ref":"/previews/PR43/SPICE/stable/api/#SPICE.frame-Tuple{Any}","content":" SPICE.frame  —  Method . frame(x) Given a vector  x , this routine builds a right handed orthonormal frame  x ,  y ,  z  where the output  x  is parallel to the input  x . Arguments x : Input vector Output x : Unit vector parallel to  x  on output y : Unit vector in the plane orthogonal to  x z : Unit vector given by  x × y References NAIF Documentation source"},{"id":911,"pagetitle":"API","title":"SPICE.frinfo","ref":"/previews/PR43/SPICE/stable/api/#SPICE.frinfo-Tuple{Any}","content":" SPICE.frinfo  —  Method . frinfo(frcode) Retrieve the minimal attributes associated with a frame needed for converting transformations to and from it. Arguments frcode : The id code for a reference frame Output cent : The center of the frame frclss : The class (type) of the frame clssid : The idcode for the frame within its class Returns  nothing  if no frame with id  frcode  could be found. References NAIF Documentation source"},{"id":912,"pagetitle":"API","title":"SPICE.frmnam","ref":"/previews/PR43/SPICE/stable/api/#SPICE.frmnam-Tuple{Any}","content":" SPICE.frmnam  —  Method . frmnam(frcode) Retrieve the name of a reference frame associated with an id code. Arguments frcode : The id code for a reference frame Output Returns the name associated with the reference frame. References NAIF Documentation source"},{"id":913,"pagetitle":"API","title":"SPICE.furnsh","ref":"/previews/PR43/SPICE/stable/api/#SPICE.furnsh-Tuple","content":" SPICE.furnsh  —  Method . furnsh(kernels...) Load one or more SPICE kernels into a program. Arguments kernels : Path(s) of SPICE kernels to load References NAIF Documentation source"},{"id":914,"pagetitle":"API","title":"SPICE.gcpool","ref":"/previews/PR43/SPICE/stable/api/#SPICE.gcpool-Tuple{Any}","content":" SPICE.gcpool  —  Method . gcpool(name; start=1, room=100, lenout=128) Return the value of a kernel variable from the kernel pool. Arguments name : Name of the variable whose value is to be returned start : Which component to start retrieving for name (default: 1) room : The largest number of values to return (default: 100) lenout : The length of the longest string to return (default: 128) Output Returns an array of values if the variable exists or  nothing  if not. References NAIF Documentation source"},{"id":915,"pagetitle":"API","title":"SPICE.gdpool","ref":"/previews/PR43/SPICE/stable/api/#SPICE.gdpool-Tuple{Any}","content":" SPICE.gdpool  —  Method . gdpool(name; start=1, room=100) Return the value of a kernel variable from the kernel pool. Arguments name : Name of the variable whose value is to be returned start : Which component to start retrieving for name (default: 1) room : The largest number of values to return (default: 100) Output Returns an array of values if the variable exists or  nothing  if not. References NAIF Documentation source"},{"id":916,"pagetitle":"API","title":"SPICE.georec","ref":"/previews/PR43/SPICE/stable/api/#SPICE.georec-NTuple{5,Any}","content":" SPICE.georec  —  Method . georec(lon, lat, alt, re, f) Convert geodetic coordinates to rectangular coordinates. Arguments lon : Geodetic longitude of point (radians) lat : Geodetic latitude  of point (radians) alt : Altitude of point above the reference spheroid re : Equatorial radius of the reference spheroid f : Flattening coefficient Output Returns the rectangular coordinates of point. References NAIF Documentation source"},{"id":917,"pagetitle":"API","title":"SPICE.getelm","ref":"/previews/PR43/SPICE/stable/api/#SPICE.getelm-Tuple{Any,Any}","content":" SPICE.getelm  —  Method . getelm(frstyr, lines) Given the \"lines\" of a two-line element set, parse the lines and return the elements in units suitable for use in SPICE software. Arguments frstyr : Year of earliest representable two-line elements lines : A pair of \"lines\" containing two-line elements Output epoch : The epoch of the elements in seconds past J2000 elems : The elements converted to SPICE units References NAIF Documentation source"},{"id":918,"pagetitle":"API","title":"SPICE.getfat","ref":"/previews/PR43/SPICE/stable/api/#SPICE.getfat","content":" SPICE.getfat  —  Function . getfat(file, arclen=10, typlen=10) Determine the file architecture and file type of most SPICE kernel files. Arguments file : The name of a file to be examined arclen : Maximum length of output architecture string (default: 10) typlen : Maximum length of output type string (default: 10) Output arch : The architecture of the kernel file typ : The type of the kernel file References NAIF Documentation source"},{"id":919,"pagetitle":"API","title":"SPICE.getfov","ref":"/previews/PR43/SPICE/stable/api/#SPICE.getfov","content":" SPICE.getfov  —  Function . getfov(instid, room=10, shapelen=128, framelen=128) Return the field-of-view (FOV) parameters for a specified instrument. The instrument is specified by its NAIF ID code. Arguments instid : NAIF ID of an instrument room : Maximum number of vectors that can be returned (default: 10) shapelen : Space available in the string  shape  (default: 128) framelen : Space available in the string  frame  (default: 128) Output Returns a tuple consisting of shape : Instrument FOV shape frame : Name of the frame in which FOV vectors are defined bsight : Boresight vector bounds : FOV boundary vectors References NAIF Documentation source"},{"id":920,"pagetitle":"API","title":"SPICE.gfdist","ref":"/previews/PR43/SPICE/stable/api/#SPICE.gfdist-NTuple{9,Any}","content":" SPICE.gfdist  —  Method . gfdist(target, abcorr, obsrvr, relate, refval, adjust, step, nintvls, cnfine) Return the time window over which a specified constraint on observer-target distance is met. Arguments target : Name of the target body abcorr : Aberration correction flag obsrvr : Name of the observing body relate : Relational operator refval : Reference value adjust : Adjustment value for absolute extrema searches step : Step size used for locating extrema and roots nintvls : Workspace window interval count cnfine : Window to which the search is confined Output Returns a window containing the results. References NAIF Documentation source"},{"id":921,"pagetitle":"API","title":"SPICE.gfevnt","ref":"/previews/PR43/SPICE/stable/api/#SPICE.gfevnt-NTuple{18,Any}","content":" SPICE.gfevnt  —  Method . gfevnt(udstep, udrefn, gquant, qnpars, lenvals, qpnams, qcpars, qdpars, qipars, qlpars,\n       op, refval, tol, adjust, rpt, udrepi, udrepu, udrepf, nintvls, bail, udbail, cnfine) Determine time intervals when a specified geometric quantity satisfies a specified mathematical condition. Arguments udstep : Name of the routine that computes and returns a time step udrefn : Name of the routine that computes a refined time gquant : Type of geometric quantity qpnams : Names of quantity definition parameters qcpars : Array of character quantity definition parameters qdpars : Array of double precision quantity definition parameters qipars : Array of integer quantity definition parameters qlpars : Array of logical quantity definition parameters op : Operator that either looks for an extreme value (max, min, local, absolute) or compares the   geometric quantity value and a number refval : Reference value tol : Convergence tolerance in second adjust : Absolute extremum adjustment value rpt : Progress reporter on ( true ) or off ( false ) udrepi : Function that initializes progress reporting udrepu : Function that updates the progress report udrepf : Function that finalizes progress reporting nintvls : Workspace window interval coun cnfine : SPICE window to which the search is restricted Output Returns a window containing the results. References NAIF Documentation source"},{"id":922,"pagetitle":"API","title":"SPICE.gffove!","ref":"/previews/PR43/SPICE/stable/api/#SPICE.gffove!-NTuple{16,Any}","content":" SPICE.gffove!  —  Method . gffove!(inst, tshape, raydir, target, tframe, abcorr, obsrvr, tol, udstep, udrefn,\n            rpt, udrepi, udrepu, udrepf, cnfine, result) Determine time intervals when a specified target body or ray intersects the space bounded by the field-of-view (FOV) of a specified instrument. Arguments inst : Name of the instrument tshape : Type of shape model used for target body raydir : Ray's direction vector target : Name of the target body tframe : Body-fixed, body-centered frame for target body abcorr : Aberration correction flag obsrvr : Name of the observing body tol : Convergence tolerance in seconds udstep : Name of the routine returns a time step udrefn : Name of the routine that computes a refined time rpt : Progress report flag udrepi : Function that initializes progress reporting udrepu : Function that updates the progress report udrepf : Function that finalizes progress reporting cnfine : SPICE window to which the search is restricted result : Window containing the results Output Returns  result . References NAIF Documentation source"},{"id":923,"pagetitle":"API","title":"SPICE.gfilum","ref":"/previews/PR43/SPICE/stable/api/#SPICE.gfilum-NTuple{14,Any}","content":" SPICE.gfilum  —  Method . gfilum(method, angtyp, target, illmn, fixref, abcorr, obsrvr, spoint, relate, refval,\n       adjust, step, nintvls, cnfine) Return the time window over which a specified constraint on the observed phase, solar incidence, or emission angle at a specifed target body surface point is met. Arguments method : Computation method angtyp : Type of illumination angle target : Name of the target body illmn : Name of the illumination source fixref : Body-fixed, body-centered target body frame abcorr : Aberration correction flag obsrvr : Name of the observing body spoint : Body-fixed coordinates of a target surface point relate : Relational operator refval : Reference value adjust : Adjustment value for absolute extrema searches step : Step size used for locating extrema and roots nintvls : Workspace window interval count cnfine : Window to which the search is confined Output Returns a window containing the results. References NAIF Documentation source"},{"id":924,"pagetitle":"API","title":"SPICE.gfocce!","ref":"/previews/PR43/SPICE/stable/api/#SPICE.gfocce!-NTuple{18,Any}","content":" SPICE.gfocce!  —  Method . function gfocce!(occtyp, front, fshape, fframe, back, bshape, bframe, abcorr, obsrvr, tol,\n    udstep, udrefn, rpt, udrepi, udrepu, udrepf, cnfine, result) Determine time intervals when an observer sees one target occulted by another. Arguments occtyp : Type of occultation front : Name of body occulting the other fshape : Type of shape model used for front body fframe : Body-fixed, body-centered frame for front body back : Name of body occulted by the other bshape : Type of shape model used for back body bframe : Body-fixed, body-centered frame for back body abcorr : Aberration correction flag obsrvr : Name of the observing body tol : Convergence tolerance in seconds udstep : Name of the routine that returns a time step udrefn : Name of the routine that computes a refined time rpt : Progress report flag udrepi : Function that initializes progress reporting udrepu : Function that updates the progress report udrepf : Function that finalizes progress reporting cnfine : SPICE window to which the search is restricted result : SPICE window containing results Output Returns  result . References NAIF Documentation source"},{"id":925,"pagetitle":"API","title":"SPICE.gfoclt","ref":"/previews/PR43/SPICE/stable/api/#SPICE.gfoclt","content":" SPICE.gfoclt  —  Function . gfoclt(occtyp, front, fshape, fframe, back, bshape, bframe, abcorr, obsrvr, step, cnfine,\n       maxwin=100) Determine time intervals when an observer sees one target occulted by, or in transit across, another. The surfaces of the target bodies may be represented by triaxial ellipsoids or by topographic data provided by DSK files. Arguments occtyp : Type of occultation front : Name of body occulting the other fshape : Type of shape model used for front body fframe : Body-fixed, body-centered frame for front body back : Name of body occulted by the other bshape : Type of shape model used for back body bframe : Body-fixed, body-centered frame for back body abcorr : Aberration correction flag obsrvr : Name of the observing body step : Step size in seconds for finding occultation events cnfine : Window to which the search is restricted maxwin : Maximum size of the output window (default: 100) Output Returns a window containing the results. References NAIF Documentation source"},{"id":926,"pagetitle":"API","title":"SPICE.gfpa","ref":"/previews/PR43/SPICE/stable/api/#SPICE.gfpa-NTuple{10,Any}","content":" SPICE.gfpa  —  Method . gfpa(result, target, illmn, abcorr, obsrvr, relate, refval, adjust, step, nintvls, cnfine) Determine time intervals for which a specified constraint on the phase angle between an illumination source, a target, and observer body centers is met. Arguments target : Name of the target body illmn : Name of the illuminating body abcorr : Aberration correction flag obsrvr : Name of the observing body relate : Relational operator refval : Reference value adjust : Adjustment value for absolute extrema searches step : Step size used for locating extrema and roots nintvls : Workspace window interval count cnfine : Window to which the search is confined Output Returns a window containing the results. References NAIF Documentation source"},{"id":927,"pagetitle":"API","title":"SPICE.gfposc","ref":"/previews/PR43/SPICE/stable/api/#SPICE.gfposc-NTuple{12,Any}","content":" SPICE.gfposc  —  Method . gfposc(target, frame, abcorr, obsrvr, crdsys, coord, relate, refval, adjust, step,\n       nintvls, cnfine) Determine time intervals for which a coordinate of an observer-target position vector satisfies a numerical constraint. Arguments target : Name of the target body frame : Name of the reference frame for coordinate calculations abcorr : Aberration correction flag obsrvr : Name of the observing body crdsys : Name of the coordinate system containing  coord coord : Name of the coordinate of interest relate : Operator that either looks for an extreme value (max, min, local, absolute) or compares   the coordinate value and refval refval : Reference value adjust : Adjustment value for absolute extrema searches step : Step size used for locating extrema and roots nintvls : Workspace window interval count cnfine : Window to which the search is restricted Output Returns a window containing the results. References NAIF Documentation source"},{"id":928,"pagetitle":"API","title":"SPICE.gfrefn","ref":"/previews/PR43/SPICE/stable/api/#SPICE.gfrefn-NTuple{4,Any}","content":" SPICE.gfrefn  —  Method . gfrefn(t1, t2, s1, s2) For those times when we can't do better, we use a bisection method to find the next time at which to test for state change. Arguments t1 : One of two values bracketing a state change t2 : The other value that brackets a state change s1 : State at  t1 s2 : State at  t2 Output Returns the new value at which to check for transition. References NAIF Documentation source"},{"id":929,"pagetitle":"API","title":"SPICE.gfrepf","ref":"/previews/PR43/SPICE/stable/api/#SPICE.gfrepf-Tuple{}","content":" SPICE.gfrepf  —  Method . gfrepf() Finish a GF progress report. References NAIF Documentation source"},{"id":930,"pagetitle":"API","title":"SPICE.gfrepi","ref":"/previews/PR43/SPICE/stable/api/#SPICE.gfrepi-Tuple{SPICE.SpiceCell{Float64,T,N} where N where T,Any,Any}","content":" SPICE.gfrepi  —  Method . gfrepi(window, begmss, endmss) Initialize a search progress report. Arguments window : A window over which a job is to be performed begmss : Beginning of the text portion of the output message endmss : End of the text portion of the output message References NAIF Documentation source"},{"id":931,"pagetitle":"API","title":"SPICE.gfrepu","ref":"/previews/PR43/SPICE/stable/api/#SPICE.gfrepu-Tuple{Any,Any,Any}","content":" SPICE.gfrepu  —  Method . gfrepu(ivbeg, ivend, time) Tell the progress reporting system how far a search has progressed. Arguments ivbeg : Start time of work interval ivend : End time of work interval time : Current time being examined in the search process References NAIF Documentation source"},{"id":932,"pagetitle":"API","title":"SPICE.gfrfov","ref":"/previews/PR43/SPICE/stable/api/#SPICE.gfrfov","content":" SPICE.gfrfov  —  Function . gfrfov(inst, raydir, rframe, abcorr, obsrvr, step, cnfine, maxwin=10000) Determine time intervals when a specified ray intersects the space bounded by the field-of-view (FOV) of a specified instrument. Arguments inst : Name of the instrument raydir : Ray's direction vector rframe : Reference frame of ray's direction vector abcorr : Aberration correction flag obsrvr : Name of the observing body step : Step size in seconds for finding FOV events cnfine : SPICE window to which the search is restricted maxwin : Maximum length of the output window (default: 10000) Output Returns a window containing the results. References NAIF Documentation source"},{"id":933,"pagetitle":"API","title":"SPICE.gfrr","ref":"/previews/PR43/SPICE/stable/api/#SPICE.gfrr-NTuple{9,Any}","content":" SPICE.gfrr  —  Method . gfrr(target, abcorr, obsrvr, relate, refval, adjust, step, nintvls, cnfine) Determine time intervals for which a specified constraint on the observer-target range rate is met. Arguments target : Name of the target body abcorr : Aberration correction flag obsrvr : Name of the observing body relate : Relational operator refval : Reference value adjust : Adjustment value for absolute extrema searches step : Step size used for locating extrema and roots nintvls : Workspace window interval count cnfine : Window to which the search is confined Output Returns a window containing the results. References NAIF Documentation source"},{"id":934,"pagetitle":"API","title":"SPICE.gfsep","ref":"/previews/PR43/SPICE/stable/api/#SPICE.gfsep-NTuple{14,Any}","content":" SPICE.gfsep  —  Method . Determine time intervals when the angular separation between the position vectors of two target bodies relative to an observer satisfies a numerical relationship. Arguments targ1 : Name of first body shape1 : Name of shape model describing the first body frame1 : The body-fixed reference frame of the first body targ2 : Name of second body shape2 : Name of the shape model describing the second body frame2 : The body-fixed reference frame of the second body abcorr : Aberration correction flag obsrvr : Name of the observing body relate : Operator that either looks for an extreme value (max, min, local, absolute) or compares   the angular separation value and refval refval : Reference value adjust : Absolute extremum adjustment value step : Step size in seconds for finding angular separation events nintvls : Workspace window interval count cnfine : Window to which the search is restricted Output Returns a window containing the results. References NAIF Documentation source"},{"id":935,"pagetitle":"API","title":"SPICE.gfsntc","ref":"/previews/PR43/SPICE/stable/api/#SPICE.gfsntc-NTuple{15,Any}","content":" SPICE.gfsntc  —  Method . gfsntc(target, fixref, method, abcorr, obsrvr, dref, dvec, crdsys, coord, relate, refval,\n       adjust, step, nintvls, cnfine) Determine time intervals for which a coordinate of an surface intercept position vector satisfies a numerical constraint. Arguments target : Name of the target body fixref : Body fixed frame associated with  target method : Name of method type for surface intercept calculation abcorr : Aberration correction flag obsrvr : Name of the observing body dref : Reference frame of direction vector  dvec dvec : Pointing direction vector from  obsrvr crdsys : Name of the coordinate system containing COORD coord : Name of the coordinate of interest relate : Operator that either looks for an extreme value (max, min, local, absolute) or compares the coordinate value and  refval refval : Reference value adjust : Adjustment value for absolute extrema searches step : Step size used for locating extrema and roots nintvls : Workspace window interval count cnfine : Window to which the search is restricted Output Returns a window containing the results. References NAIF Documentation source"},{"id":936,"pagetitle":"API","title":"SPICE.gfsstp","ref":"/previews/PR43/SPICE/stable/api/#SPICE.gfsstp-Tuple{Any}","content":" SPICE.gfsstp  —  Method . gfsstp(step) Set the step size to be returned by  gfstep . Arguments step : Time step to take References NAIF Documentation source"},{"id":937,"pagetitle":"API","title":"SPICE.gfstep","ref":"/previews/PR43/SPICE/stable/api/#SPICE.gfstep-Tuple{}","content":" SPICE.gfstep  —  Method . gfstep() Return the time step set by the most recent call to  gfsstp . Arguments step : Time step to take References NAIF Documentation source"},{"id":938,"pagetitle":"API","title":"SPICE.gfstol","ref":"/previews/PR43/SPICE/stable/api/#SPICE.gfstol-Tuple{Any}","content":" SPICE.gfstol  —  Method . gfstol(value) Override the default GF convergence value used in the high level GF routines. Arguments value : Double precision value returned or to store References NAIF Documentation source"},{"id":939,"pagetitle":"API","title":"SPICE.gfsubc","ref":"/previews/PR43/SPICE/stable/api/#SPICE.gfsubc-NTuple{13,Any}","content":" SPICE.gfsubc  —  Method . gfsubc(target, fixref, method, abcorr, obsrvr, crdsys, coord, relate, refval, adjust, step,\n       nintvls, cnfine) Determine time intervals for which a coordinate of an subpoint position vector satisfies a numerical constraint. Arguments target : Name of the target body fixref : Body fixed frame associated with  target method : Name of method type for subpoint calculation abcorr : Aberration correction flag obsrvr : Name of the observing body crdsys : Name of the coordinate system containing  coord coord : Name of the coordinate of interest relate : Operator that either looks for an extreme value (max, min, local, absolute) or compares   the coordinate value and refval refval : Reference value adjust : Adjustment value for absolute extrema searches step : Step size used for locating extrema and roots nintvls : Workspace window interval count cnfine : Window to which the search is restricted Output Returns a window containing the results. References NAIF Documentation source"},{"id":940,"pagetitle":"API","title":"SPICE.gftfov","ref":"/previews/PR43/SPICE/stable/api/#SPICE.gftfov-NTuple{9,Any}","content":" SPICE.gftfov  —  Method . gftfov(inst, target, tshape, tframe, abcorr, obsrvr, step, nintvls, cnfine) Determine time intervals when a specified ephemeris object intersects the space bounded by the field-of-view (FOV) of a specified instrument. Arguments inst : Name of the instrument target : Name of the target body tshape : Type of shape model used for target body tframe : Body-fixed, body-centered frame for target body abcorr : Aberration correction flag obsrvr : Name of the observing body step : Step size in seconds for finding FOV events nintvls : Workspace window interval count cnfine : Window to which the search is restricted Output Returns a window containing the results. References NAIF Documentation source"},{"id":941,"pagetitle":"API","title":"SPICE.gfudb!","ref":"/previews/PR43/SPICE/stable/api/#SPICE.gfudb!-NTuple{5,Any}","content":" SPICE.gfudb!  —  Method . gfudb!(udfuns, udfunb, step, cnfine, result) Perform a GF search on a user defined boolean quantity. Arguments udfuns : Name of the routine that computes a scalar quantity of interest corresponding to an  et , e.g.  f(et) = ... udfunb : Name of the routine returning the boolean value corresponding to an  et , e.g.  g(f, et) = ... step : Step size used for locating extrema and roots cnfine : Window to which the search is restricted result : Window containing results Output Returns  result . References NAIF Documentation source"},{"id":942,"pagetitle":"API","title":"SPICE.gfuds!","ref":"/previews/PR43/SPICE/stable/api/#SPICE.gfuds!-NTuple{9,Any}","content":" SPICE.gfuds!  —  Method . gfuds!(udfuns, udqdec, relate, refval, adjust, step, nintvls, cnfine, result) Perform a GF search on a user defined scalar quantity. Arguments udfuns : Name of the routine that computes the scalar quantity of interest at some time, e.g.  f(et) = ... udqdec : Name of the routine that computes whether the scalar quantity is decreasing, e.g.  g(f, et) = ... relate : Operator that either looks for an extreme value (max, min, local, absolute) or compares the geometric quantity value and a number refval : Value used as reference for scalar quantity condition adjust : Allowed variation for absolute extremal geometric conditions step : Step size used for locating extrema and roots nintvls : Workspace window interval count cnfine : SPICE window to which the search is restricted result : SPICE window containing results Output Returns  result . References NAIF Documentation source"},{"id":943,"pagetitle":"API","title":"SPICE.gipool","ref":"/previews/PR43/SPICE/stable/api/#SPICE.gipool-Tuple{Any}","content":" SPICE.gipool  —  Method . gipool(name; start=1, room=100) Return the value of a kernel variable from the kernel pool. Arguments name : Name of the variable whose value is to be returned start : Which component to start retrieving for name (default: 1) room : The largest number of values to return (default: 100) Output Returns an array of values if the variable exists or  nothing  if not. References NAIF Documentation source"},{"id":944,"pagetitle":"API","title":"SPICE.gnpool","ref":"/previews/PR43/SPICE/stable/api/#SPICE.gnpool","content":" SPICE.gnpool  —  Function . gnpool(name, start, room, lenout=128) Return names of kernel variables matching a specified template. Arguments name : Template that names should match start : Index of first matching name to retrieve room : The largest number of values to return lenout : Length of strings in output array  kvars  (default: 128) Output Returns lernel pool variables whose names match  name . References NAIF Documentation source"},{"id":945,"pagetitle":"API","title":"SPICE.halfpi","ref":"/previews/PR43/SPICE/stable/api/#SPICE.halfpi","content":" SPICE.halfpi  —  Function . halfpi() Deprecated Use  π/2  instead. source"},{"id":946,"pagetitle":"API","title":"SPICE.hrmint","ref":"/previews/PR43/SPICE/stable/api/#SPICE.hrmint-Tuple{Any,Any,Any}","content":" SPICE.hrmint  —  Method . hrmint(xvals, yvals, x) Evaluate a Hermite interpolating polynomial at a specified abscissa value. Arguments xvals : Abscissa values yvals : Ordinate and derivative values x : Point at which to interpolate the polynomial Output f : Interpolated function value at  x df : Interpolated function's derivative at  x References NAIF Documentation source"},{"id":947,"pagetitle":"API","title":"SPICE.hx2dp","ref":"/previews/PR43/SPICE/stable/api/#SPICE.hx2dp-Tuple{Any}","content":" SPICE.hx2dp  —  Method . hx2dp(str) Convert a string representing a double precision number in a base 16 \"scientific notation\" into its equivalent double precision number. Arguments str : Hex form string to convert to double precision Output dp : Double precision value to be returned References NAIF Documentation source"},{"id":948,"pagetitle":"API","title":"SPICE.illumf","ref":"/previews/PR43/SPICE/stable/api/#SPICE.illumf-NTuple{8,Any}","content":" SPICE.illumf  —  Method . illumf(method, target, ilusrc, et, fixref, abcorr, obsrvr, spoint) Compute the illumination angles - phase, incidence, and emission - at a specified point on a target body. Return logical flags indicating whether the surface point is visible from the observer's position and whether the surface point is illuminated. The target body's surface is represented using topographic data provided by DSK files, or by a reference ellipsoid. The illumination source is a specified ephemeris object. Arguments method : Computation method target : Name of target body ilusrc : Name of illumination source et : Epoch in TDB seconds past J2000 TDB fixref : Body-fixed, body-centered target body frame abcorr : Aberration correction flag obsrvr : Name of observing body spoint : Body-fixed coordinates of a target surface point Output trgepc : Target surface point epoch srfvec : Vector from observer to target surface point phase : Phase angle at the surface point incdnc : Source incidence angle at the surface point emissn : Emission angle at the surface point visibl : Visibility flag ( true  if visible) lit : Illumination flag ( true  if illuminated) References NAIF Documentation source"},{"id":949,"pagetitle":"API","title":"SPICE.illumg","ref":"/previews/PR43/SPICE/stable/api/#SPICE.illumg-NTuple{7,Any}","content":" SPICE.illumg  —  Method . illumg(method, target, ilusrc, et, fixref, obsrvr, spoint, abcorr) Find the illumination angles (phase, incidence, and emission) at a specified surface point of a target body. The surface of the target body may be represented by a triaxial ellipsoid or by topographic data provided by DSK files. The illumination source is a specified ephemeris object. Arguments method : Computation method. target : Name of target body. ilusrc : Name of illumination source. et : Epoch in ephemeris seconds past J2000 TDB. fixref : Body-fixed, body-centered target body frame. obsrvr : Name of observing body. spoint : Body-fixed coordinates of a target surface point. abcorr : Aberration correction. Output trgepc : Sub-solar point epoch. srfvec : Vector from observer to sub-solar point. phase : Phase angle at the surface point. incdnc : Solar incidence angle at the surface point. emissn : Emission angle at the surface point. References NAIF Documentation source"},{"id":950,"pagetitle":"API","title":"SPICE.ilumin","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ilumin-NTuple{6,Any}","content":" SPICE.ilumin  —  Method . ilumin(method, target, et, fixref, obsrvr, spoint, abcorr) Find the illumination angles (phase, solar incidence, and emission) at a specified surface point of a target body. Arguments method : Computation method target : Name of target body et : Epoch in ephemeris seconds past J2000 TDB fixref : Body-fixed, body-centered target body frame obsrvr : Name of observing body spoint : Body-fixed coordinates of a target surface point abcorr : Aberration correction Output trgepc : Sub-solar point epoch srfvec : Vector from observer to sub-solar point phase : Phase angle at the surface point incdnc : Solar incidence angle at the surface point emissn : Emission angle at the surface point References NAIF Documentation source"},{"id":951,"pagetitle":"API","title":"SPICE.inedpl","ref":"/previews/PR43/SPICE/stable/api/#SPICE.inedpl-NTuple{4,Any}","content":" SPICE.inedpl  —  Method . inedpl(a, b, c, plane) Find the intersection of a triaxial ellipsoid and a plane. Arguments a : Length of ellipsoid semi-axis lying on the x-axis b : Length of ellipsoid semi-axis lying on the y-axis c : Length of ellipsoid semi-axis lying on the z-axis plane : Plane that intersects ellipsoid Output ellipse : Intersection ellipse Returns  nothing  if no ellipse could be found. References NAIF Documentation source"},{"id":952,"pagetitle":"API","title":"SPICE.inelpl","ref":"/previews/PR43/SPICE/stable/api/#SPICE.inelpl-Tuple{Any,Any}","content":" SPICE.inelpl  —  Method . inelpl(ellips, plane) Find the intersection of an ellipse and a plane. Arguments ellips : An ellipse plane : A plane Output nxpts : Number of intersection points of ellipse and plane xpt1 ,  xpt2 : Intersection points References NAIF Documentation source"},{"id":953,"pagetitle":"API","title":"SPICE.inrypl","ref":"/previews/PR43/SPICE/stable/api/#SPICE.inrypl-Tuple{Any,Any,Any}","content":" SPICE.inrypl  —  Method . inrypl(vertex, dir, plane) Find the intersection of a ray and a plane. Arguments vertex ,  dir : Vertex and direction vector of ray plane : A plane Output nxpts : Number of intersection points of ray and plane xpt1 ,  xpt2 : Intersection points References NAIF Documentation source"},{"id":954,"pagetitle":"API","title":"SPICE.insrtc!","ref":"/previews/PR43/SPICE/stable/api/#SPICE.insrtc!-Tuple{Any,Any}","content":" SPICE.insrtc!  —  Method . insrtc!(set, item) Insert an item into a character set. Arguments set : Insertion set item : Item to be inserted Output Returns the updated set. References NAIF Documentation source"},{"id":955,"pagetitle":"API","title":"SPICE.insrtd!","ref":"/previews/PR43/SPICE/stable/api/#SPICE.insrtd!-Tuple{Any,Any}","content":" SPICE.insrtd!  —  Method . insrtd!(set, item) Insert an item into a double set. Arguments set : Insertion set item : Item to be inserted Output Returns the updated set. References NAIF Documentation source"},{"id":956,"pagetitle":"API","title":"SPICE.insrti!","ref":"/previews/PR43/SPICE/stable/api/#SPICE.insrti!-Tuple{Any,Any}","content":" SPICE.insrti!  —  Method . insrti!(set, item) Insert an item into an integer set. Arguments set : Insertion set item : Item to be inserted Output Returns the updated set. References NAIF Documentation source"},{"id":957,"pagetitle":"API","title":"SPICE.inter","ref":"/previews/PR43/SPICE/stable/api/#SPICE.inter-Union{Tuple{T}, Tuple{SPICE.SpiceCell{T,T1,N} where N where T1,SPICE.SpiceCell{T,T1,N} where N where T1}} where T","content":" SPICE.inter  —  Method . inter(a, b) Intersect two sets of any data type to form a third set. Arguments a : First input set b : Second input set Output Returns intersection of a and b. References NAIF Documentation source"},{"id":958,"pagetitle":"API","title":"SPICE.intmax","ref":"/previews/PR43/SPICE/stable/api/#SPICE.intmax","content":" SPICE.intmax  —  Function . intmax() Deprecated Use  typemax(Cint)  instead. source"},{"id":959,"pagetitle":"API","title":"SPICE.intmin","ref":"/previews/PR43/SPICE/stable/api/#SPICE.intmin","content":" SPICE.intmin  —  Function . intmin() Deprecated Use  typemin(Cint)  instead. source"},{"id":960,"pagetitle":"API","title":"SPICE.invert","ref":"/previews/PR43/SPICE/stable/api/#SPICE.invert","content":" SPICE.invert  —  Function . invert(matrix) Deprecated Use  inv(matrix)  instead. source"},{"id":961,"pagetitle":"API","title":"SPICE.invort","ref":"/previews/PR43/SPICE/stable/api/#SPICE.invort","content":" SPICE.invort  —  Function . invort(matrix) Deprecated Use  inv(matrix)  instead. source"},{"id":962,"pagetitle":"API","title":"SPICE.isordv","ref":"/previews/PR43/SPICE/stable/api/#SPICE.isordv","content":" SPICE.isordv  —  Function . isordv(vec) Deprecated Use  isperm(vec)  instead. source"},{"id":963,"pagetitle":"API","title":"SPICE.isrchc","ref":"/previews/PR43/SPICE/stable/api/#SPICE.isrchc","content":" SPICE.isrchc  —  Function . isrchc(value, array) Deprecated Use  findfirst(array .== value)  instead. source"},{"id":964,"pagetitle":"API","title":"SPICE.isrchd","ref":"/previews/PR43/SPICE/stable/api/#SPICE.isrchd","content":" SPICE.isrchd  —  Function . isrchd(value, array) Deprecated Use  findfirst(array .== value)  instead. source"},{"id":965,"pagetitle":"API","title":"SPICE.isrchi","ref":"/previews/PR43/SPICE/stable/api/#SPICE.isrchi","content":" SPICE.isrchi  —  Function . isrchi(value, array) Deprecated Use  findfirst(array .== value)  instead. source"},{"id":966,"pagetitle":"API","title":"SPICE.isrot","ref":"/previews/PR43/SPICE/stable/api/#SPICE.isrot-Tuple{Any,Any,Any}","content":" SPICE.isrot  —  Method . isrot(m, ntol, dtol) Indicate whether a 3x3 matrix is a rotation matrix. Arguments m : A matrix to be tested ntol : Tolerance for the norms of the columns of  m dtol : Tolerance for the determinant of a matrix whose columns are the unitized columns of  m Output Returns  true  if  m  is a rotation matrix. References NAIF Documentation source"},{"id":967,"pagetitle":"API","title":"SPICE.iswhsp","ref":"/previews/PR43/SPICE/stable/api/#SPICE.iswhsp","content":" SPICE.iswhsp  —  Function . iswhsp(str) Deprecated Use  isempty(strip(str))  instead. source"},{"id":968,"pagetitle":"API","title":"SPICE.j1900","ref":"/previews/PR43/SPICE/stable/api/#SPICE.j1900-Tuple{}","content":" SPICE.j1900  —  Method . j1900() Returns the Julian Date of 1899 DEC 31 12:00:00 (1900 JAN 0.5). https://naif.jpl.nasa.gov/pub/naif/toolkit docs/C/cspice/j1900 c.html source"},{"id":969,"pagetitle":"API","title":"SPICE.j1950","ref":"/previews/PR43/SPICE/stable/api/#SPICE.j1950-Tuple{}","content":" SPICE.j1950  —  Method . j1950() Returns the Julian Date of 1950 JAN 01 00:00:00 (1950 JAN 1.0). https://naif.jpl.nasa.gov/pub/naif/toolkit docs/C/cspice/j1950 c.html source"},{"id":970,"pagetitle":"API","title":"SPICE.j2000","ref":"/previews/PR43/SPICE/stable/api/#SPICE.j2000-Tuple{}","content":" SPICE.j2000  —  Method . j2000() Returns the Julian Date of 2000 JAN 01 12:00:00 (2000 JAN 1.5). https://naif.jpl.nasa.gov/pub/naif/toolkit docs/C/cspice/j2000 c.html source"},{"id":971,"pagetitle":"API","title":"SPICE.j2100","ref":"/previews/PR43/SPICE/stable/api/#SPICE.j2100-Tuple{}","content":" SPICE.j2100  —  Method . j2100() Returns the Julian Date of 2100 JAN 01 12:00:00 (2100 JAN 1.5). https://naif.jpl.nasa.gov/pub/naif/toolkit docs/C/cspice/j2100 c.html source"},{"id":972,"pagetitle":"API","title":"SPICE.jyear","ref":"/previews/PR43/SPICE/stable/api/#SPICE.jyear-Tuple{}","content":" SPICE.jyear  —  Method . jyear() Returns the number of seconds per Julian year. https://naif.jpl.nasa.gov/pub/naif/toolkit docs/C/cspice/jyear c.html source"},{"id":973,"pagetitle":"API","title":"SPICE.kclear","ref":"/previews/PR43/SPICE/stable/api/#SPICE.kclear-Tuple{}","content":" SPICE.kclear  —  Method . kclear() Clear the KEEPER subsystem: unload all kernels, clear the kernel pool, and re-initialize the subsystem. Existing watches on kernel variables are retained. References NAIF Documentation source"},{"id":974,"pagetitle":"API","title":"SPICE.kdata","ref":"/previews/PR43/SPICE/stable/api/#SPICE.kdata","content":" SPICE.kdata  —  Function . kdata(which, kind, fillen=1024, srclen=256) Return data for the n-th kernel that is among a list of specified kernel types. Arguments which : Index of kernel to fetch from the list of kernels kind : The kind of kernel to which fetches are limited fillen : Available space in output file string srclen : Available space in output source string Output Returns  nothing  if no kernel was found or a tuple consisting of file : The name of the kernel file filtyp : The type of the kernel source : Name of the source file used to load file handle : The handle attached to file References NAIF Documentation source"},{"id":975,"pagetitle":"API","title":"SPICE.kinfo","ref":"/previews/PR43/SPICE/stable/api/#SPICE.kinfo","content":" SPICE.kinfo  —  Function . kinfo(file, srclen=256) Arguments file : Name of a kernel to fetch information for srclen : Available space in output source string Output Returns  nothing  if no kernel was found or a tuple consisting of filtyp : The type of the kernel source : Name of the source file used to load file handle : The handle attached to file References NAIF Documentation source"},{"id":976,"pagetitle":"API","title":"SPICE.kplfrm","ref":"/previews/PR43/SPICE/stable/api/#SPICE.kplfrm","content":" SPICE.kplfrm  —  Function . kplfrm(frmcls) Return a SPICE set containing the frame IDs of all reference frames of a given class having specifications in the kernel pool. Arguments frmcls : Frame class size : Size of the output set Output Returns the set of ID codes of frames of the specified class. References NAIF Documentation source"},{"id":977,"pagetitle":"API","title":"SPICE.ktotal","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ktotal-Tuple{Any}","content":" SPICE.ktotal  —  Method . ktotal(kind) Return the current number of kernels that have been loaded via the KEEPER interface that are of a specified type. References NAIF Documentation source"},{"id":978,"pagetitle":"API","title":"SPICE.kxtrct","ref":"/previews/PR43/SPICE/stable/api/#SPICE.kxtrct","content":" SPICE.kxtrct  —  Function . kxtrct(keywd, terms, string) Locate a keyword in a string and extract the substring from the beginning of the first word following the keyword to the beginning of the first subsequent recognized terminator of a list. Arguments keywd : Word that marks the beginning of text of interest terms : Set of words, any of which marks the end of text string : String containing a sequence of words Output Returns  nothing  if  keywd  was found or a tuple consisting of string : The input  string  with the text of interest removed substr : String from end of  keywd  to beginning of first  terms  item found References NAIF Documentation source"},{"id":979,"pagetitle":"API","title":"SPICE.lastnb","ref":"/previews/PR43/SPICE/stable/api/#SPICE.lastnb","content":" SPICE.lastnb  —  Function . lastnb(str) Deprecated Use  findprev(!isspace, str, length(str))  instead. source"},{"id":980,"pagetitle":"API","title":"SPICE.latcyl","ref":"/previews/PR43/SPICE/stable/api/#SPICE.latcyl-Tuple{Any,Any,Any}","content":" SPICE.latcyl  —  Method . latcyl(radius, lon, lat) Convert from latitudinal coordinates to cylindrical coordinates. Arguments radius : Distance of a point from the origin lon : Angle of the point from the XZ plane in radians lat : Angle of the point from the XY plane in radians Output Return the tuple  (r, lonc, z) . r : Distance of the point from the z axis lonc : Angle of the point from the XZ plane in radians. 'lonc' is set equal to 'lon' z : Height of the point above the XY plane References NAIF Documentation source"},{"id":981,"pagetitle":"API","title":"SPICE.latrec","ref":"/previews/PR43/SPICE/stable/api/#SPICE.latrec-Tuple{Any,Any,Any}","content":" SPICE.latrec  —  Method . latrec(radius, lon, lat) Convert from latitudinal coordinates to rectangular coordinates. Arguments radius : Distance of a point from the origin lon : Angle of the point from the XZ plane in radians lat : Angle of the point from the XY plane in radians Output Return the rectangular coordinates vector of the point. References NAIF Documentation source"},{"id":982,"pagetitle":"API","title":"SPICE.latsph","ref":"/previews/PR43/SPICE/stable/api/#SPICE.latsph-Tuple{Any,Any,Any}","content":" SPICE.latsph  —  Method . latsph(radius, lon, lat) Convert from latitudinal coordinates to rectangular coordinates. Arguments radius : Distance of a point from the origin lon : Angle of the point from the XZ plane in radians lat : Angle of the point from the XY plane in radians Output Return the tuple  (rho, colat, lons) . rho : Distance of the point from the origin colat : Angle of the point from positive z axis (radians) lons : Angle of the point from the XZ plane (radians) References NAIF Documentation source"},{"id":983,"pagetitle":"API","title":"SPICE.latsrf","ref":"/previews/PR43/SPICE/stable/api/#SPICE.latsrf-NTuple{5,Any}","content":" SPICE.latsrf  —  Method . latsrf(method, target, et, fixref, npts, lonlat) Map array of planetocentric longitude/latitude coordinate pairs to surface points on a specified target body. The surface of the target body may be represented by a triaxial ellipsoid or by topographic data provided by DSK files. Arguments method : Computation method target : Name of target body et : Epoch in TDB seconds past J2000 TDB fixref : Body-fixed, body-centered target body frame lonlat : Array of longitude/latitude coordinate pairs Output Returns an array of surface points. References NAIF Documentation source"},{"id":984,"pagetitle":"API","title":"SPICE.lcase","ref":"/previews/PR43/SPICE/stable/api/#SPICE.lcase","content":" SPICE.lcase  —  Function . lcase(in) Deprecated Use  lowercase(in)  instead. source"},{"id":985,"pagetitle":"API","title":"SPICE.ldpool","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ldpool-Tuple{Any}","content":" SPICE.ldpool  —  Method . ldpool(kernel) Load the variables contained in a NAIF ASCII kernel file into the kernel pool. Arguments kernel : Name of the kernel file Output None References NAIF Documentation source"},{"id":986,"pagetitle":"API","title":"SPICE.lgrind","ref":"/previews/PR43/SPICE/stable/api/#SPICE.lgrind-Tuple{Any,Any,Any}","content":" SPICE.lgrind  —  Method . lgrind(xvals, yvals, x) Evaluate a Lagrange interpolating polynomial for a specified set of coordinate pairs, at a specified abscissa value. Return the value of both polynomial and derivative. Arguments xvals : Abscissa values of coordinate pairs yvals : Ordinate values of coordinate pairs x : Point at which to interpolate the polynomial Output p : The value at x of the unique polynomial of      degree n-1 that fits the points in the plane      defined by xvals and yvals dp : The derivative at x of the interpolating       polynomial described above References NAIF Documentation source"},{"id":987,"pagetitle":"API","title":"SPICE.limbpt","ref":"/previews/PR43/SPICE/stable/api/#SPICE.limbpt-NTuple{13,Any}","content":" SPICE.limbpt  —  Method . limbpt(method, target, et, fixref, abcorr, corloc, obsrvr, refvec, rolstp, ncuts, schstp,\n       soltol, maxn) Find limb points on a target body. The limb is the set of points of tangency on the target of rays emanating from the observer.  The caller specifies half-planes bounded by the observer-target center vector in which to search for limb points. The surface of the target body may be represented either by a triaxial ellipsoid or by topographic data. Arguments method : Computation method target : Name of target body et : Epoch in ephemeris seconds past J2000 TDB fixref : Body-fixed, body-centered target body frame abcorr : Aberration correction corloc : Aberration correction locus obsrvr : Name of observing body refvec : Reference vector for cutting half-planes rolstp : Roll angular step for cutting half-planes ncuts : Number of cutting half-planes schstp : Angular step size for searching soltol : Solution convergence tolerance maxn : Maximum number of entries in output arrays Output Returns the tuple  (npts, points, epochs, tangts) . npts : Counts of limb points corresponding to cuts points : Limb points epochs : Times associated with limb points tangts : Tangent vectors emanating from the observer References NAIF Documentation source"},{"id":988,"pagetitle":"API","title":"SPICE.lmpool","ref":"/previews/PR43/SPICE/stable/api/#SPICE.lmpool-Tuple{Any}","content":" SPICE.lmpool  —  Method . lmpool(cvals) Load the variables contained in an internal buffer into the kernel pool. Arguments cvals : An array that contains a SPICE text kernel References NAIF Documentation source"},{"id":989,"pagetitle":"API","title":"SPICE.lparse","ref":"/previews/PR43/SPICE/stable/api/#SPICE.lparse","content":" SPICE.lparse  —  Function . lparse(list, delim, nmax) Deprecated Use  split(list, delim, limit=nmax)  instead. source"},{"id":990,"pagetitle":"API","title":"SPICE.lparsm","ref":"/previews/PR43/SPICE/stable/api/#SPICE.lparsm","content":" SPICE.lparsm  —  Function . lparsm(list, delims, nmax) Deprecated Use  split(list, delim, limit=nmax, keepempty=false)  instead. source"},{"id":991,"pagetitle":"API","title":"SPICE.lparss","ref":"/previews/PR43/SPICE/stable/api/#SPICE.lparss","content":" SPICE.lparss  —  Function . lparss(list, delims) Deprecated Use  Set(split(list, collect(delim)))  instead. source"},{"id":992,"pagetitle":"API","title":"SPICE.lspcn","ref":"/previews/PR43/SPICE/stable/api/#SPICE.lspcn-Tuple{Any,Any,Any}","content":" SPICE.lspcn  —  Method . lspcn(body, et, abcorr) Compute L_s, the planetocentric longitude of the sun, as seen from a specified body. Arguments body : Name of the central body et : Epoch in seconds past J2000 TDB abcorr : Aberration correction Output Returns the planetocentric longitude of the sun for the specified body at the specified time in radians. References NAIF Documentation source"},{"id":993,"pagetitle":"API","title":"SPICE.lstlec","ref":"/previews/PR43/SPICE/stable/api/#SPICE.lstlec","content":" SPICE.lstlec  —  Function . lstlecd(x, array) Deprecated Use  findfirst(item .<= array)  instead. source"},{"id":994,"pagetitle":"API","title":"SPICE.lstled","ref":"/previews/PR43/SPICE/stable/api/#SPICE.lstled","content":" SPICE.lstled  —  Function . lstle[di](x, array) Deprecated Use  searchsortedlast(array, x)  instead. source"},{"id":995,"pagetitle":"API","title":"SPICE.lstltc","ref":"/previews/PR43/SPICE/stable/api/#SPICE.lstltc","content":" SPICE.lstltc  —  Function . lstltcd(x, array) Deprecated Use  findfirst(item .< array)  instead. source"},{"id":996,"pagetitle":"API","title":"SPICE.lstltd","ref":"/previews/PR43/SPICE/stable/api/#SPICE.lstltd","content":" SPICE.lstltd  —  Function . lstlt[di](x, array) Deprecated Use  searchsortedlast(array, x, lt=<=)  instead. source"},{"id":997,"pagetitle":"API","title":"SPICE.ltime","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ltime-NTuple{4,Any}","content":" SPICE.ltime  —  Method . ltime(etobs, obs, dir, targ) This routine computes the transmit (or receive) time of a signal at a specified target, given the receive (or transmit) time at a specified observer. The elapsed time between transmit and receive is also returned. Arguments etobs : Epoch of a signal at some observer obs : NAIF ID of some observer dir : Direction the signal travels ( \"->\" or \"<-\" ) targ : Time between transmit and receipt of the signal Output ettarg : Epoch of the signal at the target obs : NAIF ID of some observer References NAIF Documentation source"},{"id":998,"pagetitle":"API","title":"SPICE.lx4dec","ref":"/previews/PR43/SPICE/stable/api/#SPICE.lx4dec-Tuple{Any,Any}","content":" SPICE.lx4dec  —  Method . lx4dec(string, first) Scan a string from a specified starting position for the end of a decimal number. Arguments string : Any character string first : First character to scan from in string Output last : Last character that is part of a decimal number. If there is no such         character, last will be returned with the value first-1. nchar : Number of characters in the decimal number References NAIF Documentation source"},{"id":999,"pagetitle":"API","title":"SPICE.lx4num","ref":"/previews/PR43/SPICE/stable/api/#SPICE.lx4num-Tuple{Any,Any}","content":" SPICE.lx4num  —  Method . lx4num(string, first) Scan a string from a specified starting position for the end of a number. Arguments string : Any character string first : First character to scan from in string Output last : Last character that is part of a number. If there is no such         character, last will be returned with the value first-1. nchar : Number of characters in the number References NAIF Documentation source"},{"id":1000,"pagetitle":"API","title":"SPICE.lx4sgn","ref":"/previews/PR43/SPICE/stable/api/#SPICE.lx4sgn-Tuple{Any,Any}","content":" SPICE.lx4sgn  —  Method . lx4sgn(string, first) Scan a string from a specified starting position for the end of a signed integer. Arguments string : Any character string first : First character to scan from in string Output last : Last character that is part of a signed integer. If there is no such         character, last will be returned with the value first-1. nchar : Number of characters in the signed integer References NAIF Documentation source"},{"id":1001,"pagetitle":"API","title":"SPICE.lx4uns","ref":"/previews/PR43/SPICE/stable/api/#SPICE.lx4uns-Tuple{Any,Any}","content":" SPICE.lx4uns  —  Method . lx4uns(string, first) Scan a string from a specified starting position for the end of a unsigned integer. Arguments string : Any character string first : First character to scan from in string Output last : Last character that is part of an unsigned integer. If there is no such         character, last will be returned with the value first-1. nchar : Number of characters in the unsigned integer References NAIF Documentation source"},{"id":1002,"pagetitle":"API","title":"SPICE.lxqstr","ref":"/previews/PR43/SPICE/stable/api/#SPICE.lxqstr-Tuple{Any,Any,Any}","content":" SPICE.lxqstr  —  Method . lxqstr(string, qchar, first) Lex (scan) a quoted string. Arguments string : String to be scanned qchar : Quote delimiter character first : Character position at which to start scanning Output last : Character position of end of token nchar : Number of characters in token References NAIF Documentation source"},{"id":1003,"pagetitle":"API","title":"SPICE.m2eul","ref":"/previews/PR43/SPICE/stable/api/#SPICE.m2eul-NTuple{4,Any}","content":" SPICE.m2eul  —  Method . m2eul(r, axis3, axis2, axis1) Factor a rotation matrix as a product of three rotations about specified coordinate axes. Arguments r : A rotation matrix to be factored axis3 : Number of the third rotation axis axis2 : Number of the second rotation axis axis1 : Number of the first rotation axis Output A tuple consisting of the third, second, and first Euler angles in radians. References NAIF Documentation source"},{"id":1004,"pagetitle":"API","title":"SPICE.m2q","ref":"/previews/PR43/SPICE/stable/api/#SPICE.m2q-Tuple{Any}","content":" SPICE.m2q  —  Method . m2q(r) Find a unit quaternion corresponding to a specified rotation matrix. Arguments r : A rotation matrix Output A unit quaternion representing `r' References NAIF Documentation source"},{"id":1005,"pagetitle":"API","title":"SPICE.matchi","ref":"/previews/PR43/SPICE/stable/api/#SPICE.matchi-NTuple{4,Any}","content":" SPICE.matchi  —  Method . matchi(string, templ, wstr, wchar) Determine whether a string is matched by a template containing wild cards. The pattern comparison is case-insensitive. Arguments string : String to be tested templ : Template (with wild cards) to test against string wstr : Wild string token wchr : Wild character token Output Returns  true  if the string matches. References NAIF Documentation source"},{"id":1006,"pagetitle":"API","title":"SPICE.matchw","ref":"/previews/PR43/SPICE/stable/api/#SPICE.matchw-NTuple{4,Any}","content":" SPICE.matchw  —  Method . matchw(string, templ, wstr, wchar) Determine whether a string is matched by a template containing wild cards. Arguments string : String to be tested templ : Template (with wild cards) to test against string wstr : Wild string token wchr : Wild character token Output Returns  true  if the string matches. References NAIF Documentation source"},{"id":1007,"pagetitle":"API","title":"SPICE.maxd","ref":"/previews/PR43/SPICE/stable/api/#SPICE.maxd","content":" SPICE.maxd  —  Function . maxd(args...) Deprecated Use  max(args...)  instead. source"},{"id":1008,"pagetitle":"API","title":"SPICE.maxi","ref":"/previews/PR43/SPICE/stable/api/#SPICE.maxi","content":" SPICE.maxi  —  Function . maxi(args...) Deprecated Use  max(args...)  instead. source"},{"id":1009,"pagetitle":"API","title":"SPICE.mequ","ref":"/previews/PR43/SPICE/stable/api/#SPICE.mequ","content":" SPICE.mequ  —  Function . mequ(m1, mout) Deprecated Use  mout .= m1  instead. source"},{"id":1010,"pagetitle":"API","title":"SPICE.mequg","ref":"/previews/PR43/SPICE/stable/api/#SPICE.mequg","content":" SPICE.mequg  —  Function . mequg(m1, mout) Deprecated Use  mout .= m1  instead. source"},{"id":1011,"pagetitle":"API","title":"SPICE.mind","ref":"/previews/PR43/SPICE/stable/api/#SPICE.mind","content":" SPICE.mind  —  Function . mind(args...) Deprecated Use  min(args...)  instead. source"},{"id":1012,"pagetitle":"API","title":"SPICE.mini","ref":"/previews/PR43/SPICE/stable/api/#SPICE.mini","content":" SPICE.mini  —  Function . mini(args...) Deprecated Use  min(args...)  instead. source"},{"id":1013,"pagetitle":"API","title":"SPICE.mtxm","ref":"/previews/PR43/SPICE/stable/api/#SPICE.mtxm","content":" SPICE.mtxm  —  Function . mtxm(m1, m2) Deprecated Use  m1' * m2  instead. source"},{"id":1014,"pagetitle":"API","title":"SPICE.mtxmg","ref":"/previews/PR43/SPICE/stable/api/#SPICE.mtxmg","content":" SPICE.mtxmg  —  Function . mtxmg(m1, m2) Deprecated Use  m1' * m2  instead. source"},{"id":1015,"pagetitle":"API","title":"SPICE.mtxv","ref":"/previews/PR43/SPICE/stable/api/#SPICE.mtxv","content":" SPICE.mtxv  —  Function . mtxv(m1,v2) Deprecated Use  m1' * v2  instead. source"},{"id":1016,"pagetitle":"API","title":"SPICE.mtxvg","ref":"/previews/PR43/SPICE/stable/api/#SPICE.mtxvg","content":" SPICE.mtxvg  —  Function . mtxvg(m1,v2) Deprecated Use  m1' * v2  instead. source"},{"id":1017,"pagetitle":"API","title":"SPICE.mxm","ref":"/previews/PR43/SPICE/stable/api/#SPICE.mxm","content":" SPICE.mxm  —  Function . mxm(m1, m2) Deprecated Use  m1 * m2  instead. source"},{"id":1018,"pagetitle":"API","title":"SPICE.mxmg","ref":"/previews/PR43/SPICE/stable/api/#SPICE.mxmg","content":" SPICE.mxmg  —  Function . mxmg(m1, m2) Deprecated Use  m1 * m2  instead. source"},{"id":1019,"pagetitle":"API","title":"SPICE.mxmt","ref":"/previews/PR43/SPICE/stable/api/#SPICE.mxmt","content":" SPICE.mxmt  —  Function . mxmt(m1, m2) Deprecated Use  m1 * m2'  instead. source"},{"id":1020,"pagetitle":"API","title":"SPICE.mxmtg","ref":"/previews/PR43/SPICE/stable/api/#SPICE.mxmtg","content":" SPICE.mxmtg  —  Function . mxmtg(m1, m2) Deprecated Use  m1 * m2'  instead. source"},{"id":1021,"pagetitle":"API","title":"SPICE.mxv","ref":"/previews/PR43/SPICE/stable/api/#SPICE.mxv","content":" SPICE.mxv  —  Function . mxv(m1,v2) Deprecated Use  m1 * v2  instead. source"},{"id":1022,"pagetitle":"API","title":"SPICE.mxvg","ref":"/previews/PR43/SPICE/stable/api/#SPICE.mxvg","content":" SPICE.mxvg  —  Function . mxvg(m1,v2) Deprecated Use  m1 * v2  instead. source"},{"id":1023,"pagetitle":"API","title":"SPICE.namfrm","ref":"/previews/PR43/SPICE/stable/api/#SPICE.namfrm-Tuple{Any}","content":" SPICE.namfrm  —  Method . namfrm(frname) Look up the frame ID code associated with a string. Arguments frname : The name of some reference frame Output The SPICE ID code of the frame. References NAIF Documentation source"},{"id":1024,"pagetitle":"API","title":"SPICE.ncpos","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ncpos-Tuple{Any,Any,Any}","content":" SPICE.ncpos  —  Method . ncpos(str, chars, start) Find the first occurrence in a string of a character NOT belonging to a collection of characters, starting at a specified location, searching forward. Arguments str : A string chars : A collection of characters start : Position to begin looking for a character not in  chars Output Returns the index of the first character of  str  at or following index  start  that is not in the collection  chars . References NAIF Documentation source"},{"id":1025,"pagetitle":"API","title":"SPICE.ncposr","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ncposr-Tuple{Any,Any,Any}","content":" SPICE.ncposr  —  Method . ncposr(str, chars, start) Find the first occurrence in a string of a character NOT belonging to a collection of characters, starting at a specified location, searching in reverse. Arguments str : A string chars : A collection of characters start : Position to begin looking for a character not in  chars Output Returns the index of the last character of  str  at or before index  start  that is not in the collection  chars . References NAIF Documentation source"},{"id":1026,"pagetitle":"API","title":"SPICE.nearpt","ref":"/previews/PR43/SPICE/stable/api/#SPICE.nearpt-NTuple{4,Any}","content":" SPICE.nearpt  —  Method . nearpt(positn, a, b, c) This routine locates the point on the surface of an ellipsoid that is nearest to a specified position. It also returns the altitude of the position above the ellipsoid. Arguments positn : Position of a point in the bodyfixed frame a : Length of semi-axis parallel to x-axis b : Length of semi-axis parallel to y-axis c : Length on semi-axis parallel to z-axis Output Returns a tuple consisting of  npoint  and  alt . npoint : Point on the ellipsoid closest to  positn alt : Altitude of  positn  above the ellipsoid References NAIF Documentation source"},{"id":1027,"pagetitle":"API","title":"SPICE.npedln","ref":"/previews/PR43/SPICE/stable/api/#SPICE.npedln-NTuple{5,Any}","content":" SPICE.npedln  —  Method . npedln(a, b, c, linept, linedr) Find nearest point on a triaxial ellipsoid to a specified line, and the distance from the ellipsoid to the line. Arguments a : Length of semi-axis in the x direction b : Length of semi-axis in the y direction c : Length of semi-axis in the z direction linept : Point on line linedr : Direction vector of line Output Returns a tuple consisting of  pnear  and  dist . pnear : Nearest point on ellipsoid to line dist : Distance of ellipsoid from line References NAIF Documentation source"},{"id":1028,"pagetitle":"API","title":"SPICE.npelpt","ref":"/previews/PR43/SPICE/stable/api/#SPICE.npelpt-Tuple{Any,Any}","content":" SPICE.npelpt  —  Method . npelpt(point, ellips) Find the nearest point on an ellipse to a specified point, both in three-dimensional space, and find the distance between the ellipse and the point. Arguments point : Point whose distance to an ellipse is to be found ellips : A SPICE ellipse Output Returns a tuple consisting of  pnear  and  dist . pnear : Nearest point on ellipse to input point dist : Distance of input point to ellipse References NAIF Documentation source"},{"id":1029,"pagetitle":"API","title":"SPICE.nplnpt","ref":"/previews/PR43/SPICE/stable/api/#SPICE.nplnpt-Tuple{Any,Any,Any}","content":" SPICE.nplnpt  —  Method . nplnpt(linept, linedr, point) Find the nearest point on a line to a specified point, and find the distance between the two points. Arguments linept : Point on line linedr : Direction vector of line point : A second point Output Returns a tuple consisting of  pnear  and  dist . pnear : Nearest point on the line to  point dist : Distance between  point  and  pnear References NAIF Documentation source"},{"id":1030,"pagetitle":"API","title":"SPICE.nvc2pl","ref":"/previews/PR43/SPICE/stable/api/#SPICE.nvc2pl-Tuple{Any,Any}","content":" SPICE.nvc2pl  —  Method . nvc2pl(norm, point) Make a SPICE plane from a normal vector and a point. Arguments norm : A normal vector... constant : ...and a constant defining a plane Output Returns a struct representing the plane. References NAIF Documentation source"},{"id":1031,"pagetitle":"API","title":"SPICE.nvp2pl","ref":"/previews/PR43/SPICE/stable/api/#SPICE.nvp2pl-Tuple{Any,Any}","content":" SPICE.nvp2pl  —  Method . nvp2pl(norm, point) Make a SPICE plane from a normal vector and a point. Arguments norm : A normal vector... point : ...and a point defining a plane Output Returns a struct representing the plane. References NAIF Documentation source"},{"id":1032,"pagetitle":"API","title":"SPICE.occult","ref":"/previews/PR43/SPICE/stable/api/#SPICE.occult-NTuple{9,Any}","content":" SPICE.occult  —  Method . occult(targ1, shape1, frame1, targ2, shape2, frame2, abcorr, obsrvr, et) Determines the occultation condition (not occulted, partially, etc.) of one target relative to another target as seen by an observer at a given time. The surfaces of the target bodies may be represented by triaxial ellipsoids or by topographic data provided by DSK files. Arguments targ1 : Name or ID of first target. shape1 : Type of shape model used for first target. frame1 : Body-fixed, body-centered frame for first body. targ2 : Name or ID of second target. shape2 : Type of shape model used for second target. frame2 : Body-fixed, body-centered frame for second body. abcorr : Aberration correction flag. obsrvr : Name or ID of the observer. et : Time of the observation (seconds past J2000). Output Returns the occultation identification code. References NAIF Documentation source"},{"id":1033,"pagetitle":"API","title":"SPICE.ordc","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ordc-Tuple{Any,Any}","content":" SPICE.ordc  —  Method . ordc(set, item) The function returns the ordinal position of any given item in a character set. Arguments set : A set to search for a given item item : An item to locate within a set Output Returns the ordinal position or  nothing  if the items does not appear in the set. References NAIF Documentation source"},{"id":1034,"pagetitle":"API","title":"SPICE.ordd","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ordd-Tuple{Any,Any}","content":" SPICE.ordd  —  Method . ordd(set, item) The function returns the ordinal position of any given item in a character set. Arguments set : A set to search for a given item item : An item to locate within a set Output Returns the ordinal position or  nothing  if the items does not appear in the set. References NAIF Documentation source"},{"id":1035,"pagetitle":"API","title":"SPICE.orderc","ref":"/previews/PR43/SPICE/stable/api/#SPICE.orderc","content":" SPICE.orderc  —  Function . orderc(array) Deprecated Use  sortperm  instead. source"},{"id":1036,"pagetitle":"API","title":"SPICE.orderd","ref":"/previews/PR43/SPICE/stable/api/#SPICE.orderd","content":" SPICE.orderd  —  Function . orderd(array) Deprecated Use  sortperm  instead. source"},{"id":1037,"pagetitle":"API","title":"SPICE.orderi","ref":"/previews/PR43/SPICE/stable/api/#SPICE.orderi","content":" SPICE.orderi  —  Function . orderi(array) Deprecated Use  sortperm  instead. source"},{"id":1038,"pagetitle":"API","title":"SPICE.ordi","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ordi-Tuple{Any,Any}","content":" SPICE.ordi  —  Method . ordi(set, item) The function returns the ordinal position of any given item in a character set. Arguments set : A set to search for a given item item : An item to locate within a set Output Returns the ordinal position or  nothing  if the items does not appear in the set. References NAIF Documentation source"},{"id":1039,"pagetitle":"API","title":"SPICE.oscelt","ref":"/previews/PR43/SPICE/stable/api/#SPICE.oscelt-Tuple{Any,Any,Any}","content":" SPICE.oscelt  —  Method . oscelt(state, et, mu) Determine the set of osculating conic orbital elements that corresponds to the state (position, velocity) of a body at some epoch. Arguments state : State of body at epoch of elements et : Epoch of elements mu : Gravitational parameter (GM) of primary body Output Returns the equivalent conic elements: rp : Perifocal distance ecc : Eccentricity inc : Inclination lnode : Longitude of the ascending node argp : Argument of periapsis m0 : Mean anomaly at epoch t0 : Epoch mu : Gravitational parameter References NAIF Documentation source"},{"id":1040,"pagetitle":"API","title":"SPICE.oscltx","ref":"/previews/PR43/SPICE/stable/api/#SPICE.oscltx-Tuple{Any,Any,Any}","content":" SPICE.oscltx  —  Method . oscltx(state, et, mu) Determine the set of osculating conic orbital elements that corresponds to the state (position, velocity) of a body at some epoch. In addition to the classical elements, return the true anomaly, semi-major axis, and period, if applicable. Arguments state : State of body at epoch of elements et : Epoch of elements mu : Gravitational parameter (GM) of primary body Output Returns the extended set of classical conic elements: rp : Perifocal distance. ecc : Eccentricity. inc : Inclination. lnode : Longitude of the ascending node. argp : Argument of periapsis. m0 : Mean anomaly at epoch. t0 : Epoch. mu : Gravitational parameter. nu : True anomaly at epoch. a : Semi-major axis. A is set to zero if it is not computable. tau : Orbital period. Applicable only for elliptical orbits. Set to zero otherwise. References NAIF Documentation source"},{"id":1041,"pagetitle":"API","title":"SPICE.pckcls","ref":"/previews/PR43/SPICE/stable/api/#SPICE.pckcls-Tuple{Any}","content":" SPICE.pckcls  —  Method . pckcls(handle) Close an open PCK file. Arguments handle : Handle of the PCK file to be closed References NAIF Documentation source"},{"id":1042,"pagetitle":"API","title":"SPICE.pckcov!","ref":"/previews/PR43/SPICE/stable/api/#SPICE.pckcov!-Tuple{Any,Any,Any}","content":" SPICE.pckcov!  —  Method . pckcov!(cover, pck, idcode) Find the coverage window for a specified reference frame in a specified binary PCK file. Arguments cover : An initalized window  SpiceDoubleCell pck : Path of PCK file idcode : Class ID code of PCK reference frame Output Returns  cover  containing coverage in  pck  for  idcode References NAIF Documentation source"},{"id":1043,"pagetitle":"API","title":"SPICE.pckfrm!","ref":"/previews/PR43/SPICE/stable/api/#SPICE.pckfrm!-Tuple{Any,Any}","content":" SPICE.pckfrm!  —  Method . pckfrm!(ids, pck) Find the set of reference frame class ID codes of all frames in a specified binary PCK file. Arguments ids : An initalized  SpiceIntCell pck : Path of PCK file Output Returns  ids  containing a set of frame class ID codes of frames in PCK file. References NAIF Documentation source"},{"id":1044,"pagetitle":"API","title":"SPICE.pcklof","ref":"/previews/PR43/SPICE/stable/api/#SPICE.pcklof-Tuple{Any}","content":" SPICE.pcklof  —  Method . pcklof(filename) Load a binary PCK file for use by the readers. Return the handle of the loaded file which is used by other PCK routines to refer to the file. Arguments filename : Path of the PCK file Output Returns an integer handle. References NAIF Documentation source"},{"id":1045,"pagetitle":"API","title":"SPICE.pckopn","ref":"/previews/PR43/SPICE/stable/api/#SPICE.pckopn-Tuple{Any,Any,Any}","content":" SPICE.pckopn  —  Method . pckopn(name, ifname, ncomch) Create a new PCK file, returning the handle of the opened file. Arguments name : The name of the PCK file to be opened ifname : The internal filename for the PCK ncomch : The number of characters to reserve for comments Output Returns the handle of the opened PCK file. References NAIF Documentation source"},{"id":1046,"pagetitle":"API","title":"SPICE.pckuof","ref":"/previews/PR43/SPICE/stable/api/#SPICE.pckuof-Tuple{Any}","content":" SPICE.pckuof  —  Method . pckuof(handle) Unload a binary PCK file so that it will no longer be searched by the readers. Arguments handle : Integer handle of a PCK file References NAIF Documentation source"},{"id":1047,"pagetitle":"API","title":"SPICE.pckw02","ref":"/previews/PR43/SPICE/stable/api/#SPICE.pckw02-NTuple{9,Any}","content":" SPICE.pckw02  —  Method . pckw02(handle, clssid, frame, first, last, segid, intlen, cdata, btime) Write a type 2 segment to a PCK binary file given the file handle, frame class ID, base frame, time range covered by the segment, and the Chebyshev polynomial coefficients. Arguments handle : Handle of binary PCK file open for writing. clssid : Frame class ID of body-fixed frame. frame : Name of base reference frame. first : Start time of interval covered by segment. last : End time of interval covered by segment. segid : Segment identifier. intlen : Length of time covered by logical record. cdata : Array of Chebyshev coefficients. btime : Begin time of first logical record. References NAIF Documentation source"},{"id":1048,"pagetitle":"API","title":"SPICE.pcpool","ref":"/previews/PR43/SPICE/stable/api/#SPICE.pcpool-Tuple{Any,Any}","content":" SPICE.pcpool  —  Method . pcpool(name, vals) Insert character data into the kernel pool. Arguments name : The kernel pool name to associate with  vals vals : An array of values to insert into the kernel pool References NAIF Documentation source"},{"id":1049,"pagetitle":"API","title":"SPICE.pdpool","ref":"/previews/PR43/SPICE/stable/api/#SPICE.pdpool-Tuple{Any,Any}","content":" SPICE.pdpool  —  Method . pdpool(name, vals) Insert double precision data into the kernel pool. Arguments name : The kernel pool name to associate with  vals vals : An array of values to insert into the kernel pool References NAIF Documentation source"},{"id":1050,"pagetitle":"API","title":"SPICE.pgrrec","ref":"/previews/PR43/SPICE/stable/api/#SPICE.pgrrec-NTuple{6,Any}","content":" SPICE.pgrrec  —  Method . pgrrec(body, lon, lat, alt, re, f) Convert planetographic coordinates to rectangular coordinates. Arguments body : Body with which coordinate system is associated. lon : Planetographic longitude of a point (radians). lat : Planetographic latitude of a point (radians). alt : Altitude of a point above reference spheroid. re : Equatorial radius of the reference spheroid. f : Flattening coefficient. Output Returns the rectangular coordinates of the point. References NAIF Documentation source"},{"id":1051,"pagetitle":"API","title":"SPICE.phaseq","ref":"/previews/PR43/SPICE/stable/api/#SPICE.phaseq-NTuple{5,Any}","content":" SPICE.phaseq  —  Method . phaseq(et, target, illmn, obsrvr, abcorr) Compute the apparent phase angle for a target, observer, illuminator set of ephemeris objects. Arguments et : Ephemeris seconds past J2000 TDB target : Target body name illmn : Illuminating body name obsrvr : Observer body abcorr : Aberration correction flag Output Returns the value of the phase angle. References NAIF Documentation source"},{"id":1052,"pagetitle":"API","title":"SPICE.pipool","ref":"/previews/PR43/SPICE/stable/api/#SPICE.pipool-Tuple{Any,Any}","content":" SPICE.pipool  —  Method . pipool(name, ivals) Insert integer data into the kernel pool. Arguments name : The kernel pool name to associate with the values ivals : An array of integers to insert into the pool References NAIF Documentation source"},{"id":1053,"pagetitle":"API","title":"SPICE.pjelpl","ref":"/previews/PR43/SPICE/stable/api/#SPICE.pjelpl-Tuple{Any,Any}","content":" SPICE.pjelpl  —  Method . pjelpl(elin, plane) Project an ellipse onto a plane, orthogonally. Arguments elin : An ellipse to be projected plane : A plane onto which  elin  is to be projected Output Returns the ellipse resulting from the projection. References NAIF Documentation source"},{"id":1054,"pagetitle":"API","title":"SPICE.pl2nvc","ref":"/previews/PR43/SPICE/stable/api/#SPICE.pl2nvc-Tuple{Any}","content":" SPICE.pl2nvc  —  Method . pl2nvc(plane) Return a unit normal vector and constant that define a specified plane. Arguments plane : A plane Output Returns a tuple consisting of normal : A normal vector and... constant : ... constant defining the geometric plane represented by  plane References NAIF Documentation source"},{"id":1055,"pagetitle":"API","title":"SPICE.pl2nvp","ref":"/previews/PR43/SPICE/stable/api/#SPICE.pl2nvp-Tuple{Any}","content":" SPICE.pl2nvp  —  Method . pl2nvp(plane) Return a unit normal vector and point that define a specified plane. Arguments plane : A plane Output Returns a tuple consisting of normal : A normal vector and... point : ... point defining the geometric plane represented by  plane References NAIF Documentation source"},{"id":1056,"pagetitle":"API","title":"SPICE.pl2psv","ref":"/previews/PR43/SPICE/stable/api/#SPICE.pl2psv-Tuple{Any}","content":" SPICE.pl2psv  —  Method . pl2psv(plane) Return a point and two orthogonal spanning vectors that define a specified plane. Arguments plane : A plane Output Returns a tuple consisting of a point in the  plane  and two vectors spanning the input plane. References NAIF Documentation source"},{"id":1057,"pagetitle":"API","title":"SPICE.pltar","ref":"/previews/PR43/SPICE/stable/api/#SPICE.pltar-Tuple{Any,Any}","content":" SPICE.pltar  —  Method . pltar(vrtces, plates) Compute the total area of a collection of triangular plates. Arguments vrtces : Array of vertices plates : Array of plates Output Returns the area. References NAIF Documentation source"},{"id":1058,"pagetitle":"API","title":"SPICE.pltexp","ref":"/previews/PR43/SPICE/stable/api/#SPICE.pltexp-Tuple{Any,Any}","content":" SPICE.pltexp  —  Method . pltexp(iverts, delta) Expand a triangular plate by a specified amount. The expanded plate is co-planar with, and has the same orientation as, the original. The centroids of the two plates coincide. Arguments iverts : Vertices of the plate to be expanded delta : Fraction by which the plate is to be expanded Output Returns the vertices of the expanded plate. References NAIF Documentation source"},{"id":1059,"pagetitle":"API","title":"SPICE.pltnp","ref":"/previews/PR43/SPICE/stable/api/#SPICE.pltnp-NTuple{4,Any}","content":" SPICE.pltnp  —  Method . pltnp(point, v1, v2, v3) Find the nearest point on a triangular plate to a given point. Arguments point : A point in 3-dimensional space. v1 ,  v2 ,  v3 : Vertices of a triangular plate Output Returns a tuple consisting of pnear : Nearest point on the plate to  point dist : Distance between  pnear  and  point References NAIF Documentation source"},{"id":1060,"pagetitle":"API","title":"SPICE.pltnrm","ref":"/previews/PR43/SPICE/stable/api/#SPICE.pltnrm-Tuple{Any,Any,Any}","content":" SPICE.pltnrm  —  Method . pltnrm(v1, v2, v3) Compute an outward normal vector of a triangular plate.  The vector does not necessarily have unit length. Arguments v1 ,  v2 ,  v3 : Vertices of a plate Output Returns the plate's outward normal vector. References NAIF Documentation source"},{"id":1061,"pagetitle":"API","title":"SPICE.pltvol","ref":"/previews/PR43/SPICE/stable/api/#SPICE.pltvol-Tuple{Any,Any}","content":" SPICE.pltvol  —  Method . pltvol(vrtces, plates) Compute the volume of a three-dimensional region bounded by a collection of triangular plates. Arguments vrtces : Array of vertices plates : Array of plates Output Returns the volume of the spatial region bounded by the plates. References NAIF Documentation source"},{"id":1062,"pagetitle":"API","title":"SPICE.polyds","ref":"/previews/PR43/SPICE/stable/api/#SPICE.polyds-Tuple{Any,Any,Any}","content":" SPICE.polyds  —  Method . polyds(coeffs, nderiv, t) Compute the value of a polynomial and it's first  nderiv  derivatives at the value  t . Arguments coeffs : Coefficients of the polynomial to be evaluated nderiv : Number of derivatives to compute t : Point to evaluate the polynomial and derivatives Output Returns the value of the polynomial and the derivatives as an array. References NAIF Documentation source"},{"id":1063,"pagetitle":"API","title":"SPICE.pos","ref":"/previews/PR43/SPICE/stable/api/#SPICE.pos","content":" SPICE.pos  —  Function . pos(str, substr, start) Deprecated Use  first(findnext(substr, str, start))  instead. source"},{"id":1064,"pagetitle":"API","title":"SPICE.posr","ref":"/previews/PR43/SPICE/stable/api/#SPICE.posr","content":" SPICE.posr  —  Function . posr(str, substr, start) Deprecated Use  first(findprev(substr, str, start))  instead. source"},{"id":1065,"pagetitle":"API","title":"SPICE.prop2b","ref":"/previews/PR43/SPICE/stable/api/#SPICE.prop2b-Tuple{Any,Any,Any}","content":" SPICE.prop2b  —  Method . prop2b(gm, pvinit, dt) Given a central mass and the state of massless body at time  t_0 , this routine determines the state as predicted by a two-body force model at time  t_0 + dt . Arguments gm : Gravity of the central mass. pvinit : Initial state from which to propagate a state. dt : Time offset from initial state to propagate to. Output Returns the propagated state. References NAIF Documentation source"},{"id":1066,"pagetitle":"API","title":"SPICE.prsdp","ref":"/previews/PR43/SPICE/stable/api/#SPICE.prsdp","content":" SPICE.prsdp  —  Function . prsdp(str) Deprecated Use  parse(Float64, str)  instead. source"},{"id":1067,"pagetitle":"API","title":"SPICE.prsint","ref":"/previews/PR43/SPICE/stable/api/#SPICE.prsint","content":" SPICE.prsint  —  Function . prsint(str) Deprecated Use  parse(Int, str)  instead. source"},{"id":1068,"pagetitle":"API","title":"SPICE.psv2pl","ref":"/previews/PR43/SPICE/stable/api/#SPICE.psv2pl-Tuple{Any,Any,Any}","content":" SPICE.psv2pl  —  Method . psv2pl(point, span1, span2) Make a plane from a point and two spanning vectors. Arguments point ,  span1 ,  span2 : A point and two spanning vectors defining a plane Output Returns the plane. References NAIF Documentation source"},{"id":1069,"pagetitle":"API","title":"SPICE.pxform","ref":"/previews/PR43/SPICE/stable/api/#SPICE.pxform-Tuple{Any,Any,Any}","content":" SPICE.pxform  —  Method . pxform(from, to, et) Return the matrix that transforms position vectors from one specified frame to another at a specified epoch. Arguments from : Name of the frame to transform from to : Name of the frame to transform to et : Epoch of the rotation matrix Output Returns the rotation matrix. References NAIF Documentation source"},{"id":1070,"pagetitle":"API","title":"SPICE.pxfrm2","ref":"/previews/PR43/SPICE/stable/api/#SPICE.pxfrm2-NTuple{4,Any}","content":" SPICE.pxfrm2  —  Method . pxfrm2(from, to, etfrom, etto) Return the 3x3 matrix that transforms position vectors from one specified frame at a specified epoch to another specified frame at another specified epoch. Arguments from : Name of the frame to transform from to : Name of the frame to transform to etfrom : Evaluation time of  from  frame etto : Evaluation time of  to  frame Output Returns a position transformation matrix from frame  from  to frame  to . References NAIF Documentation source"},{"id":1071,"pagetitle":"API","title":"SPICE.q2m","ref":"/previews/PR43/SPICE/stable/api/#SPICE.q2m-Tuple{Any}","content":" SPICE.q2m  —  Method . q2m(q) Find the rotation matrix corresponding to a specified unit quaternion. Arguments q : A unit quaternion Output A rotation matrix corresponding to  q . References NAIF Documentation source"},{"id":1072,"pagetitle":"API","title":"SPICE.qdq2av","ref":"/previews/PR43/SPICE/stable/api/#SPICE.qdq2av-Tuple{Any,Any}","content":" SPICE.qdq2av  —  Method . qdq2av(q, dq) Derive angular velocity from a unit quaternion and its derivative with respect to time. Arguments q : Unit SPICE quaternion (as any kind of iterable with four elements) dq : Derivative of `q' with respect to time Output Angular velocity vector defined by  q' and dq' References NAIF Documentation source"},{"id":1073,"pagetitle":"API","title":"SPICE.qxq","ref":"/previews/PR43/SPICE/stable/api/#SPICE.qxq-Tuple{Any,Any}","content":" SPICE.qxq  —  Method . qxq(q1, q2) Multiply two quaternions. Arguments q1 : First SPICE quaternion factor (as any kind of iterable with four elements) q2 : Second SPICE quaternion factor (as any kind of iterable with four elements) Output A quaternion corresponding to the product of  q1' and q2' References NAIF Documentation source"},{"id":1074,"pagetitle":"API","title":"SPICE.radrec","ref":"/previews/PR43/SPICE/stable/api/#SPICE.radrec-Tuple{Any,Any,Any}","content":" SPICE.radrec  —  Method . radrec(range, ra, dec) Convert from range, right ascension, and declination to rectangular coordinates. Arguments range : Distance of a point from the origin ra : Right ascension of point in radians dec : Declination of point in radians Output Returns the rectangular coordinates of the point. References NAIF Documentation source"},{"id":1075,"pagetitle":"API","title":"SPICE.rav2xf","ref":"/previews/PR43/SPICE/stable/api/#SPICE.rav2xf-Tuple{Any,Any}","content":" SPICE.rav2xf  —  Method . rav2xf(rot, av) Determine a state transformation matrix from a rotation matrix and the angular velocity of the rotation. Arguments rot : Rotation matrix av : Angular velocity vector Output Returns state transformation matrix associated with  rot  and  av . References NAIF Documentation source"},{"id":1076,"pagetitle":"API","title":"SPICE.raxisa","ref":"/previews/PR43/SPICE/stable/api/#SPICE.raxisa-Tuple{Any}","content":" SPICE.raxisa  —  Method . raxisa(matrix) Compute the axis of the rotation given by an input matrix and the angle of the rotation about that axis. Arguments matrix : A 3x3 rotation matrix Output axis : Axis of the rotation angle : Angle through which the rotation is performed References NAIF Documentation source"},{"id":1077,"pagetitle":"API","title":"SPICE.reccyl","ref":"/previews/PR43/SPICE/stable/api/#SPICE.reccyl-Tuple{Any}","content":" SPICE.reccyl  —  Method . reccyl(rectan) Convert from rectangular to cylindrical coordinates. Arguments rectan : Rectangular coordinates of a point Output r : Distance of the point from the Z axis lon : Angle (radians) of the point from the XZ plane z : Height of the point above the XY plane References NAIF Documentation source"},{"id":1078,"pagetitle":"API","title":"SPICE.recgeo","ref":"/previews/PR43/SPICE/stable/api/#SPICE.recgeo-Tuple{Any,Any,Any}","content":" SPICE.recgeo  —  Method . recgeo(rectan, re, f) Convert from rectangular coordinates to geodetic coordinates. Arguments rectan : Rectangular coordinates of a point re : Equatorial radius of the reference spheroid f : Flattening coefficient Output lon : Geodetic longitude of the point (radians) lat : Geodetic latitude  of the point (radians) alt : Altitude of the point above reference spheroid References NAIF Documentation source"},{"id":1079,"pagetitle":"API","title":"SPICE.reclat","ref":"/previews/PR43/SPICE/stable/api/#SPICE.reclat-Tuple{Any}","content":" SPICE.reclat  —  Method . reclat(rectan) Convert from rectangular coordinates to latitudinal coordinates. Arguments rectan : Rectangular coordinates of a point Output Returns a tuple consisting of: rad : Distance of the point from the origin lon : Planetographic longitude of the point (radians) lat : Planetographic latitude of the point (radians) References NAIF Documentation source"},{"id":1080,"pagetitle":"API","title":"SPICE.recpgr","ref":"/previews/PR43/SPICE/stable/api/#SPICE.recpgr-NTuple{4,Any}","content":" SPICE.recpgr  —  Method . recpgr(body, rectan, re, f) Convert rectangular coordinates to planetographic coordinates. Arguments body : Body with which coordinate system is associated rectan : Rectangular coordinates of a point re : Equatorial radius of the reference spheroid f : flattening coefficient Output lon : Planetographic longitude of the point (radians). lat : Planetographic latitude of the point (radians). alt : Altitude of the point above reference spheroid. References NAIF Documentation source"},{"id":1081,"pagetitle":"API","title":"SPICE.recrad","ref":"/previews/PR43/SPICE/stable/api/#SPICE.recrad-Tuple{Any}","content":" SPICE.recrad  —  Method . recrad(rectan) Convert rectangular coordinates to range, right ascension, and declination. Arguments rectan : Rectangular coordinates of a point Output Return the tuple  (range, ra, dec) . range : Distance of the point from the origin ra : Right ascension in radians dec : Declination in radians References NAIF Documentation source"},{"id":1082,"pagetitle":"API","title":"SPICE.recsph","ref":"/previews/PR43/SPICE/stable/api/#SPICE.recsph-Tuple{Any}","content":" SPICE.recsph  —  Method . recsph(rectan) Convert from rectangular coordinates to spherical coordinates. Arguments rectan : Rectangular coordinates of a point Output r : Distance of the point from the origin colat : Angle of the point from the Z-axis in radian lon : Longitude of the point in radians References NAIF Documentation source"},{"id":1083,"pagetitle":"API","title":"SPICE.removc!","ref":"/previews/PR43/SPICE/stable/api/#SPICE.removc!-Tuple{Any,Any}","content":" SPICE.removc!  —  Method . removc!(set, item) Remove an item from a character set. Arguments set : A set item : Item to be removed Output Returns the updated set. References NAIF Documentation source"},{"id":1084,"pagetitle":"API","title":"SPICE.removd!","ref":"/previews/PR43/SPICE/stable/api/#SPICE.removd!-Tuple{Any,Any}","content":" SPICE.removd!  —  Method . removd!(set, item) Remove an item from a double set. Arguments set : A set item : Item to be removed Output Returns the updated set. References NAIF Documentation source"},{"id":1085,"pagetitle":"API","title":"SPICE.removi!","ref":"/previews/PR43/SPICE/stable/api/#SPICE.removi!-Tuple{Any,Any}","content":" SPICE.removi!  —  Method . removi!(set, item) Remove an item from a character set. Arguments set : A set item : Item to be removed Output Returns the updated set. References NAIF Documentation source"},{"id":1086,"pagetitle":"API","title":"SPICE.reordc","ref":"/previews/PR43/SPICE/stable/api/#SPICE.reordc","content":" SPICE.reordc  —  Function . reordc(iorder, array) Deprecated Use  array[iorder]  instead. source"},{"id":1087,"pagetitle":"API","title":"SPICE.reordd","ref":"/previews/PR43/SPICE/stable/api/#SPICE.reordd","content":" SPICE.reordd  —  Function . reordd(iorder, array) Deprecated Use  array[iorder]  instead. source"},{"id":1088,"pagetitle":"API","title":"SPICE.reordi","ref":"/previews/PR43/SPICE/stable/api/#SPICE.reordi","content":" SPICE.reordi  —  Function . reordi(iorder, array) Deprecated Use  array[iorder]  instead. source"},{"id":1089,"pagetitle":"API","title":"SPICE.reordl","ref":"/previews/PR43/SPICE/stable/api/#SPICE.reordl","content":" SPICE.reordl  —  Function . reordl(iorder, array) Deprecated Use  array[iorder]  instead. source"},{"id":1090,"pagetitle":"API","title":"SPICE.repmc","ref":"/previews/PR43/SPICE/stable/api/#SPICE.repmc","content":" SPICE.repmc  —  Function . repmc(input, marker, value) Deprecated Use  replace(input, marker=>value)  instead. source"},{"id":1091,"pagetitle":"API","title":"SPICE.repmct","ref":"/previews/PR43/SPICE/stable/api/#SPICE.repmct","content":" SPICE.repmct  —  Function . repmct Deprecated Use  replace  instead. source"},{"id":1092,"pagetitle":"API","title":"SPICE.repmd","ref":"/previews/PR43/SPICE/stable/api/#SPICE.repmd","content":" SPICE.repmd  —  Function . repmd Deprecated Use  replace  instead. source"},{"id":1093,"pagetitle":"API","title":"SPICE.repmf","ref":"/previews/PR43/SPICE/stable/api/#SPICE.repmf","content":" SPICE.repmf  —  Function . repmf Deprecated Use  replace  instead. source"},{"id":1094,"pagetitle":"API","title":"SPICE.repmi","ref":"/previews/PR43/SPICE/stable/api/#SPICE.repmi","content":" SPICE.repmi  —  Function . repmi Deprecated Use  replace  instead. source"},{"id":1095,"pagetitle":"API","title":"SPICE.repmot","ref":"/previews/PR43/SPICE/stable/api/#SPICE.repmot","content":" SPICE.repmot  —  Function . repmot Deprecated Use  replace  instead. source"},{"id":1096,"pagetitle":"API","title":"SPICE.rotate","ref":"/previews/PR43/SPICE/stable/api/#SPICE.rotate-Tuple{Any,Any}","content":" SPICE.rotate  —  Method . rotate(angle, iaxis) Calculate the 3x3 rotation matrix generated by a rotation of a specified angle about a specified axis. This rotation is thought of as rotating the coordinate system. Arguments angle : Angle of rotation (radians) iaxis : Axis of rotation (X=1, Y=2, Z=3) Output Returns rotation matrix associated with  angle  and  iaxis . References NAIF Documentation source"},{"id":1097,"pagetitle":"API","title":"SPICE.rotmat","ref":"/previews/PR43/SPICE/stable/api/#SPICE.rotmat-Tuple{Any,Any,Any}","content":" SPICE.rotmat  —  Method . rotmat(m1, angle, iaxis) Applies a rotation of  angle  radians about axis  iaxis  to a matrix  m1 . This rotation is thought of as rotating the coordinate system. Arguments m1 : Matrix to be rotated angle : Angle of rotation (radians) iaxis : Axis of rotation (X=1, Y=2, Z=3) Output Returns the resulting rotated matrix. References NAIF Documentation source"},{"id":1098,"pagetitle":"API","title":"SPICE.rotvec","ref":"/previews/PR43/SPICE/stable/api/#SPICE.rotvec-Tuple{Any,Any,Any}","content":" SPICE.rotvec  —  Method . rotvec(v1, angle, iaxis) Transform a vector to a new coordinate system rotated by  angle  radians about axis  iaxis . This transformation rotates  v1  by  -angle  radians about the specified axis. Arguments v1 : Vector whose coordinate system is to be rotated angle : Angle of rotation in radians iaxis : Axis of rotation (X=1, Y=2, Z=3) Output Returns the resulting vector expressed in the new coordinate system. References NAIF Documentation source"},{"id":1099,"pagetitle":"API","title":"SPICE.rpd","ref":"/previews/PR43/SPICE/stable/api/#SPICE.rpd","content":" SPICE.rpd  —  Function . rpd() Deprecated Use  deg2rad  instead. source"},{"id":1100,"pagetitle":"API","title":"SPICE.rquad","ref":"/previews/PR43/SPICE/stable/api/#SPICE.rquad-Tuple{Any,Any,Any}","content":" SPICE.rquad  —  Method . rquad(a, b, c) Find the roots of a quadratic equation. Arguments a : Coefficient of quadratic term b : Coefficient of linear term c : Constant Output root1 : Root built from positive discriminant term root2 : Root built from negative discriminant term References NAIF Documentation source"},{"id":1101,"pagetitle":"API","title":"SPICE.saelgv","ref":"/previews/PR43/SPICE/stable/api/#SPICE.saelgv-Tuple{Any,Any}","content":" SPICE.saelgv  —  Method . saelgv(vec1, vec2) Find semi-axis vectors of an ellipse generated by two arbitrary three-dimensional vectors. Arguments vec1 ,  vec2 : Two vectors used to generate an ellipse Output smajor : Semi-major axis of ellipse sminor : Semi-minor axis of ellipse References NAIF Documentation source"},{"id":1102,"pagetitle":"API","title":"SPICE.scard!","ref":"/previews/PR43/SPICE/stable/api/#SPICE.scard!-Union{Tuple{T}, Tuple{SPICE.SpiceCell{T,T1,N} where N where T1,Any}} where T","content":" SPICE.scard!  —  Method . scard!(cell::SpiceCell{T}, card) where T Set the cardinality of a cell. Arguments cell : The cell card : Cardinality of (number of elements in) the cell Output Returns  cell  with its cardinality set to  card . References NAIF Documentation source"},{"id":1103,"pagetitle":"API","title":"SPICE.scdecd","ref":"/previews/PR43/SPICE/stable/api/#SPICE.scdecd","content":" SPICE.scdecd  —  Function . scdecd(sc, sclkdp, lenout=128) Convert double precision encoding of spacecraft clock time into a character representation. Arguments sc : NAIF spacecraft identification code sclkdp : Encoded representation of a spacecraft clock count lenout : Maximum allowed length of output SCLK string Output Returns the character representation of a clock count. References NAIF Documentation source"},{"id":1104,"pagetitle":"API","title":"SPICE.sce2c","ref":"/previews/PR43/SPICE/stable/api/#SPICE.sce2c-Tuple{Any,Any}","content":" SPICE.sce2c  —  Method . sce2c(sc, et) Convert ephemeris seconds past J2000 (ET) to continuous encoded spacecraft clock (\"ticks\"). Non-integral tick values may be returned. Arguments sc : NAIF spacecraft ID code et : Ephemeris time, seconds past J2000 Output Returns SCLK, encoded as ticks since spacecraft clock start. References NAIF Documentation source"},{"id":1105,"pagetitle":"API","title":"SPICE.sce2s","ref":"/previews/PR43/SPICE/stable/api/#SPICE.sce2s","content":" SPICE.sce2s  —  Function . sce2s(sc, et, lenout=128) Convert an epoch specified as ephemeris seconds past J2000 (ET) to a character string representation of a spacecraft clock value (SCLK). Arguments sc : NAIF spacecraft identification code et : Ephemeris time, specified as seconds past J2000 lenout : Maximum allowed length of output SCLK string Output Returns an SCLK string. References NAIF Documentation source"},{"id":1106,"pagetitle":"API","title":"SPICE.sce2t","ref":"/previews/PR43/SPICE/stable/api/#SPICE.sce2t-Tuple{Any,Any}","content":" SPICE.sce2t  —  Method . sce2t(sc, et) Convert ephemeris seconds past J2000 (ET) to integral encoded spacecraft clock (\"ticks\"). For conversion to fractional ticks, (required for C-kernel production), see the routine  sce2c . Arguments sc : NAIF spacecraft ID code et : Ephemeris time, seconds past J2000 Output Returns SCLK, encoded as ticks since spacecraft clock start. References NAIF Documentation source"},{"id":1107,"pagetitle":"API","title":"SPICE.scencd","ref":"/previews/PR43/SPICE/stable/api/#SPICE.scencd-Tuple{Any,Any}","content":" SPICE.scencd  —  Method . scencd(sc, sclkch) Encode character representation of spacecraft clock time into a double precision number. Arguments sc : NAIF spacecraft identification code sclkch : Character representation of a spacecraft clock Output Returns the encoded representation of the clock count. References NAIF Documentation source"},{"id":1108,"pagetitle":"API","title":"SPICE.scfmt","ref":"/previews/PR43/SPICE/stable/api/#SPICE.scfmt","content":" SPICE.scfmt  —  Function . scfmt(sc, ticks, lenout=128) Convert encoded spacecraft clock ticks to character clock format. Arguments sc : NAIF spacecraft identification code ticks : Encoded representation of a spacecraft clock count lenout : Maximum allowed length of output string Output Returns a character representation of a clock count. References NAIF Documentation source"},{"id":1109,"pagetitle":"API","title":"SPICE.scpart","ref":"/previews/PR43/SPICE/stable/api/#SPICE.scpart-Tuple{Any}","content":" SPICE.scpart  —  Method . scpart(sc) Get spacecraft clock partition information from a spacecraft clock kernel file. Arguments sc : NAIF spacecraft identification code Output pstart : Array of partition start times pstop : Array of partition stop times References NAIF Documentation source"},{"id":1110,"pagetitle":"API","title":"SPICE.scs2e","ref":"/previews/PR43/SPICE/stable/api/#SPICE.scs2e-Tuple{Any,Any}","content":" SPICE.scs2e  —  Method . scs2e(sc, sclkch) Convert a spacecraft clock string to ephemeris seconds past J2000 (ET). Arguments sc : NAIF integer code for a spacecraft sclkch : An SCLK string Output Returns ephemeris time seconds past J2000. References NAIF Documentation source"},{"id":1111,"pagetitle":"API","title":"SPICE.sct2e","ref":"/previews/PR43/SPICE/stable/api/#SPICE.sct2e-Tuple{Any,Any}","content":" SPICE.sct2e  —  Method . sct2e(sc, sclkdp) Convert encoded spacecraft clock (\"ticks\") to ephemeris seconds past J2000 (ET). Arguments sc : NAIF integer code for a spacecraft sclkdp : SCLK, encoded as ticks since spacecraft clock start. Output Returns ephemeris time seconds past J2000. References NAIF Documentation source"},{"id":1112,"pagetitle":"API","title":"SPICE.sctiks","ref":"/previews/PR43/SPICE/stable/api/#SPICE.sctiks-Tuple{Any,Any}","content":" SPICE.sctiks  —  Method . sctiks(sc, clkstr) Convert a spacecraft clock format string to number of \"ticks\". Arguments sc : NAIF spacecraft identification code clkstr : Character representation of a spacecraft clock Output Returns the number of ticks represented by the clock string. References NAIF Documentation source"},{"id":1113,"pagetitle":"API","title":"SPICE.sdiff","ref":"/previews/PR43/SPICE/stable/api/#SPICE.sdiff-Union{Tuple{T}, Tuple{SPICE.SpiceCell{T,T1,N} where N where T1,SPICE.SpiceCell{T,T1,N} where N where T1}} where T","content":" SPICE.sdiff  —  Method . sdiff(a::T, b::T) where T <: SpiceCell Compute the symmetric difference of two sets of any data type to form a third set. Arguments a : First input set b : Second input set Output Returns a cell containing the symmetric difference of  a  and  b . References NAIF Documentation source"},{"id":1114,"pagetitle":"API","title":"SPICE.set","ref":"/previews/PR43/SPICE/stable/api/#SPICE.set-Union{Tuple{T}, Tuple{SPICE.SpiceCell{T,T1,N} where N where T1,Any,SPICE.SpiceCell{T,T1,N} where N where T1}} where T","content":" SPICE.set  —  Method . set(a::T, b::T) where T <: SpiceCell Given a relational operator, compare two sets of any data type. Arguments a : First set op : Comparison operator b : Second set Output Returns the result of the comparison:  a (op) b . References NAIF Documentation source"},{"id":1115,"pagetitle":"API","title":"SPICE.shellc","ref":"/previews/PR43/SPICE/stable/api/#SPICE.shellc","content":" SPICE.shellc  —  Function . shellc(array) Deprecated Use  sort!(array)  instead. source"},{"id":1116,"pagetitle":"API","title":"SPICE.shelld","ref":"/previews/PR43/SPICE/stable/api/#SPICE.shelld","content":" SPICE.shelld  —  Function . shelld(array) Deprecated Use  sort!(array)  instead. source"},{"id":1117,"pagetitle":"API","title":"SPICE.shelli","ref":"/previews/PR43/SPICE/stable/api/#SPICE.shelli","content":" SPICE.shelli  —  Function . shelli(array) Deprecated Use  sort!(array)  instead. source"},{"id":1118,"pagetitle":"API","title":"SPICE.sincpt","ref":"/previews/PR43/SPICE/stable/api/#SPICE.sincpt-NTuple{8,Any}","content":" SPICE.sincpt  —  Method . sincpt(method, target, et, fixref, abcorr, obsrvr, dref, dvec) Given an observer and a direction vector defining a ray, compute the surface intercept of the ray on a target body at a specified epoch, optionally corrected for light time and stellar aberration. The surface of the target body may be represented by a triaxial ellipsoid or by topographic data provided by DSK files. Arguments method : Computation method target : Name of target body et : Epoch in TDB seconds past J2000 TDB fixref : Body-fixed, body-centered target body frame abcorr : Aberration correction flag obsrvr : Name of observing body dref : Reference frame of ray's direction vector dvec : Ray's direction vector Output Returns a tuple consisting of the following data or  nothing  if no intercept was found. spoint : Surface intercept point on the target body trgepc : Intercept epoch srfvec : Vector from observer to intercept point References NAIF Documentation source"},{"id":1119,"pagetitle":"API","title":"SPICE.size_c","ref":"/previews/PR43/SPICE/stable/api/#SPICE.size_c-Tuple{Any}","content":" SPICE.size_c  —  Method . size_c(cell::SpiceCell) Returns the maximum number of elements that  cell  can hold. source"},{"id":1120,"pagetitle":"API","title":"SPICE.spd","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spd-Tuple{}","content":" SPICE.spd  —  Method . spd() Returns the number of seconds in a day. References NAIF Documentation source"},{"id":1121,"pagetitle":"API","title":"SPICE.sphcyl","ref":"/previews/PR43/SPICE/stable/api/#SPICE.sphcyl-Tuple{Any,Any,Any}","content":" SPICE.sphcyl  —  Method . sphcyl(radius, colat, slon) Converts from spherical coordinates to cylindrical coordinates. Arguments radius : Distance of point from origin colat : Polar angle (co-latitude in radians) of point slon : Azimuthal angle (longitude) of point (radians) Output r : Distance of point from Z axis lon : Angle (radians) of point from XZ plane z : Height of point above XY plane References NAIF Documentation source"},{"id":1122,"pagetitle":"API","title":"SPICE.sphlat","ref":"/previews/PR43/SPICE/stable/api/#SPICE.sphlat-Tuple{Any,Any,Any}","content":" SPICE.sphlat  —  Method . sphlat(r, colat, lons) Convert from spherical coordinates to latitudinal coordinates. Arguments r : Distance of the point from the origin colat : Angle of the point from positive z axis (radians) lons : Angle of the point from the XZ plane (radians) Output radius : Distance of a point from the origin lon : Angle of the point from the XZ plane in radians lat : Angle of the point from the XY plane in radians References NAIF Documentation source"},{"id":1123,"pagetitle":"API","title":"SPICE.sphrec","ref":"/previews/PR43/SPICE/stable/api/#SPICE.sphrec-Tuple{Any,Any,Any}","content":" SPICE.sphrec  —  Method . sphrec(r, colat, lon) Convert from spherical coordinates to rectangular coordinates. Arguments r : Distance of a point from the origin colat : Angle of the point from the Z-axis in radians lon : Angle of the point from the XZ plane in radians Output Returns the rectangular coordinates of the point. References NAIF Documentation source"},{"id":1124,"pagetitle":"API","title":"SPICE.spk14a","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spk14a-NTuple{4,Any}","content":" SPICE.spk14a  —  Method . spk14a(handle, ncsets, coeffs, epochs) Add data to a type 14 SPK segment associated with  handle . See also  spk14b  and  spk14e . Arguments handle : The handle of an SPK file open for writing ncsets : The number of coefficient sets and epochs coeffs : The collection of coefficient sets epochs : The epochs associated with the coefficient sets References NAIF Documentation source"},{"id":1125,"pagetitle":"API","title":"SPICE.spk14b","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spk14b-NTuple{8,Any}","content":" SPICE.spk14b  —  Method . spk14b(handle, segid, body, center, frame, first, last, chbdeg) Begin a type 14 SPK segment in the SPK file associated with  handle . See also  spk14a  and  spk14e . Arguments handle : The handle of an SPK file open for writing segid : The string to use for segment identifier body : The NAIF ID code for the body of the segment center : The center of motion for body frame : The reference frame for this segment first : The first epoch for which the segment is valid last : The last epoch for which the segment is valid chbdeg : The degree of the Chebyshev Polynomial used References NAIF Documentation source"},{"id":1126,"pagetitle":"API","title":"SPICE.spk14e","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spk14e-Tuple{Any}","content":" SPICE.spk14e  —  Method . spk14e(handle) End the type 14 SPK segment currently being written to the SPK file associated with  handle . See also  spk14a  and  spk14b . Arguments handle : The handle of an SPK file open for writing Output Returns the handle of the SPK file. References NAIF Documentation source"},{"id":1127,"pagetitle":"API","title":"SPICE.spkacs","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkacs-NTuple{5,Any}","content":" SPICE.spkacs  —  Method . spkacs(targ, et, ref, abcorr, obs, starg, lt, dlt) Return the state (position and velocity) of a target body relative to an observer, optionally corrected for light time and stellar aberration, expressed relative to an inertial reference frame. Arguments targ : Target body et : Observer epoch ref : Inertial reference frame of output state abcorr : Aberration correction flag obs : Observer Output starg : State of target lt : One way light time between observer and target dlt : Derivative of light time with respect to time References NAIF Documentation source"},{"id":1128,"pagetitle":"API","title":"SPICE.spkapo","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkapo-NTuple{5,Any}","content":" SPICE.spkapo  —  Method . spkapo(targ, et, ref, sobs, abcorr) Return the position of a target body relative to an observer, optionally corrected for light time and stellar aberration. Arguments targ : Target body et : Observer epoch ref : Inertial reference frame of observer's state sobs : State of observer wrt. solar system barycenter abcorr : Aberration correction flag Output ptarg : Position of target lt : One way light time between observer and target References NAIF Documentation source"},{"id":1129,"pagetitle":"API","title":"SPICE.spkaps","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkaps-NTuple{6,Any}","content":" SPICE.spkaps  —  Method . spkaps(targ, et, ref, abcorr, stobs, accobs) Given the state and acceleration of an observer relative to the solar system barycenter, return the state (position and velocity) of a target body relative to the observer, optionally corrected for light time and stellar aberration. All input and output vectors are expressed relative to an inertial reference frame. Users normally should call the high-level API routines  spkezr  or  spkez  rather than this routine. Arguments targ : Target body. et : Observer epoch. ref : Inertial reference frame of output state. abcorr : Aberration correction flag. stobs : State of the observer relative to the SSB. accobs : Acceleration of the observer relative to the SSB. Output starg : State of target. lt : One way light time between observer and target. dlt : Derivative of light time with respect to time. References NAIF Documentation source"},{"id":1130,"pagetitle":"API","title":"SPICE.spkcls","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkcls-Tuple{Any}","content":" SPICE.spkcls  —  Method . spkcls(handle) Close an open SPK file. Arguments handle : Handle of the SPK file to be closed Output Returns the handle of the closed file. References NAIF Documentation source"},{"id":1131,"pagetitle":"API","title":"SPICE.spkcov!","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkcov!-Tuple{Any,Any,Any}","content":" SPICE.spkcov!  —  Method . spkcov!(cover, spk, idcode) Find the coverage window for a specified ephemeris object in a specified SPK file. Arguments cover : Window giving coverage in  spk  for  idcode spk : Name of the SPK file idcode : ID code of ephemeris object Output Returns the extended coverage window. References NAIF Documentation source"},{"id":1132,"pagetitle":"API","title":"SPICE.spkcpo","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkcpo-NTuple{8,Any}","content":" SPICE.spkcpo  —  Method . spkcpo(target, et, outref, refloc, abcorr, obspos, obsctr, obsref) Return the state of a specified target relative to an \"observer,\" where the observer has constant position in a specified reference frame. The observer's position is provided by the calling program rather than by loaded SPK files. Arguments target : Name of target ephemeris object et : Observation epoch outref : Reference frame of output state refloc : Output reference frame evaluation locus abcorr : Aberration correction obspos : Observer position relative to center of motion obsctr : Center of motion of observer obsref : Frame of observer position Output state : State of target with respect to observer lt : One way light time between target and observer References NAIF Documentation source"},{"id":1133,"pagetitle":"API","title":"SPICE.spkcpt","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkcpt-NTuple{8,Any}","content":" SPICE.spkcpt  —  Method . spkcpt(trgpos, trgctr, trgref, et, outref, refloc, abcorr, obsrvr) Return the state, relative to a specified observer, of a target having constant position in a specified reference frame. The target's position is provided by the calling program rather than by loaded SPK files. Arguments trgpos : Target position relative to center of motion trgctr : Center of motion of target trgref : Frame of target position et : Observation epoch outref : Reference frame of output state refloc : Output reference frame evaluation locus abcorr : Aberration correction obsrvr : Name of observing ephemeris object Output state : State of target with respect to observer lt : One way light time between target and observer References NAIF Documentation source"},{"id":1134,"pagetitle":"API","title":"SPICE.spkcvo","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkcvo-NTuple{9,Any}","content":" SPICE.spkcvo  —  Method . spkcvo(target, et, outref, refloc, abcorr, obssta, obsepc, obsctr, obsref) Return the state of a specified target relative to an \"observer,\" where the observer has constant velocity in a specified reference frame.  The observer's state is provided by the calling program rather than by loaded SPK files. Arguments target : Name of target ephemeris object et : Observation epoch outref : Reference frame of output state refloc : Output reference frame evaluation locus abcorr : Aberration correction obssta : Observer state relative to center of motion obsepc : Epoch of observer state obsctr : Center of motion of observer obsref : Frame of observer state Output state : State of target with respect to observer lt : One way light time between target and observer References NAIF Documentation source"},{"id":1135,"pagetitle":"API","title":"SPICE.spkcvt","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkcvt-NTuple{9,Any}","content":" SPICE.spkcvt  —  Method . spkcvt(trgsta, trgepc, trgctr, trgref, et, outref, refloc, abcorr, obsrvr) Return the state, relative to a specified observer, of a target having constant velocity in a specified reference frame. The target's state is provided by the calling program rather than by loaded SPK files. Arguments trgsta : Target state relative to center of motion trgepc : Epoch of target state trgctr : Center of motion of target trgref : Frame of target state et : Observation epoch outref : Reference frame of output state refloc : Output reference frame evaluation locus abcorr : Aberration correction obsrvr : Name of observing ephemeris object Output state : State of target with respect to observer lt : One way light time between target and observer References NAIF Documentation source"},{"id":1136,"pagetitle":"API","title":"SPICE.spkez","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkez-NTuple{5,Any}","content":" SPICE.spkez  —  Method . spkez(targ, et, ref, abcorr, obs) Return the state (position and velocity) of a target body relative to an observing body, optionally corrected for light time (planetary aberration) and stellar aberration. Arguments targ : Target body et : Observer epoch ref : Reference frame of output state vector abcorr : Aberration correction flag obs : Observing body Output starg : State of target lt : One way light time between observer and target References NAIF Documentation source"},{"id":1137,"pagetitle":"API","title":"SPICE.spkezp","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkezp-NTuple{5,Any}","content":" SPICE.spkezp  —  Method . spkezp(targ, et, ref, abcorr, obs) Return the position of a target body relative to an observing body, optionally corrected for light time (planetary aberration) and stellar aberration. Arguments targ : Target body et : Observer epoch ref : Reference frame of output state vector abcorr : Aberration correction flag obs : Observing body Output ptarg : Position of target lt : One way light time between observer and target References NAIF Documentation source"},{"id":1138,"pagetitle":"API","title":"SPICE.spkezr","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkezr-NTuple{5,Any}","content":" SPICE.spkezr  —  Method . spkezr(targ, et, ref, abcorr, obs) Return the state (position and velocity) of a target body relative to an observing body, optionally corrected for light time (planetary aberration) and stellar aberration. Arguments targ : Target body name et : Observer epoch ref : Reference frame of output state vector abcorr : Aberration correction flag obs : Observing body name Output starg : State of target lt : One way light time between observer and target References NAIF Documentation source"},{"id":1139,"pagetitle":"API","title":"SPICE.spkgeo","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkgeo-NTuple{4,Any}","content":" SPICE.spkgeo  —  Method . spkgeo(targ, et, ref, obs) Compute the geometric state (position and velocity) of a target body relative to an observing body. Arguments targ : Target body. et : Target epoch. ref : Target reference frame. obs : Observing body. Output state : State of target. lt : Light time. References NAIF Documentation source"},{"id":1140,"pagetitle":"API","title":"SPICE.spkgps","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkgps-NTuple{4,Any}","content":" SPICE.spkgps  —  Method . spkgps(targ, et, ref, obs) Compute the geometric position of a target body relative to an observing body. Arguments targ : Target body et : Target epoch ref : Target reference frame obs : Observing body Output pos : Position of target lt : Light time References NAIF Documentation source"},{"id":1141,"pagetitle":"API","title":"SPICE.spklef","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spklef-Tuple{Any}","content":" SPICE.spklef  —  Method . spklef(fname) Load an ephemeris file for use by the readers. Return that file's handle, to be used by other SPK routines to refer to the file. Arguments fname : Name of the file to be loaded Output handle : Loaded file's handle References NAIF Documentation source"},{"id":1142,"pagetitle":"API","title":"SPICE.spkltc","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkltc-NTuple{5,Any}","content":" SPICE.spkltc  —  Method . spkltc(targ, et, ref, abcorr, stobs) Return the state (position and velocity) of a target body relative to an observer, optionally corrected for light time, expressed relative to an inertial reference frame. Arguments targ : Target body et : Observer epoch ref : Inertial reference frame of output state abcorr : Aberration correction flag stobs : State of the observer relative to the SSB Output starg : State of target lt : One way light time between observer and target dlt : Derivative of light time with respect to time References NAIF Documentation source"},{"id":1143,"pagetitle":"API","title":"SPICE.spkobj!","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkobj!-Tuple{Any,Any}","content":" SPICE.spkobj!  —  Method . spkobj!(ids, spk) Find the set of ID codes of all objects in a specified SPK file. Arguments ids : A preallocated set of ID codes of objects in SPK file spk : Name of the SPK file Output Returns the set of id codes. References NAIF Documentation source"},{"id":1144,"pagetitle":"API","title":"SPICE.spkopa","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkopa-Tuple{Any}","content":" SPICE.spkopa  —  Method . spkopa(file) Open an existing SPK file for subsequent write. Arguments file : The name of an existing SPK file Output Returns a handle attached to the SPK file opened to append. References NAIF Documentation source"},{"id":1145,"pagetitle":"API","title":"SPICE.spkopn","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkopn","content":" SPICE.spkopn  —  Function . spkopn(name, ifname=\"\", ncomch=0) Create a new SPK file, returning the handle of the opened file. Arguments name : The name of the new SPK file to be created ifname : The internal filename for the SPK file (default: \"\") ncomch : The number of characters to reserve for comments (default: 0) Output Returns the handle of the opened SPK file. References NAIF Documentation source"},{"id":1146,"pagetitle":"API","title":"SPICE.spkpds","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkpds-NTuple{6,Any}","content":" SPICE.spkpds  —  Method . spkpds(body, center, frame, typ, first, last) Perform routine error checks and if all checks pass, pack the descriptor for an SPK segment. Arguments body : The NAIF ID code for the body of the segment center : The center of motion for body frame : The frame for this segment type : The type of SPK segment to create first : The first epoch for which the segment is valid last : The last  epoch for which the segment is valid Output Returns an SPK segment descriptor. References NAIF Documentation source"},{"id":1147,"pagetitle":"API","title":"SPICE.spkpos","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkpos-NTuple{5,Any}","content":" SPICE.spkpos  —  Method . spkpos(targ, et, ref, abcorr, obs) Return the position of a target body relative to an observing body, optionally corrected for light time (planetary aberration) and stellar aberration. Arguments targ : Target body name et : Observer epoch ref : Reference frame of output position vector abcorr : Aberration correction flag obs : Observing body name Output ptarg : Position of target lt : One way light time between observer and target References NAIF Documentation source"},{"id":1148,"pagetitle":"API","title":"SPICE.spkpvn","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkpvn-Tuple{Any,Any,Any}","content":" SPICE.spkpvn  —  Method . spkpvn(handle, descr, et) For a specified SPK segment and time, return the state (position and velocity) of the segment's target body relative to its center of motion. Arguments handle : File handle descr : Segment descriptor et : Evaluation epoch Output ref : Segment reference frame ID code state : Output state vector center : Center of state References NAIF Documentation source"},{"id":1149,"pagetitle":"API","title":"SPICE.spksfs","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spksfs-Tuple{Any,Any}","content":" SPICE.spksfs  —  Method . spksfs(body, et) Search through loaded SPK files to find the highest-priority segment applicable to the body and time specified. Arguments body : Body ID et : Ephemeris time Output Returns  nothing  if no segment was found or a tuple consisting of: handle : Handle of file containing the applicable segment descr : Descriptor of the applicable segment ident : Identifier of the applicable segment References NAIF Documentation source"},{"id":1150,"pagetitle":"API","title":"SPICE.spkssb","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkssb-Tuple{Any,Any,Any}","content":" SPICE.spkssb  —  Method . spkssb(targ, et, ref) Return the state (position and velocity) of a target body relative to the solar system barycenter. Arguments targ : Target body et : Target epoch ref : Target reference frame Output Returns the state of target. References NAIF Documentation source"},{"id":1151,"pagetitle":"API","title":"SPICE.spksub!","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spksub!-NTuple{6,Any}","content":" SPICE.spksub!  —  Method . spksub!(newh, handle, descr, ident, start, stop) Extract a subset of the data in an SPK segment into a separate segment. Arguments newh : Handle of new segment handle : Handle of source segment descr : Descriptor of source segment ident : Identifier of source segment start : Beginning (initial epoch) of subset stop : End (final epoch) of subset References NAIF Documentation source"},{"id":1152,"pagetitle":"API","title":"SPICE.spkuds","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkuds-Tuple{Any}","content":" SPICE.spkuds  —  Method . spkuds(descr) Unpack the contents of an SPK segment descriptor. Arguments descr : An SPK segment descriptor Output body : The NAIF ID code for the body of the segment center : The center of motion for body frame : The ID code for the frame of this segment type : The type of SPK segment first : The first epoch for which the segment is valid last : The last  epoch for which the segment is valid start : Beginning DAF address of the segment stop : Ending DAF address of the segment References NAIF Documentation source"},{"id":1153,"pagetitle":"API","title":"SPICE.spkuef","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkuef-Tuple{Any}","content":" SPICE.spkuef  —  Method . spkuef(handle) Unload an ephemeris file so that it will no longer be searched by the readers. Arguments handle : Handle of file to be unloaded References NAIF Documentation source"},{"id":1154,"pagetitle":"API","title":"SPICE.spkw02","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkw02-NTuple{10,Any}","content":" SPICE.spkw02  —  Method . spkw02(handle, body, center, frame, first, last, segid, intlen, cdata, btime) Write a type 2 segment to an SPK file. Arguments handle : Handle of an SPK file open for writing body : Body code for ephemeris object center : Body code for the center of motion of the body frame : The reference frame of the states first : First valid time for which states can be computed last : Last valid time for which states can be computed segid : Segment identifier intlen : Length of time covered by logical record cdata : Array of Chebyshev coefficients btime : Begin time of first logical record References NAIF Documentation source"},{"id":1155,"pagetitle":"API","title":"SPICE.spkw03","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkw03-NTuple{10,Any}","content":" SPICE.spkw03  —  Method . spkw03(handle, body, center, frame, first, last, segid, intlen, cdata, btime) Write a type 3 segment to an SPK file. Arguments handle : Handle of an SPK file open for writing body : Body code for ephemeris object center : Body code for the center of motion of the body frame : The reference frame of the states first : First valid time for which states can be computed last : Last valid time for which states can be computed segid : Segment identifier intlen : Length of time covered by logical record cdata : Array of Chebyshev coefficients btime : Begin time of first logical record References NAIF Documentation source"},{"id":1156,"pagetitle":"API","title":"SPICE.spkw05","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkw05-NTuple{10,Any}","content":" SPICE.spkw05  —  Method . spkw05(handle, body, center, frame, first, last, segid, gm, states, epochs) Write an SPK segment of type 5 given a time-ordered set of discrete states and epochs, and the gravitational parameter of a central body. Arguments handle : Handle of an SPK file open for writing body : Body code for ephemeris object center : Body code for the center of motion of the body frame : The reference frame of the states first : First valid time for which states can be computed last : Last valid time for which states can be computed segid : Segment identifier gm : Gravitational parameter of central body states : States epochs : Epochs References NAIF Documentation source"},{"id":1157,"pagetitle":"API","title":"SPICE.spkw08","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkw08-NTuple{11,Any}","content":" SPICE.spkw08  —  Method . spkw08(handle, body, center, frame, first, last, segid, degree, states, epoch1, step) Write a type 8 segment to an SPK file. Arguments handle : Handle of an SPK file open for writing body : Body code for ephemeris object center : Body code for the center of motion of the body frame : The reference frame of the states first : First valid time for which states can be computed last : Last valid time for which states can be computed segid : Segment identifier degree : Degree of interpolating polynomials states : States epoch1 : Epoch of first state in states array step : Time step separating epochs of states References NAIF Documentation source"},{"id":1158,"pagetitle":"API","title":"SPICE.spkw09","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkw09-NTuple{10,Any}","content":" SPICE.spkw09  —  Method . spkw09(handle, body, center, frame, first, last, segid, degree, states, epochs) Write a type 9 segment to an SPK file. Arguments handle : Handle of an SPK file open for writing body : Body code for ephemeris object center : Body code for the center of motion of the body frame : The reference frame of the states first : First valid time for which states can be computed last : Last valid time for which states can be computed segid : Segment identifier degree : Degree of interpolating polynomials states : States epochs : Epochs References NAIF Documentation source"},{"id":1159,"pagetitle":"API","title":"SPICE.spkw10","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkw10-NTuple{10,Any}","content":" SPICE.spkw10  —  Method . spkw10(handle, body, center, frame, first, last, segid, consts, elems, epochs) Write a type 10 segment to an SPK file. Arguments handle : The handle of a DAF file open for writing body : The NAIF ID code for the body of the segment center : The center of motion for body frame : The reference frame for this segment first : The first epoch for which the segment is valid last : The last  epoch for which the segment is valid segid : The string to use for segment identifier consts : The array of geophysical constants for the segmen elems : The collection of \"two-line\" element sets epochs : The epochs associated with the element sets References NAIF Documentation source"},{"id":1160,"pagetitle":"API","title":"SPICE.spkw12","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkw12-NTuple{11,Any}","content":" SPICE.spkw12  —  Method . spkw12(handle, body, center, frame, first, last, segid, degree, states, epoch1, step) Write a type 12 segment to an SPK file. Arguments handle : Handle of an SPK file open for writing body : Body code for ephemeris object center : Body code for the center of motion of the body frame : The reference frame of the states first : First valid time for which states can be computed last : Last valid time for which states can be computed segid : Segment identifier degree : Degree of interpolating polynomials states : States epoch1 : Epoch of first state in states array step : Time step separating epochs of states References NAIF Documentation source"},{"id":1161,"pagetitle":"API","title":"SPICE.spkw13","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkw13-NTuple{10,Any}","content":" SPICE.spkw13  —  Method . spkw13(handle, body, center, frame, first, last, segid, degree, states, epochs) Write a type 13 segment to an SPK file. Arguments handle : Handle of an SPK file open for writing body : Body code for ephemeris object center : Body code for the center of motion of the body frame : The reference frame of the states first : First valid time for which states can be computed last : Last valid time for which states can be computed segid : Segment identifier degree : Degree of interpolating polynomials states : States epochs : Epochs References NAIF Documentation source"},{"id":1162,"pagetitle":"API","title":"SPICE.spkw15","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkw15-NTuple{17,Any}","content":" SPICE.spkw15  —  Method . spkw15(handle, body, center, frame, first, last, segid,\n       epoch, tp, pa, p, ecc, j2flg, pv, gm, j2, radius) Write a type 15 segment to an SPK file. Arguments handle : Handle of an SPK file open for writing body : Body code for ephemeris object center : Body code for the center of motion of the body frame : The reference frame of the states first : First valid time for which states can be computed last : Last valid time for which states can be computed segid : Segment identifier epoch : Epoch of the periapse tp : Trajectory pole vector pa : Periapsis vector p : Semi-latus rectum ecc : Eccentricity j2flg : J2 processing flag pv : Central body pole vector gm : Central body GM j2 : Central body J2 radius : Equatorial radius of central body References NAIF Documentation source"},{"id":1163,"pagetitle":"API","title":"SPICE.spkw17","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkw17-NTuple{11,Any}","content":" SPICE.spkw17  —  Method . spkw17(handle, body, center, frame, first, last, segid, epoch, eqel, rapol, decpol) Write a type 17 segment to an SPK file. Arguments handle : Handle of an SPK file open for writing body : Body code for ephemeris object center : Body code for the center of motion of the body frame : The reference frame of the states first : First valid time for which states can be computed last : Last valid time for which states can be computed segid : Segment identifier epoch : Epoch of elements in seconds past J2000 eqel : Array of equinoctial elements rapol : Right Ascension of the pole of the reference plane decpol : Declination of the pole of the reference plane References NAIF Documentation source"},{"id":1164,"pagetitle":"API","title":"SPICE.spkw18","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkw18-NTuple{11,Any}","content":" SPICE.spkw18  —  Method . spkw18(handle, subtyp, body, center, frame, first, last, segid, degree, packts, epochs) Write a type 18 segment to an SPK file. Arguments handle : Handle of an SPK file open for writing subtyp : SPK type 18 subtype code, either  :S18TP0  or  :S18TP1 body : NAIF code for an ephemeris object center : NAIF code for center of motion of body frame : Reference frame name first : Start time of interval covered by segment last : End time of interval covered by segment segid : Segment identifier degree : Degree of interpolating polynomials packts : Time-ordered array of data packets representing geometric states of body For  :S18TP0 :  [x,  y,  z,  dx/dt,  dy/dt,  dz/dt, vx, vy, vz, dvx/dt, dvy/dt, dvz/dt] For  :S18TP1 :  [x,  y,  z,  dx/dt,  dy/dt,  dz/dt] epochs : Array of epochs corresponding to states. References NAIF Documentation source"},{"id":1165,"pagetitle":"API","title":"SPICE.spkw20","ref":"/previews/PR43/SPICE/stable/api/#SPICE.spkw20-NTuple{13,Any}","content":" SPICE.spkw20  —  Method . spkw20(handle, body, center, frame, first, last, segid, intlen, n, polydg, cdata, dscale,\n       tscale, initjd, initfr) Write a type 20 segment to an SPK file. Arguments handle : Handle of SPK file open for writing body : NAIF code for ephemeris object center : NAIF code for the center of motion of the body frame : Reference frame name first : Start time of interval covered by segment last : End time of interval covered by segment segid : Segment identifier intlen : Length of time covered by logical record (days) cdata : Array of Chebyshev coefficients and positions dscale : Distance scale of data tscale : Time scale of data initjd : Integer part of begin time (TDB Julian date) of first record initfr : Fractional part of begin time (TDB Julian date) of first record References NAIF Documentation source"},{"id":1166,"pagetitle":"API","title":"SPICE.srfc2s","ref":"/previews/PR43/SPICE/stable/api/#SPICE.srfc2s-Tuple{Any,Any}","content":" SPICE.srfc2s  —  Method . srfc2s(code, bodyid) Translate a surface ID code, together with a body ID code, to the corresponding surface name. If no such name exists, return a string representation of the surface ID code. Arguments code : Integer surface ID code to translate to a string bodyid : ID code of body associated with surface Output srfstr : String corresponding to surface ID code isname : Logical flag indicating output is a surface name References NAIF Documentation source"},{"id":1167,"pagetitle":"API","title":"SPICE.srfcss","ref":"/previews/PR43/SPICE/stable/api/#SPICE.srfcss-Tuple{Any,Any}","content":" SPICE.srfcss  —  Method . srfcss(code, bodstr) Translate a surface ID code, together with a body string, to the corresponding surface name. If no such surface name exists, return a string representation of the surface ID code. Arguments code : Integer surface ID code to translate to a string bodstr : Name or ID of body associated with surface Output srfstr : String corresponding to surface ID code isname : Logical flag indicating output is a surface name References NAIF Documentation source"},{"id":1168,"pagetitle":"API","title":"SPICE.srfnrm","ref":"/previews/PR43/SPICE/stable/api/#SPICE.srfnrm-NTuple{5,Any}","content":" SPICE.srfnrm  —  Method . srfnrm(method, target, et, fixref, npts, srfpts) Map array of surface points on a specified target body to the corresponding unit length outward surface normal vectors. The surface of the target body may be represented by a triaxial ellipsoid or by topographic data provided by DSK files. Arguments method : Computation method target : Name of target body et : Epoch in TDB seconds past J2000 TDB fixref : Body-fixed, body-centered target body frame srfpts : Array of surface points Output Returns an array of outward, unit length normal vectors. References NAIF Documentation source"},{"id":1169,"pagetitle":"API","title":"SPICE.srfrec","ref":"/previews/PR43/SPICE/stable/api/#SPICE.srfrec-Tuple{Any,Any,Any}","content":" SPICE.srfrec  —  Method . srfrec(body, longitude, latitude) Convert planetocentric latitude and longitude of a surface point on a specified body to rectangular coordinates. Arguments body : NAIF integer code of an extended body. longitude : Longitude of point in radians. latitude : Latitude of point in radians. Output Returns the rectangular coordinates of the point. References NAIF Documentation source"},{"id":1170,"pagetitle":"API","title":"SPICE.srfs2c","ref":"/previews/PR43/SPICE/stable/api/#SPICE.srfs2c-Tuple{Any,Any}","content":" SPICE.srfs2c  —  Method . srfs2c(srfstr, bodstr) Translate a surface string, together with a body string, to the corresponding surface ID code. The input strings may contain names or integer ID codes. Arguments srfstr : Surface name or ID string bodstr : Body name or ID string Output Returns the surface ID code if it was found or  nothing  otherwise. References NAIF Documentation source"},{"id":1171,"pagetitle":"API","title":"SPICE.srfscc","ref":"/previews/PR43/SPICE/stable/api/#SPICE.srfscc-Tuple{Any,Any}","content":" SPICE.srfscc  —  Method . srfscc(srfstr, bodyid) Translate a surface string, together with a body ID code, to the corresponding surface ID code. The input surface string may contain a name or an integer ID code. Arguments srfstr : Surface name or ID string bodyid : Body ID code. Output Returns the surface ID code if it was found or  nothing  otherwise. References NAIF Documentation source"},{"id":1172,"pagetitle":"API","title":"SPICE.srfxpt","ref":"/previews/PR43/SPICE/stable/api/#SPICE.srfxpt","content":" SPICE.srfxpt  —  Function . srfxpt Deprecated Use  sincpt  instead. source"},{"id":1173,"pagetitle":"API","title":"SPICE.ssize!","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ssize!-Union{Tuple{T}, Tuple{SPICE.SpiceCell{T,T1,N} where N where T1,Any}} where T","content":" SPICE.ssize!  —  Method . ssize!(cell, size) Set the size (maximum cardinality) of a cell of any data type. Arguments cell : The cell size : Size (maximum cardinality) of the cell Output Returns the updated cell. References NAIF Documentation source"},{"id":1174,"pagetitle":"API","title":"SPICE.stelab","ref":"/previews/PR43/SPICE/stable/api/#SPICE.stelab-Tuple{Any,Any}","content":" SPICE.stelab  —  Method . stelab(pobj, vobs) Correct the apparent position of an object for stellar aberration. Arguments pobj : Position of an object with respect to the observer vobs : Velocity of the observer with respect to the Solar System barycenter Output Returns the apparent position of the object with respect to the observer, corrected for stellar aberration. References NAIF Documentation source"},{"id":1175,"pagetitle":"API","title":"SPICE.stpool","ref":"/previews/PR43/SPICE/stable/api/#SPICE.stpool","content":" SPICE.stpool  —  Function . stpool(item, nth, contin, lenout=1024) Retrieve the nth string from the kernel pool variable, where the string may be continued across several components of the kernel pool variable. Arguments item : Name of the kernel pool variable nth : Index of the full string to retrieve contin : Character sequence used to indicate continuation lenout : Available space in output string (default: 1024) Output Returns the full string concatenated across continuations if the kernel variable was found or  nothing  otherwise. References NAIF Documentation source"},{"id":1176,"pagetitle":"API","title":"SPICE.str2et","ref":"/previews/PR43/SPICE/stable/api/#SPICE.str2et-Tuple{Any}","content":" SPICE.str2et  —  Method . str2et(str) Convert a string representing an epoch to a double precision value representing the number of TDB seconds past the J2000 epoch corresponding to the input epoch. Arguments str : A string representing an epoch Output Returns the equivalent value in seconds past J2000, TDB. References NAIF Documentation source"},{"id":1177,"pagetitle":"API","title":"SPICE.subpnt","ref":"/previews/PR43/SPICE/stable/api/#SPICE.subpnt-NTuple{6,Any}","content":" SPICE.subpnt  —  Method . subpnt(method, target, et, fixref, obsrvr, abcorr) Compute the rectangular coordinates of the sub-observer point on a target body at a specified epoch, optionally corrected for light time and stellar aberration. Arguments method : Computation method target : Name of target body et : Epoch in ephemeris seconds past J2000 TDB fixref : Body-fixed, body-centered target body frame abcorr : Aberration correction obsrvr : Name of observing body Output spoint : Sub-solar point on the target body trgepc : Sub-solar point epoch srfvec : Vector from observer to sub-solar point References NAIF Documentation source"},{"id":1178,"pagetitle":"API","title":"SPICE.subpt","ref":"/previews/PR43/SPICE/stable/api/#SPICE.subpt","content":" SPICE.subpt  —  Function . subpt Deprecated Use  subpnt  instead. source"},{"id":1179,"pagetitle":"API","title":"SPICE.subpt_pl02","ref":"/previews/PR43/SPICE/stable/api/#SPICE.subpt_pl02","content":" SPICE.subpt_pl02  —  Function . subpt_pl02 Deprecated Use  subpnt  instead. source"},{"id":1180,"pagetitle":"API","title":"SPICE.subslr","ref":"/previews/PR43/SPICE/stable/api/#SPICE.subslr-NTuple{6,Any}","content":" SPICE.subslr  —  Method . subslr(method, target, et, fixref, abcorr, obsrvr) Compute the rectangular coordinates of the sub-solar point on a target body at a specified epoch, optionally corrected for light time and stellar aberration. Arguments method : Computation method target : Name of target body et : Epoch in ephemeris seconds past J2000 TDB fixref : Body-fixed, body-centered target body frame abcorr : Aberration correction obsrvr : Name of observing body Output spoint : Sub-solar point on the target body trgepc : Sub-solar point epoch srfvec : Vector from observer to sub-solar point References NAIF Documentation source"},{"id":1181,"pagetitle":"API","title":"SPICE.subsol","ref":"/previews/PR43/SPICE/stable/api/#SPICE.subsol","content":" SPICE.subsol  —  Function . subsol Deprecated Use  subslr  instead. source"},{"id":1182,"pagetitle":"API","title":"SPICE.subsol_pl02","ref":"/previews/PR43/SPICE/stable/api/#SPICE.subsol_pl02","content":" SPICE.subsol_pl02  —  Function . subsol_pl02 Deprecated Use  subslr  instead. source"},{"id":1183,"pagetitle":"API","title":"SPICE.sumad","ref":"/previews/PR43/SPICE/stable/api/#SPICE.sumad","content":" SPICE.sumad  —  Function . sumad(array) Deprecated Use  sum(array)  instead. source"},{"id":1184,"pagetitle":"API","title":"SPICE.sumai","ref":"/previews/PR43/SPICE/stable/api/#SPICE.sumai","content":" SPICE.sumai  —  Function . sumai(array) Deprecated Use  sum(array)  instead. source"},{"id":1185,"pagetitle":"API","title":"SPICE.surfnm","ref":"/previews/PR43/SPICE/stable/api/#SPICE.surfnm-NTuple{4,Any}","content":" SPICE.surfnm  —  Method . surfnm(a, b, c, point) Computes the outward-pointing, unit normal vector from a point on the surface of an ellipsoid. Arguments a : Length of the ellisoid semi-axis along the x-axis b : Length of the ellisoid semi-axis along the y-axis c : Length of the ellisoid semi-axis along the z-axis point : Body-fixed coordinates of a point on the ellipsoid Output Return the outward pointing unit normal to ellipsoid at point References NAIF Documentation source"},{"id":1186,"pagetitle":"API","title":"SPICE.surfpt","ref":"/previews/PR43/SPICE/stable/api/#SPICE.surfpt-NTuple{5,Any}","content":" SPICE.surfpt  —  Method . surfpt(positn, u, a, b, c) Determine the intersection of a line-of-sight vector with the surface of an ellipsoid. Arguments positn : Position of the observer in body-fixed frame u : Vector from the observer in some direction a : Length of the ellipsoid semi-axis along the x-axis b : Length of the ellipsoid semi-axis along the y-axis c : Length of the ellipsoid semi-axis along the z-axis Output Returns the point on the ellipsoid pointed to by u or  nothing  if none was found. References NAIF Documentation source"},{"id":1187,"pagetitle":"API","title":"SPICE.surfpv","ref":"/previews/PR43/SPICE/stable/api/#SPICE.surfpv-NTuple{5,Any}","content":" SPICE.surfpv  —  Method . surfpv(stvrtx, stdir, a, b, c) Find the state (position and velocity) of the surface intercept defined by a specified ray, ray velocity, and ellipsoid. Arguments stvrtx : State of ray's vertex stdir : State of ray's direction vector a : Length of ellipsoid semi-axis along the x-axis b : Length of ellipsoid semi-axis along the y-axis c : Length of ellipsoid semi-axis along the z-axis Output Return the state of surface intercept or  nothing  if none was found. References NAIF Documentation source"},{"id":1188,"pagetitle":"API","title":"SPICE.swpool","ref":"/previews/PR43/SPICE/stable/api/#SPICE.swpool-Tuple{Any,Any}","content":" SPICE.swpool  —  Method . swpool(agent, names) Add a name to the list of agents to notify whenever a member of a list of kernel variables is updated. Arguments agent : The name of an agent to be notified after updates names : Variable names whose update causes the notice References NAIF Documentation source"},{"id":1189,"pagetitle":"API","title":"SPICE.sxform","ref":"/previews/PR43/SPICE/stable/api/#SPICE.sxform-Tuple{Any,Any,Any}","content":" SPICE.sxform  —  Method . sxform(from, to, et) Return the state transformation matrix from one frame to another at a specified epoch. Arguments from : Name of the frame to transform from to : Name of the frame to transform to et : Epoch of the state transformation matrix Output Returns the state transformation matrix. References NAIF Documentation source"},{"id":1190,"pagetitle":"API","title":"SPICE.szpool","ref":"/previews/PR43/SPICE/stable/api/#SPICE.szpool-Tuple{Any}","content":" SPICE.szpool  —  Method . szpool(name) Return the kernel pool size limitations. Arguments name : Name of the parameter to be returned Output Returns the value of the parameter specified by  name  or  nothing  if none was found. References NAIF Documentation source"},{"id":1191,"pagetitle":"API","title":"SPICE.termpt","ref":"/previews/PR43/SPICE/stable/api/#SPICE.termpt-NTuple{14,Any}","content":" SPICE.termpt  —  Method . Find terminator points on a target body. The caller specifies half-planes, bounded by the illumination source center-target center vector, in which to search for terminator points. The terminator can be either umbral or penumbral. The umbral terminator is the boundary of the region on the target surface where no light from the source is visible. The penumbral terminator is the boundary of the region on the target surface where none of the light from the source is blocked by the target itself. The surface of the target body may be represented either by a triaxial ellipsoid or by topographic data. Arguments method : Computation method ilusrc : Illumination source target : Name of target body et : Epoch in ephemeris seconds past J2000 TDB fixref : Body-fixed, body-centered target body frame abcorr : Aberration correction corloc : Aberration correction locus obsrvr : Name of observing body refvec : Reference vector for cutting half-planes rolstp : Roll angular step for cutting half-planes ncuts : Number of cutting planes schstp : Angular step size for searching soltol : Solution convergence tolerance maxn : Maximum number of entries in output arrays Output npts : Counts of terminator points corresponding to cuts points : Terminator points epochs : Times associated with terminator points trmvcs : Terminator vectors emanating from the observer References NAIF Documentation source"},{"id":1192,"pagetitle":"API","title":"SPICE.timdef","ref":"/previews/PR43/SPICE/stable/api/#SPICE.timdef","content":" SPICE.timdef  —  Function . timdef(action, item, value=\"\") Set and retrieve the defaults associated with calendar input strings. Arguments action : The kind of action to take, either  :SET  or  :GET item : The default item of interest. The items that may be requested are: :CALENDAR  with allowed values: \"GREGORIAN\" \"JULIAN\" \"MIXED\" :SYSTEM  with allowed values: \"TDB\" \"TDT\" \"UTC\" :ZONE  with allowed values ( 0 <= HR < 13  and  0 <= MN < 60 ): \"EST\" \"EDT\" \"CST\" \"CDT\" \"MST\" \"MDT\" \"PST\" \"PDT\" \"UTC+$HR\" \"UTC-$HR\" \"UTC+$HR:$MN\" \"UTC-$HR:$MN\" Output Returns the value associated with the default item. References NAIF Documentation source"},{"id":1193,"pagetitle":"API","title":"SPICE.timout","ref":"/previews/PR43/SPICE/stable/api/#SPICE.timout","content":" SPICE.timout  —  Function . timout(et, pictur, lenout=128) This routine converts an input epoch represented in TDB seconds past the TDB epoch of J2000 to a character string formatted to the specifications of a user's format picture. Arguments et : An epoch in seconds past the ephemeris epoch J2000 pictur : A format specification for the output string lenout : The length of the output string plus 1 (default: 128) Output Returns a string representation of the input epoch. References NAIF Documentation source"},{"id":1194,"pagetitle":"API","title":"SPICE.tipbod","ref":"/previews/PR43/SPICE/stable/api/#SPICE.tipbod-Tuple{Any,Any,Any}","content":" SPICE.tipbod  —  Method . tipbod(ref, body, et) Return a 3x3 matrix that transforms positions in inertial coordinates to positions in body-equator-and-prime-meridian coordinates. Arguments ref : Name of inertial reference frame to transform from body : ID code of body et : Epoch of transformation Output Returns transformation matrix from intertial position to prime meridian. References NAIF Documentation source"},{"id":1195,"pagetitle":"API","title":"SPICE.tisbod","ref":"/previews/PR43/SPICE/stable/api/#SPICE.tisbod-Tuple{Any,Any,Any}","content":" SPICE.tisbod  —  Method . tisbod(ref, body, et) Return a 6x6 matrix that transforms states in inertial coordinates to states in body-equator-and-prime-meridian coordinates. Arguments ref : Name of inertial reference frame to transform from body : ID code of body et : Epoch of transformation Output Returns transformation matrix from intertial state to prime meridian. References NAIF Documentation source"},{"id":1196,"pagetitle":"API","title":"SPICE.tkvrsn","ref":"/previews/PR43/SPICE/stable/api/#SPICE.tkvrsn","content":" SPICE.tkvrsn  —  Function . tkvrsn(item=:TOOLKIT) Given an item such as the Toolkit or an entry point name, return the latest version string. References NAIF Documentation source"},{"id":1197,"pagetitle":"API","title":"SPICE.tparse","ref":"/previews/PR43/SPICE/stable/api/#SPICE.tparse-Tuple{Any}","content":" SPICE.tparse  —  Method . tparse(string) Parse a time string and return seconds past the J2000 epoch on a formal calendar. Arguments string : Input time string in UTC Output Returns UTC expressed in seconds since J2000. References NAIF Documentation source"},{"id":1198,"pagetitle":"API","title":"SPICE.tpictr","ref":"/previews/PR43/SPICE/stable/api/#SPICE.tpictr","content":" SPICE.tpictr  —  Function . tpictr(sample, lenout=80) Given a sample time string, create a time format picture suitable for use by the routine  timout . Arguments sample : A sample time string lenout : The length for the output picture string (default: 80) Output Returns a format picture that describes sample. References NAIF Documentation source"},{"id":1199,"pagetitle":"API","title":"SPICE.trace","ref":"/previews/PR43/SPICE/stable/api/#SPICE.trace","content":" SPICE.trace  —  Function . trace(matrix) Deprecated Use  LinearAlgebra.tr(matrix)  instead. source"},{"id":1200,"pagetitle":"API","title":"SPICE.tsetyr","ref":"/previews/PR43/SPICE/stable/api/#SPICE.tsetyr-Tuple{Any}","content":" SPICE.tsetyr  —  Method . tsetyr(year) Set the lower bound on the 100 year range. Arguments - year : Lower bound on the 100 year interval of expansion References NAIF Documentation source"},{"id":1201,"pagetitle":"API","title":"SPICE.twopi","ref":"/previews/PR43/SPICE/stable/api/#SPICE.twopi","content":" SPICE.twopi  —  Function . twopi() Deprecated Use  2π  instead. source"},{"id":1202,"pagetitle":"API","title":"SPICE.twovec","ref":"/previews/PR43/SPICE/stable/api/#SPICE.twovec-NTuple{4,Any}","content":" SPICE.twovec  —  Method . twovec(axdef, indexa, plndef, indexp) Find the transformation to the right-handed frame having a given vector as a specified axis and having a second given vector lying in a specified coordinate plane. Arguments axdef : Vector defining a principal axis indexa : Principal axis number of axdef (X=1, Y=2, Z=3) plndef : Vector defining (with axdef) a principal plane indexp : Second axis number (with indexa) of principal plane Output Returns output rotation matrix. References NAIF Documentation source"},{"id":1203,"pagetitle":"API","title":"SPICE.tyear","ref":"/previews/PR43/SPICE/stable/api/#SPICE.tyear-Tuple{}","content":" SPICE.tyear  —  Method . tyear() Returns the number of seconds per tropical year. References NAIF Documentation source"},{"id":1204,"pagetitle":"API","title":"SPICE.ucase","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ucase","content":" SPICE.ucase  —  Function . ucase(in) Deprecated Use  uppercase(in)  instead. source"},{"id":1205,"pagetitle":"API","title":"SPICE.ucrss","ref":"/previews/PR43/SPICE/stable/api/#SPICE.ucrss","content":" SPICE.ucrss  —  Function . ucrss(v1, v2) Deprecated Use  LinearAlgebra.normalize(LinearAlgebra.cross(v1, v2))  instead. source"},{"id":1206,"pagetitle":"API","title":"SPICE.uddf","ref":"/previews/PR43/SPICE/stable/api/#SPICE.uddf-Tuple{Any,Any,Any}","content":" SPICE.uddf  —  Method . uddf(udfunc, x, dx) Routine to calculate the first derivative of a caller-specified function using a three-point estimation. Arguments udfunc : A callable that computes the scalar value of interest,   e.g.  f(x::Float64) -> Float64 x : Independent variable of  udfunc dx : Interval from  x  for derivative calculation Output Returns the approximate derivative of  udfunc  at  x . References NAIF Documentation source"},{"id":1207,"pagetitle":"API","title":"SPICE.unitim","ref":"/previews/PR43/SPICE/stable/api/#SPICE.unitim-Tuple{Any,Any,Any}","content":" SPICE.unitim  —  Method . unitim(epoch, insys, outsys) Transform time from one uniform scale to another. Arguments epoch : An epoch to be converted insys : The time scale associated with the input epoch outsys : The time scale associated with the function value The uniform time scales are: :TAI :TDT :TDB :ET :JED :JDTDB :JDTDT Output Returns the time in the system specified by  outsys  that is equivalent to the  epoch  in the  insys  time scale. References NAIF Documentation source"},{"id":1208,"pagetitle":"API","title":"SPICE.unload","ref":"/previews/PR43/SPICE/stable/api/#SPICE.unload-Tuple{Any}","content":" SPICE.unload  —  Method . unload(file) Unload a SPICE kernel. Arguments file : The file name of a kernel to unload References NAIF Documentation source"},{"id":1209,"pagetitle":"API","title":"SPICE.unorm","ref":"/previews/PR43/SPICE/stable/api/#SPICE.unorm","content":" SPICE.unorm  —  Function . unorm(v1) Deprecated Use  (LinearAlgebra.normalize(v1), LinearAlgebra.norm(v1))  instead. source"},{"id":1210,"pagetitle":"API","title":"SPICE.unormg","ref":"/previews/PR43/SPICE/stable/api/#SPICE.unormg","content":" SPICE.unormg  —  Function . unormg(v1) Deprecated Use  (LinearAlgebra.normalize(v1), LinearAlgebra.norm(v1))  instead. source"},{"id":1211,"pagetitle":"API","title":"SPICE.utc2et","ref":"/previews/PR43/SPICE/stable/api/#SPICE.utc2et-Tuple{Any}","content":" SPICE.utc2et  —  Method . utc2et(utcstr) Convert an input time from Calendar or Julian Date format, UTC, to ephemeris seconds past J2000. Arguments utcstr : Input time string, UTC Output Returns the equivalent of utcstr, expressed in ephemeris seconds past J2000. References NAIF Documentation source"},{"id":1212,"pagetitle":"API","title":"SPICE.vadd","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vadd","content":" SPICE.vadd  —  Function . vadd(v1, v2) Deprecated Use  v1 .+ v2  instead. source"},{"id":1213,"pagetitle":"API","title":"SPICE.vaddg","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vaddg","content":" SPICE.vaddg  —  Function . vaddg(v1, v2) Deprecated Use  v1 .+ v2  instead. source"},{"id":1214,"pagetitle":"API","title":"SPICE.valid!","ref":"/previews/PR43/SPICE/stable/api/#SPICE.valid!-Union{Tuple{SPICE.SpiceCell{T,T1,N} where N where T1}, Tuple{T}} where T","content":" SPICE.valid!  —  Method . valid!(set::SpiceCell{T}) where T Create a valid SPICE set from a SPICE Cell of any data type. Arguments set : Set to be validated Output Returns the validated set with ordered elements and duplicates removed. References NAIF Documentation source"},{"id":1215,"pagetitle":"API","title":"SPICE.vcrss","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vcrss","content":" SPICE.vcrss  —  Function . vcrss(v1, v2) Deprecated Use  LinearAlgebra.cross(v1, v2)  instead. source"},{"id":1216,"pagetitle":"API","title":"SPICE.vdist","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vdist","content":" SPICE.vdist  —  Function . vdist(v1, v2) Deprecated Use  LinearAlgebra.norm(v1 .- v2)  instead. source"},{"id":1217,"pagetitle":"API","title":"SPICE.vdistg","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vdistg","content":" SPICE.vdistg  —  Function . vdistg(v1, v2) Deprecated Use  LinearAlgebra.norm(v1 .- v2)  instead. source"},{"id":1218,"pagetitle":"API","title":"SPICE.vdot","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vdot","content":" SPICE.vdot  —  Function . vdot(v1, v2) Deprecated Use  LinearAlgebra.dot(v1, v2)  instead. source"},{"id":1219,"pagetitle":"API","title":"SPICE.vdotg","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vdotg","content":" SPICE.vdotg  —  Function . vdotg(v1, v2) Deprecated Use  LinearAlgebra.dot(v1, v2)  instead. source"},{"id":1220,"pagetitle":"API","title":"SPICE.vequ","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vequ","content":" SPICE.vequ  —  Function . vequ(v1, v2) Deprecated Use  v1 .= v2  instead. source"},{"id":1221,"pagetitle":"API","title":"SPICE.vequg","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vequg","content":" SPICE.vequg  —  Function . vequg(v1, v2) Deprecated Use  v1 .= v2  instead. source"},{"id":1222,"pagetitle":"API","title":"SPICE.vhat","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vhat","content":" SPICE.vhat  —  Function . vhat(v1) Deprecated Use  LinearAlgebra.normalize(v1)  instead. source"},{"id":1223,"pagetitle":"API","title":"SPICE.vhatg","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vhatg","content":" SPICE.vhatg  —  Function . vhatg(v1) Deprecated Use  LinearAlgebra.normalize(v1)  instead. source"},{"id":1224,"pagetitle":"API","title":"SPICE.vlcom","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vlcom","content":" SPICE.vlcom  —  Function . vlcom(a, v1, b, v2) Deprecated Use  a .* v1 .+ b .* v2  instead. source"},{"id":1225,"pagetitle":"API","title":"SPICE.vlcom3","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vlcom3","content":" SPICE.vlcom3  —  Function . vlcom3(a, v1, b, v2, c, v3) Deprecated Use  a .* v1 .+ b .* v2 .+ c .* v3  instead. source"},{"id":1226,"pagetitle":"API","title":"SPICE.vlcomg","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vlcomg","content":" SPICE.vlcomg  —  Function . vlcomg(a, v1, b, v2) Deprecated Use  a .* v1 .+ b .* v2  instead. source"},{"id":1227,"pagetitle":"API","title":"SPICE.vminug","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vminug","content":" SPICE.vminug  —  Function . vminug(vin) Deprecated Use  -vin  instead. source"},{"id":1228,"pagetitle":"API","title":"SPICE.vminus","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vminus","content":" SPICE.vminus  —  Function . vminus(vin) Deprecated Use  -vin  instead. source"},{"id":1229,"pagetitle":"API","title":"SPICE.vnorm","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vnorm","content":" SPICE.vnorm  —  Function . vnorm(v1) Deprecated Use  LinearAlgebra.norm(v1)  instead. source"},{"id":1230,"pagetitle":"API","title":"SPICE.vnormg","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vnormg","content":" SPICE.vnormg  —  Function . vnormg(v1, v2) Deprecated Use  LinearAlgebra.norm(v1)  instead. source"},{"id":1231,"pagetitle":"API","title":"SPICE.vpack","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vpack","content":" SPICE.vpack  —  Function . vpack(x, y, z) Deprecated Use  [x, y, z]  instead. source"},{"id":1232,"pagetitle":"API","title":"SPICE.vperp","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vperp-Tuple{Any,Any}","content":" SPICE.vperp  —  Method . vperp(a, b) Find the component of a vector that is perpendicular to a second vector. Arguments a : The vector whose orthogonal component is sought b : The vector used as the orthogonal reference Output Returns the component  a  orthogonal to  b . References NAIF Documentation source"},{"id":1233,"pagetitle":"API","title":"SPICE.vprjp","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vprjp-Tuple{Any,Any}","content":" SPICE.vprjp  —  Method . vprjp(vin, plane) Project a vector onto a specified plane, orthogonally. Arguments vin : Vector to be projected plane : Plane onto which vin is projected Output Returns the vector resulting from the projection. References NAIF Documentation source"},{"id":1234,"pagetitle":"API","title":"SPICE.vprjpi","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vprjpi-Tuple{Any,Any,Any}","content":" SPICE.vprjpi  —  Method . vprjpi(vin, projpl, invpl) Find the vector in a specified plane that maps to a specified vector in another plane under orthogonal projection. Arguments vin : The projected vector projpl : Plane containing  vin invpl : Plane containing inverse image of  vin Output Returns the inverse projection of  vin  or  nothing  if  vin  could not be calculated. References NAIF Documentation source"},{"id":1235,"pagetitle":"API","title":"SPICE.vproj","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vproj-Tuple{Any,Any}","content":" SPICE.vproj  —  Method . vproj(a, b) Finds the projection of one vector onto another vector. All vectors are 3-dimensional. Arguments a : The vector to be projected b : The vector onto which  a  is to be projected Output Returns the projection of  a  onto  b . References NAIF Documentation source"},{"id":1236,"pagetitle":"API","title":"SPICE.vrel","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vrel-Tuple{Any,Any}","content":" SPICE.vrel  —  Method . vrel(v1, v2) Return the relative difference between two 3-dimensional vectors. Arguments v1 ,  v2 : Two three-dimensional input vectors Output Returns the relative differences between  v1  and  v2 . References NAIF Documentation source"},{"id":1237,"pagetitle":"API","title":"SPICE.vrelg","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vrelg-Tuple{Any,Any}","content":" SPICE.vrelg  —  Method . vrelg(v1, v2) Return the relative difference between two vectors. Arguments v1 ,  v2 : Input vectors Output Returns the relative differences between  v1  and  v2 . References NAIF Documentation source"},{"id":1238,"pagetitle":"API","title":"SPICE.vrotv","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vrotv-Tuple{Any,Any,Any}","content":" SPICE.vrotv  —  Method . vrotv(v, axis, theta) Rotate a vector about a specified axis vector by a specified angle and return the rotated vector. Arguments v : Vector to be rotated axis : Axis of the rotation theta : Angle of rotation (radians) Output Result of rotating  v  about  axis  by  theta . References NAIF Documentation source"},{"id":1239,"pagetitle":"API","title":"SPICE.vscl","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vscl","content":" SPICE.vscl  —  Function . vscl(s, v1) Deprecated Use  s .* v1  instead. source"},{"id":1240,"pagetitle":"API","title":"SPICE.vsclg","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vsclg","content":" SPICE.vsclg  —  Function . vsclg(s, v1) Deprecated Use  s .* v1  instead. source"},{"id":1241,"pagetitle":"API","title":"SPICE.vsep","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vsep-Tuple{Any,Any}","content":" SPICE.vsep  —  Method . vsep(v1, v2) Return the sepative difference between two 3-dimensional vectors. Arguments v1 ,  v2 : Two three-dimensional input vectors Output Returns the angle between  v1  and  v2  in radians. References NAIF Documentation source"},{"id":1242,"pagetitle":"API","title":"SPICE.vsepg","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vsepg-Tuple{Any,Any}","content":" SPICE.vsepg  —  Method . vsepg(v1, v2) Return the sepative difference between two vectors. Arguments v1 ,  v2 : Input vectors Output Returns the angle between  v1  and  v2  in radians. References NAIF Documentation source"},{"id":1243,"pagetitle":"API","title":"SPICE.vsub","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vsub","content":" SPICE.vsub  —  Function . vsub(v1, v2) Deprecated Use  v1 .- v2  instead. source"},{"id":1244,"pagetitle":"API","title":"SPICE.vsubg","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vsubg","content":" SPICE.vsubg  —  Function . vsubg(v1, v2) Deprecated Use  v1 .- v2  instead. source"},{"id":1245,"pagetitle":"API","title":"SPICE.vtmv","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vtmv","content":" SPICE.vtmv  —  Function . vtmv(v1, matrix, v2) Deprecated Use  v1' * matrix * v2  instead. source"},{"id":1246,"pagetitle":"API","title":"SPICE.vtmvg","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vtmvg","content":" SPICE.vtmvg  —  Function . vtmvg(v1, matrix, v2) Deprecated Use  v1' * matrix * v2  instead. source"},{"id":1247,"pagetitle":"API","title":"SPICE.vupack","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vupack","content":" SPICE.vupack  —  Function . vupack(v) Deprecated Use  x, y, z = v  instead. source"},{"id":1248,"pagetitle":"API","title":"SPICE.vzero","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vzero","content":" SPICE.vzero  —  Function . vzero(v1) Deprecated Use  iszero(v1)  instead. source"},{"id":1249,"pagetitle":"API","title":"SPICE.vzerog","ref":"/previews/PR43/SPICE/stable/api/#SPICE.vzerog","content":" SPICE.vzerog  —  Function . vzerog(v1, v2) Deprecated Use  iszero(v1)  instead. source"},{"id":1250,"pagetitle":"API","title":"SPICE.wncard","ref":"/previews/PR43/SPICE/stable/api/#SPICE.wncard-Tuple{Any}","content":" SPICE.wncard  —  Method . wncard(window) Return the cardinality (number of intervals) of a double precision window. Arguments window : Input window References NAIF Documentation source"},{"id":1251,"pagetitle":"API","title":"SPICE.wncomd","ref":"/previews/PR43/SPICE/stable/api/#SPICE.wncomd-Tuple{Any,Any,Any}","content":" SPICE.wncomd  —  Method . wncomd(window, left, right) Determine the complement of a double precision window with respect to a specified interval. Arguments window : Input window left :  Left endpoint of the complement interval right :  Right endpoint of the complement interval Output Returns the complement of  window  with respect to  [left,right] . References NAIF Documentation source"},{"id":1252,"pagetitle":"API","title":"SPICE.wncond!","ref":"/previews/PR43/SPICE/stable/api/#SPICE.wncond!-Tuple{Any,Any,Any}","content":" SPICE.wncond!  —  Method . wncond!(window, left, right) Contract each of the intervals of a double precision window. Arguments window : Window to be contracted left :  Amount added to each left endpoint right : Amount subtracted from each right endpoint Output Returns the contracted window. References NAIF Documentation source"},{"id":1253,"pagetitle":"API","title":"SPICE.wndifd","ref":"/previews/PR43/SPICE/stable/api/#SPICE.wndifd-Tuple{Any,Any}","content":" SPICE.wndifd  —  Method . wndifd(a, b) Place the difference of two double precision windows into a third window. Arguments a : Input window b : Input window Output Returns a window containing the difference of  a  and  b . References NAIF Documentation source"},{"id":1254,"pagetitle":"API","title":"SPICE.wnelmd","ref":"/previews/PR43/SPICE/stable/api/#SPICE.wnelmd-Tuple{Any,Any}","content":" SPICE.wnelmd  —  Method . wnelmd(window, point) Determine whether a point is an element of a double precision window. Arguments window : Input window point : Input point Output Returns  true  if  point  is an element of  window . References NAIF Documentation source"},{"id":1255,"pagetitle":"API","title":"SPICE.wnexpd!","ref":"/previews/PR43/SPICE/stable/api/#SPICE.wnexpd!-Tuple{Any,Any,Any}","content":" SPICE.wnexpd!  —  Method . wnexpd(window, left, right) Expand each of the intervals of a double precision window. Arguments left : Amount subtracted from each left endpoint right : Amount added to each right endpoint Output Returns the expanded window. References NAIF Documentation source"},{"id":1256,"pagetitle":"API","title":"SPICE.wnextd!","ref":"/previews/PR43/SPICE/stable/api/#SPICE.wnextd!-Tuple{Any,Any}","content":" SPICE.wnextd!  —  Method . wnextd!(window, side) Extract the left or right endpoints from a double precision window. Arguments window : Window to be extracted side : Extract left ( :L ) or right ( :R ) endpoints Output Returns the extracted window. References NAIF Documentation source"},{"id":1257,"pagetitle":"API","title":"SPICE.wnfetd","ref":"/previews/PR43/SPICE/stable/api/#SPICE.wnfetd-Tuple{Any,Any}","content":" SPICE.wnfetd  —  Method . wnfetd(window, n) Fetch a particular interval from a double precision window. Arguments window : Input window n : Index of interval to be fetched Output Returns a tuple consisting of the left and right endpoints of the n-th interval in the input window. References NAIF Documentation source"},{"id":1258,"pagetitle":"API","title":"SPICE.wnfild!","ref":"/previews/PR43/SPICE/stable/api/#SPICE.wnfild!-Tuple{Any,Any}","content":" SPICE.wnfild!  —  Method . wnfild!(window, small) Fill small gaps between adjacent intervals of a double precision window. Arguments window : Window to be filled small : Limiting measure of small gaps Output Returns the updated window. References NAIF Documentation source"},{"id":1259,"pagetitle":"API","title":"SPICE.wnfltd!","ref":"/previews/PR43/SPICE/stable/api/#SPICE.wnfltd!-Tuple{Any,Any}","content":" SPICE.wnfltd!  —  Method . wnfild!(window, small) Filter (remove) small intervals from a double precision window. Arguments window : Window to be filtered small : Limiting measure of small intervals Output Returns the updated window. References NAIF Documentation source"},{"id":1260,"pagetitle":"API","title":"SPICE.wnincd","ref":"/previews/PR43/SPICE/stable/api/#SPICE.wnincd-Tuple{Any,Any,Any}","content":" SPICE.wnincd  —  Method . wnincd(window, left, right) Determine whether an interval is included in a double precision window. Arguments window : Input window left : Left endpoint of the input interval right : Right endpoint of the input interval Output Returns  true  when  (left, right)  is contained in  window . References NAIF Documentation source"},{"id":1261,"pagetitle":"API","title":"SPICE.wninsd!","ref":"/previews/PR43/SPICE/stable/api/#SPICE.wninsd!-Tuple{Any,Any,Any}","content":" SPICE.wninsd!  —  Method . wninsd!(window, left, right) Insert an interval into a double precision window. Arguments window : Input window left : Left endpoint of the new interval right : Right endpoint of the new interval Output Returns the updated windows. References NAIF Documentation source"},{"id":1262,"pagetitle":"API","title":"SPICE.wnintd","ref":"/previews/PR43/SPICE/stable/api/#SPICE.wnintd-Tuple{Any,Any}","content":" SPICE.wnintd  —  Method . wnintd(a, b) Place the intersection of two double precision windows into a third window. Arguments a : Input window b : Input window Output Returns a window containing the intersection of  a  and  b . References NAIF Documentation source"},{"id":1263,"pagetitle":"API","title":"SPICE.wnreld","ref":"/previews/PR43/SPICE/stable/api/#SPICE.wnreld-Tuple{Any,Any,Any}","content":" SPICE.wnreld  —  Method . wnreld(a, op, b) Compare two double precision windows. Note Consider using overloaded operators instead, i.e.  a == b ,  a ⊆ b , and  a ⊊ b . Arguments a : First window op : Comparison operator b : Second window Output Returns the result of comparison  a (op) b . References NAIF Documentation source"},{"id":1264,"pagetitle":"API","title":"SPICE.wnsumd","ref":"/previews/PR43/SPICE/stable/api/#SPICE.wnsumd-Tuple{Any}","content":" SPICE.wnsumd  —  Method . wnsumd(window) Summarize the contents of a double precision window. Arguments window : Window to be summarized Output Returns a tuple consisting of: meas : Total measure of intervals in window avg : Average measure stddev : Standard deviation shortest : Location of shortest interval longest : Location of longest interval References NAIF Documentation source"},{"id":1265,"pagetitle":"API","title":"SPICE.wnunid","ref":"/previews/PR43/SPICE/stable/api/#SPICE.wnunid-Tuple{Any,Any}","content":" SPICE.wnunid  —  Method . wnunid(a, b) Place the union of two double precision windows into a third window. Arguments a : Input window b : Input window Output Returns a window containing the union of  a  and  b . References NAIF Documentation source"},{"id":1266,"pagetitle":"API","title":"SPICE.wnvald!","ref":"/previews/PR43/SPICE/stable/api/#SPICE.wnvald!-Tuple{Any}","content":" SPICE.wnvald!  —  Method . wnvald!(window) Form a valid double precision window from the contents of a window array. Arguments window : A (possibly uninitialized)  SpiceDoubleCell  containing endpoints of   (possibly unordered and non-disjoint) intervals. Output Returns the validated window. References NAIF Documentation source"},{"id":1267,"pagetitle":"API","title":"SPICE.xf2eul","ref":"/previews/PR43/SPICE/stable/api/#SPICE.xf2eul-NTuple{4,Any}","content":" SPICE.xf2eul  —  Method . xf2eul(xform, axisa, axisb, axisc) Convert a state transformation matrix to Euler angles and their derivatives with respect to a specified set of axes. Arguments xform : A state transformation matrix axisa : Axis A of the Euler angle factorization axisb : Axis B of the Euler angle factorization axisc : Axis C of the Euler angle factorization Output Returns a tuple of an array of Euler angles and their derivatives and a boolean that indicates whether these are a unique representation. References NAIF Documentation source"},{"id":1268,"pagetitle":"API","title":"SPICE.xf2rav","ref":"/previews/PR43/SPICE/stable/api/#SPICE.xf2rav-Tuple{Any}","content":" SPICE.xf2rav  —  Method . xf2rav(xform) Determines the rotation matrix and angular velocity of the rotation from a state transformation matrix. Arguments xform : State transformation matrix Output Returns a tuple of the rotation matrix and the angular velocity vector associated with  xform . References NAIF Documentation source"},{"id":1269,"pagetitle":"API","title":"SPICE.xfmsta","ref":"/previews/PR43/SPICE/stable/api/#SPICE.xfmsta-NTuple{4,Any}","content":" SPICE.xfmsta  —  Method . xfmsta(input_state, input_coord_sys, output_coord_sys, body) Transform a state between coordinate systems. Arguments input_state : Input state input_coord_sys : Current (input) coordinate system `output coord sys: Desired (output) coordinate system body : Name or NAIF ID of body with which coordinates are associated (if applicable) Output Returns the converted output state. References NAIF Documentation source"},{"id":1270,"pagetitle":"API","title":"SPICE.xpose","ref":"/previews/PR43/SPICE/stable/api/#SPICE.xpose","content":" SPICE.xpose  —  Function . xpose(matrix) Deprecated Use  transpose(matrix)  instead. source"},{"id":1271,"pagetitle":"API","title":"SPICE.xpose6","ref":"/previews/PR43/SPICE/stable/api/#SPICE.xpose6","content":" SPICE.xpose6  —  Function . xpose6(matrix) Deprecated Use  transpose(matrix)  instead. source"},{"id":1272,"pagetitle":"API","title":"SPICE.xposeg","ref":"/previews/PR43/SPICE/stable/api/#SPICE.xposeg","content":" SPICE.xposeg  —  Function . xposeg(matrix) Deprecated Use  transpose(matrix)  instead. source Previous Home"},{"id":1277,"pagetitle":"Home","title":"UnitfulAstro.jl Documentation","ref":"/previews/PR43/UnitfulAstro/stable/#UnitfulAstro.jl-Documentation","content":" UnitfulAstro.jl Documentation UnitfulAstro.jl is an extension of  Unitful.jl  to include units commonly encountered in astronomy."},{"id":1278,"pagetitle":"Home","title":"Table of Units","ref":"/previews/PR43/UnitfulAstro/stable/#Table-of-Units","content":" Table of Units The list of additional units is given below: Name Binding Value Erg UnitfulAstro.erg 1//10000000 J Dyne UnitfulAstro.dyn 1//100000 N Arcminute UnitfulAstro.arcminute 1//60 ° Arcsecond UnitfulAstro.arcsecond 1//3600 ° Julian year UnitfulAstro.yr 1461//4 d Astronomical unit UnitfulAstro.AU 1.495978707e13 cm Light year UnitfulAstro.ly 946073047258080000 cm Parsec UnitfulAstro.pc 3.0856775814913674e18 cm Jansky UnitfulAstro.Jy 1.0e-23 erg Hz^-1 cm^-2 s^-1 Solar radius UnitfulAstro.Rsun 6.957e10 cm Solar irradiance UnitfulAstro.Ssun 1.361e6 erg cm^-2 s^-1 Solar luminosity UnitfulAstro.Lsun 3.828e33 erg s^-1 G × Solar mass UnitfulAstro.GMsun 1.3271244e20 m^3 s^-2 Solar mass UnitfulAstro.Msun 1.988409870698051e33 g Earth radius (equatorial) UnitfulAstro.Rearth_e 6.3781e8 cm Earth radius (polar) UnitfulAstro.Rearth_p 6.3568e8 cm Earth radius UnitfulAstro.Rearth 6.3781e8 cm G × Earth mass UnitfulAstro.GMearth 3.986004e14 m^3 s^-2 Earth mass UnitfulAstro.Mearth 5.972167867791379e27 g Jupiter radius (equatorial) UnitfulAstro.Rjup_e 7.1492e9 cm Jupiter radius (polar) UnitfulAstro.Rjup_p 6.6854e9 cm Jupiter radius UnitfulAstro.Rjup 7.1492e9 cm G × Jupiter mass UnitfulAstro.GMjup 1.2668653e17 m^3 s^-2 Jupiter mass UnitfulAstro.Mjup 1.8981245973360504e30 g Fifty-one ergs UnitfulAstro.foe 1.0e51 erg Solar flux unit UnitfulAstro.SFU 10 kJy Total electron content unit UnitfulAstro.TECU 1.0e12 cm^-2"},{"id":1279,"pagetitle":"Home","title":"Examples","ref":"/previews/PR43/UnitfulAstro/stable/#Examples","content":" Examples julia> using Unitful, UnitfulAstro\n\njulia> uconvert(u\"erg\", 1 * Unitful.kg * Unitful.gn * Unitful.m)\n9.80665e7 erg\n\njulia> uconvert(u\"Jy\", 1.23e-20 * u\"erg/s/cm^2/Hz\")\n1230.0000000000002 Jy\n\njulia> uconvert(u\"ly\", 1u\"pc\")\n3.2615637771674333 ly"},{"id":1280,"pagetitle":"Home","title":"Magnitudes","ref":"/previews/PR43/UnitfulAstro/stable/#Magnitudes","content":" Magnitudes Name Binding Zero Point absolute bolometric Magnitude UnitfulAstro.bol_Mag 3.0128e28 W apparent bolometric magnitude UnitfulAstro.bol_mag 2.518021002e-8 W m^-2 AB magnitude UnitfulAstro.AB_mag 3631 Jy Johnson U magnitude UnitfulAstro.U_mag 1810 Jy Johnson B magnitude UnitfulAstro.B_mag 4260 Jy Johnson V magnitude UnitfulAstro.V_mag 3640 Jy Johnson R magnitude UnitfulAstro.R_mag 3080 Jy Johnson I magnitude UnitfulAstro.I_mag 2550 Jy Johnson J magnitude UnitfulAstro.J_mag 1600 Jy Johnson H magnitude UnitfulAstro.H_mag 1080 Jy Johnson K magnitude UnitfulAstro.K_mag 670 Jy Gunn g magnitude UnitfulAstro.g_mag 3730 Jy Gunn r magnitude UnitfulAstro.r_mag 4490 Jy Gunn i magnitude UnitfulAstro.i_mag 4760 Jy Gunn z magnitude UnitfulAstro.z_mag 4810 Jy Warn Support for magnitudes is experimental. Please use care and report any issues you experience on the  UnitfulAstro.jl GitHub issue tracker . Currently only AB, bolometric, Johnson, and Gunn magnitudes are supported. For example julia> 5u\"AB_mag\" + 5u\"AB_mag\"\n4.247425010840047 AB mag\n\njulia> 5u\"U_mag\"/100\n10.0 Johnson U mag\n\njulia> 5u\"g_mag\" + 10u\"Jy\" # magnitudes can be mixed with ordinary linear units\n47.300000000000004 Jy\n\njulia> uconvert(u\"AB_mag\", 1u\"μJy\") # converting one μJy to AB magnitudes\n23.90006562228223 AB mag\n\njulia> uconvert(u\"bol_mag\", 1u\"Ssun\") # apparent bolometric magnitude of the Sun\n-26.83199694276591 bol mag\n\njulia> uconvert(u\"bol_Mag\", 1u\"Lsun\") # absolute bolometric magnitude of the Sun\n4.7399959339194595 bol Mag"},{"id":1281,"pagetitle":"Home","title":"Color","ref":"/previews/PR43/UnitfulAstro/stable/#Color","content":" Color Color index  is also supported julia> 1u\"B_mag\" - 0.5u\"V_mag\"\n0.4999999999999999 Note:  that the only operation that can happen between different bands is subtraction julia> 1u\"B_mag\" + 0.5u\"V_mag\"\nERROR: MagnitudeError: an invalid operation was attempted with magnitudes: 0.9999999999999999 Johnson B mag, 0.5 Johnson V mag and  that  +  and  -  work on individual bands julia> 1u\"B_mag\" - 1.5u\"B_mag\"\n2.0823085833406205 Johnson B mag\n\njulia> 1u\"B_mag\" + 1.5u\"B_mag\"\n0.46889349301415084 Johnson B mag"},{"id":1282,"pagetitle":"Home","title":"IAU Resolutions","ref":"/previews/PR43/UnitfulAstro/stable/#IAU-Resolutions","content":" IAU Resolutions Copies of recent IAU resolutions which formalize the definitions of some units used in this package are linked below. IAU 2012 (pdf) IAU 2015 (pdf)"},{"id":1285,"pagetitle":"API Reference","title":"API Reference","ref":"/previews/PR43/UnitfulAstro/stable/api/#API-Reference","content":" API Reference"},{"id":1286,"pagetitle":"API Reference","title":"Lengths and Distances","ref":"/previews/PR43/UnitfulAstro/stable/api/#Lengths-and-Distances","content":" Lengths and Distances"},{"id":1287,"pagetitle":"API Reference","title":"UnitfulAstro.AU","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.AU","content":" UnitfulAstro.AU  —  Constant UnitfulAstro.AU The astronomical unit, an IAU unit of distance, defined as 149 597 870 700 m, in IAU 2012. It is intended to represent the mean distance between the Earth and the Sun. Dimension:  𝐋 Reference:  IAU 2012 Resolution B2 source"},{"id":1288,"pagetitle":"API Reference","title":"UnitfulAstro.ly","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.ly","content":" UnitfulAstro.ly  —  Constant UnitfulAstro.ly The light-year, a unit of distance, defined as 1 c⋅yr (speed of light times year). It is intended to represent the amount of distance traveled by an object traveling at the speed of light (e.g., a photon) in a year. Dimesion:  𝐋 See also:  c  (speed of light) ,  yr source"},{"id":1289,"pagetitle":"API Reference","title":"UnitfulAstro.pc","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.pc","content":" UnitfulAstro.pc  —  Constant UnitfulAstro.pc The parsec, a unit of distance, defined as 1 AU/arcsecond, in IAU 2015. The exact conversion is 648000/π AU. It is intended to represent the distance to an object whose apparent parallax is 1 arcsecond when viewed from two distances 1 AU apart. Dimension:  𝐋 See also:  AU ,  arcsecond References:  Binney & Tremaine (2008) ,  Cox (2002) ,  IAU 2015 Resolution B2 source"},{"id":1290,"pagetitle":"API Reference","title":"UnitfulAstro.Rsun","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.Rsun","content":" UnitfulAstro.Rsun  —  Constant UnitfulAstro.Rsun The solar radius, a unit of length. It is defined as 6.957 × 10^8 m in IAU 2015. It is intended to represent the radius of the sun. Dimension:  𝐋 Reference:  IAU 2015 Resolution B3 source"},{"id":1291,"pagetitle":"API Reference","title":"UnitfulAstro.Rearth","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.Rearth","content":" UnitfulAstro.Rearth  —  Constant UnitfulAstro.Rearth The terrestrial radius, a unit of length. It is defined as 1 equatorial Earth radius. Dimension:  𝐋 See also:  Rearth_e ,  Rearth_p source"},{"id":1292,"pagetitle":"API Reference","title":"UnitfulAstro.Rearth_e","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.Rearth_e","content":" UnitfulAstro.Rearth_e  —  Constant UnitfulAstro.Rearth_e The equatorial Earth radius, a unit of length. It is defined as 6.3781 × 10^6 m. It is intended to represent the distance from the Earth's center to its equator. Dimension:  𝐋 See also:  Rearth_p Reference:  IAU 2015 Resolution B3 source"},{"id":1293,"pagetitle":"API Reference","title":"UnitfulAstro.Rearth_p","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.Rearth_p","content":" UnitfulAstro.Rearth_p  —  Constant UnitfulAstro.Rearth_p The polar Earth radius, a unit of length. It is defined as 6.3568 × 10^6 m. It is intended to represent the distance from the Earth's center to its poles. Dimension:  𝐋 See also:  Rearth_e Reference:  IAU 2015 Resolution B3 source"},{"id":1294,"pagetitle":"API Reference","title":"UnitfulAstro.Rjup","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.Rjup","content":" UnitfulAstro.Rjup  —  Constant UnitfulAstro.Rjup The jovian radius, a unit of length. It is defined as 1 equatorial Jupiter radius. Dimension:  𝐋 See also:  Rjup_e ,  Rjup_p source"},{"id":1295,"pagetitle":"API Reference","title":"UnitfulAstro.Rjup_e","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.Rjup_e","content":" UnitfulAstro.Rjup_e  —  Constant UnitfulAstro.Rjup_e The equatorial Jupiter radius, a unit of length. It is defined as 7.1492 × 10^7 m. It is intended to represent the distance from Jupiter's center to its equator. Dimension:  𝐋 See also:  Rjup_p Reference:  IAU 2015 Resolution B3 source"},{"id":1296,"pagetitle":"API Reference","title":"UnitfulAstro.Rjup_p","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.Rjup_p","content":" UnitfulAstro.Rjup_p  —  Constant UnitfulAstro.Rjup_p The polar Jupiter radius, a unit of length. It is defined as 6.6854 × 10^7 m. It is intended to represent the distance from Jupiter's center to its equator. Dimension:  𝐋 See also:  Rjup_e Reference:  IAU 2015 Resolution B3 source"},{"id":1297,"pagetitle":"API Reference","title":"Masses and mass parameters","ref":"/previews/PR43/UnitfulAstro/stable/api/#Masses-and-mass-parameters","content":" Masses and mass parameters"},{"id":1298,"pagetitle":"API Reference","title":"UnitfulAstro.GMsun","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.GMsun","content":" UnitfulAstro.GMsun  —  Constant UnitfulAstro.GMSun The solar mass parameter. It is defined as 1.3271244 × 10^20 m^3 s^-2. It is intended to represent the product of G (the universal gravitational constant) and Msun (the solar mass). Dimension:  𝐋^3 𝐓^-2 See also:  G ,  Msun Reference:  IAU 2015 Resolution B3 source"},{"id":1299,"pagetitle":"API Reference","title":"UnitfulAstro.Msun","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.Msun","content":" UnitfulAstro.Msun  —  Constant UnitfulAstro.Msun The solar mass, a unit of mass. It is defined as 1 GMsun/G. It is approximately equal to 1.988 × 10^30 kg. It is intended to represent the entire mass of the Sun. Dimension:  𝐌 See also:  G ,  GMsun Reference:  IAU 2015 Resolution B3 source"},{"id":1300,"pagetitle":"API Reference","title":"UnitfulAstro.GMearth","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.GMearth","content":" UnitfulAstro.GMearth  —  Constant UnitfulAstro.GMearth The terrestrial mass parameter. It is defined as 3.986 004 × 10^14 m^3 s^-2. It is intended to represent the product of G (the universal gravitational constant) and Mearth (the terrestrial mass). Dimension:  𝐋^3 𝐓^-2 See also:  G ,  Mearth Reference:  IAU 2015 Resolution B3 source"},{"id":1301,"pagetitle":"API Reference","title":"UnitfulAstro.Mearth","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.Mearth","content":" UnitfulAstro.Mearth  —  Constant UnitfulAstro.Mearth The terrestrial mass, a unit of mass. It is defined as 1 GMearth/G. It is approximately 5.972 × 10^24 kg. It is intended to represent the total mass of the Earth. Dimension:  𝐌 See also:  G ,  GMearth source"},{"id":1302,"pagetitle":"API Reference","title":"UnitfulAstro.GMjup","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.GMjup","content":" UnitfulAstro.GMjup  —  Constant UnitfulAstro.GMjup The jovian mass parameter. It is defined as 1.266 8653 × 10^17 m^3 s^-2. It is intended to represent the product of G (the universal gravitational constant) and Mjup (the jovian mass). Dimension:  𝐋^3 𝐓^-2 See also:  G ,  Mjup Reference:  IAU 2015 Resolution B3 source"},{"id":1303,"pagetitle":"API Reference","title":"UnitfulAstro.Mjup","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.Mjup","content":" UnitfulAstro.Mjup  —  Constant UnitfulAstro.Mjup The jovian mass, a unit of mass. It is defined as 1 GMjup/G. It is approximately 1.898 × 10^27 kg. It is intended to represent the total mass of Jupiter . Dimension:  𝐌 See also:  G ,  GMjup source"},{"id":1304,"pagetitle":"API Reference","title":"Energy and fluxes","ref":"/previews/PR43/UnitfulAstro/stable/api/#Energy-and-fluxes","content":" Energy and fluxes"},{"id":1305,"pagetitle":"API Reference","title":"UnitfulAstro.Jy","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.Jy","content":" UnitfulAstro.Jy  —  Constant UnitfulAstro.Jy The jansky, a unit of spectral flux density, or spectral irradiance. It is defined as 10^-26 W m^-2 Hz^-1, or 10^-23 erg/s cm^-2 Hz^-1. Dimension:  𝐌 𝐓^-2 source"},{"id":1306,"pagetitle":"API Reference","title":"UnitfulAstro.Lsun","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.Lsun","content":" UnitfulAstro.Lsun  —  Constant UnitfulAstro.Lsun The solar luminosity, a unit of power. It is defined as 3.828 × 10^26 W in IAU 2015. It is intended to represent the total power emitted by the sun. Dimension:  𝐌 𝐋^2 𝐓^-3 Reference:  IAU 2015 Resolution B3 source"},{"id":1307,"pagetitle":"API Reference","title":"UnitfulAstro.foe","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.foe","content":" UnitfulAstro.foe  —  Constant UnitfulAstro.foe The foe, a unit of energy. It is defined as 10^51 erg (ten to the Fifty-One Ergs), or 10^44 J. It is intended to represent the approximate energy released in a supernova explosion. Dimension:  𝐌 𝐋^-2 𝐓^-2 References:  Herant et al. (1997) ,  Hartmann (1999) source"},{"id":1308,"pagetitle":"API Reference","title":"UnitfulAstro.SFU","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.SFU","content":" UnitfulAstro.SFU  —  Constant UnitfulAstro.SFU The solar flux unit, a unit of spectral flux density, or spectral irradiance. It is defined as 10 kJy, or 10^4 Jy. Dimension:  𝐌 𝐓^-2 See also:  Jy Reference:  Tapping (2013) source"},{"id":1309,"pagetitle":"API Reference","title":"UnitfulAstro.TECU","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.TECU","content":" UnitfulAstro.TECU  —  Constant UnitfulAstro.TECU The total electron content unit, a unit of areal number density. It is defined as 10^16 m^-2. TODO cite Hofmann-Wellenhof (2001). Dimension:  𝐋^-2 Reference:  Hofmann-Wellenhof (2001) source"},{"id":1312,"pagetitle":"Bibliography","title":"Bibliography","ref":"/previews/PR43/UnitfulAstro/stable/bibliography/#Bibliography","content":" Bibliography [1] IAU Division I Working Group Numerical Standards.  Resolution B2 on the Re-Definition of the Astronomical Unit of Length  (2012). [2] J. Binney and S. Tremaine.  Galactic Dynamics . 2nd Edition,  Princeton Series in Astrophysics  (Princeton University Press, Princeton, 2008). [3] Allen's Astrophysical Quantities  (Springer New York, New York, NY, 2002). [4] IAU Inter-Division A-G Working Group on Nominal Units for Stellar & Planetary Astronomy.  Resolution B2 on Recommended Zero Points for the Absolute and Apparent Bolometric Magnitude Scales  (2015). [5] IAU Inter-Division A-G Working Group on Nominal Units for Stellar & Planetary Astronomy.  Resolution B3 on Recommended Nominal Conversion Constants for Selected Solar and Planetary Properties  (2015). [6] M. Herant, S. Colgate, W. Benz and C. Fryer.  Neutrinos and Supernovae . Los Alamos Science, 164―178 (1997). [7] D. H. Hartmann.  Afterglows From the Largest Explosions in the Universe .  Proceedings of the National Academy of Science  96 , 4752–4755  (1999). [8] K. F. Tapping.  The 10.7 cm solar radio flux (F10.7) .  Space Weather  11 , 394–406  (2013). [9] B. Hofmann-Wellenhof.  Global Positioning System: Theory and Practice . 5th Edition (Springer Wien, Vienna, 2001)."},{"id":1315,"pagetitle":"Home","title":"WCS.jl","ref":"/previews/PR43/WCS/stable/#WCS.jl","content":" WCS.jl Astronomical  World Coordinate System  library for Julia. This package wraps the WCSLIB C library. This is a tool made for users who are already familiar with WCS transformations. If you are not, please reference the following manuscripts Representation of world coordinates in FITS Representations of celestial coordinates in FITS Representations of spectral coordinates in FITS Representations of distortions in FITS world coordinate systems"},{"id":1316,"pagetitle":"Home","title":"Table of Contents","ref":"/previews/PR43/WCS/stable/#Table-of-Contents","content":" Table of Contents WCS.jl Table of Contents Installation Usage API/Reference Index"},{"id":1317,"pagetitle":"Home","title":"Installation","ref":"/previews/PR43/WCS/stable/#Installation","content":" Installation From the REPL, press  ]  to enter Pkg mode (v 1.2) pkg> add WCS"},{"id":1318,"pagetitle":"Home","title":"Usage","ref":"/previews/PR43/WCS/stable/#Usage","content":" Usage Import the library julia> using WCS There are many ways to utilize WCS transformations. Let's make one for a 2-dimensional array (like an image) from scratch. julia> wcs = WCSTransform(2;\n                          cdelt = [-0.066667, 0.066667],\n                          ctype = [\"RA---AIR\", \"DEC--AIR\"],\n                          crpix = [-234.75, 8.3393],\n                          crval = [0., -90],\n                          pv    = [(2, 1, 45.0)])\nWCSTransform(naxis=2,cdelt=[-0.066667, 0.066667],crval=[0.0, -90.0],crpix=[-234.75, 8.3393]) We can also create one from a FITS header if it contains the appropriate keywords # Or from a FITS header with appropriate keywords\njulia> wcs_array = WCS.from_header(header)\n\njulia> wcs = wcs_array[1]\n Now we can do conversions between pixel and world coordinates. Note that WCS transforms use pixel  (0, 0)  as the top-left corner (not 1-indexed!!!) # convert pixel -> world coordinates\njulia> pixcoords = [0.0  24.0  45.0;  # x coordinates\n                    0.0  38.0  98.0]  # y coordinates\n2×3 Matrix{Float64}:\n 0.0  24.0  45.0\n 0.0  38.0  98.0\n\njulia> worldcoords = pix_to_world(wcs, pixcoords)\n2×3 Matrix{Float64}:\n 267.965   276.539   287.771\n -73.7366  -71.9741  -69.6781\njulia> pixcoords = world_to_pix(wcs, worldcoords)\n2×3 Matrix{Float64}:\n  1.16529e-12  24.0  45.0\n -7.10543e-14  38.0  98.0\n"},{"id":1319,"pagetitle":"Home","title":"API/Reference","ref":"/previews/PR43/WCS/stable/#API/Reference","content":" API/Reference"},{"id":1320,"pagetitle":"Home","title":"WCS.WCSTransform","ref":"/previews/PR43/WCS/stable/#WCS.WCSTransform","content":" WCS.WCSTransform  —  Type WCSTransform(naxis; kwds...) Construct a WCS transformation with the given number of axes  naxis . Keyword arguments can be passed to set various attributes of the transform. Specifying keyword arguments is equivalent to setting them after construction: julia> wcs = WCSTransform(2; crpix=[1000., 1000.]) is equilvalent to: julia> wcs = WCSTransform(2)\n\njulia> wcs.crpix = [1000., 1000.] Properties Below is the entire list of public properties for a  WCSTransform Keyword Type Description naxis Int Number of dimensions crval Vector{Float}[naxis] coordinate value at reference point crpix Vector{Float}[naxis] array location of the reference point in pixels cdelt Vector{Float}[naxis] coordinate increment at reference point crder Vector{Float}[naxis] random error in coordinate csyer Vector{Float}[naxis] systematic error in coordinate ctype Vector{String}[naxis] axis type (8 characters) crota Vector{Float}[naxis] rotation from stated coordinate type cunit Vector{String}[naxis] units of axes cunit Vector{String}[naxis] names of axes pc Matrix{Float}[naxis, naxis] linear transformation matrix cd Matrix{Float}[naxis, naxis] linear transformation matrix (with scale) equinox Float the equinox associated with dynamical equatorial or ecliptic coordinate systems latpole Float the native latitude of the celestial pole lonpole Float the native longitude of the celestial pole mjdavg Float Modified Julian Date corresponding to  DATE-AVG mjdobs Float Modified Julian Date corresponding to  DATE-OBS restfrq Float rest frequency (Hz) restwav Float rest wavelength (m) velangl Float velocity angle velosys Float relative radial velocity zsource Float the redshift of the source colnum Int column of FITS binary table associated with this WCS dateavg String representative mid-point of the date of observation dateobs String start of the date of observation radesys String the equatorial or ecliptic coordinate system type specsys String spectral reference frame (standard of rest) ssysobs String spectral reference frame ssyssrc String spectral reference frame for redshift wcsname String name of this coordinate representation obsgeo Vector{Float}[3]  or  Vector{Float}[6] location of the observer in a standard terrestrial reference frame alt String character code for alternate coordinate descriptions source"},{"id":1321,"pagetitle":"Home","title":"WCS.from_header","ref":"/previews/PR43/WCS/stable/#WCS.from_header-Tuple{String}","content":" WCS.from_header  —  Method from_header(header[; relax=WCS.HDR_ALL, ctrl=0, ignore_rejected=false, table=false]) Parse the FITS image header in the String  header , returning a  Vector{WCSTransform}  giving all the transforms defined in the header. The  relax  determines the treatment of non-standard keywords. The default is to accept all known non-standard keywords. Use  relax=WCS.HDR_NONE  to ignore all non-standard keywords. Use, e.g.,  relax=(WCS.HDR_RADECSYS & WCS.HDR_CROTAia)  to only accept selected non-standard keywords. source"},{"id":1322,"pagetitle":"Home","title":"WCS.obsfix","ref":"/previews/PR43/WCS/stable/#WCS.obsfix-Tuple{Integer, WCSTransform}","content":" WCS.obsfix  —  Method obsfix(ctrl::Integer, wcs::WCSTransform) Complete the  obsgeo  field  wcs  of observatory coordinates.  That is, if only the (x,y,z) Cartesian coordinate triplet or the (l,b,h) geodetic coordinate triplet are set, then it derives the other triplet from it. If both triplets are set, then it checks for consistency at the level of 1 metre. Parameters ctrl : flag that controls behaviour if one triplet is defined and the other is only partially defined: 0: Reset only the undefined elements of an incomplete coordinate triplet. 1: Reset all elements of an incomplete triplet. 2: Don't make any changes, check for consistency only. Returns an error if either of the two triplets is incomplete. wcs : Coordinate transformation parameters. Its  obsgeo  field may be changed. Returns -1: No change required (not an error). 0: Success. 1: Null wcsprm pointer passed. 5: Invalid parameter value. source"},{"id":1323,"pagetitle":"Home","title":"WCS.pix_to_world!","ref":"/previews/PR43/WCS/stable/#WCS.pix_to_world!-Tuple{WCSTransform, VecOrMat{Float64}, VecOrMat{Float64}}","content":" WCS.pix_to_world!  —  Method pix_to_world!(wcs, pixcoords, worldcoords[; stat=, imcoords=, phi=, theta=]) Convert the array of pixel coordinates  pixcoords  to world coordinates according to the WCSTransform  wcs , storing the result in the  worldcoords  and  stat  arrays.  pixcoords  should be a 2-d array where \"pixcoords[:, i]\" is the i-th set of coordinates, or a 1-d array representing a single set of coordinates.  worldcoords  must be the same size and type as  pixcoords . If given, the arrays  stat ,  imcoords ,  phi ,  theta  will be used to store intermediate results. Their sizes and types must all match  pixcoords , except for  stat  which should be the same size but of type Cint (typically Int32). source"},{"id":1324,"pagetitle":"Home","title":"WCS.pix_to_world","ref":"/previews/PR43/WCS/stable/#WCS.pix_to_world-Tuple{WCSTransform, VecOrMat{Float64}}","content":" WCS.pix_to_world  —  Method pix_to_world(wcs, pixcoords) Convert the array of pixel coordinates  pixcoords  to world coordinates according to the WCSTransform  wcs .  pixcoords  should be a 2-d array where \"pixcoords[:, i]\" is the i-th set of coordinates, or a 1-d array representing a single set of coordinates. The return value is the same shape as  pixcoords . source"},{"id":1325,"pagetitle":"Home","title":"WCS.to_header","ref":"/previews/PR43/WCS/stable/#WCS.to_header-Tuple{WCSTransform}","content":" WCS.to_header  —  Method to_header(wcs[; relax=WCS.HDR_NONE]) Encode the WCSTransform  wcs  as a FITS header string. The  relax  keyword controls how non-standard extensions to the WCS standard are handled. source"},{"id":1326,"pagetitle":"Home","title":"WCS.world_to_pix!","ref":"/previews/PR43/WCS/stable/#WCS.world_to_pix!-Tuple{WCSTransform, VecOrMat{Float64}, VecOrMat{Float64}}","content":" WCS.world_to_pix!  —  Method world_to_pix!(wcs, worldcoords, pixcoords[; stat=, phi=, theta=, imcoords=]) Convert the array of pixel coordinates  worldcoords  to pixel coordinates according to the WCSTransform  wcs , storing the result in the  pixcoords  array.  worldcoords  should be a 2-d array where \"worldcoords[:, i]\" is the i-th set of coordinates, or a 1-d array representing a single set of coordinates.  pixcoords  must be the same size and type as  worldcoords . If given, the arrays  stat ,  imcoords ,  phi ,  theta  will be used to store intermediate results. Their sizes and types must all match  worldcoords , except for  stat  which should be the same size but of type Cint (typically Int32). source"},{"id":1327,"pagetitle":"Home","title":"WCS.world_to_pix","ref":"/previews/PR43/WCS/stable/#WCS.world_to_pix-Tuple{WCSTransform, VecOrMat{Float64}}","content":" WCS.world_to_pix  —  Method world_to_pix(wcs, worldcoords) Convert the array of world coordinates  worldcoords  to pixel coordinates according to the WCSTransform  wcs .  worldcoords  is a 2-d array where \"worldcoords[:, i]\" is the i-th set of coordinates, or a 1-d array representing a single set of coordinates. The return value is the same size as  worldcoords . source"},{"id":1328,"pagetitle":"Home","title":"Index","ref":"/previews/PR43/WCS/stable/#Index","content":" Index WCS.WCSTransform WCS.from_header WCS.obsfix WCS.pix_to_world WCS.pix_to_world! WCS.to_header WCS.world_to_pix WCS.world_to_pix!"},{"id":1333,"pagetitle":"Home","title":"Transits.jl","ref":"/previews/PR43/Transits/stable/#Transits.jl","content":" Transits.jl Transits.jl provides flexible and powerful occultation curves with limb darkening. The goals of this package are, in this order have a simple interface with high  composability be flexible with respect to numeric types and application be fully compatible with  ChainRules.jl  automatic differentiation (AD) system to leverage the derived analytical gradients provide a codebase that is well-organized, instructive, and easy to extend maintain high performance: at least as fast as similar tools In particular,  PolynomialLimbDark  implements the \"starry\" limb darkening method, which solves the flux integral analytically. This provides floating-point errors and runtimes that are best in class."},{"id":1334,"pagetitle":"Home","title":"Installation","ref":"/previews/PR43/Transits/stable/#Installation","content":" Installation To install use  Pkg . From the REPL, press  ]  to enter Pkg-mode pkg> add Transits If you want to use the most up-to-date version of the code, check it out from  main pkg> add Transits#main"},{"id":1335,"pagetitle":"Home","title":"Citations","ref":"/previews/PR43/Transits/stable/#Citations","content":" Citations If you use Transits.jl or a derivative of it in your work please consider citing it at the  Zenodo DOI . If you use  PolynomialLimbDark  or  QuadLimbDark  please also cite  Agol et al. (2020)  and  Luger et al. (2019) . If you use  Kipping13  please cite  Kipping (2013) . BibTeX for all those citations can be found in  CITATIONS.bib ."},{"id":1338,"pagetitle":"API/Reference","title":"API/Reference","ref":"/previews/PR43/Transits/stable/api/#API/Reference","content":" API/Reference"},{"id":1339,"pagetitle":"API/Reference","title":"Index","ref":"/previews/PR43/Transits/stable/api/#Index","content":" Index Transits.AbstractLimbDark Transits.AbstractLimbDark Transits.IntegratedLimbDark Transits.Kipping13 Transits.PolynomialLimbDark Transits.QuadLimbDark Transits.SecondaryLimbDark Transits.compute Transits.compute"},{"id":1340,"pagetitle":"API/Reference","title":"Light Curves","ref":"/previews/PR43/Transits/stable/api/#Light-Curves","content":" Light Curves"},{"id":1341,"pagetitle":"API/Reference","title":"Transits.AbstractLimbDark","ref":"/previews/PR43/Transits/stable/api/#Transits.AbstractLimbDark","content":" Transits.AbstractLimbDark  —  Type AbstractLimbDark A limb dark law need only need to implement  compute(::Law, b, r)  to extend the limb darkening interface. See also compute source"},{"id":1342,"pagetitle":"API/Reference","title":"Transits.AbstractLimbDark","ref":"/previews/PR43/Transits/stable/api/#Transits.AbstractLimbDark-Tuple","content":" Transits.AbstractLimbDark  —  Method (::AbstractLimbDark)(b, r) An alias for calling  compute Examples julia> ld = PolynomialLimbDark([0.4, 0.26]);\n\njulia> ld(0, 0.01)\n0.9998785437247428 source"},{"id":1343,"pagetitle":"API/Reference","title":"Transits.PolynomialLimbDark","ref":"/previews/PR43/Transits/stable/api/#Transits.PolynomialLimbDark","content":" Transits.PolynomialLimbDark  —  Type PolynomialLimbDark(u::AbstractVector) Polynomial limb darkening using analytical integrals. The length of the  u  vector is equivalent to the order of polynomial used; e.g.,  [0.2, 0.3]  corresponds to quadratic limb darkening. Mathematical form \\[I(\\mu) \\propto 1 - u_1(1-\\mu) - u_2(1-\\mu)^2 - \\dots - u_N(1-\\mu)^N\\] which is equivalent to the series \\[I(\\mu) \\propto -\\sum_{i=0}^N{u_i(1-\\mu)^i}\\] with the definition  $u_0 \\equiv -1$ . Examples u = [0.4, 0.26] # quadratic and below is 100% analytical\nld = PolynomialLimbDark(u)\nld(0.1, 0.01)\n\n# output\n0.9998787880717668 u2 = vcat(u, ones(12) ./ 12)\nld2 = PolynomialLimbDark(u2)\nld2(0.1, 0.01)\n\n# output\n0.9998740059086433 References Agol, Luger, Foreman-Mackey (2020) \"Analytic Planetary Transit Light Curves and Derivatives for Stars with Polynomial Limb Darkening\" Luger et al. (2019) \"starry: Analytic Occultation Light Curves\" source"},{"id":1344,"pagetitle":"API/Reference","title":"Transits.QuadLimbDark","ref":"/previews/PR43/Transits/stable/api/#Transits.QuadLimbDark","content":" Transits.QuadLimbDark  —  Type QuadLimbDark(u::AbstractVector) A specialized implementation of  PolynomialLimbDark  with a maximum of two terms (quadratic form). This has a completely closed-form solution without any numerical integration. This means there are no intermediate allocations and reduced numerical error. Mathematical form \\[I(\\mu) \\propto 1 - u_1(1-\\mu) - u_2(1-\\mu)^2\\] Higher-order terms Higher-order terms will be  ignored ; no error will be thrown Examples ld = QuadLimbDark(Float64[]) # constant term only\n\nb = [0, 1, 2] # impact parameter\nr = 0.01 # radius ratio\nld.(b, r)\n\n# output\n3-element Vector{Float64}:\n 0.9999\n 0.9999501061035608\n 1.0 ld = QuadLimbDark([0.4, 0.26]) # max two terms\nld.(b, r)\n\n# output\n3-element Vector{Float64}:\n 0.9998785437247428\n 0.999974726693709\n 1.0 References See references for  PolynomialLimbDark source"},{"id":1345,"pagetitle":"API/Reference","title":"Transits.IntegratedLimbDark","ref":"/previews/PR43/Transits/stable/api/#Transits.IntegratedLimbDark","content":" Transits.IntegratedLimbDark  —  Type IntegratedLimbDark(limbdark; N=21, basis=:legendre)\nIntegratedLimbDark(u; kwargs...) Computes the time-averaged flux in the middle of an exposure by wrapping a limb darkening law  limbdark  with a quadrature scheme. For each time step  t ,  N  extra points are  super-sampled  from  t-texp/2  to  t+texp/2 and the time-averaged flux is calculated via quadrature. If a set of limb darkening coefficients,  u , is provided, a  PolynomialLimbDark  law will be used by default. Mathematical form \\[\\bar{F}(t) = \\frac{1}{\\Delta t}\\int_{t-\\Delta t / 2}^{t+\\Delta t / 2}{F(t')dt'}\\] where  $F$  is the wrapped limb darkening law and  $\\Delta t$  is the exposure time. Quadrature The integration is approximated via  Guassian quadrature \\[\\frac{1}{\\Delta t} \\int{F(t')dt'} \\approx \\frac12\\sum_i^N{w_i * F(\\frac{\\Delta t}{2}\\xi_i + t)}\\] where the weights  w_i  and nodes  ξ_i  are defined by the given quadrature rule. The nodes are defined by evaluating orthogonal polynomials  N  times between -1 and 1. Notice the change of interval required to go from the natural bounds of the orthogonal polynomial basis,  -1, 1 , to the range defined by the exposure time. The following bases are available from  FastGaussQuadrature.jl . In addition, a function can be passed which calculates  nodes, weights = f(N) . :legendre  - Legendre polynomial base on the open  (-1, 1) :radau  - Legendre polynomial base on the semi-open  [-1, 1)  interval :lobatto  - Legendre polynomial base on the closed  [-1, 1]  interval source"},{"id":1346,"pagetitle":"API/Reference","title":"Transits.SecondaryLimbDark","ref":"/previews/PR43/Transits/stable/api/#Transits.SecondaryLimbDark","content":" Transits.SecondaryLimbDark  —  Type SecondaryLimbDark(primary::AbstractLimbDark,\n                  secondary::AbstractLimbDark; \n                  brightness_ratio=1)\nSecondaryLimbDark(u_p::AbstractVector, u_s=u_p; kwargs...) Compose two limb darkening laws together to add a secondary eclipse. If vectors of coefficients are provided, laws will automatically be constructed using  PolynomialLimbDark . The surface brightness ratio is given in terms of the host; e.g., if the companion is half as bright as the host, the ratio would be 0.5. Interface SecondaryLimbDark  only works with an orbit, since the companion's reference frame needs to be calculated. This means you can't call it using an impact parameter like  ld(b, r)  directly. Mathematical form \\[f(t, r) = \\frac{2f_p(t, r) + \\eta r^2 f_s(t', r')}{1 + f_p(t, r) + \\eta r^2 f_s(t', r')}\\] where  $f_p$  is to the primary flux,  $f_s$  is to the secondary flux, and  $\\eta$  is the surface brightness ratio.  $t'$  and  $r'$  correspond to the time and radius ratio from the companion's reference frame. Examples using Orbits\n# equal size and limb darkening\nr = 1.0\nu = [0.4, 0.26]\n# companion is 1/10 as bright\nbrightness_ratio = 0.1\nld = SecondaryLimbDark(u; brightness_ratio)\norbit = SimpleOrbit(period=2, duration=0.5)\nfp = ld(orbit, 0, r) # primary egress\nfs = ld(orbit, 1, r) # secondary egress\n\nfp ≈ brightness_ratio * fs\n\n# output\ntrue source"},{"id":1347,"pagetitle":"API/Reference","title":"Transits.compute","ref":"/previews/PR43/Transits/stable/api/#Transits.compute","content":" Transits.compute  —  Function compute(::AbstractLimbDark, b, r; kwargs...) Compute the relative flux for the given impact parameter  b  and radius ratio  r . The impact parameter is unitless. The radius ratio is given in terms of the host; e.g., if the companion is half the size of the host, r=0.5. source"},{"id":1348,"pagetitle":"API/Reference","title":"Transits.compute","ref":"/previews/PR43/Transits/stable/api/#Transits.compute-Tuple{AbstractLimbDark, Orbits.AbstractOrbit, Any, Any}","content":" Transits.compute  —  Method compute(::AbstractLimbDark, orbit::AbstractOrbit, t, r) Compute the relative flux by calculating the impact parameter at time  t  from the given orbit. The time needs to be compatible with the period of the orbit, nominally in days. Examples julia> using Orbits\n\njulia> ld = PolynomialLimbDark([0.4, 0.26]);\n\njulia> orbit = SimpleOrbit(period=3, duration=1);\n\njulia> ld(orbit, 0, 0.1) # primary egress\n0.9878664434953113\n\njulia> ld(orbit, 0.1, 0.1) # 0.1 d\n0.9879670695533511 this works effortlessly with libraries like  Unitful.jl julia> using Unitful\n\njulia> orbit = SimpleOrbit(period=3u\"d\", duration=3u\"hr\");\n\njulia> ld(orbit, 0u\"d\", 0.1)\n0.9878664434953113 source"},{"id":1349,"pagetitle":"API/Reference","title":"Gradients","ref":"/previews/PR43/Transits/stable/api/#Gradients","content":" Gradients Gradients and jacobians are integrated directly into  ChainRules.jl  via  frule s and  rrule s.  For most users, this just means using AD libraries like  ForwardDiff.jl  and  Zygote.jl  is effortless and fast . using Transits\nusing Zygote\n\nlightcurve(X) = compute(PolynomialLimbDark(X[3:end]), X[1], X[2])\ngrad(X) = lightcurve'(X) # Zygote gradient\ngrad([0.1, 0.1, 0.4, 0.26])\n\n# output\n4-element Vector{Float64}:\n  0.0004972185834858653\n -0.2419262730830416\n -0.0048107583897073185\n -0.0024501564976671724 To help demonstrate the logic behind these chain rules, here we derive a simple gradient function manually. using ChainRulesCore\n\nu_n = [0.4, 0.26]\nμ = 0.1\nror = 0.1\nX0 = [μ, ror, u_n...]\n\nfunction gradr(X)\n    ld, ld_pullback = rrule(PolynomialLimbDark, X[3:end])\n    f, f_pullback = rrule(compute, ld, X[1], X[2])\n\n    f̄ = one(eltype(X))\n    _, l̄d, b̄, r̄ = f_pullback(f̄)\n    _, ū_n = ld_pullback(l̄d)\n    return [b̄, r̄, ū_n...]\nend\n\ngradr([0.1, 0.1, 0.4, 0.26])\n\n# output\n4-element Vector{Float64}:\n  0.0004972185834858653\n -0.2419262730830416\n -0.0048107583897073185\n -0.0024501564976671724 For the most granular support for gradients and jacobians, peer into the depths of  polynomial/poly-grad.jl  and  polynomial/quad-grad.jl . These functions are not part of the public API and are not guaranteed any stability according to  semantic versioning ."},{"id":1350,"pagetitle":"API/Reference","title":"Distributions","ref":"/previews/PR43/Transits/stable/api/#Distributions","content":" Distributions"},{"id":1351,"pagetitle":"API/Reference","title":"Transits.Kipping13","ref":"/previews/PR43/Transits/stable/api/#Transits.Kipping13","content":" Transits.Kipping13  —  Type Kipping13() A non-informative prior for two-parameter limb-darkening coefficients using  triangular sampling  ( Kipping 2013 ). Examples julia> using StableRNGs; rng = StableRNG(10);\n\njulia> rand(rng, Kipping13())\n2-element Vector{Float64}:\n  0.3361047299132651\n -0.025681638815114587\n\njulia> rand(rng, Kipping13(), 5)\n2×5 Matrix{Float64}:\n 0.0621057   0.992689   1.77965    0.784055  0.186386\n 0.0659477  -0.236613  -0.795884  -0.187791  0.592194 References Kipping (2013) \"Efficient, uninformative sampling of limb darkening coefficients for two-parameter laws\" source"},{"id":1354,"pagetitle":"Benchmarks","title":"Benchmarks","ref":"/previews/PR43/Transits/stable/bench/#Benchmarks","content":" Benchmarks Transits.jl aims to be at least as fast as similar tools.  Limbdark.jl  is also written in Julia and  Agol et al. (2020)  showed it outperforms starry, PyTransit, and batman in both runtime speed and numerical accuracy. The following benchmarks are works in progress, but they already show a marginal improvement on the Limbdark.jl implementation."},{"id":1355,"pagetitle":"Benchmarks","title":"Setup","ref":"/previews/PR43/Transits/stable/bench/#Setup","content":" Setup Warning These benchmarks are works in progress The code can be found in  bench/ . You'll need to set up the environment yourself, including the installation of Limbdark.jl."},{"id":1356,"pagetitle":"Benchmarks","title":"Performance","ref":"/previews/PR43/Transits/stable/bench/#Performance","content":" Performance"},{"id":1357,"pagetitle":"Benchmarks","title":"Comparison with Limbdark.jl","ref":"/previews/PR43/Transits/stable/bench/#Comparison-with-Limbdark.jl","content":" Comparison with Limbdark.jl"},{"id":1360,"pagetitle":"Getting Started","title":"Getting Started","ref":"/previews/PR43/Transits/stable/gettingstarted/#Getting-Started","content":" Getting Started"},{"id":1361,"pagetitle":"Getting Started","title":"Usage","ref":"/previews/PR43/Transits/stable/gettingstarted/#Usage","content":" Usage using Orbits\nusing Transits\n\norbit = SimpleOrbit(period=3, duration=1)\nu = [0.4, 0.26] # quad limb dark\nld = PolynomialLimbDark(u)\n\nt = range(-1, 1, length=1000) # days from t0\nrs = range(0, 0.2, length=10) # radius ratio\n\nfluxes = @. ld(orbit, t, rs')"},{"id":1362,"pagetitle":"Getting Started","title":"Integrated and Secondary Curves","ref":"/previews/PR43/Transits/stable/gettingstarted/#Integrated-and-Secondary-Curves","content":" Integrated and Secondary Curves IntegratedLimbDark  can be used to numerically integrate each light curve exposure in time ld = IntegratedLimbDark([0.4, 0.26])\norbit = SimpleOrbit(period=3, duration=1)\nt = range(-1, 1, length=1000)\ntexp = [0.1 0.2 0.3]\n# no extra calculations made\nflux = @. ld(orbit, t, 0.2)\n# use quadrature to find time-averaged flux for each t\nflux_int = @. ld(orbit, t, 0.2, texp)  SecondaryLimbDark  can be used to generate secondary eclipses given a surface brightness ratio ld = SecondaryLimbDark([0.4, 0.26], brightness_ratio=0.1)\nld_int = IntegratedLimbDark(ld) # composition works flawlessly\n\norbit = SimpleOrbit(period=4, duration=1)\nt = range(-1.25, 2.75, length=1000)\nrs = range(0.01, 0.1, length=6)\n\nf = @. ld(orbit, t, rs')\nf_int = @. ld_int(orbit, t, rs', texp=0.3)"},{"id":1363,"pagetitle":"Getting Started","title":"Using Units","ref":"/previews/PR43/Transits/stable/gettingstarted/#Using-Units","content":" Using Units Units from  Unitful.jl  are a drop-in substitution for numbers using Unitful\norbit = SimpleOrbit(period=10u\"d\", duration=5u\"hr\")\nt = range(-6, 6, length=1000)u\"hr\"\nflux = @. ld(orbit, t, 0.1)"},{"id":1364,"pagetitle":"Getting Started","title":"Gradients","ref":"/previews/PR43/Transits/stable/gettingstarted/#Gradients","content":" Gradients Gradients are provided in the form of  chain rules . The easiest way to access them is using an automatic differentiation (AD) library like  ForwardDiff.jl  or  Zygote.jl . using Zygote\n\nts = range(-1, 1, length=1000) # days from t0\nror = 0.1\nu_n = [0.4, 0.26]\n\norbit = SimpleOrbit(period=3, duration=1)\nlightcurve(X) = compute(PolynomialLimbDark(X[3:end]), orbit, X[1], X[2])\n\n# use Zygote for gradient\nflux = [lightcurve([t, ror, u_n...]) for t in ts]\ngrads = mapreduce(hcat, ts) do t\n    grad = lightcurve'([t, ror, u_n...])\n    return grad === nothing ? zeros(4) : grad\nend"},{"id":1367,"pagetitle":"Introduction","title":"Introduction","ref":"/previews/PR43/Transits/stable/introduction/#Introduction","content":" Introduction"},{"id":1368,"pagetitle":"Introduction","title":"Historical overview","ref":"/previews/PR43/Transits/stable/introduction/#Historical-overview","content":" Historical overview Transit light curves are an essential tool used for the detection of  exoplanets . To date, there have been over 4,300 confirmed planets discovered in over 3,400 different star systems, with an additional 2,400 candidates currently awaiting follow-up analysis and validation [1] . Since the first confirmed discovery of an exoplanet – as part of a multi-planetary system in 1992 [2] , and the first exoplanet discovered around a Sun-like star shortly after in 1995 [3]  – there has been an explosion in new discoveries, thanks in large part to the successful  Kepler/K2  and  TESS  space missions. The large majority of these planets have been detected via the  transit method : Exoplanet Archive"},{"id":1369,"pagetitle":"Introduction","title":"Transit method","ref":"/previews/PR43/Transits/stable/introduction/#Transit-method","content":" Transit method This method works by observing the dimming in apparent brightness of a star as a planet passes in front of it from our point of view. The plot of the star's brightness as a function of time defines the  white light curve  as seen in the schematic below: \"How Do You Find an Exoplanet?\" by John Asher Johnson Even just starting with a simple single planet system in a circular orbit, there is already a wealth of information encoded in this diagram. These observations give us insight not only into the bulk properties of the planet, but into the architecture of its orbital system and characteristics of its host star as well. For example,  direct observables  from the light curve like the  transit duration $(T)$  and  ingress/egress  time  $(\\tau)$  give us information about how tilted its orbit is and how fast the planet is traveling, while the  transit depth $(\\delta)$  gives us a direct measure of the size of the planet relative to its star. For circular orbits, these are nicely summarized by: \\[\\begin{aligned}\n\\frac{R_\\text{p}}{R_*} &= \\delta^{1/2} \\\\\n\nb^2 &= 1 - \\delta^{1/2}\\frac{T}{t} \\\\\n\n\\frac{a}{R_*} &= \\frac{P\\delta^{1/4}}{2\\pi}\n\\left(\\frac{4}{T\\tau}\\right)^{1/2} \\\\\n\n\\rho_* &= \\frac{3P}{G\\pi^2}\\left(\\frac{\\delta^{1/4}}{\\sqrt{T\\tau}}\\right)^3 \\quad,\n\\end{aligned}\\] where  $P$  is the period of the planet's orbit and  $a$  its semi-major axis,  $b$  is the impact parameter,  $R_*$  is the radius of its star, and  $\\rho_*$  is the stellar density."},{"id":1370,"pagetitle":"Introduction","title":"Limb darkening","ref":"/previews/PR43/Transits/stable/introduction/#Limb-darkening","content":" Limb darkening Not shown above is an added dimension that  Transits.jl  excels in,  limb darkening , demonstrated in the schematic below: ASTR 236 class notes This effect is intimately related to the shape of the light curve, and allows us to constrain the brightness profile of the star itself. As we will see next, the method of transit light curves is not just useful for the detection of exoplanets, but also for taking it to the next step of characterizing its atmosphere."},{"id":1371,"pagetitle":"Introduction","title":"Transmission spectroscopy","ref":"/previews/PR43/Transits/stable/introduction/#Transmission-spectroscopy","content":" Transmission spectroscopy If we perform the technique of transit light curve modeling on a wavelength-by-wavelength basis, we can further probe the properties of the host star and begin to make predictions about the properties of the planet's atmosphere, such as its chemical composition and whether clouds/hazes are likely to be present at higher altitudes. This analysis begins in the same way as with the white light curve seen above, only now a  wavelength binned light curve  is measured at a range of different wavelengths:  Adapted from Weaver et al. (2021,  submitted ) Plotting these wavelength dependent transit depths then builds a  transmission spectrum , which is filled with information about the planet's atmosphere and its star, summarized below: Benneke & Seager (2012) Rackham, Apai, & Giampapa (2018) Performing forward modeling (see, e.g.,  Kempton et al. 2016 ,  Goyal et al. 2017 ) and retrievals (see, e.g.,  Barstow et al. 2020  and references therein) using these frameworks then allows us to explore exoplanetary atmospheres in never before seen detail."},{"id":1372,"pagetitle":"Introduction","title":"Summary","ref":"/previews/PR43/Transits/stable/introduction/#Summary","content":" Summary The detection and characterization of exoplanets through their transit light curves is a relatively new technique in the field of astronomy, with recent advances only being made possible through novel uses of large, ground-based telescopes and soon in the future with planned  ELTs  and space based missions like  JWST . Studies using these observing facilities will require the fast and precise computation of transit light curves, which  Transits.jl  aims to provide. 1 https://exoplanetarchive.ipac.caltech.edu/ 2 https://ui.adsabs.harvard.edu/abs/1992Natur.355..145W/abstract 3 https://ui.adsabs.harvard.edu/abs/1995Natur.378..355M/abstract"},{"id":1377,"pagetitle":"Home","title":"EarthOrientation.jl","ref":"/previews/PR43/EarthOrientation/stable/#EarthOrientation.jl","content":" EarthOrientation.jl Calculate Earth orientation parameters from IERS tables in Julia."},{"id":1378,"pagetitle":"Home","title":"Installation","ref":"/previews/PR43/EarthOrientation/stable/#Installation","content":" Installation The package can be installed through Julia's package manager: Pkg.add(\"EarthOrientation\")"},{"id":1379,"pagetitle":"Home","title":"Quickstart","ref":"/previews/PR43/EarthOrientation/stable/#Quickstart","content":" Quickstart Fetch the latest [IERS][iers-link] tables: using EarthOrientation\nEarthOrientation.update() Get the current Earth orientation parameters, e.g. for polar motion: xp, yp = polarmotion(now()) # arcseconds Or the current difference between UT1 and UTC and the associated prediction error: ΔUT1 = getΔUT1(now()) # seconds\nΔUT1_err = getΔUT1_err(now()) # seconds"},{"id":1380,"pagetitle":"Home","title":"Available data","ref":"/previews/PR43/EarthOrientation/stable/#Available-data","content":" Available data Polar motion: x-coordinate of Earth's north pole:  getxp y-coordinate of Earth's north pole:  getyp both:  polarmotion Earth rotation Difference between UT1 and UTC:  getΔUT1 Difference between UT1 and TAI:  getΔUT1_TAI Excess length of day:  getlod Precession and nutation based on the 1980 IAU conventions Correction to the nutation of the ecliptic:  getdψ Correction to the obliquity of the ecliptic:  getdϵ both:  precession_nutation80 Precession and nutation based on the 2000 IAU conventions Correction to the celestial pole's x-coordinate:  getdx Correction to the celestial pole's y-coordinate:  getdy both:  precession_nutation00 There is an associated function that returns the prediction error for each data type, e.g.  getxp_err ."},{"id":1381,"pagetitle":"Home","title":"Manual Data Management","ref":"/previews/PR43/EarthOrientation/stable/#Manual-Data-Management","content":" Manual Data Management By default the files downloaded by  EarthOrientation.update()  will be used. It is also possible to pass different  finals.all  and  finals2000A.all  files in CSV format. using EarthOrientation\n\npush!(EOP_DATA, \"finals.csv\", \"finals2000A.csv\")"},{"id":1384,"pagetitle":"API","title":"API","ref":"/previews/PR43/EarthOrientation/stable/api/#API","content":" API"},{"id":1385,"pagetitle":"API","title":"EarthOrientation.EOParams","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.EOParams-Tuple{String,String}","content":" EarthOrientation.EOParams  —  Method EOParams(iau1980file::String, iau2000file::String) Parse IERS data files into a  EOParams  object.  iau1980file  and  iau2000file  are the paths to a 'finals.all' and a 'finals2000A.all' CSV file, respectively. source"},{"id":1386,"pagetitle":"API","title":"EarthOrientation.getdx","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getdx-Tuple{Any,Any}","content":" EarthOrientation.getdx  —  Method getdx(date; outside_range=:warn) Get the celestial pole x-coordinate correction for a certain  date  in milliarcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1387,"pagetitle":"API","title":"EarthOrientation.getdx_err","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getdx_err-Tuple{Any,Any}","content":" EarthOrientation.getdx_err  —  Method getdx_err(date; outside_range=:warn) Get the error in celestial pole x-coordinate correction for a certain  date  in milliarcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1388,"pagetitle":"API","title":"EarthOrientation.getdy","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getdy-Tuple{Any,Any}","content":" EarthOrientation.getdy  —  Method getdy(date; outside_range=:warn) Get the celestial pole y-coordinate correction for a certain  date  in milliarcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1389,"pagetitle":"API","title":"EarthOrientation.getdy_err","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getdy_err-Tuple{Any,Any}","content":" EarthOrientation.getdy_err  —  Method getdy_err(date; outside_range=:warn) Get the error in celestial pole y-coordinate correction for a certain  date  in milliarcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1390,"pagetitle":"API","title":"EarthOrientation.getdψ","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getdψ-Tuple{Any,Any}","content":" EarthOrientation.getdψ  —  Method getdψ(date; outside_range=:warn) Get the ecliptic nutation correction for a certain  date  in milliarcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1391,"pagetitle":"API","title":"EarthOrientation.getdψ_err","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getdψ_err-Tuple{Any,Any}","content":" EarthOrientation.getdψ_err  —  Method getdψ_err(date; outside_range=:warn) Get the error in the ecliptic nutation correction for a certain  date  in milliarcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1392,"pagetitle":"API","title":"EarthOrientation.getdϵ","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getdϵ-Tuple{Any,Any}","content":" EarthOrientation.getdϵ  —  Method getdϵ(date; outside_range=:warn) Get the ecliptic obliquity correction for a certain  date  in milliarcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1393,"pagetitle":"API","title":"EarthOrientation.getdϵ_err","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getdϵ_err-Tuple{Any,Any}","content":" EarthOrientation.getdϵ_err  —  Method getdϵ_err(date; outside_range=:warn) Get the error in the ecliptic obliquity correction for a certain  date  in milliarcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1394,"pagetitle":"API","title":"EarthOrientation.getlod","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getlod-Tuple{Any,Any}","content":" EarthOrientation.getlod  —  Method getlod(date; outside_range=:warn) Get the excess length of day for a certain  date  in milliseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1395,"pagetitle":"API","title":"EarthOrientation.getlod_err","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getlod_err-Tuple{Any,Any}","content":" EarthOrientation.getlod_err  —  Method getlod_err(date; outside_range=:warn) Get the error in the excess length of day for a certain  date  in milliseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1396,"pagetitle":"API","title":"EarthOrientation.getxp","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getxp-Tuple{Any,Any}","content":" EarthOrientation.getxp  —  Method getxp(date; outside_range=:warn) Get the x-coordinate of Earth's north pole w.r.t. the CIO for a certain  date  in arcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1397,"pagetitle":"API","title":"EarthOrientation.getxp_err","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getxp_err-Tuple{Any,Any}","content":" EarthOrientation.getxp_err  —  Method getxp_err(date; outside_range=:warn) Get the error for the x-coordinate of Earth's north pole w.r.t. the CIO for a certain  date  in arcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1398,"pagetitle":"API","title":"EarthOrientation.getyp","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getyp-Tuple{Any,Any}","content":" EarthOrientation.getyp  —  Method getyp(date; outside_range=:warn) Get the y-coordinate of Earth's north pole w.r.t. the CIO for a certain  date  in arcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1399,"pagetitle":"API","title":"EarthOrientation.getyp_err","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getyp_err-Tuple{Any,Any}","content":" EarthOrientation.getyp_err  —  Method getyp_err(date; outside_range=:warn) Get the error for the y-coordinate of Earth's north pole w.r.t. the CIO for a certain  date  in arcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1400,"pagetitle":"API","title":"EarthOrientation.getΔUT1","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getΔUT1-Tuple{Any,Any}","content":" EarthOrientation.getΔUT1  —  Method getΔUT1(date; outside_range=:warn) Get the difference between UTC and UT1 for a certain  date  in seconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1401,"pagetitle":"API","title":"EarthOrientation.getΔUT1_TAI","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getΔUT1_TAI-Tuple{Any,Any}","content":" EarthOrientation.getΔUT1_TAI  —  Method getΔUT1_TAI(date; outside_range=:warn) Get the difference between TAI and UT1 for a certain  date  in seconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1402,"pagetitle":"API","title":"EarthOrientation.getΔUT1_err","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getΔUT1_err-Tuple{Any,Any}","content":" EarthOrientation.getΔUT1_err  —  Method getΔUT1_err(date; outside_range=:warn) Get the error in the difference between UTC and UT1 for a certain  date  in seconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1403,"pagetitle":"API","title":"EarthOrientation.polarmotion","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.polarmotion-Tuple{Any,Any}","content":" EarthOrientation.polarmotion  —  Method polarmotion(date; outside_range=:warn) Get the coordinates of Earth's north pole w.r.t. the CIO for a certain  date  in arcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1404,"pagetitle":"API","title":"EarthOrientation.precession_nutation00","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.precession_nutation00-Tuple{Any,Any}","content":" EarthOrientation.precession_nutation00  —  Method precession_nutation00(date; outside_range=:warn) Get the celestial pole coordinate corrections for a certain  date  in milliarcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1405,"pagetitle":"API","title":"EarthOrientation.precession_nutation80","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.precession_nutation80-Tuple{Any,Any}","content":" EarthOrientation.precession_nutation80  —  Method precession_nutation80(date; outside_range=:warn) Get the ecliptic corrections for a certain  date  in milliarcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1408,"pagetitle":"Internals","title":"Internals","ref":"/previews/PR43/EarthOrientation/stable/internals/#Internals","content":" Internals"},{"id":1409,"pagetitle":"Internals","title":"EarthOrientation.getdate","ref":"/previews/PR43/EarthOrientation/stable/internals/#EarthOrientation.getdate-Tuple{Any}","content":" EarthOrientation.getdate  —  Method getdate(data) Determine the creation date of an IERS table by finding the last entry which is marked as \"final\". source"},{"id":1410,"pagetitle":"Internals","title":"EarthOrientation.update","ref":"/previews/PR43/EarthOrientation/stable/internals/#EarthOrientation.update-Tuple{}","content":" EarthOrientation.update  —  Method update(; force=false) Download weekly EOP data from the IERS servers if newer files are available or no data has been downloaded previously. If the keyword  force  is  true , then all the files will be downloaded again. source"},{"id":1415,"pagetitle":"Tutorial","title":"Tutorial","ref":"/previews/PR43/EarthOrientation/stable/tutorial/#Tutorial","content":" Tutorial EarthOrientation.jl  downloads, parses, and interpolates weekly-updated tables from the  IERS  that contain the following Earth Orientation Parameters (EOP): Polar motion: x-coordinate of Earth's north pole:  $x_p$ y-coordinate of Earth's north pole:  $y_p$ Earth rotation Difference between UT1 and UTC:  $\\Delta UT1$ Excess length of day:  $LOD$ Precession and nutation based on the 1980 IAU conventions Correction to the nutation of the ecliptic:  $d\\psi$ Correction to the obliquity of the ecliptic:  $d\\epsilon$ Precession and nutation based on the 2000 IAU conventions Correction to the celestial pole's x-coordinate:  $dx$ Correction to the celestial pole's y-coordinate:  $dy$ These parameters are required for precise transformations between quasi-inertial and rotating terrestrial reference frames."},{"id":1416,"pagetitle":"Tutorial","title":"Getting Earth Orientation Data","ref":"/previews/PR43/EarthOrientation/stable/tutorial/#Getting-Earth-Orientation-Data","content":" Getting Earth Orientation Data When the package is imported for the first time the required data will be automatically downloaded from the IERS servers. After that the data needs to be updated manually like shown below. using EarthOrientation\nEarthOrientation.update()"},{"id":1417,"pagetitle":"Tutorial","title":"Loading Earth Orientation Data","ref":"/previews/PR43/EarthOrientation/stable/tutorial/#Loading-Earth-Orientation-Data","content":" Loading Earth Orientation Data The downloaded data is parsed into an  EOParams  object: eop = EOParams() By default the files downloaded by  EarthOrientation.update()  will be used. It is also possible to manually pass the required  finals.all  and  finals2000A.all  files in CSV format. eop = EOParams(\"finals.csv\", \"finals2000A.csv\") This is useful if the data should not be managed by  EarthOrientation.jl  but by a different system instead."},{"id":1418,"pagetitle":"Tutorial","title":"Interpolating Earth Orientation Data","ref":"/previews/PR43/EarthOrientation/stable/tutorial/#Interpolating-Earth-Orientation-Data","content":" Interpolating Earth Orientation Data Get the current Earth orientation parameters, e.g. for polar motion: xp, yp = polarmotion(eop, now()) # arcseconds Or the current difference between UT1 and UTC and the associated prediction error: ΔUT1 = getΔUT1(eop, now()) # seconds\nΔUT1_err = getΔUT1_err(eop, now()) # milliseconds"},{"id":1421,"pagetitle":"Introduction","title":"AstroLib.jl","ref":"/previews/PR43/AstroLib/stable/#AstroLib.jl","content":" AstroLib.jl AstroLib  is a package of small generic routines useful above all in astronomical and astrophysical context, written in  Julia . Included are also translations of some  IDL Astronomy User’s Library  procedures, which are released under terms of  BSD-2-Clause License . AstroLib’s functions are not drop-in replacement of those procedures, Julia standard data types are often used (e.g.,  DateTime  type instead of generic string for dates) and the syntax may slightly differ. An extensive error testing suite ensures old fixed bugs will not be brought back by future changes."},{"id":1422,"pagetitle":"Introduction","title":"Installation","ref":"/previews/PR43/AstroLib/stable/#Installation","content":" Installation AstroLib is available for Julia 1.0 and later versions, and can be installed with  Julia 's built-in package manager. In a Julia session run the commands julia> import Pkg\njulia> Pkg.update()\njulia> Pkg.add(\"AstroLib\") Older versions are also available for Julia 0.4-0.6. Note that, in order to work, a few functions require external files, which are automatically downloaded when building the package. Should these files be missing for some reason, you will be able to load the package but some functions may not work properly. You can manually build the package with julia> Pkg.build(\"AstroLib\")"},{"id":1423,"pagetitle":"Introduction","title":"Usage","ref":"/previews/PR43/AstroLib/stable/#Usage","content":" Usage After installing the package, you can start using AstroLib with using AstroLib Many functions in  AstroLib.jl  are compatible with  Measurements.jl  package, which allows you to define quantities with uncertainty and propagate the error when performing calculations according to  propagation of uncertainty rules . For example: julia> using AstroLib, Measurements\n\njulia> mag2flux(12.54 ± 0.03)\n3.499e-14 ± 9.7e-16"},{"id":1424,"pagetitle":"Introduction","title":"How Can I Help?","ref":"/previews/PR43/AstroLib/stable/#How-Can-I-Help?","content":" How Can I Help? AstroLib.jl  is developed on  GitHub . You can contribute to the project in a number of ways: by translating more routines from IDL Astronomy User’s Library, or providing brand-new functions, or even improving existing ones (make them faster and more precise). Also bug reports are encouraged."},{"id":1425,"pagetitle":"Introduction","title":"License","ref":"/previews/PR43/AstroLib/stable/#License","content":" License The  AstroLib.jl  package is licensed under the MIT “Expat” License. The original author is Mosè Giordano."},{"id":1426,"pagetitle":"Introduction","title":"Notes","ref":"/previews/PR43/AstroLib/stable/#Notes","content":" Notes This project is a work-in-progress, only few procedures have been translated so far. In addition, function syntax may change from time to time. Check  TODO.md  out to see how you can help. Volunteers are welcome!"},{"id":1427,"pagetitle":"Introduction","title":"Documentation","ref":"/previews/PR43/AstroLib/stable/#Documentation","content":" Documentation Every function provided has detailed documentation that can be  accessed  at Julia REPL with julia> ?FunctionName or with julia> @doc FunctionName"},{"id":1428,"pagetitle":"Introduction","title":"Related Projects","ref":"/previews/PR43/AstroLib/stable/#Related-Projects","content":" Related Projects This is not the only effort to bundle astronomical functions written in Julia language. Other packages useful for more specific purposes are available at  JuliaAstro . Because of this, some of IDL AstroLib’s utilities are not provided in  AstroLib.jl  as they are already present in other Julia packages. Here is a list of such utilities: aper , see  Photometry.jl  package asinh , already present in Julia with the same name cirrange , it is equivalent to  mod(x, 360) .  To restrict a number to the   range  [0, 2pi)  use  mod2pi(x) cosmo_param , see  Cosmology.jl  package galage , see  Cosmology.jl  package glactc_pm , see  SkyCoords.jl  package glactc , see  SkyCoords.jl  package jplephinterp , see  JPLEphemeris.jl  package jplephread , see  JPLEphemeris.jl  package jplephtest , see  JPLEphemeris.jl  package lumdist , see  Cosmology.jl  package readcol , use  readdlm , part of Julia  Base.DataFmt  module. This is not a complete replacement for  readcol  but most of the time it does-the-right-thing even without using any option (it automatically identifies string and numerical columns) and you do not need to manually specify a variable for each column In addition, there are similar projects for Python ( Python AstroLib ) and R ( Astronomy Users Library )."},{"id":1431,"pagetitle":"Reference","title":"Reference","ref":"/previews/PR43/AstroLib/stable/ref/#Reference","content":" Reference"},{"id":1432,"pagetitle":"Reference","title":"Data types","ref":"/previews/PR43/AstroLib/stable/ref/#Data-types","content":" Data types"},{"id":1433,"pagetitle":"Reference","title":"Observatory","ref":"/previews/PR43/AstroLib/stable/ref/#Observatory","content":" Observatory AstroLib.jl  defines a new  Observatory  type. This can be used to define a new object holding information about an observing site. It is a  composite type  whose fields are name  ( String  type): the name of the site latitude  ( Float64  type): North-ward latitude of the site in degrees longitude  ( Float64  type): East-ward longitude of the site in degrees altitude  ( Float64  type): altitude of the site in meters tz  ( Float64  type): the number of hours of offset from UTC The type constructor  Observatory  can be used to create a new  Observatory  object. Its syntax is Observatory(name, lat, long, alt, tz) name  should be a string;  lat ,  long , and  tz  should be anything that can be converted to a floating number with  ten  function;  alt  should be a real number. A predefined list of some observing sites is provided with  AstroLib.observatories  constant. It is a dictionary whose keys are the abbreviated names of the observatories. For example, you can access information of the European Southern Observatory with julia> obs = AstroLib.observatories[\"eso\"]\nObservatory: European Southern Observatory\nlatitude:    -29.256666666666668°N\nlongitude:   -70.73°E\naltitude:    2347.0 m\ntime zone:   UTC-4\n\njulia> obs.longitude\n-70.73 You can list all keys of the dictionary with keys(AstroLib.observatories) Feel free to contribute new sites or adjust information of already present ones."},{"id":1434,"pagetitle":"Reference","title":"Planet","ref":"/previews/PR43/AstroLib/stable/ref/#Planet","content":" Planet The package provides  Planet  type to hold information about Solar System planets. Its fields are Designation: name : the name Physical characteristics: radius : mean radius in meters eqradius : equatorial radius in meters polradius : polar radius in meters mass : mass in kilogram Orbital characteristics (epoch J2000): ecc : eccentricity of the orbit axis : semi-major axis of the orbit in meters period : sidereal orbital period in seconds The constructor has this syntax: Planet(name, radius, eqradius, polradius, mass, ecc, axis, period) The list of Solar System planets, from Mercury to Pluto, is available with  AstroLib.planets  dictionary. The keys of this dictionary are the lowercase names of the planets. For example: julia> AstroLib.planets[\"mercury\"]\nPlanet:                      Mercury\nmean radius:                 2.4397e6 m\nequatorial radius:           2.4397e6 m\npolar radius:                2.4397e6 m\nmass:                        3.3011e23 kg\neccentricity:                0.20563593\nsemi-major axis:             5.790922654152439e10 m\nperiod:                      7.60053024e6 s\ninclination:                 7.00497902 °\nlongitude of ascending node: 48.33076593 °\nlongitude of perihelion:     77.45779628 °\nmean longitude:              252.2503235 °\n\njulia> AstroLib.planets[\"mars\"].eqradius\n3.3962e6\n\njulia> AstroLib.planets[\"saturn\"].mass\n5.6834e26"},{"id":1435,"pagetitle":"Reference","title":"Functions organized by category","ref":"/previews/PR43/AstroLib/stable/ref/#Functions-organized-by-category","content":" Functions organized by category"},{"id":1436,"pagetitle":"Reference","title":"Coordinates and positions","ref":"/previews/PR43/AstroLib/stable/ref/#Coordinates-and-positions","content":" Coordinates and positions adstring() aitoff() altaz2hadec() baryvel() bprecess() co_aberration() co_nutate() co_refract() eci2geo() eq2hor() eqpole() euler() gcirc() geo2eci() geo2geodetic() geo2mag() geodetic2geo() hadec2altaz() helio_rv() helio() hor2eq() jprecess() mag2geo() mean_obliquity() planet_coords() polrec() posang() precess() precess_cd() precess_xyz() premat() radec() recpol() true_obliquity() zenpos()"},{"id":1437,"pagetitle":"Reference","title":"Time and date","ref":"/previews/PR43/AstroLib/stable/ref/#Time-and-date","content":" Time and date ct2lst() daycnv() get_date() get_juldate() helio_jd() jdcnv() juldate() month_cnv() nutate() ydn2md() ymd2dn()"},{"id":1438,"pagetitle":"Reference","title":"Moon and sun","ref":"/previews/PR43/AstroLib/stable/ref/#Moon-and-sun","content":" Moon and sun moonpos() mphase() sunpos() xyz()"},{"id":1439,"pagetitle":"Reference","title":"Utilities","ref":"/previews/PR43/AstroLib/stable/ref/#Utilities","content":" Utilities airtovac() calz_unred() deredd() flux2mag() gal_uvw() imf() ismeuv() kepler_solver() lsf_rotate() mag2flux() paczynski() planck_freq() planck_wave() rad2sec() rhotheta() sec2rad() sixty() sphdist() ten() tic_one() ticpos() tics() trueanom() uvbybeta() vactoair()"},{"id":1440,"pagetitle":"Reference","title":"Miscellaneous (non-astronomy) functions","ref":"/previews/PR43/AstroLib/stable/ref/#Miscellaneous-(non-astronomy)-functions","content":" Miscellaneous (non-astronomy) functions ordinal()"},{"id":1441,"pagetitle":"Reference","title":"Types and functions organized alphabetically","ref":"/previews/PR43/AstroLib/stable/ref/#Types-and-functions-organized-alphabetically","content":" Types and functions organized alphabetically"},{"id":1442,"pagetitle":"Reference","title":"AstroLib.POLELATLONG","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.POLELATLONG","content":" AstroLib.POLELATLONG  —  Constant List of locations of North Magnetic Pole since 1590. This is provided by World Magnetic Model (https://www.ngdc.noaa.gov/geomag/data/poles/NP.xy). source"},{"id":1443,"pagetitle":"Reference","title":"AstroLib.observatories","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.observatories","content":" AstroLib.observatories  —  Constant List of observing sites.  The observatories have  Observatory  type. source"},{"id":1444,"pagetitle":"Reference","title":"AstroLib.planets","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.planets","content":" AstroLib.planets  —  Constant List of planets of the Solar System, from Mercury to Pluto.  The elements of the list have  Planet  type. Reference for most quantities is the Planetary Fact Sheet: http://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html and the Keplerian Elements for Approximate Positions of the Major Planets: https://ssd.jpl.nasa.gov/txt/p elem t1.txt source"},{"id":1445,"pagetitle":"Reference","title":"AstroLib.Observatory","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.Observatory","content":" AstroLib.Observatory  —  Type Type holding information about an observing site.  Its fields are: name : the name of the site latitude : North-ward latitude of the site in degrees longitude : East-ward longitude of the site in degrees altitude : altitude of the site in meters tz : the number of hours of offset from UTC source"},{"id":1446,"pagetitle":"Reference","title":"AstroLib.Planet","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.Planet","content":" AstroLib.Planet  —  Type Type holding information about a planet.  Its fields are: Designation: name : the name Physical characteristics: radius : mean radius in meters eqradius : equatorial radius in meters polradius : polar radius in meters mass : mass in kilogram Orbital characteristics (epoch J2000): ecc : eccentricity of the orbit axis : semi-major axis of the orbit in meters period : sidereal orbital period in seconds Position characteristics (epoch J2000): inc : inclination in degrees asc_long : longitude of the ascending node in degrees per_long : longitude of perihelion in degrees mean_long : mean longitude in degrees source"},{"id":1447,"pagetitle":"Reference","title":"AstroLib.adstring","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.adstring-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractFloat","content":" AstroLib.adstring  —  Method adstring(ra::Real, dec::Real[, precision::Int=2, truncate::Bool=true]) -> string\nadstring([ra, dec]) -> string\nadstring(dec) -> string\nadstring([ra], [dec]) -> [\"string1\", \"string2\", ...] Purpose Returns right ascension and declination as string(s) in sexagesimal format. Explanation Takes right ascension and declination expressed in decimal format, converts them to sexagesimal and return a formatted string.  The precision of right ascension and declination can be specified. Arguments Arguments of this function are: ra : right ascension in decimal degrees.  It is converted to hours before printing. dec : declination in decimal degrees. The function can be called in different ways: Two numeric arguments: first is  ra , the second is  dec . An iterable (array, tuple) of two elements:  (ra, dec) . One numeric argument: it is assumed only  dec  is provided. Optional keywords affecting the output format are always available: precision  (optional integer keyword): specifies the number of digits of declination seconds.  The number of digits for right ascension seconds is always assumed to be one more  precision .  If the function is called with only  dec  as input,  precision  default to 1, in any other case defaults to 0. truncate  (optional boolean keyword): if true, then the last displayed digit in the output is truncated in precision rather than rounded.  This option is useful if  adstring  is used to form an official IAU name (see http://vizier.u-strasbg.fr/Dic/iau-spec.htx) with coordinate specification. Output The function returns one string.  The format of strings can be specified with  precision  and  truncate  keywords, see above. Example julia> using AstroLib\n\njulia> adstring(30.4, -1.23, truncate=true)\n\" 02 01 35.9  -01 13 48\"\n\njulia> adstring.([30.4, -15.63], [-1.23, 48.41], precision=1)\n2-element Vector{String}:\n \" 02 01 36.00  -01 13 48.0\"\n \" 22 57 28.80  +48 24 36.0\" source"},{"id":1448,"pagetitle":"Reference","title":"AstroLib.airtovac","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.airtovac-Tuple{Real}","content":" AstroLib.airtovac  —  Method airtovac(wave_air) -> wave_vacuum Purpose Converts air wavelengths to vacuum wavelengths. Explanation Wavelengths are corrected for the index of refraction of air under standard conditions. Wavelength values below  $2000 Å$  will  not  be altered, take care within  $[1 Å, 2000 Å]$ .  Uses relation of Ciddor (1996). Arguments wave_air : the wavelength in air. Output Vacuum wavelength in angstroms. Method Uses relation of Ciddor (1996), Applied Optics 62, 958. Example If the air wavelength is  w = 6056.125  (a Krypton line), then  airtovac(w)  yields a vacuum wavelength of  6057.8019 . julia> using AstroLib\n\njulia> airtovac(6056.125)\n6057.801930991426 Notes vactoair  converts vacuum wavelengths to air wavelengths. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1449,"pagetitle":"Reference","title":"AstroLib.aitoff","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.aitoff-Tuple{Real, Real}","content":" AstroLib.aitoff  —  Method aitoff(l, b) -> x, y Purpose Convert longitude  l  and latitude  b  to  (x, y)  using an Aitoff projection. Explanation This function can be used to create an all-sky map in Galactic coordinates with an equal-area Aitoff projection.  Output map coordinates are zero longitude centered. Arguments l : longitude, scalar or vector, in degrees. b : latitude, number of elements as  l , in degrees. Coordinates can be given also as a 2-tuple  (l, b) . Output 2-tuple  (x, y) . x : x coordinate, same number of elements as  l .   x  is normalized to be in  $[-180, 180]$ . y : y coordinate, same number of elements as  l .   y  is normalized to be in  $[-90, 90]$ . Example Get  $(x ,y)$  Aitoff coordinates of Sirius, whose Galactic coordinates are  $(227.23, -8.890)$ . julia> using AstroLib\n\njulia> x, y = aitoff(227.23, -8.890)\n(-137.92196683723276, -11.772527357473054) Notes See  AIPS memo No. 46 , page 4, for details of the algorithm.  This version of  aitoff  assumes the projection is centered at  b=0  degrees. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1450,"pagetitle":"Reference","title":"AstroLib.altaz2hadec","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.altaz2hadec-Tuple{Real, Real, Real}","content":" AstroLib.altaz2hadec  —  Method altaz2hadec(alt, az, lat) -> ha, dec Purpose Convert Horizon (Alt-Az) coordinates to Hour Angle and Declination. Explanation Can deal with the NCP singularity.  Intended mainly to be used by program  hor2eq . Arguments Input coordinates may be either a scalar or an array, of the same dimension. alt : local apparent altitude, in degrees, scalar or array. az : the local apparent azimuth, in degrees, scalar or vector, measured  east  of  north !!!  If you have measured azimuth west-of-south (like the book Meeus does), convert it to east of north via:  az = (az + 180) % 360 . lat : the local geodetic latitude, in degrees, scalar or array. alt  and  az  can be given as a 2-tuple  (alt, az) . Output 2-tuple  (ha, dec) ha : the local apparent hour angle, in degrees.  The hour angle is the time that right ascension of 0 hours crosses the local meridian.  It is unambiguously defined. dec : the local apparent declination, in degrees. The output coordinates are always floating points and have the same type (scalar or array) as the input coordinates. Example Arcturus is observed at an apparent altitude of 59d,05m,10s and an azimuth (measured east of north) of 133d,18m,29s while at the latitude of +43.07833 degrees.  What are the local hour angle and declination of this object? julia> using AstroLib\n\njulia> ha, dec = altaz2hadec(ten(59,05,10), ten(133,18,29), 43.07833)\n(336.6828582472844, 19.182450965120402) The widely available XEPHEM code gets: Hour Angle = 336.683\nDeclination = 19.1824 Notes hadec2altaz  converts Hour Angle and Declination to Horizon (Alt-Az) coordinates. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1451,"pagetitle":"Reference","title":"AstroLib.baryvel","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.baryvel-Tuple{Real}","content":" AstroLib.baryvel  —  Method baryvel(dje, deq) -> dvelh, dvelb Purpose Calculates heliocentric and barycentric velocity components of Earth. Explanation Baryvel takes into account the Earth-Moon motion, and is useful for radial velocity work to an accuracy of ~1 m/s. Arguments dje : julian ephemeris date deq  (optional): epoch of mean equinox of  dvelh  and  dvelb . If  deq  is not provided, then it is assumed to be equal to  dje . Output dvelh : heliocentric velocity component. in km/s dvelb : barycentric velocity component. in km/s Example Compute the radial velocity of the Earth toward Altair on 15-Feb-1994 using both the original Stumpf algorithm. julia> using AstroLib\n\njulia> jd = jdcnv(1994, 2, 15, 0)\n2.4493985e6\n\njulia> baryvel(jd, 2000)\n([-17.0724258266945, -22.81120895274765, -9.889315408506354], [-17.080834081384847, -22.80470807516409, -9.886258269159352]) Notes The 3-vectors outputs  dvelh  and  dvelb  are given in a right-handed coordinate system with the +X axis toward the Vernal Equinox, and +Z axis toward the celestial pole. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1452,"pagetitle":"Reference","title":"AstroLib.bprecess","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.bprecess","content":" AstroLib.bprecess  —  Function bprecess(ra, dec[, epoch]) -> ra1950, dec1950\nbprecess(ra, dec, muradec[, parallax=parallax, radvel=radvel]) -> ra1950, dec1950 Purpose Precess positions from J2000.0 (FK5) to B1950.0 (FK4). Explanation Calculates the mean place of a star at B1950.0 on the FK4 system from the mean place at J2000.0 on the FK5 system. bprecess  function has two methods, one for each of the following cases: the proper motion is known and non-zero the proper motion is unknown or known to be exactly zero (i.e. extragalactic radio sources).  Better precision can be achieved in this case by inputting the epoch of the original observations. Arguments The function has 2 methods.  The common mandatory arguments are: ra : input J2000 right ascension, in degrees. dec : input J2000 declination, in degrees. The two methods have a different third argument (see \"Explanation\" section for more details).  It can be one of the following: muradec : 2-element vector containing the proper motion in seconds of arc per tropical  century  in right ascension and declination. epoch : scalar giving epoch of original observations. If none of these two arguments is provided (so  bprecess  is fed only with right ascension and declination), it is assumed that proper motion is exactly zero and  epoch = 2000 . If it is used the method involving  muradec  argument, the following keywords are available: parallax  (optional numerical keyword): stellar parallax, in seconds of arc. radvel  (optional numerical keyword): radial velocity in km/s. Right ascension and declination can be passed as the 2-tuple  (ra, dec) .  You can also pass  ra ,  dec ,  parallax , and  radvel  as arrays, all of the same length N.  In that case,  muradec  should be a matrix 2×N. Output The 2-tuple of right ascension and declination in 1950, in degrees, of input coordinates is returned.  If  ra  and  dec  (and other possible optional arguments) are arrays, the 2-tuple of arrays  (ra1950, dec1950)  of the same length as the input coordinates is returned. Method The algorithm is taken from the Explanatory Supplement to the Astronomical Almanac 1992, page 186.  See also Aoki et al (1983), A&A, 128, 263.  URL: http://adsabs.harvard.edu/abs/1983A%26A...128..263A. Example The SAO2000 catalogue gives the J2000 position and proper motion for the star HD 119288.  Find the B1950 position. RA(2000) = 13h 42m 12.740s Dec(2000) = 8d 23' 17.69'' Mu(RA) = -.0257 s/yr Mu(Dec) = -.090 ''/yr julia> using AstroLib\n\njulia> muradec = 100*[-15*0.0257, -0.090]; # convert to century proper motion\n\njulia> ra = ten(13, 42, 12.74)*15;\n\njulia> decl = ten(8, 23, 17.69);\n\njulia> adstring(bprecess(ra, decl, muradec), precision=2)\n\" 13 39 44.526  +08 38 28.63\" Notes \"When transferring individual observations, as opposed to catalog mean place, the safest method is to transform the observations back to the epoch of the observation, on the FK4 system (or in the system that was used to to produce the observed mean place), convert to the FK5 system, and transform to the the epoch and equinox of J2000.0\" – from the Explanatory Supplement (1992), p. 180 jprecess  performs the precession to J2000 coordinates. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1453,"pagetitle":"Reference","title":"AstroLib.calz_unred","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.calz_unred","content":" AstroLib.calz_unred  —  Function calz_unred(wave, flux, ebv[, r_v]) -> deredden_wave Purpose Deredden a galaxy spectrum using the Calzetti et al. (2000) recipe. Explanation Calzetti et al.  (2000, ApJ 533, 682; http://adsabs.harvard.edu/abs/2000ApJ...533..682C) developed a recipe for dereddening the spectra of galaxies where massive stars dominate the radiation output, valid between  $0.12$  to  $2.2$  microns.  ( calz_unred  extrapolates between  $0.12$  and  $0.0912$  microns.) Arguments wave : wavelength (Angstroms) flux : calibrated flux. ebv : color excess E(B-V).  If a negative  ebv  is supplied, then fluxes will be reddened rather than deredenned.  Note that the supplied color excess should be that derived for the stellar continuum, EBV(stars), which is related to the reddening derived from the gas, EBV(gas), via the Balmer decrement by EBV(stars) = 0.44*EBV(gas). r_v  (optional): ratio of total to selective extinction, default is 4.05.  Calzetti et al. (2000) estimate  $r_v = 4.05 ± 0.80$  from optical-IR observations of 4 starbursts. Output Unreddened flux, same units as  flux .  Flux values will be left unchanged outside valid domain ( $0.0912$  -  $2.2$  microns). Example Estimate how a flat galaxy spectrum (in wavelength) between  $1200 Å$  and  $3200 Å$  is altered by a reddening of E(B-V) = 0.1. wave = collect(1200:50:3150);\nflux = ones(size(wave));\nflux_new = calz_unred.(wave, flux, -0.1); Using a plotting tool you can visualize the unreddend flux.  For example, with  Plots.jl using Plots\nplot(wave, flux_new) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1454,"pagetitle":"Reference","title":"AstroLib.co_aberration","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.co_aberration","content":" AstroLib.co_aberration  —  Function co_aberration(jd, ra, dec[, eps=NaN]) -> d_ra, d_dec Purpose Calculate changes to right ascension and declination due to the effect of annual aberration Explanation With reference to Meeus, Chapter 23 Arguments jd : julian date, scalar or vector ra : right ascension in degrees, scalar or vector dec : declination in degrees, scalar or vector eps  (optional): true obliquity of the ecliptic (in radians). It will be calculated if no argument is specified. Output The 2-tuple  (d_ra, d_dec) : d_ra : correction to right ascension due to aberration, in arc seconds d_dec : correction to declination due to aberration, in arc seconds Example Compute the change in RA and Dec of Theta Persei (RA = 2h46m,11.331s, Dec = 49d20',54.5'') due to aberration on 2028 Nov 13.19 TD julia> using AstroLib\n\njulia> jd = jdcnv(2028,11,13,4, 56)\n2.4620887055555554e6\n\njulia> co_aberration(jd,ten(2,46,11.331)*15,ten(49,20,54.54))\n(30.04404628365077, 6.699400463119431) d_ra = 30.04404628365103'' (≈ 2.003s) d_dec = 6.699400463118504'' Notes Code of this function is based on IDL Astronomy User's Library. The output d ra is  not  multiplied by cos(dec), so that apparent ra = ra + d_ra/3600. These formula are from Meeus, Chapters 23.  Accuracy is much better than 1 arcsecond. The maximum deviation due to annual aberration is 20.49'' and occurs when the Earth's velocity is perpendicular to the direction of the star. This function calls  true_obliquity  and  sunpos . source"},{"id":1455,"pagetitle":"Reference","title":"AstroLib.co_nutate","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.co_nutate-Tuple{Real, Real, Real}","content":" AstroLib.co_nutate  —  Method co_nutate(jd, ra, dec) -> d_ra, d_dec, eps, d_psi, d_eps Purpose Calculate changes in RA and Dec due to nutation of the Earth's rotation Explanation Calculates necessary changes to ra and dec due to the nutation of the Earth's rotation axis, as described in Meeus, Chap 23. Uses formulae from Astronomical Almanac, 1984, and does the calculations in equatorial rectangular coordinates to avoid singularities at the celestial poles. Arguments jd : julian date, scalar or vector ra : right ascension in degrees, scalar or vector dec : declination in degrees, scalar or vector Output The 5-tuple  (d_ra, d_dec, eps, d_psi, d_eps) : d_ra : correction to right ascension due to nutation, in degrees d_dec : correction to declination due to nutation, in degrees eps : the true obliquity of the ecliptic d_psi : nutation in the longitude of the ecliptic d_eps : nutation in the obliquity of the ecliptic Example Example 23a in Meeus: On 2028 Nov 13.19 TD the mean position of Theta Persei is 2h 46m 11.331s 49d 20' 54.54''. Determine the shift in position due to the Earth's nutation. julia> using AstroLib\n\njulia> jd = jdcnv(2028,11,13,4,56)\n2.4620887055555554e6\n\njulia> co_nutate(jd,ten(2,46,11.331) * 15,ten(49,20,54.54))\n(0.004400660977140092, 0.00172668646508356, 0.40904016038217555, 14.859389427896472, 2.703809037235057) Notes Code of this function is based on IDL Astronomy User's Library. The output of  d_ra  and  d_dec  in IDL AstroLib is in arcseconds, however it is in degrees here. This function calls  mean_obliquity  and  nutate . source"},{"id":1456,"pagetitle":"Reference","title":"AstroLib.co_refract","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.co_refract","content":" AstroLib.co_refract  —  Function co_refract(old_alt[, altitude=0, pressure=NaN, temperature=NaN,\n           epsilon=0.25, to_observe=false]) -> aout Purpose Calculate correction to altitude due to atmospheric refraction. Explanation Because the index of refraction of air is not precisely 1.0, the atmosphere bends all incoming light, making a star or other celestial object appear at a slightly different altitude (or elevation) than it really is.  It is important to understand the following definitions: Observed Altitude: The altitude that a star is seen to be, with a telescope. This is where it appears in the sky. This is should be always greater than the apparent altitude. Apparent Altitude: The altitude that a star would be at, if ~there were no atmosphere~ (sometimes called the \"true\" altitude). This is usually calculated from an object's celestial coordinates. Apparent altitude should always be smaller than the observed altitude. Thus, for example, the Sun's apparent altitude when you see it right on the horizon is actually -34 arcminutes. This program uses a couple of simple formulae to estimate the effect for most optical and radio wavelengths. Typically, you know your observed altitude (from an observation), and want the apparent altitude. To go the other way, this program uses an iterative approach. Arguments old_alt : observed altitude in degrees. If  to_observe  is set to true, this should be apparent altitude altitude  (optional): the height of the observing location, in meters. This is only used to determine an approximate temperature and pressure, if these are not specified separately. Default is 0 i.e. sea level pressure  (optional): the pressure at the observing location, in millibars. Default is NaN temperature  (optional): the temperature at the observing location, in Kelvins. Default is NaN epsilon  (optional): the accuracy to obtain, in arcseconds. If  to_observe  is true, then it will be calculated. Default is 0.25 arcseconds to_observe  (optional boolean keyword): if set to true, it is assumed that  old_alt  has apparent altitude as its input and the observed altitude will be found Output aout : apparent altitude, in degrees. Observed altitude is returned if  to_observe  is set to true Example The lower limb of the Sun is observed to have altitude of 0d 30'. Calculate the the true (i.e. apparent) altitude of the Sun's lower limb using mean  conditions of air pressure and temperature. julia> using AstroLib\n\njulia> co_refract(0.5)\n0.02584736873098442 Notes If altitude is set but the temperature or pressure is not, the program will make an intelligent guess for the temperature and pressure. Wavelength Dependence This correction is 0 at zenith, about 1 arcminute at 45 degrees, and 34 arcminutes at the horizon for optical wavelengths. The correction is non-negligible at all wavelengths, but is not very easily calculable. These formulae assume a wavelength of 550 nm, and will be accurate to about 4 arcseconds for all visible wavelengths, for elevations of 10 degrees and higher. Amazingly, they are also accurate for radio frequencies less than ~ 100 GHz. References Meeus, Astronomical Algorithms, Chapter 15. Explanatory Supplement to the Astronomical Almanac, 1992. Methods of Experimental Physics, Vol 12 Part B, Astrophysics, Radio Telescopes, Chapter 2.5, \"Refraction Effects in the Neutral Atmosphere\", by R.K. Crane. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1457,"pagetitle":"Reference","title":"AstroLib.co_refract_forward","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.co_refract_forward-Tuple{Real, Real, Real}","content":" AstroLib.co_refract_forward  —  Method co_refract_forward(alt, pre, temp) -> ref Purpose A function used by  co_refract  to find apparent (or observed) altitude Arguments alt : the observed (or apparent) altitude, in degrees pre : pressure, in millibars temp : temperature, in Kelvins Output ref : the atmospheric refraction, in minutes of arc Notes The atmospheric refraction is calculated by Saemundsson's formula Code of this function is based on IDL Astronomy User's Library. source"},{"id":1458,"pagetitle":"Reference","title":"AstroLib.ct2lst","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.ct2lst","content":" AstroLib.ct2lst  —  Function ct2lst(longitude, jd) -> local_sidereal_time\nct2lst(longitude, tz, date) -> local_sidereal_time Purpose Convert from Local Civil Time to Local Mean Sidereal Time. Arguments The function can be called in two different ways.  The only argument common to both methods is  longitude : longitude : the longitude in degrees (east of Greenwich) of the place for which the local sidereal time is desired.  The Greenwich mean sidereal time (GMST) can be found by setting longitude =  0 . The civil date to be converted to mean sidereal time can be specified either by providing the Julian days: jd : this is number of Julian days for the date to be converted. or the time zone and the date: tz : the time zone of the site in hours, positive East of the Greenwich meridian (ahead of GMT).  Use this parameter to easily account for Daylight Savings time (e.g. -4=EDT, -5 = EST/CDT). date : this is the local civil time with type  DateTime . Output The local sidereal time for the date/time specified in hours. Method The Julian days of the day and time is question is used to determine the number of days to have passed since 2000-01-01.  This is used in conjunction with the GST of that date to extrapolate to the current GST; this is then used to get the LST.  See Astronomical Algorithms by Jean Meeus, p. 84 (Eq. 11-4) for the constants used. Example Find the Greenwich mean sidereal time (GMST) on 2008-07-30 at 15:53 in Baltimore, Maryland (longitude=-76.72 degrees).  The timezone is EDT or tz=-4 julia> using AstroLib, Dates\n\njulia> lst = ct2lst(-76.72, -4, DateTime(2008, 7, 30, 15, 53))\n11.356505172312609\n\njulia> sixty(lst)\n3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):\n 11.0\n 21.0\n 23.418620325392112 Find the Greenwich mean sidereal time (GMST) on 2015-11-24 at 13:21 in Heidelberg, Germany (longitude=08° 43' E).  The timezone is CET or tz=1. Provide  ct2lst  only with the longitude of the place and the number of Julian days. julia> using AstroLib, Dates\n\njulia> longitude = ten(8, 43); # Convert longitude to decimals.\n\njulia> # Get number of Julian days. Remember to subtract the time zone in\n       # order to convert local time to UTC.\n\njulia> jd = jdcnv(DateTime(2015, 11, 24, 13, 21) - Dates.Hour(1));\n\njulia> lst = ct2lst(longitude, jd) # Calculate Greenwich Mean Sidereal Time.\n17.140685171005316\n\njulia> sixty(lst)\n3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):\n 17.0\n  8.0\n 26.466615619137883 Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1459,"pagetitle":"Reference","title":"AstroLib.daycnv","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.daycnv","content":" AstroLib.daycnv  —  Function daycnv(julian_days) -> DateTime Purpose Converts Julian days number to Gregorian calendar dates. Explanation Takes the number of Julian calendar days since epoch  -4713-11-24T12:00:00  and returns the corresponding proleptic Gregorian Calendar date. Argument julian_days : Julian days number. Output Proleptic Gregorian Calendar date, of type  DateTime , corresponding to the given Julian days number. Example julia> using AstroLib\n\njulia> daycnv(2440000)\n1968-05-23T12:00:00 Notes jdcnv  is the inverse of this function. source"},{"id":1460,"pagetitle":"Reference","title":"AstroLib.deredd","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.deredd-NTuple{5, Real}","content":" AstroLib.deredd  —  Method deredd(Eby, by, m1, c1, ub) -> by0, m0, c0, ub0 Purpose Deredden stellar Stromgren parameters given for a value of E(b-y) Arguments Eby : color index E(b-y), scalar (E(b-y) = 0.73*E(B-V)) by : b-y color (observed) m1 : Stromgren line blanketing parameter (observed) c1 : Stromgren Balmer discontinuity parameter (observed) ub : u-b color (observed) All arguments can be either scalars or arrays all of the same length. Output The 4-tuple  (by0, m0, c0, ub0) . by0 : b-y color (dereddened) m0 : line blanketing index (dereddened) c0 : Balmer discontinuity parameter (dereddened) ub0 : u-b color (dereddened) These are scalars or arrays of the same length as the input arguments. Example julia> using AstroLib\n\njulia> deredd(0.5, 0.2, 1.0, 1.0, 0.1)\n(-0.3, 1.165, 0.905, -0.665) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1461,"pagetitle":"Reference","title":"AstroLib.eci2geo","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.eci2geo-NTuple{4, Real}","content":" AstroLib.eci2geo  —  Method eci2geo(x, y, z, jd) -> latitude, longitude, altitude Purpose Convert Earth-centered inertial coordinates to geographic spherical coordinates. Explanation Converts from ECI (Earth-Centered Inertial) (x, y, z) rectangular coordinates to geographic spherical coordinates (latitude, longitude, altitude).  Julian day is also needed as input. ECI coordinates are in km from Earth center at the supplied time (True of Date). Geographic coordinates assume the Earth is a perfect sphere, with radius equal to its equatorial radius. Arguments x : ECI x coordinate at  jd , in kilometers. y : ECI y coordinate at  jd , in kilometers. z : ECI z coordinate at  jd , in kilometers. jd : Julian days. The three coordinates can be passed as a 3-tuple  (x, y, z) .  In addition,  x ,  y ,  z , and  jd  can be given as arrays of the same length. Output The 3-tuple of geographical coordinate (latitude, longitude, altitude). latitude : latitude, in degrees. longitude : longitude, in degrees. altitude : altitude, in kilometers. If ECI coordinates are given as arrays, a 3-tuple of arrays of the same length is returned. Example Obtain the geographic direction of the vernal point on 2015-06-30T14:03:12.857, in geographic coordinates, at altitude 600 km.  Note: equatorial radii of Solar System planets in meters are stored into  AstroLib.planets  dictionary. julia> using AstroLib\n\njulia> x = AstroLib.planets[\"earth\"].eqradius*1e-3 + 600;\n\njulia> lat, long, alt = eci2geo(x, 0, 0, jdcnv(\"2015-06-30T14:03:12.857\"))\n(0.0, 230.87301833205856, 600.0) These coordinates can be further transformed into geodetic coordinates using  geo2geodetic  or into geomagnetic coordinates using  geo2mag . Notes geo2eci  converts geographic spherical coordinates to Earth-centered inertial coordinates. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1462,"pagetitle":"Reference","title":"AstroLib.eq2hor","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.eq2hor","content":" AstroLib.eq2hor  —  Function eq2hor(ra, dec, jd[, obsname; ws=false, B1950=false, precession=true, nutate=true,\n       aberration=true, refract=true, pressure=NaN, temperature=NaN]) -> alt, az, ha\n\neq2hor(ra, dec, jd, lat, lon[, altitude=0; ws=false, B1950=false,\n       precession=true, nutate=true, aberration=true, refract=true,\n       pressure=NaN, temperature=NaN]) -> alt, az, ha Purpose Convert celestial  (ra-dec) coords to local horizon coords (alt-az). Explanation This code calculates horizon (alt,az) coordinates from equatorial (ra,dec) coords. It performs precession, nutation, aberration, and refraction corrections. Arguments This function has two base methods.  With one you can specify the name of the observatory, if present in  AstroLib.observatories , with the other one you can provide the coordinates of the observing site and, optionally, the altitude. Common mandatory arguments: ra : right ascension of object, in degrees dec : declination of object, in degrees jd : julian date Other positional arguments: obsname : set this to a valid observatory name in  AstroLib.observatories . or lat : north geodetic latitude of location, in degrees. lon : AST longitude of location, in degrees. You can specify west longitude with a negative sign. altitude : the altitude of the observing location, in meters.  It is  0  by default Optional keyword arguments: ws  (optional boolean keyword): set this to  true  to get the azimuth measured westward from south (not East of North) B1950  (optional boolean keyword): set this to  true  if the ra and dec are specified in B1950 (FK4 coordinates) instead of J2000 (FK5). This is  false  by default precession  (optional boolean keyword): set this to  false  for no precession correction,  true  by default nutate  (optional boolean keyword): set this to  false  for no nutation,  true  by default aberration  (optional boolean keyword): set this to  false  for no aberration correction,  true  by default refract  (optional boolean keyword): set this to  false  for no refraction correction,  true  by default pressure  (optional keyword): the pressure at the observing location, in millibars. Default value is  NaN temperature  (optional keyword): the temperature at the observing location, in Kelvins. Default value is  NaN Output alt : altitude of horizon coords, in degrees az : azimuth angle measured East from North (unless ws is  true ), in degrees ha : hour angle, in degrees Example julia> using AstroLib\n\njulia> alt_o, az_o = eq2hor(ten(6,40,58.2)*15, ten(9,53,44), 2460107.25, ten(50,31,36),\n                            ten(6,51,18), 369, pressure = 980, temperature=283)\n(16.423991509721567, 265.60656932130564, 76.11502253130612)\n\njulia> adstring(az_o, alt_o)\n\" 17 42 25.6  +16 25 26\" Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1463,"pagetitle":"Reference","title":"AstroLib.eqpole","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.eqpole-Tuple{Real, Real}","content":" AstroLib.eqpole  —  Method eqpole(l, b[; southpole = false]) -> x, y Purpose Convert right ascension  $l$  and declination  $b$  to coordinate  $(x, y)$  using an equal-area polar projection. Explanation The output  $x$  and  $y$  coordinates are scaled to be in the range  $[-90, 90]$  and to go from equator to pole to equator.  Output map points can be centered on the north pole or south pole. Arguments l : longitude, scalar or vector, in degrees b : latitude, same number of elements as right ascension, in degrees southpole  (optional boolean keyword): keyword to indicate that the plot is to be centered on the south pole instead of the north pole.  Default is  false . Output The 2-tuple  $(x, y)$ : $x$  coordinate, same number of elements as right ascension, normalized to be in the range  $[-90, 90]$ . $y$  coordinate, same number of elements as declination, normalized to be in the range  $[-90, 90]$ . Example julia> using AstroLib\n\njulia> eqpole(100, 35, southpole=true)\n(-111.18287262822456, -19.604540237028665)\n\njulia> eqpole(80, 19)\n(72.78853915267848, 12.83458333897169) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1464,"pagetitle":"Reference","title":"AstroLib.euler","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.euler-Tuple{Real, Real, Integer}","content":" AstroLib.euler  —  Method euler(ai, bi, select[, FK4=true, radians=true]) Purpose Transform between Galactic, celestial, and ecliptic coordinates. Explanation The function is used by the astro procedure. Arguments ai : input longitude, scalar or vector. bi : input latitude, scalar or vector. select  : integer input specifying type of coordinate transformation. SELECT   From          To     | SELECT   From       To    1   RA-Dec (2000) Galactic |   4    Ecliptic   RA-Dec    2   Galactic      RA-DEC   |   5    Ecliptic   Galactic    3   RA-Dec        Ecliptic |   6    Galactic   Ecliptic FK4  (optional boolean keyword) : if this keyword is set to  true , then input and output celestial and ecliptic coordinates should be given in equinox B1950. When  false , by default, they should be given in equinox J2000. radians  (optional boolean keyword) : if this keyword is set to  true , all input and output angles are in radians rather than degrees. Output a 2-tuple  (ao, bo) : ao : output longitude in degrees. bo : output latitude in degrees. Example Find the Galactic coordinates of Cyg X-1 (ra=299.590315, dec=35.201604) julia> using AstroLib\n\njulia> euler(299.590315, 35.201604, 1)\n(71.33498957116959, 3.0668335310640984) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1465,"pagetitle":"Reference","title":"AstroLib.flux2mag","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.flux2mag","content":" AstroLib.flux2mag  —  Function flux2mag(flux[, zero_point, ABwave=number]) -> magnitude Purpose Convert from flux expressed in erg/(s cm² Å) to magnitudes. Explanation This is the reverse of  mag2flux . Arguments flux : the flux to be converted in magnitude, expressed in erg/(s cm² Å). zero_point : the zero point level of the magnitude.  If not supplied then defaults to 21.1 (Code et al 1976).  Ignored if the  ABwave  keyword is supplied ABwave  (optional numeric keyword): wavelength in Angstroms. If supplied, then returns Oke AB magnitudes (Oke & Gunn 1983, ApJ, 266, 713; http://adsabs.harvard.edu/abs/1983ApJ...266..713O). Output The magnitude. If the  ABwave  keyword is set then magnitude is given by the expression \\[\\text{ABmag} = -2.5\\log_{10}(f) - 5\\log_{10}(\\text{ABwave}) - 2.406\\] Otherwise, magnitude is given by the expression \\[\\text{mag} = -2.5\\log_{10}(\\text{flux}) - \\text{zero point}\\] Example julia> using AstroLib\n\njulia> flux2mag(5.2e-15)\n14.609991640913002\n\njulia> flux2mag(5.2e-15, 15)\n20.709991640913003\n\njulia> flux2mag(5.2e-15, ABwave=15)\n27.423535345634598 Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1466,"pagetitle":"Reference","title":"AstroLib.gal_uvw","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.gal_uvw-NTuple{6, Real}","content":" AstroLib.gal_uvw  —  Method gal_uvw(ra, dec, pmra, pmdec, vrad, plx[, lsr=true]) -> u, v, w Purpose Calculate the Galactic space velocity  $(u, v, w)$  of a star. Explanation Calculates the Galactic space velocity  $(u, v, w)$  of a star given its (1) coordinates, (2) proper motion, (3) parallax, and (4) radial velocity. Arguments User must supply a position, proper motion, radial velocity and parallax. Either scalars or arrays all of the same length can be supplied. Position: ra : right ascension, in degrees dec : declination, in degrees Proper Motion pmra : proper motion in right ascension in arc units (typically milli-arcseconds/yr).  If given  $μ_α$  – proper motion in seconds of time/year – then this is equal to  $15 μ_α \\cos(\\text{dec})$ . pmdec : proper motion in declination (typically mas/yr). Radial Velocity vrad : velocity in km/s Parallax plx : parallax with same distance units as proper motion measurements typically milliarcseconds (mas) If you know the distance in parsecs, then set  plx  to  $1000/\\text{distance}$ , if proper motion measurements are given in milli-arcseconds/yr. There is an additional optional keyword: lsr  (optional boolean keyword): if this keyword is set to  true , then the output velocities will be corrected for the solar motion  $(u, v, w)_⊙ = (-8.5, 13.38, 6.49)$  (Coşkunoǧlu et al. 2011 MNRAS, 412, 1237; DOI: 10.1111/j.1365-2966.2010.17983.x ) to the local standard of rest (LSR).  Note that the value of the solar motion through the LSR remains poorly determined. Output The 3-tuple  $(u, v, w)$ $u$ : velocity (km/s) positive toward the Galactic  anti center $v$ : velocity (km/s) positive in the direction of Galactic rotation $w$ : velocity (km/s) positive toward the North Galactic Pole Method Follows the general outline of Johnson & Soderblom (1987, AJ, 93, 864; DOI: 10.1086/114370 ) except that  $u$  is positive outward toward the Galactic  anti center, and the J2000 transformation matrix to Galactic coordinates is taken from the introduction to the Hipparcos catalog. Example Compute the U,V,W coordinates for the halo star HD 6755.  Use values from Hipparcos catalog, and correct to the LSR. julia> using AstroLib\n\njulia> ra = ten(1,9,42.3)*15.; dec = ten(61,32,49.5);\n\njulia> pmra = 627.89;  pmdec = 77.84; # mas/yr\n\njulia> vrad = -321.4; dis = 129; # distance in parsecs\n\njulia> u, v, w = gal_uvw(ra, dec, pmra, pmdec, vrad, 1e3/dis, lsr=true)\n(118.2110474553902, -466.4828898385057, 88.16573278565097) Notes This function does not take distance as input.  See \"Arguments\" section above for how to provide it using parallax argument. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1467,"pagetitle":"Reference","title":"AstroLib.gcirc","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.gcirc-Tuple{Integer, Vararg{Real, 4}}","content":" AstroLib.gcirc  —  Method gcirc(units, ra1, dec1, ra2, dec2) -> angular_distance Purpose Computes rigorous great circle arc distances. Explanation Input position can be either radians, sexagesimal right ascension and declination, or degrees. Arguments units : integer, can be either 0, or 1, or 2.  Describes units of inputs and output: 0: everything (input right ascensions and declinations, and output distance) is radians 1: right ascensions are in decimal hours, declinations in decimal degrees, output distance in arc seconds 2: right ascensions and declinations are in degrees, output distance in arc seconds ra1 :  right ascension or longitude of point 1 dec1 : declination or latitude of point 1 ra2 : right ascension or longitude of point 2 dec2 : declination or latitude of point 2 Both  ra1  and  dec1 , and  ra2  and  dec2  can be given as 2-tuples  (ra1, dec1)  and  (ra2, dec2) . Output Angular distance on the sky between points 1 and 2, as a  AbstractFloat .  See  units  argument above for the units. Method \"Haversine formula\" see http://en.wikipedia.org/wiki/Great-circle_distance. Example julia> using AstroLib\n\njulia> gcirc(0, 120, -43, 175, +22)\n1.590442261600714 Notes The function  sphdist  provides an alternate method of computing a spherical distance. The Haversine formula can give rounding errors for antipodal points. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1468,"pagetitle":"Reference","title":"AstroLib.geo2eci","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.geo2eci-NTuple{4, Real}","content":" AstroLib.geo2eci  —  Method geo2eci(latitude, longitude, altitude, jd) -> x, y, z Purpose Convert geographic spherical coordinates to Earth-centered inertial coordinates. Explanation Converts from geographic spherical coordinates (latitude, longitude, altitude) to ECI (Earth-Centered Inertial) (x, y, z) rectangular coordinates.  Julian days is also needed. Geographic coordinates assume the Earth is a perfect sphere, with radius equal to its equatorial radius.  ECI coordinates are in km from Earth center at epoch TOD (True of Date). Arguments latitude : geographic latitude, in degrees. longitude : geographic longitude, in degrees. altitude : geographic altitude, in kilometers. jd : Julian days. The three coordinates can be passed as a 3-tuple  (latitude, longitude, altitude) .  In addition,  latitude ,  longitude ,  altitude , and  jd  can be given as arrays of the same length. Output The 3-tuple of ECI (x, y, z) coordinates, in kilometers.  The TOD epoch is the supplied  jd  time. If geographical coordinates are given as arrays, a 3-tuple of arrays of the same length is returned. Example Obtain the ECI coordinates of the intersection of the equator and Greenwich's meridian on 2015-06-30T14:03:12.857 julia> using AstroLib\n\njulia> geo2eci(0, 0, 0, jdcnv(\"2015-06-30T14:03:12.857\"))\n(-4024.8671780315185, 4947.835465127513, 0.0) Notes eci2geo  converts Earth-centered inertial coordinates to geographic spherical coordinates. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1469,"pagetitle":"Reference","title":"AstroLib.geo2geodetic","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.geo2geodetic-NTuple{5, Real}","content":" AstroLib.geo2geodetic  —  Method geo2geodetic(latitude, longitude, altitude) -> latitude, longitude, altitude\ngeo2geodetic(latitude, longitude, altitude, planet) -> latitude, longitude, altitude\ngeo2geodetic(latitude, longitude, altitude, equatorial_radius, polar_radius) -> latitude, longitude, altitude Purpose Convert from geographic (or planetographic) to geodetic coordinates. Explanation Converts from geographic (latitude, longitude, altitude) to geodetic (latitude, longitude, altitude).  In geographic coordinates, the Earth is assumed a perfect sphere with a radius equal to its equatorial radius.  The geodetic (or ellipsoidal) coordinate system takes into account the Earth's oblateness. Geographic and geodetic longitudes are identical.  Geodetic latitude is the angle between local zenith and the equatorial plane.  Geographic and geodetic altitudes are both the closest distance between the satellite and the ground. Arguments The function has two base methods.  The arguments common to all methods and always mandatory are  latitude ,  longitude , and  altitude : latitude : geographic latitude, in degrees. longitude : geographic longitude, in degrees. altitude : geographic altitude, in kilometers. In order to convert to geodetic coordinates, you can either provide custom equatorial and polar radii of the planet or use the values of one of the planets of Solar System (Pluto included). If you want to use the method with explicit equatorial and polar radii the additional mandatory arguments are: equatorial_radius : value of the equatorial radius of the body, in kilometers. polar_radius : value of the polar radius of the body, in kilometers. Instead, if you want to use the method with the selection of a planet, the only additional argument is the planet name: planet  (optional string argument): string with the name of the Solar System planet, from \"Mercury\" to \"Pluto\".  If omitted (so, when only  latitude ,  longitude , and  altitude  are provided), the default is \"Earth\". In all cases, the three coordinates can be passed as a 3-tuple  (latitude, longitude, altitude) .  In addition, geographical  latitude ,  longitude , and  altitude  can be given as arrays of the same length. Output The 3-tuple  (latitude, longitude, altitude)  in geodetic coordinates, for the body with specified equatorial and polar radii (Earth by default). If geographical coordinates are given as arrays, a 3-tuple of arrays of the same length is returned. Method Stephen P.  Keeler and Yves Nievergelt, \"Computing geodetic coordinates\", SIAM Rev. Vol. 40, No. 2, pp. 300-309, June 1998 (DOI: 10.1137/S0036144597323921 ). Planetary constants are from Planetary Fact Sheet (http://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html). Example Locate the Earth geographic North pole (latitude: 90°, longitude: 0°, altitude 0 km), in geodetic coordinates: julia> using AstroLib\n\njulia> geo2geodetic(90, 0, 0)\n(90.0, 0.0, 21.38499999999931) The same for Jupiter: julia> using AstroLib\n\njulia> geo2geodetic(90, 0, 0, \"Jupiter\")\n(90.0, 0.0, 4638.0) Find geodetic coordinates for point of geographic coordinates (latitude, longitude, altitude) = (43.16°, -24.32°, 3.87 km) on a planet with equatorial radius 8724.32 km and polar radius 8619.19 km: julia> using AstroLib\n\njulia> geo2geodetic(43.16, -24.32, 3.87, 8724.32, 8619.19)\n(43.849399515234516, -24.32, 53.53354478670965) Notes Whereas the conversion from geodetic to geographic coordinates is given by an exact, analytical formula, the conversion from geographic to geodetic isn't. Approximative iterations (as used here) exist, but tend to become less good with increasing eccentricity and altitude.  The formula used in this routine should give correct results within six digits for all spatial locations, for an ellipsoid (planet) with an eccentricity similar to or less than Earth's.  More accurate results can be obtained via calculus, needing a non-determined amount of iterations. In any case, the function  geodetic2geo , which converts from geodetic (or planetodetic) to geographic coordinates, can be used to estimate the accuracy of  geo2geodetic . julia> using AstroLib\n\njulia> collect(geodetic2geo(geo2geodetic(67.2, 13.4, 1.2))) - [67.2, 13.4, 1.2]\n3-element Vector{Float64}:\n -3.5672513831741526e-9\n  0.0\n  9.484211194177306e-10 Code of this function is based on IDL Astronomy User's Library. source"},{"id":1470,"pagetitle":"Reference","title":"AstroLib.geo2mag","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.geo2mag","content":" AstroLib.geo2mag  —  Function geo2mag(latitude, longitude[, year]) -> geomagnetic_latitude, geomagnetic_longitude Purpose Convert from geographic to geomagnetic coordinates. Explanation Converts from geographic (latitude, longitude) to geomagnetic (latitude, longitude).  Altitude is not involved in this function. Arguments latitude : geographic latitude (North), in degrees. longitude : geographic longitude (East), in degrees. year  (optional numerical argument): the year in which to perform conversion. If omitted, defaults to current year. The coordinates can be passed as arrays of the same length. Output The 2-tuple of magnetic (latitude, longitude) coordinates, in degrees. If geographical coordinates are given as arrays, a 2-tuple of arrays of the same length is returned. Example Kyoto has geographic coordinates 35° 00' 42'' N, 135° 46' 06'' E, find its geomagnetic coordinates in 2016: julia> using AstroLib\n\njulia> geo2mag(ten(35,0,42), ten(135,46,6), 2016)\n(36.86579228937769, -60.1840605366516) Notes This function uses list of North Magnetic Pole positions provided by World Magnetic Model (https://www.ngdc.noaa.gov/geomag/data/poles/NP.xy). mag2geo  converts geomagnetical coordinates to geographic coordinates. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1471,"pagetitle":"Reference","title":"AstroLib.geodetic2geo","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.geodetic2geo-NTuple{5, Real}","content":" AstroLib.geodetic2geo  —  Method geodetic2geo(latitude, longitude, altitude) -> latitude, longitude, altitude\ngeodetic2geo(latitude, longitude, altitude, planet) -> latitude, longitude, altitude\ngeodetic2geo(latitude, longitude, altitude, equatorial_radius, polar_radius) -> latitude, longitude, altitude Purpose Convert from geodetic (or planetodetic) to geographic coordinates. Explanation Converts from geodetic (latitude, longitude, altitude) to geographic (latitude, longitude, altitude).  In geographic coordinates, the Earth is assumed a perfect sphere with a radius equal to its equatorial radius.  The geodetic (or ellipsoidal) coordinate system takes into account the Earth's oblateness. Geographic and geodetic longitudes are identical.  Geodetic latitude is the angle between local zenith and the equatorial plane.  Geographic and geodetic altitudes are both the closest distance between the satellite and the ground. Arguments The function has two base methods.  The arguments common to all methods and always mandatory are  latitude ,  longitude , and  altitude : latitude : geodetic latitude, in degrees. longitude : geodetic longitude, in degrees. altitude : geodetic altitude, in kilometers. In order to convert to geographic coordinates, you can either provide custom equatorial and polar radii of the planet or use the values of one of the planets of Solar System (Pluto included). If you want to use the method with explicit equatorial and polar radii the additional mandatory arguments are: equatorial_radius : value of the equatorial radius of the body, in kilometers. polar_radius : value of the polar radius of the body, in kilometers. Instead, if you want to use the method with the selection of a planet, the only additional argument is the planet name: planet  (optional string argument): string with the name of the Solar System planet, from \"Mercury\" to \"Pluto\".  If omitted (so, when only  latitude ,  longitude , and  altitude  are provided), the default is \"Earth\". In all cases, the three coordinates can be passed as a 3-tuple  (latitude, longitude, altitude) .  In addition, geodetic  latitude ,  longitude , and  altitude  can be given as arrays of the same length. Output The 3-tuple  (latitude, longitude, altitude)  in geographic coordinates, for the body with specified equatorial and polar radii (Earth by default). If geodetic coordinates are given as arrays, a 3-tuple of arrays of the same length is returned. Method Stephen P.  Keeler and Yves Nievergelt, \"Computing geodetic coordinates\", SIAM Rev. Vol. 40, No. 2, pp. 300-309, June 1998 (DOI: 10.1137/S0036144597323921 ). Planetary constants from \"Allen's Astrophysical Quantities\", Fourth Ed., (2000). Example Find geographic coordinates of geodetic North pole (latitude: 90°, longitude: 0°, altitude 0 km) of the Earth: julia> using AstroLib\n\njulia> geodetic2geo(90, 0, 0)\n(90.0, 0.0, -21.38499999999931) The same for Jupiter: julia> using AstroLib\n\njulia> geodetic2geo(90, 0, 0, \"Jupiter\")\n(90.0, 0.0, -4638.0) Find geographic coordinates for point of geodetic coordinates (latitude, longitude, altitude) = (43.16°, -24.32°, 3.87 km) on a planet with equatorial radius 8724.32 km and polar radius 8619.19 km: julia> using AstroLib\n\njulia> geodetic2geo(43.16, -24.32, 3.87, 8724.32, 8619.19)\n(42.46772711708433, -24.32, -44.52902080669082) Notes geo2geodetic  converts from geographic (or planetographic) to geodetic coordinates. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1472,"pagetitle":"Reference","title":"AstroLib.get_date","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.get_date-Tuple{Dates.DateTime, Bool, Bool}","content":" AstroLib.get_date  —  Method get_date([date, old=true, timetag=true]) -> string Purpose Returns the UTC date in  \"CCYY-MM-DD\"  format for FITS headers. Explanation This is the format required by the  DATE  and  DATE-OBS  keywords in a FITS header. Argument date  (optional): the date in UTC standard.  If omitted, defaults to the current UTC time.  Each element can be either a  DateTime  type or anything that can be converted to that type.  In the case of vectorial input, each element is considered as a date, so you cannot provide a date by parts. old  (optional boolean keyword): see below. timetag  (optional boolean keyword): see below. Output A string with the date formatted according to the given optional keywords. When no optional keywords ( timetag  and  old ) are supplied, the format of the output string is  \"CCYY-MM-DD\"  (year-month-day part of the date), where  CCYY  represents a 4-digit calendar year,  MM  the 2-digit ordinal number of a calendar month within the calendar year, and  DD  the 2-digit ordinal number of a day within the calendar month. If the boolean keyword  old  is true (default: false), the year-month-day part of date has  \"DD/MM/YY\"  format.  This is the formerly (pre-1997) recommended for FITS.  Note that this format is now deprecated because it uses only a 2-digit representation of the year. If the boolean keyword  timetag  is true (default: false),  \"Thh:mm:ss\"  is appended to the year-month-day part of the date, where <hh> represents the hour in the day, <mm> the minutes, <ss> the seconds, and the literal 'T' the ISO 8601 time designator. Note that  old  and  timetag  keywords can be used together, so that the output string will have  \"DD/MM/YYThh:mm:ss\"  format. Example julia> using AstroLib, Dates\n\njulia> get_date(DateTime(21937, 05, 30, 09, 59, 00), timetag=true)\n\"21937-05-30T09:59:00\" Notes A discussion of the DATExxx syntax in FITS headers can be found in http://www.cv.nrao.edu/fits/documents/standards/year2000.txt Those who wish to use need further flexibility in their date formats (e.g. to use TAI time) should look at Bill Thompson's time routines in http://sohowww.nascom.nasa.gov/solarsoft/gen/idl/time source"},{"id":1473,"pagetitle":"Reference","title":"AstroLib.get_juldate","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.get_juldate-Tuple{}","content":" AstroLib.get_juldate  —  Method get_juldate() -> julian_days Purpose Return the number of Julian days for current time. Explanation Return for current time the number of Julian calendar days since epoch  -4713-11-24T12:00:00  as a floating point. Example get_juldate()\ndaycnv(get_juldate()) Notes Use  jdcnv  to get the number of Julian days for a different date. source"},{"id":1474,"pagetitle":"Reference","title":"AstroLib.hadec2altaz","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.hadec2altaz-Tuple{Real, Real, Real}","content":" AstroLib.hadec2altaz  —  Method hadec2altaz(ha, dec, lat[, ws=true]) -> alt, az Purpose Convert Hour Angle and Declination to Horizon (Alt-Az) coordinates. Explanation Can deal with the NCP singularity.  Intended mainly to be used by program  eq2hor . Arguments Input coordinates may be either a scalar or an array, of the same dimension. ha : the local apparent hour angle, in degrees.  The hour angle is the time that right ascension of 0 hours crosses the local meridian.  It is unambiguously defined. dec : the local apparent declination, in degrees. lat : the local geodetic latitude, in degrees, scalar or array. ws  (optional boolean keyword): if true, the output azimuth is measured West from South.  The default is to measure azimuth East from North. ha  and  dec  can be given as a 2-tuple  (ha, dec) . Output 2-tuple  (alt, az) alt : local apparent altitude, in degrees. az : the local apparent azimuth, in degrees. The output coordinates are always floating points and have the same type (scalar or array) as the input coordinates. Example Arcturus is observed at an apparent hour angle of 336.6829 and a declination of 19.1825 while at the latitude of +43° 4' 42''.  What are the local altitude and azimuth of this object? julia> using AstroLib\n\njulia> alt, az = hadec2altaz(336.6829, 19.1825, ten(43, 4, 42))\n(59.08617155005685, 133.3080693440254) Notes altaz2hadec  converts Horizon (Alt-Az) coordinates to Hour Angle and Declination. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1475,"pagetitle":"Reference","title":"AstroLib.helio","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.helio","content":" AstroLib.helio  —  Function helio(jd, list[, radians=true]) -> hrad, hlong, hlat Purpose Compute heliocentric coordinates for the planets. Explanation The mean orbital elements for epoch J2000 are used. These are derived from a 250 yr least squares fit of the DE 200 planetary ephemeris to a Keplerian orbit where each element is allowed to vary linearly with time. Useful mainly for dates between 1800 and 2050, this solution fits the terrestrial planet orbits to ~25'' or better, but achieves only ~600'' for Saturn. Arguments jd : julian date, scalar or vector num : integer denoting planet number, scalar or vector 1 = Mercury, 2 = Venus, ... 9 = Pluto radians (optional): if this keyword is set to  true , then the longitude and latitude output are in radians rather than degrees. Output hrad : the heliocentric radii, in astronomical units. hlong : the heliocentric (ecliptic) longitudes, in degrees. hlat : the heliocentric latitudes in degrees. Example Find heliocentric position of Venus on August 23, 2000 julia> using AstroLib\n\njulia> helio(jdcnv(2000,08,23,0), 2)\n(0.7213758288364316, 198.39093251916148, 2.887355631705488) Find the current heliocentric positions of all the planets julia> using AstroLib\n\njulia> helio.([jdcnv(1900)], 1:9)\n9-element Vector{Tuple{Float64, Float64, Float64}}:\n (0.4207394142180803, 202.60972662618906, 3.0503005607270532)\n (0.7274605731764012, 344.5381482401048, -3.3924346961624785)\n (0.9832446886519147, 101.54969268801035, 0.012669354526696368)\n (1.4212659241051142, 287.8531100442217, -1.5754626002228043)\n (5.386813769590955, 235.91306092135062, 0.9131692817310215)\n (10.054339927304339, 268.04069870870387, 1.0851704598594278)\n (18.984683376211326, 250.0555468087738, 0.05297087029604253)\n (29.87722677219009, 87.07244903504716, -1.245060583142733)\n (46.9647515992327, 75.94692594417324, -9.576681044165511) Notes This program is based on the two-body model and thus neglects interactions between the planets. The coordinates are given for equinox 2000 and  not  the equinox of the supplied date. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1476,"pagetitle":"Reference","title":"AstroLib.helio_jd","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.helio_jd-Tuple{Real, Real, Real}","content":" AstroLib.helio_jd  —  Method helio_jd(date, ra, dec[, B1950=true, diff=false]) -> jd_helio\nhelio_jd(date, ra, dec[, B1950=true, diff=true]) -> time_diff Purpose Convert geocentric (reduced) Julian date to heliocentric Julian date. Explanation This procedure corrects for the extra light travel time between the Earth and the Sun. An online calculator for this quantity is available at http://www.physics.sfasu.edu/astro/javascript/hjd.html Users requiring more precise calculations and documentation should look at the IDL code available at http://astroutils.astronomy.ohio-state.edu/time/ Arguments date : reduced Julian date (= JD - 2400000).  You can use  juldate()  to calculate the reduced Julian date. ra  and  dec : right ascension and declination in degrees.  Default equinox is J2000. B1950  (optional boolean keyword): if set to  true , then input coordinates are assumed to be in equinox B1950 coordinates.  Default is  false . diff  (optional boolean keyword): if set to  true , the function returns the time difference (heliocentric JD - geocentric JD) in seconds.  Default is  false . Output The return value depends on the value of  diff  optional keywords: if  diff  is  false  (default), then the heliocentric reduced Julian date is returned. if  diff  is  true , then the time difference in seconds between the geocentric and heliocentric Julian date is returned. Example What is the heliocentric Julian date of an observation of V402 Cygni (J2000: RA = 20 9 7.8, Dec = 37 09 07) taken on June 15, 2016 at 11:40 UT? julia> using AstroLib\n\njulia> jd = juldate(2016, 6, 15, 11, 40);\n\njulia> helio_jd(jd, ten(20, 9, 7.8) * 15, ten(37, 9, 7))\n57554.98808289718 Notes Wayne Warren (Raytheon ITSS) has compared the results of this algorithm with the FORTRAN subroutines in the STARLINK SLALIB library (see http://star-www.rl.ac.uk/).                                                  Time Diff (sec)\n     Date               RA(2000)   Dec(2000)  STARLINK      IDL\n\n1999-10-29T00:00:00.0  21 08 25.  -67 22 00.  -59.0        -59.0\n1999-10-29T00:00:00.0  02 56 33.4 +00 26 55.  474.1        474.1\n1940-12-11T06:55:00.0  07 34 41.9 -00 30 42.  366.3        370.2\n1992-02-29T03:15:56.2  12 56 27.4 +42 10 17.  350.8        350.9\n2000-03-01T10:26:31.8  14 28 36.7 -20 42 11.  243.7        243.7\n2100-02-26T09:18:24.2  08 26 51.7 +85 47 28.  104.0        108.8 Code of this function is based on IDL Astronomy User's Library. source"},{"id":1477,"pagetitle":"Reference","title":"AstroLib.helio_rv","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.helio_rv","content":" AstroLib.helio_rv  —  Function helio_rv(jd, T, P, V_0, K[, e, ω]) -> rv Purpose Return the heliocentric radial velocity of a spectroscopic binary. Explanation This function will return the heliocentric radial velocity of a spectroscopic binary star at a given heliocentric date given its orbit. Arguments jd : time of observation, as number of Julian days. T : time of periastron passage (max. +ve velocity for circular orbits), same time system as  jd P : the orbital period in same units as  jd V_0 : systemic velocity K : velocity semi-amplitude in the same units as  V_0 e : eccentricity of the orbit.  It defaults to 0 if omitted ω : longitude of periastron in degrees.  It defaults to 0 if omitted Output The predicted heliocentric radial velocity in the same units as Gamma for the date(s) specified by  jd . Example What was the heliocentric radial velocity of the primary component of HU Tau at 1730 UT 25 Oct 1994? julia> using AstroLib\n\njulia> jd = juldate(94, 10, 25, 17, 30); # Obtain Geocentric Julian days\n\njulia> hjd = helio_jd(jd, ten(04, 38, 16) * 15, ten(20, 41, 05)); # Convert to HJD\n\njulia> helio_rv(hjd, 46487.5303, 2.0563056, -6, 59.3)\n-62.965570107789475 NB: the functions  juldate  and  helio_jd  return a reduced HJD (HJD - 2400000) and so T and P must be specified in the same fashion. Plot two cycles of an eccentric orbit,  $e = 0.6$ ,  $ω = 45°$  for both components of a binary star.  Use  Plots.jl  for plotting. using Plots\nφ = range(0, stop=2, length=1000); # Generate 1000 phase points\nplot(φ, helio_rv.(φ, 0, 1, 0, 100, 0.6, 45)) # Plot 1st component\nplot(φ, helio_rv.(φ, 0, 1, 0, 100, 0.6, 45+180)) # Plot 2nd component Notes The user should ensure consistency with all time systems being used (i.e.  jd  and  t  should be in the same units and time system).  Generally, users should reduce large time values by subtracting a large constant offset, which may improve numerical accuracy. If using the the function  juldate  and  helio_jd , the reduced HJD time system must be used throughtout. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1478,"pagetitle":"Reference","title":"AstroLib.hor2eq","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.hor2eq","content":" AstroLib.hor2eq  —  Function hor2eq(alt, az, jd[, obsname;\n       ws=false, B1950=false, precession=true, nutate=true,\n       aberration=true, refract=true,\n       lat=NaN, lon=NaN, altitude=0,\n       pressure=NaN, temperature=NaN]) -> ra, dec, ha\n\nhor2eq(alt, az, jd, lat, lon[, altitude=0;\n       ws=false, B1950=false, precession=true, nutate=true,\n       aberration=true, refract=true,\n       pressure=NaN, temperature=NaN]) -> ra, dec, ha Purpose Converts local horizon coordinates (alt-az) to equatorial (ra-dec) coordinates. Explanation This is a function to calculate equatorial (ra,dec) coordinates from horizon (alt,az) coords. It is accurate to about 1 arcsecond or better. It performs precession, nutation, aberration, and refraction corrections. Arguments This function has two base methods.  With one you can specify the name of the observatory, if present in  AstroLib.observatories , with the other one you can provide the coordinates of the observing site and, optionally, the altitude. Common mandatory arguments: alt : altitude of horizon coords, in degrees az : azimuth angle measured East from North (unless ws is  true ), in degrees jd : julian date Other positional arguments: obsname : set this to a valid observatory name in  AstroLib.observatories . or lat : north geodetic latitude of location, in degrees. lon : AST longitude of location, in degrees. You can specify west longitude with a negative sign. altitude : the altitude of the observing location, in meters.  It is  0  by default Optional keyword arguments: ws  (optional boolean keyword): set this to  true  to get the azimuth measured westward from south. This is  false  by default B1950  (optional boolean keyword): set this to  true  if the ra and dec are specified in B1950 (FK4 coordinates) instead of J2000 (FK5). This is  false  by default precession  (optional boolean keyword): set this to  false  for no precession,  true  by default nutate  (optional boolean keyword): set this to  false  for no nutation,  true  by default aberration  (optional boolean keyword): set this to  false  for no aberration correction,  true  by default refract  (optional boolean keyword): set this to  false  for no refraction correction,  true  by default pressure  (optional keyword): the pressure at the observing location, in millibars. Default value is  NaN temperature  (optional keyword): the temperature at the observing location, in Kelvins. Default value is  NaN Output ra : right ascension of object, in degrees (FK5) dec : declination of the object, in degrees (FK5) ha : hour angle, in degrees Example You are at Kitt Peak National Observatory, looking at a star at azimuth angle 264d 55m 06s and elevation 37d 54m 41s (in the visible). Today is Dec 25, 2041 and the local time is 10 PM precisely. What is the right ascension and declination (J2000) of the star you're looking at? The temperature here is about 0 Celsius, and the pressure is 781 millibars. The Julian date for this time is 2466879.7083333 julia> using AstroLib\n\njulia> ra_o, dec_o = hor2eq(ten(37,54,41), ten(264,55,06), 2466879.7083333,\n                            \"kpno\", pressure = 781, temperature = 273)\n(3.3224480269254713, 15.19061543702944, 54.61174536229464)\n\njulia> adstring(ra_o, dec_o)\n\" 00 13 17.4  +15 11 26\" Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1479,"pagetitle":"Reference","title":"AstroLib.imf","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.imf-Tuple{AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}}","content":" AstroLib.imf  —  Method imf(mass, expon, mass_range) -> psi Purpose Compute an N-component power-law logarithmic initial mass function (IMF). Explanation The function is normalized so that the total mass distribution equals one solar mass. Arguments mass : mass in units of solar mass, vector. expon : power law exponent, vector. The number of values in expon equals the number of different power-law components in the IMF. mass_range : vector containing the mass upper and lower limits of the IMF and masses where the IMF exponent changes. The number of values in mass range should be one more than in expon. The values in mass range should be monotonically increasing and positive. Output psi : mass function, number of stars per unit logarithmic mass interval evaluated for supplied masses. Example Show the number of stars per unit mass interval at 3 Msun for a Salpeter (expon = -1.35) IMF, with a mass range from 0.1 MSun to 110 Msun. julia> using AstroLib\n\njulia> imf([3], [-1.35], [0.1, 110]) / 3\n1-element Vector{Float64}:\n 0.01294143518151214 Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1480,"pagetitle":"Reference","title":"AstroLib.ismeuv","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.ismeuv","content":" AstroLib.ismeuv  —  Function ismeuv(wave, hcol[, he1col=hcol*0.1, he2col=0, fano=false]) -> tau Purpose Compute the continuum interstellar EUV optical depth Explanation The EUV optical depth is computed from the photoionization of hydrogen and helium. Arguments wave : wavelength value (in Angstroms). Useful range is 40 - 912 A; at shorter wavelength metal opacity should be considered, at longer wavelengths there is no photoionization. hcol : interstellar hydrogen column density in cm-2. he1col  (optional): neutral helium column density in cm-2. Default is 0.1*hcol (10% of hydrogen column) he2col  (optional): ionized helium column density in cm-2 Default is 0. fano  (optional boolean keyword): If this keyword is true, then the 4 strongest auto-ionizing resonances of He I are included. The shape of these resonances is given by a Fano profile - see Rumph, Bowyer, & Vennes 1994, AJ, 107, 2108. If these resonances are included then the input wavelength vector should have a fine (>~0.01 A) grid between 190 A and 210 A, since the resonances are very narrow. Output tau : Vector giving resulting optical depth, non-negative values. Example One has a model EUV spectrum with wavelength, w (in Angstroms). Find the EUV optical depth by 1e18 cm-2 of HI, with N(HeI)/N(HI) = N(HeII)/N(HI) = 0.05. julia> using AstroLib\n\njulia> ismeuv.([670, 910], 1e19, 5e17, 5e17)\n2-element Vector{Float64}:\n 27.35393320556168\n 62.683796028917286 Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1481,"pagetitle":"Reference","title":"AstroLib.jdcnv","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.jdcnv","content":" AstroLib.jdcnv  —  Function jdcnv(date) -> julian_days Purpose Convert proleptic Gregorian Calendar date in UTC standard to number of Julian days. Explanation Takes the given proleptic Gregorian date in UTC standard and returns the number of Julian calendar days since epoch  -4713-11-24T12:00:00 . Argument date : date in proleptic Gregorian Calendar.  Each element can be either a  DateTime  or anything that can be converted directly to  DateTime . Output Number of Julian days, as a floating point. Example Find the Julian days number at 2016 August 23, 03:39:06. julia> using AstroLib, Dates\n\njulia> jdcnv(DateTime(2016, 08, 23, 03, 39, 06))\n2.4576236521527776e6\n\njulia> jdcnv(2016, 08, 23, 03, 39, 06)\n2.4576236521527776e6\n\njulia> jdcnv(\"2016-08-23T03:39:06\")\n2.4576236521527776e6 Notes This is the inverse of  daycnv . get_juldate  returns the number of Julian days for current time.  It is equivalent to  jdcnv(now(Dates.UTC)) . For the conversion of Julian date to number of Julian days, use  juldate . source"},{"id":1482,"pagetitle":"Reference","title":"AstroLib.jprecess","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.jprecess","content":" AstroLib.jprecess  —  Function jprecess(ra, dec[, epoch]) -> ra2000, dec2000\njprecess(ra, dec, muradec[, parallax=parallax, radvel=radvel]) -> ra2000, dec2000 Purpose Precess positions from B1950.0 (FK4) to J2000.0 (FK5). Explanation Calculate the mean place of a star at J2000.0 on the FK5 system from the mean place at B1950.0 on the FK4 system. jprecess  function has two methods, one for each of the following cases: the proper motion is known and non-zero the proper motion is unknown or known to be exactly zero (i.e. extragalactic radio sources).  Better precision can be achieved in this case by inputting the epoch of the original observations. Arguments The function has 2 methods.  The common mandatory arguments are: ra : input B1950 right ascension, in degrees. dec : input B1950 declination, in degrees. The two methods have a different third argument (see \"Explanation\" section for more details).  It can be one of the following: muradec : 2-element vector containing the proper motion in seconds of arc per tropical  century  in right ascension and declination. epoch : scalar giving epoch of original observations. If none of these two arguments is provided (so  jprecess  is fed only with right ascension and declination), it is assumed that proper motion is exactly zero and  epoch = 1950 . If it is used the method involving  muradec  argument, the following keywords are available: parallax  (optional numerical keyword): stellar parallax, in seconds of arc. radvel  (optional numerical keyword): radial velocity in km/s. Right ascension and declination can be passed as the 2-tuple  (ra, dec) .  You can also pass  ra ,  dec ,  parallax , and  radvel  as arrays, all of the same length N.  In that case,  muradec  should be a matrix 2×N. Output The 2-tuple of right ascension and declination in 2000, in degrees, of input coordinates is returned.  If  ra  and  dec  (and other possible optional arguments) are arrays, the 2-tuple of arrays  (ra2000, dec2000)  of the same length as the input coordinates is returned. Method The algorithm is taken from the Explanatory Supplement to the Astronomical Almanac 1992, page 184.  See also Aoki et al (1983), A&A, 128, 263.  URL: http://adsabs.harvard.edu/abs/1983A%26A...128..263A. Example The SAO catalogue gives the B1950 position and proper motion for the star HD 119288.   Find the J2000 position. RA(1950) = 13h 39m 44.526s Dec(1950) = 8d 38' 28.63'' Mu(RA) = -.0259 s/yr Mu(Dec) = -.093 ''/yr julia> using AstroLib\n\njulia> muradec = 100 * [-15*0.0259, -0.093]; # convert to century proper motion\n\njulia> ra = ten(13, 39, 44.526)*15;\n\njulia> decl = ten(8, 38, 28.63);\n\njulia> adstring(jprecess(ra, decl, muradec), precision=2)\n\" 13 42 12.740  +08 23 17.69\" Notes \"When transferring individual observations, as opposed to catalog mean place, the safest method is to tranform the observations back to the epoch of the observation, on the FK4 system (or in the system that was used to to produce the observed mean place), convert to the FK5 system, and transform to the the epoch and equinox of J2000.0\" – from the Explanatory Supplement (1992), p. 180 bprecess  performs the precession to B1950 coordinates. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1483,"pagetitle":"Reference","title":"AstroLib.juldate","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.juldate-Tuple{Dates.DateTime}","content":" AstroLib.juldate  —  Method juldate(date::DateTime) -> reduced_julia_days Purpose Convert from calendar to Reduced Julian Days. Explanation Julian Day Number is a count of days elapsed since Greenwich mean noon on 1 January 4713 B.C.  Julian Days are the number of Julian days followed by the fraction of the day elapsed since the preceding noon. This function takes the given  date  and returns the number of Julian calendar days since epoch  1858-11-16T12:00:00  (Reduced Julian Days = Julian Days - 2400000). Argument date : date in Julian Calendar, UTC standard.  Each element can be given in  DateTime  type or anything that can be converted to that type. Output The number of Reduced Julian Days is returned. Example Get number of Reduced Julian Days at 2016-03-20T15:24:00. julia> using AstroLib, Dates\n\njulia> juldate(DateTime(2016, 03, 20, 15, 24))\n57468.14166666667\n\njulia> juldate(2016, 03, 20, 15, 24)\n57468.14166666667\n\njulia> juldate(\"2016-03-20T15:24\")\n57468.14166666667 Notes Julian Calendar is assumed, thus before  1582-10-15T00:00:00  this function is  not  the inverse of  daycnv .  For the conversion proleptic Gregorian date to number of Julian days, use  jdcnv , which is the inverse of  daycnv . Code of this function is based on IDL Astronomy User's Library. source"},{"id":1484,"pagetitle":"Reference","title":"AstroLib.kepler_solver","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.kepler_solver","content":" AstroLib.kepler_solver  —  Function kepler_solver(M, e) -> E Purpose Solve Kepler's equation in the elliptic motion regime ( $0 ≤ e ≤ 1$ ) and return eccentric anomaly  $E$ . Explanation In order to find the position of a body in elliptic motion (e.g., in the two-body problem) at a given time  $t$ , one has to solve the  Kepler's equation \\[M(t) = E(t) - e \\sin E(t)\\] where  $M(t) = (t - t_0)/P$  is the mean anomaly,  $E(t)$  the eccentric anomaly,  $e$  the eccentricity of the orbit,  $t_0$  is the time of periapsis passage, and  $P$  is the period of the orbit.  Usually the eccentricity is given and one wants to find the eccentric anomaly  $E(t)$  at a specific time  $t$ , so that also the mean anomaly  $M(t)$  is known. Arguments M : mean anomaly. e : eccentricity, in the elliptic motion regime ( $0 ≤ e ≤ 1$ ) Output The eccentric anomaly  $E$ , restricted to the range  $[-π, π]$ . Method Many different numerical methods exist to solve Kepler's equation.  This function implements the algorithm proposed in Markley (1995) Celestial Mechanics and Dynamical Astronomy, 63, 101 (DOI: 10.1007/BF00691917 ).  This method is not iterative, requires only four transcendental function evaluations, and has been proved to be fast and efficient over the entire range of elliptic motion  $0 ≤ e ≤ 1$ . Example Find the eccentric anomaly for an orbit with eccentricity  $e = 0.7$  and for  $M(t) = 8π/3$ . julia> using AstroLib\n\njulia> ecc = 0.7;\n\njulia> E = kepler_solver(8pi/3, ecc)\n2.5085279492864223 Plot the eccentric anomaly as a function of mean anomaly for eccentricity  $e = 0, 0.5, 0.9$ .  Recall that  kepler_solver  gives  $E ∈ [-π, π]$ , use  mod2pi  to have it in  $[0, 2π]$ .  Use  Plots.jl  for plotting. using AstroLib\nusing Plots\nM = range(0, stop=2pi, length=1001)[1:end-1];\nfor ecc in (0, 0.5, 0.9)\n    plot(M, mod2pi.(kepler_solver.(M, ecc)))\nend Notes The true anomaly can be calculated with  trueanom  function. source"},{"id":1485,"pagetitle":"Reference","title":"AstroLib.lsf_rotate","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.lsf_rotate","content":" AstroLib.lsf_rotate  —  Function lsf_rotate(delta_v, v_sin_i[, epsilon = 0.3]) -> velocity_grid, lsf Purpose Create a 1-d convolution kernel to broaden a spectrum from a rotating star. Explanation Can be used to derive the broadening effect (LSF, line spread function) due to rotation on a synthetic stellar spectrum.  Assumes constant limb darkening across the disk. Arguments delta_v : the step increment (in km/s) in the output rotation kernel v_sin_i : the rotational velocity projected along the line of sight (km/s) epsilon  (optional numeric argument): the limb-darkening coefficient, default = 0.6 which is typical for photospheric lines.  The specific intensity  $I$  at any angle  $θ$  from the specific intensity  $I_{\\text{cen}}$  at the center of the disk is given by: \\[I = I_{\\text{cen}} ⋅ (1 - ε ⋅ (1 - \\cos(θ)))\\] Output The 2-tuple ( velocity_grid ,  lsf ): velocity_grid : vector of velocity grid with the same number of elements as  lsf  (see below) lsf : the convolution kernel vector for the specified rotational velocity. The number of points in  lsf  will be always be odd (the kernel is symmetric) and equal to either  ceil(2*v_sin_i/delta_v)  or  ceil(2*v_sin_i/delta_v) + 1 , whichever number is odd.  Elements of  lsf  will always be of type  AbstractFloat .  To actually compute the broadening, the spectrum should be convolved with the rotational  lsf Example Plot the line spread function for a star rotating at 90 km/s in velocity space every 3 km/s.  Use  Plots.jl  for plotting. using Plots\nplot(lsf_rotate(3, 90)...) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1486,"pagetitle":"Reference","title":"AstroLib.mag2flux","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.mag2flux","content":" AstroLib.mag2flux  —  Function mag2flux(mag[, zero_point, ABwave=number]) -> flux Purpose Convert from magnitudes to flux expressed in erg/(s cm² Å). Explanation This is the reverse of  flux2mag . Arguments mag : the magnitude to be converted in flux. zero_point : the zero point level of the magnitude.  If not supplied then defaults to 21.1 (Code et al 1976).  Ignored if the  ABwave  keyword is supplied ABwave  (optional numeric keyword): wavelength, in Angstroms.  If supplied, then the input  mag  is assumed to contain Oke AB magnitudes (Oke & Gunn 1983, ApJ, 266, 713; http://adsabs.harvard.edu/abs/1983ApJ...266..713O). Output The flux. If the  ABwave  keyword is set, then the flux is given by the expression \\[\\text{flux} = 10^{-0.4(\\text{mag} +2.406 + 4\\log_{10}(\\text{ABwave}))}\\] Otherwise the flux is given by \\[\\text{flux} =  10^{-0.4(\\text{mag} + \\text{zero point})}\\] Example julia> using AstroLib\n\njulia> mag2flux(8.3)\n1.7378008287493692e-12\n\njulia> mag2flux(8.3, 12)\n7.58577575029182e-9\n\njulia> mag2flux(8.3, ABwave=12)\n3.624411568301719e-7 Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1487,"pagetitle":"Reference","title":"AstroLib.mag2geo","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.mag2geo","content":" AstroLib.mag2geo  —  Function mag2geo(latitude, longitude[, year]) -> geographic_latitude, geographic_longitude Purpose Convert from geomagnetic to geographic coordinates. Explanation Converts from geomagnetic (latitude, longitude) to geographic (latitude, longitude).  Altitude is not involved in this function. Arguments latitude : geomagnetic latitude (North), in degrees. longitude : geomagnetic longitude (East), in degrees. year  (optional numerical argument): the year in which to perform conversion. If omitted, defaults to current year. The coordinates can be passed as arrays of the same length. Output The 2-tuple of geographic (latitude, longitude) coordinates, in degrees. If geomagnetic coordinates are given as arrays, a 2-tuple of arrays of the same length is returned. Example Find position of North Magnetic Pole in 2016 julia> using AstroLib\n\njulia> mag2geo(90, 0, 2016)\n(86.395, -166.29000000000002) Notes This function uses list of North Magnetic Pole positions provided by World Magnetic Model (https://www.ngdc.noaa.gov/geomag/data/poles/NP.xy). geo2mag  converts geographic coordinates to geomagnetic coordinates. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1488,"pagetitle":"Reference","title":"AstroLib.mean_obliquity","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.mean_obliquity-Tuple{Real}","content":" AstroLib.mean_obliquity  —  Method mean_obliquity(jd) -> m_eps Purpose Return the mean obliquity of the ecliptic for a given Julian date Explanation The function is used by the  co_nutate  procedure. Arguments jd : julian date Output m_eps : mean obliquity of the ecliptic, in radians Example julia> using AstroLib\n\njulia> mean_obliquity(jdcnv(1978,01,7,11, 01))\n0.4091425159336512 Notes The algorithm used to find the mean obliquity( eps0 ) is mentioned in USNO Circular 179, but the canonical reference for the IAU adoption is apparently Hilton et al., 2006, Celest.Mech.Dyn.Astron. 94, 351. 2000 source"},{"id":1489,"pagetitle":"Reference","title":"AstroLib.month_cnv","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.month_cnv-Tuple{Integer}","content":" AstroLib.month_cnv  —  Method month_cnv(number[, shor=true, up=true, low=true]) -> month_name\nmonth_cnv(name) -> number Purpose Convert between a month English name and  the equivalent number. Explanation For example, converts from \"January\" to 1  or vice-versa. Arguments The functions has two methods, one with numeric input (and three possible boolean keywords) and the other one with string input. Numeric input arguments: number : the number of the month to be converted to month name. short  (optional boolean keyword): if true, the abbreviated (3-character) name of the month will be returned, e.g. \"Apr\" or \"Oct\".  Default is false. up  (optional boolean keyword): if true, the name of the month will be all in upper case, e.g. \"APRIL\" or \"OCTOBER\".  Default is false. low  (optional boolean keyword): if true, the name of the month will be all in lower case, e.g. \"april\" or \"october\".  Default is false. String input argument: name : month name to be converted to month number. Output The month name or month number, depending on the input.  For numeric input, the format of the month name is influenced by the optional keywords. Example julia> using AstroLib\n\njulia> month_cnv.([\"janua\", \"SEP\", \"aUgUsT\"])\n3-element Vector{Int64}:\n 1\n 9\n 8\n\njulia> month_cnv.([2, 12, 6], short=true, low=true)\n3-element Vector{String}:\n \"feb\"\n \"dec\"\n \"jun\" source"},{"id":1490,"pagetitle":"Reference","title":"AstroLib.moonpos","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.moonpos","content":" AstroLib.moonpos  —  Function moonpos(jd[, radians=true]) -> ra, dec, dis, geolong, geolat Purpose Compute the right ascension and declination of the Moon at specified Julian date. Arguments jd : the Julian ephemeris date.  It can be either a scalar or an array radians  (optional boolean keyword): if set to  true , then all output angular quantities are given in radians rather than degrees.  The default is  false Output The 5-tuple  (ra, dec, dis, geolong, geolat) : ra : apparent right ascension of the Moon in degrees, referred to the true equator of the specified date(s) dec : the declination of the Moon in degrees dis : the distance between the centre of the Earth and the centre of the Moon in kilometers geolong : apparent longitude of the moon in degrees, referred to the ecliptic of the specified date(s) geolat : apparent longitude of the moon in degrees, referred to the ecliptic of the specified date(s) If  jd  is an array, then all output quantities are arrays of the same length as  jd . Method Derived from the Chapront ELP2000/82 Lunar Theory (Chapront-Touze' and Chapront, 1983, 124, 50), as described by Jean Meeus in Chapter 47 of ``Astronomical Algorithms'' (Willmann-Bell, Richmond), 2nd edition, 1998.  Meeus quotes an approximate accuracy of 10\" in longitude and 4\" in latitude, but he does not give the time range for this accuracy. Comparison of the IDL procedure with the example in ``Astronomical Algorithms'' reveals a very small discrepancy (~1 km) in the distance computation, but no difference in the position calculation. Example Find the position of the moon on April 12, 1992 julia> using AstroLib\n\njulia> jd = jdcnv(1992, 4, 12);\n\njulia> adstring(moonpos(jd)[1:2],precision=1)\n\" 08 58 45.23  +13 46 06.1\" This is within 1\" from the position given in the Astronomical Almanac. Plot the Earth-moon distance during 2016 with sampling of 6 hours.  Use  Plots.jl  for plotting using Dates\nusing Plots\npoints = DateTime(2016):Dates.Hour(6):DateTime(2017);\nplot(points, moonpos(jdcnv.(points))[3]) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1491,"pagetitle":"Reference","title":"AstroLib.mphase","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.mphase-Tuple{Real}","content":" AstroLib.mphase  —  Method mphase(jd) -> k Purpose Return the illuminated fraction of the Moon at given Julian date(s). Arguments jd : the Julian ephemeris date. Output The illuminated fraction  $k$  of Moon's disk, with  $0 ≤ k ≤ 1$ .  $k = 0$  indicates a new moon, while  $k = 1$  stands for a full moon. Method Algorithm from Chapter 46 of \"Astronomical Algorithms\" by Jean Meeus (Willmann-Bell, Richmond) 1991.   sunpos  and  moonpos  are used to get positions of the Sun and the Moon, and the Moon distance.  The selenocentric elongation of the Earth from the Sun (phase angle) is then computed, and used to determine the illuminated fraction. Example Plot the illuminated fraction of the Moon for every day in January 2018 with a hourly sampling.  Use  Plots.jl  for plotting using Dates\nusing Plots\npoints = DateTime(2018,01,01):Dates.Hour(1):DateTime(2018,01,31,23,59,59);\nplot(points, mphase.(jdcnv.(points))) Note that in this calendar month there are two full moons, this event is called  blue moon . Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1492,"pagetitle":"Reference","title":"AstroLib.nutate","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.nutate-Tuple{Real}","content":" AstroLib.nutate  —  Method nutate(jd) -> long, obliq Purpose Return the nutation in longitude and obliquity for a given Julian date. Arguments jd : Julian ephemeris date, it can be either a scalar or a vector Output The 2-tuple  (long, obliq) , where long : the nutation in longitude obl : the nutation in latitude If  jd  is an array,  long  and  obl  are arrays of the same length. Method Uses the formula in Chapter 22 of \"Astronomical Algorithms\" by Jean Meeus (1998, 2nd ed.) which is based on the 1980 IAU Theory of Nutation and includes all terms larger than 0.0003\". Example Find the nutation in longitude and obliquity 1987 on Apr 10 at 0h.  This is example 22.a from Meeus julia> using AstroLib\n\njulia> jd = jdcnv(1987, 4, 10);\n\njulia> nutate(jd)\n(-3.787931077110494, 9.44252069864449) Plot the daily nutation in longitude and obliquity during the 21st century. Use  Plots.jl  for plotting. using Dates\nusing Plots\nyears = DateTime(2000):DateTime(2100);\nlong, obl = nutate(jdcnv.(years));\nplot(years, long); plot(years, obl) You can see both the dominant large scale period of nutation, of 18.6 years, and smaller oscillations with shorter periods. Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1493,"pagetitle":"Reference","title":"AstroLib.ordinal","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.ordinal-Tuple{Integer}","content":" AstroLib.ordinal  —  Method ordinal(num) -> result Purpose Convert an integer to a correct English ordinal string. Explanation The first four ordinal strings are \"1st\", \"2nd\", \"3rd\", \"4th\", .... Arguments num : number to be made ordinal. It should be of type  Integer . Output result : ordinal string, such as \"1st\", \"3rd\", \"164th\", \"87th\", etc. Example julia> using AstroLib\n\njulia> ordinal.(1:5)\n5-element Vector{String}:\n \"1st\"\n \"2nd\"\n \"3rd\"\n \"4th\"\n \"5th\" Notes This function does not support float arguments, unlike the IDL implementation. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1494,"pagetitle":"Reference","title":"AstroLib.paczynski","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.paczynski-Tuple{Real}","content":" AstroLib.paczynski  —  Method paczynski(u) -> amplification Purpose Calculate gravitational microlensing amplification of a point-like source by a single point-like lens. Explanation Return the  gravitational microlensing  amplification of a point-like source by a single point-like lens, using Paczyński formula \\[A(u) = \\frac{u^2 + 2}{u\\sqrt{u^2 + 4}}\\] where  $u$  is the projected distance between the lens and the source in units of  Einstein radii . In order to speed up calculations for extreme values of  $u$ , the following asyntotic expressions for  $A(u)$  are used: \\[A(u) =\n\\begin{cases}\n 1/u & |u| ≪ 1 \\\\\n \\text{sgn}(u) & |u| ≫ 1\n\\end{cases}\\] Arguments u : projected distance between the lens and the source, in units of Einstein radii Output The microlensing amplification for the given distance. Example Calculate the microlensing amplification for  $u = 10^{-10}, 10^{-1}, 1, 10, 10^{10}$ : julia> paczynski.([1e-10, 1e-1, 1, 10, 1e10])\n5-element Vector{Float64}:\n  1.0e10\n 10.037461005722337\n  1.3416407864998738\n  1.0001922892047386\n  1.0 Notes The expression of  $A(u)$  of microlensing amplification has been given by Bohdan Paczyński in Paczynski, B. 1986, ApJ, 304, 1. DOI: 10.1086/164140 , Bibcode: 1986ApJ...304....1P The same expression was actually found by Albert Einstein half a century earlier: Einstein, A. 1936, Science, 84, 506. DOI: 10.1126/science.84.2188.506 , Bibcode: 1936Sci....84..506E source"},{"id":1495,"pagetitle":"Reference","title":"AstroLib.planck_freq","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.planck_freq-Tuple{Real, Real}","content":" AstroLib.planck_freq  —  Method planck_freq(frequency, temperature) -> black_body_flux Purpose Calculate the flux of a black body per unit frequency. Explanation Return the spectral radiance of a black body per unit frequency using  Planck's law \\[B_\\nu(\\nu, T) = \\frac{2h\\nu^3}{c^2} \\frac{1}{e^\\frac{h\\nu}{k_\\mathrm{B}T} - 1}\\] Arguments frequency : frequency at which the flux is to be calculated, in Hertz. temperature : the equilibrium temperature of the black body, in Kelvin. Output The spectral radiance of the black body, in units of W/(sr·m²·Hz). Example Plot the spectrum of a black body in  $[10^{12}, 10^{15.4}]$  Hz at 8000 K. Use  Plots.jl  for plotting. using Plots\nfrequency = exp10.(range(12, stop=15.4, length=1000));\ntemperature = ones(size(frequency)) * 8000;\nflux = planck_freq.(frequency, temperature);\nplot(frequency, flux) Notes planck_wave  calculates the flux of a black body per unit wavelength. source"},{"id":1496,"pagetitle":"Reference","title":"AstroLib.planck_wave","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.planck_wave-Tuple{Real, Real}","content":" AstroLib.planck_wave  —  Method planck_wave(wavelength, temperature) -> black_body_flux Purpose Calculate the flux of a black body per unit wavelength. Explanation Return the spectral radiance of a black body per unit wavelength using  Planck's law \\[B_λ(λ, T) = \\frac{2hc^2}{λ^5} \\frac{1}{e^{\\frac{hc}{λ k_\\mathrm{B}T}} - 1}\\] Arguments wavelength : wavelength at which the flux is to be calculated, in meters. temperature : the equilibrium temperature of the black body, in Kelvin. Output The spectral radiance of the black body, in units of W/(sr·m³). Example Plot the spectrum of a black body in  $[0, 3]$  µm at  $5000$  K.  Use  Plots.jl  for plotting. using Plots\nwavelength = range(0, stop=3e-6, length=1000);\ntemperature = ones(wavelength)*5000;\nflux = planck_wave.(wavelength, temperature);\nplot(wavelength, flux) Notes planck_freq  calculates the flux of a black body per unit frequency. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1497,"pagetitle":"Reference","title":"AstroLib.planet_coords","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.planet_coords-Tuple{Real, Integer}","content":" AstroLib.planet_coords  —  Method planet_coords(date, num) Purpose Find right ascension and declination for the planets when provided a date as input. Explanation This function uses the  helio  to get the heliocentric ecliptic coordinates of the planets at the given date which it then converts these to geocentric ecliptic coordinates ala \"Astronomical Algorithms\" by Jean Meeus (1991, p 209). These are then converted to right ascension and declination using  euler . The accuracy between the years 1800 and 2050 is better than 1 arcminute for the terrestial planets, but reaches 10 arcminutes for Saturn. Before 1850 or after 2050 the accuracy can get much worse. Arguments date : Can be either a single date or an array of dates. Each element can be either a  DateTime  type or Julian Date. It can be a scalar or vector. num : integer denoting planet number, scalar or vector 1 = Mercury, 2 = Venus, ... 9 = Pluto. If not in that change, then the program will throw an error. Output ra : right ascension of planet(J2000), in degrees dec : declination of the planet(J2000), in degrees Example Find the RA, Dec of Venus on 1992 Dec 20 julia> using AstroLib, Dates\n\njulia> adstring(planet_coords(DateTime(1992,12,20),2))\n\" 21 05 02.8  -18 51 41\" Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1498,"pagetitle":"Reference","title":"AstroLib.polrec","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.polrec-Tuple{Real, Real}","content":" AstroLib.polrec  —  Method polrec(radius, angle[, degrees=true]) -> x, y Purpose Convert 2D polar coordinates to rectangular coordinates. Explanation This is the partial inverse function of  recpol . Arguments radius : radial coordinate of the point.  It may be a scalar or an array. angle : the angular coordinate of the point.  It may be a scalar or an array of the same lenth as  radius . degrees  (optional boolean keyword): if  true , the  angle  is assumed to be in degrees, otherwise in radians.  It defaults to  false . Mandatory arguments can also be passed as the 2-tuple  (radius, angle) , so that it is possible to execute  recpol(polrec(radius, angle)) . Output A 2-tuple  (x, y)  with the rectangular coordinate of the input.  If  radius  and  angle  are arrays,  x  and  y  are arrays of the same length as  radius  and  angle . Example Get rectangular coordinates  $(x, y)$  of the point with polar coordinates  $(r, φ) = (1.7, 227)$ , with angle  $φ$  expressed in degrees. julia> using AstroLib\n\njulia> x, y = polrec(1.7, 227, degrees=true)\n(-1.1593972121062475, -1.2433012927525897) source"},{"id":1499,"pagetitle":"Reference","title":"AstroLib.posang","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.posang-Tuple{Integer, Vararg{Real, 4}}","content":" AstroLib.posang  —  Method posang(units, ra1, dec1, ra2, dec2) -> angular_distance Purpose Compute rigorous position angle of point 2 relative to point 1. Explanation Computes the rigorous position angle of point 2 (with given right ascension and declination) using point 1 (with given right ascension and declination) as the center. Arguments units : integer, can be either 0, or 1, or 2.  Describes units of inputs and output: 0: everything (input right ascensions and declinations, and output distance) is radians 1: right ascensions are in decimal hours, declinations in decimal degrees, output distance in degrees 2: right ascensions and declinations are in degrees, output distance in degrees ra1 :  right ascension or longitude of point 1 dec1 : declination or latitude of point 1 ra2 : right ascension or longitude of point 2 dec2 : declination or latitude of point 2 Both  ra1  and  dec1 , and  ra2  and  dec2  can be given as 2-tuples  (ra1, dec1)  and  (ra2, dec2) . Output Angle of the great circle containing  [ra2, dec2]  from the meridian containing  [ra1, dec1] , in the sense north through east rotating about  [ra1, dec1] . See  units  argument above for units. Method The \"four-parts formula\" from spherical trigonometry (p. 12 of Smart's Spherical Astronomy or p. 12 of Green' Spherical Astronomy). Example Mizar has coordinates (ra, dec) = (13h 23m 55.5s, +54° 55' 31'').  Its companion, Alcor, has coordinates (ra, dec) = (13h 25m 13.5s, +54° 59' 17''). Find the position angle of Alcor with respect to Mizar. julia> using AstroLib\n\njulia> posang(1, ten(13, 25, 13.5), ten(54, 59, 17), ten(13, 23, 55.5), ten(54, 55, 31))\n-108.46011246802047 Notes The function  sphdist  provides an alternate method of computing a spherical distance. Note that  posang  is not commutative: the position angle between A and B is  $θ$ , then the position angle between B and A is  $180 + θ$ . Code of this function is based on IDL Astronomy User's Library. source"},{"id":1500,"pagetitle":"Reference","title":"AstroLib.precess","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.precess-NTuple{4, Real}","content":" AstroLib.precess  —  Method precess(ra, dec, equinox1, equinox2[, FK4=true, radians=true]) -> prec_ra, prec_dec Purpose Precess coordinates from  equinox1  to  equinox2 . Explanation The default  (ra, dec)  system is FK5 based on epoch J2000.0 but FK4 based on B1950.0 is available via the  FK4  boolean keyword. Arguments ra : input right ascension, scalar or vector, in degrees, unless the  radians  keyword is set to  true dec : input declination, scalar or vector, in degrees, unless the  radians  keyword is set to  true equinox1 : original equinox of coordinates, numeric scalar. equinox2 : equinox of precessed coordinates. FK4  (optional boolean keyword): if this keyword is set to  true , the FK4 (B1950.0) system precession angles are used to compute the precession matrix. When it is  false , the default, use FK5 (J2000.0) precession angles. radians  (optional boolean keyword): if this keyword is set to  true , then the input and output right ascension and declination vectors are in radians rather than degrees. Output The 2-tuple  (ra, dec)  of coordinates modified by precession. Example The Pole Star has J2000.0 coordinates (2h, 31m, 46.3s, 89d 15' 50.6\"); compute its coordinates at J1985.0 julia> using AstroLib\n\njulia> ra, dec = ten(2,31,46.3)*15, ten(89,15,50.6)\n(37.94291666666666, 89.26405555555556)\n\njulia> adstring(precess(ra, dec, 2000, 1985), precision=1)\n\" 02 16 22.73  +89 11 47.3\" Precess the B1950 coordinates of Eps Ind (RA = 21h 59m,33.053s, DEC = -56d, 59', 33.053\") to equinox B1975. julia> using AstroLib\n\njulia> ra, dec = ten(21, 59, 33.053) * 15, ten(-56, 59, 33.053)\n(329.88772083333333, -56.992514722222225)\n\njulia> adstring(precess(ra, dec, 1950, 1975, FK4=true), precision=1)\n\" 22 01 15.46  -56 52 18.7\" Method Algorithm from \"Computational Spherical Astronomy\" by Taff (1983), p. 24. (FK4). FK5 constants from \"Explanatory Supplement To The Astronomical Almanac\" 1992, page 104 Table 3.211.1 (https://archive.org/details/131123ExplanatorySupplementAstronomicalAlmanac). Notes Accuracy of precession decreases for declination values near 90 degrees.  precess  should not be used more than 2.5 centuries from 2000 on the FK5 system (1950.0 on the FK4 system).  If you need better accuracy, use  bprecess  or  jprecess  as needed. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1501,"pagetitle":"Reference","title":"AstroLib.precess_cd","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.precess_cd","content":" AstroLib.precess_cd  —  Function precess_cd(cd, epoch1, epoch2, crval_old, crval_new[, FK4=true]) -> cd Purpose Precess the coordinate description matrix. Explanation The coordinate matrix is precessed from epoch1 to epoch2. Arguments cd : 2×2 coordinate description matrix in degrees epoch1 : original equinox of coordinates, scalar epoch2 : equinox of precessed coordinates, scalar crval_old : 2 element vector containing right ascension and declination in degrees of the reference pixel in the original equinox crval_new : 2 element vector giving crval in the new equinox FK4  (optional boolean keyword): if this keyword is set to  true , then the precession constants are taken in the FK4 reference frame. When it is  false , the default is the FK5 frame Output cd : coordinate description containing precessed values Example julia> using AstroLib\n\njulia> precess_cd([20 60; 45 45], 1950, 2000, [34, 58], [12, 83])\n2×2 Matrix{Float64}:\n  48.8944  147.075\n 110.188   110.365 Notes Code of this function is based on IDL Astronomy User's Library. This function should not be used for values more than 2.5 centuries from the year 1900. This function calls  sec2rad ,  precess  and  bprecess . source"},{"id":1502,"pagetitle":"Reference","title":"AstroLib.precess_xyz","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.precess_xyz-NTuple{5, Real}","content":" AstroLib.precess_xyz  —  Method precess_xyz(x, y, z, equinox1, equinox2) -> prec_x, prec_y, prec_z Purpose Precess equatorial geocentric rectangular coordinates. Arguments x ,  y ,  z : scalars or vectors giving heliocentric rectangular coordinates. equinox1 : original equinox of coordinates, numeric scalar. equinox2 : equinox of precessed coordinates, numeric scalar. Input coordinates can be given also a 3-tuple  (x, y, z) . Output The 3-tuple  (x, y, z)  of coordinates modified by precession. Example Precess 2000 equinox coordinates  (1, 1, 1)  to 2050. julia> using AstroLib\n\njulia> precess_xyz(1, 1, 1, 2000, 2050)\n(0.9838854500981734, 1.0110925876508692, 1.0048189888146941) Method The equatorial geocentric rectangular coordinates are converted to right ascension and declination, precessed in the normal way, then changed back to  x ,  y  and  z  using unit vectors. Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1503,"pagetitle":"Reference","title":"AstroLib.premat","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.premat-Tuple{Real, Real}","content":" AstroLib.premat  —  Method premat(equinox1, equinox2[, FK4=true]) -> precession_matrix Purpose Return the precession matrix needed to go from  equinox1  to  equinox2 . Explanation This matrix is used by  precess  and  baryvel  to precess astronomical coordinates. Arguments equinox1 : original equinox of coordinates. equinox2 : equinox of precessed coordinates. FK4  (optional boolean keyword): if this keyword is set to  true , the FK4 (B1950.0) system precession angles are used to compute the precession matrix. When it is  false , the default, use FK5 (J2000.0) precession angles. Output A 3×3 matrix, used to precess equatorial rectangular coordinates. Example Return the precession matrix from 1950.0 to 1975.0 in the FK4 system julia> using AstroLib\n\njulia> premat(1950, 1975, FK4=true)\n3×3 StaticArraysCore.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n 0.999981    -0.00558775  -0.00242909\n 0.00558775   0.999984    -6.78691e-6\n 0.00242909  -6.78633e-6   0.999997 Method FK4 constants from \"Computational Spherical Astronomy\" by Taff (1983), p. 24. (FK4). FK5 constants from \"Explanatory Supplement To The Astronomical Almanac\" 1992, page 104 Table 3.211.1 (https://archive.org/details/131123ExplanatorySupplementAstronomicalAlmanac). Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1504,"pagetitle":"Reference","title":"AstroLib.rad2sec","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.rad2sec-Tuple{Real}","content":" AstroLib.rad2sec  —  Method rad2sec(rad) -> seconds Purpose Convert from radians to seconds. Argument rad : number of radians. Output The number of seconds corresponding to  rad . Example julia> using AstroLib\n\njulia> rad2sec(1)\n206264.80624709636 Notes Use  sec2rad  to convert seconds to radians. source"},{"id":1505,"pagetitle":"Reference","title":"AstroLib.radec","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.radec-Tuple{Real, Real}","content":" AstroLib.radec  —  Method radec(ra::Real, dec::Real[, hours=false]) -> ra_hours, ra_minutes, ra_seconds, dec_degrees, dec_minutes, dec_seconds Purpose Convert right ascension and declination from decimal to sexagesimal units. Explanation The conversion is to sexagesimal hours for right ascension, and sexagesimal degrees for declination. Arguments ra : decimal right ascension, scalar or array.  It is expressed in degrees, unless the optional keyword  hours  is set to  true . dec : declination in decimal degrees, scalar or array, same number of elements as  ra . hours  (optional boolean keyword): if  false  (the default),  ra  is assumed to be given in degrees, otherwise  ra  is assumed to be expressed in hours. Output A 6-tuple of  AbstractFloat : (ra_hours, ra_minutes, ra_seconds, dec_degrees, dec_minutes, dec_seconds) If  ra  and  dec  are arrays, also each element of the output 6-tuple are arrays of the same dimension. Example Position of Sirius in the sky is (ra, dec) = (6.7525, -16.7161), with right ascension expressed in hours.  Its sexagesimal representation is given by julia> using AstroLib\n\njulia> radec(6.7525, -16.7161, hours=true)\n(6.0, 45.0, 9.0, -16.0, 42.0, 57.9600000000064) source"},{"id":1506,"pagetitle":"Reference","title":"AstroLib.recpol","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.recpol-Tuple{Real, Real}","content":" AstroLib.recpol  —  Method recpol(x, y[, degrees=false]) -> radius, angle Purpose Convert 2D rectangular coordinates to polar coordinates. Explanation This is the partial inverse function of  polrec . Arguments x : the abscissa coordinate of the point.  It may be a scalar or an array. y : the ordinate coordinate of the point.  It may be a scalar or an array of the same lenth as  x . degrees  (optional boolean keyword): if  true , the output  angle  is given in degrees, otherwise in radians.  It defaults to  false . Mandatory arguments may also be passed as the 2-tuple  (x, y) , so that it is possible to execute  polrec(recpol(x, y)) . Output A 2-tuple  (radius, angle)  with the polar coordinates of the input.  The coordinate  angle  coordinate lies in the range  $[-π, π]$  if  degrees=false , or  $[-180, 180]$  when  degrees=true . If  x  and  y  are arrays,  radius  and  angle  are arrays of the same length as  radius  and  angle . Example Calculate polar coordinates  $(r, φ)$  of point with rectangular coordinates  $(x, y) = (2.24, -1.87)$ . julia> using AstroLib\n\njulia> r, phi = recpol(2.24, -1.87)\n(2.9179616172938263, -0.6956158538564537) Angle  $φ$  is given in radians. source"},{"id":1507,"pagetitle":"Reference","title":"AstroLib.rhotheta","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.rhotheta-NTuple{8, Real}","content":" AstroLib.rhotheta  —  Method rhotheta(period, periastron, eccentricity, semimajor_axis, inclination, omega, omega2, epoch) -> rho, theta Purpose Calculate the separation and position angle of a binary star. Explanation This function will return the separation  $ρ$  and position angle  $θ$  of a visual binary star derived from its orbital elements.  The algorithms described in the following book will be used: Meeus J., 1992, Astronomische Algorithmen, Barth.  Compared to the examples given at page 400 and no discrepancy found. Arguments period : period [year] periastro : time of periastron passage [year] eccentricity : eccentricity of the orbit semimajor_axis : semi-major axis [arc second] inclination : inclination angle [degree] omega : node [degree] omega2 : longitude of periastron [degree] epoch : epoch of observation [year] All input parameters have to be scalars. Output The 2-tuple  $(ρ, θ)$ , where $ρ$  is separation [arc second], and $θ$  is position angle (degree). Example Find the position of Eta Coronae Borealis at the epoch 2016 julia> using AstroLib\n\njulia> ρ, θ = rhotheta(41.623, 1934.008, 0.2763, 0.907, 59.025, 23.717, 219.907, 2016)\n(0.6351167848659552, 214.42513387396497) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1508,"pagetitle":"Reference","title":"AstroLib.sec2rad","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.sec2rad-Tuple{Real}","content":" AstroLib.sec2rad  —  Method sec2rad(sec) -> radians Purpose Convert from seconds to radians. Argument sec : number of seconds. Output The number of radians corresponding to  sec . Example julia> using AstroLib\n\njulia> sec2rad(3600 * 30)\n0.5235987755982988 Notes Use  rad2sec  to convert radians to seconds. source"},{"id":1509,"pagetitle":"Reference","title":"AstroLib.sixty","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.sixty-Tuple{Real}","content":" AstroLib.sixty  —  Method sixty(number) -> [deg, min, sec] Purpose Converts a decimal number to sexagesimal. Explanation The reverse of  ten  function. Argument number : decimal number to be converted to sexagesimal. Output An array of three  AbstractFloat , that are the sexagesimal counterpart (degrees, minutes, seconds) of  number . Example julia> using AstroLib\n\njulia> sixty(-0.615)\n3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):\n -0.0\n 36.0\n 54.0 Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1510,"pagetitle":"Reference","title":"AstroLib.sphdist","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.sphdist-NTuple{4, Real}","content":" AstroLib.sphdist  —  Method sphdist(long1, lat1, long2, lat2[, degrees=true]) -> angular_distance Purpose Angular distance between points on a sphere. Arguments long1 :  longitude of point 1 lat1 : latitude of point 1 long2 : longitude of point 2 lat2 : latitude of point 2 degrees  (optional boolean keyword): if  true , all angles, including the output distance, are assumed to be in degrees, otherwise they are all in radians.  It defaults to  false . Output Angular distance on a sphere between points 1 and 2, as an  AbstractFloat .  It is expressed in radians unless  degrees  keyword is set to  true . Example julia> using AstroLib\n\njulia> sphdist(120, -43, 175, +22)\n1.5904422616007134 Notes gcirc  function is similar to  sphdist , but may be more suitable for astronomical applications. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1511,"pagetitle":"Reference","title":"AstroLib.sunpos","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.sunpos","content":" AstroLib.sunpos  —  Function sunpos(jd[, radians=false]) -> ra, dec, elong, obliquity Purpose Compute the right ascension and declination of the Sun at a given date. Arguments jd : the Julian date of when you want to calculate Sun position.  It can be either a scalar or a vector.  Use  jdcnv  to get the Julian date for a given date and time. radians  (optional boolean keyword): if set to  true , all output quantities are given in radians.  The default is  false , so all quantities are given in degrees. Output The 4-tuple  (ra, dec, elong, obliquity) : ra : the right ascension of the Sun at that date dec : the declination of the Sun at that date elong : ecliptic longitude of the Sun at that date obliquity : the obliquity of the ecliptic All quantities are given in degrees, unless  radians  keyword is set to  true  (see \"Arguments\" section).  If  jd  is an array, arrays of the same given as  jd  are returned. Method Uses a truncated version of Newcomb's Sun.  Adapted from the IDL routine SUN_POS by CD Pike, which was adapted from a FORTRAN routine by B. Emerson (RGO). Example Find the apparent right ascension and declination of the Sun on May 1, 1982 julia> using AstroLib\n\njulia> adstring(sunpos(jdcnv(1982, 5, 1))[1:2], precision=2)\n\" 02 31 32.614  +14 54 34.92\" The Astronomical Almanac gives  02 31 32.58 +14 54 34.9  so the error for this case is < 0.5\". Plot the apparent right ascension, in hours, and declination of the Sun, in degrees, for every day in 2016.  Use  Plots.jl  for plotting. using Plots\nusing Dates\n\ndays = DateTime(2016):Day(1):DateTime(2016, 12, 31);\nra, declin = sunpos(jdcnv.(days));\nplot(days, ra/15); plot(days, declin) Notes Patrick Wallace (Rutherford Appleton Laboratory, UK) has tested the accuracy of a C adaptation of the present algorithm and found the following results.  From 1900-2100  sunpos  gave 7.3 arcsec maximum error, 2.6 arcsec RMS.  Over the shorter interval 1950-2050 the figures were 6.4 arcsec max, 2.2 arcsec RMS. The returned  ra  and  dec  are in the given date's equinox. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1512,"pagetitle":"Reference","title":"AstroLib.ten","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.ten","content":" AstroLib.ten  —  Function ten(deg[, min, sec]) -> decimal\nten(\"deg:min:sec\") -> decimal Purpose Converts a sexagesimal number or string to decimal. Explanation ten  is the inverse of the  sixty  function. Arguments ten  takes as argument either three scalars ( deg ,  min ,  sec ) or a string. The string should have the form  \"deg:min:sec\"  or  \"deg min sec\" .  Also any iterable like  (deg, min, sec)  or  [deg, min, sec]  is accepted as argument. If minutes and seconds are not specified they default to zero. Output The decimal conversion of the sexagesimal numbers provided is returned. Method The formula used for the conversion is \\[\\mathrm{sign}(\\mathrm{deg})·\\left(|\\mathrm{deg}| + \\frac{\\mathrm{min}}{60} + \\frac{\\mathrm{sec}}{3600}\\right)\\] Example julia> using AstroLib\n\njulia> ten(-0.0, 19, 47)\n-0.3297222222222222\n\njulia> ten(\"+5:14:58\")\n5.249444444444444\n\njulia> ten(\"-10 26\")\n-10.433333333333334\n\njulia> ten((-10, 26))\n-10.433333333333334 Notes These functions cannot deal with  -0  (negative integer zero) in numeric input. If it is important to give sense to negative zero, you can either make sure to pass a floating point negative zero  -0.0  (this is the best option), or use negative minutes and seconds, or non-integer negative degrees and minutes. source"},{"id":1513,"pagetitle":"Reference","title":"AstroLib.tic_one","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.tic_one","content":" AstroLib.tic_one  —  Function tic_one(zmin, pixx, incr[, ra=true]) -> min2, tic1 Purpose Determine the position of the first tic mark for astronomical images. Explanation For use in labelling images with right ascension and declination axes. This routine determines the position in pixels of the first tic. Arguments zmin : astronomical coordinate value at axis zero point (degrees  or hours). pixx : distance in pixels between tic marks (usually obtained from  tics ). incr  - increment in minutes for labels (usually an even number obtained  from the procedure  tics ). ra  (optional boolean keyword): if true, incremental value being entered  is in minutes of time, else it is assumed that value is in else it's in minutes of arc.  Default is false. Output The 2 tuple  (min2, tic1) : min2 : astronomical coordinate value at first tic mark tic1 : position in pixels of first tic mark Example Suppose a declination axis has a value of 30.2345 degrees at its zero point.  A tic mark is desired every 10 arc minutes, which corresponds to 12.74 pixels, with increment for labels being 10 minutes. Then julia> using AstroLib\n\njulia> tic_one(30.2345, 12.74, 10)\n(30.333333333333332, 7.554820000000081) yields values of min2 ≈ 30.333 and tic1 ≈ 7.55482, i.e. the first tic mark should be labeled 30 deg 20 minutes and be placed at pixel value 7.55482. Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1514,"pagetitle":"Reference","title":"AstroLib.ticpos","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.ticpos-Tuple{Real, Real, Real}","content":" AstroLib.ticpos  —  Method ticpos(deglen, pixlen, ticsize) -> ticsize, incr, units Purpose Specify distance between tic marks for astronomical coordinate overlays. Explanation User inputs number an approximate distance between tic marks, and the axis length in degrees.  ticpos  will return a distance between tic marks such that the separation is a round multiple in arc seconds, arc minutes, or degrees. Arguments deglen : length of axis in degrees, positive scalar pixlen : length of axis in plotting units (pixels), postive scalar ticsize : distance between tic marks (pixels).  This value will be  adjusted by  ticpos  such that the distance corresponds to a round  multiple in the astronomical coordinate. Output The 3-tuple  (ticsize, incr, units) : ticsize : distance between tic marks (pixels), positive scalar incr : incremental value for tic marks in round units given  by the  units  parameter units : string giving units of ticsize, either 'Arc Seconds', 'Arc Minutes', or 'Degrees' Example Suppose a 512 × 512 image array corresponds to 0.2 × 0.2 degrees on the sky. A tic mark is desired in round angular units, approximately every 75 pixels. Then julia> using AstroLib\n\njulia> ticpos(0.2, 512, 75)\n(85.33333333333333, 2.0, \"Arc Minutes\") i.e. a good tic mark spacing is every 2 arc minutes, corresponding to 85.333 pixels. Notes All the arguments taken as input are assumed to be positive in nature. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1515,"pagetitle":"Reference","title":"AstroLib.tics","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.tics","content":" AstroLib.tics  —  Function tics(radec_min, radec_max, numx, ticsize[, ra=true]) -> ticsize, incr Purpose Compute a nice increment between tic marks for astronomical images. Explanation For use in labelling a displayed image with right ascension or declination axes.  An approximate distance between tic marks is input, and a new value is computed such that the distance between tic marks is in simple increments of the tic label values. Arguements radec_min  : minimum axis value (degrees). radec_min  : maximum axis value (degrees). numx  : number of pixels in x direction. ticsize  : distance between tic marks (pixels). ra  (optional boolean keyword): if true, incremental value would be in minutes of time. Default is false. Output A 2-tuple  (ticsize, incr) : ticsize  : distance between tic marks (pixels). incr  : incremental value for tic labels.  The format is dependent on the optional keyword. If true (i.e for right ascension), it's in minutes of time, else it's in minutes of arc (for declination). Example julia> using AstroLib\n\njulia> tics(55, 60, 100.0, 1/2)\n(0.66, 2.0)\n\njulia> tics(30, 60, 12, 2, true)\n(2.75, 30.0) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1516,"pagetitle":"Reference","title":"AstroLib.true_obliquity","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.true_obliquity-Tuple{Real}","content":" AstroLib.true_obliquity  —  Method true_obliquity(jd) -> t_eps Purpose Return the true obliquity of the ecliptic for a given Julian date Explanation The function is used by the  co_aberration  procedure. Arguments jd : Julian date. Output t_eps : true obliquity of the ecliptic, in radians Example julia> using AstroLib\n\njulia> true_obliquity(jdcnv(1978,01,7,11, 01))\n0.4090953896211926 Notes The function calls  mean_obliquity . source"},{"id":1517,"pagetitle":"Reference","title":"AstroLib.trueanom","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.trueanom-Tuple{Real, Real}","content":" AstroLib.trueanom  —  Method trueanom(E, e) -> true anomaly Purpose Calculate true anomaly for a particle in elliptic orbit with eccentric anomaly  $E$  and eccentricity  $e$ . Explanation In the two-body problem, once that the  Kepler's equation  is solved and  $E(t)$  is determined, the polar coordinates  $(r(t), θ(t))$  of the body at time  $t$  in the elliptic orbit are given by \\[θ(t) = 2 \\arctan \\left( \\sqrt{\\frac{1 + e}{1 - e}} \\tan\\frac{E(t)}{2} \\right)\\] \\[r(t) = \\frac{a(1 - e^2)}{1 + e\\cos(θ(t) - θ_0)}\\] in which  $a$  is the semi-major axis of the orbit, and  $θ_0$  the value of angular coordinate at time  $t = t_0$ . Arguments E : eccentric anomaly. e : eccentricity, in the elliptic motion regime ( $0 ≤ e ≤ 1$ ) Output The true anomaly. Example Plot the true anomaly as a function of mean anomaly for eccentricity  $e = 0, 0.5, 0.9$ . Use  Plots.jl  for plotting. using Plots\nM = range(0, stop=2pi, length=1001)[1:end-1];\np = plot()\nfor ecc in (0, 0.5, 0.9)\n    plot!(p, M, mod2pi.(trueanom.(kepler_solver.(M, ecc), ecc)))\nend\np Notes The eccentric anomaly can be calculated with  kepler_solver  function. source"},{"id":1518,"pagetitle":"Reference","title":"AstroLib.uvbybeta","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.uvbybeta","content":" AstroLib.uvbybeta  —  Function uvbybeta(by, m1, c1, n[, hbeta=NaN, eby_in=NaN]) -> te, mv, eby, delm0, radius Purpose Derive dereddened colors, metallicity, and Teff from Stromgren colors. Arguments by : Stromgren b-y color m1 : Stromgren line-blanketing parameter c1 : Stromgren Balmer discontinuity parameter n : Integer which can be any value between 1 to 8, giving approximate stellar classification. B0 - A0, classes III - V, 2.59 < Hbeta < 2.88,-0.20 <   c0   < 1.00 B0 - A0, class   Ia     , 2.52 < Hbeta < 2.59,-0.15 <   c0   < 0.40 B0 - A0, class   Ib     , 2.56 < Hbeta < 2.61,-0.10 <   c0   < 0.50 B0 - A0, class   II     , 2.58 < Hbeta < 2.63,-0.10 <   c0   < 0.10 A0 - A3, classes III - V, 2.87 < Hbeta < 2.93,-0.01 < (b-y)o < 0.06 A3 - F0, classes III - V, 2.72 < Hbeta < 2.88, 0.05 < (b-y)o < 0.22 F1 - G2, classes III - V, 2.60 < Hbeta < 2.72, 0.22 < (b-y)o < 0.39 G2 - M2, classes  IV - V, 0.20 < m0    < 0.76, 0.39 < (b-y)o < 1.00 hbeta  (optional): H-beta line strength index. If it is not supplied, then by default its value will be  NaN  and the code will estimate a value based on by, m1,and c1. It is not used for stars in group 8. eby_in  (optional): specifies the E(b-y) color to use. If not supplied, then by default its value will be  NaN  and E(b-y) will be estimated from the Stromgren colors. Output te : approximate effective temperature mv : absolute visible magnitude eby : color excess E(b-y) delm0 : metallicity index, delta m0, may not be calculable for early B stars and so returns  NaN . radius : stellar radius (R/R(solar)) Example Determine the stellar parameters of 5 stars given their Stromgren parameters julia> using AstroLib\n\njulia> by = [-0.001, 0.403, 0.244, 0.216, 0.394];\n\njulia> m1 = [0.105, -0.074, -0.053, 0.167, 0.186];\n\njulia> c1 = [0.647, 0.215, 0.051, 0.785, 0.362];\n\njulia> hbeta = [2.75, 2.552, 2.568, 2.743, 0];\n\njulia> nn = [1, 2, 3, 7, 8];\n\njulia> uvbybeta.(by, m1, c1, nn, hbeta)\n5-element Vector{NTuple{5, Float64}}:\n (13057.535222326893, -0.27375469585031265, 0.04954396423248884, -0.008292894218734928, 2.7136529525371897)\n (14025.053834219656, -6.907050783073221, 0.4140562248995983, NaN, 73.50771722263974)\n (18423.76405400214, -5.935816553877892, 0.2828247876690783, NaN, 39.84106215808709)\n (7210.507090112837, 2.2180408083364167, 0.018404079180028038, 0.018750927360588615, 2.0459018065648165)\n (5755.671513413262, 3.9449408311022, -0.025062997393370458, 0.03241423718769865, 1.5339239690774464) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1519,"pagetitle":"Reference","title":"AstroLib.vactoair","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.vactoair-Tuple{Real}","content":" AstroLib.vactoair  —  Method vactoair(wave_vacuum) -> wave_air Purpose Converts vacuum wavelengths to air wavelengths. Explanation Corrects for the index of refraction of air under standard conditions. Wavelength values below  $2000 Å$  will not be altered.  Uses relation of Ciddor (1996). Arguments wave_vacuum : vacuum wavelength in angstroms.  Wavelengths are corrected for the index of refraction of air under standard conditions.  Wavelength values below  $2000 Å$  will  not  be altered, take care within  $[1 Å, 2000 Å]$ . Output Air wavelength in angstroms. Method Uses relation of Ciddor (1996), Applied Optics 35, 1566 ( http://adsabs.harvard.edu/abs/1996ApOpt..35.1566C ). Example If the vacuum wavelength is  w = 2000 , then  vactoair(w)  yields an air wavelength of  1999.353 . julia> using AstroLib\n\njulia> vactoair(2000)\n1999.3526230448367 Notes airtovac  converts air wavelengths to vacuum wavelengths. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1520,"pagetitle":"Reference","title":"AstroLib.xyz","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.xyz","content":" AstroLib.xyz  —  Function xyz(jd[, equinox]) -> x, y, z, v_x, v_y, v_z Purpose Calculate geocentric  $x$ ,  $y$ , and  $z$  and velocity coordinates of the Sun. Explanation Calculates geocentric  $x$ ,  $y$ , and  $z$  vectors and velocity coordinates ( $dx$ ,  $dy$  and  $dz$ ) of the Sun.  (The positive  $x$  axis is directed towards the equinox, the  $y$ -axis, towards the point on the equator at right ascension 6h, and the  $z$  axis toward the north pole of the equator).  Typical position accuracy is  $<10^{-4}$  AU (15000 km). Arguments jd : number of Reduced Julian Days for the wanted date.  It can be either a scalar or a vector. equinox  (optional numeric argument): equinox of output. Default is 1950. You can use  juldate  to get the number of Reduced Julian Days for the selected dates. Output The 6-tuple  $(x, y, z, v_x, v_y, v_z)$ , where $x, y, z$ : scalars or vectors giving heliocentric rectangular coordinates (in AU) for each date supplied.  Note that  $\\sqrt{x^2 + y^2 + z^2}$  gives the Earth-Sun distance for the given date. $v_x, v_y, v_z$ : velocity vectors corresponding to  $x, y$ , and  $z$ . Example What were the rectangular coordinates and velocities of the Sun on 1999-01-22T00:00:00 (= JD 2451200.5) in J2000 coords?  Note: Astronomical Almanac (AA) is in TDT, so add 64 seconds to UT to convert. julia> using AstroLib, Dates\n\njulia> jd = juldate(DateTime(1999, 1, 22))\n51200.5\n\njulia> xyz(jd + 64/86400, 2000)\n(0.514568709240398, -0.7696326261820209, -0.33376880143023935, 0.014947267514079971, 0.008314838205477328, 0.003606857607575486) Compare to Astronomical Almanac (1999 page C20)             x  (AU)        y  (AU)     z (AU)\nxyz:      0.51456871   -0.76963263  -0.33376880\nAA:       0.51453130   -0.7697110   -0.3337152\nabs(err): 0.00003739    0.00007839   0.00005360\nabs(err)\n    (km):   5609          11759         8040 NOTE: Velocities in AA are for Earth/Moon barycenter       (a very minor offset) see AA 1999 page E3            x vel (AU/day) y vel (AU/day)   z vel (AU/day)\nxyz:      -0.014947268   -0.0083148382    -0.0036068576\nAA:       -0.01494574    -0.00831185      -0.00360365\nabs(err):  0.000001583    0.0000029886     0.0000032076\nabs(err)\n (km/sec): 0.00265        0.00519          0.00557 Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1521,"pagetitle":"Reference","title":"AstroLib.ydn2md","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.ydn2md-Tuple{Integer, Integer}","content":" AstroLib.ydn2md  —  Method ydn2md(year, day) -> date Purpose Convert from year and day number of year to a date. Explanation Returns the date corresponding to the  day  of  year . Arguments year : the year, as an integer. day : the day of  year , as an integer. Output The date, of  Date  type, of  $\\text{day} - 1$  days after January 1st of  year . Example Find the date of the 60th and 234th days of the year 2016. julia> using AstroLib\n\njulia> ydn2md.(2016, [60, 234])\n2-element Vector{Dates.Date}:\n 2016-02-29\n 2016-08-21 Note ymd2dn  converts from a date to day of the year. source"},{"id":1522,"pagetitle":"Reference","title":"AstroLib.ymd2dn","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.ymd2dn","content":" AstroLib.ymd2dn  —  Function ymd2dn(date) -> number_of_days Purpose Convert from a date to day of the year. Explanation Returns the day of the year for  date  with January 1st being day 1. Arguments date : the date with  Date  type.  Can be a single date or an array of dates. Output The day of the year for the given  date .  If  date  is an array, returns an array of days. Example Find the days of the year for March 5 in the years 2015 and 2016 (this is a leap year). julia> using AstroLib, Dates\n\njulia> ymd2dn.([Date(2015, 3, 5), Date(2016, 3, 5)])\n2-element Vector{Int64}:\n 64\n 65 Note ydn2md  converts from year and day number of year to a date. source"},{"id":1523,"pagetitle":"Reference","title":"AstroLib.zenpos","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.zenpos","content":" AstroLib.zenpos  —  Function zenpos(jd, latitude, longitude) -> zenith_right_ascension, declination\nzenpos(date, latitude, longitude, tz) -> zenith_right_ascension, declination Purpose Return the zenith right ascension and declination in radians for a given Julian date or a local civil time and timezone. Explanation The local sidereal time is computed with the help of  ct2lst , which is the right ascension of the zenith. This and the observatories latitude (corresponding to the declination) are converted to radians and returned as the zenith direction. Arguments The function can be called in two different ways. The arguments common to both methods are  latitude  and  longitude : latitude  : latitude of the desired location. longitude  : longitude of the desired location. The zenith direction can be computed either by providing the Julian date: jd  : the Julian date of the date and time for which the zenith position is desired. or the time zone and the date: tz : the time zone (in hours) of the desired location (e.g. 4 = EDT, 5 = EST) date : the local civil time with type  DateTime . Output A 2-tuple  (ra, dec) : ra  : the right ascension (in radians) of the zenith. dec  : the declination (in radians) of the zenith. Example julia> using AstroLib, Dates\n\njulia> zenpos(DateTime(2017, 04, 25, 18, 59), 43.16, -24.32, 4)\n(0.946790432684706, 0.7532841051607526)\n\njulia> zenpos(jdcnv(2016, 05, 05, 13, 41), ten(35,0,42), ten(135,46,6))\n(3.5757821152779536, 0.6110688599440813) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1526,"pagetitle":"Introduction","title":"AstroLib.jl","ref":"/previews/PR43/AstroLib/stable/#AstroLib.jl","content":" AstroLib.jl AstroLib  is a package of small generic routines useful above all in astronomical and astrophysical context, written in  Julia . Included are also translations of some  IDL Astronomy User’s Library  procedures, which are released under terms of  BSD-2-Clause License . AstroLib’s functions are not drop-in replacement of those procedures, Julia standard data types are often used (e.g.,  DateTime  type instead of generic string for dates) and the syntax may slightly differ. An extensive error testing suite ensures old fixed bugs will not be brought back by future changes."},{"id":1527,"pagetitle":"Introduction","title":"Installation","ref":"/previews/PR43/AstroLib/stable/#Installation","content":" Installation AstroLib is available for Julia 1.0 and later versions, and can be installed with  Julia 's built-in package manager. In a Julia session run the commands julia> import Pkg\njulia> Pkg.update()\njulia> Pkg.add(\"AstroLib\") Older versions are also available for Julia 0.4-0.6. Note that, in order to work, a few functions require external files, which are automatically downloaded when building the package. Should these files be missing for some reason, you will be able to load the package but some functions may not work properly. You can manually build the package with julia> Pkg.build(\"AstroLib\")"},{"id":1528,"pagetitle":"Introduction","title":"Usage","ref":"/previews/PR43/AstroLib/stable/#Usage","content":" Usage After installing the package, you can start using AstroLib with using AstroLib Many functions in  AstroLib.jl  are compatible with  Measurements.jl  package, which allows you to define quantities with uncertainty and propagate the error when performing calculations according to  propagation of uncertainty rules . For example: julia> using AstroLib, Measurements\n\njulia> mag2flux(12.54 ± 0.03)\n3.499e-14 ± 9.7e-16"},{"id":1529,"pagetitle":"Introduction","title":"How Can I Help?","ref":"/previews/PR43/AstroLib/stable/#How-Can-I-Help?","content":" How Can I Help? AstroLib.jl  is developed on  GitHub . You can contribute to the project in a number of ways: by translating more routines from IDL Astronomy User’s Library, or providing brand-new functions, or even improving existing ones (make them faster and more precise). Also bug reports are encouraged."},{"id":1530,"pagetitle":"Introduction","title":"License","ref":"/previews/PR43/AstroLib/stable/#License","content":" License The  AstroLib.jl  package is licensed under the MIT “Expat” License. The original author is Mosè Giordano."},{"id":1531,"pagetitle":"Introduction","title":"Notes","ref":"/previews/PR43/AstroLib/stable/#Notes","content":" Notes This project is a work-in-progress, only few procedures have been translated so far. In addition, function syntax may change from time to time. Check  TODO.md  out to see how you can help. Volunteers are welcome!"},{"id":1532,"pagetitle":"Introduction","title":"Documentation","ref":"/previews/PR43/AstroLib/stable/#Documentation","content":" Documentation Every function provided has detailed documentation that can be  accessed  at Julia REPL with julia> ?FunctionName or with julia> @doc FunctionName"},{"id":1533,"pagetitle":"Introduction","title":"Related Projects","ref":"/previews/PR43/AstroLib/stable/#Related-Projects","content":" Related Projects This is not the only effort to bundle astronomical functions written in Julia language. Other packages useful for more specific purposes are available at  JuliaAstro . Because of this, some of IDL AstroLib’s utilities are not provided in  AstroLib.jl  as they are already present in other Julia packages. Here is a list of such utilities: aper , see  Photometry.jl  package asinh , already present in Julia with the same name cirrange , it is equivalent to  mod(x, 360) .  To restrict a number to the   range  [0, 2pi)  use  mod2pi(x) cosmo_param , see  Cosmology.jl  package galage , see  Cosmology.jl  package glactc_pm , see  SkyCoords.jl  package glactc , see  SkyCoords.jl  package jplephinterp , see  JPLEphemeris.jl  package jplephread , see  JPLEphemeris.jl  package jplephtest , see  JPLEphemeris.jl  package lumdist , see  Cosmology.jl  package readcol , use  readdlm , part of Julia  Base.DataFmt  module. This is not a complete replacement for  readcol  but most of the time it does-the-right-thing even without using any option (it automatically identifies string and numerical columns) and you do not need to manually specify a variable for each column In addition, there are similar projects for Python ( Python AstroLib ) and R ( Astronomy Users Library )."},{"id":1536,"pagetitle":"Reference","title":"Reference","ref":"/previews/PR43/AstroLib/stable/ref/#Reference","content":" Reference"},{"id":1537,"pagetitle":"Reference","title":"Data types","ref":"/previews/PR43/AstroLib/stable/ref/#Data-types","content":" Data types"},{"id":1538,"pagetitle":"Reference","title":"Observatory","ref":"/previews/PR43/AstroLib/stable/ref/#Observatory","content":" Observatory AstroLib.jl  defines a new  Observatory  type. This can be used to define a new object holding information about an observing site. It is a  composite type  whose fields are name  ( String  type): the name of the site latitude  ( Float64  type): North-ward latitude of the site in degrees longitude  ( Float64  type): East-ward longitude of the site in degrees altitude  ( Float64  type): altitude of the site in meters tz  ( Float64  type): the number of hours of offset from UTC The type constructor  Observatory  can be used to create a new  Observatory  object. Its syntax is Observatory(name, lat, long, alt, tz) name  should be a string;  lat ,  long , and  tz  should be anything that can be converted to a floating number with  ten  function;  alt  should be a real number. A predefined list of some observing sites is provided with  AstroLib.observatories  constant. It is a dictionary whose keys are the abbreviated names of the observatories. For example, you can access information of the European Southern Observatory with julia> obs = AstroLib.observatories[\"eso\"]\nObservatory: European Southern Observatory\nlatitude:    -29.256666666666668°N\nlongitude:   -70.73°E\naltitude:    2347.0 m\ntime zone:   UTC-4\n\njulia> obs.longitude\n-70.73 You can list all keys of the dictionary with keys(AstroLib.observatories) Feel free to contribute new sites or adjust information of already present ones."},{"id":1539,"pagetitle":"Reference","title":"Planet","ref":"/previews/PR43/AstroLib/stable/ref/#Planet","content":" Planet The package provides  Planet  type to hold information about Solar System planets. Its fields are Designation: name : the name Physical characteristics: radius : mean radius in meters eqradius : equatorial radius in meters polradius : polar radius in meters mass : mass in kilogram Orbital characteristics (epoch J2000): ecc : eccentricity of the orbit axis : semi-major axis of the orbit in meters period : sidereal orbital period in seconds The constructor has this syntax: Planet(name, radius, eqradius, polradius, mass, ecc, axis, period) The list of Solar System planets, from Mercury to Pluto, is available with  AstroLib.planets  dictionary. The keys of this dictionary are the lowercase names of the planets. For example: julia> AstroLib.planets[\"mercury\"]\nPlanet:                      Mercury\nmean radius:                 2.4397e6 m\nequatorial radius:           2.4397e6 m\npolar radius:                2.4397e6 m\nmass:                        3.3011e23 kg\neccentricity:                0.20563593\nsemi-major axis:             5.790922654152439e10 m\nperiod:                      7.60053024e6 s\ninclination:                 7.00497902 °\nlongitude of ascending node: 48.33076593 °\nlongitude of perihelion:     77.45779628 °\nmean longitude:              252.2503235 °\n\njulia> AstroLib.planets[\"mars\"].eqradius\n3.3962e6\n\njulia> AstroLib.planets[\"saturn\"].mass\n5.6834e26"},{"id":1540,"pagetitle":"Reference","title":"Functions organized by category","ref":"/previews/PR43/AstroLib/stable/ref/#Functions-organized-by-category","content":" Functions organized by category"},{"id":1541,"pagetitle":"Reference","title":"Coordinates and positions","ref":"/previews/PR43/AstroLib/stable/ref/#Coordinates-and-positions","content":" Coordinates and positions adstring() aitoff() altaz2hadec() baryvel() bprecess() co_aberration() co_nutate() co_refract() eci2geo() eq2hor() eqpole() euler() gcirc() geo2eci() geo2geodetic() geo2mag() geodetic2geo() hadec2altaz() helio_rv() helio() hor2eq() jprecess() mag2geo() mean_obliquity() planet_coords() polrec() posang() precess() precess_cd() precess_xyz() premat() radec() recpol() true_obliquity() zenpos()"},{"id":1542,"pagetitle":"Reference","title":"Time and date","ref":"/previews/PR43/AstroLib/stable/ref/#Time-and-date","content":" Time and date ct2lst() daycnv() get_date() get_juldate() helio_jd() jdcnv() juldate() month_cnv() nutate() ydn2md() ymd2dn()"},{"id":1543,"pagetitle":"Reference","title":"Moon and sun","ref":"/previews/PR43/AstroLib/stable/ref/#Moon-and-sun","content":" Moon and sun moonpos() mphase() sunpos() xyz()"},{"id":1544,"pagetitle":"Reference","title":"Utilities","ref":"/previews/PR43/AstroLib/stable/ref/#Utilities","content":" Utilities airtovac() calz_unred() deredd() flux2mag() gal_uvw() imf() ismeuv() kepler_solver() lsf_rotate() mag2flux() paczynski() planck_freq() planck_wave() rad2sec() rhotheta() sec2rad() sixty() sphdist() ten() tic_one() ticpos() tics() trueanom() uvbybeta() vactoair()"},{"id":1545,"pagetitle":"Reference","title":"Miscellaneous (non-astronomy) functions","ref":"/previews/PR43/AstroLib/stable/ref/#Miscellaneous-(non-astronomy)-functions","content":" Miscellaneous (non-astronomy) functions ordinal()"},{"id":1546,"pagetitle":"Reference","title":"Types and functions organized alphabetically","ref":"/previews/PR43/AstroLib/stable/ref/#Types-and-functions-organized-alphabetically","content":" Types and functions organized alphabetically"},{"id":1547,"pagetitle":"Reference","title":"AstroLib.POLELATLONG","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.POLELATLONG","content":" AstroLib.POLELATLONG  —  Constant List of locations of North Magnetic Pole since 1590. This is provided by World Magnetic Model (https://www.ngdc.noaa.gov/geomag/data/poles/NP.xy). source"},{"id":1548,"pagetitle":"Reference","title":"AstroLib.observatories","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.observatories","content":" AstroLib.observatories  —  Constant List of observing sites.  The observatories have  Observatory  type. source"},{"id":1549,"pagetitle":"Reference","title":"AstroLib.planets","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.planets","content":" AstroLib.planets  —  Constant List of planets of the Solar System, from Mercury to Pluto.  The elements of the list have  Planet  type. Reference for most quantities is the Planetary Fact Sheet: http://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html and the Keplerian Elements for Approximate Positions of the Major Planets: https://ssd.jpl.nasa.gov/txt/p elem t1.txt source"},{"id":1550,"pagetitle":"Reference","title":"AstroLib.Observatory","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.Observatory","content":" AstroLib.Observatory  —  Type Type holding information about an observing site.  Its fields are: name : the name of the site latitude : North-ward latitude of the site in degrees longitude : East-ward longitude of the site in degrees altitude : altitude of the site in meters tz : the number of hours of offset from UTC source"},{"id":1551,"pagetitle":"Reference","title":"AstroLib.Planet","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.Planet","content":" AstroLib.Planet  —  Type Type holding information about a planet.  Its fields are: Designation: name : the name Physical characteristics: radius : mean radius in meters eqradius : equatorial radius in meters polradius : polar radius in meters mass : mass in kilogram Orbital characteristics (epoch J2000): ecc : eccentricity of the orbit axis : semi-major axis of the orbit in meters period : sidereal orbital period in seconds Position characteristics (epoch J2000): inc : inclination in degrees asc_long : longitude of the ascending node in degrees per_long : longitude of perihelion in degrees mean_long : mean longitude in degrees source"},{"id":1552,"pagetitle":"Reference","title":"AstroLib.adstring","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.adstring-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractFloat","content":" AstroLib.adstring  —  Method adstring(ra::Real, dec::Real[, precision::Int=2, truncate::Bool=true]) -> string\nadstring([ra, dec]) -> string\nadstring(dec) -> string\nadstring([ra], [dec]) -> [\"string1\", \"string2\", ...] Purpose Returns right ascension and declination as string(s) in sexagesimal format. Explanation Takes right ascension and declination expressed in decimal format, converts them to sexagesimal and return a formatted string.  The precision of right ascension and declination can be specified. Arguments Arguments of this function are: ra : right ascension in decimal degrees.  It is converted to hours before printing. dec : declination in decimal degrees. The function can be called in different ways: Two numeric arguments: first is  ra , the second is  dec . An iterable (array, tuple) of two elements:  (ra, dec) . One numeric argument: it is assumed only  dec  is provided. Optional keywords affecting the output format are always available: precision  (optional integer keyword): specifies the number of digits of declination seconds.  The number of digits for right ascension seconds is always assumed to be one more  precision .  If the function is called with only  dec  as input,  precision  default to 1, in any other case defaults to 0. truncate  (optional boolean keyword): if true, then the last displayed digit in the output is truncated in precision rather than rounded.  This option is useful if  adstring  is used to form an official IAU name (see http://vizier.u-strasbg.fr/Dic/iau-spec.htx) with coordinate specification. Output The function returns one string.  The format of strings can be specified with  precision  and  truncate  keywords, see above. Example julia> using AstroLib\n\njulia> adstring(30.4, -1.23, truncate=true)\n\" 02 01 35.9  -01 13 48\"\n\njulia> adstring.([30.4, -15.63], [-1.23, 48.41], precision=1)\n2-element Vector{String}:\n \" 02 01 36.00  -01 13 48.0\"\n \" 22 57 28.80  +48 24 36.0\" source"},{"id":1553,"pagetitle":"Reference","title":"AstroLib.airtovac","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.airtovac-Tuple{Real}","content":" AstroLib.airtovac  —  Method airtovac(wave_air) -> wave_vacuum Purpose Converts air wavelengths to vacuum wavelengths. Explanation Wavelengths are corrected for the index of refraction of air under standard conditions. Wavelength values below  $2000 Å$  will  not  be altered, take care within  $[1 Å, 2000 Å]$ .  Uses relation of Ciddor (1996). Arguments wave_air : the wavelength in air. Output Vacuum wavelength in angstroms. Method Uses relation of Ciddor (1996), Applied Optics 62, 958. Example If the air wavelength is  w = 6056.125  (a Krypton line), then  airtovac(w)  yields a vacuum wavelength of  6057.8019 . julia> using AstroLib\n\njulia> airtovac(6056.125)\n6057.801930991426 Notes vactoair  converts vacuum wavelengths to air wavelengths. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1554,"pagetitle":"Reference","title":"AstroLib.aitoff","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.aitoff-Tuple{Real, Real}","content":" AstroLib.aitoff  —  Method aitoff(l, b) -> x, y Purpose Convert longitude  l  and latitude  b  to  (x, y)  using an Aitoff projection. Explanation This function can be used to create an all-sky map in Galactic coordinates with an equal-area Aitoff projection.  Output map coordinates are zero longitude centered. Arguments l : longitude, scalar or vector, in degrees. b : latitude, number of elements as  l , in degrees. Coordinates can be given also as a 2-tuple  (l, b) . Output 2-tuple  (x, y) . x : x coordinate, same number of elements as  l .   x  is normalized to be in  $[-180, 180]$ . y : y coordinate, same number of elements as  l .   y  is normalized to be in  $[-90, 90]$ . Example Get  $(x ,y)$  Aitoff coordinates of Sirius, whose Galactic coordinates are  $(227.23, -8.890)$ . julia> using AstroLib\n\njulia> x, y = aitoff(227.23, -8.890)\n(-137.92196683723276, -11.772527357473054) Notes See  AIPS memo No. 46 , page 4, for details of the algorithm.  This version of  aitoff  assumes the projection is centered at  b=0  degrees. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1555,"pagetitle":"Reference","title":"AstroLib.altaz2hadec","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.altaz2hadec-Tuple{Real, Real, Real}","content":" AstroLib.altaz2hadec  —  Method altaz2hadec(alt, az, lat) -> ha, dec Purpose Convert Horizon (Alt-Az) coordinates to Hour Angle and Declination. Explanation Can deal with the NCP singularity.  Intended mainly to be used by program  hor2eq . Arguments Input coordinates may be either a scalar or an array, of the same dimension. alt : local apparent altitude, in degrees, scalar or array. az : the local apparent azimuth, in degrees, scalar or vector, measured  east  of  north !!!  If you have measured azimuth west-of-south (like the book Meeus does), convert it to east of north via:  az = (az + 180) % 360 . lat : the local geodetic latitude, in degrees, scalar or array. alt  and  az  can be given as a 2-tuple  (alt, az) . Output 2-tuple  (ha, dec) ha : the local apparent hour angle, in degrees.  The hour angle is the time that right ascension of 0 hours crosses the local meridian.  It is unambiguously defined. dec : the local apparent declination, in degrees. The output coordinates are always floating points and have the same type (scalar or array) as the input coordinates. Example Arcturus is observed at an apparent altitude of 59d,05m,10s and an azimuth (measured east of north) of 133d,18m,29s while at the latitude of +43.07833 degrees.  What are the local hour angle and declination of this object? julia> using AstroLib\n\njulia> ha, dec = altaz2hadec(ten(59,05,10), ten(133,18,29), 43.07833)\n(336.6828582472844, 19.182450965120402) The widely available XEPHEM code gets: Hour Angle = 336.683\nDeclination = 19.1824 Notes hadec2altaz  converts Hour Angle and Declination to Horizon (Alt-Az) coordinates. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1556,"pagetitle":"Reference","title":"AstroLib.baryvel","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.baryvel-Tuple{Real}","content":" AstroLib.baryvel  —  Method baryvel(dje, deq) -> dvelh, dvelb Purpose Calculates heliocentric and barycentric velocity components of Earth. Explanation Baryvel takes into account the Earth-Moon motion, and is useful for radial velocity work to an accuracy of ~1 m/s. Arguments dje : julian ephemeris date deq  (optional): epoch of mean equinox of  dvelh  and  dvelb . If  deq  is not provided, then it is assumed to be equal to  dje . Output dvelh : heliocentric velocity component. in km/s dvelb : barycentric velocity component. in km/s Example Compute the radial velocity of the Earth toward Altair on 15-Feb-1994 using both the original Stumpf algorithm. julia> using AstroLib\n\njulia> jd = jdcnv(1994, 2, 15, 0)\n2.4493985e6\n\njulia> baryvel(jd, 2000)\n([-17.0724258266945, -22.81120895274765, -9.889315408506354], [-17.080834081384847, -22.80470807516409, -9.886258269159352]) Notes The 3-vectors outputs  dvelh  and  dvelb  are given in a right-handed coordinate system with the +X axis toward the Vernal Equinox, and +Z axis toward the celestial pole. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1557,"pagetitle":"Reference","title":"AstroLib.bprecess","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.bprecess","content":" AstroLib.bprecess  —  Function bprecess(ra, dec[, epoch]) -> ra1950, dec1950\nbprecess(ra, dec, muradec[, parallax=parallax, radvel=radvel]) -> ra1950, dec1950 Purpose Precess positions from J2000.0 (FK5) to B1950.0 (FK4). Explanation Calculates the mean place of a star at B1950.0 on the FK4 system from the mean place at J2000.0 on the FK5 system. bprecess  function has two methods, one for each of the following cases: the proper motion is known and non-zero the proper motion is unknown or known to be exactly zero (i.e. extragalactic radio sources).  Better precision can be achieved in this case by inputting the epoch of the original observations. Arguments The function has 2 methods.  The common mandatory arguments are: ra : input J2000 right ascension, in degrees. dec : input J2000 declination, in degrees. The two methods have a different third argument (see \"Explanation\" section for more details).  It can be one of the following: muradec : 2-element vector containing the proper motion in seconds of arc per tropical  century  in right ascension and declination. epoch : scalar giving epoch of original observations. If none of these two arguments is provided (so  bprecess  is fed only with right ascension and declination), it is assumed that proper motion is exactly zero and  epoch = 2000 . If it is used the method involving  muradec  argument, the following keywords are available: parallax  (optional numerical keyword): stellar parallax, in seconds of arc. radvel  (optional numerical keyword): radial velocity in km/s. Right ascension and declination can be passed as the 2-tuple  (ra, dec) .  You can also pass  ra ,  dec ,  parallax , and  radvel  as arrays, all of the same length N.  In that case,  muradec  should be a matrix 2×N. Output The 2-tuple of right ascension and declination in 1950, in degrees, of input coordinates is returned.  If  ra  and  dec  (and other possible optional arguments) are arrays, the 2-tuple of arrays  (ra1950, dec1950)  of the same length as the input coordinates is returned. Method The algorithm is taken from the Explanatory Supplement to the Astronomical Almanac 1992, page 186.  See also Aoki et al (1983), A&A, 128, 263.  URL: http://adsabs.harvard.edu/abs/1983A%26A...128..263A. Example The SAO2000 catalogue gives the J2000 position and proper motion for the star HD 119288.  Find the B1950 position. RA(2000) = 13h 42m 12.740s Dec(2000) = 8d 23' 17.69'' Mu(RA) = -.0257 s/yr Mu(Dec) = -.090 ''/yr julia> using AstroLib\n\njulia> muradec = 100*[-15*0.0257, -0.090]; # convert to century proper motion\n\njulia> ra = ten(13, 42, 12.74)*15;\n\njulia> decl = ten(8, 23, 17.69);\n\njulia> adstring(bprecess(ra, decl, muradec), precision=2)\n\" 13 39 44.526  +08 38 28.63\" Notes \"When transferring individual observations, as opposed to catalog mean place, the safest method is to transform the observations back to the epoch of the observation, on the FK4 system (or in the system that was used to to produce the observed mean place), convert to the FK5 system, and transform to the the epoch and equinox of J2000.0\" – from the Explanatory Supplement (1992), p. 180 jprecess  performs the precession to J2000 coordinates. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1558,"pagetitle":"Reference","title":"AstroLib.calz_unred","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.calz_unred","content":" AstroLib.calz_unred  —  Function calz_unred(wave, flux, ebv[, r_v]) -> deredden_wave Purpose Deredden a galaxy spectrum using the Calzetti et al. (2000) recipe. Explanation Calzetti et al.  (2000, ApJ 533, 682; http://adsabs.harvard.edu/abs/2000ApJ...533..682C) developed a recipe for dereddening the spectra of galaxies where massive stars dominate the radiation output, valid between  $0.12$  to  $2.2$  microns.  ( calz_unred  extrapolates between  $0.12$  and  $0.0912$  microns.) Arguments wave : wavelength (Angstroms) flux : calibrated flux. ebv : color excess E(B-V).  If a negative  ebv  is supplied, then fluxes will be reddened rather than deredenned.  Note that the supplied color excess should be that derived for the stellar continuum, EBV(stars), which is related to the reddening derived from the gas, EBV(gas), via the Balmer decrement by EBV(stars) = 0.44*EBV(gas). r_v  (optional): ratio of total to selective extinction, default is 4.05.  Calzetti et al. (2000) estimate  $r_v = 4.05 ± 0.80$  from optical-IR observations of 4 starbursts. Output Unreddened flux, same units as  flux .  Flux values will be left unchanged outside valid domain ( $0.0912$  -  $2.2$  microns). Example Estimate how a flat galaxy spectrum (in wavelength) between  $1200 Å$  and  $3200 Å$  is altered by a reddening of E(B-V) = 0.1. wave = collect(1200:50:3150);\nflux = ones(size(wave));\nflux_new = calz_unred.(wave, flux, -0.1); Using a plotting tool you can visualize the unreddend flux.  For example, with  Plots.jl using Plots\nplot(wave, flux_new) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1559,"pagetitle":"Reference","title":"AstroLib.co_aberration","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.co_aberration","content":" AstroLib.co_aberration  —  Function co_aberration(jd, ra, dec[, eps=NaN]) -> d_ra, d_dec Purpose Calculate changes to right ascension and declination due to the effect of annual aberration Explanation With reference to Meeus, Chapter 23 Arguments jd : julian date, scalar or vector ra : right ascension in degrees, scalar or vector dec : declination in degrees, scalar or vector eps  (optional): true obliquity of the ecliptic (in radians). It will be calculated if no argument is specified. Output The 2-tuple  (d_ra, d_dec) : d_ra : correction to right ascension due to aberration, in arc seconds d_dec : correction to declination due to aberration, in arc seconds Example Compute the change in RA and Dec of Theta Persei (RA = 2h46m,11.331s, Dec = 49d20',54.5'') due to aberration on 2028 Nov 13.19 TD julia> using AstroLib\n\njulia> jd = jdcnv(2028,11,13,4, 56)\n2.4620887055555554e6\n\njulia> co_aberration(jd,ten(2,46,11.331)*15,ten(49,20,54.54))\n(30.04404628365077, 6.699400463119431) d_ra = 30.04404628365103'' (≈ 2.003s) d_dec = 6.699400463118504'' Notes Code of this function is based on IDL Astronomy User's Library. The output d ra is  not  multiplied by cos(dec), so that apparent ra = ra + d_ra/3600. These formula are from Meeus, Chapters 23.  Accuracy is much better than 1 arcsecond. The maximum deviation due to annual aberration is 20.49'' and occurs when the Earth's velocity is perpendicular to the direction of the star. This function calls  true_obliquity  and  sunpos . source"},{"id":1560,"pagetitle":"Reference","title":"AstroLib.co_nutate","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.co_nutate-Tuple{Real, Real, Real}","content":" AstroLib.co_nutate  —  Method co_nutate(jd, ra, dec) -> d_ra, d_dec, eps, d_psi, d_eps Purpose Calculate changes in RA and Dec due to nutation of the Earth's rotation Explanation Calculates necessary changes to ra and dec due to the nutation of the Earth's rotation axis, as described in Meeus, Chap 23. Uses formulae from Astronomical Almanac, 1984, and does the calculations in equatorial rectangular coordinates to avoid singularities at the celestial poles. Arguments jd : julian date, scalar or vector ra : right ascension in degrees, scalar or vector dec : declination in degrees, scalar or vector Output The 5-tuple  (d_ra, d_dec, eps, d_psi, d_eps) : d_ra : correction to right ascension due to nutation, in degrees d_dec : correction to declination due to nutation, in degrees eps : the true obliquity of the ecliptic d_psi : nutation in the longitude of the ecliptic d_eps : nutation in the obliquity of the ecliptic Example Example 23a in Meeus: On 2028 Nov 13.19 TD the mean position of Theta Persei is 2h 46m 11.331s 49d 20' 54.54''. Determine the shift in position due to the Earth's nutation. julia> using AstroLib\n\njulia> jd = jdcnv(2028,11,13,4,56)\n2.4620887055555554e6\n\njulia> co_nutate(jd,ten(2,46,11.331) * 15,ten(49,20,54.54))\n(0.004400660977140092, 0.00172668646508356, 0.40904016038217555, 14.859389427896472, 2.703809037235057) Notes Code of this function is based on IDL Astronomy User's Library. The output of  d_ra  and  d_dec  in IDL AstroLib is in arcseconds, however it is in degrees here. This function calls  mean_obliquity  and  nutate . source"},{"id":1561,"pagetitle":"Reference","title":"AstroLib.co_refract","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.co_refract","content":" AstroLib.co_refract  —  Function co_refract(old_alt[, altitude=0, pressure=NaN, temperature=NaN,\n           epsilon=0.25, to_observe=false]) -> aout Purpose Calculate correction to altitude due to atmospheric refraction. Explanation Because the index of refraction of air is not precisely 1.0, the atmosphere bends all incoming light, making a star or other celestial object appear at a slightly different altitude (or elevation) than it really is.  It is important to understand the following definitions: Observed Altitude: The altitude that a star is seen to be, with a telescope. This is where it appears in the sky. This is should be always greater than the apparent altitude. Apparent Altitude: The altitude that a star would be at, if ~there were no atmosphere~ (sometimes called the \"true\" altitude). This is usually calculated from an object's celestial coordinates. Apparent altitude should always be smaller than the observed altitude. Thus, for example, the Sun's apparent altitude when you see it right on the horizon is actually -34 arcminutes. This program uses a couple of simple formulae to estimate the effect for most optical and radio wavelengths. Typically, you know your observed altitude (from an observation), and want the apparent altitude. To go the other way, this program uses an iterative approach. Arguments old_alt : observed altitude in degrees. If  to_observe  is set to true, this should be apparent altitude altitude  (optional): the height of the observing location, in meters. This is only used to determine an approximate temperature and pressure, if these are not specified separately. Default is 0 i.e. sea level pressure  (optional): the pressure at the observing location, in millibars. Default is NaN temperature  (optional): the temperature at the observing location, in Kelvins. Default is NaN epsilon  (optional): the accuracy to obtain, in arcseconds. If  to_observe  is true, then it will be calculated. Default is 0.25 arcseconds to_observe  (optional boolean keyword): if set to true, it is assumed that  old_alt  has apparent altitude as its input and the observed altitude will be found Output aout : apparent altitude, in degrees. Observed altitude is returned if  to_observe  is set to true Example The lower limb of the Sun is observed to have altitude of 0d 30'. Calculate the the true (i.e. apparent) altitude of the Sun's lower limb using mean  conditions of air pressure and temperature. julia> using AstroLib\n\njulia> co_refract(0.5)\n0.02584736873098442 Notes If altitude is set but the temperature or pressure is not, the program will make an intelligent guess for the temperature and pressure. Wavelength Dependence This correction is 0 at zenith, about 1 arcminute at 45 degrees, and 34 arcminutes at the horizon for optical wavelengths. The correction is non-negligible at all wavelengths, but is not very easily calculable. These formulae assume a wavelength of 550 nm, and will be accurate to about 4 arcseconds for all visible wavelengths, for elevations of 10 degrees and higher. Amazingly, they are also accurate for radio frequencies less than ~ 100 GHz. References Meeus, Astronomical Algorithms, Chapter 15. Explanatory Supplement to the Astronomical Almanac, 1992. Methods of Experimental Physics, Vol 12 Part B, Astrophysics, Radio Telescopes, Chapter 2.5, \"Refraction Effects in the Neutral Atmosphere\", by R.K. Crane. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1562,"pagetitle":"Reference","title":"AstroLib.co_refract_forward","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.co_refract_forward-Tuple{Real, Real, Real}","content":" AstroLib.co_refract_forward  —  Method co_refract_forward(alt, pre, temp) -> ref Purpose A function used by  co_refract  to find apparent (or observed) altitude Arguments alt : the observed (or apparent) altitude, in degrees pre : pressure, in millibars temp : temperature, in Kelvins Output ref : the atmospheric refraction, in minutes of arc Notes The atmospheric refraction is calculated by Saemundsson's formula Code of this function is based on IDL Astronomy User's Library. source"},{"id":1563,"pagetitle":"Reference","title":"AstroLib.ct2lst","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.ct2lst","content":" AstroLib.ct2lst  —  Function ct2lst(longitude, jd) -> local_sidereal_time\nct2lst(longitude, tz, date) -> local_sidereal_time Purpose Convert from Local Civil Time to Local Mean Sidereal Time. Arguments The function can be called in two different ways.  The only argument common to both methods is  longitude : longitude : the longitude in degrees (east of Greenwich) of the place for which the local sidereal time is desired.  The Greenwich mean sidereal time (GMST) can be found by setting longitude =  0 . The civil date to be converted to mean sidereal time can be specified either by providing the Julian days: jd : this is number of Julian days for the date to be converted. or the time zone and the date: tz : the time zone of the site in hours, positive East of the Greenwich meridian (ahead of GMT).  Use this parameter to easily account for Daylight Savings time (e.g. -4=EDT, -5 = EST/CDT). date : this is the local civil time with type  DateTime . Output The local sidereal time for the date/time specified in hours. Method The Julian days of the day and time is question is used to determine the number of days to have passed since 2000-01-01.  This is used in conjunction with the GST of that date to extrapolate to the current GST; this is then used to get the LST.  See Astronomical Algorithms by Jean Meeus, p. 84 (Eq. 11-4) for the constants used. Example Find the Greenwich mean sidereal time (GMST) on 2008-07-30 at 15:53 in Baltimore, Maryland (longitude=-76.72 degrees).  The timezone is EDT or tz=-4 julia> using AstroLib, Dates\n\njulia> lst = ct2lst(-76.72, -4, DateTime(2008, 7, 30, 15, 53))\n11.356505172312609\n\njulia> sixty(lst)\n3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):\n 11.0\n 21.0\n 23.418620325392112 Find the Greenwich mean sidereal time (GMST) on 2015-11-24 at 13:21 in Heidelberg, Germany (longitude=08° 43' E).  The timezone is CET or tz=1. Provide  ct2lst  only with the longitude of the place and the number of Julian days. julia> using AstroLib, Dates\n\njulia> longitude = ten(8, 43); # Convert longitude to decimals.\n\njulia> # Get number of Julian days. Remember to subtract the time zone in\n       # order to convert local time to UTC.\n\njulia> jd = jdcnv(DateTime(2015, 11, 24, 13, 21) - Dates.Hour(1));\n\njulia> lst = ct2lst(longitude, jd) # Calculate Greenwich Mean Sidereal Time.\n17.140685171005316\n\njulia> sixty(lst)\n3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):\n 17.0\n  8.0\n 26.466615619137883 Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1564,"pagetitle":"Reference","title":"AstroLib.daycnv","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.daycnv","content":" AstroLib.daycnv  —  Function daycnv(julian_days) -> DateTime Purpose Converts Julian days number to Gregorian calendar dates. Explanation Takes the number of Julian calendar days since epoch  -4713-11-24T12:00:00  and returns the corresponding proleptic Gregorian Calendar date. Argument julian_days : Julian days number. Output Proleptic Gregorian Calendar date, of type  DateTime , corresponding to the given Julian days number. Example julia> using AstroLib\n\njulia> daycnv(2440000)\n1968-05-23T12:00:00 Notes jdcnv  is the inverse of this function. source"},{"id":1565,"pagetitle":"Reference","title":"AstroLib.deredd","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.deredd-NTuple{5, Real}","content":" AstroLib.deredd  —  Method deredd(Eby, by, m1, c1, ub) -> by0, m0, c0, ub0 Purpose Deredden stellar Stromgren parameters given for a value of E(b-y) Arguments Eby : color index E(b-y), scalar (E(b-y) = 0.73*E(B-V)) by : b-y color (observed) m1 : Stromgren line blanketing parameter (observed) c1 : Stromgren Balmer discontinuity parameter (observed) ub : u-b color (observed) All arguments can be either scalars or arrays all of the same length. Output The 4-tuple  (by0, m0, c0, ub0) . by0 : b-y color (dereddened) m0 : line blanketing index (dereddened) c0 : Balmer discontinuity parameter (dereddened) ub0 : u-b color (dereddened) These are scalars or arrays of the same length as the input arguments. Example julia> using AstroLib\n\njulia> deredd(0.5, 0.2, 1.0, 1.0, 0.1)\n(-0.3, 1.165, 0.905, -0.665) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1566,"pagetitle":"Reference","title":"AstroLib.eci2geo","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.eci2geo-NTuple{4, Real}","content":" AstroLib.eci2geo  —  Method eci2geo(x, y, z, jd) -> latitude, longitude, altitude Purpose Convert Earth-centered inertial coordinates to geographic spherical coordinates. Explanation Converts from ECI (Earth-Centered Inertial) (x, y, z) rectangular coordinates to geographic spherical coordinates (latitude, longitude, altitude).  Julian day is also needed as input. ECI coordinates are in km from Earth center at the supplied time (True of Date). Geographic coordinates assume the Earth is a perfect sphere, with radius equal to its equatorial radius. Arguments x : ECI x coordinate at  jd , in kilometers. y : ECI y coordinate at  jd , in kilometers. z : ECI z coordinate at  jd , in kilometers. jd : Julian days. The three coordinates can be passed as a 3-tuple  (x, y, z) .  In addition,  x ,  y ,  z , and  jd  can be given as arrays of the same length. Output The 3-tuple of geographical coordinate (latitude, longitude, altitude). latitude : latitude, in degrees. longitude : longitude, in degrees. altitude : altitude, in kilometers. If ECI coordinates are given as arrays, a 3-tuple of arrays of the same length is returned. Example Obtain the geographic direction of the vernal point on 2015-06-30T14:03:12.857, in geographic coordinates, at altitude 600 km.  Note: equatorial radii of Solar System planets in meters are stored into  AstroLib.planets  dictionary. julia> using AstroLib\n\njulia> x = AstroLib.planets[\"earth\"].eqradius*1e-3 + 600;\n\njulia> lat, long, alt = eci2geo(x, 0, 0, jdcnv(\"2015-06-30T14:03:12.857\"))\n(0.0, 230.87301833205856, 600.0) These coordinates can be further transformed into geodetic coordinates using  geo2geodetic  or into geomagnetic coordinates using  geo2mag . Notes geo2eci  converts geographic spherical coordinates to Earth-centered inertial coordinates. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1567,"pagetitle":"Reference","title":"AstroLib.eq2hor","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.eq2hor","content":" AstroLib.eq2hor  —  Function eq2hor(ra, dec, jd[, obsname; ws=false, B1950=false, precession=true, nutate=true,\n       aberration=true, refract=true, pressure=NaN, temperature=NaN]) -> alt, az, ha\n\neq2hor(ra, dec, jd, lat, lon[, altitude=0; ws=false, B1950=false,\n       precession=true, nutate=true, aberration=true, refract=true,\n       pressure=NaN, temperature=NaN]) -> alt, az, ha Purpose Convert celestial  (ra-dec) coords to local horizon coords (alt-az). Explanation This code calculates horizon (alt,az) coordinates from equatorial (ra,dec) coords. It performs precession, nutation, aberration, and refraction corrections. Arguments This function has two base methods.  With one you can specify the name of the observatory, if present in  AstroLib.observatories , with the other one you can provide the coordinates of the observing site and, optionally, the altitude. Common mandatory arguments: ra : right ascension of object, in degrees dec : declination of object, in degrees jd : julian date Other positional arguments: obsname : set this to a valid observatory name in  AstroLib.observatories . or lat : north geodetic latitude of location, in degrees. lon : AST longitude of location, in degrees. You can specify west longitude with a negative sign. altitude : the altitude of the observing location, in meters.  It is  0  by default Optional keyword arguments: ws  (optional boolean keyword): set this to  true  to get the azimuth measured westward from south (not East of North) B1950  (optional boolean keyword): set this to  true  if the ra and dec are specified in B1950 (FK4 coordinates) instead of J2000 (FK5). This is  false  by default precession  (optional boolean keyword): set this to  false  for no precession correction,  true  by default nutate  (optional boolean keyword): set this to  false  for no nutation,  true  by default aberration  (optional boolean keyword): set this to  false  for no aberration correction,  true  by default refract  (optional boolean keyword): set this to  false  for no refraction correction,  true  by default pressure  (optional keyword): the pressure at the observing location, in millibars. Default value is  NaN temperature  (optional keyword): the temperature at the observing location, in Kelvins. Default value is  NaN Output alt : altitude of horizon coords, in degrees az : azimuth angle measured East from North (unless ws is  true ), in degrees ha : hour angle, in degrees Example julia> using AstroLib\n\njulia> alt_o, az_o = eq2hor(ten(6,40,58.2)*15, ten(9,53,44), 2460107.25, ten(50,31,36),\n                            ten(6,51,18), 369, pressure = 980, temperature=283)\n(16.423991509721567, 265.60656932130564, 76.11502253130612)\n\njulia> adstring(az_o, alt_o)\n\" 17 42 25.6  +16 25 26\" Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1568,"pagetitle":"Reference","title":"AstroLib.eqpole","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.eqpole-Tuple{Real, Real}","content":" AstroLib.eqpole  —  Method eqpole(l, b[; southpole = false]) -> x, y Purpose Convert right ascension  $l$  and declination  $b$  to coordinate  $(x, y)$  using an equal-area polar projection. Explanation The output  $x$  and  $y$  coordinates are scaled to be in the range  $[-90, 90]$  and to go from equator to pole to equator.  Output map points can be centered on the north pole or south pole. Arguments l : longitude, scalar or vector, in degrees b : latitude, same number of elements as right ascension, in degrees southpole  (optional boolean keyword): keyword to indicate that the plot is to be centered on the south pole instead of the north pole.  Default is  false . Output The 2-tuple  $(x, y)$ : $x$  coordinate, same number of elements as right ascension, normalized to be in the range  $[-90, 90]$ . $y$  coordinate, same number of elements as declination, normalized to be in the range  $[-90, 90]$ . Example julia> using AstroLib\n\njulia> eqpole(100, 35, southpole=true)\n(-111.18287262822456, -19.604540237028665)\n\njulia> eqpole(80, 19)\n(72.78853915267848, 12.83458333897169) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1569,"pagetitle":"Reference","title":"AstroLib.euler","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.euler-Tuple{Real, Real, Integer}","content":" AstroLib.euler  —  Method euler(ai, bi, select[, FK4=true, radians=true]) Purpose Transform between Galactic, celestial, and ecliptic coordinates. Explanation The function is used by the astro procedure. Arguments ai : input longitude, scalar or vector. bi : input latitude, scalar or vector. select  : integer input specifying type of coordinate transformation. SELECT   From          To     | SELECT   From       To    1   RA-Dec (2000) Galactic |   4    Ecliptic   RA-Dec    2   Galactic      RA-DEC   |   5    Ecliptic   Galactic    3   RA-Dec        Ecliptic |   6    Galactic   Ecliptic FK4  (optional boolean keyword) : if this keyword is set to  true , then input and output celestial and ecliptic coordinates should be given in equinox B1950. When  false , by default, they should be given in equinox J2000. radians  (optional boolean keyword) : if this keyword is set to  true , all input and output angles are in radians rather than degrees. Output a 2-tuple  (ao, bo) : ao : output longitude in degrees. bo : output latitude in degrees. Example Find the Galactic coordinates of Cyg X-1 (ra=299.590315, dec=35.201604) julia> using AstroLib\n\njulia> euler(299.590315, 35.201604, 1)\n(71.33498957116959, 3.0668335310640984) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1570,"pagetitle":"Reference","title":"AstroLib.flux2mag","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.flux2mag","content":" AstroLib.flux2mag  —  Function flux2mag(flux[, zero_point, ABwave=number]) -> magnitude Purpose Convert from flux expressed in erg/(s cm² Å) to magnitudes. Explanation This is the reverse of  mag2flux . Arguments flux : the flux to be converted in magnitude, expressed in erg/(s cm² Å). zero_point : the zero point level of the magnitude.  If not supplied then defaults to 21.1 (Code et al 1976).  Ignored if the  ABwave  keyword is supplied ABwave  (optional numeric keyword): wavelength in Angstroms. If supplied, then returns Oke AB magnitudes (Oke & Gunn 1983, ApJ, 266, 713; http://adsabs.harvard.edu/abs/1983ApJ...266..713O). Output The magnitude. If the  ABwave  keyword is set then magnitude is given by the expression \\[\\text{ABmag} = -2.5\\log_{10}(f) - 5\\log_{10}(\\text{ABwave}) - 2.406\\] Otherwise, magnitude is given by the expression \\[\\text{mag} = -2.5\\log_{10}(\\text{flux}) - \\text{zero point}\\] Example julia> using AstroLib\n\njulia> flux2mag(5.2e-15)\n14.609991640913002\n\njulia> flux2mag(5.2e-15, 15)\n20.709991640913003\n\njulia> flux2mag(5.2e-15, ABwave=15)\n27.423535345634598 Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1571,"pagetitle":"Reference","title":"AstroLib.gal_uvw","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.gal_uvw-NTuple{6, Real}","content":" AstroLib.gal_uvw  —  Method gal_uvw(ra, dec, pmra, pmdec, vrad, plx[, lsr=true]) -> u, v, w Purpose Calculate the Galactic space velocity  $(u, v, w)$  of a star. Explanation Calculates the Galactic space velocity  $(u, v, w)$  of a star given its (1) coordinates, (2) proper motion, (3) parallax, and (4) radial velocity. Arguments User must supply a position, proper motion, radial velocity and parallax. Either scalars or arrays all of the same length can be supplied. Position: ra : right ascension, in degrees dec : declination, in degrees Proper Motion pmra : proper motion in right ascension in arc units (typically milli-arcseconds/yr).  If given  $μ_α$  – proper motion in seconds of time/year – then this is equal to  $15 μ_α \\cos(\\text{dec})$ . pmdec : proper motion in declination (typically mas/yr). Radial Velocity vrad : velocity in km/s Parallax plx : parallax with same distance units as proper motion measurements typically milliarcseconds (mas) If you know the distance in parsecs, then set  plx  to  $1000/\\text{distance}$ , if proper motion measurements are given in milli-arcseconds/yr. There is an additional optional keyword: lsr  (optional boolean keyword): if this keyword is set to  true , then the output velocities will be corrected for the solar motion  $(u, v, w)_⊙ = (-8.5, 13.38, 6.49)$  (Coşkunoǧlu et al. 2011 MNRAS, 412, 1237; DOI: 10.1111/j.1365-2966.2010.17983.x ) to the local standard of rest (LSR).  Note that the value of the solar motion through the LSR remains poorly determined. Output The 3-tuple  $(u, v, w)$ $u$ : velocity (km/s) positive toward the Galactic  anti center $v$ : velocity (km/s) positive in the direction of Galactic rotation $w$ : velocity (km/s) positive toward the North Galactic Pole Method Follows the general outline of Johnson & Soderblom (1987, AJ, 93, 864; DOI: 10.1086/114370 ) except that  $u$  is positive outward toward the Galactic  anti center, and the J2000 transformation matrix to Galactic coordinates is taken from the introduction to the Hipparcos catalog. Example Compute the U,V,W coordinates for the halo star HD 6755.  Use values from Hipparcos catalog, and correct to the LSR. julia> using AstroLib\n\njulia> ra = ten(1,9,42.3)*15.; dec = ten(61,32,49.5);\n\njulia> pmra = 627.89;  pmdec = 77.84; # mas/yr\n\njulia> vrad = -321.4; dis = 129; # distance in parsecs\n\njulia> u, v, w = gal_uvw(ra, dec, pmra, pmdec, vrad, 1e3/dis, lsr=true)\n(118.2110474553902, -466.4828898385057, 88.16573278565097) Notes This function does not take distance as input.  See \"Arguments\" section above for how to provide it using parallax argument. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1572,"pagetitle":"Reference","title":"AstroLib.gcirc","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.gcirc-Tuple{Integer, Vararg{Real, 4}}","content":" AstroLib.gcirc  —  Method gcirc(units, ra1, dec1, ra2, dec2) -> angular_distance Purpose Computes rigorous great circle arc distances. Explanation Input position can be either radians, sexagesimal right ascension and declination, or degrees. Arguments units : integer, can be either 0, or 1, or 2.  Describes units of inputs and output: 0: everything (input right ascensions and declinations, and output distance) is radians 1: right ascensions are in decimal hours, declinations in decimal degrees, output distance in arc seconds 2: right ascensions and declinations are in degrees, output distance in arc seconds ra1 :  right ascension or longitude of point 1 dec1 : declination or latitude of point 1 ra2 : right ascension or longitude of point 2 dec2 : declination or latitude of point 2 Both  ra1  and  dec1 , and  ra2  and  dec2  can be given as 2-tuples  (ra1, dec1)  and  (ra2, dec2) . Output Angular distance on the sky between points 1 and 2, as a  AbstractFloat .  See  units  argument above for the units. Method \"Haversine formula\" see http://en.wikipedia.org/wiki/Great-circle_distance. Example julia> using AstroLib\n\njulia> gcirc(0, 120, -43, 175, +22)\n1.590442261600714 Notes The function  sphdist  provides an alternate method of computing a spherical distance. The Haversine formula can give rounding errors for antipodal points. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1573,"pagetitle":"Reference","title":"AstroLib.geo2eci","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.geo2eci-NTuple{4, Real}","content":" AstroLib.geo2eci  —  Method geo2eci(latitude, longitude, altitude, jd) -> x, y, z Purpose Convert geographic spherical coordinates to Earth-centered inertial coordinates. Explanation Converts from geographic spherical coordinates (latitude, longitude, altitude) to ECI (Earth-Centered Inertial) (x, y, z) rectangular coordinates.  Julian days is also needed. Geographic coordinates assume the Earth is a perfect sphere, with radius equal to its equatorial radius.  ECI coordinates are in km from Earth center at epoch TOD (True of Date). Arguments latitude : geographic latitude, in degrees. longitude : geographic longitude, in degrees. altitude : geographic altitude, in kilometers. jd : Julian days. The three coordinates can be passed as a 3-tuple  (latitude, longitude, altitude) .  In addition,  latitude ,  longitude ,  altitude , and  jd  can be given as arrays of the same length. Output The 3-tuple of ECI (x, y, z) coordinates, in kilometers.  The TOD epoch is the supplied  jd  time. If geographical coordinates are given as arrays, a 3-tuple of arrays of the same length is returned. Example Obtain the ECI coordinates of the intersection of the equator and Greenwich's meridian on 2015-06-30T14:03:12.857 julia> using AstroLib\n\njulia> geo2eci(0, 0, 0, jdcnv(\"2015-06-30T14:03:12.857\"))\n(-4024.8671780315185, 4947.835465127513, 0.0) Notes eci2geo  converts Earth-centered inertial coordinates to geographic spherical coordinates. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1574,"pagetitle":"Reference","title":"AstroLib.geo2geodetic","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.geo2geodetic-NTuple{5, Real}","content":" AstroLib.geo2geodetic  —  Method geo2geodetic(latitude, longitude, altitude) -> latitude, longitude, altitude\ngeo2geodetic(latitude, longitude, altitude, planet) -> latitude, longitude, altitude\ngeo2geodetic(latitude, longitude, altitude, equatorial_radius, polar_radius) -> latitude, longitude, altitude Purpose Convert from geographic (or planetographic) to geodetic coordinates. Explanation Converts from geographic (latitude, longitude, altitude) to geodetic (latitude, longitude, altitude).  In geographic coordinates, the Earth is assumed a perfect sphere with a radius equal to its equatorial radius.  The geodetic (or ellipsoidal) coordinate system takes into account the Earth's oblateness. Geographic and geodetic longitudes are identical.  Geodetic latitude is the angle between local zenith and the equatorial plane.  Geographic and geodetic altitudes are both the closest distance between the satellite and the ground. Arguments The function has two base methods.  The arguments common to all methods and always mandatory are  latitude ,  longitude , and  altitude : latitude : geographic latitude, in degrees. longitude : geographic longitude, in degrees. altitude : geographic altitude, in kilometers. In order to convert to geodetic coordinates, you can either provide custom equatorial and polar radii of the planet or use the values of one of the planets of Solar System (Pluto included). If you want to use the method with explicit equatorial and polar radii the additional mandatory arguments are: equatorial_radius : value of the equatorial radius of the body, in kilometers. polar_radius : value of the polar radius of the body, in kilometers. Instead, if you want to use the method with the selection of a planet, the only additional argument is the planet name: planet  (optional string argument): string with the name of the Solar System planet, from \"Mercury\" to \"Pluto\".  If omitted (so, when only  latitude ,  longitude , and  altitude  are provided), the default is \"Earth\". In all cases, the three coordinates can be passed as a 3-tuple  (latitude, longitude, altitude) .  In addition, geographical  latitude ,  longitude , and  altitude  can be given as arrays of the same length. Output The 3-tuple  (latitude, longitude, altitude)  in geodetic coordinates, for the body with specified equatorial and polar radii (Earth by default). If geographical coordinates are given as arrays, a 3-tuple of arrays of the same length is returned. Method Stephen P.  Keeler and Yves Nievergelt, \"Computing geodetic coordinates\", SIAM Rev. Vol. 40, No. 2, pp. 300-309, June 1998 (DOI: 10.1137/S0036144597323921 ). Planetary constants are from Planetary Fact Sheet (http://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html). Example Locate the Earth geographic North pole (latitude: 90°, longitude: 0°, altitude 0 km), in geodetic coordinates: julia> using AstroLib\n\njulia> geo2geodetic(90, 0, 0)\n(90.0, 0.0, 21.38499999999931) The same for Jupiter: julia> using AstroLib\n\njulia> geo2geodetic(90, 0, 0, \"Jupiter\")\n(90.0, 0.0, 4638.0) Find geodetic coordinates for point of geographic coordinates (latitude, longitude, altitude) = (43.16°, -24.32°, 3.87 km) on a planet with equatorial radius 8724.32 km and polar radius 8619.19 km: julia> using AstroLib\n\njulia> geo2geodetic(43.16, -24.32, 3.87, 8724.32, 8619.19)\n(43.849399515234516, -24.32, 53.53354478670965) Notes Whereas the conversion from geodetic to geographic coordinates is given by an exact, analytical formula, the conversion from geographic to geodetic isn't. Approximative iterations (as used here) exist, but tend to become less good with increasing eccentricity and altitude.  The formula used in this routine should give correct results within six digits for all spatial locations, for an ellipsoid (planet) with an eccentricity similar to or less than Earth's.  More accurate results can be obtained via calculus, needing a non-determined amount of iterations. In any case, the function  geodetic2geo , which converts from geodetic (or planetodetic) to geographic coordinates, can be used to estimate the accuracy of  geo2geodetic . julia> using AstroLib\n\njulia> collect(geodetic2geo(geo2geodetic(67.2, 13.4, 1.2))) - [67.2, 13.4, 1.2]\n3-element Vector{Float64}:\n -3.5672513831741526e-9\n  0.0\n  9.484211194177306e-10 Code of this function is based on IDL Astronomy User's Library. source"},{"id":1575,"pagetitle":"Reference","title":"AstroLib.geo2mag","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.geo2mag","content":" AstroLib.geo2mag  —  Function geo2mag(latitude, longitude[, year]) -> geomagnetic_latitude, geomagnetic_longitude Purpose Convert from geographic to geomagnetic coordinates. Explanation Converts from geographic (latitude, longitude) to geomagnetic (latitude, longitude).  Altitude is not involved in this function. Arguments latitude : geographic latitude (North), in degrees. longitude : geographic longitude (East), in degrees. year  (optional numerical argument): the year in which to perform conversion. If omitted, defaults to current year. The coordinates can be passed as arrays of the same length. Output The 2-tuple of magnetic (latitude, longitude) coordinates, in degrees. If geographical coordinates are given as arrays, a 2-tuple of arrays of the same length is returned. Example Kyoto has geographic coordinates 35° 00' 42'' N, 135° 46' 06'' E, find its geomagnetic coordinates in 2016: julia> using AstroLib\n\njulia> geo2mag(ten(35,0,42), ten(135,46,6), 2016)\n(36.86579228937769, -60.1840605366516) Notes This function uses list of North Magnetic Pole positions provided by World Magnetic Model (https://www.ngdc.noaa.gov/geomag/data/poles/NP.xy). mag2geo  converts geomagnetical coordinates to geographic coordinates. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1576,"pagetitle":"Reference","title":"AstroLib.geodetic2geo","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.geodetic2geo-NTuple{5, Real}","content":" AstroLib.geodetic2geo  —  Method geodetic2geo(latitude, longitude, altitude) -> latitude, longitude, altitude\ngeodetic2geo(latitude, longitude, altitude, planet) -> latitude, longitude, altitude\ngeodetic2geo(latitude, longitude, altitude, equatorial_radius, polar_radius) -> latitude, longitude, altitude Purpose Convert from geodetic (or planetodetic) to geographic coordinates. Explanation Converts from geodetic (latitude, longitude, altitude) to geographic (latitude, longitude, altitude).  In geographic coordinates, the Earth is assumed a perfect sphere with a radius equal to its equatorial radius.  The geodetic (or ellipsoidal) coordinate system takes into account the Earth's oblateness. Geographic and geodetic longitudes are identical.  Geodetic latitude is the angle between local zenith and the equatorial plane.  Geographic and geodetic altitudes are both the closest distance between the satellite and the ground. Arguments The function has two base methods.  The arguments common to all methods and always mandatory are  latitude ,  longitude , and  altitude : latitude : geodetic latitude, in degrees. longitude : geodetic longitude, in degrees. altitude : geodetic altitude, in kilometers. In order to convert to geographic coordinates, you can either provide custom equatorial and polar radii of the planet or use the values of one of the planets of Solar System (Pluto included). If you want to use the method with explicit equatorial and polar radii the additional mandatory arguments are: equatorial_radius : value of the equatorial radius of the body, in kilometers. polar_radius : value of the polar radius of the body, in kilometers. Instead, if you want to use the method with the selection of a planet, the only additional argument is the planet name: planet  (optional string argument): string with the name of the Solar System planet, from \"Mercury\" to \"Pluto\".  If omitted (so, when only  latitude ,  longitude , and  altitude  are provided), the default is \"Earth\". In all cases, the three coordinates can be passed as a 3-tuple  (latitude, longitude, altitude) .  In addition, geodetic  latitude ,  longitude , and  altitude  can be given as arrays of the same length. Output The 3-tuple  (latitude, longitude, altitude)  in geographic coordinates, for the body with specified equatorial and polar radii (Earth by default). If geodetic coordinates are given as arrays, a 3-tuple of arrays of the same length is returned. Method Stephen P.  Keeler and Yves Nievergelt, \"Computing geodetic coordinates\", SIAM Rev. Vol. 40, No. 2, pp. 300-309, June 1998 (DOI: 10.1137/S0036144597323921 ). Planetary constants from \"Allen's Astrophysical Quantities\", Fourth Ed., (2000). Example Find geographic coordinates of geodetic North pole (latitude: 90°, longitude: 0°, altitude 0 km) of the Earth: julia> using AstroLib\n\njulia> geodetic2geo(90, 0, 0)\n(90.0, 0.0, -21.38499999999931) The same for Jupiter: julia> using AstroLib\n\njulia> geodetic2geo(90, 0, 0, \"Jupiter\")\n(90.0, 0.0, -4638.0) Find geographic coordinates for point of geodetic coordinates (latitude, longitude, altitude) = (43.16°, -24.32°, 3.87 km) on a planet with equatorial radius 8724.32 km and polar radius 8619.19 km: julia> using AstroLib\n\njulia> geodetic2geo(43.16, -24.32, 3.87, 8724.32, 8619.19)\n(42.46772711708433, -24.32, -44.52902080669082) Notes geo2geodetic  converts from geographic (or planetographic) to geodetic coordinates. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1577,"pagetitle":"Reference","title":"AstroLib.get_date","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.get_date-Tuple{Dates.DateTime, Bool, Bool}","content":" AstroLib.get_date  —  Method get_date([date, old=true, timetag=true]) -> string Purpose Returns the UTC date in  \"CCYY-MM-DD\"  format for FITS headers. Explanation This is the format required by the  DATE  and  DATE-OBS  keywords in a FITS header. Argument date  (optional): the date in UTC standard.  If omitted, defaults to the current UTC time.  Each element can be either a  DateTime  type or anything that can be converted to that type.  In the case of vectorial input, each element is considered as a date, so you cannot provide a date by parts. old  (optional boolean keyword): see below. timetag  (optional boolean keyword): see below. Output A string with the date formatted according to the given optional keywords. When no optional keywords ( timetag  and  old ) are supplied, the format of the output string is  \"CCYY-MM-DD\"  (year-month-day part of the date), where  CCYY  represents a 4-digit calendar year,  MM  the 2-digit ordinal number of a calendar month within the calendar year, and  DD  the 2-digit ordinal number of a day within the calendar month. If the boolean keyword  old  is true (default: false), the year-month-day part of date has  \"DD/MM/YY\"  format.  This is the formerly (pre-1997) recommended for FITS.  Note that this format is now deprecated because it uses only a 2-digit representation of the year. If the boolean keyword  timetag  is true (default: false),  \"Thh:mm:ss\"  is appended to the year-month-day part of the date, where <hh> represents the hour in the day, <mm> the minutes, <ss> the seconds, and the literal 'T' the ISO 8601 time designator. Note that  old  and  timetag  keywords can be used together, so that the output string will have  \"DD/MM/YYThh:mm:ss\"  format. Example julia> using AstroLib, Dates\n\njulia> get_date(DateTime(21937, 05, 30, 09, 59, 00), timetag=true)\n\"21937-05-30T09:59:00\" Notes A discussion of the DATExxx syntax in FITS headers can be found in http://www.cv.nrao.edu/fits/documents/standards/year2000.txt Those who wish to use need further flexibility in their date formats (e.g. to use TAI time) should look at Bill Thompson's time routines in http://sohowww.nascom.nasa.gov/solarsoft/gen/idl/time source"},{"id":1578,"pagetitle":"Reference","title":"AstroLib.get_juldate","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.get_juldate-Tuple{}","content":" AstroLib.get_juldate  —  Method get_juldate() -> julian_days Purpose Return the number of Julian days for current time. Explanation Return for current time the number of Julian calendar days since epoch  -4713-11-24T12:00:00  as a floating point. Example get_juldate()\ndaycnv(get_juldate()) Notes Use  jdcnv  to get the number of Julian days for a different date. source"},{"id":1579,"pagetitle":"Reference","title":"AstroLib.hadec2altaz","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.hadec2altaz-Tuple{Real, Real, Real}","content":" AstroLib.hadec2altaz  —  Method hadec2altaz(ha, dec, lat[, ws=true]) -> alt, az Purpose Convert Hour Angle and Declination to Horizon (Alt-Az) coordinates. Explanation Can deal with the NCP singularity.  Intended mainly to be used by program  eq2hor . Arguments Input coordinates may be either a scalar or an array, of the same dimension. ha : the local apparent hour angle, in degrees.  The hour angle is the time that right ascension of 0 hours crosses the local meridian.  It is unambiguously defined. dec : the local apparent declination, in degrees. lat : the local geodetic latitude, in degrees, scalar or array. ws  (optional boolean keyword): if true, the output azimuth is measured West from South.  The default is to measure azimuth East from North. ha  and  dec  can be given as a 2-tuple  (ha, dec) . Output 2-tuple  (alt, az) alt : local apparent altitude, in degrees. az : the local apparent azimuth, in degrees. The output coordinates are always floating points and have the same type (scalar or array) as the input coordinates. Example Arcturus is observed at an apparent hour angle of 336.6829 and a declination of 19.1825 while at the latitude of +43° 4' 42''.  What are the local altitude and azimuth of this object? julia> using AstroLib\n\njulia> alt, az = hadec2altaz(336.6829, 19.1825, ten(43, 4, 42))\n(59.08617155005685, 133.3080693440254) Notes altaz2hadec  converts Horizon (Alt-Az) coordinates to Hour Angle and Declination. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1580,"pagetitle":"Reference","title":"AstroLib.helio","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.helio","content":" AstroLib.helio  —  Function helio(jd, list[, radians=true]) -> hrad, hlong, hlat Purpose Compute heliocentric coordinates for the planets. Explanation The mean orbital elements for epoch J2000 are used. These are derived from a 250 yr least squares fit of the DE 200 planetary ephemeris to a Keplerian orbit where each element is allowed to vary linearly with time. Useful mainly for dates between 1800 and 2050, this solution fits the terrestrial planet orbits to ~25'' or better, but achieves only ~600'' for Saturn. Arguments jd : julian date, scalar or vector num : integer denoting planet number, scalar or vector 1 = Mercury, 2 = Venus, ... 9 = Pluto radians (optional): if this keyword is set to  true , then the longitude and latitude output are in radians rather than degrees. Output hrad : the heliocentric radii, in astronomical units. hlong : the heliocentric (ecliptic) longitudes, in degrees. hlat : the heliocentric latitudes in degrees. Example Find heliocentric position of Venus on August 23, 2000 julia> using AstroLib\n\njulia> helio(jdcnv(2000,08,23,0), 2)\n(0.7213758288364316, 198.39093251916148, 2.887355631705488) Find the current heliocentric positions of all the planets julia> using AstroLib\n\njulia> helio.([jdcnv(1900)], 1:9)\n9-element Vector{Tuple{Float64, Float64, Float64}}:\n (0.4207394142180803, 202.60972662618906, 3.0503005607270532)\n (0.7274605731764012, 344.5381482401048, -3.3924346961624785)\n (0.9832446886519147, 101.54969268801035, 0.012669354526696368)\n (1.4212659241051142, 287.8531100442217, -1.5754626002228043)\n (5.386813769590955, 235.91306092135062, 0.9131692817310215)\n (10.054339927304339, 268.04069870870387, 1.0851704598594278)\n (18.984683376211326, 250.0555468087738, 0.05297087029604253)\n (29.87722677219009, 87.07244903504716, -1.245060583142733)\n (46.9647515992327, 75.94692594417324, -9.576681044165511) Notes This program is based on the two-body model and thus neglects interactions between the planets. The coordinates are given for equinox 2000 and  not  the equinox of the supplied date. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1581,"pagetitle":"Reference","title":"AstroLib.helio_jd","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.helio_jd-Tuple{Real, Real, Real}","content":" AstroLib.helio_jd  —  Method helio_jd(date, ra, dec[, B1950=true, diff=false]) -> jd_helio\nhelio_jd(date, ra, dec[, B1950=true, diff=true]) -> time_diff Purpose Convert geocentric (reduced) Julian date to heliocentric Julian date. Explanation This procedure corrects for the extra light travel time between the Earth and the Sun. An online calculator for this quantity is available at http://www.physics.sfasu.edu/astro/javascript/hjd.html Users requiring more precise calculations and documentation should look at the IDL code available at http://astroutils.astronomy.ohio-state.edu/time/ Arguments date : reduced Julian date (= JD - 2400000).  You can use  juldate()  to calculate the reduced Julian date. ra  and  dec : right ascension and declination in degrees.  Default equinox is J2000. B1950  (optional boolean keyword): if set to  true , then input coordinates are assumed to be in equinox B1950 coordinates.  Default is  false . diff  (optional boolean keyword): if set to  true , the function returns the time difference (heliocentric JD - geocentric JD) in seconds.  Default is  false . Output The return value depends on the value of  diff  optional keywords: if  diff  is  false  (default), then the heliocentric reduced Julian date is returned. if  diff  is  true , then the time difference in seconds between the geocentric and heliocentric Julian date is returned. Example What is the heliocentric Julian date of an observation of V402 Cygni (J2000: RA = 20 9 7.8, Dec = 37 09 07) taken on June 15, 2016 at 11:40 UT? julia> using AstroLib\n\njulia> jd = juldate(2016, 6, 15, 11, 40);\n\njulia> helio_jd(jd, ten(20, 9, 7.8) * 15, ten(37, 9, 7))\n57554.98808289718 Notes Wayne Warren (Raytheon ITSS) has compared the results of this algorithm with the FORTRAN subroutines in the STARLINK SLALIB library (see http://star-www.rl.ac.uk/).                                                  Time Diff (sec)\n     Date               RA(2000)   Dec(2000)  STARLINK      IDL\n\n1999-10-29T00:00:00.0  21 08 25.  -67 22 00.  -59.0        -59.0\n1999-10-29T00:00:00.0  02 56 33.4 +00 26 55.  474.1        474.1\n1940-12-11T06:55:00.0  07 34 41.9 -00 30 42.  366.3        370.2\n1992-02-29T03:15:56.2  12 56 27.4 +42 10 17.  350.8        350.9\n2000-03-01T10:26:31.8  14 28 36.7 -20 42 11.  243.7        243.7\n2100-02-26T09:18:24.2  08 26 51.7 +85 47 28.  104.0        108.8 Code of this function is based on IDL Astronomy User's Library. source"},{"id":1582,"pagetitle":"Reference","title":"AstroLib.helio_rv","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.helio_rv","content":" AstroLib.helio_rv  —  Function helio_rv(jd, T, P, V_0, K[, e, ω]) -> rv Purpose Return the heliocentric radial velocity of a spectroscopic binary. Explanation This function will return the heliocentric radial velocity of a spectroscopic binary star at a given heliocentric date given its orbit. Arguments jd : time of observation, as number of Julian days. T : time of periastron passage (max. +ve velocity for circular orbits), same time system as  jd P : the orbital period in same units as  jd V_0 : systemic velocity K : velocity semi-amplitude in the same units as  V_0 e : eccentricity of the orbit.  It defaults to 0 if omitted ω : longitude of periastron in degrees.  It defaults to 0 if omitted Output The predicted heliocentric radial velocity in the same units as Gamma for the date(s) specified by  jd . Example What was the heliocentric radial velocity of the primary component of HU Tau at 1730 UT 25 Oct 1994? julia> using AstroLib\n\njulia> jd = juldate(94, 10, 25, 17, 30); # Obtain Geocentric Julian days\n\njulia> hjd = helio_jd(jd, ten(04, 38, 16) * 15, ten(20, 41, 05)); # Convert to HJD\n\njulia> helio_rv(hjd, 46487.5303, 2.0563056, -6, 59.3)\n-62.965570107789475 NB: the functions  juldate  and  helio_jd  return a reduced HJD (HJD - 2400000) and so T and P must be specified in the same fashion. Plot two cycles of an eccentric orbit,  $e = 0.6$ ,  $ω = 45°$  for both components of a binary star.  Use  Plots.jl  for plotting. using Plots\nφ = range(0, stop=2, length=1000); # Generate 1000 phase points\nplot(φ, helio_rv.(φ, 0, 1, 0, 100, 0.6, 45)) # Plot 1st component\nplot(φ, helio_rv.(φ, 0, 1, 0, 100, 0.6, 45+180)) # Plot 2nd component Notes The user should ensure consistency with all time systems being used (i.e.  jd  and  t  should be in the same units and time system).  Generally, users should reduce large time values by subtracting a large constant offset, which may improve numerical accuracy. If using the the function  juldate  and  helio_jd , the reduced HJD time system must be used throughtout. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1583,"pagetitle":"Reference","title":"AstroLib.hor2eq","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.hor2eq","content":" AstroLib.hor2eq  —  Function hor2eq(alt, az, jd[, obsname;\n       ws=false, B1950=false, precession=true, nutate=true,\n       aberration=true, refract=true,\n       lat=NaN, lon=NaN, altitude=0,\n       pressure=NaN, temperature=NaN]) -> ra, dec, ha\n\nhor2eq(alt, az, jd, lat, lon[, altitude=0;\n       ws=false, B1950=false, precession=true, nutate=true,\n       aberration=true, refract=true,\n       pressure=NaN, temperature=NaN]) -> ra, dec, ha Purpose Converts local horizon coordinates (alt-az) to equatorial (ra-dec) coordinates. Explanation This is a function to calculate equatorial (ra,dec) coordinates from horizon (alt,az) coords. It is accurate to about 1 arcsecond or better. It performs precession, nutation, aberration, and refraction corrections. Arguments This function has two base methods.  With one you can specify the name of the observatory, if present in  AstroLib.observatories , with the other one you can provide the coordinates of the observing site and, optionally, the altitude. Common mandatory arguments: alt : altitude of horizon coords, in degrees az : azimuth angle measured East from North (unless ws is  true ), in degrees jd : julian date Other positional arguments: obsname : set this to a valid observatory name in  AstroLib.observatories . or lat : north geodetic latitude of location, in degrees. lon : AST longitude of location, in degrees. You can specify west longitude with a negative sign. altitude : the altitude of the observing location, in meters.  It is  0  by default Optional keyword arguments: ws  (optional boolean keyword): set this to  true  to get the azimuth measured westward from south. This is  false  by default B1950  (optional boolean keyword): set this to  true  if the ra and dec are specified in B1950 (FK4 coordinates) instead of J2000 (FK5). This is  false  by default precession  (optional boolean keyword): set this to  false  for no precession,  true  by default nutate  (optional boolean keyword): set this to  false  for no nutation,  true  by default aberration  (optional boolean keyword): set this to  false  for no aberration correction,  true  by default refract  (optional boolean keyword): set this to  false  for no refraction correction,  true  by default pressure  (optional keyword): the pressure at the observing location, in millibars. Default value is  NaN temperature  (optional keyword): the temperature at the observing location, in Kelvins. Default value is  NaN Output ra : right ascension of object, in degrees (FK5) dec : declination of the object, in degrees (FK5) ha : hour angle, in degrees Example You are at Kitt Peak National Observatory, looking at a star at azimuth angle 264d 55m 06s and elevation 37d 54m 41s (in the visible). Today is Dec 25, 2041 and the local time is 10 PM precisely. What is the right ascension and declination (J2000) of the star you're looking at? The temperature here is about 0 Celsius, and the pressure is 781 millibars. The Julian date for this time is 2466879.7083333 julia> using AstroLib\n\njulia> ra_o, dec_o = hor2eq(ten(37,54,41), ten(264,55,06), 2466879.7083333,\n                            \"kpno\", pressure = 781, temperature = 273)\n(3.3224480269254713, 15.19061543702944, 54.61174536229464)\n\njulia> adstring(ra_o, dec_o)\n\" 00 13 17.4  +15 11 26\" Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1584,"pagetitle":"Reference","title":"AstroLib.imf","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.imf-Tuple{AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}}","content":" AstroLib.imf  —  Method imf(mass, expon, mass_range) -> psi Purpose Compute an N-component power-law logarithmic initial mass function (IMF). Explanation The function is normalized so that the total mass distribution equals one solar mass. Arguments mass : mass in units of solar mass, vector. expon : power law exponent, vector. The number of values in expon equals the number of different power-law components in the IMF. mass_range : vector containing the mass upper and lower limits of the IMF and masses where the IMF exponent changes. The number of values in mass range should be one more than in expon. The values in mass range should be monotonically increasing and positive. Output psi : mass function, number of stars per unit logarithmic mass interval evaluated for supplied masses. Example Show the number of stars per unit mass interval at 3 Msun for a Salpeter (expon = -1.35) IMF, with a mass range from 0.1 MSun to 110 Msun. julia> using AstroLib\n\njulia> imf([3], [-1.35], [0.1, 110]) / 3\n1-element Vector{Float64}:\n 0.01294143518151214 Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1585,"pagetitle":"Reference","title":"AstroLib.ismeuv","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.ismeuv","content":" AstroLib.ismeuv  —  Function ismeuv(wave, hcol[, he1col=hcol*0.1, he2col=0, fano=false]) -> tau Purpose Compute the continuum interstellar EUV optical depth Explanation The EUV optical depth is computed from the photoionization of hydrogen and helium. Arguments wave : wavelength value (in Angstroms). Useful range is 40 - 912 A; at shorter wavelength metal opacity should be considered, at longer wavelengths there is no photoionization. hcol : interstellar hydrogen column density in cm-2. he1col  (optional): neutral helium column density in cm-2. Default is 0.1*hcol (10% of hydrogen column) he2col  (optional): ionized helium column density in cm-2 Default is 0. fano  (optional boolean keyword): If this keyword is true, then the 4 strongest auto-ionizing resonances of He I are included. The shape of these resonances is given by a Fano profile - see Rumph, Bowyer, & Vennes 1994, AJ, 107, 2108. If these resonances are included then the input wavelength vector should have a fine (>~0.01 A) grid between 190 A and 210 A, since the resonances are very narrow. Output tau : Vector giving resulting optical depth, non-negative values. Example One has a model EUV spectrum with wavelength, w (in Angstroms). Find the EUV optical depth by 1e18 cm-2 of HI, with N(HeI)/N(HI) = N(HeII)/N(HI) = 0.05. julia> using AstroLib\n\njulia> ismeuv.([670, 910], 1e19, 5e17, 5e17)\n2-element Vector{Float64}:\n 27.35393320556168\n 62.683796028917286 Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1586,"pagetitle":"Reference","title":"AstroLib.jdcnv","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.jdcnv","content":" AstroLib.jdcnv  —  Function jdcnv(date) -> julian_days Purpose Convert proleptic Gregorian Calendar date in UTC standard to number of Julian days. Explanation Takes the given proleptic Gregorian date in UTC standard and returns the number of Julian calendar days since epoch  -4713-11-24T12:00:00 . Argument date : date in proleptic Gregorian Calendar.  Each element can be either a  DateTime  or anything that can be converted directly to  DateTime . Output Number of Julian days, as a floating point. Example Find the Julian days number at 2016 August 23, 03:39:06. julia> using AstroLib, Dates\n\njulia> jdcnv(DateTime(2016, 08, 23, 03, 39, 06))\n2.4576236521527776e6\n\njulia> jdcnv(2016, 08, 23, 03, 39, 06)\n2.4576236521527776e6\n\njulia> jdcnv(\"2016-08-23T03:39:06\")\n2.4576236521527776e6 Notes This is the inverse of  daycnv . get_juldate  returns the number of Julian days for current time.  It is equivalent to  jdcnv(now(Dates.UTC)) . For the conversion of Julian date to number of Julian days, use  juldate . source"},{"id":1587,"pagetitle":"Reference","title":"AstroLib.jprecess","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.jprecess","content":" AstroLib.jprecess  —  Function jprecess(ra, dec[, epoch]) -> ra2000, dec2000\njprecess(ra, dec, muradec[, parallax=parallax, radvel=radvel]) -> ra2000, dec2000 Purpose Precess positions from B1950.0 (FK4) to J2000.0 (FK5). Explanation Calculate the mean place of a star at J2000.0 on the FK5 system from the mean place at B1950.0 on the FK4 system. jprecess  function has two methods, one for each of the following cases: the proper motion is known and non-zero the proper motion is unknown or known to be exactly zero (i.e. extragalactic radio sources).  Better precision can be achieved in this case by inputting the epoch of the original observations. Arguments The function has 2 methods.  The common mandatory arguments are: ra : input B1950 right ascension, in degrees. dec : input B1950 declination, in degrees. The two methods have a different third argument (see \"Explanation\" section for more details).  It can be one of the following: muradec : 2-element vector containing the proper motion in seconds of arc per tropical  century  in right ascension and declination. epoch : scalar giving epoch of original observations. If none of these two arguments is provided (so  jprecess  is fed only with right ascension and declination), it is assumed that proper motion is exactly zero and  epoch = 1950 . If it is used the method involving  muradec  argument, the following keywords are available: parallax  (optional numerical keyword): stellar parallax, in seconds of arc. radvel  (optional numerical keyword): radial velocity in km/s. Right ascension and declination can be passed as the 2-tuple  (ra, dec) .  You can also pass  ra ,  dec ,  parallax , and  radvel  as arrays, all of the same length N.  In that case,  muradec  should be a matrix 2×N. Output The 2-tuple of right ascension and declination in 2000, in degrees, of input coordinates is returned.  If  ra  and  dec  (and other possible optional arguments) are arrays, the 2-tuple of arrays  (ra2000, dec2000)  of the same length as the input coordinates is returned. Method The algorithm is taken from the Explanatory Supplement to the Astronomical Almanac 1992, page 184.  See also Aoki et al (1983), A&A, 128, 263.  URL: http://adsabs.harvard.edu/abs/1983A%26A...128..263A. Example The SAO catalogue gives the B1950 position and proper motion for the star HD 119288.   Find the J2000 position. RA(1950) = 13h 39m 44.526s Dec(1950) = 8d 38' 28.63'' Mu(RA) = -.0259 s/yr Mu(Dec) = -.093 ''/yr julia> using AstroLib\n\njulia> muradec = 100 * [-15*0.0259, -0.093]; # convert to century proper motion\n\njulia> ra = ten(13, 39, 44.526)*15;\n\njulia> decl = ten(8, 38, 28.63);\n\njulia> adstring(jprecess(ra, decl, muradec), precision=2)\n\" 13 42 12.740  +08 23 17.69\" Notes \"When transferring individual observations, as opposed to catalog mean place, the safest method is to tranform the observations back to the epoch of the observation, on the FK4 system (or in the system that was used to to produce the observed mean place), convert to the FK5 system, and transform to the the epoch and equinox of J2000.0\" – from the Explanatory Supplement (1992), p. 180 bprecess  performs the precession to B1950 coordinates. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1588,"pagetitle":"Reference","title":"AstroLib.juldate","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.juldate-Tuple{Dates.DateTime}","content":" AstroLib.juldate  —  Method juldate(date::DateTime) -> reduced_julia_days Purpose Convert from calendar to Reduced Julian Days. Explanation Julian Day Number is a count of days elapsed since Greenwich mean noon on 1 January 4713 B.C.  Julian Days are the number of Julian days followed by the fraction of the day elapsed since the preceding noon. This function takes the given  date  and returns the number of Julian calendar days since epoch  1858-11-16T12:00:00  (Reduced Julian Days = Julian Days - 2400000). Argument date : date in Julian Calendar, UTC standard.  Each element can be given in  DateTime  type or anything that can be converted to that type. Output The number of Reduced Julian Days is returned. Example Get number of Reduced Julian Days at 2016-03-20T15:24:00. julia> using AstroLib, Dates\n\njulia> juldate(DateTime(2016, 03, 20, 15, 24))\n57468.14166666667\n\njulia> juldate(2016, 03, 20, 15, 24)\n57468.14166666667\n\njulia> juldate(\"2016-03-20T15:24\")\n57468.14166666667 Notes Julian Calendar is assumed, thus before  1582-10-15T00:00:00  this function is  not  the inverse of  daycnv .  For the conversion proleptic Gregorian date to number of Julian days, use  jdcnv , which is the inverse of  daycnv . Code of this function is based on IDL Astronomy User's Library. source"},{"id":1589,"pagetitle":"Reference","title":"AstroLib.kepler_solver","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.kepler_solver","content":" AstroLib.kepler_solver  —  Function kepler_solver(M, e) -> E Purpose Solve Kepler's equation in the elliptic motion regime ( $0 ≤ e ≤ 1$ ) and return eccentric anomaly  $E$ . Explanation In order to find the position of a body in elliptic motion (e.g., in the two-body problem) at a given time  $t$ , one has to solve the  Kepler's equation \\[M(t) = E(t) - e \\sin E(t)\\] where  $M(t) = (t - t_0)/P$  is the mean anomaly,  $E(t)$  the eccentric anomaly,  $e$  the eccentricity of the orbit,  $t_0$  is the time of periapsis passage, and  $P$  is the period of the orbit.  Usually the eccentricity is given and one wants to find the eccentric anomaly  $E(t)$  at a specific time  $t$ , so that also the mean anomaly  $M(t)$  is known. Arguments M : mean anomaly. e : eccentricity, in the elliptic motion regime ( $0 ≤ e ≤ 1$ ) Output The eccentric anomaly  $E$ , restricted to the range  $[-π, π]$ . Method Many different numerical methods exist to solve Kepler's equation.  This function implements the algorithm proposed in Markley (1995) Celestial Mechanics and Dynamical Astronomy, 63, 101 (DOI: 10.1007/BF00691917 ).  This method is not iterative, requires only four transcendental function evaluations, and has been proved to be fast and efficient over the entire range of elliptic motion  $0 ≤ e ≤ 1$ . Example Find the eccentric anomaly for an orbit with eccentricity  $e = 0.7$  and for  $M(t) = 8π/3$ . julia> using AstroLib\n\njulia> ecc = 0.7;\n\njulia> E = kepler_solver(8pi/3, ecc)\n2.5085279492864223 Plot the eccentric anomaly as a function of mean anomaly for eccentricity  $e = 0, 0.5, 0.9$ .  Recall that  kepler_solver  gives  $E ∈ [-π, π]$ , use  mod2pi  to have it in  $[0, 2π]$ .  Use  Plots.jl  for plotting. using AstroLib\nusing Plots\nM = range(0, stop=2pi, length=1001)[1:end-1];\nfor ecc in (0, 0.5, 0.9)\n    plot(M, mod2pi.(kepler_solver.(M, ecc)))\nend Notes The true anomaly can be calculated with  trueanom  function. source"},{"id":1590,"pagetitle":"Reference","title":"AstroLib.lsf_rotate","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.lsf_rotate","content":" AstroLib.lsf_rotate  —  Function lsf_rotate(delta_v, v_sin_i[, epsilon = 0.3]) -> velocity_grid, lsf Purpose Create a 1-d convolution kernel to broaden a spectrum from a rotating star. Explanation Can be used to derive the broadening effect (LSF, line spread function) due to rotation on a synthetic stellar spectrum.  Assumes constant limb darkening across the disk. Arguments delta_v : the step increment (in km/s) in the output rotation kernel v_sin_i : the rotational velocity projected along the line of sight (km/s) epsilon  (optional numeric argument): the limb-darkening coefficient, default = 0.6 which is typical for photospheric lines.  The specific intensity  $I$  at any angle  $θ$  from the specific intensity  $I_{\\text{cen}}$  at the center of the disk is given by: \\[I = I_{\\text{cen}} ⋅ (1 - ε ⋅ (1 - \\cos(θ)))\\] Output The 2-tuple ( velocity_grid ,  lsf ): velocity_grid : vector of velocity grid with the same number of elements as  lsf  (see below) lsf : the convolution kernel vector for the specified rotational velocity. The number of points in  lsf  will be always be odd (the kernel is symmetric) and equal to either  ceil(2*v_sin_i/delta_v)  or  ceil(2*v_sin_i/delta_v) + 1 , whichever number is odd.  Elements of  lsf  will always be of type  AbstractFloat .  To actually compute the broadening, the spectrum should be convolved with the rotational  lsf Example Plot the line spread function for a star rotating at 90 km/s in velocity space every 3 km/s.  Use  Plots.jl  for plotting. using Plots\nplot(lsf_rotate(3, 90)...) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1591,"pagetitle":"Reference","title":"AstroLib.mag2flux","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.mag2flux","content":" AstroLib.mag2flux  —  Function mag2flux(mag[, zero_point, ABwave=number]) -> flux Purpose Convert from magnitudes to flux expressed in erg/(s cm² Å). Explanation This is the reverse of  flux2mag . Arguments mag : the magnitude to be converted in flux. zero_point : the zero point level of the magnitude.  If not supplied then defaults to 21.1 (Code et al 1976).  Ignored if the  ABwave  keyword is supplied ABwave  (optional numeric keyword): wavelength, in Angstroms.  If supplied, then the input  mag  is assumed to contain Oke AB magnitudes (Oke & Gunn 1983, ApJ, 266, 713; http://adsabs.harvard.edu/abs/1983ApJ...266..713O). Output The flux. If the  ABwave  keyword is set, then the flux is given by the expression \\[\\text{flux} = 10^{-0.4(\\text{mag} +2.406 + 4\\log_{10}(\\text{ABwave}))}\\] Otherwise the flux is given by \\[\\text{flux} =  10^{-0.4(\\text{mag} + \\text{zero point})}\\] Example julia> using AstroLib\n\njulia> mag2flux(8.3)\n1.7378008287493692e-12\n\njulia> mag2flux(8.3, 12)\n7.58577575029182e-9\n\njulia> mag2flux(8.3, ABwave=12)\n3.624411568301719e-7 Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1592,"pagetitle":"Reference","title":"AstroLib.mag2geo","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.mag2geo","content":" AstroLib.mag2geo  —  Function mag2geo(latitude, longitude[, year]) -> geographic_latitude, geographic_longitude Purpose Convert from geomagnetic to geographic coordinates. Explanation Converts from geomagnetic (latitude, longitude) to geographic (latitude, longitude).  Altitude is not involved in this function. Arguments latitude : geomagnetic latitude (North), in degrees. longitude : geomagnetic longitude (East), in degrees. year  (optional numerical argument): the year in which to perform conversion. If omitted, defaults to current year. The coordinates can be passed as arrays of the same length. Output The 2-tuple of geographic (latitude, longitude) coordinates, in degrees. If geomagnetic coordinates are given as arrays, a 2-tuple of arrays of the same length is returned. Example Find position of North Magnetic Pole in 2016 julia> using AstroLib\n\njulia> mag2geo(90, 0, 2016)\n(86.395, -166.29000000000002) Notes This function uses list of North Magnetic Pole positions provided by World Magnetic Model (https://www.ngdc.noaa.gov/geomag/data/poles/NP.xy). geo2mag  converts geographic coordinates to geomagnetic coordinates. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1593,"pagetitle":"Reference","title":"AstroLib.mean_obliquity","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.mean_obliquity-Tuple{Real}","content":" AstroLib.mean_obliquity  —  Method mean_obliquity(jd) -> m_eps Purpose Return the mean obliquity of the ecliptic for a given Julian date Explanation The function is used by the  co_nutate  procedure. Arguments jd : julian date Output m_eps : mean obliquity of the ecliptic, in radians Example julia> using AstroLib\n\njulia> mean_obliquity(jdcnv(1978,01,7,11, 01))\n0.4091425159336512 Notes The algorithm used to find the mean obliquity( eps0 ) is mentioned in USNO Circular 179, but the canonical reference for the IAU adoption is apparently Hilton et al., 2006, Celest.Mech.Dyn.Astron. 94, 351. 2000 source"},{"id":1594,"pagetitle":"Reference","title":"AstroLib.month_cnv","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.month_cnv-Tuple{Integer}","content":" AstroLib.month_cnv  —  Method month_cnv(number[, shor=true, up=true, low=true]) -> month_name\nmonth_cnv(name) -> number Purpose Convert between a month English name and  the equivalent number. Explanation For example, converts from \"January\" to 1  or vice-versa. Arguments The functions has two methods, one with numeric input (and three possible boolean keywords) and the other one with string input. Numeric input arguments: number : the number of the month to be converted to month name. short  (optional boolean keyword): if true, the abbreviated (3-character) name of the month will be returned, e.g. \"Apr\" or \"Oct\".  Default is false. up  (optional boolean keyword): if true, the name of the month will be all in upper case, e.g. \"APRIL\" or \"OCTOBER\".  Default is false. low  (optional boolean keyword): if true, the name of the month will be all in lower case, e.g. \"april\" or \"october\".  Default is false. String input argument: name : month name to be converted to month number. Output The month name or month number, depending on the input.  For numeric input, the format of the month name is influenced by the optional keywords. Example julia> using AstroLib\n\njulia> month_cnv.([\"janua\", \"SEP\", \"aUgUsT\"])\n3-element Vector{Int64}:\n 1\n 9\n 8\n\njulia> month_cnv.([2, 12, 6], short=true, low=true)\n3-element Vector{String}:\n \"feb\"\n \"dec\"\n \"jun\" source"},{"id":1595,"pagetitle":"Reference","title":"AstroLib.moonpos","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.moonpos","content":" AstroLib.moonpos  —  Function moonpos(jd[, radians=true]) -> ra, dec, dis, geolong, geolat Purpose Compute the right ascension and declination of the Moon at specified Julian date. Arguments jd : the Julian ephemeris date.  It can be either a scalar or an array radians  (optional boolean keyword): if set to  true , then all output angular quantities are given in radians rather than degrees.  The default is  false Output The 5-tuple  (ra, dec, dis, geolong, geolat) : ra : apparent right ascension of the Moon in degrees, referred to the true equator of the specified date(s) dec : the declination of the Moon in degrees dis : the distance between the centre of the Earth and the centre of the Moon in kilometers geolong : apparent longitude of the moon in degrees, referred to the ecliptic of the specified date(s) geolat : apparent longitude of the moon in degrees, referred to the ecliptic of the specified date(s) If  jd  is an array, then all output quantities are arrays of the same length as  jd . Method Derived from the Chapront ELP2000/82 Lunar Theory (Chapront-Touze' and Chapront, 1983, 124, 50), as described by Jean Meeus in Chapter 47 of ``Astronomical Algorithms'' (Willmann-Bell, Richmond), 2nd edition, 1998.  Meeus quotes an approximate accuracy of 10\" in longitude and 4\" in latitude, but he does not give the time range for this accuracy. Comparison of the IDL procedure with the example in ``Astronomical Algorithms'' reveals a very small discrepancy (~1 km) in the distance computation, but no difference in the position calculation. Example Find the position of the moon on April 12, 1992 julia> using AstroLib\n\njulia> jd = jdcnv(1992, 4, 12);\n\njulia> adstring(moonpos(jd)[1:2],precision=1)\n\" 08 58 45.23  +13 46 06.1\" This is within 1\" from the position given in the Astronomical Almanac. Plot the Earth-moon distance during 2016 with sampling of 6 hours.  Use  Plots.jl  for plotting using Dates\nusing Plots\npoints = DateTime(2016):Dates.Hour(6):DateTime(2017);\nplot(points, moonpos(jdcnv.(points))[3]) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1596,"pagetitle":"Reference","title":"AstroLib.mphase","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.mphase-Tuple{Real}","content":" AstroLib.mphase  —  Method mphase(jd) -> k Purpose Return the illuminated fraction of the Moon at given Julian date(s). Arguments jd : the Julian ephemeris date. Output The illuminated fraction  $k$  of Moon's disk, with  $0 ≤ k ≤ 1$ .  $k = 0$  indicates a new moon, while  $k = 1$  stands for a full moon. Method Algorithm from Chapter 46 of \"Astronomical Algorithms\" by Jean Meeus (Willmann-Bell, Richmond) 1991.   sunpos  and  moonpos  are used to get positions of the Sun and the Moon, and the Moon distance.  The selenocentric elongation of the Earth from the Sun (phase angle) is then computed, and used to determine the illuminated fraction. Example Plot the illuminated fraction of the Moon for every day in January 2018 with a hourly sampling.  Use  Plots.jl  for plotting using Dates\nusing Plots\npoints = DateTime(2018,01,01):Dates.Hour(1):DateTime(2018,01,31,23,59,59);\nplot(points, mphase.(jdcnv.(points))) Note that in this calendar month there are two full moons, this event is called  blue moon . Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1597,"pagetitle":"Reference","title":"AstroLib.nutate","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.nutate-Tuple{Real}","content":" AstroLib.nutate  —  Method nutate(jd) -> long, obliq Purpose Return the nutation in longitude and obliquity for a given Julian date. Arguments jd : Julian ephemeris date, it can be either a scalar or a vector Output The 2-tuple  (long, obliq) , where long : the nutation in longitude obl : the nutation in latitude If  jd  is an array,  long  and  obl  are arrays of the same length. Method Uses the formula in Chapter 22 of \"Astronomical Algorithms\" by Jean Meeus (1998, 2nd ed.) which is based on the 1980 IAU Theory of Nutation and includes all terms larger than 0.0003\". Example Find the nutation in longitude and obliquity 1987 on Apr 10 at 0h.  This is example 22.a from Meeus julia> using AstroLib\n\njulia> jd = jdcnv(1987, 4, 10);\n\njulia> nutate(jd)\n(-3.787931077110494, 9.44252069864449) Plot the daily nutation in longitude and obliquity during the 21st century. Use  Plots.jl  for plotting. using Dates\nusing Plots\nyears = DateTime(2000):DateTime(2100);\nlong, obl = nutate(jdcnv.(years));\nplot(years, long); plot(years, obl) You can see both the dominant large scale period of nutation, of 18.6 years, and smaller oscillations with shorter periods. Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1598,"pagetitle":"Reference","title":"AstroLib.ordinal","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.ordinal-Tuple{Integer}","content":" AstroLib.ordinal  —  Method ordinal(num) -> result Purpose Convert an integer to a correct English ordinal string. Explanation The first four ordinal strings are \"1st\", \"2nd\", \"3rd\", \"4th\", .... Arguments num : number to be made ordinal. It should be of type  Integer . Output result : ordinal string, such as \"1st\", \"3rd\", \"164th\", \"87th\", etc. Example julia> using AstroLib\n\njulia> ordinal.(1:5)\n5-element Vector{String}:\n \"1st\"\n \"2nd\"\n \"3rd\"\n \"4th\"\n \"5th\" Notes This function does not support float arguments, unlike the IDL implementation. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1599,"pagetitle":"Reference","title":"AstroLib.paczynski","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.paczynski-Tuple{Real}","content":" AstroLib.paczynski  —  Method paczynski(u) -> amplification Purpose Calculate gravitational microlensing amplification of a point-like source by a single point-like lens. Explanation Return the  gravitational microlensing  amplification of a point-like source by a single point-like lens, using Paczyński formula \\[A(u) = \\frac{u^2 + 2}{u\\sqrt{u^2 + 4}}\\] where  $u$  is the projected distance between the lens and the source in units of  Einstein radii . In order to speed up calculations for extreme values of  $u$ , the following asyntotic expressions for  $A(u)$  are used: \\[A(u) =\n\\begin{cases}\n 1/u & |u| ≪ 1 \\\\\n \\text{sgn}(u) & |u| ≫ 1\n\\end{cases}\\] Arguments u : projected distance between the lens and the source, in units of Einstein radii Output The microlensing amplification for the given distance. Example Calculate the microlensing amplification for  $u = 10^{-10}, 10^{-1}, 1, 10, 10^{10}$ : julia> paczynski.([1e-10, 1e-1, 1, 10, 1e10])\n5-element Vector{Float64}:\n  1.0e10\n 10.037461005722337\n  1.3416407864998738\n  1.0001922892047386\n  1.0 Notes The expression of  $A(u)$  of microlensing amplification has been given by Bohdan Paczyński in Paczynski, B. 1986, ApJ, 304, 1. DOI: 10.1086/164140 , Bibcode: 1986ApJ...304....1P The same expression was actually found by Albert Einstein half a century earlier: Einstein, A. 1936, Science, 84, 506. DOI: 10.1126/science.84.2188.506 , Bibcode: 1936Sci....84..506E source"},{"id":1600,"pagetitle":"Reference","title":"AstroLib.planck_freq","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.planck_freq-Tuple{Real, Real}","content":" AstroLib.planck_freq  —  Method planck_freq(frequency, temperature) -> black_body_flux Purpose Calculate the flux of a black body per unit frequency. Explanation Return the spectral radiance of a black body per unit frequency using  Planck's law \\[B_\\nu(\\nu, T) = \\frac{2h\\nu^3}{c^2} \\frac{1}{e^\\frac{h\\nu}{k_\\mathrm{B}T} - 1}\\] Arguments frequency : frequency at which the flux is to be calculated, in Hertz. temperature : the equilibrium temperature of the black body, in Kelvin. Output The spectral radiance of the black body, in units of W/(sr·m²·Hz). Example Plot the spectrum of a black body in  $[10^{12}, 10^{15.4}]$  Hz at 8000 K. Use  Plots.jl  for plotting. using Plots\nfrequency = exp10.(range(12, stop=15.4, length=1000));\ntemperature = ones(size(frequency)) * 8000;\nflux = planck_freq.(frequency, temperature);\nplot(frequency, flux) Notes planck_wave  calculates the flux of a black body per unit wavelength. source"},{"id":1601,"pagetitle":"Reference","title":"AstroLib.planck_wave","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.planck_wave-Tuple{Real, Real}","content":" AstroLib.planck_wave  —  Method planck_wave(wavelength, temperature) -> black_body_flux Purpose Calculate the flux of a black body per unit wavelength. Explanation Return the spectral radiance of a black body per unit wavelength using  Planck's law \\[B_λ(λ, T) = \\frac{2hc^2}{λ^5} \\frac{1}{e^{\\frac{hc}{λ k_\\mathrm{B}T}} - 1}\\] Arguments wavelength : wavelength at which the flux is to be calculated, in meters. temperature : the equilibrium temperature of the black body, in Kelvin. Output The spectral radiance of the black body, in units of W/(sr·m³). Example Plot the spectrum of a black body in  $[0, 3]$  µm at  $5000$  K.  Use  Plots.jl  for plotting. using Plots\nwavelength = range(0, stop=3e-6, length=1000);\ntemperature = ones(wavelength)*5000;\nflux = planck_wave.(wavelength, temperature);\nplot(wavelength, flux) Notes planck_freq  calculates the flux of a black body per unit frequency. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1602,"pagetitle":"Reference","title":"AstroLib.planet_coords","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.planet_coords-Tuple{Real, Integer}","content":" AstroLib.planet_coords  —  Method planet_coords(date, num) Purpose Find right ascension and declination for the planets when provided a date as input. Explanation This function uses the  helio  to get the heliocentric ecliptic coordinates of the planets at the given date which it then converts these to geocentric ecliptic coordinates ala \"Astronomical Algorithms\" by Jean Meeus (1991, p 209). These are then converted to right ascension and declination using  euler . The accuracy between the years 1800 and 2050 is better than 1 arcminute for the terrestial planets, but reaches 10 arcminutes for Saturn. Before 1850 or after 2050 the accuracy can get much worse. Arguments date : Can be either a single date or an array of dates. Each element can be either a  DateTime  type or Julian Date. It can be a scalar or vector. num : integer denoting planet number, scalar or vector 1 = Mercury, 2 = Venus, ... 9 = Pluto. If not in that change, then the program will throw an error. Output ra : right ascension of planet(J2000), in degrees dec : declination of the planet(J2000), in degrees Example Find the RA, Dec of Venus on 1992 Dec 20 julia> using AstroLib, Dates\n\njulia> adstring(planet_coords(DateTime(1992,12,20),2))\n\" 21 05 02.8  -18 51 41\" Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1603,"pagetitle":"Reference","title":"AstroLib.polrec","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.polrec-Tuple{Real, Real}","content":" AstroLib.polrec  —  Method polrec(radius, angle[, degrees=true]) -> x, y Purpose Convert 2D polar coordinates to rectangular coordinates. Explanation This is the partial inverse function of  recpol . Arguments radius : radial coordinate of the point.  It may be a scalar or an array. angle : the angular coordinate of the point.  It may be a scalar or an array of the same lenth as  radius . degrees  (optional boolean keyword): if  true , the  angle  is assumed to be in degrees, otherwise in radians.  It defaults to  false . Mandatory arguments can also be passed as the 2-tuple  (radius, angle) , so that it is possible to execute  recpol(polrec(radius, angle)) . Output A 2-tuple  (x, y)  with the rectangular coordinate of the input.  If  radius  and  angle  are arrays,  x  and  y  are arrays of the same length as  radius  and  angle . Example Get rectangular coordinates  $(x, y)$  of the point with polar coordinates  $(r, φ) = (1.7, 227)$ , with angle  $φ$  expressed in degrees. julia> using AstroLib\n\njulia> x, y = polrec(1.7, 227, degrees=true)\n(-1.1593972121062475, -1.2433012927525897) source"},{"id":1604,"pagetitle":"Reference","title":"AstroLib.posang","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.posang-Tuple{Integer, Vararg{Real, 4}}","content":" AstroLib.posang  —  Method posang(units, ra1, dec1, ra2, dec2) -> angular_distance Purpose Compute rigorous position angle of point 2 relative to point 1. Explanation Computes the rigorous position angle of point 2 (with given right ascension and declination) using point 1 (with given right ascension and declination) as the center. Arguments units : integer, can be either 0, or 1, or 2.  Describes units of inputs and output: 0: everything (input right ascensions and declinations, and output distance) is radians 1: right ascensions are in decimal hours, declinations in decimal degrees, output distance in degrees 2: right ascensions and declinations are in degrees, output distance in degrees ra1 :  right ascension or longitude of point 1 dec1 : declination or latitude of point 1 ra2 : right ascension or longitude of point 2 dec2 : declination or latitude of point 2 Both  ra1  and  dec1 , and  ra2  and  dec2  can be given as 2-tuples  (ra1, dec1)  and  (ra2, dec2) . Output Angle of the great circle containing  [ra2, dec2]  from the meridian containing  [ra1, dec1] , in the sense north through east rotating about  [ra1, dec1] . See  units  argument above for units. Method The \"four-parts formula\" from spherical trigonometry (p. 12 of Smart's Spherical Astronomy or p. 12 of Green' Spherical Astronomy). Example Mizar has coordinates (ra, dec) = (13h 23m 55.5s, +54° 55' 31'').  Its companion, Alcor, has coordinates (ra, dec) = (13h 25m 13.5s, +54° 59' 17''). Find the position angle of Alcor with respect to Mizar. julia> using AstroLib\n\njulia> posang(1, ten(13, 25, 13.5), ten(54, 59, 17), ten(13, 23, 55.5), ten(54, 55, 31))\n-108.46011246802047 Notes The function  sphdist  provides an alternate method of computing a spherical distance. Note that  posang  is not commutative: the position angle between A and B is  $θ$ , then the position angle between B and A is  $180 + θ$ . Code of this function is based on IDL Astronomy User's Library. source"},{"id":1605,"pagetitle":"Reference","title":"AstroLib.precess","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.precess-NTuple{4, Real}","content":" AstroLib.precess  —  Method precess(ra, dec, equinox1, equinox2[, FK4=true, radians=true]) -> prec_ra, prec_dec Purpose Precess coordinates from  equinox1  to  equinox2 . Explanation The default  (ra, dec)  system is FK5 based on epoch J2000.0 but FK4 based on B1950.0 is available via the  FK4  boolean keyword. Arguments ra : input right ascension, scalar or vector, in degrees, unless the  radians  keyword is set to  true dec : input declination, scalar or vector, in degrees, unless the  radians  keyword is set to  true equinox1 : original equinox of coordinates, numeric scalar. equinox2 : equinox of precessed coordinates. FK4  (optional boolean keyword): if this keyword is set to  true , the FK4 (B1950.0) system precession angles are used to compute the precession matrix. When it is  false , the default, use FK5 (J2000.0) precession angles. radians  (optional boolean keyword): if this keyword is set to  true , then the input and output right ascension and declination vectors are in radians rather than degrees. Output The 2-tuple  (ra, dec)  of coordinates modified by precession. Example The Pole Star has J2000.0 coordinates (2h, 31m, 46.3s, 89d 15' 50.6\"); compute its coordinates at J1985.0 julia> using AstroLib\n\njulia> ra, dec = ten(2,31,46.3)*15, ten(89,15,50.6)\n(37.94291666666666, 89.26405555555556)\n\njulia> adstring(precess(ra, dec, 2000, 1985), precision=1)\n\" 02 16 22.73  +89 11 47.3\" Precess the B1950 coordinates of Eps Ind (RA = 21h 59m,33.053s, DEC = -56d, 59', 33.053\") to equinox B1975. julia> using AstroLib\n\njulia> ra, dec = ten(21, 59, 33.053) * 15, ten(-56, 59, 33.053)\n(329.88772083333333, -56.992514722222225)\n\njulia> adstring(precess(ra, dec, 1950, 1975, FK4=true), precision=1)\n\" 22 01 15.46  -56 52 18.7\" Method Algorithm from \"Computational Spherical Astronomy\" by Taff (1983), p. 24. (FK4). FK5 constants from \"Explanatory Supplement To The Astronomical Almanac\" 1992, page 104 Table 3.211.1 (https://archive.org/details/131123ExplanatorySupplementAstronomicalAlmanac). Notes Accuracy of precession decreases for declination values near 90 degrees.  precess  should not be used more than 2.5 centuries from 2000 on the FK5 system (1950.0 on the FK4 system).  If you need better accuracy, use  bprecess  or  jprecess  as needed. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1606,"pagetitle":"Reference","title":"AstroLib.precess_cd","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.precess_cd","content":" AstroLib.precess_cd  —  Function precess_cd(cd, epoch1, epoch2, crval_old, crval_new[, FK4=true]) -> cd Purpose Precess the coordinate description matrix. Explanation The coordinate matrix is precessed from epoch1 to epoch2. Arguments cd : 2×2 coordinate description matrix in degrees epoch1 : original equinox of coordinates, scalar epoch2 : equinox of precessed coordinates, scalar crval_old : 2 element vector containing right ascension and declination in degrees of the reference pixel in the original equinox crval_new : 2 element vector giving crval in the new equinox FK4  (optional boolean keyword): if this keyword is set to  true , then the precession constants are taken in the FK4 reference frame. When it is  false , the default is the FK5 frame Output cd : coordinate description containing precessed values Example julia> using AstroLib\n\njulia> precess_cd([20 60; 45 45], 1950, 2000, [34, 58], [12, 83])\n2×2 Matrix{Float64}:\n  48.8944  147.075\n 110.188   110.365 Notes Code of this function is based on IDL Astronomy User's Library. This function should not be used for values more than 2.5 centuries from the year 1900. This function calls  sec2rad ,  precess  and  bprecess . source"},{"id":1607,"pagetitle":"Reference","title":"AstroLib.precess_xyz","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.precess_xyz-NTuple{5, Real}","content":" AstroLib.precess_xyz  —  Method precess_xyz(x, y, z, equinox1, equinox2) -> prec_x, prec_y, prec_z Purpose Precess equatorial geocentric rectangular coordinates. Arguments x ,  y ,  z : scalars or vectors giving heliocentric rectangular coordinates. equinox1 : original equinox of coordinates, numeric scalar. equinox2 : equinox of precessed coordinates, numeric scalar. Input coordinates can be given also a 3-tuple  (x, y, z) . Output The 3-tuple  (x, y, z)  of coordinates modified by precession. Example Precess 2000 equinox coordinates  (1, 1, 1)  to 2050. julia> using AstroLib\n\njulia> precess_xyz(1, 1, 1, 2000, 2050)\n(0.9838854500981734, 1.0110925876508692, 1.0048189888146941) Method The equatorial geocentric rectangular coordinates are converted to right ascension and declination, precessed in the normal way, then changed back to  x ,  y  and  z  using unit vectors. Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1608,"pagetitle":"Reference","title":"AstroLib.premat","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.premat-Tuple{Real, Real}","content":" AstroLib.premat  —  Method premat(equinox1, equinox2[, FK4=true]) -> precession_matrix Purpose Return the precession matrix needed to go from  equinox1  to  equinox2 . Explanation This matrix is used by  precess  and  baryvel  to precess astronomical coordinates. Arguments equinox1 : original equinox of coordinates. equinox2 : equinox of precessed coordinates. FK4  (optional boolean keyword): if this keyword is set to  true , the FK4 (B1950.0) system precession angles are used to compute the precession matrix. When it is  false , the default, use FK5 (J2000.0) precession angles. Output A 3×3 matrix, used to precess equatorial rectangular coordinates. Example Return the precession matrix from 1950.0 to 1975.0 in the FK4 system julia> using AstroLib\n\njulia> premat(1950, 1975, FK4=true)\n3×3 StaticArraysCore.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n 0.999981    -0.00558775  -0.00242909\n 0.00558775   0.999984    -6.78691e-6\n 0.00242909  -6.78633e-6   0.999997 Method FK4 constants from \"Computational Spherical Astronomy\" by Taff (1983), p. 24. (FK4). FK5 constants from \"Explanatory Supplement To The Astronomical Almanac\" 1992, page 104 Table 3.211.1 (https://archive.org/details/131123ExplanatorySupplementAstronomicalAlmanac). Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1609,"pagetitle":"Reference","title":"AstroLib.rad2sec","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.rad2sec-Tuple{Real}","content":" AstroLib.rad2sec  —  Method rad2sec(rad) -> seconds Purpose Convert from radians to seconds. Argument rad : number of radians. Output The number of seconds corresponding to  rad . Example julia> using AstroLib\n\njulia> rad2sec(1)\n206264.80624709636 Notes Use  sec2rad  to convert seconds to radians. source"},{"id":1610,"pagetitle":"Reference","title":"AstroLib.radec","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.radec-Tuple{Real, Real}","content":" AstroLib.radec  —  Method radec(ra::Real, dec::Real[, hours=false]) -> ra_hours, ra_minutes, ra_seconds, dec_degrees, dec_minutes, dec_seconds Purpose Convert right ascension and declination from decimal to sexagesimal units. Explanation The conversion is to sexagesimal hours for right ascension, and sexagesimal degrees for declination. Arguments ra : decimal right ascension, scalar or array.  It is expressed in degrees, unless the optional keyword  hours  is set to  true . dec : declination in decimal degrees, scalar or array, same number of elements as  ra . hours  (optional boolean keyword): if  false  (the default),  ra  is assumed to be given in degrees, otherwise  ra  is assumed to be expressed in hours. Output A 6-tuple of  AbstractFloat : (ra_hours, ra_minutes, ra_seconds, dec_degrees, dec_minutes, dec_seconds) If  ra  and  dec  are arrays, also each element of the output 6-tuple are arrays of the same dimension. Example Position of Sirius in the sky is (ra, dec) = (6.7525, -16.7161), with right ascension expressed in hours.  Its sexagesimal representation is given by julia> using AstroLib\n\njulia> radec(6.7525, -16.7161, hours=true)\n(6.0, 45.0, 9.0, -16.0, 42.0, 57.9600000000064) source"},{"id":1611,"pagetitle":"Reference","title":"AstroLib.recpol","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.recpol-Tuple{Real, Real}","content":" AstroLib.recpol  —  Method recpol(x, y[, degrees=false]) -> radius, angle Purpose Convert 2D rectangular coordinates to polar coordinates. Explanation This is the partial inverse function of  polrec . Arguments x : the abscissa coordinate of the point.  It may be a scalar or an array. y : the ordinate coordinate of the point.  It may be a scalar or an array of the same lenth as  x . degrees  (optional boolean keyword): if  true , the output  angle  is given in degrees, otherwise in radians.  It defaults to  false . Mandatory arguments may also be passed as the 2-tuple  (x, y) , so that it is possible to execute  polrec(recpol(x, y)) . Output A 2-tuple  (radius, angle)  with the polar coordinates of the input.  The coordinate  angle  coordinate lies in the range  $[-π, π]$  if  degrees=false , or  $[-180, 180]$  when  degrees=true . If  x  and  y  are arrays,  radius  and  angle  are arrays of the same length as  radius  and  angle . Example Calculate polar coordinates  $(r, φ)$  of point with rectangular coordinates  $(x, y) = (2.24, -1.87)$ . julia> using AstroLib\n\njulia> r, phi = recpol(2.24, -1.87)\n(2.9179616172938263, -0.6956158538564537) Angle  $φ$  is given in radians. source"},{"id":1612,"pagetitle":"Reference","title":"AstroLib.rhotheta","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.rhotheta-NTuple{8, Real}","content":" AstroLib.rhotheta  —  Method rhotheta(period, periastron, eccentricity, semimajor_axis, inclination, omega, omega2, epoch) -> rho, theta Purpose Calculate the separation and position angle of a binary star. Explanation This function will return the separation  $ρ$  and position angle  $θ$  of a visual binary star derived from its orbital elements.  The algorithms described in the following book will be used: Meeus J., 1992, Astronomische Algorithmen, Barth.  Compared to the examples given at page 400 and no discrepancy found. Arguments period : period [year] periastro : time of periastron passage [year] eccentricity : eccentricity of the orbit semimajor_axis : semi-major axis [arc second] inclination : inclination angle [degree] omega : node [degree] omega2 : longitude of periastron [degree] epoch : epoch of observation [year] All input parameters have to be scalars. Output The 2-tuple  $(ρ, θ)$ , where $ρ$  is separation [arc second], and $θ$  is position angle (degree). Example Find the position of Eta Coronae Borealis at the epoch 2016 julia> using AstroLib\n\njulia> ρ, θ = rhotheta(41.623, 1934.008, 0.2763, 0.907, 59.025, 23.717, 219.907, 2016)\n(0.6351167848659552, 214.42513387396497) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1613,"pagetitle":"Reference","title":"AstroLib.sec2rad","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.sec2rad-Tuple{Real}","content":" AstroLib.sec2rad  —  Method sec2rad(sec) -> radians Purpose Convert from seconds to radians. Argument sec : number of seconds. Output The number of radians corresponding to  sec . Example julia> using AstroLib\n\njulia> sec2rad(3600 * 30)\n0.5235987755982988 Notes Use  rad2sec  to convert radians to seconds. source"},{"id":1614,"pagetitle":"Reference","title":"AstroLib.sixty","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.sixty-Tuple{Real}","content":" AstroLib.sixty  —  Method sixty(number) -> [deg, min, sec] Purpose Converts a decimal number to sexagesimal. Explanation The reverse of  ten  function. Argument number : decimal number to be converted to sexagesimal. Output An array of three  AbstractFloat , that are the sexagesimal counterpart (degrees, minutes, seconds) of  number . Example julia> using AstroLib\n\njulia> sixty(-0.615)\n3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):\n -0.0\n 36.0\n 54.0 Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1615,"pagetitle":"Reference","title":"AstroLib.sphdist","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.sphdist-NTuple{4, Real}","content":" AstroLib.sphdist  —  Method sphdist(long1, lat1, long2, lat2[, degrees=true]) -> angular_distance Purpose Angular distance between points on a sphere. Arguments long1 :  longitude of point 1 lat1 : latitude of point 1 long2 : longitude of point 2 lat2 : latitude of point 2 degrees  (optional boolean keyword): if  true , all angles, including the output distance, are assumed to be in degrees, otherwise they are all in radians.  It defaults to  false . Output Angular distance on a sphere between points 1 and 2, as an  AbstractFloat .  It is expressed in radians unless  degrees  keyword is set to  true . Example julia> using AstroLib\n\njulia> sphdist(120, -43, 175, +22)\n1.5904422616007134 Notes gcirc  function is similar to  sphdist , but may be more suitable for astronomical applications. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1616,"pagetitle":"Reference","title":"AstroLib.sunpos","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.sunpos","content":" AstroLib.sunpos  —  Function sunpos(jd[, radians=false]) -> ra, dec, elong, obliquity Purpose Compute the right ascension and declination of the Sun at a given date. Arguments jd : the Julian date of when you want to calculate Sun position.  It can be either a scalar or a vector.  Use  jdcnv  to get the Julian date for a given date and time. radians  (optional boolean keyword): if set to  true , all output quantities are given in radians.  The default is  false , so all quantities are given in degrees. Output The 4-tuple  (ra, dec, elong, obliquity) : ra : the right ascension of the Sun at that date dec : the declination of the Sun at that date elong : ecliptic longitude of the Sun at that date obliquity : the obliquity of the ecliptic All quantities are given in degrees, unless  radians  keyword is set to  true  (see \"Arguments\" section).  If  jd  is an array, arrays of the same given as  jd  are returned. Method Uses a truncated version of Newcomb's Sun.  Adapted from the IDL routine SUN_POS by CD Pike, which was adapted from a FORTRAN routine by B. Emerson (RGO). Example Find the apparent right ascension and declination of the Sun on May 1, 1982 julia> using AstroLib\n\njulia> adstring(sunpos(jdcnv(1982, 5, 1))[1:2], precision=2)\n\" 02 31 32.614  +14 54 34.92\" The Astronomical Almanac gives  02 31 32.58 +14 54 34.9  so the error for this case is < 0.5\". Plot the apparent right ascension, in hours, and declination of the Sun, in degrees, for every day in 2016.  Use  Plots.jl  for plotting. using Plots\nusing Dates\n\ndays = DateTime(2016):Day(1):DateTime(2016, 12, 31);\nra, declin = sunpos(jdcnv.(days));\nplot(days, ra/15); plot(days, declin) Notes Patrick Wallace (Rutherford Appleton Laboratory, UK) has tested the accuracy of a C adaptation of the present algorithm and found the following results.  From 1900-2100  sunpos  gave 7.3 arcsec maximum error, 2.6 arcsec RMS.  Over the shorter interval 1950-2050 the figures were 6.4 arcsec max, 2.2 arcsec RMS. The returned  ra  and  dec  are in the given date's equinox. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1617,"pagetitle":"Reference","title":"AstroLib.ten","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.ten","content":" AstroLib.ten  —  Function ten(deg[, min, sec]) -> decimal\nten(\"deg:min:sec\") -> decimal Purpose Converts a sexagesimal number or string to decimal. Explanation ten  is the inverse of the  sixty  function. Arguments ten  takes as argument either three scalars ( deg ,  min ,  sec ) or a string. The string should have the form  \"deg:min:sec\"  or  \"deg min sec\" .  Also any iterable like  (deg, min, sec)  or  [deg, min, sec]  is accepted as argument. If minutes and seconds are not specified they default to zero. Output The decimal conversion of the sexagesimal numbers provided is returned. Method The formula used for the conversion is \\[\\mathrm{sign}(\\mathrm{deg})·\\left(|\\mathrm{deg}| + \\frac{\\mathrm{min}}{60} + \\frac{\\mathrm{sec}}{3600}\\right)\\] Example julia> using AstroLib\n\njulia> ten(-0.0, 19, 47)\n-0.3297222222222222\n\njulia> ten(\"+5:14:58\")\n5.249444444444444\n\njulia> ten(\"-10 26\")\n-10.433333333333334\n\njulia> ten((-10, 26))\n-10.433333333333334 Notes These functions cannot deal with  -0  (negative integer zero) in numeric input. If it is important to give sense to negative zero, you can either make sure to pass a floating point negative zero  -0.0  (this is the best option), or use negative minutes and seconds, or non-integer negative degrees and minutes. source"},{"id":1618,"pagetitle":"Reference","title":"AstroLib.tic_one","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.tic_one","content":" AstroLib.tic_one  —  Function tic_one(zmin, pixx, incr[, ra=true]) -> min2, tic1 Purpose Determine the position of the first tic mark for astronomical images. Explanation For use in labelling images with right ascension and declination axes. This routine determines the position in pixels of the first tic. Arguments zmin : astronomical coordinate value at axis zero point (degrees  or hours). pixx : distance in pixels between tic marks (usually obtained from  tics ). incr  - increment in minutes for labels (usually an even number obtained  from the procedure  tics ). ra  (optional boolean keyword): if true, incremental value being entered  is in minutes of time, else it is assumed that value is in else it's in minutes of arc.  Default is false. Output The 2 tuple  (min2, tic1) : min2 : astronomical coordinate value at first tic mark tic1 : position in pixels of first tic mark Example Suppose a declination axis has a value of 30.2345 degrees at its zero point.  A tic mark is desired every 10 arc minutes, which corresponds to 12.74 pixels, with increment for labels being 10 minutes. Then julia> using AstroLib\n\njulia> tic_one(30.2345, 12.74, 10)\n(30.333333333333332, 7.554820000000081) yields values of min2 ≈ 30.333 and tic1 ≈ 7.55482, i.e. the first tic mark should be labeled 30 deg 20 minutes and be placed at pixel value 7.55482. Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1619,"pagetitle":"Reference","title":"AstroLib.ticpos","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.ticpos-Tuple{Real, Real, Real}","content":" AstroLib.ticpos  —  Method ticpos(deglen, pixlen, ticsize) -> ticsize, incr, units Purpose Specify distance between tic marks for astronomical coordinate overlays. Explanation User inputs number an approximate distance between tic marks, and the axis length in degrees.  ticpos  will return a distance between tic marks such that the separation is a round multiple in arc seconds, arc minutes, or degrees. Arguments deglen : length of axis in degrees, positive scalar pixlen : length of axis in plotting units (pixels), postive scalar ticsize : distance between tic marks (pixels).  This value will be  adjusted by  ticpos  such that the distance corresponds to a round  multiple in the astronomical coordinate. Output The 3-tuple  (ticsize, incr, units) : ticsize : distance between tic marks (pixels), positive scalar incr : incremental value for tic marks in round units given  by the  units  parameter units : string giving units of ticsize, either 'Arc Seconds', 'Arc Minutes', or 'Degrees' Example Suppose a 512 × 512 image array corresponds to 0.2 × 0.2 degrees on the sky. A tic mark is desired in round angular units, approximately every 75 pixels. Then julia> using AstroLib\n\njulia> ticpos(0.2, 512, 75)\n(85.33333333333333, 2.0, \"Arc Minutes\") i.e. a good tic mark spacing is every 2 arc minutes, corresponding to 85.333 pixels. Notes All the arguments taken as input are assumed to be positive in nature. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1620,"pagetitle":"Reference","title":"AstroLib.tics","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.tics","content":" AstroLib.tics  —  Function tics(radec_min, radec_max, numx, ticsize[, ra=true]) -> ticsize, incr Purpose Compute a nice increment between tic marks for astronomical images. Explanation For use in labelling a displayed image with right ascension or declination axes.  An approximate distance between tic marks is input, and a new value is computed such that the distance between tic marks is in simple increments of the tic label values. Arguements radec_min  : minimum axis value (degrees). radec_min  : maximum axis value (degrees). numx  : number of pixels in x direction. ticsize  : distance between tic marks (pixels). ra  (optional boolean keyword): if true, incremental value would be in minutes of time. Default is false. Output A 2-tuple  (ticsize, incr) : ticsize  : distance between tic marks (pixels). incr  : incremental value for tic labels.  The format is dependent on the optional keyword. If true (i.e for right ascension), it's in minutes of time, else it's in minutes of arc (for declination). Example julia> using AstroLib\n\njulia> tics(55, 60, 100.0, 1/2)\n(0.66, 2.0)\n\njulia> tics(30, 60, 12, 2, true)\n(2.75, 30.0) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1621,"pagetitle":"Reference","title":"AstroLib.true_obliquity","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.true_obliquity-Tuple{Real}","content":" AstroLib.true_obliquity  —  Method true_obliquity(jd) -> t_eps Purpose Return the true obliquity of the ecliptic for a given Julian date Explanation The function is used by the  co_aberration  procedure. Arguments jd : Julian date. Output t_eps : true obliquity of the ecliptic, in radians Example julia> using AstroLib\n\njulia> true_obliquity(jdcnv(1978,01,7,11, 01))\n0.4090953896211926 Notes The function calls  mean_obliquity . source"},{"id":1622,"pagetitle":"Reference","title":"AstroLib.trueanom","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.trueanom-Tuple{Real, Real}","content":" AstroLib.trueanom  —  Method trueanom(E, e) -> true anomaly Purpose Calculate true anomaly for a particle in elliptic orbit with eccentric anomaly  $E$  and eccentricity  $e$ . Explanation In the two-body problem, once that the  Kepler's equation  is solved and  $E(t)$  is determined, the polar coordinates  $(r(t), θ(t))$  of the body at time  $t$  in the elliptic orbit are given by \\[θ(t) = 2 \\arctan \\left( \\sqrt{\\frac{1 + e}{1 - e}} \\tan\\frac{E(t)}{2} \\right)\\] \\[r(t) = \\frac{a(1 - e^2)}{1 + e\\cos(θ(t) - θ_0)}\\] in which  $a$  is the semi-major axis of the orbit, and  $θ_0$  the value of angular coordinate at time  $t = t_0$ . Arguments E : eccentric anomaly. e : eccentricity, in the elliptic motion regime ( $0 ≤ e ≤ 1$ ) Output The true anomaly. Example Plot the true anomaly as a function of mean anomaly for eccentricity  $e = 0, 0.5, 0.9$ . Use  Plots.jl  for plotting. using Plots\nM = range(0, stop=2pi, length=1001)[1:end-1];\np = plot()\nfor ecc in (0, 0.5, 0.9)\n    plot!(p, M, mod2pi.(trueanom.(kepler_solver.(M, ecc), ecc)))\nend\np Notes The eccentric anomaly can be calculated with  kepler_solver  function. source"},{"id":1623,"pagetitle":"Reference","title":"AstroLib.uvbybeta","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.uvbybeta","content":" AstroLib.uvbybeta  —  Function uvbybeta(by, m1, c1, n[, hbeta=NaN, eby_in=NaN]) -> te, mv, eby, delm0, radius Purpose Derive dereddened colors, metallicity, and Teff from Stromgren colors. Arguments by : Stromgren b-y color m1 : Stromgren line-blanketing parameter c1 : Stromgren Balmer discontinuity parameter n : Integer which can be any value between 1 to 8, giving approximate stellar classification. B0 - A0, classes III - V, 2.59 < Hbeta < 2.88,-0.20 <   c0   < 1.00 B0 - A0, class   Ia     , 2.52 < Hbeta < 2.59,-0.15 <   c0   < 0.40 B0 - A0, class   Ib     , 2.56 < Hbeta < 2.61,-0.10 <   c0   < 0.50 B0 - A0, class   II     , 2.58 < Hbeta < 2.63,-0.10 <   c0   < 0.10 A0 - A3, classes III - V, 2.87 < Hbeta < 2.93,-0.01 < (b-y)o < 0.06 A3 - F0, classes III - V, 2.72 < Hbeta < 2.88, 0.05 < (b-y)o < 0.22 F1 - G2, classes III - V, 2.60 < Hbeta < 2.72, 0.22 < (b-y)o < 0.39 G2 - M2, classes  IV - V, 0.20 < m0    < 0.76, 0.39 < (b-y)o < 1.00 hbeta  (optional): H-beta line strength index. If it is not supplied, then by default its value will be  NaN  and the code will estimate a value based on by, m1,and c1. It is not used for stars in group 8. eby_in  (optional): specifies the E(b-y) color to use. If not supplied, then by default its value will be  NaN  and E(b-y) will be estimated from the Stromgren colors. Output te : approximate effective temperature mv : absolute visible magnitude eby : color excess E(b-y) delm0 : metallicity index, delta m0, may not be calculable for early B stars and so returns  NaN . radius : stellar radius (R/R(solar)) Example Determine the stellar parameters of 5 stars given their Stromgren parameters julia> using AstroLib\n\njulia> by = [-0.001, 0.403, 0.244, 0.216, 0.394];\n\njulia> m1 = [0.105, -0.074, -0.053, 0.167, 0.186];\n\njulia> c1 = [0.647, 0.215, 0.051, 0.785, 0.362];\n\njulia> hbeta = [2.75, 2.552, 2.568, 2.743, 0];\n\njulia> nn = [1, 2, 3, 7, 8];\n\njulia> uvbybeta.(by, m1, c1, nn, hbeta)\n5-element Vector{NTuple{5, Float64}}:\n (13057.535222326893, -0.27375469585031265, 0.04954396423248884, -0.008292894218734928, 2.7136529525371897)\n (14025.053834219656, -6.907050783073221, 0.4140562248995983, NaN, 73.50771722263974)\n (18423.76405400214, -5.935816553877892, 0.2828247876690783, NaN, 39.84106215808709)\n (7210.507090112837, 2.2180408083364167, 0.018404079180028038, 0.018750927360588615, 2.0459018065648165)\n (5755.671513413262, 3.9449408311022, -0.025062997393370458, 0.03241423718769865, 1.5339239690774464) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1624,"pagetitle":"Reference","title":"AstroLib.vactoair","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.vactoair-Tuple{Real}","content":" AstroLib.vactoair  —  Method vactoair(wave_vacuum) -> wave_air Purpose Converts vacuum wavelengths to air wavelengths. Explanation Corrects for the index of refraction of air under standard conditions. Wavelength values below  $2000 Å$  will not be altered.  Uses relation of Ciddor (1996). Arguments wave_vacuum : vacuum wavelength in angstroms.  Wavelengths are corrected for the index of refraction of air under standard conditions.  Wavelength values below  $2000 Å$  will  not  be altered, take care within  $[1 Å, 2000 Å]$ . Output Air wavelength in angstroms. Method Uses relation of Ciddor (1996), Applied Optics 35, 1566 ( http://adsabs.harvard.edu/abs/1996ApOpt..35.1566C ). Example If the vacuum wavelength is  w = 2000 , then  vactoair(w)  yields an air wavelength of  1999.353 . julia> using AstroLib\n\njulia> vactoair(2000)\n1999.3526230448367 Notes airtovac  converts air wavelengths to vacuum wavelengths. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1625,"pagetitle":"Reference","title":"AstroLib.xyz","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.xyz","content":" AstroLib.xyz  —  Function xyz(jd[, equinox]) -> x, y, z, v_x, v_y, v_z Purpose Calculate geocentric  $x$ ,  $y$ , and  $z$  and velocity coordinates of the Sun. Explanation Calculates geocentric  $x$ ,  $y$ , and  $z$  vectors and velocity coordinates ( $dx$ ,  $dy$  and  $dz$ ) of the Sun.  (The positive  $x$  axis is directed towards the equinox, the  $y$ -axis, towards the point on the equator at right ascension 6h, and the  $z$  axis toward the north pole of the equator).  Typical position accuracy is  $<10^{-4}$  AU (15000 km). Arguments jd : number of Reduced Julian Days for the wanted date.  It can be either a scalar or a vector. equinox  (optional numeric argument): equinox of output. Default is 1950. You can use  juldate  to get the number of Reduced Julian Days for the selected dates. Output The 6-tuple  $(x, y, z, v_x, v_y, v_z)$ , where $x, y, z$ : scalars or vectors giving heliocentric rectangular coordinates (in AU) for each date supplied.  Note that  $\\sqrt{x^2 + y^2 + z^2}$  gives the Earth-Sun distance for the given date. $v_x, v_y, v_z$ : velocity vectors corresponding to  $x, y$ , and  $z$ . Example What were the rectangular coordinates and velocities of the Sun on 1999-01-22T00:00:00 (= JD 2451200.5) in J2000 coords?  Note: Astronomical Almanac (AA) is in TDT, so add 64 seconds to UT to convert. julia> using AstroLib, Dates\n\njulia> jd = juldate(DateTime(1999, 1, 22))\n51200.5\n\njulia> xyz(jd + 64/86400, 2000)\n(0.514568709240398, -0.7696326261820209, -0.33376880143023935, 0.014947267514079971, 0.008314838205477328, 0.003606857607575486) Compare to Astronomical Almanac (1999 page C20)             x  (AU)        y  (AU)     z (AU)\nxyz:      0.51456871   -0.76963263  -0.33376880\nAA:       0.51453130   -0.7697110   -0.3337152\nabs(err): 0.00003739    0.00007839   0.00005360\nabs(err)\n    (km):   5609          11759         8040 NOTE: Velocities in AA are for Earth/Moon barycenter       (a very minor offset) see AA 1999 page E3            x vel (AU/day) y vel (AU/day)   z vel (AU/day)\nxyz:      -0.014947268   -0.0083148382    -0.0036068576\nAA:       -0.01494574    -0.00831185      -0.00360365\nabs(err):  0.000001583    0.0000029886     0.0000032076\nabs(err)\n (km/sec): 0.00265        0.00519          0.00557 Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1626,"pagetitle":"Reference","title":"AstroLib.ydn2md","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.ydn2md-Tuple{Integer, Integer}","content":" AstroLib.ydn2md  —  Method ydn2md(year, day) -> date Purpose Convert from year and day number of year to a date. Explanation Returns the date corresponding to the  day  of  year . Arguments year : the year, as an integer. day : the day of  year , as an integer. Output The date, of  Date  type, of  $\\text{day} - 1$  days after January 1st of  year . Example Find the date of the 60th and 234th days of the year 2016. julia> using AstroLib\n\njulia> ydn2md.(2016, [60, 234])\n2-element Vector{Dates.Date}:\n 2016-02-29\n 2016-08-21 Note ymd2dn  converts from a date to day of the year. source"},{"id":1627,"pagetitle":"Reference","title":"AstroLib.ymd2dn","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.ymd2dn","content":" AstroLib.ymd2dn  —  Function ymd2dn(date) -> number_of_days Purpose Convert from a date to day of the year. Explanation Returns the day of the year for  date  with January 1st being day 1. Arguments date : the date with  Date  type.  Can be a single date or an array of dates. Output The day of the year for the given  date .  If  date  is an array, returns an array of days. Example Find the days of the year for March 5 in the years 2015 and 2016 (this is a leap year). julia> using AstroLib, Dates\n\njulia> ymd2dn.([Date(2015, 3, 5), Date(2016, 3, 5)])\n2-element Vector{Int64}:\n 64\n 65 Note ydn2md  converts from year and day number of year to a date. source"},{"id":1628,"pagetitle":"Reference","title":"AstroLib.zenpos","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.zenpos","content":" AstroLib.zenpos  —  Function zenpos(jd, latitude, longitude) -> zenith_right_ascension, declination\nzenpos(date, latitude, longitude, tz) -> zenith_right_ascension, declination Purpose Return the zenith right ascension and declination in radians for a given Julian date or a local civil time and timezone. Explanation The local sidereal time is computed with the help of  ct2lst , which is the right ascension of the zenith. This and the observatories latitude (corresponding to the declination) are converted to radians and returned as the zenith direction. Arguments The function can be called in two different ways. The arguments common to both methods are  latitude  and  longitude : latitude  : latitude of the desired location. longitude  : longitude of the desired location. The zenith direction can be computed either by providing the Julian date: jd  : the Julian date of the date and time for which the zenith position is desired. or the time zone and the date: tz : the time zone (in hours) of the desired location (e.g. 4 = EDT, 5 = EST) date : the local civil time with type  DateTime . Output A 2-tuple  (ra, dec) : ra  : the right ascension (in radians) of the zenith. dec  : the declination (in radians) of the zenith. Example julia> using AstroLib, Dates\n\njulia> zenpos(DateTime(2017, 04, 25, 18, 59), 43.16, -24.32, 4)\n(0.946790432684706, 0.7532841051607526)\n\njulia> zenpos(jdcnv(2016, 05, 05, 13, 41), ten(35,0,42), ten(135,46,6))\n(3.5757821152779536, 0.6110688599440813) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1631,"pagetitle":"Home","title":"BoxLeastSquares.jl","ref":"/previews/PR43/BoxLeastSquares/stable/#BoxLeastSquares.jl","content":" BoxLeastSquares.jl"},{"id":1632,"pagetitle":"Home","title":"Installation","ref":"/previews/PR43/BoxLeastSquares/stable/#Installation","content":" Installation To install use  Pkg . From the REPL, press  ]  to enter Pkg-mode pkg> add BoxLeastSquares If you want to use the most up-to-date version of the code, check it out from  main pkg> add BoxLeastSquares#main"},{"id":1633,"pagetitle":"Home","title":"Usage","ref":"/previews/PR43/BoxLeastSquares/stable/#Usage","content":" Usage First, import the package julia> using BoxLeastSquares you can optionally alias the package name, too julia> import BoxLeastSquares as BLS now, load some data. If you don't have an estimate of the y error it will default to 1. julia> t, y, yerr = load_data(); # load data somehow The primary interface is through the  BLS  method julia> result = BLS(t, y, yerr; duration=0.16)\nBLSPeriodogram\n==============\ninput dim: 1000\noutput dim: 1820\nperiod range: 0.32 - 5.014724142709022\nduration range: 0.16 - 0.16\nobjective: likelihood\n\nparameters\n----------\nindex: 1633\nperiod: 1.99930396919953\nduration: 0.16\nt0: 0.5001330656464655\ndepth: 0.19594118110109113 ± 0.0008688097746093883\nsnr: 225.52828804117118\nlog-likelihood: 27396.365214805144 to extract the parameters in a convenient named tuple use  BoxLeastSquares.params julia> BoxLeastSquares.params(result)\n(index = 1633, power = 27396.365214805144, period = 1.99930396919953, duration = 0.16, t0 = 0.5001330656464655, depth = 0.19594118110109113, depth_err = 0.0008688097746093883, snr = 225.52828804117118, loglike = 27396.365214805144) The period grid was automatically determined using  autoperiod , but you can supply your own, too: julia> periods = exp.(range(log(2) - 0.1, log(2) + 0.1, length=1000));\n\njulia> result_fine = BLS(t, y, yerr; duration=0.12:0.01:0.20, periods=periods)\nBLSPeriodogram\n==============\ninput dim: 1000\noutput dim: 1000\nperiod range: 1.809674836071919 - 2.210341836151295\nduration range: 0.12 - 0.2\nobjective: likelihood\n\nparameters\n----------\nindex: 503\nperiod: 2.001001251543549\nduration: 0.168\nt0: 0.4961330656464656\ndepth: 0.19466955969052016 ± 0.0008627202098527317\nsnr: 225.64622628204188\nlog-likelihood: 27457.6383039924"},{"id":1634,"pagetitle":"Home","title":"Unitful.jl","ref":"/previews/PR43/BoxLeastSquares/stable/#Unitful.jl","content":" Unitful.jl BoxLeastSquares.jl is fully compatible with  Unitful.jl  (although it is not a dependency of the library). For example julia> using Unitful\n\njulia> tu = t * u\"d\";\n\njulia> results_units = BLS(tu, y, yerr; duration=(2:0.1:4)u\"hr\")\nBLSPeriodogram\n==============\ninput dim: 1000\noutput dim: 3343\nperiod range: 0.3333333333333333 d - 4.988348864592586 d\nduration range: 2.0 hr - 4.0 hr\nobjective: likelihood\n\nparameters\n----------\nindex: 2986\nperiod: 2.0019235780121827 d\nduration: 3.8000000000000003 hr\nt0: 0.4916330656464656 d\ndepth: 0.19445716575012517 ± 0.0008692454825826517\nsnr: 223.70799693127577\nlog-likelihood: 26953.643422397385"},{"id":1635,"pagetitle":"Home","title":"Plotting","ref":"/previews/PR43/BoxLeastSquares/stable/#Plotting","content":" Plotting BoxLeastSquares.BLSPeriodogram  has plotting shorthands built right in- by default it will plot the period grid and the computed power using Plots, UnitfulRecipes\n\nplot(results_units, label=\"\") now let's look at how the transit model compares to the data pars = BoxLeastSquares.params(results_units)\nwrap = 0.5 * pars.period\nphases = @. (mod(t - pars.t0 + wrap, pars.period) - wrap) / pars.period\ninds = sortperm(phases)\nmodel = BoxLeastSquares.model(results_units)\n\nscatter(phases[inds], y[inds], yerr=yerr[inds],\n    label=\"data\", xlabel=\"phase\", xlim=(-0.2, 0.2), leg=:bottomright)\nplot!(phases[inds], model[inds], lw=3, label=\"BLS model\")"},{"id":1636,"pagetitle":"Home","title":"Performance","ref":"/previews/PR43/BoxLeastSquares/stable/#Performance","content":" Performance This code has been benchmarked against the C implementation in  astropy.timeseries.bls . The C version uses OpenMP to multi-thread some parts of the core BLS algorithm, but BoxLeastSquares.jl has no threading support currently. For a fair comparison, we set  OMP_NUM_THREADS  to 1 for the following tests. This first benchmark is simply the time it takes to evaluate the BLS periodogram. Periods are pre-computed using  autoperiod . We simulate different sizes of data sets (x-axis) as well as different sizes of period grids (shape). This benchmark does not use units. The code can be found in  bench/benchmark.jl . Here is the information for my system- Julia Version 1.6.0\nCommit f9720dc2eb* (2021-03-24 12:55 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin20.3.0)\n  CPU: Intel(R) Core(TM) i5-8259U CPU @ 2.30GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, skylake)\nEnvironment:\n  OMP_NUM_THREADS = 1\n  JULIA_NUM_THREADS = 1"},{"id":1637,"pagetitle":"Home","title":"Contributing and Support","ref":"/previews/PR43/BoxLeastSquares/stable/#Contributing-and-Support","content":" Contributing and Support If you would like to contribute, feel free to open a  pull request . If you want to discuss something before contributing, head over to  discussions  and join or open a new topic. If you're having problems with something, open an  issue ."},{"id":1640,"pagetitle":"API/Reference","title":"API/Reference","ref":"/previews/PR43/BoxLeastSquares/stable/api/#API/Reference","content":" API/Reference BoxLeastSquares.BLSPeriodogram BoxLeastSquares.BLS BoxLeastSquares.autoperiod BoxLeastSquares.model BoxLeastSquares.model BoxLeastSquares.params BoxLeastSquares.periods BoxLeastSquares.power"},{"id":1641,"pagetitle":"API/Reference","title":"BoxLeastSquares.BLSPeriodogram","ref":"/previews/PR43/BoxLeastSquares/stable/api/#BoxLeastSquares.BLSPeriodogram","content":" BoxLeastSquares.BLSPeriodogram  —  Type BLSPeriodogram A convenient wrapper for outputs from  BLS . Methods BoxLeastSquares.params BoxLeastSquares.power BoxLeastSquares.periods Attributes t  - input time grid y  - input data yerr  - input data uncertainty periods  - the input periods duration_in  - the input durations objective  - the objective that was maximized power  - the power calculated at each period duration  - the best duration at each period t0  - the best transit time at each period depth  - the best transit depth at each period snr  - the signal-to-noise ratio at each period loglike  - the log-likeilhood at each period Plotting Plotting recipes are provided for  BLSPeriodogram  which automatically plots the period and the power source"},{"id":1642,"pagetitle":"API/Reference","title":"BoxLeastSquares.BLS","ref":"/previews/PR43/BoxLeastSquares/stable/api/#BoxLeastSquares.BLS","content":" BoxLeastSquares.BLS  —  Function BLS(t, y, [yerr];\n    duration, periods=autoperiod(t, duration, kwargs...), \n    objective=:likelihood, oversample=10, kwargs...) Compute the box-least-squares periodogram. Parameters t  - the time for each observation. Units are irrelevant, except that they must be consistent for all temporal parameters (e.g.,  duration ).  Unitful.jl  units work seamlessly without needing to convert. y  - the flux value for each observation yerr , optional - the uncertainty for each observation, if not provided, will default to ones duration  - The duration or durations to consider. Same units as  t periods , optional - The period grid to computer the BLS power over. If not provided,  autoperiod  will be called along with any extra keyword arguments (like  minimum_period ) objective , optional - Choose between maximizing the likeilhood ( :likeilhood , default) or the signal-to-noise ratio ( :snr ). oversample , optional - The number of bins per duration that should be used. Larger values of  oversample  will lead to a finer grid. The returned values are wrapped into a convenience type  BoxLeastSquares.BLSPeriodogram source"},{"id":1643,"pagetitle":"API/Reference","title":"BoxLeastSquares.autoperiod","ref":"/previews/PR43/BoxLeastSquares/stable/api/#BoxLeastSquares.autoperiod-Union{Tuple{T}, Tuple{AbstractVector{T}, Any}} where T","content":" BoxLeastSquares.autoperiod  —  Method autoperiod(t, duration;\n    minimum_n_transit=3, frequency_factor=1.0,\n    [minimum_period, maximum_period]) Automatically determine a period grid from the given times and duration(s). Periods are selected such that at least  minimum_n_trasnit  transits occur. The default minimum period is twice the maximum duration. The default maximum period is  (maximum(t) - minimum(t)) / (minimum_n_transit - 1) . The frequency factor changes the granularity in frequency space- a smaller frequency factor will create a finer period grid. source"},{"id":1644,"pagetitle":"API/Reference","title":"BoxLeastSquares.model","ref":"/previews/PR43/BoxLeastSquares/stable/api/#BoxLeastSquares.model","content":" BoxLeastSquares.model  —  Function BoxLeastSquares.model(t, y, [yerr]; period, duration, t0) Evaluate the transit model on the given time grid. If  yerr  is not provided, it will default to 1. The following transit parameters must be set: period  orbital period in the same units as  t duration  the transit duration in the same units as  t t0  the transit time (middle of transit) in the same units as  t If you are using  Unitful.jl , the unit conversions will be made automatically. source"},{"id":1645,"pagetitle":"API/Reference","title":"BoxLeastSquares.model","ref":"/previews/PR43/BoxLeastSquares/stable/api/#BoxLeastSquares.model-Tuple{BoxLeastSquares.BLSPeriodogram}","content":" BoxLeastSquares.model  —  Method BoxLeastSquares.model(::BLSPeriodogram; kwargs...) Create a transit model using the data and best-fitting parameters from the given BLS periodogram. Any keyword parameters can be overriden. source"},{"id":1646,"pagetitle":"API/Reference","title":"BoxLeastSquares.params","ref":"/previews/PR43/BoxLeastSquares/stable/api/#BoxLeastSquares.params-Tuple{BoxLeastSquares.BLSPeriodogram}","content":" BoxLeastSquares.params  —  Method BoxLeastSquares.params(::BLSPeriodogram) Return the transit parameters for the best fitting period. Returns period, duration, t0, and power as well as the index of the max-power period. source"},{"id":1647,"pagetitle":"API/Reference","title":"BoxLeastSquares.periods","ref":"/previews/PR43/BoxLeastSquares/stable/api/#BoxLeastSquares.periods-Tuple{BoxLeastSquares.BLSPeriodogram}","content":" BoxLeastSquares.periods  —  Method BoxLeastSquares.periods(::BLSPeriodogram) Return the period grid for the periodogram source"},{"id":1648,"pagetitle":"API/Reference","title":"BoxLeastSquares.power","ref":"/previews/PR43/BoxLeastSquares/stable/api/#BoxLeastSquares.power-Tuple{BoxLeastSquares.BLSPeriodogram}","content":" BoxLeastSquares.power  —  Method BoxLeastSquares.power(::BLSPeriodogram) Return the power calculated for each period for the periodogram source"},{"id":1653,"pagetitle":"Home","title":"Cosmology.jl","ref":"/previews/PR43/Cosmology/stable/#Cosmology.jl-1","content":" Cosmology.jl Cosmology.jl  provides functions for quick cosmological calculations, written in pure Julia. "},{"id":1654,"pagetitle":"Home","title":"Installation","ref":"/previews/PR43/Cosmology/stable/#Installation-1","content":" Installation To install the package, enter  pkg  mode ( ] ) pkg> add Cosmology Then, to load the package julia> using Cosmology"},{"id":1655,"pagetitle":"Home","title":"Contributing","ref":"/previews/PR43/Cosmology/stable/#Contributing-1","content":" Contributing If you would like to contribute to  Cosmology.jl , head over to our  GitHub page  and open an issue or pull request! For any new features, we ask the contributors to add any relevant unit tests and bump the package version by one minor version."},{"id":1658,"pagetitle":"API/Reference","title":"API/Reference","ref":"/previews/PR43/Cosmology/stable/api/#API/Reference-1","content":" API/Reference Unitful Unitful.jl  works seamlessly with Cosmology.jl. In order to use its features, make sure it is installed and imported, along with  UnitfulAstro . pkg> add Unitful UnitfulAstro\njulia> using Unitful, UnitfulAstro"},{"id":1659,"pagetitle":"API/Reference","title":"Cosmological Models","ref":"/previews/PR43/Cosmology/stable/api/#Cosmological-Models-1","content":" Cosmological Models"},{"id":1660,"pagetitle":"API/Reference","title":"Cosmology.cosmology","ref":"/previews/PR43/Cosmology/stable/api/#Cosmology.cosmology","content":" Cosmology.cosmology  —  Function cosmology(;h = 0.69,\n           Neff = 3.04,\n           OmegaK = 0,\n           OmegaM = 0.29,\n           OmegaR = nothing,\n           Tcmb = 2.7255,\n           w0 = -1,\n           wa = 0) Parameters h  - Dimensionless Hubble constant OmegaK  - Curvature density (Ω_k) OmegaM  - Matter density (Ω_m) OmegaR  - Radiation density (Ω_r) Tcmb  - CMB temperature in Kelvin; used to compute Ω_γ Neff  - Effective number of massless neutrino species; used to compute Ω_ν w0  - CPL dark energy equation of state;  w = w0 + wa(1-a) wa  - CPL dark energy equation of state;  w = w0 + wa(1-a) Examples julia> c = cosmology()\nCosmology.FlatLCDM{Float64}(0.69, 0.7099122024007928, 0.29, 8.77975992071536e-5)\n\njulia> c = cosmology(OmegaK=0.1)\nCosmology.OpenLCDM{Float64}(0.69, 0.1, 0.6099122024007929, 0.29, 8.77975992071536e-5)\n\njulia> c = cosmology(w0=-0.9, OmegaK=-0.1)\nCosmology.ClosedWCDM{Float64}(0.69, -0.1, 0.8099122024007929, 0.29, 8.77975992071536e-5, -0.9, 0.0) source"},{"id":1661,"pagetitle":"API/Reference","title":"Distances","ref":"/previews/PR43/Cosmology/stable/api/#Distances-1","content":" Distances"},{"id":1662,"pagetitle":"API/Reference","title":"Cosmology.angular_diameter_dist","ref":"/previews/PR43/Cosmology/stable/api/#Cosmology.angular_diameter_dist","content":" Cosmology.angular_diameter_dist  —  Function angular_diameter_dist([u::Unitlike,] c::AbstractCosmology, [z₁,] z₂) Ratio of the proper transverse size in Mpc of an object at redshift  z₂  to its angular size in radians, as seen by an observer at  z₁ .  Redshift  z₁  defaults to 0 if omitted.  Will convert to compatible unit  u  if provided. source"},{"id":1663,"pagetitle":"API/Reference","title":"Cosmology.comoving_radial_dist","ref":"/previews/PR43/Cosmology/stable/api/#Cosmology.comoving_radial_dist","content":" Cosmology.comoving_radial_dist  —  Function comoving_radial_dist([u::Unitlike,] c::AbstractCosmology, [z₁,] z₂) Comoving radial distance in Mpc at redshift  z₂  as seen by an observer at  z₁ .  Redshift  z₁  defaults to 0 if omitted.  Will convert to compatible unit  u  if provided. source"},{"id":1664,"pagetitle":"API/Reference","title":"Cosmology.luminosity_dist","ref":"/previews/PR43/Cosmology/stable/api/#Cosmology.luminosity_dist","content":" Cosmology.luminosity_dist  —  Function luminosity_dist([u::Unitlike,] c::AbstractCosmology, z) Bolometric luminosity distance in Mpc at redshift  z . Will convert to compatible unit  u  if provided. source"},{"id":1665,"pagetitle":"API/Reference","title":"Cosmology.distmod","ref":"/previews/PR43/Cosmology/stable/api/#Cosmology.distmod","content":" Cosmology.distmod  —  Function distmod(c::AbstractCosmology, z) Distance modulus in magnitudes at redshift  z . source"},{"id":1666,"pagetitle":"API/Reference","title":"Examples","ref":"/previews/PR43/Cosmology/stable/api/#Examples-1","content":" Examples julia> c = cosmology(OmegaM=0.26)\nCosmology.FlatLCDM{Float64}(0.69, 0.7399122024007928, 0.26, 8.77975992071536e-5)\n\njulia> angular_diameter_dist(c, 1.2)\n1784.0089227105113 Mpc\n\njulia> angular_diameter_dist(c, 0.7, 1.2)\n606.6521737365097 Mpc\n\njulia> luminosity_dist(c, 1.5)\n11420.338287150073 Mpc\n\njulia> luminosity_dist(u\"Gpc\", c, 1.5) # Can convert to appropriate unit\n11.420338287150074 Gpc"},{"id":1667,"pagetitle":"API/Reference","title":"Volumes","ref":"/previews/PR43/Cosmology/stable/api/#Volumes-1","content":" Volumes"},{"id":1668,"pagetitle":"API/Reference","title":"Cosmology.comoving_volume_element","ref":"/previews/PR43/Cosmology/stable/api/#Cosmology.comoving_volume_element","content":" Cosmology.comoving_volume_element  —  Function comoving_volume_element([u::Unitlike,] c::AbstractCosmology, z) Comoving volume element in Gpc out to redshift  z . Will convert to compatible unit  u  if provided. source"},{"id":1669,"pagetitle":"API/Reference","title":"Cosmology.comoving_volume","ref":"/previews/PR43/Cosmology/stable/api/#Cosmology.comoving_volume","content":" Cosmology.comoving_volume  —  Function comoving_volume([u::Unitlike,] c::AbstractCosmology, z) Comoving volume in cubic Gpc out to redshift  z . Will convert to compatible unit  u  if provided. source"},{"id":1670,"pagetitle":"API/Reference","title":"Examples","ref":"/previews/PR43/Cosmology/stable/api/#Examples-2","content":" Examples julia> c = cosmology(OmegaM=0.26)\nCosmology.FlatLCDM{Float64}(0.69, 0.7399122024007928, 0.26, 8.77975992071536e-5)\n\njulia> comoving_volume_element(c, 2.1)\n46.74459228888612 Gpc^3\n\njulia> comoving_volume(c, 0.6)\n49.3633436631307 Gpc^3\n\njulia> comoving_volume(u\"ly^3\", c, 0.6)\n1.7127035381753e30 ly^3"},{"id":1671,"pagetitle":"API/Reference","title":"Times","ref":"/previews/PR43/Cosmology/stable/api/#Times-1","content":" Times"},{"id":1672,"pagetitle":"API/Reference","title":"Cosmology.age","ref":"/previews/PR43/Cosmology/stable/api/#Cosmology.age","content":" Cosmology.age  —  Function age([u::Unitlike,] c::AbstractCosmology, z) Age of the universe in Gyr at redshift  z . Will convert to compatible unit  u  if provided. source"},{"id":1673,"pagetitle":"API/Reference","title":"Cosmology.lookback_time","ref":"/previews/PR43/Cosmology/stable/api/#Cosmology.lookback_time","content":" Cosmology.lookback_time  —  Function lookback_time([u::Unitlike,] c::AbstractCosmology, z) Difference between age at redshift 0 and age at redshift  z  in Gyr. Will convert to compatible unit  u  if provided. source"},{"id":1674,"pagetitle":"API/Reference","title":"Examples","ref":"/previews/PR43/Cosmology/stable/api/#Examples-3","content":" Examples julia> c = cosmology(OmegaM=0.26)\nCosmology.FlatLCDM{Float64}(0.69, 0.7399122024007928, 0.26, 8.77975992071536e-5)\n\njulia> age(c, 1.2)\n5.445600787626434 Gyr\n\njulia> lookback_time(u\"yr\", c, 1.2)\n8.761660748088268e9 yr"},{"id":1679,"pagetitle":"Home","title":"DustExtinction.jl","ref":"/previews/PR43/DustExtinction/stable/#DustExtinction.jl","content":" DustExtinction.jl This package implements different empirical dust measurements for use in astronomy. This package is written in pure Julia and is built with first-class support with  Unitful.jl  and  Measurements.jl ."},{"id":1680,"pagetitle":"Home","title":"About","ref":"/previews/PR43/DustExtinction/stable/#About","content":" About Extinction describes the effect of dust grains on observations of stars in space. Light that travels through dust is absorbed and scatterred as natural processes of light's interactions with materials. This obfuscation can be modeled and removed from our data in order to more properly retrieve the star's flux. When dealing with multiple stars, or large clusters or galaxies, this process is considered dust attenuation and is not provided for in this package."},{"id":1681,"pagetitle":"Home","title":"Installation","ref":"/previews/PR43/DustExtinction/stable/#Installation","content":" Installation From the REPL, press  ]  to enter Pkg mode (v 1.4) pkg> add DustExtinction\n\njulia> using DustExtinction"},{"id":1682,"pagetitle":"Home","title":"Usage","ref":"/previews/PR43/DustExtinction/stable/#Usage","content":" Usage julia> using DustExtinction\n\njulia> CCM89(Rv=3.1)(4000)\n1.464555702942584 For more examples, view the  Color Laws  and  Dust Maps  sections."},{"id":1683,"pagetitle":"Home","title":"Citations","ref":"/previews/PR43/DustExtinction/stable/#Citations","content":" Citations There are various citations relevant to this work. Please be considerate when using this work or any derivate of it by adding the appropriate citations. Law Reference BibTeX CCM89 Clayton, Cardelli and Mathis (1989) download OD94 O'Donnell (1994) download CAL00 Calzetti et al. (2000) download VCG04 Valencic, Clayton, & Gordon (2004) download GCC09 Gordon, Cartledge, & Clayton (2009) download FM90 Fitzpatrick & Massa (1990) download G16 Gordon et al (2016)  download SFD98Map Schlegel, Finkbeiner and Davis (1998) download F99 Fitzpatrick (1999) download F04 Fitzpatrick (2004) download F19 Fitzpatrick (2019) download M14 Maiz Apellaniz et al. (2014) download"},{"id":1684,"pagetitle":"Home","title":"Index","ref":"/previews/PR43/DustExtinction/stable/#Index","content":" Index DustExtinction.bounds DustExtinction.deredden DustExtinction.redden DustExtinction.CAL00 DustExtinction.CCM89 DustExtinction.ExtinctionLaw DustExtinction.F04 DustExtinction.F19 DustExtinction.F99 DustExtinction.FM90 DustExtinction.G16 DustExtinction.GCC09 DustExtinction.M14 DustExtinction.OD94 DustExtinction.SFD98Map DustExtinction.VCG04"},{"id":1685,"pagetitle":"Home","title":"Contributing","ref":"/previews/PR43/DustExtinction/stable/#Contributing","content":" Contributing If you are interested in contributing, feel free to make a pull request or open an issue for discussion."},{"id":1688,"pagetitle":"Color Laws","title":"Color laws","ref":"/previews/PR43/DustExtinction/stable/color_laws/#laws","content":" Color laws The following empirical laws allow us to model the reddening of light as it travels to us. The law you use should depend on the type of data you have and the goal of its use.  CCM89  is very common for use in removing extinction from stellar observations, but  CAL00 , for instance, is suited for galaxies with massive stars. Look through the citations and documentation for each law to get a better idea of what sort of physics it targets."},{"id":1689,"pagetitle":"Color Laws","title":"Usage","ref":"/previews/PR43/DustExtinction/stable/color_laws/#Usage","content":" Usage Color laws are constructed and then used as a function for passing wavelengths. Wavelengths are assumed to be in units of angstroms. julia> CCM89(Rv=3.1)(4000)\n1.464555702942584\n These laws can be applied across higher dimension arrays using the  .  operator julia> CCM89(Rv=3.1).([4000, 5000])\n2-element Array{Float64,1}:\n 1.464555702942584\n 1.1222468788993019\n these laws return magnitudes, which we can apply directly to flux by mulitplication with a base-2.5 logarithmic system (because astronomers are fun): \\[f = f \\cdot 10 ^ {-0.4A_v\\cdot mag}\\] To make this easier, we provide a convenience  redden  and  deredden  functions for applying these color laws to flux measurements. julia> wave = range(4000, 5000, length=4)\n4000.0:333.3333333333333:5000.0\n\njulia> flux = 1e-8 .* wave .+ 1e-2\n0.01004:3.3333333333333333e-6:0.01005\n\njulia> redden.(CCM89, wave, flux; Av=0.3)\n4-element Array{Float64,1}:\n 0.006698646015454752\n 0.006918253926353551\n 0.007154659823737299\n 0.007370491272731541\n\njulia> deredden.(CCM89(Rv=3.1), wave, ans; Av=0.3) ≈ flux\ntrue\n"},{"id":1690,"pagetitle":"Color Laws","title":"Advanced Usage","ref":"/previews/PR43/DustExtinction/stable/color_laws/#Advanced-Usage","content":" Advanced Usage The color laws also have built-in support for uncertainties using  Measurements.jl . julia> using Measurements\n\njulia> CCM89(Rv=3.1).([4000. ± 10.5, 5000. ± 10.2])\n2-element Array{Measurement{Float64},1}:\n 1.4646 ± 0.0033\n 1.1222 ± 0.003\n and also support units via  Unitful.jl  and its subsidiaries. Notice how the output type is now  Unitful.Gain . julia> using Unitful, UnitfulAstro\n\njulia> mags = CCM89(Rv=3.1).([4000u\"angstrom\", 0.5u\"μm\"])\n2-element Array{Gain{Unitful.LogInfo{:Magnitude,10,-2.5},:?,Float64},1}:\n 1.4645557029425837 mag\n 1.1222468788993019 mag\n You can even combine the two above to get some really nice workflows exploiting all Julia has to offer! This example shows how you could redden some OIR observational data with uncertainties in the flux density. julia> using Measurements, Unitful, UnitfulAstro\n\njulia> wave = range(0.3, 1.0, length=5)u\"μm\"\n(0.3:0.175:1.0) μm\n\njulia> err = randn(length(wave))\n5-element Array{Float64,1}:\n  0.2972879845354616\n  0.3823959677906078\n -0.5976344767282311\n -0.01044524463737564\n -0.839026854388764\n\njulia> flux = @.(300 / ustrip(wave)^4 ± err)*u\"Jy\"\n5-element Array{Quantity{Measurement{Float64},𝐌*𝐓⁻²,Unitful.FreeUnits{(Jy,),𝐌*𝐓⁻²,nothing}},1}:\n  37037.04 ± 0.3 Jy\n  5893.14 ± 0.38 Jy\n  1680.61 ± -0.6 Jy\n 647.598 ± -0.01 Jy\n   300.0 ± -0.84 Jy\n\njulia> redden.(CCM89, wave, flux; Av=0.3)\n5-element Array{Quantity{Measurement{Float64},𝐌*𝐓⁻²,Unitful.FreeUnits{(Jy,),𝐌*𝐓⁻²,nothing}},1}:\n    22410.8 ± 0.18 Jy\n    4229.74 ± 0.27 Jy\n    1337.12 ± 0.48 Jy\n 554.3349 ± 0.0089 Jy\n     268.31 ± 0.75 Jy\n"},{"id":1691,"pagetitle":"Color Laws","title":"Parametric Extinction Laws","ref":"/previews/PR43/DustExtinction/stable/color_laws/#Parametric-Extinction-Laws","content":" Parametric Extinction Laws These laws are all parametrized by the selective extinction  Rv . Mathematically, this is the ratio of the total extinction by the reddening \\[R_V = \\frac{A_V}{E(B-V)}\\] and is loosely associated with the size of the dust grains in the interstellar medium. Index: CCM89 OD94 CAL00 VCG04 GCC09 F99 F04 F19"},{"id":1692,"pagetitle":"Color Laws","title":"Clayton, Cardelli and Mathis (1989)","ref":"/previews/PR43/DustExtinction/stable/color_laws/#Clayton,-Cardelli-and-Mathis-(1989)","content":" Clayton, Cardelli and Mathis (1989)"},{"id":1693,"pagetitle":"Color Laws","title":"DustExtinction.CCM89","ref":"/previews/PR43/DustExtinction/stable/color_laws/#DustExtinction.CCM89","content":" DustExtinction.CCM89  —  Type CCM89(;Rv=3.1) Clayton, Cardelli and Mathis (1989) dust law. Returns E(B-V) in magnitudes at the given wavelength relative to the extinction at 5494.5 Å. The default support is [1000, 33333]. Outside of that range this will return 0.  Rv  is the selective extinction and is valid over [2, 6]. A typical value for the Milky Way is 3.1. References Clayton,Cardelli and Mathis (1989) source"},{"id":1694,"pagetitle":"Color Laws","title":"O'Donnell 1994","ref":"/previews/PR43/DustExtinction/stable/color_laws/#O'Donnell-1994","content":" O'Donnell 1994"},{"id":1695,"pagetitle":"Color Laws","title":"DustExtinction.OD94","ref":"/previews/PR43/DustExtinction/stable/color_laws/#DustExtinction.OD94","content":" DustExtinction.OD94  —  Type OD94(;Rv=3.1) O'Donnell (1994) dust law. This is identical to the Clayton, Cardelli and Mathis (1989) dust law, except for different coefficients used in the optical (3030.3 Å to 9090.9 Å). References O'Donnell (1994) See Also CCM89 source"},{"id":1696,"pagetitle":"Color Laws","title":"Calzetti et al. (2000)","ref":"/previews/PR43/DustExtinction/stable/color_laws/#Calzetti-et-al.-(2000)","content":" Calzetti et al. (2000)"},{"id":1697,"pagetitle":"Color Laws","title":"DustExtinction.CAL00","ref":"/previews/PR43/DustExtinction/stable/color_laws/#DustExtinction.CAL00","content":" DustExtinction.CAL00  —  Type CAL00(;Rv=4.05) Calzetti et al. (2000) Dust Law. Returns E(B-V) in magnitudes at the given wavelength.  λ  is the wavelength in Å  and has support over [1200, 22000]. Outside of that range this will return 0. Calzetti et al. (2000) developed a recipe for dereddening the spectra of galaxies where massive stars dominate the radiation output. They found the best  fit value for such galaxies was 4.05±0.80. References Calzetti et al. (2000) source"},{"id":1698,"pagetitle":"Color Laws","title":"Valencic, Clayton, & Gordon (2004)","ref":"/previews/PR43/DustExtinction/stable/color_laws/#Valencic,-Clayton,-and-Gordon-(2004)","content":" Valencic, Clayton, & Gordon (2004)"},{"id":1699,"pagetitle":"Color Laws","title":"DustExtinction.VCG04","ref":"/previews/PR43/DustExtinction/stable/color_laws/#DustExtinction.VCG04","content":" DustExtinction.VCG04  —  Type VCG04(;Rv=3.1) Valencic, Clayton, & Gordon (2004) dust law. This model applies to the UV spectral region all the way to 912 Å. This model was not derived for the optical or NIR. References Valencic, Clayton, & Gordon (2004) source"},{"id":1700,"pagetitle":"Color Laws","title":"Gordon, Cartledge, & Clayton (2009)","ref":"/previews/PR43/DustExtinction/stable/color_laws/#Gordon,-Cartledge,-and-Clayton-(2009)","content":" Gordon, Cartledge, & Clayton (2009)"},{"id":1701,"pagetitle":"Color Laws","title":"DustExtinction.GCC09","ref":"/previews/PR43/DustExtinction/stable/color_laws/#DustExtinction.GCC09","content":" DustExtinction.GCC09  —  Type GCC09(;Rv=3.1) Gordon, Cartledge, & Clayton (2009) dust law. This model applies to the UV spectral region all the way to 909.09 Å. This model was not derived for the optical or NIR. References Gordon, Cartledge, & Clayton (2009) source"},{"id":1702,"pagetitle":"Color Laws","title":"Fitzpatrick (1999)","ref":"/previews/PR43/DustExtinction/stable/color_laws/#Fitzpatrick-(1999)","content":" Fitzpatrick (1999)"},{"id":1703,"pagetitle":"Color Laws","title":"DustExtinction.F99","ref":"/previews/PR43/DustExtinction/stable/color_laws/#DustExtinction.F99","content":" DustExtinction.F99  —  Type F99(;Rv=3.1) Fitzpatrick (1999) dust law. Returns E(B-V) in magnitudes at the given wavelength relative to the extinction. This model applies to the UV and optical to NIR spectral range. The default support is [1000, 33333] Å. Outside of that range this will return Rv is the selective extinction and is valid over [2, 6]. A typical value for the Milky Way is 3.1. References Fitzpatrick (1999) source"},{"id":1704,"pagetitle":"Color Laws","title":"Fitzpatrick (2004)","ref":"/previews/PR43/DustExtinction/stable/color_laws/#Fitzpatrick-(2004)","content":" Fitzpatrick (2004)"},{"id":1705,"pagetitle":"Color Laws","title":"DustExtinction.F04","ref":"/previews/PR43/DustExtinction/stable/color_laws/#DustExtinction.F04","content":" DustExtinction.F04  —  Type F04(;Rv=3.1) Fitzpatrick (2004) dust law. Returns E(B-V) in magnitudes at the given wavelength relative to the extinction. This model applies to the UV and optical to NIR spectral range. The default support is [1000, 33333] Å. Outside of that range this will return Rv is the selective extinction and is valid over [2, 6]. A typical value for the Milky Way is 3.1. Equivalent to the F99 model with an updated NIR Rv dependence See also Fitzpatrick & Massa (2007, ApJ, 663, 320) References Fitzpatrick (2004) source"},{"id":1706,"pagetitle":"Color Laws","title":"Fitzpatrick (2019)","ref":"/previews/PR43/DustExtinction/stable/color_laws/#Fitzpatrick-(2019)","content":" Fitzpatrick (2019)"},{"id":1707,"pagetitle":"Color Laws","title":"DustExtinction.F19","ref":"/previews/PR43/DustExtinction/stable/color_laws/#DustExtinction.F19","content":" DustExtinction.F19  —  Type F19(;Rv=3.1) Fitzpatrick (2019) dust law. Returns E(B-V) in magnitudes at the given wavelength relative to the extinction. This model applies to the UV and optical to NIR spectral range. The default support is [1149, 33333] Å. Outside of that range this will return Rv is the selective extinction and is valid over [2, 6]. A typical value for the Milky Way is 3.1. Fitzpatrick, Massa, Gordon et al. (2019, ApJ, 886, 108) model. Based on a sample of stars observed spectroscopically in the optical with HST/STIS. References Fitzpatrick (2019) source"},{"id":1708,"pagetitle":"Color Laws","title":"Maiz Apellaniz et al. (2014)","ref":"/previews/PR43/DustExtinction/stable/color_laws/#Maiz-Apellaniz-et-al.-(2014)","content":" Maiz Apellaniz et al. (2014)"},{"id":1709,"pagetitle":"Color Laws","title":"DustExtinction.M14","ref":"/previews/PR43/DustExtinction/stable/color_laws/#DustExtinction.M14","content":" DustExtinction.M14  —  Type M14(;Rv=3.1) Maiz Apellaniz et al (2014) Milky Way & LMC R(V) dependent model. Returns E(B-V) in magnitudes at the given wavelength relative to the extinction. The published UV extinction curve is identical to Clayton, Cardelli, and Mathis (1989, CCM). Forcing the optical section to match smoothly with CCM introduces a non-physical feature at high values of R5495 around 3.9 inverse microns; see section 5 in Maiz Apellaniz et al. (2014) for more discussion. For that reason, we provide the M14 model only through 3.3 inverse microns, the limit of the optical in CCM. Outside of that range this will return 0. Rv is the selective extinction and is valid over [2, 6]. A typical value for the Milky Way is 3.1. R5495 = A(5485)/E(4405-5495) Spectral equivalent to photometric R(V). References Maiz Apellaniz et al. (2014) source"},{"id":1710,"pagetitle":"Color Laws","title":"API/Reference","ref":"/previews/PR43/DustExtinction/stable/color_laws/#API/Reference","content":" API/Reference"},{"id":1711,"pagetitle":"Color Laws","title":"DustExtinction.redden","ref":"/previews/PR43/DustExtinction/stable/color_laws/#DustExtinction.redden","content":" DustExtinction.redden  —  Function redden(::ExtinctionLaw, wave, flux; Av=1)\nredden(::Type{ExtinctionLaw}, wave, flux; Av=1, law_kwargs...) Redden the given  flux  using the given extinction law at the given wavelength. If  wave  is  <:Real  then it is expected to be in angstrom and if it is  <:Unitful.Quantity  it will be automatically converted.  Av  is the total extinction value. The extinction law can be a constructed struct or a  Type . If it is a  Type ,  law_kwargs  will be passed to the constructor. Examples julia> wave = 3000; flux = 1000;\n\njulia> redden(CCM89, wave, flux; Rv=3.1)\n187.38607779757183\n\njulia> redden(CCM89(Rv=3.1), wave, flux; Av=2)\n35.11354215235764 See Also deredden source"},{"id":1712,"pagetitle":"Color Laws","title":"DustExtinction.deredden","ref":"/previews/PR43/DustExtinction/stable/color_laws/#DustExtinction.deredden","content":" DustExtinction.deredden  —  Function deredden(::ExtinctionLaw, wave, flux; Av=1)\nderedden(::Type{ExtinctionLaw}, wave, flux; Av=1, law_kwargs...) Deredden the given  flux  using the given extinction law at the given wavelength. If  wave  is  <:Real  then it is expected to be in angstrom and if it is  <:Unitful.Quantity  it will be automatically converted.  Av  is the total extinction value. The extinction law can be a constructed struct or a  Type . If it is a  Type ,  law_kwargs  will be passed to the constructor. Examples julia> wave = 3000; flux = 187.386;\n\njulia> deredden(CCM89, wave, flux; Rv=3.1)\n999.9995848273642\n\njulia> deredden(CCM89(Rv=3.1), wave, flux; Av=2)\n5336.573541539394 See Also redden source"},{"id":1713,"pagetitle":"Color Laws","title":"DustExtinction.ExtinctionLaw","ref":"/previews/PR43/DustExtinction/stable/color_laws/#DustExtinction.ExtinctionLaw","content":" DustExtinction.ExtinctionLaw  —  Type DustExtinction.ExtinctionLaw The abstract super-type for dust extinction laws. See the extended help ( ??DustExtinction.ExtinctionLaw  from the REPL) for more information about the interface. Extended Help Interface Here's how to make a new extinction law, called  MyLaw Create your struct. We strongly recommend using  Parameters.jl  to facilitate creating keyword argument constructors if your model is parameterized, which allows convenient usage with  redden  and  deredden .  struct MyLaw <: DustExtinction.ExtinctionLaw end (Optional) Define the limits. This will default to  (0, Inf) . Currently, this is used within the  DustExtinction.checkbounds  function and in the future will be used for plotting recipes. DustExtinction.bounds(::Type{<:MyLaw}) = (min, max) Define the law. You only need to provide one function which takes wavelength as angstrom. If your law is naturally written for inverse-micron, there is a helper function  aa_to_invum . (::MyLaw)(wavelength::Real) (Optional) enable  Unitful.jl  support by adding this function. If you are building a new law within  DustExtinction.jl  you can add your law to the code-gen list inside  DustExtinction.jl/src/DustExtinction.jl . (l::MyLaw)(wavelength::Unitful.Quantity) = l(ustrip(u\"angstrom\", wavelength)) * u\"mag\" source"},{"id":1714,"pagetitle":"Color Laws","title":"DustExtinction.bounds","ref":"/previews/PR43/DustExtinction/stable/color_laws/#DustExtinction.bounds","content":" DustExtinction.bounds  —  Function DustExtinction.bounds(::ExtinctionLaw)::Tuple\nDustExtinction.bounds(::Type{<:ExtinctionLaw})::Tuple Get the natural wavelengths bounds for the extinction law, in angstrom source"},{"id":1715,"pagetitle":"Color Laws","title":"Fittable Extinction Laws","ref":"/previews/PR43/DustExtinction/stable/color_laws/#Fittable-Extinction-Laws","content":" Fittable Extinction Laws"},{"id":1716,"pagetitle":"Color Laws","title":"Fitzpatrick & Massa (1990)","ref":"/previews/PR43/DustExtinction/stable/color_laws/#Fitzpatrick-and-Massa-(1990)","content":" Fitzpatrick & Massa (1990)"},{"id":1717,"pagetitle":"Color Laws","title":"DustExtinction.FM90","ref":"/previews/PR43/DustExtinction/stable/color_laws/#DustExtinction.FM90","content":" DustExtinction.FM90  —  Type FM90(;c1=0.10, c2=0.70, c3=3.23, c4=0.41, x0=4.60, gamma=0.9)\nFM90(coeffs, x0=4.60, gamma=0.9) Fitzpatrick & Massa (1990) generative model for ultraviolet dust extinction. The default values are the published values for the Milky Way average. Parameters c1  - y-intercept of linear term c2  - slope of liner term c3  - amplitude of 2175 Å bump c4  - amplitude of FUV rise x0  - centroid of 2175 Å bump gamma  - width of 2175 Å bump If  λ  is a  Unitful.Quantity  it will be automatically converted to Å and the returned value will be  UnitfulAstro.mag . Examples julia> model = FM90(c1=0.2, c2=0.7, c3=3.23, c4=0.41, x0=4.6, gamma=0.99);\n\njulia> model(1500)\n5.2521258452800135\n\njulia> FM90()(1500)\n5.152125845280013\n\njulia> FM90(c1=0.2, c2=0.7, c3=3.23, c4=0.41, x0=4.6, gamma=0.99).([1000, 1200, 1800])\n3-element Array{Float64,1}:\n 12.562237969522851\n  7.769215017329513\n  4.890128210972148\n Extended Help The model has form  $c_1 + c_2x + c_3D(x; \\gamma, x_0) + c_4 F(x)$  where  $x$  is the wavenumber in inverse microns,  $D(x)$  is a Drude profile (modified Lorentzian) used to model the 2175 Å bump with the scale-free parameters  $x_0$  (central wavenumber) and  $\\gamma$  (damping coefficient), and  $F(x)$ , a piecewise function for the far-UV. Note that the coefficients will change the overall normalization, possibly changing the expected behavior of reddening via the parameter  $A_V$ . References Fitzpatrick & Massa (1990) source"},{"id":1718,"pagetitle":"Color Laws","title":"Mixture Extinction Laws","ref":"/previews/PR43/DustExtinction/stable/color_laws/#Mixture-Extinction-Laws","content":" Mixture Extinction Laws"},{"id":1719,"pagetitle":"Color Laws","title":"Gordon et al. (2016)","ref":"/previews/PR43/DustExtinction/stable/color_laws/#Gordon-et-al.-(2016)","content":" Gordon et al. (2016)"},{"id":1720,"pagetitle":"Color Laws","title":"DustExtinction.G16","ref":"/previews/PR43/DustExtinction/stable/color_laws/#DustExtinction.G16","content":" DustExtinction.G16  —  Type G16(;Rv=3.1, f_A=1.0) Gordon et al. (2016) Milky Way, LMC, & SMC R(V) and f_A dependent model Returns E(B-V) in magnitudes at the given wavelength relative to the extinction. This is mixture model between the F99 R(V) dependent model (component A) and the  G03_SMCBar  model (component B) The default support is [1000, 33333] Å. Outside of that range this will return 0. Rv is the selective extinction and is valid over [2, 6]. A typical value for the Milky Way is 3.1. References Gordon et al. (2016) source"},{"id":1723,"pagetitle":"Dust Maps","title":"Dust Maps","ref":"/previews/PR43/DustExtinction/stable/dust_maps/#maps","content":" Dust Maps"},{"id":1724,"pagetitle":"Dust Maps","title":"Usage","ref":"/previews/PR43/DustExtinction/stable/dust_maps/#Usage","content":" Usage julia> dustmap = SFD98Map();\n\njulia> dustmap(0, 2)\n0.020303287464050277\n\njulia> l = range(-π, π, length=5)\n-3.141592653589793:1.5707963267948966:3.141592653589793\n\njulia> b = range(-π/2, π/2, length=5)\n-1.5707963267948966:0.7853981633974483:1.5707963267948966\n\njulia> [dustmap(l[i], b[j]) for i in 1:length(l), j in 1:length(b)]\n5×5 Array{Float64,2}:\n 0.0159853  0.105782    1.40486  0.0158918  0.0119615\n 0.0159853  0.0268289   3.47788  0.0654852  0.0119615\n 0.0159853  0.0343457  99.6976   0.103875   0.0119615\n 0.0159853  0.0432165   2.60569  0.0178195  0.0119615\n 0.0159853  0.105782    1.40486  0.0158918  0.0119615\n"},{"id":1725,"pagetitle":"Dust Maps","title":"Advanced Usage","ref":"/previews/PR43/DustExtinction/stable/dust_maps/#Advanced-Usage","content":" Advanced Usage Our dust maps also have native support for  Unitful.jl  and  Measurements.jl . julia> using Measurements, Unitful\n\njulia> l = 45u\"°\"; b=0u\"°\";\n\njulia> dustmap = SFD98Map();\n\njulia> dustmap(l, b)\n6.4290331211742355 mag\n\njulia> l = l ± 0.1u\"°\"; b = b ± 0.3u\"°\";\n\njulia> dustmap(l, b)\n6.4 ± 5.7 mag\n"},{"id":1726,"pagetitle":"Dust Maps","title":"API/Reference","ref":"/previews/PR43/DustExtinction/stable/dust_maps/#API/Reference","content":" API/Reference"},{"id":1727,"pagetitle":"Dust Maps","title":"Schlegel, Finkbeiner and Davis (1998)","ref":"/previews/PR43/DustExtinction/stable/dust_maps/#Schlegel,-Finkbeiner-and-Davis-(1998)","content":" Schlegel, Finkbeiner and Davis (1998)"},{"id":1728,"pagetitle":"Dust Maps","title":"DustExtinction.SFD98Map","ref":"/previews/PR43/DustExtinction/stable/dust_maps/#DustExtinction.SFD98Map","content":" DustExtinction.SFD98Map  —  Type SFD98Map([mapdir]) Schlegel, Finkbeiner and Davis (1998) dust map.  The first time this is constructed, the data files required will be downloaded  and stored in a directory following the semantics of   DataDeps.jl . To avoid being asked to  download the files, set the environment variable  DATADEPS_ALWAYS_ACCEPT  to    true . You can also provide the directory of the two requisite files manually   instead of relying on DataDeps.jl. Internally, this type keeps the FITS files   defining the map open, speeding up repeated queries for E(B-V) values. References Schlegel, Finkbeiner and Davis (1998) source (dustmap::SFD98Map)(l::Real, b::Real)\n(dustmap::SFD98Map)(l::Quantity, b::Quantity) Get E(B-V) value from a  SFD98Map  instance at galactic coordinates ( l ,  b ),  given in radians. Uses bilinear interpolation between pixel values. If  l  and   b  are  Unitful.Quantity  they will be converted to radians and the output  will be given as  UnitfulAstro.mag .  Example julia> using DustExtinction\n\njulia> m = SFD98Map();\n\njulia> m(1, 2)\n0.013439524544325624\n\njulia> l = 0:0.5:2; b = 0:0.5:2;\n\njulia> m.(l, b)\n5-element Array{Float64,1}:\n 99.69757461547852    \n  0.10180447359074371 \n  0.019595484241066132\n  0.010238757633890877\n  0.01862100327420125  source"},{"id":1733,"pagetitle":"LombScargle.jl","title":"LombScargle.jl","ref":"/previews/PR43/LombScargle/stable/#LombScargle.jl","content":" LombScargle.jl"},{"id":1734,"pagetitle":"LombScargle.jl","title":"Introduction","ref":"/previews/PR43/LombScargle/stable/#Introduction","content":" Introduction LombScargle.jl  is a package for a fast multi-threaded estimation of the  frequency spectrum  of a periodic signal with  the Lomb–Scargle periodogram .  This is written in  Julia , a modern high-level, high-performance dynamic programming language designed for technical computing. Another Julia package that provides tools to perform spectral analysis of signals is  DSP.jl , but its methods require that the signal has been sampled at equally spaced times. Instead, the Lomb–Scargle periodogram enables you to analyze unevenly sampled data as well, which is a fairly common case in astronomy, a field where this periodogram is widely used. The algorithms used in this package are reported in the following papers: [PR89] Press, W. H., Rybicki, G. B. 1989, ApJ, 338, 277 (URL:  http://dx.doi.org/10.1086/167197 , Bibcode:  http://adsabs.harvard.edu/abs/1989ApJ...338..277P ) [TOW10] Townsend, R. H. D. 2010, ApJS, 191, 247 (URL:  http://dx.doi.org/10.1088/0067-0049/191/2/247 , Bibcode:  http://adsabs.harvard.edu/abs/2010ApJS..191..247T ) [ZK09] Zechmeister, M., Kürster, M. 2009, A&A, 496, 577 (URL:  http://dx.doi.org/10.1051/0004-6361:200811296 , Bibcode:  http://adsabs.harvard.edu/abs/2009A%26A...496..577Z ) Other relevant papers are: [CMB99] Cumming, A., Marcy, G. W., & Butler, R. P. 1999, ApJ, 526, 890 (URL:  http://dx.doi.org/10.1086/308020 , Bibcode:  http://adsabs.harvard.edu/abs/1999ApJ...526..890C ) [CUM04] Cumming, A. 2004, MNRAS, 354, 1165 (URL:  http://dx.doi.org/10.1111/j.1365-2966.2004.08275.x , Bibcode:  http://adsabs.harvard.edu/abs/2004MNRAS.354.1165C ) [HB86] Horne, J. H., & Baliunas, S. L. 1986, ApJ, 302, 757 (URL:  http://dx.doi.org/10.1086/164037 , Bibcode:  http://adsabs.harvard.edu/abs/1986ApJ...302..757H ) [LOM76] Lomb, N. R. 1976, Ap&SS, 39, 447 (URL:  http://dx.doi.org/10.1007/BF00648343 , Bibcode:  http://adsabs.harvard.edu/abs/1976Ap%26SS..39..447L ) [MHC93] Murdoch, K. A., Hearnshaw, J. B., & Clark, M. 1993, ApJ, 413, 349 (URL:  http://dx.doi.org/10.1086/173003 , Bibcode:  http://adsabs.harvard.edu/abs/1993ApJ...413..349M ) [SCA82] Scargle, J. D. 1982, ApJ, 263, 835 (URL:  http://dx.doi.org/10.1086/160554 , Bibcode:  http://adsabs.harvard.edu/abs/1982ApJ...263..835S ) [SS10] Sturrock, P. A., & Scargle, J. D. 2010, ApJ, 718, 527 (URL:  http://dx.doi.org/10.1088/0004-637X/718/1/527 , Bibcode:  http://adsabs.harvard.edu/abs/2010ApJ...718..527S ) The package provides facilities to: compute the periodogram using different methods (with different speeds) and different normalizations. This is one of the fastest implementations of these methods available as free software. If Julia is run with more than one  thread , computation is automatically multi-threaded, further speeding up calculations; access the frequency and period grid of the resulting periodogram, together with the power spectrum; find the maximum power in the periodogram and the frequency and period corresponding to the peak. All these queries can be restricted to a specified region, in order to search a local maximum, instead of the global one; calculate the probability that a peak arises from noise only (false-alarm probability) using analytic formulas, in order to assess the significance of the peak; perform bootstrap resamplings in order to compute the false-alarm probability with a statistical method; determine the best-fitting Lomb–Scargle model for the given data set at the given frequency."},{"id":1735,"pagetitle":"LombScargle.jl","title":"Installation","ref":"/previews/PR43/LombScargle/stable/#Installation","content":" Installation LombScargle.jl  is available for Julia 0.7 and later versions, and can be installed with  Julia's built-in package manager . In a Julia session run the commands julia> using Pkg\njulia> Pkg.update()\njulia> Pkg.add(\"LombScargle\") Older versions are also available for Julia 0.4-0.6."},{"id":1736,"pagetitle":"LombScargle.jl","title":"Usage","ref":"/previews/PR43/LombScargle/stable/#Usage","content":" Usage After installing the package, you can start using it with using LombScargle The module defines a new  LombScargle.Periodogram  data type, which, however, is not exported because you will most probably not need to directly manipulate such objects. This data type holds both the frequency and the power vectors of the periodogram. The main function provided by the package is  lombscargle :"},{"id":1737,"pagetitle":"LombScargle.jl","title":"LombScargle.lombscargle","ref":"/previews/PR43/LombScargle/stable/#LombScargle.lombscargle-Tuple{AbstractVector{var\"#s1\"} where var\"#s1\"<:Real, Vararg{Any, N} where N}","content":" LombScargle.lombscargle  —  Method lombscargle(times::AbstractVector{<:Real}, signal::AbstractVector{<:Real},\n            [errors::AbstractVector{<:Real}]; keywords...) Compute the Lomb–Scargle periodogram of the  signal  vector, observed at  times .  You can also specify the uncertainties for each signal point with  errors  argument.  All these vectors must have the same length. All optional keywords are described in the docstring of  LombScargle.plan . If the signal has uncertainties, the  signal  vector can also be a vector of  Measurement  objects (from  Measurements.jl  package), in which case you don’t need to pass a separate  errors  vector for the uncertainties of the signal. source lombscargle  returns a  LombScargle.Periodogram . The only two mandatory arguments are: times : the vector of observation times signal : the vector of observations associated with  times The optional argument is: errors : the uncertainties associated to each  signal  point. All these vectors must have the same length. Tip You can pre-plan a periodogram with  LombScargle.plan  function, which has the same syntax as  lombscargle  described in this section. In this way the actual computation of the periodogram is faster and you will save memory. See the  Planning the Periodogram  section below. Tip LombScargle.jl  exploits Julia's native  multi-threading  for the non-fast methods (the methods used when you set the keyword  fast=false ). Run Julia with  $n$  threads (e.g.,  JULIA_NUM_THREADS=4 julia  for 4 threads, if your machine has 4 physical cores) in order to automatically gain an  $n$  -fold scaling. Please note that multi-threading is still an experimental feature in Julia, so you may encounter issues when running it with more than one thread. For example, bug  #17395  (if still open) may prevent the function, on some systems, from effectively scaling. If the signal has uncertainties, the  signal  vector can also be a vector of  Measurement  objects (from  Measurements.jl  package), in which case you need not to pass a separate  errors  vector for the uncertainties of the signal. You can create arrays of  Measurement  objects with the  measurement  function, see  Measurements.jl  manual at  https://juliaphysics.github.io/Measurements.jl/stable  for more details. The generalised Lomb–Scargle periodogram by [ZK09] is always used when the signal has uncertainties, because the original Lomb–Scargle algorithm cannot handle them. Tip The uncertainties are only used in the generalised Lomb–Scargle algorithm to build an  inverse-variance  weights vector (see [ZK09]), that gives more importance to datapoints with lower uncertainties. The case where all measurements have the same uncertainty (a condition known as  homoskedasticity ) results in a constant weights vector, like if there are no uncertainties at all. If you have homoskedastic errors, you do not need to provide them to  lombscargle ."},{"id":1738,"pagetitle":"LombScargle.jl","title":"Planning the Periodogram","ref":"/previews/PR43/LombScargle/stable/#Planning-the-Periodogram","content":" Planning the Periodogram In a manner similar to planning Fourier transforms with FFTW, it is possible to speed-up computation of the Lomb–Scargle periodogram by pre-planning it with  LombScargle.plan  function. It has the same syntax as  lombscargle , which in the base case is:"},{"id":1739,"pagetitle":"LombScargle.jl","title":"LombScargle.plan","ref":"/previews/PR43/LombScargle/stable/#LombScargle.plan","content":" LombScargle.plan  —  Function LombScargle.plan(times::AbstractVector{<:Real}, signal::AbstractVector{<:Real},\n                 [errors::AbstractVector{<:Real}];\n                 normalization::Symbol=:standard,\n                 noise_level::Real=1,\n                 center_data::Bool=true,\n                 fit_mean::Bool=true,\n                 fast::Bool=true,\n                 flags::Integer=FFTW.ESTIMATE,\n                 timelimit::Real=Inf,\n                 oversampling::Integer=5,\n                 padding_factors::Vector{Int}=[2],\n                 Mfft::Integer=4,\n                 samples_per_peak::Integer=5,\n                 nyquist_factor::Integer=5,\n                 minimum_frequency::Real=NaN,\n                 maximum_frequency::Real=NaN,\n                 frequencies::AbstractVector{Real}=\n                 autofrequency(times,\n                               samples_per_peak=samples_per_peak,\n                               nyquist_factor=nyquist_factor,\n                               minimum_frequency=minimum_frequency,\n                               maximum_frequency=maximum_frequency)) Pre-plan the Lomb–Scargle periodogram of the  signal  vector, observed at  times .  The periodogram can then be computed by passing the result of this function to  lombscargle . You can also specify the uncertainties for each signal point with  errors  argument.  All these vectors must have the same length. Optional keywords arguments are: normalization : how to normalize the periodogram.  Valid choices are:  :standard ,  :model ,  :log ,  :psd ,  :Scargle ,  :HorneBaliunas ,  :Cumming noise_level : the noise level used to normalize the periodogram when  normalization  is set to  :Scargle fit_mean : if  true , fit for the mean of the signal using the Generalised Lomb–Scargle algorithm (see Zechmeister & Kürster paper below).  If this is  false  and no uncertainty on the signal is provided, the original algorithm by Lomb and Scargle will be employed (see Townsend paper below) center_data : if  true , subtract the weighted mean of  signal  from  signal  itself before performing the periodogram.  This is especially important if  fit_mean  is  false frequencies : the frequecy grid (not angular frequencies) at which the periodogram will be computed, as a vector.  If not provided, it is an evenly spaced grid of type  Range , automatically determined with  LombScargle.autofrequency  function, which see.  See below for other available keywords that can be used to affect the frequency grid without directly setting  frequencies You can explicitely require to use or not the fast method by Press & Rybicki, overriding the default choice, by setting the  fast  keyword.  In any case,  frequencies  must be a  Range  object (this is the default) in order to actually use this method.  A few other keywords are available to adjust the settings of the periodogram when the fast method is used (otherwise they are ignored): fast : whether to use the fast method. flags : this integer keyword is a bitwise-or of FFTW planner flags, defaulting to  FFTW.ESTIMATE .  Passing  FFTW.MEASURE  or  FFTW.PATIENT  will instead spend several seconds (or more) benchmarking different possible FFT algorithms and picking the fastest one; see the FFTW manual for more information on planner flags. timelimit : specifies a rough upper bound on the allowed planning time, in seconds. oversampling : oversampling the frequency factor for the approximation; roughly the number of time samples across the highest-frequency sinusoid. This parameter contains the tradeoff between accuracy and speed. padding_factors : the FFT is performed on a vector with length equal to the smallest number larger than or equal to  N * oversampling  which is a product of all numbers in this vector.  E.g., use  padding_factors=[2]  to perform the FFT on a vector padded to a power of 2, or  padding_factors=[2, 3, 5, 7]  for the optimal size for the FFTW library. Mfft : the number of adjacent points to use in the FFT approximation. In addition, you can use all optional keyword arguments of  LombScargle.autofrequency  function in order to tune the  frequencies . If the signal has uncertainties, the  signal  vector can also be a vector of  Measurement  objects (from  Measurements.jl  package), in which case you don’t need to pass a separate  errors  vector for the uncertainties of the signal. source"},{"id":1740,"pagetitle":"LombScargle.jl","title":"LombScargle.autofrequency","ref":"/previews/PR43/LombScargle/stable/#LombScargle.autofrequency","content":" LombScargle.autofrequency  —  Function autofrequency(times::AbstractVector{Real};\n              samples_per_peak::Integer=5,\n              nyquist_factor::Integer=5,\n              minimum_frequency::Real=NaN,\n              maximum_frequency::Real=NaN) Determine a suitable frequency grid for the given vector of  times . Optional keyword arguments are: samples_per_peak : the approximate number of desired samples across the typical peak nyquist_factor : the multiple of the average Nyquist frequency used to choose the maximum frequency if  maximum_frequency  is not provided minimum_frequency : if specified, then use this minimum frequency rather than one chosen based on the size of the baseline maximum_frequency : if specified, then use this maximum frequency rather than one chosen based on the average Nyquist frequency This is based on prescription given at  https://jakevdp.github.io/blog/2015/06/13/lomb-scargle-in-python/  and uses the same keywords names adopted in Astropy. source LombScargle.plan  takes all the same argument as  lombscargle  shown above and returns a  LombScargle.PeriodogramPlan  object after having pre-computed certain quantities needed afterwards, and pre-allocated the memory for the periodogram. It is highly suggested to plan a periodogram before actually computing it, especially for the fast method. Once you plan a periodogram, you can pass the  LombScargle.PeriodogramPlan  to  lombscargle  as the only argument."},{"id":1741,"pagetitle":"LombScargle.jl","title":"LombScargle.lombscargle","ref":"/previews/PR43/LombScargle/stable/#LombScargle.lombscargle-Tuple{LombScargle.PeriodogramPlan}","content":" LombScargle.lombscargle  —  Method lombscargle(plan::PeriodogramPlan) Compute the Lomb–Scargle periodogram for the given  plan .  This method has no other arguments.  See documentation of  LombScargle.plan  for how to plan a Lomb–Scargle periodogram. source Planning the periodogram has a twofold advantage. First of all, the planning stage is  type-unstable , because the type of the plan depends on the value of input parameters, and not on their types. Thus, separating the planning (inherently inefficient) from the actual computation of the periodogram (completely type-stable) makes overall computation faster than directly calling  lombscargle . Secondly, the  LombScargle.PeriodogramPlan  bears the time vector, but the quantities that are pre-computed in planning stage do not actually depend on it. This is particularly useful if you want to calculate the  False-Alarm Probability  via bootstrapping with  LombScargle.bootstrap : the vector time is randomly shuffled, but pre-computed quantities will remain the same, saving both time and memory in each iteration. In addition, you ensure that you will use the same options you used to compute the periodogram."},{"id":1742,"pagetitle":"LombScargle.jl","title":"Fast Algorithm","ref":"/previews/PR43/LombScargle/stable/#Fast-Algorithm","content":" Fast Algorithm When the frequency grid is evenly spaced, you can compute an approximate generalised Lomb–Scargle periodogram using a fast algorithm proposed by [PR89] that greatly speeds up calculations, as it scales as  $O[N \\log(M)]$  for  $N$  data points and  $M$  frequencies. For comparison, the true Lomb–Scargle periodogram has complexity  $O[NM]$ .  The larger the number of datapoints, the more accurate the approximation. Note This method internally performs a  Fast Fourier Transform  (FFT) to compute some quantities, but it is in no way equivalent to conventional Fourier periodogram analysis. LombScargle.jl  uses  FFTW  functions to compute the FFT. You can speed-up this task by using multi-threading: call  FFTW.set_num_threads(n)  to use  $n$  threads. However, please note that the running time will not scale as  $n$  because computation of the FFT is only a part of the algorithm. The only prerequisite in order to be able to employ this fast method is to provide a  frequencies  vector as an  AbstractRange  object, which ensures that the frequency grid is perfectly evenly spaced. This is the default, since  LombScargle.autofrequency  returns an  AbstractRange  object. Tip In Julia, an  AbstractRange  object can be constructed for example with the  range  function (you specify the start of the range, and optionally the stop, the length and the step of the vector) or with the syntax  start:[step:]stop  (you specify the start and the end of the range, and optionally the linear step). Since this fast method is accurate only for large datasets, it is enabled by default only if the number of output frequencies is larger than 200. You can override the default choice of using this method by setting the  fast  keyword to  true  or  false . We recall that in any case, the  frequencies  vector must be a  Range  in order to use this method. To summarize, provided that  frequencies  vector is an  AbstractRange  object, you can use the fast method: by default if the length of the output frequency grid is larger than 200 points in any case with the  fast=true  keyword Setting  fast=false  always ensures you that this method will not be used, instead  fast=true  actually enables it only if  frequencies  is an  AbstractRange ."},{"id":1743,"pagetitle":"LombScargle.jl","title":"Normalization","ref":"/previews/PR43/LombScargle/stable/#Normalization","content":" Normalization By default, the periodogram  $p(f)$  is normalized so that it has values in the range  $0 \\leq p(f) \\leq 1$ , with  $p = 0$  indicating no improvement of the fit and  $p = 1$  a \"perfect\" fit (100% reduction of  $\\chi^2$  or  $\\chi^2 = 0$ ). This is the normalization suggested by [LOM76] and [ZK09], and corresponds to the  :standard  normalization in  lombscargle  function. [ZK09] wrote the formula for the power of the periodogram at frequency  $f$  as \\[p(f) = \\frac{1}{YY}\\left[\\frac{YC^2_{\\tau}}{CC_{\\tau}} +\n\\frac{YS^2_{\\tau}}{SS_{\\tau}}\\right]\\] See the paper for details. The other normalizations for periodograms  $P(f)$  are calculated from this one. In what follows,  $N$  is the number of observations. :model : \\[P(f) = \\frac{p(f)}{1 - p(f)}\\] :log : \\[P(f) = -\\log(1 - p(f))\\] :psd : \\[P(f) = \\frac{W}{2}\\left[\\frac{YC^2_{\\tau}}{CC_{\\tau}} +\n\\frac{YS^2_{\\tau}}{SS_{\\tau}}\\right] = p(f) \\frac{W*YY}{2}\\] where W is the sum of the inverse of the individual errors,  $W = \\sum \\frac{1}{\\sigma_{i}}$ , as given in [ZK09]. :Scargle : \\[P(f) = \\frac{p(f)}{\\text{noise level}}\\] This normalization can be used when you know the noise level (expected from the a priori known noise variance or population variance), but this isn't usually the case. See [SCA82] :HorneBaliunas : \\[P(f) = \\frac{N - 1}{2} p(f)\\] This is like the  :Scargle  normalization, where the noise has been estimated for Gaussian noise to be  $(N - 1)/2$ . See [HB86] If the data contains a signal or if errors are under- or overestimated or if intrinsic variability is present, then  $(N-1)/2$  may not be a good uncorrelated estimator for the noise level.  [CMB99] suggested to estimate the noise level a posteriori with the residuals of the best fit and normalised the periodogram as: \\[P(f) = \\frac{N - 3}{2} \\frac{p(f)}{1 - p(f_{\\text{best}})}\\] This is the  :Cumming  normalization option"},{"id":1744,"pagetitle":"LombScargle.jl","title":"Access Frequency Grid and Power Spectrum of the Periodogram","ref":"/previews/PR43/LombScargle/stable/#Access-Frequency-Grid-and-Power-Spectrum-of-the-Periodogram","content":" Access Frequency Grid and Power Spectrum of the Periodogram lombscargle  returns a  LombScargle.Periodogram  object, but you most probably want to use the frequency grid and the power spectrum. You can access these vectors with  freq  and  power  functions, just like in  DSP.jl  package. If you want to get the 2-tuple  (freq(p), power(p))  use the  freqpower  function."},{"id":1745,"pagetitle":"LombScargle.jl","title":"LombScargle.power","ref":"/previews/PR43/LombScargle/stable/#LombScargle.power","content":" LombScargle.power  —  Function power(p::Periodogram) Return the power vector of Lomb–Scargle periodogram  p . source"},{"id":1746,"pagetitle":"LombScargle.jl","title":"LombScargle.freq","ref":"/previews/PR43/LombScargle/stable/#LombScargle.freq","content":" LombScargle.freq  —  Function freq(p::Periodogram) Return the frequency vector of Lomb–Scargle periodogram  p . source"},{"id":1747,"pagetitle":"LombScargle.jl","title":"LombScargle.freqpower","ref":"/previews/PR43/LombScargle/stable/#LombScargle.freqpower","content":" LombScargle.freqpower  —  Function freqpower(p::Periodogram) Return the 2-tuple  (freq(p), power(p)) , where  freq(p)  and  power(p)  are the frequency vector and the power vector of Lomb–Scargle periodogram  p  respectively. source"},{"id":1748,"pagetitle":"LombScargle.jl","title":"Access Period Grid","ref":"/previews/PR43/LombScargle/stable/#Access-Period-Grid","content":" Access Period Grid The following utilities are the analogs of  freq  and  freqpower , but relative to the periods instead of the frequencies. Thus  period(p)  returns the vector of periods in the periodogram, that is  1./freq(p) , and  periodpower(p)  gives you the 2-tuple  (period(p), power(p)) ."},{"id":1749,"pagetitle":"LombScargle.jl","title":"LombScargle.period","ref":"/previews/PR43/LombScargle/stable/#LombScargle.period","content":" LombScargle.period  —  Function period(p::Periodogram) Return the period vector of Lomb–Scargle periodogram  p .  It is equal to  1 ./ freq(p) . source"},{"id":1750,"pagetitle":"LombScargle.jl","title":"LombScargle.periodpower","ref":"/previews/PR43/LombScargle/stable/#LombScargle.periodpower","content":" LombScargle.periodpower  —  Function periodpower(p::Periodogram) Return the 2-tuple  (period(p), power(p)) , where  period(p)  and  power(p)  are the period vector and the power vector of Lomb–Scargle periodogram  p  respectively. source"},{"id":1751,"pagetitle":"LombScargle.jl","title":"findmaxpower, findmaxfreq, and findmaxperiod Functions","ref":"/previews/PR43/LombScargle/stable/#findmaxpower,-findmaxfreq,-and-findmaxperiod-Functions","content":" findmaxpower ,  findmaxfreq , and  findmaxperiod  Functions Once you compute the periodogram, you usually want to know which are the frequencies or periods with highest power. To do this, you can use the  findmaxfreq  and  findmaxperiod  functions."},{"id":1752,"pagetitle":"LombScargle.jl","title":"LombScargle.findmaxpower","ref":"/previews/PR43/LombScargle/stable/#LombScargle.findmaxpower","content":" LombScargle.findmaxpower  —  Function findmaxpower(p::Periodogram) Return the highest power of the periodogram  p . source"},{"id":1753,"pagetitle":"LombScargle.jl","title":"LombScargle.findmaxfreq","ref":"/previews/PR43/LombScargle/stable/#LombScargle.findmaxfreq","content":" LombScargle.findmaxfreq  —  Function findmaxfreq(p::Periodogram, [interval::AbstractVector{Real}], threshold::Real=findmaxpower(p)) Return the array of frequencies with the highest power in the periodogram  p . If a scalar real argument  threshold  is provided, return the frequencies with power larger than or equal to  threshold .  If you want to limit the search to a narrower frequency range, pass as second argument a vector with the extrema of the interval. source"},{"id":1754,"pagetitle":"LombScargle.jl","title":"LombScargle.findmaxperiod","ref":"/previews/PR43/LombScargle/stable/#LombScargle.findmaxperiod","content":" LombScargle.findmaxperiod  —  Function findmaxperiod(p::Periodogram, [interval::AbstractVector{Real}], threshold::Real=findmaxpower(p)) Return the array of periods with the highest power in the periodogram  p .  If a scalar real argument  threshold  is provided, return the period with power larger than or equal to  threshold .  If you want to limit the search to a narrower period range, pass as second argument a vector with the extrema of the interval. source"},{"id":1755,"pagetitle":"LombScargle.jl","title":"False-Alarm Probability","ref":"/previews/PR43/LombScargle/stable/#False-Alarm-Probability","content":" False-Alarm Probability Noise in the data produce fluctuations in the periodogram that will present several local peaks, but not all of them related to real periodicities. The significance of the peaks can be tested by calculating the probability that its power can arise purely from noise.  The higher the value of the power, the lower will be this probability. Note [CMB99] showed that the different normalizations result in different probability functions.  LombScargle.jl  can calculate the probability (and the false-alarm probability) only for the normalizations reported by [ZK09], that are  :standard ,  :Scargle ,  :HorneBaliunas , and  :Cumming . The probability  $\\text{Prob}(p > p_{0})$  that the periodogram power  $p$  can exceed the value  $p_{0}$  can be calculated with the  prob  function, whose first argument is the periodogram and the second one is the  $p_{0}$  value. The function  probinv  is its inverse: it takes the probability as second argument and returns the corresponding  $p_{0}$  value."},{"id":1756,"pagetitle":"LombScargle.jl","title":"LombScargle.prob","ref":"/previews/PR43/LombScargle/stable/#LombScargle.prob-Tuple{LombScargle.Periodogram, Real}","content":" LombScargle.prob  —  Method prob(P::Periodogram, pow::Real) Return the probability that the periodogram power can exceed the value  pow . Its inverse is the  probinv  function. source"},{"id":1757,"pagetitle":"LombScargle.jl","title":"LombScargle.probinv","ref":"/previews/PR43/LombScargle/stable/#LombScargle.probinv-Tuple{LombScargle.Periodogram, Real}","content":" LombScargle.probinv  —  Method probinv(P::Periodogram, prob::Real) Return the power value of the periodogram power whose probability is  prob . This is the inverse of  prob  function. source"},{"id":1758,"pagetitle":"LombScargle.jl","title":"LombScargle.M","ref":"/previews/PR43/LombScargle/stable/#LombScargle.M","content":" LombScargle.M  —  Function LombScargle.M(P::Periodogram) Estimates the number of independent frequencies in the periodogram  P . source"},{"id":1759,"pagetitle":"LombScargle.jl","title":"LombScargle.fap","ref":"/previews/PR43/LombScargle/stable/#LombScargle.fap-Tuple{LombScargle.Periodogram, Real}","content":" LombScargle.fap  —  Method fap(P::Periodogram, pow::Real) Return the false-alarm probability for periodogram  P  and power value  pow . Its inverse is the  fapinv  function. source"},{"id":1760,"pagetitle":"LombScargle.jl","title":"LombScargle.fapinv","ref":"/previews/PR43/LombScargle/stable/#LombScargle.fapinv-Tuple{LombScargle.Periodogram, Real}","content":" LombScargle.fapinv  —  Method fapinv(P::Periodogram, prob::Real) Return the power value of the periodogram whose false-alarm probability is  prob . This is the inverse of  fap  function. source Here are the probability functions for each normalization supported by  LombScargle.jl : :standard  ( $p \\in [0, 1]$ ): \\[\\text{Prob}(p > p_{0}) = (1 - p_{0})^{(N - 3)/2}\\] :Scargle  ( $p \\in [0, \\infty)$ ): \\[\\text{Prob}(p > p_{0}) = \\exp(-p_{0})\\] :HorneBaliunas  ( $p \\in [0, (N - 1)/2]$ ): \\[\\text{Prob}(p > p_{0}) = \\left(1 - \\frac{2p_{0}}{N - 1}\\right)^{(N - 3)/2}\\] :Cumming  ( $p \\in [0, \\infty)$ ): \\[\\text{Prob}(p > p_{0}) = \\left(1 + \\frac{2p_{0}}{N - 3}\\right)^{-(N - 3)/2}\\] As explained by [SS10], «the term \"false-alarm probability denotes the probability that at least one out of  $M$  independent power values in a prescribed search band of a power spectrum computed from a white-noise time series is expected to be as large as or larger than a given value».  LombScargle.jl  provides the  fap  function to calculate the false-alarm probability (FAP) of a given power in a periodogram. Its first argument is the periodogram, the second one is the value  $p_{0}$  of the power of which you want to calculate the FAP. The function  fap  uses the formula \\[\\text{FAP} = 1 - (1 - \\text{Prob}(p > p_{0}))^M\\] where  $M$  is the number of independent frequencies estimated with  $M = T \\cdot \\Delta f$ , being  $T$  the duration of the observations and  $\\Delta f$  the width of the frequency range in which the periodogram has been calculated (see [CUM04]). The function  fapinv  is the inverse of  fap : it takes as second argument the value of the FAP and returns the corresponding value  $p_{0}$  of the power. The detection threshold  $p_{0}$  is the periodogram power corresponding to some (small) value of  $\\text{FAP}$ , i.e. the value of  $p$  exceeded due to noise alone in only a small fraction  $\\text{FAP}$  of trials. An observed power larger than  $p_{0}$  indicates that a signal is likely present (see [CUM04]). Warning Some authors stressed that this method to calculate the false-alarm probability is not completely reliable. A different approach to calculate the false-alarm probability is to perform Monte Carlo or bootstrap simulations in order to determine how often a certain power level  $p_{0}$  is exceeded just by chance (see [CMB99], [CUM04], and [ZK09]). See the  Bootstrapping  section."},{"id":1761,"pagetitle":"LombScargle.jl","title":"Bootstrapping","ref":"/previews/PR43/LombScargle/stable/#Bootstrapping","content":" Bootstrapping One of the possible and simplest statistical methods that you can use to measure the false-alarm probability and its inverse is  bootstrapping  (see section 4.2.2 of [MHC93]). Note We emphasize that you can use this method only if you know your data points are  independent and identically distributed , and they have  white uncorrelated noise . The recipe of the bootstrap method is very simple to implement: repeat the Lomb–Scargle analysis a large number  $N$  of times on the original data, but with the signal (and errors, if present) vector randomly shuffled. As an alternative, shuffle only the time vector; out of all these simulations, store the powers of the highest peaks; in order to estimate the false-alarm probability of a given power, count how many times the highest peak of the simulations exceeds that power, as a fraction of  $N$ . If you instead want to find the inverse of the false-alarm probability  $\\text{prob}$ , looks for the  $N\\cdot\\text{prob}$ -th element of the highest peaks vector sorted in descending order. Remember to pass to  lombscargle  function the same options, if any, you used to compute the Lomb–Scargle periodogram before. LombScargle.jl  provides simple methods to perform such analysis. The  LombScargle.bootstrap  function allows you to create a bootstrap sample with  N  permutations of the original data."},{"id":1762,"pagetitle":"LombScargle.jl","title":"LombScargle.bootstrap","ref":"/previews/PR43/LombScargle/stable/#LombScargle.bootstrap","content":" LombScargle.bootstrap  —  Function LombScargle.bootstrap(N::Integer,\n                      times::AbstractVector{Real},\n                      signal::AbstractVector{Real},\n                      errors::AbstractVector{Real}=ones(signal); ...) Create  N  bootstrap samples, perform the Lomb–Scargle analysis on them, and store all the highest peaks for each one in a  LombScargle.Bootstrap  object. All the arguments after  N  are passed around to  lombscargle . source LombScargle.bootstrap(N::Integer, plan::PeriodogramPlan) Create  N  bootstrap samples, perform the Lomb–Scargle analysis on them for the given  plan , and store all the highest peaks for each one in a  LombScargle.Bootstrap  object. See documentation of  LombScargle.plan  for how to plan a Lomb–Scargle periodogram. source The false-alarm probability and its inverse can be calculated with  fap  and  fapinv  functions respectively.  Their syntax is the same as the methods introduced above, but with a  LombScargle.Bootstrap  object as first argument, instead of the  LombScargle.Periodogram  one."},{"id":1763,"pagetitle":"LombScargle.jl","title":"LombScargle.fap","ref":"/previews/PR43/LombScargle/stable/#LombScargle.fap-Tuple{LombScargle.Bootstrap{var\"#s1\"} where var\"#s1\"<:AbstractFloat, Real}","content":" LombScargle.fap  —  Method fap(b::Bootstrap, power::Real) Return the false-alarm probability for  power  in the bootstrap sample  b . Its inverse is the  fapinv  function. source"},{"id":1764,"pagetitle":"LombScargle.jl","title":"LombScargle.fapinv","ref":"/previews/PR43/LombScargle/stable/#LombScargle.fapinv-Tuple{LombScargle.Bootstrap{var\"#s1\"} where var\"#s1\"<:AbstractFloat, Real}","content":" LombScargle.fapinv  —  Method fapinv(b::Bootstrap, prob::Real) Return the power value whose false-alarm probability is  prob  in the bootstrap sample  b . It returns  NaN  if the requested probability is too low and the power cannot be determined with the bootstrap sample  b .  In this case, you should enlarge your bootstrap sample so that  N*fap  can be rounded to an integer larger than or equal to 1. This is the inverse of  fap  function. source"},{"id":1765,"pagetitle":"LombScargle.jl","title":"LombScargle.model Function","ref":"/previews/PR43/LombScargle/stable/#LombScargle.model-Function","content":" LombScargle.model  Function For each frequency  $f$  (and hence for the corresponding angular frequency  $\\omega = 2\\pi f$ ) the Lomb–Scargle algorithm looks for the sinusoidal function of the type \\[a_f\\cos(\\omega t) + b_f\\sin(\\omega t) + c_f\\] that best fits the data. In the original Lomb–Scargle algorithm the offset  $c$  is null (see [LOM76]). In order to find the best-fitting coefficients  $a_f$ ,  $b_f$ , and  $c_f$  for the given frequency  $f$ , without actually performing the periodogram, you can solve the linear system  $\\mathbf{A}x = \\mathbf{y}$ , where  $\\mathbf{A}$  is the matrix \\[\\begin{aligned}\n\\begin{bmatrix}\n  \\cos(\\omega t) & \\sin(\\omega t) & 1\n\\end{bmatrix} =\n\\begin{bmatrix}\n  \\cos(\\omega t_{1}) & \\sin(\\omega t_{1}) & 1      \\\\\n  \\vdots             & \\vdots             & \\vdots \\\\\n  \\cos(\\omega t_{n}) & \\sin(\\omega t_{n}) & 1\n\\end{bmatrix}\n\\end{aligned}\\] $t = [t_1, \\dots, t_n]^\\text{T}$  is the column vector of observation times,  $x$  is the column vector with the unknown coefficients \\[\\begin{aligned}\n\\begin{bmatrix}\n  a_f \\\\\n  b_f \\\\\n  c_f\n\\end{bmatrix}\n\\end{aligned}\\] and  $\\textbf{y}$  is the column vector of the signal. The solution of the matrix gives the wanted coefficients. This is what the  LombScargle.model  function does in order to return the best fitting Lomb–Scargle model for the given signal at the given frequency."},{"id":1766,"pagetitle":"LombScargle.jl","title":"LombScargle.model","ref":"/previews/PR43/LombScargle/stable/#LombScargle.model","content":" LombScargle.model  —  Function LombScargle.model(times::AbstractVector{Real},\n                  signal::AbstractVector{R2},\n                  [errors::AbstractVector{R3},]\n                  frequency::Real,\n                  [times_fit::AbstractVector{R4}];\n                  center_data::Bool=true,\n                  fit_mean::Bool=true) Return the best fitting Lomb–Scargle model for the given signal at the given frequency. Mandatory arguments are: times : the observation times signal : the signal, sampled at  times  (must have the same length as  times ) frequency : the frequency at which to calculate the model Optional arguments are: errors : the vector of uncertainties of the signal.  If provided, it must have the same length as  signal  and  times , and be the third argument.  Like for  lombscargle , if the signal has uncertainties, the  signal  vector can also be a vector of  Measurement  objects, and this argument should be omitted times_fit : the vector of times at which the model will be calculated.  It defaults to  times .  If provided, it must come after  frequency Optional keyword arguments  center_data  and  fit_mean  have the same meaning as in  lombscargle : fit_mean : whether to fit for the mean. If this is  false , like in the original Lomb–Scargle periodogram,  $\\mathbf{A}$  does not have the third column of ones,  $c_f$  is set to  $0$  and the unknown vector to be determined becomes  $x = [a_f, b_f]^\\text{T}$ center_data : whether the data should be pre-centered before solving the linear system. This is particularly important if  fit_mean=false source"},{"id":1767,"pagetitle":"LombScargle.jl","title":"Examples","ref":"/previews/PR43/LombScargle/stable/#Examples","content":" Examples Here is an example of a noisy periodic signal ( $\\sin(\\pi t) + 1.5\\cos(2\\pi t)$ ) sampled at unevenly spaced times. julia> using LombScargle\n\njulia> ntimes = 1001\n1001\n\njulia> t = range(0.01, stop = 10pi, length = ntimes) # Observation times\n0.01:0.03140592653589793:31.41592653589793\n\njulia> t += step(t)*rand(ntimes) # Randomize times\n\njulia> s = sinpi.(t) .+ 1.5cospi.(2t) .+ rand(ntimes) # The signal\n\njulia> plan = LombScargle.plan(t, s); # Pre-plan the periodogram\n\njulia> pgram = lombscargle(plan) # Compute the periodogram\nLombScargle.Periodogram{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}},Array{Float64,1}}([0.000472346, 0.000461633, 0.000440906, 0.000412717, 0.000383552, 0.000355828, 0.000289723, 0.000154585, 3.44734e-5, 5.94437e-7  …  3.15125e-5, 0.000487391, 0.0018939, 0.00367003, 0.00484181, 0.00495189, 0.00453233, 0.00480968, 0.00619657, 0.0074052], 0.003185690706734265:0.00637138141346853:79.72190993602499, [0.0295785, 0.0540516, 0.0780093, 0.122759, 0.15685, 0.192366, 0.206601, 0.252829, 0.265771, 0.315443  …  31.1512, 31.1758, 31.2195, 31.2342, 31.2752, 31.293, 31.3517, 31.3761, 31.4148, 31.4199], :standard) You can plot the result, for example with  Plots  package. Use  freqpower  function to get the frequency grid and the power of the periodogram as a 2-tuple. using Plots\nplot(freqpower(pgram)...) You can also plot the power vs the period, instead of the frequency, with  periodpower : using Plots\nplot(periodpower(pgram)...) Warning If you do not fit for the mean of the signal ( fit_mean=false  keyword to  lombscargle  function) without centering the data ( center_data=false ) you can get inaccurate results. For example, spurious peaks at low frequencies can appear and the real peaks lose power: plot(freqpower(lombscargle(t, s, fit_mean=false, center_data=false))...) Tip You can tune the frequency grid with appropriate keywords to  lombscargle  function. For example, in order to increase the sampling increase  samples_per_peak , and set  maximum_frequency  to lower values in order to narrow the frequency range: plot(freqpower(lombscargle(t, s, samples_per_peak=20, maximum_frequency=1.5))...) If you simply want to use your own frequency grid, directly set the  frequencies  keyword: plot(freqpower(lombscargle(t, s, frequencies=0.001:1e-3:1.5))...)"},{"id":1768,"pagetitle":"LombScargle.jl","title":"Signal with Uncertainties","ref":"/previews/PR43/LombScargle/stable/#Signal-with-Uncertainties","content":" Signal with Uncertainties The generalised Lomb–Scargle periodogram is able to handle a signal with uncertainties, and they will be used as weights in the algorithm.  The uncertainties can be passed either as the third optional argument  errors  to  lombscargle  or by providing this function with a  signal  vector of type  Measurement  (from  Measurements.jl  package). using Measurements, Plots\nntimes = 1001\nt = range(0.01, stop = 10pi, length = ntimes)\ns = sinpi.(2t)\nerrors = rand(0.1:1e-3:4.0, ntimes)\n# Run one of the two following equivalent commands\nplot(freqpower(lombscargle(t, s, errors, maximum_frequency=1.5))...)\nplot(freqpower(lombscargle(t, measurement(s, errors), maximum_frequency=1.5))...) This is the plot of the power versus the period: # Run one of the two following equivalent commands\nplot(periodpower(lombscargle(t, s, errors, maximum_frequency=1.5))...)\nplot(periodpower(lombscargle(t, measurement(s, errors), maximum_frequency=1.5))...) We recall that the generalised Lomb–Scargle algorithm is used when the  fit_mean  optional keyword to  lombscargle  is  true  if no error is provided, instead it is always used if the signal has uncertainties."},{"id":1769,"pagetitle":"LombScargle.jl","title":"Find Highest Power and Associated Frequencies and Periods","ref":"/previews/PR43/LombScargle/stable/#Find-Highest-Power-and-Associated-Frequencies-and-Periods","content":" Find Highest Power and Associated Frequencies and Periods findmaxfreq  function tells you the frequencies with the highest power in the periodogram (and you can get the period by taking its inverse): julia> t = range(0, stop = 10, length = 1001);\n\njulia> s = sinpi.(t);\n\njulia> plan = LombScargle.plan(t, s); # Plan the periodogram\n\njulia> p = lombscargle(plan);\n\njulia> findmaxperiod(p) # Period with highest power\n1-element Array{Float64,1}:\n 0.004987779939149084\n\njulia> findmaxfreq(p) # Frequency with the highest power\n1-element Array{Float64,1}:\n 200.49 This peak is at high frequencies, very far from the expected value of the period of 2. In order to find the real peak, you can either narrow the ranges in order to exclude higher armonics julia> findmaxperiod(p, [1, 10]) # Limit the search to periods in [1, 10]\n1-element Array{Float64,1}:\n 2.04082\n\njulia> findmaxfreq(p, [0.1, 1]) # Limit the search to frequencies in [0.1, 1]\n1-element Array{Float64,1}:\n 0.49 or pass the  threshold  argument to  findmaxfreq  or  findmaxperiod . You can use  findmaxpower  to discover the highest power in the periodogram: julia> findmaxpower(p)\n0.9958310178312316\n\njulia> findmaxperiod(p, 0.95)\n10-element Array{Float64,1}:\n 2.04082\n 1.96078\n 0.0100513\n 0.0100492\n 0.00995124\n 0.00994926\n 0.00501278\n 0.00501228\n 0.00498778\n 0.00498728\n\njulia> findmaxfreq(p, 0.95)\n10-element Array{Float64,1}:\n   0.49\n   0.51\n  99.49\n  99.51\n 100.49\n 100.51\n 199.49\n 199.51\n 200.49\n 200.51 The first peak is the real one, the other double peaks appear at higher armonics. Tip Usually, plotting the periodogram can give you a clue of what's going on."},{"id":1770,"pagetitle":"LombScargle.jl","title":"Significance of the Peaks","ref":"/previews/PR43/LombScargle/stable/#Significance-of-the-Peaks","content":" Significance of the Peaks The significance of the peaks in the Lomb–Scargle periodogram can be assessed by measuring the  False-Alarm Probability . Analytic expressions of this quantity and its inverse can be obtained with the  fap  and  fapinv  functions, respectively. julia> t = linspace(0.01, 20, samples_per_peak = 10)\n\njulia> s = sinpi.(e.*t).^2 .- cos.(5t).^4\n\njulia> plan = LombScargle.plan(t, s);\n\njulia> p = lombscargle(plan)\n\n# Find the false-alarm probability for the highest peak.\njulia> fap(p, 0.3)\n0.028198095962262748 Thus, a peak with power  $0.3$  has a probability of  $0.028$  that it is due to noise only. A quantity that is often used is the inverse of the false-alarm probability as well: what is the minimum power whose false-alarm probability is lower than the given probability? For example, if you want to know the minimum power for which the false-alarm probability is at most  $0.01$  you can use: julia> fapinv(p, 0.01)\n0.3304696923786712 As we already noted, analytic expressions of the false-alarm probability and its inverse may not be reliable if your data does not satisfy specific assumptions. A better way to calculate this quantity is to use statistical methods. One of this is bootstrapping. In  LombScargle.jl , you can use the function  LombScargle.bootstrap  to create a bootstrap sample and then you can calculate the false-alarm probability and its inverse using this sample. Tip When applying the bootstrap method you should use the same options you used to perform the periodogram on your data. Using the same periodogram plan you used to compute the periodogram will ensure that you use the same options. However, note that the fast method gives approximate results that for some frequencies may not be reliable (they can go outside the range  $[0, 1]$  for the standard normalization). More robust results can be obtained with the  fast = false  option. # Create a bootstrap sample with 10000\n# resamplings of the original data, re-using the\n# same periodogram plan.  The larger the better.\n# This may take some minutes.\njulia> b = LombScargle.bootstrap(10000, plan)\n\n# Calculate the false-alarm probability of a peak\n# with power 0.3 using this bootstrap sample.\njulia> fap(b, 0.3)\n0.0209\n\n# Calculate the lowest power that has probability\n# less than 0.01 in this bootstrap sample.\njulia> fapinv(b, 0.01)\n0.3268290388848437 If you query  fapinv  with a too low probability, the corresponding power cannot be determined and you will get  NaN  as result. julia> fapinv(b, 1e-5)\nNaN If you want to find the power corresponding to a false-alarm probability of  $\\text{prob} = 10^{-5}$ , you have to create a new bootstrap sample with  $N$  resamplings so that  $N\\cdot\\text{prob}$  can be rounded to an integer larger than or equal to one (for example  $N = 10^{5}$ )."},{"id":1771,"pagetitle":"LombScargle.jl","title":"Find the Best-Fitting Model","ref":"/previews/PR43/LombScargle/stable/#Find-the-Best-Fitting-Model","content":" Find the Best-Fitting Model The  LombScargle.model  function can help you to test whether a certain frequency fits well your data. using Plots\nt = range(0.01, stop = 10pi, length = 1000) # Observation times\ns = sinpi.(t) .+ 1.2cospi.(t) .+ 0.3rand(length(t)) # The noisy signal\n# Pick-up the best frequency\nf = findmaxfreq(lombscargle(t, s, maximum_frequency=10, samples_per_peak=20))[1]\nt_fit = range(0, stop = 1, length = 50)\ns_fit = LombScargle.model(t, s, f, t_fit/f) # Determine the model\nscatter(mod.(t.*f, 1), s, lab=\"Phased data\", title=\"Best Lomb-Scargle frequency: $f\")\nplot!(t_fit, s_fit, lab=\"Best-fitting model\", linewidth=4) Tip If there are more than one dominant frequency you may need to consider more models. This task may require some work and patience. Plot the periodogram in order to find the best frequencies. using Plots\nt = range(0.01, stop = 5, length = 1000) # Observation times\ns = sinpi.(2t) .+ 1.2cospi.(4t) .+ 0.3rand(length(t)) # Noisy signal\nplan = LombScargle.plan(t, s, samples_per_peak=50)\np = lombscargle(plan)\n# After plotting the periodogram, you discover\n# that it has two prominent peaks around 1 and 2.\nf1 = findmaxfreq(p, [0.8, 1.2])[1] # Get peak frequency around 1\nf2 = findmaxfreq(p, [1.8, 2.2])[1] # Get peak frequency around 2\nfit1 = LombScargle.model(t, s, f1) # Determine the first model\nfit2 = LombScargle.model(t, s, f2) # Determine the second model\nscatter(t, s, lab=\"Data\", title=\"Best-fitting Lomb-Scargle model\")\nplot!(t, fit1 + fit2, lab=\"Best-fitting model\", linewidth=4)"},{"id":1772,"pagetitle":"LombScargle.jl","title":"Performance","ref":"/previews/PR43/LombScargle/stable/#Performance","content":" Performance A pre-planned periodogram in  LombScargle.jl  computed in single thread mode with the fast method is more than 2 times faster than the implementation of the same algorithm provided by AstroPy, and more than 4 times faster if 4 FFTW threads are used (on machines with at least 4 physical CPUs). The following plot shows a comparison between the times needed to compute a periodogram for a signal with N datapoints using  LombScargle.jl , with 1 or 4 FFTW threads (with  flags = FFTW.MEASURE  for better performance), and the single-threaded Astropy implementation.  (Julia version: 1.6.0;  LombScargle.jl  version: 1.0.0; Python version: 3.8.6; Astropy version: 4.1.  CPU: Intel(R) Core(TM) i7-4870HQ CPU @ 2.50GHz.) Note that this comparison is unfair, as Astropy doesn’t support pre-planning a periodogram nor multi-threading, and it pads vectors for FFT to a length which is a power of 2, while by default  LombScargle.jl  uses length which are multiples of 2, 3, 5, 7.  A non-planned periodogram in single thread mode in  LombScargle.jl  is still twice as fast as Astropy."},{"id":1773,"pagetitle":"LombScargle.jl","title":"Development","ref":"/previews/PR43/LombScargle/stable/#Development","content":" Development The package is developed at  https://github.com/JuliaAstro/LombScargle.jl . There you can submit bug reports, make suggestions, and propose pull requests."},{"id":1774,"pagetitle":"LombScargle.jl","title":"History","ref":"/previews/PR43/LombScargle/stable/#History","content":" History The ChangeLog of the package is available in  NEWS.md  file in top directory."},{"id":1775,"pagetitle":"LombScargle.jl","title":"License","ref":"/previews/PR43/LombScargle/stable/#License","content":" License The  LombScargle.jl  package is licensed under the BSD 3-clause \"New\" or \"Revised\" License. The original author is Mosè Giordano."},{"id":1776,"pagetitle":"LombScargle.jl","title":"Acknowledgements","ref":"/previews/PR43/LombScargle/stable/#Acknowledgements","content":" Acknowledgements This package adapts the implementation in Astropy of the the fast Lomb–Scargle method by [PR89]. We claim no endorsement nor promotion by the Astropy Team."},{"id":1781,"pagetitle":"Home","title":"Photometry.jl","ref":"/previews/PR43/Photometry/stable/#Photometry.jl","content":" Photometry.jl"},{"id":1782,"pagetitle":"Home","title":"Installation","ref":"/previews/PR43/Photometry/stable/#Installation","content":" Installation To install from the REPL, enter Pkg-mode ( ] ) pkg> add Photometry"},{"id":1783,"pagetitle":"Home","title":"Getting Started","ref":"/previews/PR43/Photometry/stable/#Getting-Started","content":" Getting Started Here is a basic example to do some aperture photometry using  CircularAperture . The  photometry  function performs the photometry using a given method. using Photometry\ndata = ones(100, 100)\nerr = ones(100, 100)\n\nap1 = CircularAperture(50, 50, 3)\n# partial overlap\nap2 = CircularAperture(0.5, 0.5, 5)\n\nresults = photometry([ap1, ap2], data, err)\n@assert results.aperture_sum[1] ≈ 9π\n@assert results.aperture_sum[2] ≈ 25π / 4\n\nresults Table with 4 columns and 2 rows:\n     xcenter  ycenter  aperture_sum  aperture_sum_err\n   ┌─────────────────────────────────────────────────\n 1 │ 50.0     50.0     28.2743       5.31736\n 2 │ 0.5      0.5      19.635        4.43113"},{"id":1784,"pagetitle":"Home","title":"Contributing","ref":"/previews/PR43/Photometry/stable/#Contributing","content":" Contributing If you're interested in contributing, go ahead and check out the  issues  or make a  pull request . If you add a new feature, please write appropriate unit tests for it and bump the package's minor version."},{"id":1785,"pagetitle":"Home","title":"License","ref":"/previews/PR43/Photometry/stable/#License","content":" License The work derived from  astropy/photutils  is BSD 3-clause and the work derived from  kbarbary/sep  is BSD 3-clause. All other work is considered MIT expat. Therefore this work as a whole is BSD 3-clause.  LICENSE  contains all licenses and any files using derived work are noted at the top of the file."},{"id":1788,"pagetitle":"Getting Started","title":"Aperture Photometry","ref":"/previews/PR43/Photometry/stable/apertures/#Aperture-Photometry","content":" Aperture Photometry"},{"id":1789,"pagetitle":"Getting Started","title":"Introduction","ref":"/previews/PR43/Photometry/stable/apertures/#Introduction","content":" Introduction Aperture photometry uses  Apertures  to cut out and sum values in an image. A very basic mask might be a square of pixels at a certain position. We can model this as a matrix of ones and zeros like ⎡0 0 0 0 0⎤\n⎢0 1 1 1 0⎥\n⎢0 1 1 1 0⎥\n⎢0 1 1 1 0⎥\n⎣0 0 0 0 0⎦ If we have some data like ⎡7 9 6 0 8⎤\n⎢8 5 8 7 9⎥\n⎢5 6 2 2 7⎥\n⎢9 7 3 4 1⎥\n⎣7 8 0 9 8⎦ then the result of our aperture photometry looks like ⎡0 0 0 0 0⎤    ⎡7 9 6 0 8⎤     ⎡0 0 0 0 0⎤\n⎢0 1 1 1 0⎥    ⎢8 5 8 7 9⎥     ⎢0 5 8 7 0⎥\n⎢0 1 1 1 0⎥ .* ⎢5 6 2 2 7⎥  =  ⎢0 6 2 2 0⎥\n⎢0 1 1 1 0⎥    ⎢9 7 3 4 1⎥     ⎢0 7 3 4 0⎥\n⎣0 0 0 0 0⎦    ⎣7 8 0 9 8⎦     ⎣0 0 0 0 0⎦\n\nsum(result) = 44 This module uses the above principal with common aperture shapes in a fast and precise manner, including exact overlaps between apertures and pixels. The majority of the lifting is done with the  photometry  function with common shapes being described in  Apertures . It is possible to create a custom aperture by sub-typing the  Aperture.AbstractAperture  class, although it may be easier to perform PSF photometry instead."},{"id":1790,"pagetitle":"Getting Started","title":"Pixel Convention","ref":"/previews/PR43/Photometry/stable/apertures/#Pixel-Convention","content":" Pixel Convention Photometry.jl  follows the same convention as FITS, WCS, IRAF, DS9, and SourceExtractor with  (1, 1)  being the  center  on the bottom-left pixel. This means the exact bottom-left corner is at  (0.5, 0.5) . Pixels increase up and to the right until  axis_length + 0.5 ."},{"id":1791,"pagetitle":"Getting Started","title":"API/Reference","ref":"/previews/PR43/Photometry/stable/apertures/#API/Reference","content":" API/Reference"},{"id":1792,"pagetitle":"Getting Started","title":"Photometry.Aperture.photometry","ref":"/previews/PR43/Photometry/stable/apertures/#Photometry.Aperture.photometry","content":" Photometry.Aperture.photometry  —  Function photometry(::AbstractAperture, data::AbstractMatrix, [error])\nphotometry(::AbstractVector{<:AbstractAperture}, data::AbstractMatrix, [error]) Perform aperture photometry on  data  given aperture(s). If  error  (the pixel-wise standard deviation) is provided, will calculate sum error. If a list of apertures is provided the output will be a  TypedTables.Table , otherwise a  NamedTuple . Tip This code is automatically multi-threaded. To take advantage of this please make sure  JULIA_NUM_THREADS  is set before starting your runtime. source"},{"id":1793,"pagetitle":"Getting Started","title":"Performance","ref":"/previews/PR43/Photometry/stable/apertures/#Performance","content":" Performance Below are some benchmarks comparing the aperture photometry capabilities of  Photometry.jl  with the  photutils  asropy package. The benchmark code can be found in the  bench  folder . Note that for the multi-threaded examples my machine has 4 physical cores with 8 threads. julia> versioninfo()\nJulia Version 1.5.0\nCommit 96786e22cc (2020-08-01 23:44 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin18.7.0)\n  CPU: Intel(R) Core(TM) i5-8259U CPU @ 2.30GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-9.0.1 (ORCJIT, skylake)"},{"id":1794,"pagetitle":"Getting Started","title":"Number of Apertures","ref":"/previews/PR43/Photometry/stable/apertures/#Number-of-Apertures","content":" Number of Apertures This benchmark shows how performance scales as we increase the number of apertures. The apertures are distributed randomly across the image with a fixed radius of 10. The image size is (512, 512). We see an improvement of ~10-100x (depending on multithreading) over photutils."},{"id":1795,"pagetitle":"Getting Started","title":"Size of Apertures","ref":"/previews/PR43/Photometry/stable/apertures/#Size-of-Apertures","content":" Size of Apertures This benchmark analyzes how the aperture size affects performance. Theoretically it should increase with  O(n^2)  complexity. For aperture sizes increasing from 1 to 200,  located in the center of a an image of size (512, 512)."},{"id":1798,"pagetitle":"Apertures","title":"Apertures","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Apertures","content":" Apertures All apertures will rely on a position and the shape parameters. aperture = Aperture(x0, y0, shape_params...) The position can be pixels or sky coordinates. The sky coordinate positions utilize  SkyCoords.jl  and  WCS.jl  for conversion. Warning Sky coordinates are not supported yet. Note See  Pixel Convention  - The origin is the bottom-left with  (1, 1)  being the center of the pixel."},{"id":1799,"pagetitle":"Apertures","title":"API/Reference","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#API/Reference","content":" API/Reference"},{"id":1800,"pagetitle":"Apertures","title":"Photometry.Aperture.AbstractAperture","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.AbstractAperture","content":" Photometry.Aperture.AbstractAperture  —  Type AbstractAperture{T} <: AbstractMatrix{T} The abstract super-type for Apertures. Apertures can be thought of as a cutout or stamp of a geometric shape with shading applied. For example, a circular aperture with a diameter of 3 pixels will require a 5x5 pixel grid (when perfectly on-grid) to represent. julia> ap = CircularAperture(3, 3, 2.5)\n5×5 CircularAperture{Float64} with indices 1:5×1:5:\n 0.136857  0.769325  0.983232  0.769325  0.136857\n 0.769325  1.0       1.0       1.0       0.769325\n 0.983232  1.0       1.0       1.0       0.983232\n 0.769325  1.0       1.0       1.0       0.769325\n 0.136857  0.769325  0.983232  0.769325  0.136857 This is a useful way of thinking about apertures: if we have some data, we can weight the data with the aperture. julia> data = fill(2, 5, 5);\n\njulia> idxs = map(intersect, axes(ap), axes(data)) |> CartesianIndices;\n\njulia> weighted_cutout = data[idxs] .* ap[idxs]\n5×5 Matrix{Float64}:\n 0.273713  1.53865  1.96646  1.53865  0.273713\n 1.53865   2.0      2.0      2.0      1.53865\n 1.96646   2.0      2.0      2.0      1.96646\n 1.53865   2.0      2.0      2.0      1.53865\n 0.273713  1.53865  1.96646  1.53865  0.273713 Performing aperture photometry is merely summing the weighted cutout shown above. julia> flux = sum(weighted_cutout)\n39.269908169872416\n\njulia> flux ≈ (π * 2.5^2) * 2 # area of circle times intensity of 2\ntrue What's interesting about the implementation of apertures, though, is they are lazy. This means there is no stored matrix of aperture values; rather, they are calculated on the fly as needed. julia> axes(ap)\n(1:5, 1:5)\n\njulia> ap[-10, -10] # out-of-bounds, but calculated on the fly\n0.0\n\njulia> ap .* ones(5, 7) # broadcasts to eachindex(data), regardless of ap bound\n5×7 Matrix{Float64}:\n 0.136857  0.769325  0.983232  0.769325  0.136857  0.0  0.0\n 0.769325  1.0       1.0       1.0       0.769325  0.0  0.0\n 0.983232  1.0       1.0       1.0       0.983232  0.0  0.0\n 0.769325  1.0       1.0       1.0       0.769325  0.0  0.0\n 0.136857  0.769325  0.983232  0.769325  0.136857  0.0  0.0 This allows extremely efficient computation of aperture photometry from small to medium sized apertures. julia> using BenchmarkTools\n\njulia> @btime sum(idx -> $ap[idx] * $data[idx], $idxs)\n  1.097 μs (0 allocations: 0 bytes)\n39.26990816987243 This is essentially the full implementation of  photometry , save for the packing of additional information into a tabular form. source"},{"id":1801,"pagetitle":"Apertures","title":"Photometry.Aperture.Subpixel","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.Subpixel","content":" Photometry.Aperture.Subpixel  —  Type Subpixel(ap, N=1) <: AbstractAperture Use a subpixel quadrature approximation for pixel shading instead of exact geometric methods. For any pixel laying on the border of  ap , this alters the shading algorithm by breaking the border pixel up into  (N, N)  subpixels. The shading value is the fraction of these subpixels within the geometric border of  ap . Using a subpixel shading method is sometimes faster than exact methods at the cost of accuracy. For  CircularAperture  the subpixel method is only faster than the exact method for  N  ~ 7. for  EllipticalAperture  the cutoff is  N  ~ 12, and for  RectangularAperture  the cutoff is  N  ~ 20. Examples julia> ap = CircularAperture(3, 3, 2.5)\n5×5 CircularAperture{Float64} with indices 1:5×1:5:\n 0.136857  0.769325  0.983232  0.769325  0.136857\n 0.769325  1.0       1.0       1.0       0.769325\n 0.983232  1.0       1.0       1.0       0.983232\n 0.769325  1.0       1.0       1.0       0.769325\n 0.136857  0.769325  0.983232  0.769325  0.136857\n\njulia> sub_ap = Subpixel(ap, 5)\n5×5 Subpixel{Float64, CircularAperture{Float64}} with indices 1:5×1:5:\n 0.12  0.76  1.0  0.76  0.12\n 0.76  1.0   1.0  1.0   0.76\n 1.0   1.0   1.0  1.0   1.0\n 0.76  1.0   1.0  1.0   0.76\n 0.12  0.76  1.0  0.76  0.12 Note photutils  offers a  center  shading method which is equivalent to using the  Subpixel  method with 1 subpixel. To avoid unneccessary namespace cluttering, we simply instruct users to use  Subpixel(ap)  instead. source"},{"id":1802,"pagetitle":"Apertures","title":"Photometry.Aperture.area_arc","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.area_arc","content":" Photometry.Aperture.area_arc  —  Function Area of a circular segment above a chord between two points with circle radius  r Reference source"},{"id":1803,"pagetitle":"Apertures","title":"Photometry.Aperture.circular_overlap_core","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.circular_overlap_core","content":" Photometry.Aperture.circular_overlap_core  —  Function Core of circular overlap routine source"},{"id":1804,"pagetitle":"Apertures","title":"Photometry.Aperture.circular_overlap_single_exact","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.circular_overlap_single_exact","content":" Photometry.Aperture.circular_overlap_single_exact  —  Function Area of overlap between a rectangle and a circle source"},{"id":1805,"pagetitle":"Apertures","title":"Photometry.Aperture.inside_ellipse","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.inside_ellipse","content":" Photometry.Aperture.inside_ellipse  —  Function inside_ellipse(x, y, h, k, cxx, cyy, cxy) x: x coordinate of the test point y: y coordinate of the test point h: x coordinate of the center of ellipse k: y coordinate of the center of ellipse cxx, cyy, cxy: coefficients of equation of ellipse Utility function to find whether a point is inside ellipse or not. If point inside ellipse: Returns true else returns false General equation of ellipse:     cxx * (x - h)^2 + cxy * (x - h) * (y - k) + cyy * (y - k)^2 = 1 source"},{"id":1806,"pagetitle":"Apertures","title":"Base.size","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Base.size-Tuple{Photometry.Aperture.AbstractAperture}","content":" Base.size  —  Method size(::AbstractAperture) Return ( ny ,  nx ) of the aperture. source"},{"id":1807,"pagetitle":"Apertures","title":"Photometry.Aperture.area_triangle","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.area_triangle","content":" Photometry.Aperture.area_triangle  —  Function Area of a triangle defined by three vertices source"},{"id":1808,"pagetitle":"Apertures","title":"Photometry.Aperture.inside_rectangle","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.inside_rectangle","content":" Photometry.Aperture.inside_rectangle  —  Function intersection with rectangular using implicit Lamé curve source"},{"id":1809,"pagetitle":"Apertures","title":"Photometry.Aperture.bounds","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.bounds","content":" Photometry.Aperture.bounds  —  Function bounds(::AbstractAperture) Return the ( xlow ,  xhigh ,  ylow ,  yhigh ) bounds for a given Aperture. source"},{"id":1810,"pagetitle":"Apertures","title":"Circular Apertures","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Circular-Apertures","content":" Circular Apertures These apertures are parameterized by radius."},{"id":1811,"pagetitle":"Apertures","title":"Photometry.Aperture.CircularAperture","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.CircularAperture","content":" Photometry.Aperture.CircularAperture  —  Type CircularAperture(x, y, r)\nCircularAperture(position, r) A circular aperture. A circular aperture with radius  r .  r  must be greater than or equal to 0. Examples julia> ap = CircularAperture(0, 0, 10)\n21×21 CircularAperture{Int64} with indices -10:10×-10:10:\n 0          0         0           …  0           0         0\n 0          0         0              0           0         0\n 0          0         0              0           0         0\n 0          0         0.00571026     0.00571026  0         0\n 0          0         0.491844       0.491844    0         0\n 0          0.170878  0.982952    …  0.982952    0.170878  0\n 0          0.659735  1              1           0.659735  0\n 0.0590655  0.975524  1              1           0.975524  0.0590655\n 0.293527   1         1              1           1         0.293527\n 0.445643   1         1              1           1         0.445643\n ⋮                                ⋱                        ⋮\n 0.293527   1         1              1           1         0.293527\n 0.0590655  0.975524  1              1           0.975524  0.0590655\n 0          0.659735  1              1           0.659735  0\n 0          0.170878  0.982952    …  0.982952    0.170878  0\n 0          0         0.491844       0.491844    0         0\n 0          0         0.00571026     0.00571026  0         0\n 0          0         0              0           0         0\n 0          0         0              0           0         0\n 0          0         0           …  0           0         0 source"},{"id":1812,"pagetitle":"Apertures","title":"Photometry.Aperture.CircularAnnulus","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.CircularAnnulus","content":" Photometry.Aperture.CircularAnnulus  —  Type CircularAnnulus(x, y, r_in, r_out)\nCircularAnnulus(position, r_in, r_out) A circular annulus with inner radius  r_in  and outer radius  r_out . 0 ≤  r_in  ≤  r_out . Examples julia> ap = CircularAnnulus(0, 0, 5, 10)\n21×21 CircularAnnulus{Int64} with indices -10:10×-10:10:\n 0          0         0           …  0           0         0\n 0          0         0              0           0         0\n 0          0         0              0           0         0\n 0          0         0.00571026     0.00571026  0         0\n 0          0         0.491844       0.491844    0         0\n 0          0.170878  0.982952    …  0.982952    0.170878  0\n 0          0.659735  1              1           0.659735  0\n 0.0590655  0.975524  1              1           0.975524  0.0590655\n 0.293527   1         1              1           1         0.293527\n 0.445643   1         1              1           1         0.445643\n ⋮                                ⋱                        ⋮\n 0.293527   1         1              1           1         0.293527\n 0.0590655  0.975524  1              1           0.975524  0.0590655\n 0          0.659735  1              1           0.659735  0\n 0          0.170878  0.982952    …  0.982952    0.170878  0\n 0          0         0.491844       0.491844    0         0\n 0          0         0.00571026     0.00571026  0         0\n 0          0         0              0           0         0\n 0          0         0              0           0         0\n 0          0         0           …  0           0         0 source"},{"id":1813,"pagetitle":"Apertures","title":"Elliptical Apertures","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Elliptical-Apertures","content":" Elliptical Apertures These apertures are parameterized by the semi-major axis  a , semi-minor axis  b  and position angle in degrees counter-clockwise from the positive x-axis  θ"},{"id":1814,"pagetitle":"Apertures","title":"Photometry.Aperture.EllipticalAperture","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.EllipticalAperture","content":" Photometry.Aperture.EllipticalAperture  —  Type EllipticalAperture(x, y, a, b, θ=0)\nEllipticalAperture(position, a, b, θ=0) An elliptical aperture with semi-major axis  a , semi-minor axis  b , and position angle  θ .  a  and  b  must be ≥ 0,  θ  is measured in degrees counter-clockwise the standard x-axis. Examples julia> ap = EllipticalAperture(0, 0, 4, 2, 35)\n7×5 EllipticalAperture{Int64} with indices -3:3×-2:2:\n 0.873382  0.844185  0.324917  0         0\n 1         1         0.997821  0.435284  0\n 1         1         1         0.990119  0.23968\n 0.796137  1         1         1         0.796137\n 0.23968   0.990119  1         1         1\n 0         0.435284  0.997821  1         1\n 0         0         0.324917  0.844185  0.873382 source"},{"id":1815,"pagetitle":"Apertures","title":"Photometry.Aperture.EllipticalAnnulus","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.EllipticalAnnulus","content":" Photometry.Aperture.EllipticalAnnulus  —  Type EllipticalAnnulus(x, y, a_in, a_out, b_out, θ=0)\nEllipticalAnnulus(position, a_in, a_out, b_out, θ=0) An elliptical annulus with inner semi-major axis  a_in , outer semi-major axis  a_out , outer semi-minor axis  b_out , and position angle  θ .  a_out  ≥  a_in  ≥ 0 and  b_out  must be ≥ 0,  θ  is measured in degrees counter-clockwise the standard x-axis. b_in  will automatically be calculated from  (a_in / a_out) * b_out . Note this may cause a type instability. Examples julia> ap = EllipticalAnnulus(0, 0, 4, 10, 5, 45)\n15×15 EllipticalAnnulus{Float64} with indices -7:7×-7:7:\n 0.594853   1.0       1.0       1.0         …  0.0       0.0       0.0\n 1.0        1.0       1.0       1.0            0.0       0.0       0.0\n 1.0        1.0       1.0       1.0            0.0       0.0       0.0\n 1.0        1.0       1.0       1.0            0.0       0.0       0.0\n 1.0        1.0       1.0       1.0            0.0       0.0       0.0\n 0.814163   1.0       1.0       1.0         …  0.414163  0.0       0.0\n 0.369432   1.0       1.0       1.0            0.975704  0.193728  0.0\n 0.0112571  0.809079  1.0       1.0            1.0       0.809079  0.0112571\n 0.0        0.193728  0.975704  1.0            1.0       1.0       0.369432\n 0.0        0.0       0.414163  1.0            1.0       1.0       0.814163\n 0.0        0.0       0.0       0.546165    …  1.0       1.0       1.0\n 0.0        0.0       0.0       0.00252321     1.0       1.0       1.0\n 0.0        0.0       0.0       0.0            1.0       1.0       1.0\n 0.0        0.0       0.0       0.0            1.0       1.0       1.0\n 0.0        0.0       0.0       0.0            1.0       1.0       0.594853 source"},{"id":1816,"pagetitle":"Apertures","title":"Rectangular Apertures","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Rectangular-Apertures","content":" Rectangular Apertures These apertures are parameterized by width  w , height  h , and position angle in degrees counter-clockwise from the positive x-axis  θ ."},{"id":1817,"pagetitle":"Apertures","title":"Photometry.Aperture.RectangularAperture","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.RectangularAperture","content":" Photometry.Aperture.RectangularAperture  —  Type RectangularAperture(x, y, w, h, θ=0)\nRectangularAperture(position, w, h, θ=0) A rectangular aperture. A rectangular aperture with width  w , height  h , and position angle  θ  in degrees. Examples julia> ap = RectangularAperture(0, 0, 10, 4, 0)\n11×5 RectangularAperture{Int64} with indices -5:5×-2:2:\n 0.25  0.5  0.5  0.5  0.25\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.25  0.5  0.5  0.5  0.25 source"},{"id":1818,"pagetitle":"Apertures","title":"Photometry.Aperture.RectangularAnnulus","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.RectangularAnnulus","content":" Photometry.Aperture.RectangularAnnulus  —  Type RectangularAnnulus(x, y, w_in, w_out, h_out, θ=0)\nRectangularAnnulus(position, w_in, w_out, h_out, θ=0) A rectangular annulus with inner width  w_in , outer width  w_out , outer height  h_out , and position angle  θ  in degrees.  h_in  is automatically calculated from  w_in / w_out * h_out . Note that  w_out ≥ w_in > 0 . Examples julia> ap = RectangularAnnulus(0, 0, 5, 10, 8, 45)\n13×13 RectangularAnnulus{Float64} with indices -6:6×-6:6:\n 0.0       0.0       0.0         …  0.0         0.0       0.0\n 0.0       0.0       0.0            0.0         0.0       0.0\n 0.0       0.0       0.00252532     0.0         0.0       0.0\n 0.0       0.0       0.568542       0.0         0.0       0.0\n 0.0       0.568542  1.0            0.215729    0.0       0.0\n 0.528175  1.0       1.0         …  1.0         0.215729  0.0\n 0.215729  1.0       1.0            1.0         1.0       0.215729\n 0.0       0.215729  1.0            1.0         1.0       0.528175\n 0.0       0.0       0.215729       1.0         0.568542  0.0\n 0.0       0.0       0.0            0.568542    0.0       0.0\n 0.0       0.0       0.0         …  0.00252532  0.0       0.0\n 0.0       0.0       0.0            0.0         0.0       0.0\n 0.0       0.0       0.0            0.0         0.0       0.0 source"},{"id":1821,"pagetitle":"Examples","title":"Examples","ref":"/previews/PR43/Photometry/stable/apertures/examples/#Examples","content":" Examples"},{"id":1822,"pagetitle":"Examples","title":"Plotting","ref":"/previews/PR43/Photometry/stable/apertures/examples/#Plotting","content":" Plotting We have recipes for all our aperture types, so you can easily create overlays on your images. using Photometry\nusing Plots\n\nplot(CircularAperture(2, 3, 4), c=1, xlims=(-1, 12), ylims=(0, 9))\nplot!(CircularAnnulus(5, 5, 2.1, 3), c=2)\nplot!(EllipticalAperture(0, 0, 10, 1, 32), c=3)\nplot!(EllipticalAnnulus(5, 5, 4, 5, 2, -32), c=4)\nplot!(RectangularAperture(0, 0, 4, 4, 4), c=5)\nplot!(RectangularAnnulus(5, 1, 3, 4, 4, 4), c=6)"},{"id":1823,"pagetitle":"Examples","title":"Simple Stars","ref":"/previews/PR43/Photometry/stable/apertures/examples/#Simple-Stars","content":" Simple Stars Here is an example where we will find aperture fluxes for stars from M67. The dataset is provided as part of the  astropy/photutils-datasets  repository. Let's start by downloading and showing our image using Photometry\nusing Plots\nusing FITSIO\n\n# Load data in\nurl = \"https://rawcdn.githack.com/astropy/photutils-datasets/8c97b4fa3a6c9e6ea072faeed2d49a20585658ba/data/M6707HH.fits\"\nhdu = FITS(download(url))\nchunk = read(hdu[1], 81:155, 71:150)\n\n# Plot\nfunction imshow(image; kwargs...)\n    xs, ys = axes(image)\n    data = transpose(image)\n    heatmap(xs, ys, data; aspect_ratio=1, xlim=extrema(xs), ylim=extrema(ys), kwargs...)\nend\n\nimshow(chunk) Now let's add some apertures! positions = [\n    [47.5 , 67.5],\n    [29.5 , 62.5],\n    [23.5 , 48.5],\n    [17.5 , 29.5],\n    [13.25, 10.5],\n    [65.5 , 14.0]\n]\n\nradii = [3, 3, 2.7, 2, 2.7, 3]\n\naps = CircularAperture.(positions, radii) 6-element Vector{CircularAperture{Float64}}:\n CircularAperture(47.5, 67.5, r=3.0)\n CircularAperture(29.5, 62.5, r=3.0)\n CircularAperture(23.5, 48.5, r=2.7)\n CircularAperture(17.5, 29.5, r=2.0)\n CircularAperture(13.25, 10.5, r=2.7)\n CircularAperture(65.5, 14.0, r=3.0) now let's plot them up imshow(chunk)\nplot!(aps, c=:white) and finally let's get our output table for the photometry table = photometry(aps, chunk) Table with 3 columns and 6 rows:\n     xcenter  ycenter  aperture_sum\n   ┌───────────────────────────────\n 1 │ 47.5     67.5     2.48267e5\n 2 │ 29.5     62.5     2.25989e5\n 3 │ 23.5     48.5     1.49979e5\n 4 │ 17.5     29.5     72189.4\n 5 │ 13.25    10.5     1.48118e5\n 6 │ 65.5     14.0     2.02803e5"},{"id":1824,"pagetitle":"Examples","title":"Stars with Spatial Background Subtraction","ref":"/previews/PR43/Photometry/stable/apertures/examples/#Stars-with-Spatial-Background-Subtraction","content":" Stars with Spatial Background Subtraction This example will be the same as  Simple Stars  but will add background estimation using the tools in  Background Estimation clipped = sigma_clip(chunk, 1, fill=NaN)\n# Estimate 2D spatial background using boxes of size (5, 5)\nbkg, bkg_rms = estimate_background(clipped, 5)\n\nplot(\n    imshow(chunk, title=\"Original\"),\n    imshow(clipped, title=\"Sigma-Clipped\"),\n    imshow(bkg, title=\"Background\"),\n    imshow(bkg_rms, title=\"Background RMS\");\n    layout=(2, 2), size=(600, 600), ticks=false\n) Now, using the same apertures, let's find the output using the background-subtracted image plot(\n    imshow(chunk, title=\"Original\"),\n    imshow(chunk .- bkg, title=\"Subtracted\");\n    layout=2, size=(600, 260), ticks=false, colorbar=false\n)\nplot!(aps, c=:white, subplot=1)\nplot!(aps, c=:white, subplot=2) table = photometry(aps, chunk .- bkg, bkg_rms) Table with 4 columns and 6 rows:\n     xcenter  ycenter  aperture_sum  aperture_sum_err\n   ┌─────────────────────────────────────────────────\n 1 │ 47.5     67.5     2.13534e5     431.48\n 2 │ 29.5     62.5     114217.0      887.37\n 3 │ 23.5     48.5     59230.7       1061.28\n 4 │ 17.5     29.5     23159.6       697.556\n 5 │ 13.25    10.5     54638.1       1048.67\n 6 │ 65.5     14.0     91179.1       1168.71"},{"id":1827,"pagetitle":"Getting Started","title":"Background Estimation","ref":"/previews/PR43/Photometry/stable/background/#Background-Estimation","content":" Background Estimation The module provides tools and algorithms for estimating the background of astronomical data."},{"id":1828,"pagetitle":"Getting Started","title":"Usage","ref":"/previews/PR43/Photometry/stable/background/#Usage","content":" Usage Estimating backgrounds is an important step in performing photometry. Ideally, we could perfectly describe the background with a scalar value or with some distribution. Unfortunately, it's impossible for us to precisely separate the background and foreground signals. Here, we use mixture of robust statistical estimators and meshing to let us get the spatially varying background from an astronomical photo. Let's show an example using Photometry\nusing FITSIO\nusing Plots\n\n# Download our image, courtesy of astropy\nurl = \"https://rawcdn.githack.com/astropy/photutils-datasets/8c97b4fa3a6c9e6ea072faeed2d49a20585658ba/data/M6707HH.fits\"\nhdu = FITS(download(url))\nimage = read(hdu[1])\n\n# Plot\nfunction imshow(image; kwargs...)\n    xs, ys = axes(image)\n    data = transpose(image)\n    heatmap(xs, ys, data;\n            aspect_ratio=1,\n            xlim=extrema(xs), ylim=extrema(ys),\n            kwargs...)\nend\n\nimshow(image) Now let's try and estimate the background using  estimate_background . First, we'll sigma-clip to try and remove the signals from the stars. Then, the background is broken down into boxes, in this case of size  (50, 50) . Within each box, the given statistical estimators get the background value and RMS. By default, we use  SourceExtractorBackground  and  StdRMS . This creates a low-resolution image, which we then need to resize. We can accomplish this using an interpolator, by default a cubic-spline interpolator via  ZoomInterpolator . The end result is a smooth estimate of the spatially varying background and background RMS. # sigma-clip\nclipped = sigma_clip(image, 1, fill=NaN)\n\n# get background and background rms with box-size (50, 50)\nbkg, bkg_rms = estimate_background(clipped, 50)\n\n# plot\nplot(\n    imshow(image, title=\"Original\"),\n    imshow(clipped, title=\"Sigma-Clipped\"),\n    imshow(bkg, title=\"Background\"),\n    imshow(bkg_rms, title=\"Background RMS\"),\n    layout=(2, 2), ticks=false,\n) We could apply a median filter, too, by specifying  filter_size # get background and background rms with box-size (50, 50) and filter_size (5, 5)\nbkg_f, bkg_rms_f = estimate_background(clipped, 50, filter_size=5)\n\n# plot\nplot(\n    imshow(bkg, title=\"Unfiltered\", ylabel=\"Background\"),\n    imshow(bkg_f, title=\"Filtered\"),\n    imshow(bkg_rms, ylabel=\"RMS\"),\n    imshow(bkg_rms_f);\n    layout=(2, 2), ticks=false,\n) Now we can see our image after subtracting the filtered background and ready for  Aperture Photometry ! subt = image .- bkg_f[axes(image)...]\nplot(\n    imshow(image, title=\"Original\", colorbar=false),\n    imshow(subt, title=\"Subtracted\");\n    layout=(1, 2), size=(600, 260),\n    xlims=(400, 800), ylims=(400, 800),\n    clims=(minimum(subt), maximum(image)),\n    ticks=false, aspect_ratio=1,\n)"},{"id":1829,"pagetitle":"Getting Started","title":"IDW Interpolator","ref":"/previews/PR43/Photometry/stable/background/#IDW-Interpolator","content":" IDW Interpolator Here is a quick example using the  IDWInterpolator b1, r1 = estimate_background(clipped, 50, filter_size=5)\nb2, r2 = estimate_background(clipped, 50, itp=IDWInterpolator(50), filter_size=5)\n\nplot(\n    imshow(b1, title=\"ZoomInterpolator\", ylabel=\"Background\"),\n    imshow(b2, title=\"IDWInterpolator\"),\n    imshow(r1, ylabel=\"RMS\"),\n    imshow(r2);\n    layout=(2, 2), ticks=false,\n)"},{"id":1830,"pagetitle":"Getting Started","title":"API/Reference","ref":"/previews/PR43/Photometry/stable/background/#API/Reference","content":" API/Reference"},{"id":1831,"pagetitle":"Getting Started","title":"Photometry.Background.estimate_background","ref":"/previews/PR43/Photometry/stable/background/#Photometry.Background.estimate_background","content":" Photometry.Background.estimate_background  —  Function estimate_background(data;\n    location=SourceExtractorBackground(),\n    rms=StdRMS(),\n    dims=:) Perform scalar background estimation using the given estimators. The value returned will be two values corresponding to the estimated background and the estimated background RMS. The dimensionality will depend on the  dims  keyword. location  and  rms  can be anything that is callable, for example  median , or one of the estimators we provide in  Background Estimators . Examples julia> data = ones(3, 5);\n\njulia> bkg, bkg_rms = estimate_background(data)\n(1.0, 0.0)\n\njulia> using Statistics: median\n\njulia> bkg, bkg_rms = estimate_background(data; location=median, rms=MADStdRMS())\n(1.0, 0.0) See Also Location Estimators ,  RMS Estimators source estimate_background(data, box_size;\n    location=SourceExtractorBackground(),\n    rms=StdRMS(),\n    itp=ZoomInterpolator(box_size),\n    edge_method=:pad,\n    [filter_size]) Perform 2D background estimation using the given estimators mapped over windows of the data. This function will estimate backgrounds in boxes of size  box_size . When  size(data)  is not an integer multiple of the box size, there are two edge methods:  :pad  and  :crop . The default is to pad (and is recommend to avoid losing image data). If  box_size  is an integer, the implicit shape will be square (eg.  box_size=4  is equivalent to  box_size=(4,4) ). For evaluating the meshes, each box will be passed into  location  to estimate the background and then into  rms  to estimate the background root-mean-square value. These can be anything that is callable, like  median  or one of our  Background Estimators . Once the meshes are created they will be median filtered if  filter_size  is given.  filter_size  can be either an integer or a tuple, with the integer being converted to a tuple the same way  box_size  is. Filtering is done via  ImageFiltering.MapWindow.mapwindow .  filter_size  must be odd. After filtering (if applicable), the meshes are passed to the  itp  to recreate a low-order estimate of the background at the same resolution as the input. Note If your  box_size  is not an integer multiple of the input size, the output background and rms arrays will not have the same size. See Also Location Estimators ,  RMS Estimators ,  Interpolators source"},{"id":1832,"pagetitle":"Getting Started","title":"Photometry.Background.sigma_clip","ref":"/previews/PR43/Photometry/stable/background/#Photometry.Background.sigma_clip","content":" Photometry.Background.sigma_clip  —  Function sigma_clip(x, sigma; fill=:clamp, center=median(x), std=std(x, corrected=false))\nsigma_clip(x, sigma_low, sigma_high; fill=:clamp, center=median(x), std=std(x, corrected=false)) This function returns sigma-clipped values of the input  x . Specify the upper and lower bounds with  sigma_low  and  sigma_high , otherwise assume they are equal.  center  and  std  are optional keyword arguments which are functions for finding central element and standard deviation. If  fill === :clamp , this will clamp values in  x  lower than  center - sigma_low * std  and values higher than  center + sigma_high * std . Otherwise, they will be replaced with  fill . Examples julia> x = randn(100_000);\n\njulia> extrema(x)\n(-4.496308951466683, 4.080724496910187)\n\njulia> x_clip = sigma_clip(x, 1);\n\njulia> extrema(x_clip) # should be close to (-1, 1)\n(-1.0042721545326967, 0.9957463910682249) source"},{"id":1833,"pagetitle":"Getting Started","title":"Photometry.Background.sigma_clip!","ref":"/previews/PR43/Photometry/stable/background/#Photometry.Background.sigma_clip!","content":" Photometry.Background.sigma_clip!  —  Function sigma_clip!(x, sigma; fill=:clamp, center=median(x), std=std(x))\nsigma_clip!(x, sigma_low, sigma_high; fill=:clamp, center=median(x), std=std(x)) In-place version of  sigma_clip Warning sigma_clip!  mutates the element in place and mutation cannot lead to change in type. Please be considerate of your input type, because if you are using  Int64  and we try to clip it to  0.5  an  InexactError  will be thrown. To avoid this, we recommend converting to float before clipping, or using  sigma_clip  which does this internally. source"},{"id":1834,"pagetitle":"Getting Started","title":"Photometry.Background.validate_SE","ref":"/previews/PR43/Photometry/stable/background/#Photometry.Background.validate_SE","content":" Photometry.Background.validate_SE  —  Function Utility function for SourceExtractorBackground algorithm source"},{"id":1837,"pagetitle":"Background Estimators","title":"Background Estimators","ref":"/previews/PR43/Photometry/stable/background/estimators/#Background-Estimators","content":" Background Estimators All of these estimators are subtypes of  Background.LocationEstimator  or  Background.RMSEstimator  and are derived using various statistical and image processing methods."},{"id":1838,"pagetitle":"Background Estimators","title":"Location Estimators","ref":"/previews/PR43/Photometry/stable/background/estimators/#Location-Estimators","content":" Location Estimators These estimators are used for estimating the background using some form of a central statistic."},{"id":1839,"pagetitle":"Background Estimators","title":"Photometry.Background.LocationEstimator","ref":"/previews/PR43/Photometry/stable/background/estimators/#Photometry.Background.LocationEstimator","content":" Photometry.Background.LocationEstimator  —  Type Background.LocationEstimator This abstract type embodies the possible background estimation algorithms for dispatch with  estimate_background . To implement a new estimator, you must define the struct and define a method like  (::MyEstimator)(data::AbstractArray; dims=:) . See Also Location Estimators source"},{"id":1840,"pagetitle":"Background Estimators","title":"Photometry.Background.MMMBackground","ref":"/previews/PR43/Photometry/stable/background/estimators/#Photometry.Background.MMMBackground","content":" Photometry.Background.MMMBackground  —  Type MMMBackground(median_factor=3, mean_factor=2) Estimate the background using a mode estimator of the form  median_factor * median - mean_factor * mean . This algorithm is based on the  MMMBackground  routine originally implemented in DAOPHOT.  MMMBackground  uses factors of  median_factor=3  and  mean_factor=2  by default. This estimator assumes that contaminated sky pixel values overwhelmingly display positive departures from the true value. Examples julia> x = ones(3, 5);\n\njulia> MMMBackground()(x)\n1.0\n\njulia> MMMBackground(median_factor=4, mean_factor=3)(x, dims = 1)\n1×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0 See Also SourceExtractorBackground source"},{"id":1841,"pagetitle":"Background Estimators","title":"Photometry.Background.SourceExtractorBackground","ref":"/previews/PR43/Photometry/stable/background/estimators/#Photometry.Background.SourceExtractorBackground","content":" Photometry.Background.SourceExtractorBackground  —  Type SourceExtractorBackground() This estimator returns the background of the input using the SourceExtractorBackground algorithm. The background is calculated using a mode estimator of the form  (2.5 * median) - (1.5 * mean) . If  (mean - median) / std > 0.3  then the median is used and if  std = 0  then the mean is used. Examples julia> data = ones(3, 5);\n\njulia> SourceExtractorBackground()(data)\n1.0\n\njulia> SourceExtractorBackground()(data, dims=1)\n1×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0 source"},{"id":1842,"pagetitle":"Background Estimators","title":"Photometry.Background.BiweightLocationBackground","ref":"/previews/PR43/Photometry/stable/background/estimators/#Photometry.Background.BiweightLocationBackground","content":" Photometry.Background.BiweightLocationBackground  —  Type BiweightLocationBackground(c = 6.0, M = nothing) Estimate the background using the robust biweight location statistic. \\[ξ_{biloc} = M + \\frac{∑_{|uᵢ|<1}{(xᵢ - M)(1 - uᵢ²)²}}{∑_{|uᵢ|<1}{(1-uᵢ²)²}}\\] \\[u_i = \\frac{(x_i - M)}{c⋅\\mathrm{MAD}(x)}\\] Where  $\\mathrm{MAD}(x)$  is median absolute deviation of  x . Examples julia> x = ones(3,5);\n\njulia> BiweightLocationBackground()(x)\n1.0\n\njulia> BiweightLocationBackground(c=5.5)(x; dims = 1)\n1×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0 source"},{"id":1843,"pagetitle":"Background Estimators","title":"RMS Estimators","ref":"/previews/PR43/Photometry/stable/background/estimators/#RMS-Estimators","content":" RMS Estimators These estimators are used for estimating the root-mean-square (RMS) of the background using some form of a deviation statistic."},{"id":1844,"pagetitle":"Background Estimators","title":"Photometry.Background.RMSEstimator","ref":"/previews/PR43/Photometry/stable/background/estimators/#Photometry.Background.RMSEstimator","content":" Photometry.Background.RMSEstimator  —  Type Background.RMSEstimator This abstract type embodies the possible background RMS estimation algorithms for dispatch with  estimate_background . To implement a new estimator, you must define the struct and define a method like  (::MyRMSEstimator)(data::AbstractArray; dims=:) . See Also RMS Estimators source"},{"id":1845,"pagetitle":"Background Estimators","title":"Photometry.Background.StdRMS","ref":"/previews/PR43/Photometry/stable/background/estimators/#Photometry.Background.StdRMS","content":" Photometry.Background.StdRMS  —  Type StdRMS() Uses the standard deviation statistic for background RMS estimation. Examples julia> data = ones(3, 5);\n\njulia> StdRMS()(data)\n0.0\n\njulia> StdRMS()(data, dims=1)\n1×5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0 source"},{"id":1846,"pagetitle":"Background Estimators","title":"Photometry.Background.MADStdRMS","ref":"/previews/PR43/Photometry/stable/background/estimators/#Photometry.Background.MADStdRMS","content":" Photometry.Background.MADStdRMS  —  Type MADStdRMS() Uses the standard median absolute deviation (MAD) statistic for background RMS estimation. This is typically given as $σ ≈ 1.4826 ⋅ \\mathrm{MAD}$ Examples julia> data = ones(3, 5);\n\njulia> MADStdRMS()(data)\n0.0\n\njulia> MADStdRMS()(data, dims=1)\n1×5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0 source"},{"id":1847,"pagetitle":"Background Estimators","title":"Photometry.Background.BiweightScaleRMS","ref":"/previews/PR43/Photometry/stable/background/estimators/#Photometry.Background.BiweightScaleRMS","content":" Photometry.Background.BiweightScaleRMS  —  Type BiweightScaleRMS(c=9.0, M=nothing) Uses the robust biweight scale statistic for background RMS estimation. The biweight scale is the square root of the biweight midvariance. The biweight midvariance uses a tuning constant,  c , and an optional initial guess of the central value  M . \\[ζ²_{biscl} = \\frac{n ∑_{|uᵢ|<1}{(xᵢ - M)²(1 - uᵢ²)⁴}}{\\left[∑_{|uᵢ|<1}{(1-uᵢ²)(1-5uᵢ²)}\\right]²}\\] \\[uᵢ = \\frac{(xᵢ - M)}{c⋅\\mathrm{MAD}(x)}\\] Where  $\\mathrm{MAD}(x)$  is median absolute deviation of  x . Examples julia> data = ones(3, 5);\n\njulia> BiweightScaleRMS()(data)\n0.0\n\njulia> BiweightScaleRMS(c=3.0)(data, dims=1)\n1×5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0 source"},{"id":1850,"pagetitle":"Background Interpolators","title":"Background Interpolators","ref":"/previews/PR43/Photometry/stable/background/interpolators/#Background-Interpolators","content":" Background Interpolators Background interpolators provide a method for converting a low-resolution mesh into a low-order high-resolution image."},{"id":1851,"pagetitle":"Background Interpolators","title":"Photometry.Background.BackgroundInterpolator","ref":"/previews/PR43/Photometry/stable/background/interpolators/#Photometry.Background.BackgroundInterpolator","content":" Photometry.Background.BackgroundInterpolator  —  Type Background.BackgroundInterpolator This abstract type embodies the different ways of converting a low-resolution mesh into a high-resolution image, especially for dispatch with  estimate_background To implement a new interpolation scheme, you must define the struct and define a method like  (::MyInterpolator)(mesh) See Also Interpolators source"},{"id":1852,"pagetitle":"Background Interpolators","title":"Interpolators","ref":"/previews/PR43/Photometry/stable/background/interpolators/#Interpolators","content":" Interpolators"},{"id":1853,"pagetitle":"Background Interpolators","title":"Photometry.Background.ZoomInterpolator","ref":"/previews/PR43/Photometry/stable/background/interpolators/#Photometry.Background.ZoomInterpolator","content":" Photometry.Background.ZoomInterpolator  —  Type ZoomInterpolator(factors) Use a cubic-spline interpolation scheme to increase resolution of a mesh. factors  represents the level of \"zoom\", so an input mesh of size  (10, 10)  with factors  (2, 2)  will have an output size of  (20, 20) . If only an integer is provided, it will be used as the factor for every axis. Examples julia> ZoomInterpolator(2)([1 0; 0 1])\n4×4 Matrix{Float64}:\n  1.0          0.75   0.25   -2.77556e-17\n  0.75         0.625  0.375   0.25\n  0.25         0.375  0.625   0.75\n -5.55112e-17  0.25   0.75    1.0\n\njulia> ZoomInterpolator(3, 1)([1 0; 0 1])\n6×2 Matrix{Float64}:\n  1.0          -2.77556e-17\n  1.0          -2.77556e-17\n  0.666667      0.333333\n  0.333333      0.666667\n -5.55112e-17   1.0\n -5.55112e-17   1.0\n source"},{"id":1854,"pagetitle":"Background Interpolators","title":"Photometry.Background.IDWInterpolator","ref":"/previews/PR43/Photometry/stable/background/interpolators/#Photometry.Background.IDWInterpolator","content":" Photometry.Background.IDWInterpolator  —  Type IDWInterpolator(factors; leafsize=10, k=8, power=1, reg=0, conf_dist=1e-12) Use Shepard Inverse Distance Weighing interpolation scheme to increase resolution of a mesh. factors  represents the level of \"zoom\", so an input mesh of size  (10, 10)  with factors  (2, 2)  will have an output size of  (20, 20) . If only an integer is provided, it will be used as the factor for every axis. The interpolator can be called with some additional parameters: leaf_size  determines at what number of points to stop splitting the tree further, k  which is the number of nearest neighbors to be considered, power  is the exponent for distance in the weighing factor, reg  is the offset for the weighing factor in denominator, conf_dist  is the distance below which two points would be considered as the same point. Examples julia> IDWInterpolator(2, k=2)([1 0; 0 1])\n4×4 Matrix{Float64}:\n 1.0   0.75      0.25      0.0\n 0.75  0.690983  0.309017  0.25\n 0.25  0.309017  0.690983  0.75\n 0.0   0.25      0.75      1.0\n\njulia> IDWInterpolator(3, 1; k=2, power=4)([1 0; 0 1])\n6×2 Matrix{Float64}:\n 1.0        0.0\n 1.0        0.0\n 0.941176   0.0588235\n 0.0588235  0.941176\n 0.0        1.0\n 0.0        1.0 source"},{"id":1857,"pagetitle":"Getting Started","title":"Source Detection","ref":"/previews/PR43/Photometry/stable/detection/#Source-Detection","content":" Source Detection The module provides tools and algorithms for detecting and extracting point-like sources."},{"id":1858,"pagetitle":"Getting Started","title":"API/Reference","ref":"/previews/PR43/Photometry/stable/detection/#API/Reference","content":" API/Reference"},{"id":1859,"pagetitle":"Getting Started","title":"Photometry.Detection.extract_sources","ref":"/previews/PR43/Photometry/stable/detection/#Photometry.Detection.extract_sources","content":" Photometry.Detection.extract_sources  —  Function extract_sources(::SourceFinder, data, [error]; sorted=true) Uses  method  to find and extract point-like sources. Returns a  TypedTables.Table  with positions and information related to the  method . For instance, using  PeakMesh  returns a table a column for the peak values. data  is assumed to be background-subtracted. If  error  is provided it will be propagated into the detection algorithm. If  sorted  is  true  the sources will be sorted by their amplitude. See Also Source Detection Algorithms source"},{"id":1862,"pagetitle":"Algorithms","title":"Source Detection Algorithms","ref":"/previews/PR43/Photometry/stable/detection/algs/#Source-Detection-Algorithms","content":" Source Detection Algorithms"},{"id":1863,"pagetitle":"Algorithms","title":"Photometry.Detection.SourceFinder","ref":"/previews/PR43/Photometry/stable/detection/algs/#Photometry.Detection.SourceFinder","content":" Photometry.Detection.SourceFinder  —  Type Detection.SourceFinder Abstract super type for source detection algorithms used with  extract_sources . source"},{"id":1864,"pagetitle":"Algorithms","title":"API/Reference","ref":"/previews/PR43/Photometry/stable/detection/algs/#API/Reference","content":" API/Reference"},{"id":1865,"pagetitle":"Algorithms","title":"Photometry.Detection.PeakMesh","ref":"/previews/PR43/Photometry/stable/detection/algs/#Photometry.Detection.PeakMesh","content":" Photometry.Detection.PeakMesh  —  Type PeakMesh(box_size=(3, 3), nsigma=3.0) Detect sources by finding peaks above a threshold in grids across the image. This creates a pixel-wise threshold for sources by calculating  error * nsigma  when used with  extract_sources . The peaks are found by searching the image in boxes of size  box_size . If the maximum value in that box is greater than the threshold set above, the point is extracted. source"},{"id":1868,"pagetitle":"Home","title":"Transits.jl","ref":"/previews/PR43/Transits/stable/#Transits.jl","content":" Transits.jl Transits.jl provides flexible and powerful occultation curves with limb darkening. The goals of this package are, in this order have a simple interface with high  composability be flexible with respect to numeric types and application be fully compatible with  ChainRules.jl  automatic differentiation (AD) system to leverage the derived analytical gradients provide a codebase that is well-organized, instructive, and easy to extend maintain high performance: at least as fast as similar tools In particular,  PolynomialLimbDark  implements the \"starry\" limb darkening method, which solves the flux integral analytically. This provides floating-point errors and runtimes that are best in class."},{"id":1869,"pagetitle":"Home","title":"Installation","ref":"/previews/PR43/Transits/stable/#Installation","content":" Installation To install use  Pkg . From the REPL, press  ]  to enter Pkg-mode pkg> add Transits If you want to use the most up-to-date version of the code, check it out from  main pkg> add Transits#main"},{"id":1870,"pagetitle":"Home","title":"Citations","ref":"/previews/PR43/Transits/stable/#Citations","content":" Citations If you use Transits.jl or a derivative of it in your work please consider citing it at the  Zenodo DOI . If you use  PolynomialLimbDark  or  QuadLimbDark  please also cite  Agol et al. (2020)  and  Luger et al. (2019) . If you use  Kipping13  please cite  Kipping (2013) . BibTeX for all those citations can be found in  CITATIONS.bib ."},{"id":1873,"pagetitle":"API/Reference","title":"API/Reference","ref":"/previews/PR43/Transits/stable/api/#API/Reference","content":" API/Reference"},{"id":1874,"pagetitle":"API/Reference","title":"Index","ref":"/previews/PR43/Transits/stable/api/#Index","content":" Index Transits.AbstractLimbDark Transits.AbstractLimbDark Transits.IntegratedLimbDark Transits.Kipping13 Transits.PolynomialLimbDark Transits.QuadLimbDark Transits.SecondaryLimbDark Transits.compute Transits.compute"},{"id":1875,"pagetitle":"API/Reference","title":"Light Curves","ref":"/previews/PR43/Transits/stable/api/#Light-Curves","content":" Light Curves"},{"id":1876,"pagetitle":"API/Reference","title":"Transits.AbstractLimbDark","ref":"/previews/PR43/Transits/stable/api/#Transits.AbstractLimbDark","content":" Transits.AbstractLimbDark  —  Type AbstractLimbDark A limb dark law need only need to implement  compute(::Law, b, r)  to extend the limb darkening interface. See also compute source"},{"id":1877,"pagetitle":"API/Reference","title":"Transits.AbstractLimbDark","ref":"/previews/PR43/Transits/stable/api/#Transits.AbstractLimbDark-Tuple","content":" Transits.AbstractLimbDark  —  Method (::AbstractLimbDark)(b, r) An alias for calling  compute Examples julia> ld = PolynomialLimbDark([0.4, 0.26]);\n\njulia> ld(0, 0.01)\n0.9998785437247428 source"},{"id":1878,"pagetitle":"API/Reference","title":"Transits.PolynomialLimbDark","ref":"/previews/PR43/Transits/stable/api/#Transits.PolynomialLimbDark","content":" Transits.PolynomialLimbDark  —  Type PolynomialLimbDark(u::AbstractVector) Polynomial limb darkening using analytical integrals. The length of the  u  vector is equivalent to the order of polynomial used; e.g.,  [0.2, 0.3]  corresponds to quadratic limb darkening. Mathematical form \\[I(\\mu) \\propto 1 - u_1(1-\\mu) - u_2(1-\\mu)^2 - \\dots - u_N(1-\\mu)^N\\] which is equivalent to the series \\[I(\\mu) \\propto -\\sum_{i=0}^N{u_i(1-\\mu)^i}\\] with the definition  $u_0 \\equiv -1$ . Examples u = [0.4, 0.26] # quadratic and below is 100% analytical\nld = PolynomialLimbDark(u)\nld(0.1, 0.01)\n\n# output\n0.9998787880717668 u2 = vcat(u, ones(12) ./ 12)\nld2 = PolynomialLimbDark(u2)\nld2(0.1, 0.01)\n\n# output\n0.9998740059086433 References Agol, Luger, Foreman-Mackey (2020) \"Analytic Planetary Transit Light Curves and Derivatives for Stars with Polynomial Limb Darkening\" Luger et al. (2019) \"starry: Analytic Occultation Light Curves\" source"},{"id":1879,"pagetitle":"API/Reference","title":"Transits.QuadLimbDark","ref":"/previews/PR43/Transits/stable/api/#Transits.QuadLimbDark","content":" Transits.QuadLimbDark  —  Type QuadLimbDark(u::AbstractVector) A specialized implementation of  PolynomialLimbDark  with a maximum of two terms (quadratic form). This has a completely closed-form solution without any numerical integration. This means there are no intermediate allocations and reduced numerical error. Mathematical form \\[I(\\mu) \\propto 1 - u_1(1-\\mu) - u_2(1-\\mu)^2\\] Higher-order terms Higher-order terms will be  ignored ; no error will be thrown Examples ld = QuadLimbDark(Float64[]) # constant term only\n\nb = [0, 1, 2] # impact parameter\nr = 0.01 # radius ratio\nld.(b, r)\n\n# output\n3-element Vector{Float64}:\n 0.9999\n 0.9999501061035608\n 1.0 ld = QuadLimbDark([0.4, 0.26]) # max two terms\nld.(b, r)\n\n# output\n3-element Vector{Float64}:\n 0.9998785437247428\n 0.999974726693709\n 1.0 References See references for  PolynomialLimbDark source"},{"id":1880,"pagetitle":"API/Reference","title":"Transits.IntegratedLimbDark","ref":"/previews/PR43/Transits/stable/api/#Transits.IntegratedLimbDark","content":" Transits.IntegratedLimbDark  —  Type IntegratedLimbDark(limbdark; N=21, basis=:legendre)\nIntegratedLimbDark(u; kwargs...) Computes the time-averaged flux in the middle of an exposure by wrapping a limb darkening law  limbdark  with a quadrature scheme. For each time step  t ,  N  extra points are  super-sampled  from  t-texp/2  to  t+texp/2 and the time-averaged flux is calculated via quadrature. If a set of limb darkening coefficients,  u , is provided, a  PolynomialLimbDark  law will be used by default. Mathematical form \\[\\bar{F}(t) = \\frac{1}{\\Delta t}\\int_{t-\\Delta t / 2}^{t+\\Delta t / 2}{F(t')dt'}\\] where  $F$  is the wrapped limb darkening law and  $\\Delta t$  is the exposure time. Quadrature The integration is approximated via  Guassian quadrature \\[\\frac{1}{\\Delta t} \\int{F(t')dt'} \\approx \\frac12\\sum_i^N{w_i * F(\\frac{\\Delta t}{2}\\xi_i + t)}\\] where the weights  w_i  and nodes  ξ_i  are defined by the given quadrature rule. The nodes are defined by evaluating orthogonal polynomials  N  times between -1 and 1. Notice the change of interval required to go from the natural bounds of the orthogonal polynomial basis,  -1, 1 , to the range defined by the exposure time. The following bases are available from  FastGaussQuadrature.jl . In addition, a function can be passed which calculates  nodes, weights = f(N) . :legendre  - Legendre polynomial base on the open  (-1, 1) :radau  - Legendre polynomial base on the semi-open  [-1, 1)  interval :lobatto  - Legendre polynomial base on the closed  [-1, 1]  interval source"},{"id":1881,"pagetitle":"API/Reference","title":"Transits.SecondaryLimbDark","ref":"/previews/PR43/Transits/stable/api/#Transits.SecondaryLimbDark","content":" Transits.SecondaryLimbDark  —  Type SecondaryLimbDark(primary::AbstractLimbDark,\n                  secondary::AbstractLimbDark; \n                  brightness_ratio=1)\nSecondaryLimbDark(u_p::AbstractVector, u_s=u_p; kwargs...) Compose two limb darkening laws together to add a secondary eclipse. If vectors of coefficients are provided, laws will automatically be constructed using  PolynomialLimbDark . The surface brightness ratio is given in terms of the host; e.g., if the companion is half as bright as the host, the ratio would be 0.5. Interface SecondaryLimbDark  only works with an orbit, since the companion's reference frame needs to be calculated. This means you can't call it using an impact parameter like  ld(b, r)  directly. Mathematical form \\[f(t, r) = \\frac{2f_p(t, r) + \\eta r^2 f_s(t', r')}{1 + f_p(t, r) + \\eta r^2 f_s(t', r')}\\] where  $f_p$  is to the primary flux,  $f_s$  is to the secondary flux, and  $\\eta$  is the surface brightness ratio.  $t'$  and  $r'$  correspond to the time and radius ratio from the companion's reference frame. Examples using Orbits\n# equal size and limb darkening\nr = 1.0\nu = [0.4, 0.26]\n# companion is 1/10 as bright\nbrightness_ratio = 0.1\nld = SecondaryLimbDark(u; brightness_ratio)\norbit = SimpleOrbit(period=2, duration=0.5)\nfp = ld(orbit, 0, r) # primary egress\nfs = ld(orbit, 1, r) # secondary egress\n\nfp ≈ brightness_ratio * fs\n\n# output\ntrue source"},{"id":1882,"pagetitle":"API/Reference","title":"Transits.compute","ref":"/previews/PR43/Transits/stable/api/#Transits.compute","content":" Transits.compute  —  Function compute(::AbstractLimbDark, b, r; kwargs...) Compute the relative flux for the given impact parameter  b  and radius ratio  r . The impact parameter is unitless. The radius ratio is given in terms of the host; e.g., if the companion is half the size of the host, r=0.5. source"},{"id":1883,"pagetitle":"API/Reference","title":"Transits.compute","ref":"/previews/PR43/Transits/stable/api/#Transits.compute-Tuple{AbstractLimbDark, Orbits.AbstractOrbit, Any, Any}","content":" Transits.compute  —  Method compute(::AbstractLimbDark, orbit::AbstractOrbit, t, r) Compute the relative flux by calculating the impact parameter at time  t  from the given orbit. The time needs to be compatible with the period of the orbit, nominally in days. Examples julia> using Orbits\n\njulia> ld = PolynomialLimbDark([0.4, 0.26]);\n\njulia> orbit = SimpleOrbit(period=3, duration=1);\n\njulia> ld(orbit, 0, 0.1) # primary egress\n0.9878664434953113\n\njulia> ld(orbit, 0.1, 0.1) # 0.1 d\n0.9879670695533511 this works effortlessly with libraries like  Unitful.jl julia> using Unitful\n\njulia> orbit = SimpleOrbit(period=3u\"d\", duration=3u\"hr\");\n\njulia> ld(orbit, 0u\"d\", 0.1)\n0.9878664434953113 source"},{"id":1884,"pagetitle":"API/Reference","title":"Gradients","ref":"/previews/PR43/Transits/stable/api/#Gradients","content":" Gradients Gradients and jacobians are integrated directly into  ChainRules.jl  via  frule s and  rrule s.  For most users, this just means using AD libraries like  ForwardDiff.jl  and  Zygote.jl  is effortless and fast . using Transits\nusing Zygote\n\nlightcurve(X) = compute(PolynomialLimbDark(X[3:end]), X[1], X[2])\ngrad(X) = lightcurve'(X) # Zygote gradient\ngrad([0.1, 0.1, 0.4, 0.26])\n\n# output\n4-element Vector{Float64}:\n  0.0004972185834858653\n -0.2419262730830416\n -0.0048107583897073185\n -0.0024501564976671724 To help demonstrate the logic behind these chain rules, here we derive a simple gradient function manually. using ChainRulesCore\n\nu_n = [0.4, 0.26]\nμ = 0.1\nror = 0.1\nX0 = [μ, ror, u_n...]\n\nfunction gradr(X)\n    ld, ld_pullback = rrule(PolynomialLimbDark, X[3:end])\n    f, f_pullback = rrule(compute, ld, X[1], X[2])\n\n    f̄ = one(eltype(X))\n    _, l̄d, b̄, r̄ = f_pullback(f̄)\n    _, ū_n = ld_pullback(l̄d)\n    return [b̄, r̄, ū_n...]\nend\n\ngradr([0.1, 0.1, 0.4, 0.26])\n\n# output\n4-element Vector{Float64}:\n  0.0004972185834858653\n -0.2419262730830416\n -0.0048107583897073185\n -0.0024501564976671724 For the most granular support for gradients and jacobians, peer into the depths of  polynomial/poly-grad.jl  and  polynomial/quad-grad.jl . These functions are not part of the public API and are not guaranteed any stability according to  semantic versioning ."},{"id":1885,"pagetitle":"API/Reference","title":"Distributions","ref":"/previews/PR43/Transits/stable/api/#Distributions","content":" Distributions"},{"id":1886,"pagetitle":"API/Reference","title":"Transits.Kipping13","ref":"/previews/PR43/Transits/stable/api/#Transits.Kipping13","content":" Transits.Kipping13  —  Type Kipping13() A non-informative prior for two-parameter limb-darkening coefficients using  triangular sampling  ( Kipping 2013 ). Examples julia> using StableRNGs; rng = StableRNG(10);\n\njulia> rand(rng, Kipping13())\n2-element Vector{Float64}:\n  0.3361047299132651\n -0.025681638815114587\n\njulia> rand(rng, Kipping13(), 5)\n2×5 Matrix{Float64}:\n 0.0621057   0.992689   1.77965    0.784055  0.186386\n 0.0659477  -0.236613  -0.795884  -0.187791  0.592194 References Kipping (2013) \"Efficient, uninformative sampling of limb darkening coefficients for two-parameter laws\" source"},{"id":1889,"pagetitle":"Benchmarks","title":"Benchmarks","ref":"/previews/PR43/Transits/stable/bench/#Benchmarks","content":" Benchmarks Transits.jl aims to be at least as fast as similar tools.  Limbdark.jl  is also written in Julia and  Agol et al. (2020)  showed it outperforms starry, PyTransit, and batman in both runtime speed and numerical accuracy. The following benchmarks are works in progress, but they already show a marginal improvement on the Limbdark.jl implementation."},{"id":1890,"pagetitle":"Benchmarks","title":"Setup","ref":"/previews/PR43/Transits/stable/bench/#Setup","content":" Setup Warning These benchmarks are works in progress The code can be found in  bench/ . You'll need to set up the environment yourself, including the installation of Limbdark.jl."},{"id":1891,"pagetitle":"Benchmarks","title":"Performance","ref":"/previews/PR43/Transits/stable/bench/#Performance","content":" Performance"},{"id":1892,"pagetitle":"Benchmarks","title":"Comparison with Limbdark.jl","ref":"/previews/PR43/Transits/stable/bench/#Comparison-with-Limbdark.jl","content":" Comparison with Limbdark.jl"},{"id":1895,"pagetitle":"Getting Started","title":"Getting Started","ref":"/previews/PR43/Transits/stable/gettingstarted/#Getting-Started","content":" Getting Started"},{"id":1896,"pagetitle":"Getting Started","title":"Usage","ref":"/previews/PR43/Transits/stable/gettingstarted/#Usage","content":" Usage using Orbits\nusing Transits\n\norbit = SimpleOrbit(period=3, duration=1)\nu = [0.4, 0.26] # quad limb dark\nld = PolynomialLimbDark(u)\n\nt = range(-1, 1, length=1000) # days from t0\nrs = range(0, 0.2, length=10) # radius ratio\n\nfluxes = @. ld(orbit, t, rs')"},{"id":1897,"pagetitle":"Getting Started","title":"Integrated and Secondary Curves","ref":"/previews/PR43/Transits/stable/gettingstarted/#Integrated-and-Secondary-Curves","content":" Integrated and Secondary Curves IntegratedLimbDark  can be used to numerically integrate each light curve exposure in time ld = IntegratedLimbDark([0.4, 0.26])\norbit = SimpleOrbit(period=3, duration=1)\nt = range(-1, 1, length=1000)\ntexp = [0.1 0.2 0.3]\n# no extra calculations made\nflux = @. ld(orbit, t, 0.2)\n# use quadrature to find time-averaged flux for each t\nflux_int = @. ld(orbit, t, 0.2, texp)  SecondaryLimbDark  can be used to generate secondary eclipses given a surface brightness ratio ld = SecondaryLimbDark([0.4, 0.26], brightness_ratio=0.1)\nld_int = IntegratedLimbDark(ld) # composition works flawlessly\n\norbit = SimpleOrbit(period=4, duration=1)\nt = range(-1.25, 2.75, length=1000)\nrs = range(0.01, 0.1, length=6)\n\nf = @. ld(orbit, t, rs')\nf_int = @. ld_int(orbit, t, rs', texp=0.3)"},{"id":1898,"pagetitle":"Getting Started","title":"Using Units","ref":"/previews/PR43/Transits/stable/gettingstarted/#Using-Units","content":" Using Units Units from  Unitful.jl  are a drop-in substitution for numbers using Unitful\norbit = SimpleOrbit(period=10u\"d\", duration=5u\"hr\")\nt = range(-6, 6, length=1000)u\"hr\"\nflux = @. ld(orbit, t, 0.1)"},{"id":1899,"pagetitle":"Getting Started","title":"Gradients","ref":"/previews/PR43/Transits/stable/gettingstarted/#Gradients","content":" Gradients Gradients are provided in the form of  chain rules . The easiest way to access them is using an automatic differentiation (AD) library like  ForwardDiff.jl  or  Zygote.jl . using Zygote\n\nts = range(-1, 1, length=1000) # days from t0\nror = 0.1\nu_n = [0.4, 0.26]\n\norbit = SimpleOrbit(period=3, duration=1)\nlightcurve(X) = compute(PolynomialLimbDark(X[3:end]), orbit, X[1], X[2])\n\n# use Zygote for gradient\nflux = [lightcurve([t, ror, u_n...]) for t in ts]\ngrads = mapreduce(hcat, ts) do t\n    grad = lightcurve'([t, ror, u_n...])\n    return grad === nothing ? zeros(4) : grad\nend"},{"id":1902,"pagetitle":"Introduction","title":"Introduction","ref":"/previews/PR43/Transits/stable/introduction/#Introduction","content":" Introduction"},{"id":1903,"pagetitle":"Introduction","title":"Historical overview","ref":"/previews/PR43/Transits/stable/introduction/#Historical-overview","content":" Historical overview Transit light curves are an essential tool used for the detection of  exoplanets . To date, there have been over 4,300 confirmed planets discovered in over 3,400 different star systems, with an additional 2,400 candidates currently awaiting follow-up analysis and validation [1] . Since the first confirmed discovery of an exoplanet – as part of a multi-planetary system in 1992 [2] , and the first exoplanet discovered around a Sun-like star shortly after in 1995 [3]  – there has been an explosion in new discoveries, thanks in large part to the successful  Kepler/K2  and  TESS  space missions. The large majority of these planets have been detected via the  transit method : Exoplanet Archive"},{"id":1904,"pagetitle":"Introduction","title":"Transit method","ref":"/previews/PR43/Transits/stable/introduction/#Transit-method","content":" Transit method This method works by observing the dimming in apparent brightness of a star as a planet passes in front of it from our point of view. The plot of the star's brightness as a function of time defines the  white light curve  as seen in the schematic below: \"How Do You Find an Exoplanet?\" by John Asher Johnson Even just starting with a simple single planet system in a circular orbit, there is already a wealth of information encoded in this diagram. These observations give us insight not only into the bulk properties of the planet, but into the architecture of its orbital system and characteristics of its host star as well. For example,  direct observables  from the light curve like the  transit duration $(T)$  and  ingress/egress  time  $(\\tau)$  give us information about how tilted its orbit is and how fast the planet is traveling, while the  transit depth $(\\delta)$  gives us a direct measure of the size of the planet relative to its star. For circular orbits, these are nicely summarized by: \\[\\begin{aligned}\n\\frac{R_\\text{p}}{R_*} &= \\delta^{1/2} \\\\\n\nb^2 &= 1 - \\delta^{1/2}\\frac{T}{t} \\\\\n\n\\frac{a}{R_*} &= \\frac{P\\delta^{1/4}}{2\\pi}\n\\left(\\frac{4}{T\\tau}\\right)^{1/2} \\\\\n\n\\rho_* &= \\frac{3P}{G\\pi^2}\\left(\\frac{\\delta^{1/4}}{\\sqrt{T\\tau}}\\right)^3 \\quad,\n\\end{aligned}\\] where  $P$  is the period of the planet's orbit and  $a$  its semi-major axis,  $b$  is the impact parameter,  $R_*$  is the radius of its star, and  $\\rho_*$  is the stellar density."},{"id":1905,"pagetitle":"Introduction","title":"Limb darkening","ref":"/previews/PR43/Transits/stable/introduction/#Limb-darkening","content":" Limb darkening Not shown above is an added dimension that  Transits.jl  excels in,  limb darkening , demonstrated in the schematic below: ASTR 236 class notes This effect is intimately related to the shape of the light curve, and allows us to constrain the brightness profile of the star itself. As we will see next, the method of transit light curves is not just useful for the detection of exoplanets, but also for taking it to the next step of characterizing its atmosphere."},{"id":1906,"pagetitle":"Introduction","title":"Transmission spectroscopy","ref":"/previews/PR43/Transits/stable/introduction/#Transmission-spectroscopy","content":" Transmission spectroscopy If we perform the technique of transit light curve modeling on a wavelength-by-wavelength basis, we can further probe the properties of the host star and begin to make predictions about the properties of the planet's atmosphere, such as its chemical composition and whether clouds/hazes are likely to be present at higher altitudes. This analysis begins in the same way as with the white light curve seen above, only now a  wavelength binned light curve  is measured at a range of different wavelengths:  Adapted from Weaver et al. (2021,  submitted ) Plotting these wavelength dependent transit depths then builds a  transmission spectrum , which is filled with information about the planet's atmosphere and its star, summarized below: Benneke & Seager (2012) Rackham, Apai, & Giampapa (2018) Performing forward modeling (see, e.g.,  Kempton et al. 2016 ,  Goyal et al. 2017 ) and retrievals (see, e.g.,  Barstow et al. 2020  and references therein) using these frameworks then allows us to explore exoplanetary atmospheres in never before seen detail."},{"id":1907,"pagetitle":"Introduction","title":"Summary","ref":"/previews/PR43/Transits/stable/introduction/#Summary","content":" Summary The detection and characterization of exoplanets through their transit light curves is a relatively new technique in the field of astronomy, with recent advances only being made possible through novel uses of large, ground-based telescopes and soon in the future with planned  ELTs  and space based missions like  JWST . Studies using these observing facilities will require the fast and precise computation of transit light curves, which  Transits.jl  aims to provide. 1 https://exoplanetarchive.ipac.caltech.edu/ 2 https://ui.adsabs.harvard.edu/abs/1992Natur.355..145W/abstract 3 https://ui.adsabs.harvard.edu/abs/1995Natur.378..355M/abstract"}]