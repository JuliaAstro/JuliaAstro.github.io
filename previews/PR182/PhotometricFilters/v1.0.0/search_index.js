var documenterSearchIndex = {"docs":
[{"location":"#PhotometricFilters","page":"Home","title":"PhotometricFilters","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides access to, and operations on, photometric filter curves. Such filter curves are defined by a filter's transmission as a function of wavelength. Transmission and wavelength vectors are therefore the foundation of a filter curve, but it is also important to note whether the filter is used for photon counter or energy counter detectors, as the integrals used to calculate statistics over a filter curve are different between these two types of detectors.","category":"page"},{"location":"#Types","page":"Home","title":"Types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All photometric filter types should be subtypes of the AbstractFilter type. We define a minimal API that should be followed so that new types can make use of the generic filter operations we define.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The simplest concrete filter type we provide to represent photometric filters is PhotometricFilter.","category":"page"},{"location":"#PhotometricFilters.PhotometricFilter","page":"Home","title":"PhotometricFilters.PhotometricFilter","text":"PhotometricFilter(wavelength::AbstractVector, throughput::AbstractVector{T};\n                  detector::DetectorType=Photon(), filtername::Union{String, Nothing}=nothing) where T\n\nStruct representing a photometric filter, defined by vectors of wavelengths (wavelength) and filter throughputs (throughput). wavelength can have Unitful units attached, otherwise they are assumed to be Å. Optional keyword arguments define the detector type for which the filter is valid and a name to identify the filter.\n\njulia> using PhotometricFilters: PhotometricFilter, Photon, wavelength, throughput\n\njulia> using Unitful\n\njulia> f = PhotometricFilter(1000:2000, vcat(fill(0.25, 250), fill(0.5, 500), fill(0.25, 251))) # Specify only wavelength and throughput\n1001-element PhotometricFilter{Float64}: nothing\n reference wave.: 1478.1028279485677 Å\n min. wave.: 1000 Å\n max. wave.: 2000 Å\n effective wave.: 1602.7669435459648 Å\n mean wave.: 1499.8333333333333 Å\n central wave.: 1499.5 Å\n pivot wave.: 1478.1028279485677 Å\n eff. width: 750.0 Å\n fwhm: 501.0 Å\n\njulia> f == PhotometricFilter(uconvert.(Unitful.nm, wavelength(f)), throughput(f)) # Can also specify wavelength argument with Unitful units\ntrue\n\njulia> f[10] # Indexing into the filter as `f[i]` returns `(wavelength(f)[i], throughput(f)[i])`\n(1009 Å, 0.25)\n\njulia> f(1001.1) # Calling `f` like a function interpolates the throughput\n0.25\n\njulia> f(100.11 * Unitful.nm) # Can also specify wavelength with units\n0.25\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"The data contained in the struct can be accessed with the following methods:","category":"page"},{"location":"#PhotometricFilters.filtername","page":"Home","title":"PhotometricFilters.filtername","text":"filtername(f::AbstractFilter)\n\nReturns a string indicating a human-readable name for the filter (e.g., \"SDSS_u\").\n\njulia> using PhotometricFilters: SDSS_u, filtername\n\njulia> filtername(SDSS_u())\n\"SDSS_u\"\n\n\n\n\n\n","category":"function"},{"location":"#PhotometricFilters.wavelength","page":"Home","title":"PhotometricFilters.wavelength","text":"wavelength(f::AbstractFilter)\n\nReturns the wavelength vector of the filter transmission curve with proper Unitful.jl units.\n\njulia> using PhotometricFilters: SDSS_u, wavelength\n\njulia> using Unitful: Quantity\n\njulia> wavelength(SDSS_u()) isa Vector{<:Quantity}\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#PhotometricFilters.throughput","page":"Home","title":"PhotometricFilters.throughput","text":"throughput(f::AbstractFilter)\n\nReturns the throughput vector of the filter transmission curve (no units).\n\njulia> using PhotometricFilters: SDSS_u, throughput\n\njulia> throughput(SDSS_u()) isa Vector{<:Number}\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#PhotometricFilters.detector_type","page":"Home","title":"PhotometricFilters.detector_type","text":"detector_type(f::AbstractFilter)\n\nReturn an instance of PhotometricFilters.Energy if the filter is defined for energy-counting detectors or PhotometricFilters.Photon for photon-counting detectors.\n\njulia> using PhotometricFilters: SDSS_u, detector_type, Photon\n\njulia> detector_type(SDSS_u()) === Photon()\ntrue\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"Users can construct their own filter curvers from raw data using this type.","category":"page"},{"location":"#Accessing-Filter-Curves","page":"Home","title":"Accessing Filter Curves","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We provide a modest collection of filter curves through a data dependency. The available filter curves are accessible via the FILTER_NAMES module constant,","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PhotometricFilters\nPhotometricFilters.FILTER_NAMES |> println","category":"page"},{"location":"","page":"Home","title":"Home","text":"These included filter curves can be accessed like so,","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PhotometricFilters: SDSS_u, SDSS_g, SDSS_r, SDSS_i, SDSS_z, fwhm\nfilts = [SDSS_u(), SDSS_g(), SDSS_r(), SDSS_i(), SDSS_z()]","category":"page"},{"location":"","page":"Home","title":"Home","text":"NOTE THAT THESE INCLUDED FILTER CURVES ARE NOT GUARANTEED TO BE UP-TO-DATE. If you are using a filter/instrument that may have recently had its filter curves updated (e.g., JWST/NIRCAM), you should use our SVO query interface to make sure you get the most up-to-date filter curves. SVO also provides additional metadata that is useful for some applications (e.g., filter zeropoints). If you know the SVO-designated name of the filter you want, you can use get_filter to retrieve its transmission data, which returns an instance of SVOFilter.","category":"page"},{"location":"#PhotometricFilters.get_filter","page":"Home","title":"PhotometricFilters.get_filter","text":"get_filter(filtername::AbstractString, magsys::Symbol=:Vega)\n\nQuery the online SVO filter service for data on a photometric filter.\n\nArguments\n\nfiltername::AbstractString: The desired filter ID, in the correct SVO specification (e.g., \"2MASS/2MASS.J\").\nmagsys::Symbol: Desired magnitude system for associated metadata (e.g., \"ZeroPoint\"). Can be any of (:AB, :Vega, :ST). SVO uses Vega by default, so we mirror that choice here.\n\nReturns\n\nAn SVOFilter instance containing the results of the query.\n\nExamples\n\njulia> using PhotometricFilters: get_filter\n\njulia> filt = get_filter(\"2MASS/2MASS.J\", :Vega)\n107-element PhotometricFilters.SVOFilter{PhotometricFilter{Float64}}: 2MASS/2MASS.J\n reference wave.: 12350.0 Å\n min. wave.: 10806.470589792389 Å\n max. wave.: 14067.974683578484 Å\n effective wave.: 12284.994608629975 Å\n mean wave.: 12410.5170694321 Å\n central wave.: 12390.584132888223 Å\n pivot wave.: 12393.093155655275 Å\n eff. width: 1624.3245065600008 Å\n fwhm: 2149.1445403830403 Å\n\n\n\n\n\n","category":"function"},{"location":"#PhotometricFilters.SVOFilter","page":"Home","title":"PhotometricFilters.SVOFilter","text":"SVOFilter(filter::PhotometricFilter, metadata) <: AbstractFilter\n\nType for containing the photometric filter information returned by the SVO filter service. A result of this type is returned by get_filter. Contains two fields:\n\nfilter is a PhotometricFilter type that is used to support common operations.\nmetadata is a dictionary (currently an OrderedCollections.OrderedDict) that contains the metadata returned by SVO.\n\nThese fields are considered internal (subject to change) and users should interact with instances of this type via the public accessor methods instead. Example usage is below.\n\njulia> using PhotometricFilters: get_filter, SVOFilter, PhotometricFilter\n\njulia> filt = get_filter(\"2MASS/2MASS.J\", :Vega);\n\njulia> filt isa SVOFilter\ntrue\n\njulia> PhotometricFilter(filt) isa PhotometricFilter # Access simpler PhotometricFilter type\ntrue\n\njulia> Dict(filt) isa Dict # Retrieve full metadata dictionary\ntrue\n\njulia> filt[\"ZeroPoint\"] # Can retrieve metadata directly\n1594.0 Jy\n\njulia> filtername(filt) # `filtername`, `detector_type`, `wavelength`, `throughput` all work\n\"2MASS/2MASS.J\"\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"If you'd like to perform a search on the filters available through the SVO filter service, you can use query_filters.","category":"page"},{"location":"#PhotometricFilters.query_filters","page":"Home","title":"PhotometricFilters.query_filters","text":"query_filters(; queries...)\n\nQueries the filters available from the SVO filter service with search parameters and returns a table of the filters found.\n\nThe available search parameters can be found with PhotometricFilters.get_metadata. The following should be available in general:\n\nWavelengthRef: Tuple of Numbers\nWavelengthMean: Tuple of Numbers\nWavelengthEff: Tuple of Numbers\nWavelengthMin: Tuple of Numbers\nWavelengthMax: Tuple of Numbers\nWidthEff: Tuple of Numbers\nFWHM: Tuple of Numbers\nInstrument: String\nFacility: String\nPhotSystem: String\n\nThe returned table is a DataFrame from the DataFrames package with all the columns of the response VOTable.\n\nThe filter information and transmission data can be obtained by calling get_filter with the ID obtained from the filterID column.\n\nExamples\n\njulia> using PhotometricFilters: query_filters, SVOFilter\n\njulia> using DataFrames: DataFrame\n\njulia> df = query_filters(; Facility=\"SLOAN\", WavelengthEff=(1000, 5000));\n\njulia> df isa DataFrame\ntrue\n\njulia> id = df.filterID[3]\n\"SLOAN/SDSS.g\"\n\njulia> get_filter(id) isa SVOFilter\ntrue\n\n# Other examples for querying\nquery_filters(; Facility=\"SLOAN\") # all filters from a given facility\nquery_filters(; Instrument=\"BUSCA\", WavelengthEff=(1000u\"angstrom\", 5000u\"angstrom\")) # Unitful wavelengths\n\n\n\n\n\n","category":"function"},{"location":"#Interacting-with-the-Filter-Cache","page":"Home","title":"Interacting with the Filter Cache","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"After you first access a filter with get_filter, it is cached to disk for future use. It is expected that users should not typically have to manually interact with the cache. As such, the cache-related utilities discussed here are not exported from the package and must be explicitly imported (e.g., using PhotometricFilters: update_filters; update_filters()) or used via the qualified syntax (e.g., using PhotometricFilters; PhotometricFilters.update_filters()).","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can list the currently cached filters with PhotometricFilters.cached_filters. To update cached filters, ensuring you have the most up-to-date data, you can use PhotometricFilters.update_filter. You can delete filters from the cache with PhotometricFilters.clear_filter.","category":"page"},{"location":"#PhotometricFilters.cached_filters","page":"Home","title":"PhotometricFilters.cached_filters","text":"cached_filters()\n\nReturns a Vector{Tuple{String, Symbol}} containing the filter identifier and magnitude system for each SVO filter in the cache.\n\njulia> using PhotometricFilters: cached_filters, get_filter\n\njulia> get_filter(\"2MASS/2MASS.J\", :Vega); # Load SVO filter, will be cached if not already\n\njulia> (\"2MASS/2MASS.J\", :Vega) in cached_filters() # Check that filter is in the cache\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#PhotometricFilters.update_filter","page":"Home","title":"PhotometricFilters.update_filter","text":"update_filter(f::AbstractString, magsys::Symbol)\n\nReacquires filter with SVO identifier f in the magnitude system magsys from SVO and saves it into the cache. Returns the updated filter.\n\njulia> using PhotometricFilters: cached_filters, update_filter, SVOFilter\n\njulia> get_filter(\"2MASS/2MASS.J\", :Vega); # Load SVO filter, will be cached if not already\n\njulia> update_filter(\"2MASS/2MASS.J\", :Vega) isa SVOFilter # Updates cached file, returns filter\ntrue\n\n\n\n\n\nupdate_filter()\n\nWhen called with no arguments, updates all filters in the cache. Returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"#PhotometricFilters.clear_filter","page":"Home","title":"PhotometricFilters.clear_filter","text":"clear_filter(f::AbstractString, magsys::Symbol)\n\nDeletes filter f in magnitude system magsys from the cache.\n\njulia> using PhotometricFilters: get_filter, clear_filter, cached_filters\n\njulia> get_filter(\"2MASS/2MASS.J\", :Vega); # Ensure filter in cache\n\njulia> clear_filter(\"2MASS/2MASS.J\", :Vega) # Remove filter from cache\n\njulia> (\"2MASS/2MASS.J\", :Vega) in cached_filters() # Check that filter was removed from cache\nfalse\n\n\n\n\n\nclear_filter()\n\nWhen called with no arguments, deletes all filters from the cache.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"We include functions for performing many common operations on photometric filters, summarized below.","category":"page"},{"location":"#Applying-Filter-Curves-to-Spectra","page":"Home","title":"Applying Filter Curves to Spectra","text":"","category":"section"},{"location":"#PhotometricFilters.apply_throughput","page":"Home","title":"PhotometricFilters.apply_throughput","text":"apply_throughput(f::AbstractFilter, wavelengths, flux)\n\nUse linear interpolation to map the wavelengths of the photometric filter f to the given wavelengths and apply the filter throughput to the flux. The provided wavelengths and those of the filter must be compatible. This means if one has units, the other one needs units, too.\n\njulia> using PhotometricFilters: SDSS_u, wave_unit, apply_throughput\n\njulia> f = SDSS_u();\n\njulia> λ = 3000:4000\n3000:4000\n\njulia> flux = fill(1.0, length(λ)); # If `flux` is all `1`, `apply_throughput` reduces to `f` interpolated at `λ`\n\njulia> apply_throughput(f, λ, flux) == f(λ)\ntrue\n\njulia> λ_u = λ .* wave_unit # Can also put units on λ\n(3000:4000) Å\n\njulia> apply_throughput(f, λ_u, flux) == f.(λ_u)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#PhotometricFilters.apply_throughput!","page":"Home","title":"PhotometricFilters.apply_throughput!","text":"apply_throughput!(f::AbstractFilter, wavelengths, flux, out)\n\nIn-place version of apply_throughput which modifies out. It should have a compatible element type with flux.\n\n\n\n\n\n","category":"function"},{"location":"#PhotometricFilters.mean_flux_density","page":"Home","title":"PhotometricFilters.mean_flux_density","text":"mean_flux_density(filt::AbstractFilter, wavelengths, flux)\n\nReturns the mean flux density of a spectrum (defined by wavelengths wavelengths and fluxes flux) when integrated over the provided filter filt.\n\nFor photon counting detectors, this is\n\noverlinef_lambda = fracint_lambda lambda  f_lambda  T(lambda)  dlambdaint_lambda lambda  T(lambda)  dlambda\n\nwhich can also be interpreted as the mean photon rate density, while for energy counting detectors, this is\n\noverlinef_lambda = fracint_lambda f_lambda  T(lambda)  dlambdaint_lambda T(lambda)  dlambda\n\nwhich is essentially just the mean flux weighted by the filter throughput.\n\nBelow we show example usage that can be compared against this example from pyphot.\n\njulia> using PhotometricFilters: mean_flux_density, HST_WFC3_F110W, Vega\n\njulia> using Unitful, UnitfulAstro\n\njulia> v = Vega(\"alpha_lyr_stis_006\");\n\njulia> mfd = mean_flux_density(HST_WFC3_F110W(), v.wave, v.flux);\n\njulia> isapprox(mfd, 4.082289e-10 * u\"erg/s/cm^2/angstrom\"; rtol=1e-3)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#PhotometricFilters.F_nu","page":"Home","title":"PhotometricFilters.F_nu","text":"F_nu(F_lambda::SpectralFluxDensity, λref)\nF_nu(F_lambda::SpectralFluxDensity, f::AbstractFilter)\n\nConvert a spectral flux density F_lambda into a spectral energy density. Assuming F_lambda in erg / s / cm^2 / Angstrom, and F_nu in Jy, this conversion is\n\nF_nu = frac10^510^-8  c  lambda^2_r  F_lambda\n\nwhere c is the speed of light in m/s and lambda_r is the reference wavelength (λref) in Angstroms. If providing an AbstractFilter as the second argument, the reference wavelength will be automatically computed with reference_wavelength.\n\n\n\n\n\n","category":"function"},{"location":"#PhotometricFilters.F_lambda","page":"Home","title":"PhotometricFilters.F_lambda","text":"F_lambda(F_nu::SpectralEnergyDensity, λref)\nF_lambda(F_nu::SpectralEnergyDensity, f::AbstractFilter)\n\nConvert a spectral energy density F_nu into a spectral flux density. Assuming F_nu in Jy and F_lambda in erg / s / cm^2 / Angstrom, this conversion is\n\nF_lambda = frac10^-8  c10^5  lambda^-2_r  F_nu\n\nwhere c is the speed of light in m/s and lambda_r is the reference wavelength (λref) in Angstroms. If providing an AbstractFilter as the second argument, the reference wavelength will be automatically computed with reference_wavelength.\n\n\n\n\n\n","category":"function"},{"location":"#Zero-Points","page":"Home","title":"Zero Points","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We utilize multiple dispatch to support dynamic calculation of zeropoints in the magnitude systems below.","category":"page"},{"location":"#PhotometricFilters.MagnitudeSystem","page":"Home","title":"PhotometricFilters.MagnitudeSystem","text":"Abstract supertype for magnitude systems like AB, ST, and Vega. Subtypes should implement zeropoint_mag, zeropoint_flux, and zeropoint_Jy.\n\n\n\n\n\n","category":"type"},{"location":"#PhotometricFilters.AB","page":"Home","title":"PhotometricFilters.AB","text":"AB() <: MagnitudeSystem\n\nSingleton struct representing the AB magnitude system. This system is defined such that\n\nm_textAB = -25  textlog left( barf_ν right) - 4860\n\nwhen f_ν is in units of erg / s / cm^2 / Hz. This corresponds to a constant  zeropoint_Jy value in all filters of exp10(48.6 / -2.5 + 23) ≈ 3631 Jy.\n\nWhen passed to methods such as zeropoint_flux, indicates that you wish to have the AB zeropoint flux returned.\n\n\n\n\n\n","category":"type"},{"location":"#PhotometricFilters.ST","page":"Home","title":"PhotometricFilters.ST","text":"ST() <: MagnitudeSystem\n\nSingleton struct representing the ST magnitude system. This system is defined so that a source with uniform f_lambda has identical magnitude in every filter.\n\nm_textST = -25  textlog left( barf_lambda right) - 211\n\nWhen passed to methods such as zeropoint_flux, indicates that you wish to have the ST zeropoint flux returned.\n\n\n\n\n\n","category":"type"},{"location":"#PhotometricFilters.Vega","page":"Home","title":"PhotometricFilters.Vega","text":"Vega(wave, flux, name::String) <: MagnitudeSystem\n\nStruct for containing a Vega reference spectrum with wavelengths wave and flux values flux. wave should be provided in units of Å and  flux should be provided in f_λ units of erg / s / cm^2 / Angstrom.\n\nThe Vega magnitude system is defined so that the star Alpha Lyr (i.e., Vega) has magnitude 0 in every filter.\n\nm_textVega = -25  textlog left( fracbarf_lambdabarf_lambda left( textVega right) right)\n\nWhen passed to methods such as zeropoint_flux, indicates that you wish to have the Vega zeropoint flux returned.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"Any reference spectrum hosted by CALSPEC can be used to construct an instance of Vega using the method below.","category":"page"},{"location":"#PhotometricFilters.Vega-Tuple{String}","page":"Home","title":"PhotometricFilters.Vega","text":"Vega(name::String = \"alpha_lyr_stis_011\")\n\nLoads the reference spectrum with filename name and returns an appropriate instance of Vega that can be used to compute zeropoints and magnitudes in the Vega magnitude system.\n\nIf the provided name is the full path to the existing file on disk, the spectrum is loaded from that file. Otherwise, it is downloaded from the CALSPEC database of standard stars maintained by STScI. Files downloaded this way are cached for future use. Specifically, we draw from the extended catalog here. The CALSPEC catalog with the most recent reference spectrum for each star is located here. Standard Vega spectra start with \"alpha_lyr\". names like \"alpha_lyr_stis_XXX\" are based on composites of calibrated stellar models and HST/STIS data, while \"alpha_lyr_mod_XXX\" are based on stellar models only.\n\nSometimes Vega is not used as the standard star for photometric systems even when the system follows the Vega magnitude convention. For example, in the near-IR Sirius is often used as the standard reference spectrum rather than Vega. This is the case for the definition of the JWST zeropoints, which presently use the \"sirius_stis_005.fits\" CALSPEC spectrum as their standard. To load a different standard, simply provide the corresponding name to Vega. For example, to load the Sirius spectrum, use Vega(\"sirius_stis_005\") (the \".fits\" extension is optional).\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"The list of available spectral standards can be retrieved with PhotometricFilters.get_calspec_names.","category":"page"},{"location":"#PhotometricFilters.get_calspec_names","page":"Home","title":"PhotometricFilters.get_calspec_names","text":"get_calspec_names([substring::AbstractString])\n\nReturns a list of the names of the available spectral standards that can be download from CALSPEC and used as a standard in the Vega magnitude system.\n\nIf the optional substring::AbstractString argument is provided, then the list of names is filtered to only include those that contain the provided substring.\n\nThis method is not currently exported.\n\njulia> using PhotometricFilters: Vega, get_calspec_names\n\njulia> names = get_calspec_names();\n\njulia> names isa Vector{String}\ntrue\n\njulia> Vega(names[1]) isa Vega\ntrue\n\njulia> vega_standards = get_calspec_names(\"alpha_lyr\");\n\njulia> all(map(x -> occursin(\"alpha_lyr\", x), vega_standards))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"Zeropoints can be computed with methods below.","category":"page"},{"location":"#PhotometricFilters.zeropoint_flux","page":"Home","title":"PhotometricFilters.zeropoint_flux","text":"zeropoint_flux(f::AbstractFilter, T::MagnitudeSystem)\n\nReturns the flux zero point of the filter f in magnitude system T in units of erg / s / cm^2 / Angstrom.\n\njulia> using PhotometricFilters: zeropoint_flux, AB, ST, Vega, HST_WFC3_F110W\n\njulia> using Unitful\n\njulia> isapprox(zeropoint_flux(HST_WFC3_F110W(), AB()), 8.159816925e-10 * u\"erg/s/cm^2/angstrom\"; rtol=1e-3)\ntrue\n\njulia> isapprox(zeropoint_flux(HST_WFC3_F110W(), ST()), 3.6307805e-9 * u\"erg/s/cm^2/angstrom\"; rtol=1e-3)\ntrue\n\njulia> isapprox(zeropoint_flux(HST_WFC3_F110W(), Vega(\"alpha_lyr_stis_006\")), 4.082289e-10 * u\"erg/s/cm^2/angstrom\"; rtol=1e-3)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#PhotometricFilters.zeropoint_Jy","page":"Home","title":"PhotometricFilters.zeropoint_Jy","text":"zeropoint_Jy(f::AbstractFilter, T::MagnitudeSystem)\n\nReturns the flux zeropoint in Jansky in magnitude system T.\n\nNote that for the AB system, this is often approximated as 3631 Jy, following from the definition m_textAB = -25  textlog left( barf_nu right) - 486 where barf_nu is in units of erg / s / cm^2 / Hz. This can be solved for m_textAB = 0 to give barf_nu 0 = 10^frac486-25 which is approximately 3631 times 10^-20 erg / s / cm^2 / Hz, or ≈ 3631 Jy. This function returns the exact value.\n\njulia> using PhotometricFilters: zeropoint_Jy, AB, ST, Vega, HST_WFC3_F110W\n\njulia> using Unitful, UnitfulAstro\n\njulia> isapprox(zeropoint_Jy(HST_WFC3_F110W(), AB()), 3630.78054 * u\"Jy\"; rtol=1e-3)\ntrue\n\njulia> isapprox(zeropoint_Jy(HST_WFC3_F110W(), ST()), 16155.46954* u\"Jy\"; rtol=1e-3)\ntrue\n\njulia> isapprox(zeropoint_Jy(HST_WFC3_F110W(), Vega(\"alpha_lyr_stis_006\")), 1816.43597 * u\"Jy\"; rtol=1e-3)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#PhotometricFilters.zeropoint_mag","page":"Home","title":"PhotometricFilters.zeropoint_mag","text":"zeropoint_mag(f::AbstractFilter, T::MagnitudeSystem)\n\nReturns the magnitude zero point of the filter f in the magnitude system T. This is used by the magnitude method to calculate magnitudes from spectra in units of F_lambda as\n\nm_textAB = -25 * textlog left( barf_lambda right) - textZpt\n\nFor the ST magnitude system, this is always equal to 21.1 by definition.\n\njulia> using PhotometricFilters: zeropoint_mag, AB, ST, Vega, HST_WFC3_F110W\n\njulia> isapprox(zeropoint_mag(HST_WFC3_F110W(), AB()), 22.7207989; rtol=1e-3)\ntrue\n\njulia> isapprox(float(zeropoint_mag(HST_WFC3_F110W(), ST())), 21.1; rtol=1e-3)\ntrue\n\njulia> isapprox(zeropoint_mag(HST_WFC3_F110W(), Vega(\"alpha_lyr_stis_006\")), 23.4727487; rtol=1e-3)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#Synthetic-Photometry","page":"Home","title":"Synthetic Photometry","text":"","category":"section"},{"location":"#PhotometricFilters.magnitude","page":"Home","title":"PhotometricFilters.magnitude","text":"magnitude(f::AbstractFilter, T::MagnitudeSystem, wavelengths, flux)\n\nCalculates the magnitude in the given filter f in the magnitude system T from a spectrum defined by arrays wavelengths and flux, both of which must have valid Unitful units.\n\njulia> using PhotometricFilters: magnitude, Vega, ST, AB, HST_WFC3_F110W\n\njulia> v = Vega(\"alpha_lyr_stis_006\");\n\njulia> isapprox(magnitude(HST_WFC3_F110W(), AB(), v.wave, v.flux), 0.7519497; rtol=1e-3)\ntrue\n\njulia> isapprox(magnitude(HST_WFC3_F110W(), ST(), v.wave, v.flux), 2.372748728; rtol=1e-3)\ntrue\n\njulia> isapprox(magnitude(HST_WFC3_F110W(), v, v.wave, v.flux), 0; rtol=1e-3)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#Statistics","page":"Home","title":"Statistics","text":"","category":"section"},{"location":"#PhotometricFilters.reference_wavelength","page":"Home","title":"PhotometricFilters.reference_wavelength","text":"reference_wavelength(f::AbstractFilter)\n\nReturns the reference wavelength of the filter f, used for conversions of the flux and for determination of magnitudes.\n\nBy default the pivot wavelength is returned (pivot_wavelength), but filter providers sometimes provide their own specified values.\n\n\n\n\n\n","category":"function"},{"location":"#PhotometricFilters.mean_wavelength","page":"Home","title":"PhotometricFilters.mean_wavelength","text":"mean_wavelength(f::AbstractFilter)\n\nReturns the mean wavelength of the filter f, defined as\n\nfracint lambda  T(lambda)  dlambdaint T(lambda)  dlambda\n\n\n\n\n\n","category":"function"},{"location":"#PhotometricFilters.central_wavelength","page":"Home","title":"PhotometricFilters.central_wavelength","text":"central_wavelength(f::AbstractFilter)\n\nReturns the central wavelength of the filter f, defined as the central wavelength between the two wavelengths used for the FWHM (fwhm).\n\n\n\n\n\n","category":"function"},{"location":"#PhotometricFilters.effective_wavelength","page":"Home","title":"PhotometricFilters.effective_wavelength","text":"effective_wavelength(f::AbstractFilter, v::Vega = Vega())\n\nReturns the effective wavelength of the filter f using the Vega spectrum contained in v as a standard. Defined as\n\nfracint lambda  T(lambda) textVg(lambda)  dlambdaint T(lambda) textVg(lambda)  dlambda\n\nwhere T(lambda) is the filter transmission at wavelength lambda and textVg(lambda) is the spectrum of Vega.\n\n\n\n\n\n","category":"function"},{"location":"#PhotometricFilters.pivot_wavelength","page":"Home","title":"PhotometricFilters.pivot_wavelength","text":"pivot_wavelength(f::AbstractFilter)\n\nReturns the pivot wavelength of the filter f, defined for filters with Energy detector types as\n\nsqrt fracint T(lambda)  dlambdaint T(lambda)  lambda^2  dlambda \n\nFor filters with Photon detector types, lambda  T(lambda) is substituted for T(lambda) in the above expression.\n\nInternally integration is carried out using trapezoidal integration. It can be convenient to think of this as the \"center of mass\" of the filter.\n\n\n\n\n\n","category":"function"},{"location":"#PhotometricFilters.min_wave","page":"Home","title":"PhotometricFilters.min_wave","text":"min_wave(f::AbstractFilter; level=0.01)\n\nReturns the shortest wavelength at which the filter transmission is equal to level * maximum(transmission).\n\n\n\n\n\n","category":"function"},{"location":"#PhotometricFilters.max_wave","page":"Home","title":"PhotometricFilters.max_wave","text":"max_wave(f::AbstractFilter; level=0.01)\n\nReturns the longest wavelength at which the filter transmission is equal to level * maximum(transmission).\n\n\n\n\n\n","category":"function"},{"location":"#PhotometricFilters.fwhm","page":"Home","title":"PhotometricFilters.fwhm","text":"fwhm(f::AbstractFilter)\n\nReturns the difference between the furthest two wavelengths for which the filter transmission is equal to half its maximum value.\n\n\n\n\n\n","category":"function"},{"location":"#PhotometricFilters.width","page":"Home","title":"PhotometricFilters.width","text":"width(f::AbstractFilter)\n\nReturns the effective width of the filter, defined as the horizontal size of a rectangle with height equal to the maximum transmission of the filter such that the area of the rectangle is equal to the area under the filter transmission curve. This is calculated as\n\nfracint T(lambda)  dlambdatextmax(T(lambda))\n\n\n\n\n\n","category":"function"},{"location":"#Internals","page":"Home","title":"Internals","text":"","category":"section"},{"location":"#PhotometricFilters.AbstractFilter","page":"Home","title":"PhotometricFilters.AbstractFilter","text":"AbstractFilter{T}\n\nAbstract supertype for representing photometric filters. Most functions provided by this package (e.g., effective_wavelength and similar methods) are designed to work with any subtype of AbstractFilter so long as a minimal API is defined for new subtypes. The methods that should be implemented for new types to conform to this API are summarized below:\n\nfiltername(f::NewType) should return a string indicating a human-readable name for the filter (e.g., \"SDSS_u\").\nwavelength(f::NewType) should return the wavelength vector of the filter transmission curve with proper Unitful.jl units.\nthroughput(f::NewType) should return the throughput vector of the filter transmission curve (no units).\ndetector_type(f::NewType) should return an instance of PhotometricFilters.Energy if the filter is defined for energy-counting detectors or PhotometricFilters.Photon for photon-counting detectors.\n\nAdditionally, all subtypes should support filter interpolation at user-defined wavelengths with a call signature (f::NewType)(wavelengths). To support this, new types should implement a method like (f::PhotometricFilter)(wavelength::Q) where Q <: Unitful.Length. A generic fallback for inputs without units is already defined.\n\n\n\n\n\n","category":"type"},{"location":"#PhotometricFilters.get_metadata","page":"Home","title":"PhotometricFilters.get_metadata","text":"get_metadata()\n\nReturns a table of the available parameters that can be used to query the SVO filter service from the FORMAT=metadata VOTable they provide.\n\nThe table is a DataFrame from the DataFrames package with the following columns:\n\nparameter: parameter name that can be used for queries using query_filters\nunit: Unitful unit of the parameter\ndatatype: Type of the parameter\ndescription: description of the parameter\nvalues: vector of the possible values that the respective parameter can take on (e.g. for Instrument), or a vector of the minimum and maximum values that the parameter can assume (e.g. for WavelengthEff)\n\nExample\n\njulia> using DataFrames: DataFrame\n\njulia> df = PhotometricFilters.get_metadata();\n\njulia> df isa DataFrame\ntrue\n\njulia> facilities = df[findfirst(==(\"Facility\"), df.parameter), :].values;\n\njulia> facilities isa Vector{String}\ntrue\n\nThis is not exported.\n\n\n\n\n\n","category":"function"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
