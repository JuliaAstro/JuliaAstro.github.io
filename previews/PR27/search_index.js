var documenterSearchIndex = {"docs":
[{"location":"tutorials/tabular-data/#tabular-data","page":"Working with tabular data","title":"Working with tabular data","text":"","category":"section"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"Tables are a common way to represent various forms of catalogs. One common format for storing this data in astronomy is as a FITS file.","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"In these examples, we will fetch and load the Hipparcos-GAIA Catalog of Accelerations [(HGCA, Brandt et al 2021])](https://iopscience.iop.org/article/10.3847/1538-4365/abf93c). This catalog cross matches stars from the Hipparcos and GAIA catalogs in order to calculate the long term astrometric proper motion anomaly; that is, the star's deviation from straight line motion in the plane of the sky over the ~20 baseline between the two missions.","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"A wide range of tabular data formats are supported in Julia under a common Tables.jl interface. For example,  CSV, Excel, Arrow, CASA Tables, and various SQL formats to name a few.","category":"page"},{"location":"tutorials/tabular-data/#Packages","page":"Working with tabular data","title":"Packages","text":"","category":"section"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"FITSIO: we'll use this package to load a table stored in a FITS file\nDataFrames: we'll use this package to examine and manipulate the table\nPlots: we'll use this package to visualize the contents of the table\nAstroLib: general utility package. We'll use a helper function to compute a map projection.","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"You can install the necessary packages by running Julia, and typing ] to enter Pkg-mode. Then: add FITSIO DataFrames Plots AstroLib. Alternatively, you can run using Pkg; Pkg.add([\"FITSIO\", \"DataFrames\", \"Plots\", \"AstroLib\"]).","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"If you will be using these tools as part of a larger project, it's strongly recommended to create a Julia Project to record package versions.  If you're just experimenting, you can create a temporary project by running ] activate --temp.","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"If you're using Pluto notebooks, installing and recording package versions in a project are handled for you automatically.","category":"page"},{"location":"tutorials/tabular-data/#Downloading-the-data","page":"Working with tabular data","title":"Downloading the data","text":"","category":"section"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"The table in question is hosted alongside the article. Go to Table 4 and click the link at the bottom to download it in FITS format. You'll need to uncompress the archive to see the HGCA_vEDR3.fits file.","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"FITS tables can be loaded using the FITSIO package or the AstroImages package which wraps it.","category":"page"},{"location":"tutorials/tabular-data/#Loading-the-table","page":"Working with tabular data","title":"Loading the table","text":"","category":"section"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"julia> using FITSIO\njulia> fits = FITS(\"HGCA_vEDR3.fits\")\n\nFile: HGCA_vEDR3.fits\nMode: \"r\" (read-only)\nHDUs: Num  Name  Type   \n      1          Image  \n      2          Table\njulia> table_fits = fits[2]\nFile: HGCA_vEDR3.fits\nHDU: 2\nType: Table\nRows: 115346\nColumns: Name                    Size  Type     TFORM  \n         hip_id                        Int32    J\n         gaia_source_id                Int64    K\n         gaia_ra                       Float64  D\n         gaia_dec                      Float64  D\n         radial_velocity               Float32  E\n...\n         chisq                         Float32  E","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"If we choose to use the AstroImages package, this code could be substituted for:","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"julia> using AstroImages\njulia> table_fits = load(\"HGCA_vEDR3.fits\", 2);","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"Since this table conforms to the Tables.jl interface we can already pass it to a wide range of analysis and plotting tools; however, for interactive work it's useful to wrap this data in a DataFrame from DataFrames.jl.","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"julia> using DataFrames\njulia> df = DataFrame(table_fits)\n115346×35 DataFrame\n    Row │ hip_id  gaia_source_id       gaia_ra        gaia_dec ⋯\n        │ Int32   Int64                Float64        Float64  ⋯\n────────┼───────────────────────────────────────────────────────\n      1 │      1  2738327528519591936    0.000871957    1.0889 ⋯\n      2 │      2  2341871673090078592    0.00511158   -19.4988  \n      3 │      3  2881742980523997824    0.00506023    38.8593  \n      4 │      4  4973386040722654336    0.00907157   -51.8935  \n      5 │      5  2305974989264598272    0.00997423   -40.5912 ⋯\n   ⋮    │   ⋮              ⋮                 ⋮            ⋮    ⋱\n 115343 │ 120401  5290738562888564736  119.382        -60.6309  \n 115344 │ 120402  5290832364972775808  119.449        -60.6097  \n 115345 │ 120403  5290725643625189504  119.455        -60.6836  \n 115346 │ 120404  5290820682661822848  119.512        -60.6147 ⋯\n                              32 columns and 115337 rows omitted\n","category":"page"},{"location":"tutorials/tabular-data/#Examining-the-table","page":"Working with tabular data","title":"Examining the table","text":"","category":"section"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"As a first step, let's summarize the contents of the data frame using describe:","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"julia> describe(df)\n35×7 DataFrame\n Row │ variable                mean         min            median       max                  nmissing  eltype   \n     │ Symbol                  Union…       Any            Union…       Any                  Int64     DataType \n─────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────\n   1 │ hip_id                  59162.8      1              59133.5      120404                      0  Int32\n   2 │ gaia_source_id          3.5587e18    7632157690368  3.58418e18   6917489002841762304         0  Int64\n   3 │ gaia_ra                 181.445      0.000871957    181.843      359.982                     0  Float64\n   4 │ gaia_dec                -2.13495     -89.7824       -1.96568     89.5695                     0  Float64\n   5 │ radial_velocity         NaN          NaN                         NaN                         0  Float32\n   6 │ radial_velocity_error   NaN          NaN                         NaN                         0  Float32\n   7 │ radial_velocity_source               Gaia_DR2                    None                        0  String\n   8 │ parallax_gaia           6.98091      0.1            4.29612      768.067                     0  Float32\n   9 │ parallax_gaia_error     0.0450278    0.00802848     0.023354     1.52339                     0  Float32\n  10 │ pmra_gaia               -1.43563     -4406.47       -1.73408     6766.0                      0  Float32\n  11 │ pmdec_gaia              -16.3946     -5817.8        -5.53577     10362.4                     0  Float32\n  12 │ pmra_gaia_error         0.062217     0.00743185     0.0326008    2.03418                     0  Float32\n  13 │ pmdec_gaia_error        0.0574897    0.00869586     0.029098     1.99573                     0  Float32\n  14 │ pmra_pmdec_gaia         -0.0142746   -0.971819      -0.0116653   0.891564                    0  Float32\n  15 │ pmra_hg                 -1.43057     -4406.68       -1.69382     6765.91                     0  Float32\n  ⋮  │           ⋮                  ⋮             ⋮             ⋮                ⋮              ⋮         ⋮\n  22 │ pmra_hip_error          1.22346      0.290212       0.93546      2269.23                     0  Float32\n  23 │ pmdec_hip_error         1.00177      0.289527       0.794942     113.61                      0  Float32\n  24 │ pmra_pmdec_hip          0.00441718   -0.94068       0.000400515  0.986897                    0  Float32\n  25 │ epoch_ra_gaia           2016.07      2015.11        2016.07      2017.05                     0  Float64\n  26 │ epoch_dec_gaia          2016.09      2014.95        2016.1       2017.2                      0  Float64\n  27 │ epoch_ra_hip            1991.25      1990.4         1991.25      1992.43                     0  Float64\n  28 │ epoch_dec_hip           1991.28      1990.34        1991.28      1992.41                     0  Float64\n  29 │ crosscal_pmra_hip       -0.0578266   -1.36874       -0.0648208   1.50959                     0  Float32\n  30 │ crosscal_pmdec_hip      0.00226569   -1.15742       0.00306844   1.59232                     0  Float32\n  31 │ crosscal_pmra_hg        -0.0013262   -0.0511373     -0.00269026  0.0619938                   0  Float32\n  32 │ crosscal_pmdec_hg       0.000217839  -0.0598967     0.00025581   0.0564424                   0  Float32\n  33 │ nonlinear_dpmra         -9.0424e-5   -7.98001       3.44128e-8   2.64822                     0  Float32\n  34 │ nonlinear_dpmdec        0.000311498  -4.1194        1.92019e-7   16.0394                     0  Float32\n  35 │ chisq                   566.555      3.11559e-5     3.35103      3.67633e5                   0  Float32\n                                                                                                  6 rows omitted\n","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"This lists all the columns of the table along with their min, max, median, and means. It also specifies how many entries are missing and the element type of the column.","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"We can access a specific column from the table using two different syntaxes: df[:,\"epoch_ra_gaia\"], or simply df.epoch_ra_gaia.","category":"page"},{"location":"tutorials/tabular-data/#Filtering","page":"Working with tabular data","title":"Filtering","text":"","category":"section"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"Let's apply a cut to the parallax column to only include nearby stars:","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"julia> nearby = filter(:parallax_gaia => >(50.0), df)\n799×35 DataFrame\n Row │ hip_id  gaia_source_id       gaia_ra    gaia_dec   radial_velocity  radial_vel ⋯\n     │ Int32   Int64                Float64    Float64    Float32          Float32    ⋯\n─────┼─────────────────────────────────────────────────────────────────────────────────\n   1 │    428   386655019234959872    1.30108   45.7859          -1.24273             ⋯\n   2 │    436  4706630501049679744    1.32232  -67.8351          40.2364\n   3 │    439  2306965202564744064    1.38379  -37.3675          25.2944\n   4 │    473   386653851004022144    1.42676   45.8114           1.15092\n  ⋮  │   ⋮              ⋮               ⋮          ⋮             ⋮                    ⋱\n 796 │ 117779  2867175035571212416  358.285     29.0182           1.30031             ⋯\n 797 │ 117828  6377828354964753792  358.463    -75.6342          -9.62612\n 798 │ 117966  2442996678074668288  358.914     -6.14423         17.0672\n 799 │ 120005  1022456104850892928  138.591     52.6834          11.9794\n                                                        30 columns and 791 rows omitted","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"Let's break this down. First, we specify the column name as :parallax_gaia. The : syntax defines a Symbol in Julia which is a bit like a string and a variable name. Next, we say what filter we want to apply to this column by passing a key-value Pair constructed with =>. This syntax, e.g. 1 => 2 just groups two values and is unrelated to keyword arguments. Then, we pass a predicate function, that is a function that takes one value and returns true or false. The expression >(50.0) produces such a function that takes a value and compares it with 50.0 milliarseconds of parallax. Finally, we pass the table we want to filter.","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"This useful cheatsheet by Tom Kwong is a great reference for these sort of operations.","category":"page"},{"location":"tutorials/tabular-data/#Plotting","page":"Working with tabular data","title":"Plotting","text":"","category":"section"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"Let's now visualize these stars as they appear in the plane of the sky. We'll colour them based on the significance of the anomalous acceleration they had between the two satellite missions. This acceleration could be caused by a hidden companion star or planet.","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"julia> using Plots\njulia> scatter(\n    nearby.gaia_ra,\n    nearby.gaia_dec;\n    marker_z = log10.(nearby.chisq),\n    colorbartitle=\"log10 χ²\", # typed as \\chi <tab> \\^2 <tab>\n    label = \"\",\n    xlabel = \"right ascension (°)\", # typed as \\degree <tab>\n    ylabel = \"declination (°)\" \n)","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"Let's improve this plot by using a different map projection. We can make this conversion using AstroLib.jl.","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"The function aitoff takes longitude and latitude (or in this case, right-ascension and delcination) and returns a new position using an Aitoff projection.","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"julia> using AstroLib\njulia> newpoints = aitoff.(nearby.gaia_ra, nearby.gaia_dec)","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"newpoints is returned as a vector of Tuples of x and y coordinates, but to plot them we'll need separate flat vectors of x and y values. We can convert using getindex:","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"julia> newx = getindex.(newpoints, 1)\njulia> newy = getindex.(newpoints, 2)\n799-element Vector{Float64}:\n  49.51360693576993\n -71.02232113037604\n -40.77386766281466\n   ⋮\n -78.04105630927837\n  -6.821326623255115\n  64.9538084311332","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"getindex(obj, n) is equivalent to writing obj[n]. Here we use broadcasting to fetch the first and then second element of each point in the list.","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"Finally, we'll make the plot and tweak some formatting options:","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"julia> scatter(\n    newx,\n    newy;\n    marker_z = log10.(nearby.chisq),\n    color = :turbo,\n    colorbartitle=\"log10 χ²\", # typed as \\chi <tab> \\^2 <tab>\n    label = \"\",\n    xlabel = \"right ascension (°)\", # typed as \\degree <tab>\n    ylabel = \"declination (°)\",\n    background=:transparent,\n    foreground=:gray,\n    framestyle=:box,\n    markerstrokewidth=0,\n    grid=:none\n)","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"(Image: Plot of nearby stars with significant acceleration)","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"We can save the plot using savefig(\"myplot.pdf\"). png, svg, and other formats are also supported.","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"For more on plotting in general, see the Plots.jl documentation.","category":"page"},{"location":"highlevels/cosmology/#Cosmology-Overview","page":"Cosmology Overview","title":"Cosmology Overview","text":"","category":"section"},{"location":"modules/Optimization/API/modelingtoolkit/#ModelingToolkit-Integration","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"","category":"section"},{"location":"modules/Optimization/API/modelingtoolkit/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"Optimization.jl is heavily integrated with the ModelingToolkit.jl symbolic system for symbolic-numeric optimizations. It provides a front-end for automating the construction, parallelization, and optimization of code. Optimizers can better interface with the extra symbolic information provided by the system.","category":"page"},{"location":"modules/Optimization/API/modelingtoolkit/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"There are two ways that the user interacts with ModelingToolkit.jl. One can use OptimizationFunction with AutoModelingToolkit for automatically transforming numerical codes into symbolic codes. See the OptimizationFunction documentation for more details.","category":"page"},{"location":"modules/Optimization/API/modelingtoolkit/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"Secondly, one can generate OptimizationProblems for use in Optimization.jl from purely a symbolic front-end. This is the form users will encounter when using ModelingToolkit.jl directly, and its also the form supplied by domain-specific languages. For more information, see the OptimizationSystem documentation.","category":"page"},{"location":"highlevels/vizplot/#Visualization-and-Plotting-Overview","page":"Visualization & Plotting Overview","title":"Visualization & Plotting Overview","text":"","category":"section"},{"location":"highlevels/vizplot/#[AstroImages.jl](https://github.com/JuliaAstro/AstroImages.jl)-[![](../assets/book.png)](https://juliaastro.github.io/AstroImages.jl/stable/)","page":"Visualization & Plotting Overview","title":"AstroImages.jl (Image: )","text":"","category":"section"},{"location":"highlevels/vizplot/","page":"Visualization & Plotting Overview","title":"Visualization & Plotting Overview","text":"Load, manipulate, and visualize astronomical images","category":"page"},{"location":"highlevels/vizplot/","page":"Visualization & Plotting Overview","title":"Visualization & Plotting Overview","text":"Works with the FileIO.jl interface\nAutomatic visualizations are directly integrated into many environments like VSCode, Pluto.jl, and IJulia.jl\nIncludes recipes for plotting with Plots.jl","category":"page"},{"location":"highlevels/vizplot/#[SAOImageDS9.jl](https://github.com/JuliaAstro/SAOImageDS9.jl)-[![](../assets/book.png)](https://juliaastro.github.io/SAOImageDS9.jl/stable/)","page":"Visualization & Plotting Overview","title":"SAOImageDS9.jl (Image: )","text":"","category":"section"},{"location":"highlevels/vizplot/","page":"Visualization & Plotting Overview","title":"Visualization & Plotting Overview","text":"Interface with the DS9 image viewer","category":"page"},{"location":"highlevels/vizplot/","page":"Visualization & Plotting Overview","title":"Visualization & Plotting Overview","text":"Uses XPA.jl to communicate with DS9 instances\nEasily display images in DS9 and add features like circles and lines\nLow-level API accessible with set and get","category":"page"},{"location":"modules/Optimization/tutorials/rosenbrock/#Solving-the-Rosenbrock-Problem-in-10-Ways","page":"Solving the Rosenbrock Problem in >10 Ways","title":"Solving the Rosenbrock Problem in >10 Ways","text":"","category":"section"},{"location":"modules/Optimization/tutorials/rosenbrock/","page":"Solving the Rosenbrock Problem in >10 Ways","title":"Solving the Rosenbrock Problem in >10 Ways","text":"This tutorial is a demonstration of many different solvers to demonstrate the flexibility of Optimization.jl. This is a gauntlet of many solvers to get a feel for common workflows of the package and give copy-pastable starting points.","category":"page"},{"location":"modules/Optimization/tutorials/rosenbrock/","page":"Solving the Rosenbrock Problem in >10 Ways","title":"Solving the Rosenbrock Problem in >10 Ways","text":"note: Note\nThis example uses many different solvers of Optimization.jl. Each solver subpackage needs to be installed separate. For example, for the details on  the installation and usage of OptimizationOptimJL.jl package, see the  Optim.jl page.","category":"page"},{"location":"modules/Optimization/tutorials/rosenbrock/","page":"Solving the Rosenbrock Problem in >10 Ways","title":"Solving the Rosenbrock Problem in >10 Ways","text":"# Define the problem to solve\nusing Optimization, ForwardDiff, Zygote\n\nrosenbrock(x, p) =  (p[1] - x[1])^2 + p[2] * (x[2] - x[1]^2)^2\nx0 = zeros(2)\n_p  = [1.0, 100.0]\n\nf = OptimizationFunction(rosenbrock, Optimization.AutoForwardDiff())\nl1 = rosenbrock(x0, _p)\nprob = OptimizationProblem(f, x0, _p)\n\n## Optim.jl Solvers\n\nusing OptimizationOptimJL\n\n# Start with some derivative-free optimizers\n\nsol = solve(prob, SimulatedAnnealing())\nprob = OptimizationProblem(f, x0, _p, lb=[-1.0, -1.0], ub=[0.8, 0.8])\nsol = solve(prob, SAMIN())\n\nl1 = rosenbrock(x0, _p)\nprob = OptimizationProblem(rosenbrock, x0, _p)\nsol = solve(prob, NelderMead())\n\n# Now a gradient-based optimizer with forward-mode automatic differentiation\n\noptf = OptimizationFunction(rosenbrock, Optimization.AutoForwardDiff()) \nprob = OptimizationProblem(optf, x0, _p) \nsol = solve(prob, BFGS())\n\n# Now a second order optimizer using Hessians generated by forward-mode automatic differentiation\n\nsol = solve(prob, Newton())\n\n# Now a second order Hessian-free optimizer\n\nsol = solve(prob, Optim.KrylovTrustRegion())\n\n# Now derivative-based optimizers with various constraints\n\n    cons = (x,p) -> [x[1]^2 + x[2]^2]\n    optf = OptimizationFunction(rosenbrock, Optimization.AutoForwardDiff();cons= cons)\n    #prob = OptimizationProblem(optf, x0, _p)\n    #sol = solve(prob, IPNewton()) # No lcons or rcons, so constraints not satisfied\n\nprob = OptimizationProblem(optf, x0, _p, lcons = [-Inf], ucons = [Inf])\nsol = solve(prob, IPNewton()) # Note that -Inf < x[1]^2 + x[2]^2 < Inf is always true\n\nprob = OptimizationProblem(optf, x0, _p, lcons = [-5.0], ucons = [10.0])\nsol = solve(prob, IPNewton()) # Again, -5.0 < x[1]^2 + x[2]^2 < 10.0\n\nprob = OptimizationProblem(optf, x0, _p, lcons = [-Inf], ucons = [Inf], \n                           lb = [-500.0,-500.0], ub=[50.0,50.0])\nsol = solve(prob, IPNewton())\n\nprob = OptimizationProblem(optf, x0, _p, lcons = [0.5], ucons = [0.5], \n                           lb = [-500.0,-500.0], ub=[50.0,50.0]) \nsol = solve(prob, IPNewton()) # Notice now that x[1]^2 + x[2]^2 ≈ 0.5:\n                              # cons(sol.minimizer, _p) = 0.49999999999999994\n\nfunction con2_c(x,p)\n    [x[1]^2 + x[2]^2, x[2]*sin(x[1])-x[1]]\nend\n\noptf = OptimizationFunction(rosenbrock, Optimization.AutoForwardDiff();cons= con2_c)\nprob = OptimizationProblem(optf, x0, _p, lcons = [-Inf,-Inf], ucons = [Inf,Inf])\nsol = solve(prob, IPNewton())\n\ncons_circ = (x,p) -> [x[1]^2 + x[2]^2]\noptf = OptimizationFunction(rosenbrock, Optimization.AutoForwardDiff();cons= cons_circ)\nprob = OptimizationProblem(optf, x0, _p, lcons = [-Inf], ucons = [0.25^2])\nsol = solve(prob, IPNewton()) # -Inf < cons_circ(sol.minimizer, _p) = 0.25^2\n\n# Now let's switch over to OptimizationOptimisers with reverse-mode AD\n\nusing OptimizationOptimisers\noptf = OptimizationFunction(rosenbrock, Optimization.AutoZygote())\nprob = OptimizationProblem(optf, x0, _p)\nsol = solve(prob, Adam(0.05), maxiters = 1000, progress = false)\n\n## Try out CMAEvolutionStrategy.jl's evolutionary methods\n\nusing OptimizationCMAEvolutionStrategy\nsol = solve(prob, CMAEvolutionStrategyOpt())\n\n## Now try a few NLopt.jl solvers with symbolic differentiation via ModelingToolkit.jl\n\nusing OptimizationNLopt, ModelingToolkit\noptf = OptimizationFunction(rosenbrock, Optimization.AutoModelingToolkit())\nprob = OptimizationProblem(optf, x0, _p)\n\nsol = solve(prob, Opt(:LN_BOBYQA, 2))\nsol = solve(prob, Opt(:LD_LBFGS, 2))\n\n## Add some box constarints and solve with a few NLopt.jl methods\n\nprob = OptimizationProblem(optf, x0, _p, lb=[-1.0, -1.0], ub=[0.8, 0.8])\nsol = solve(prob, Opt(:LD_LBFGS, 2))\n# sol = solve(prob, Opt(:G_MLSL_LDS, 2), nstart=2, local_method = Opt(:LD_LBFGS, 2), maxiters=10000)\n\n## Evolutionary.jl Solvers\n\nusing OptimizationEvolutionary\nsol = solve(prob, CMAES(μ =40 , λ = 100),abstol=1e-15) # -1.0 ≤ x[1], x[2] ≤ 0.8 \n\n## BlackBoxOptim.jl Solvers\n\nusing OptimizationBBO\nprob = Optimization.OptimizationProblem(rosenbrock, x0, _p, lb=[-1.0, 0.2], ub=[0.8, 0.43])\nsol = solve(prob, BBO_adaptive_de_rand_1_bin()) # -1.0 ≤ x[1] ≤ 0.8, 0.2 ≤ x[2] ≤ 0.43","category":"page"},{"location":"modules/Optimization/tutorials/rosenbrock/","page":"Solving the Rosenbrock Problem in >10 Ways","title":"Solving the Rosenbrock Problem in >10 Ways","text":"And this is only a small subset of what Optimization.jl has to offer!","category":"page"},{"location":"modules/Optimization/#Optimization.jl","page":"Optimization.jl: A Unified Optimization Package","title":"Optimization.jl","text":"","category":"section"},{"location":"modules/Optimization/","page":"Optimization.jl: A Unified Optimization Package","title":"Optimization.jl: A Unified Optimization Package","text":"Optimization.jl is a package with a scope that is beyond your normal global optimization package. Optimization.jl seeks to bring together all of the optimization packages it can find, local and global, into one unified Julia interface. This means, you learn one package and you learn them all! Optimization.jl adds a few high-level features, such as integrating with automatic differentiation, to make its usage fairly simple for most cases, while allowing all of the options in a single unified interface.","category":"page"},{"location":"modules/Optimization/#Installation","page":"Optimization.jl: A Unified Optimization Package","title":"Installation","text":"","category":"section"},{"location":"modules/Optimization/","page":"Optimization.jl: A Unified Optimization Package","title":"Optimization.jl: A Unified Optimization Package","text":"Assuming that you already have Julia correctly installed, it suffices to import Optimization.jl in the standard way:","category":"page"},{"location":"modules/Optimization/","page":"Optimization.jl: A Unified Optimization Package","title":"Optimization.jl: A Unified Optimization Package","text":"import Pkg; Pkg.add(\"Optimization\")","category":"page"},{"location":"modules/Optimization/","page":"Optimization.jl: A Unified Optimization Package","title":"Optimization.jl: A Unified Optimization Package","text":"The packages relevant to the core functionality of Optimization.jl will be imported accordingly and, in most cases, you do not have to worry about the manual installation of dependencies. However, you will need to add the specific optimizer packages.","category":"page"},{"location":"modules/Optimization/#Overview-of-the-Optimizers","page":"Optimization.jl: A Unified Optimization Package","title":"Overview of the Optimizers","text":"","category":"section"},{"location":"modules/Optimization/","page":"Optimization.jl: A Unified Optimization Package","title":"Optimization.jl: A Unified Optimization Package","text":"Package Local Gradient-Based Local Hessian-Based Local Derivative-Free Local Constrained Global Unconstrained Global Constrained\nBlackBoxOptim ❌ ❌ ❌ ❌ ✅ ❌\nCMAEvolutionaryStrategy ❌ ❌ ❌ ❌ ✅ ❌\nEvolutionary ❌ ❌ ❌ ❌ ✅ 🟡\nFlux ✅ ❌ ❌ ❌ ❌ ❌\nGCMAES ❌ ❌ ❌ ❌ ✅ ❌\nMathOptInterface ✅ ✅ ✅ ✅ ✅ 🟡\nMultistartOptimization ❌ ❌ ❌ ❌ ✅ ❌\nMetaheuristics ❌ ❌ ❌ ❌ ✅ 🟡\nNOMAD ❌ ❌ ❌ ❌ ✅ 🟡\nNLopt ✅ ❌ ✅ 🟡 ✅ 🟡\nNonconvex ✅ ✅ ✅ 🟡 ✅ 🟡\nOptim ✅ ✅ ✅ ✅ ✅ ✅\nQuadDIRECT ❌ ❌ ❌ ❌ ✅ ❌","category":"page"},{"location":"modules/Optimization/","page":"Optimization.jl: A Unified Optimization Package","title":"Optimization.jl: A Unified Optimization Package","text":"✅ = supported","category":"page"},{"location":"modules/Optimization/","page":"Optimization.jl: A Unified Optimization Package","title":"Optimization.jl: A Unified Optimization Package","text":"🟡 = supported in downstream library but not yet implemented in Optimization; PR to add this functionality are welcome","category":"page"},{"location":"modules/Optimization/","page":"Optimization.jl: A Unified Optimization Package","title":"Optimization.jl: A Unified Optimization Package","text":"❌ = not supported","category":"page"},{"location":"modules/Optimization/optimization_packages/speedmapping/#SpeedMapping.jl","page":"SpeedMapping.jl","title":"SpeedMapping.jl","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/speedmapping/","page":"SpeedMapping.jl","title":"SpeedMapping.jl","text":"SpeedMapping accelerates the convergence of a mapping to a fixed point by the Alternating cyclic extrapolation algorithm which can also perform multivariate optimization based on the gradient function.","category":"page"},{"location":"modules/Optimization/optimization_packages/speedmapping/","page":"SpeedMapping.jl","title":"SpeedMapping.jl","text":"The SpeedMapping algorithm is called by SpeedMappingOpt()","category":"page"},{"location":"modules/Optimization/optimization_packages/speedmapping/#Installation:-OptimizationSpeedMapping.jl","page":"SpeedMapping.jl","title":"Installation: OptimizationSpeedMapping.jl","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/speedmapping/","page":"SpeedMapping.jl","title":"SpeedMapping.jl","text":"To use this package, install the OptimizationSpeedMapping package:","category":"page"},{"location":"modules/Optimization/optimization_packages/speedmapping/","page":"SpeedMapping.jl","title":"SpeedMapping.jl","text":"import Pkg; Pkg.add(\"OptimizationSpeedMapping\")","category":"page"},{"location":"modules/Optimization/optimization_packages/speedmapping/#Global-Optimizer","page":"SpeedMapping.jl","title":"Global Optimizer","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/speedmapping/#Without-Constraint-Equations","page":"SpeedMapping.jl","title":"Without Constraint Equations","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/speedmapping/","page":"SpeedMapping.jl","title":"SpeedMapping.jl","text":"The method in SpeedMapping is performing optimization on problems without constraint equations. Lower and upper constraints set by lb and ub in the OptimizationProblem are optional.","category":"page"},{"location":"modules/Optimization/optimization_packages/speedmapping/","page":"SpeedMapping.jl","title":"SpeedMapping.jl","text":"If no AD backend is defined via OptimizationFunction the gradient is calculated via SpeedMapping's ForwardDiff AD backend.","category":"page"},{"location":"modules/Optimization/optimization_packages/speedmapping/","page":"SpeedMapping.jl","title":"SpeedMapping.jl","text":"The Rosenbrock function can be optimized using the SpeedMappingOpt() with and without bound as follows:","category":"page"},{"location":"modules/Optimization/optimization_packages/speedmapping/","page":"SpeedMapping.jl","title":"SpeedMapping.jl","text":"rosenbrock(x, p) =  (p[1] - x[1])^2 + p[2] * (x[2] - x[1]^2)^2\nx0 = zeros(2)\np  = [1.0, 100.0]\nf = OptimizationFunction(rosenbrock, Optimization.AutoForwardDiff())\nprob = OptimizationProblem(f, x0, _p)\nsol = solve(prob,SpeedMappingOpt())\n\nprob = OptimizationProblem(f, x0, _p;lb=[0.0,0.0], ub=[1.0,1.0])\nsol = solve(prob,SpeedMappingOpt())","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/#optim","page":"Optim.jl","title":"Optim.jl","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"Optim is Julia package implementing various algorithm to perform univariate and multivariate optimization.","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/#Installation:-OptimizationOptimJL.jl","page":"Optim.jl","title":"Installation: OptimizationOptimJL.jl","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"To use this package, install the OptimizationOptimJL package:","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"import Pkg; Pkg.add(\"OptimizationOptimJL\")","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/#Methods","page":"Optim.jl","title":"Methods","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"Optim.jl algorithms can be one of the following:","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"Optim.NelderMead()\nOptim.SimulatedAnnealing()\nOptim.ParticleSwarm()\nOptim.ConjugateGradient()\nOptim.GradientDescent()\nOptim.BFGS()\nOptim.LBFGS()\nOptim.NGMRES()\nOptim.OACCEL()\nOptim.NewtonTrustRegion()\nOptim.Newton()\nOptim.KrylovTrustRegion()\nOptim.ParticleSwarm()\nOptim.SAMIN()","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"Each optimizer also takes special arguments which are outlined in the sections below.","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"The following special keyword arguments which are not covered by the common solve arguments can be used with Optim.jl optimizers:","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"x_tol: Absolute tolerance in changes of the input vector x, in infinity norm. Defaults to 0.0.\ng_tol: Absolute tolerance in the gradient, in infinity norm. Defaults to 1e-8. For gradient free methods, this will control the main convergence tolerance, which is solver specific.\nf_calls_limit: A soft upper limit on the number of objective calls. Defaults to 0 (unlimited).\ng_calls_limit: A soft upper limit on the number of gradient calls. Defaults to 0 (unlimited).\nh_calls_limit: A soft upper limit on the number of Hessian calls. Defaults to 0 (unlimited).\nallow_f_increases: Allow steps that increase the objective value. Defaults to false. Note that, when setting this to true, the last iterate will be returned as the minimizer even if the objective increased.\nstore_trace: Should a trace of the optimization algorithm's state be stored? Defaults to false.\nshow_trace: Should a trace of the optimization algorithm's state be shown on stdout? Defaults to false.\nextended_trace: Save additional information. Solver dependent. Defaults to false.\ntrace_simplex: Include the full simplex in the trace for NelderMead. Defaults to false.\nshow_every: Trace output is printed every show_everyth iteration.","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"For a more extensive documentation of all the algorithms and options please consult the  Documentation","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/#Local-Optimizer","page":"Optim.jl","title":"Local Optimizer","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/optim/#Local-Constraint","page":"Optim.jl","title":"Local Constraint","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"Optim.jl implements the following local constraint algorithms:","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"Optim.IPNewton()\nlinesearch specifies the line search algorithm (for more information, consult this source and this example)\navailable line search algorithms:\nHaegerZhang\nMoreThuente\nBackTracking\nStrongWolfe\nStatic\nμ0 specifies the initial barrier penalty coefficient as either a number or :auto\nshow_linesearch is an option to turn on linesearch verbosity.\nDefaults:\nlinesearch::Function = Optim.backtrack_constrained_grad\nμ0::Union{Symbol,Number} = :auto\nshow_linesearch::Bool = false","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"The Rosenbrock function can optimized using the Optim.IPNewton() as follows:","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"rosenbrock(x, p) =  (p[1] - x[1])^2 + p[2] * (x[2] - x[1]^2)^2\ncons= (x,p) -> [x[1]^2 + x[2]^2]\nx0 = zeros(2)\np  = [1.0,100.0]\nprob = OptimizationFunction(rosenbrock, Optimization.AutoForwardDiff();cons= cons)\nprob = Optimization.OptimizationProblem(prob, x0, p, lcons = [-5.0], ucons = [10.0])\nsol = solve(prob, IPNewton())","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/#Derivative-Free","page":"Optim.jl","title":"Derivative-Free","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"Derivative-free optimizers are optimizers that can be used even in cases where no derivatives or automatic differentiation is specified. While they tend to be less efficient than derivative-based optimizers, they can be easily applied to cases where defining derivatives is difficult. Note that while these methods do not support general constraints, all support bounds constraints via lb and ub in the Optimization.OptimizationProblem.","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"Optim.jl implements the following derivative-free algorithms:","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"Optim.NelderMead(): Nelder-Mead optimizer\nsolve(problem, NelderMead(parameters, initial_simplex))\nparameters = AdaptiveParameters() or parameters = FixedParameters()\ninitial_simplex = AffineSimplexer()\nDefaults:\nparameters = AdaptiveParameters()\ninitial_simplex = AffineSimplexer()\nOptim.SimulatedAnnealing(): Simulated Annealing\nsolve(problem, SimulatedAnnealing(neighbor, T, p))\nneighbor is a mutating function of the current and proposed x\nT is a function of the current iteration that returns a temperature\np is a function of the current temperature\nDefaults:\nneighbor = default_neighbor!\nT = default_temperature\np = kirkpatrick\nOptim.ParticleSwarm()","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"The Rosenbrock function can optimized using the Optim.NelderMead() as follows:","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"rosenbrock(x, p) =  (1 - x[1])^2 + 100 * (x[2] - x[1]^2)^2\nx0 = zeros(2)\np  = [1.0,100.0]\nprob = Optimization.OptimizationProblem(rosenbrock, x0, p)\nsol = solve(prob, Optim.NelderMead())","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/#Gradient-Based","page":"Optim.jl","title":"Gradient-Based","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"Gradient-based optimizers are optimizers which utilise the gradient information based on derivatives defined or automatic differentiation.","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"Optim.jl implements the following gradient-based algorithms:","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"Optim.ConjugateGradient(): Conjugate Gradient Descent\nsolve(problem, ConjugateGradient(alphaguess, linesearch, eta, P, precondprep))\nalphaguess computes the initial step length (for more information, consult this source and this example)\navailable initial step length procedures:\nInitialPrevious\nInitialStatic\nInitialHagerZhang\nInitialQuadratic\nInitialConstantChange\nlinesearch specifies the line search algorithm (for more information, consult this source and this example)\navailable line search algorithms:\nHaegerZhang\nMoreThuente\nBackTracking\nStrongWolfe\nStatic\neta determines the next step direction\nP is an optional preconditioner (for more information, see this source)\nprecondpred is used to update P as the state variable x changes\nDefaults:\nalphaguess = LineSearches.InitialHagerZhang()\nlinesearch = LineSearches.HagerZhang()\neta = 0.4\nP = nothing\nprecondprep = (P, x) -> nothing\nOptim.GradientDescent(): Gradient Descent (a quasi-Newton solver)\nsolve(problem, GradientDescent(alphaguess, linesearch, P, precondprep))\nalphaguess computes the initial step length (for more information, consult this source and this example)\navailable initial step length procedures:\nInitialPrevious\nInitialStatic\nInitialHagerZhang\nInitialQuadratic\nInitialConstantChange\nlinesearch specifies the line search algorithm (for more information, consult this source and this example)\navailable line search algorithms:\nHaegerZhang\nMoreThuente\nBackTracking\nStrongWolfe\nStatic\nP is an optional preconditioner (for more information, see this source)\nprecondpred is used to update P as the state variable x changes\nDefaults:\nalphaguess = LineSearches.InitialPrevious()\nlinesearch = LineSearches.HagerZhang()\nP = nothing\nprecondprep = (P, x) -> nothing\nOptim.BFGS(): Broyden-Fletcher-Goldfarb-Shanno algorithm\nsolve(problem, BFGS(alpaguess, linesearch, initial_invH, initial_stepnorm, manifold))\nalphaguess computes the initial step length (for more information, consult this source and this example)\navailable initial step length procedures:\nInitialPrevious\nInitialStatic\nInitialHagerZhang\nInitialQuadratic\nInitialConstantChange\nlinesearch specifies the line search algorithm (for more information, consult this source and this example)\navailable line search algorithms:\nHaegerZhang\nMoreThuente\nBackTracking\nStrongWolfe\nStatic\ninitial_invH specifies an optional initial matrix\ninitial_stepnorm determines that initial_invH is an identity matrix scaled by the value of initial_stepnorm multiplied by the sup-norm of the gradient at the initial point\nmanifold specifies a (Riemannian) manifold on which the function is to be minimized (for more information, consult this source)\navailable manifolds:\nFlat\nSphere\nStiefel\nmeta-manifolds:\nPowerManifold\nProductManifold\ncustom manifolds\nDefaults:\nalphaguess = LineSearches.InitialStatic()\nlinesearch = LineSearches.HagerZhang()\ninitial_invH = nothing\ninitial_stepnorm = nothing\nmanifold = Flat()\nOptim.LBFGS(): Limited-memory Broyden-Fletcher-Goldfarb-Shanno algorithm\nm is the number of history points\nalphaguess computes the initial step length (for more information, consult this source and this example)\navailable initial step length procedures:\nInitialPrevious\nInitialStatic\nInitialHagerZhang\nInitialQuadratic\nInitialConstantChange\nlinesearch specifies the line search algorithm (for more information, consult this source and this example)\navailable line search algorithms:\nHaegerZhang\nMoreThuente\nBackTracking\nStrongWolfe\nStatic\nP is an optional preconditioner (for more information, see this source)\nprecondpred is used to update P as the state variable x changes\nmanifold specifies a (Riemannian) manifold on which the function is to be minimized (for more information, consult this source)\navailable manifolds:\nFlat\nSphere\nStiefel\nmeta-manifolds:\nPowerManifold\nProductManifold\ncustom manifolds\nscaleinvH0: whether to scale the initial Hessian approximation\nDefaults:\nm = 10\nalphaguess = LineSearches.InitialStatic()\nlinesearch = LineSearches.HagerZhang()\nP = nothing\nprecondprep = (P, x) -> nothing\nmanifold = Flat()\nscaleinvH0::Bool = true && (typeof(P) <: Nothing)\nOptim.NGMRES()\nOptim.OACCEL()","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"The Rosenbrock function can optimized using the Optim.LD_LBFGS() as follows:","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"rosenbrock(x, p) =  (1 - x[1])^2 + 100 * (x[2] - x[1]^2)^2\nx0 = zeros(2)\np  = [1.0,100.0]\noptprob = OptimizationFunction(rosenbrock, Optimization.AutoForwardDiff())\nprob = Optimization.OptimizationProblem(optprob, x0, p, lb=[-1.0, -1.0], ub=[0.8, 0.8])\nsol = solve(prob, NLopt.LD_LBFGS())","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/#Hessian-Based-Second-Order","page":"Optim.jl","title":"Hessian-Based Second Order","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"Hessian-based optimization methods are second order optimization methods which use the direct computation of the Hessian. These can converge faster but require fast and accurate methods for calulating the Hessian in order to be appropriate.","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"Optim.jl implements the following hessian-based algorithms:","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"Optim.NewtonTrustRegion(): Newton Trust Region method\ninitial_delta: The starting trust region radius\ndelta_hat: The largest allowable trust region radius\neta: When rho is at least eta, accept the step.\nrho_lower: When rho is less than rho_lower, shrink the trust region.\nrho_upper: When rho is greater than rhoupper, grow the trust region (though no greater than deltahat).\nDefaults:\ninitial_delta = 1.0\ndelta_hat = 100.0\neta = 0.1\nrho_lower = 0.25\nrho_upper = 0.75\nOptim.Newton(): Newton's method with line search\nalphaguess computes the initial step length (for more information, consult this source and this example)\navailable initial step length procedures:\nInitialPrevious\nInitialStatic\nInitialHagerZhang\nInitialQuadratic\nInitialConstantChange\nlinesearch specifies the line search algorithm (for more information, consult this source and this example)\navailable line search algorithms:\nHaegerZhang\nMoreThuente\nBackTracking\nStrongWolfe\nStatic\nDefaults:\nalphaguess = LineSearches.InitialStatic()\nlinesearch = LineSearches.HagerZhang()","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"The Rosenbrock function can optimized using the Optim.Newton() as follows:","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"rosenbrock(x, p) =  (1 - x[1])^2 + 100 * (x[2] - x[1]^2)^2\nx0 = zeros(2)\np  = [1.0,100.0]\nf = OptimizationFunction(rosenbrock,ModelingToolkit.AutoModelingToolkit(),x0,p,grad=true,hess=true)\nprob = Optimization.OptimizationProblem(f,x0,p)\nsol = solve(prob,Optim.Newton())","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/#Hessian-Free-Second-Order","page":"Optim.jl","title":"Hessian-Free Second Order","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"Hessian-free methods are methods which perform second order optimization by direct computation of Hessian-vector products (Hv) without requiring the construction of the full Hessian. As such, these methods can perform well for large second order optimization problems, but can require special case when considering conditioning of the Hessian.","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"Optim.jl implements the following hessian-free algorithms:","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"Optim.KrylovTrustRegion(): A Newton-Krylov method with Trust Regions\ninitial_delta: The starting trust region radius\ndelta_hat: The largest allowable trust region radius\neta: When rho is at least eta, accept the step.\nrho_lower: When rho is less than rho_lower, shrink the trust region.\nrho_upper: When rho is greater than rhoupper, grow the trust region (though no greater than deltahat).\nDefaults:\ninitial_delta = 1.0\ndelta_hat = 100.0\neta = 0.1\nrho_lower = 0.25\nrho_upper = 0.75","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"The Rosenbrock function can optimized using the Optim.KrylovTrustRegion() as follows:","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"rosenbrock(x, p) =  (1 - x[1])^2 + 100 * (x[2] - x[1]^2)^2\ncons= (x,p) -> [x[1]^2 + x[2]^2]\nx0 = zeros(2)\np  = [1.0,100.0]\noptprob = OptimizationFunction(rosenbrock, Optimization.AutoForwardDiff();cons= cons)\nprob = Optimization.OptimizationProblem(optprob, x0, p)\nsol = solve(prob, Optim.KrylovTrustRegion())","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/#Global-Optimizer","page":"Optim.jl","title":"Global Optimizer","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/optim/#Without-Constraint-Equations","page":"Optim.jl","title":"Without Constraint Equations","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"The following method in Optim is performing global optimization on problems without constraint equations. It works both with and without lower and upper constraints set by lb and ub in the Optimization.OptimizationProblem.","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"Optim.ParticleSwarm(): Particle Swarm Optimization\nsolve(problem, ParticleSwarm(lower, upper, n_particles))\nlower/upper are vectors of lower/upper bounds respectively\nn_particles is the number of particles in the swarm\ndefaults to: lower = [], upper = [], n_particles = 0","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"The Rosenbrock function can optimized using the Optim.ParticleSwarm() as follows:","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"rosenbrock(x, p) =  (p[1] - x[1])^2 + p[2] * (x[2] - x[1]^2)^2\nx0 = zeros(2)\np  = [1.0,100.0]\nf = OptimizationFunction(rosenbrock)\nprob = Optimization.OptimizationProblem(f, x0, p, lb=[-1.0, -1.0], ub=[1.0, 1.0])\nsol = solve(prob, Optim.ParticleSwarm(lower=prob.lb, upper= prob.ub, n_particles=100))","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/#With-Constraint-Equations","page":"Optim.jl","title":"With Constraint Equations","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"The following method in Optim is performing global optimization on problems with constraint equations.","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"Optim.SAMIN(): Simulated Annealing with bounds\nsolve(problem, SAMIN(nt, ns, rt, neps, f_tol, x_tol, coverage_ok, verbosity))\nDefaults:\nnt = 5\nns = 5\nrt = 0.9\nneps = 5\nf_tol = 1e-12\nx_tol = 1e-6\ncoverage_ok = false\nverbosity = 0","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"The Rosenbrock function can optimized using the Optim.SAMIN() as follows:","category":"page"},{"location":"modules/Optimization/optimization_packages/optim/","page":"Optim.jl","title":"Optim.jl","text":"rosenbrock(x, p) =  (1 - x[1])^2 + 100 * (x[2] - x[1]^2)^2\nx0 = zeros(2)\np  = [1.0,100.0]\nf = OptimizationFunction(rosenbrock, Optimization.AutoForwardDiff())\nprob = Optimization.OptimizationProblem(f, x0, p, lb=[-1.0, -1.0], ub=[1.0, 1.0])\nsol = solve(prob, Optim.SAMIN())","category":"page"},{"location":"modules/Optimization/optimization_packages/flux/#Flux.jl","page":"Flux.jl","title":"Flux.jl","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/flux/#Installation:-OptimizationFlux.jl","page":"Flux.jl","title":"Installation: OptimizationFlux.jl","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/flux/","page":"Flux.jl","title":"Flux.jl","text":"To use this package, install the OptimizationFlux package:","category":"page"},{"location":"modules/Optimization/optimization_packages/flux/","page":"Flux.jl","title":"Flux.jl","text":"import Pkg; Pkg.add(\"OptimizationFlux\")","category":"page"},{"location":"modules/Optimization/optimization_packages/flux/","page":"Flux.jl","title":"Flux.jl","text":"warn: Warn\nFlux's optimizers are soon to be deprecated by Optimisers.jl Because of this, we recommend using the OptimizationOptimisers.jl setup instead of OptimizationFlux.jl","category":"page"},{"location":"modules/Optimization/optimization_packages/flux/#Local-Unconstrained-Optimizers","page":"Flux.jl","title":"Local Unconstrained Optimizers","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/flux/","page":"Flux.jl","title":"Flux.jl","text":"Flux.Optimise.Descent: Classic gradient descent optimizer with learning rate\nsolve(problem, Descent(η))\nη is the learning rate\nDefaults:\nη = 0.1\nFlux.Optimise.Momentum: Classic gradient descent optimizer with learning rate and momentum\nsolve(problem, Momentum(η, ρ))\nη is the learning rate\nρ is the momentum\nDefaults:\nη = 0.01\nρ = 0.9\nFlux.Optimise.Nesterov: Gradient descent optimizer with learning rate and Nesterov momentum\nsolve(problem, Nesterov(η, ρ))\nη is the learning rate\nρ is the Nesterov momentum\nDefaults:\nη = 0.01\nρ = 0.9\nFlux.Optimise.RMSProp: RMSProp optimizer\nsolve(problem, RMSProp(η, ρ))\nη is the learning rate\nρ is the momentum\nDefaults:\nη = 0.001\nρ = 0.9\nFlux.Optimise.ADAM: ADAM optimizer\nsolve(problem, ADAM(η, β::Tuple))\nη is the learning rate\nβ::Tuple is the decay of momentums\nDefaults:\nη = 0.001\nβ::Tuple = (0.9, 0.999)\nFlux.Optimise.RADAM: Rectified ADAM optimizer\nsolve(problem, RADAM(η, β::Tuple))\nη is the learning rate\nβ::Tuple is the decay of momentums\nDefaults:\nη = 0.001\nβ::Tuple = (0.9, 0.999)\nFlux.Optimise.AdaMax: AdaMax optimizer\nsolve(problem, AdaMax(η, β::Tuple))\nη is the learning rate\nβ::Tuple is the decay of momentums\nDefaults:\nη = 0.001\nβ::Tuple = (0.9, 0.999)\nFlux.Optimise.ADAGRad: ADAGrad optimizer\nsolve(problem, ADAGrad(η))\nη is the learning rate\nDefaults:\nη = 0.1\nFlux.Optimise.ADADelta: ADADelta optimizer\nsolve(problem, ADADelta(ρ))\nρ is the gradient decay factor\nDefaults:\nρ = 0.9\nFlux.Optimise.AMSGrad: AMSGrad optimizer\nsolve(problem, AMSGrad(η, β::Tuple))\nη is the learning rate\nβ::Tuple is the decay of momentums\nDefaults:\nη = 0.001\nβ::Tuple = (0.9, 0.999)\nFlux.Optimise.NADAM: Nesterov variant of the ADAM optimizer\nsolve(problem, NADAM(η, β::Tuple))\nη is the learning rate\nβ::Tuple is the decay of momentums\nDefaults:\nη = 0.001\nβ::Tuple = (0.9, 0.999)\nFlux.Optimise.ADAMW: ADAMW optimizer\nsolve(problem, ADAMW(η, β::Tuple))\nη is the learning rate\nβ::Tuple is the decay of momentums\ndecay is the decay to weights\nDefaults:\nη = 0.001\nβ::Tuple = (0.9, 0.999)\ndecay = 0","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"<h1><img src=\"https://github.com/sefffal/PairPlots.jl/blob/master/images/logo.png\" width=50/> PairPlots.jl</h1>","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"This package produces corner plots, otherwise known as pair plots or scatter plot matrices: grids of 1D and 2D histograms that allow you to visualize high dimensional data.","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"Documentation: Read on JuliaHub","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"(Image: Package Downloads)","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"The defaults in this package aim to reproduce the output of the well-known Python library corner.py as closely as possible. If these are not to your tastes, this package is highly configurable (see examples below).","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"This package is curently experimental and under active development.  See also: StatsPlots.cornerplot, GeoStats.cornerplot, and CornerPlot.jl for Gadfly.","category":"page"},{"location":"modules/PairPlots/#Installation","page":"PairPlots","title":"Installation","text":"","category":"section"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"At the Julia REPL, type ] followed by add PairPlots You must also install Plots, e.g. add Plots if you have not already done so.","category":"page"},{"location":"modules/PairPlots/#Notes","page":"PairPlots","title":"Notes","text":"","category":"section"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"This pacakge is currently only tested using the GR plots backend. I recommend you save your figures as SVG or PNG.","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"If you pass additional keyword arguments to customize the appearance of the plots, it is recommended to use their canonical form e.g. seriestype instead of st, markersize instead of ms. PairPlots attempts to do the \"smart\" thing when certain combinations of keywords are present, and the shorthands might interfere with this.","category":"page"},{"location":"modules/PairPlots/#Usage","page":"PairPlots","title":"Usage","text":"","category":"section"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"using Plots, PairPlots\n\ncorner(table [, labels])","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"This function has one required argument, a Tables.jl compatible table consisting of one or more columns. This can simply be a named tuple of vectors, a DataFrame, TypedTable, result of an execute statement from SQLite, data loaded from Arrow, etc.","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"The variable names are by default taken from the column names of the input table, but can also be supplied by a second vector of strings.","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"This package uses RecipesBase rather than Plots directly, so you must also load Plots in order to see any output. The package is only tested with GR.","category":"page"},{"location":"modules/PairPlots/#Examples","page":"PairPlots","title":"Examples","text":"","category":"section"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"Basics:","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"using Plots, PairPlots\ngr()\n\n# Generate some data to visualize\nN = 100_000\na = [2randn(N÷2) .+ 6; randn(N÷2)]\nb = [3randn(N÷2); 2randn(N÷2)]\nc = randn(N)\nd = c .+ 0.6randn(N)\n\n# Pass data in a format compatible with Tables.jl\n# Here, simply a named tuple of vectors.\ntable = (;a, b, c, d)\n\ncorner(table)","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"<img src=\"https://github.com/sefffal/PairPlots.jl/blob/master/images/basic.png\" width=350/>","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"Single variable fallback:","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"corner((;d))","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"<img src=\"https://github.com/sefffal/PairPlots.jl/blob/master/images/single-variable.png\" width=150/>","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"Basic scatter plot:","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"corner(table, plotcontours=false, filterscatter=false)","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"<img width=\"531\" alt=\"image\" src=\"https://user-images.githubusercontent.com/7330605/146047141-75de3bcb-bede-4996-b8dc-517d50eb995e.png\">","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"Appearance:","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"theme(:dark) # See PlotThemes.jl included with Plots.\ncorner(\n    table,\n    hist2d_kwargs=(;color=:magma),\n    hist_kwargs=(;color=:white,titlefontcolor=:white),\n    scatter_kwargs=(;color=:white);\n    percentiles_kwargs=(;color=:white),\n)","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"<img src=\"https://github.com/sefffal/PairPlots.jl/blob/master/images/themed.png\" width=350/>","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"Enlarging one subplot with lens:","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"# Plot a 1D histogram\ncorner(table, lens=:a)\n\n# Plot a 2D histogram\ncorner(table, lens=(:b, :a))\n\n# Plot a 2D histogram with customization\ncorner(\n    table,\n    lens=(:b, :a),\n    lens_kwargs=(\n        title=\"b - a heatmap\",\n        plotscatter=false,\n        hist2d_kwargs=(;color=:plasma),\n        contour_kwargs=(;color=:white)\n    )\n)","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"(Image: )","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"Adding an extra unrelated subplot with bonusplot:","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"f(kw)=heatmap!(rand(10,10); kw...)\ncorner((;a,b,c,d,e=a), title=\"Corner Plot\", bonusplot=f)","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"The syntax for this is a little tricky due to API limitations. the bonusplot argument accepts a function that overplots your desired plot, and must accept a named tuple of keyword arguments to forward to the plotting function. This is necessary for the layout to work as expected.","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"Minimal look:","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"a = randn(100000); b = randn(100000) .+ a; c = 4randn(100000) .+ a\n\ncorner((;a,b,c), hist_kwargs=(;title=\"\"), appearance=(;framestyle=:grid, ticks=[]), plotpercentiles=[])","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"<img src=\"https://github.com/sefffal/PairPlots.jl/blob/master/images/minimal.png\" width=350/>","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"3D wireframe and line plots:","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"α=[randn(50000); 0.5randn(50000).+4]\nβ=2randn(100000)\n\ncorner(\n    (;α,β),\n    [raw\"\\alpha\", raw\"\\beta\"],\n    hist2d_kwargs=(;seriestype=:wireframe),\n    plotscatter=false,\n    dpi=200\n)","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"<img src=\"https://github.com/sefffal/PairPlots.jl/blob/master/images/3d-mesh-2.png\" width=300/>","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"theme(:solarized);\n corner(\n    (;a,b), filterscatter=false,\n    hist2d_kwargs=(;seriestype=:wireframe,color=:white,nbins=35),\n    hist_kwargs=(;color=:lightgrey,titlefontcolor=:white,seriestype=:line, linewidth=3),\n    scatter_kwargs=(;color=:grey);\n    percentiles_kwargs=(;color=:grey),\n)","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"<img src=\"https://github.com/sefffal/PairPlots.jl/blob/master/images/3d-mesh.png\" width=300/>","category":"page"},{"location":"modules/PairPlots/#Full-API","page":"PairPlots","title":"Full API","text":"","category":"section"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"corner(table [, labels]; plotcontours, plotscatter, plotpercentiles, hist_kwargs, hist2d_kwargs, contour_kwargs, scatter_kwargs, percentiles_kwargs, appearance)","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"The corner function also accepts the following keyword arguments:","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"plotcontours=true: Overplot contours on each 2D histogram\nplotscatter=true: Plot individual data points under the histogram to reveal outliers. Disable to improve performance on large datasets.\nplotpercentiles=[15,50,84]: What percentiles should be used for the vertical lines in the 1D histogram. Pass an empty vector to hide.\nhistfunc: a function to override the calculation of the 1D and 2D histograms. See below.\nhist_kwargs=(;): plot keywords for the 1D histograms.\nhist2d_kwargs=(;): plot keywords for the 2D histograms.\ncontour_kwargs=(;): plot keywords for the contours plotted over the 2D histograms.\nscatter_kwargs=(;): plot keywords for the data points scattered under the 2D histograms. \npercentiles_kwargs=(;): plot keywords for the vertical percentile lines on the 1D histograms. \nappearance=(;): General keywords for all subplots.\ntitlefmt=\"\\$%s = %.2f^{+%.2f}_{-%.2f}\\$\": Printf format string for titles along the 1D histograms","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"Remaining keyword arguments are forwarded to the main plot that holds the all of the subplots. For example, passing size=(1000,1000) sets the size of the overall figure not each individual subplot.","category":"page"},{"location":"modules/PairPlots/#MCMCChains","page":"PairPlots","title":"MCMCChains","text":"","category":"section"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"MCMCChains.MCMCChain values can be passed directly to corner. In this case, the fields :iteration and :chain are filtered out automatically and all chains are concatenated. ","category":"page"},{"location":"modules/PairPlots/#histfunc","page":"PairPlots","title":"histfunc","text":"","category":"section"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"If you wish to calculate the histograms yourself, you can provide a callback function with two methods: one to calculate the 1D histograms along the diagonal, and another to calculate the 2D histograms.","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"Example:","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"function myhist(a, nbins)\n    ...\n    return bin_centres, weights\nend\nfunction myhist(a,b,nbins)\n    ...\n    return bin_centres_x, bin_centres_y, weights\nend\n\ncorner(data, histfunc=myhist)","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"The methods must return the bin centres rather than edges, followed by the histogram weights. You must override both the 1D and 2D cases, or neither. If you don't want to change the behaviour, you can simply forward the arguments to PairPlots.prepare_hist, the default value.","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"function myhist(a, nbins)\n    ...\n    return bin_centres, weights\nend\nmyhist(a,b,nbins) = PairPlots.prepare_hist(a,b,nbins)\ncorner(data, histfunc=myhist)","category":"page"},{"location":"modules/PairPlots/#Credits","page":"PairPlots","title":"Credits","text":"","category":"section"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"This package is built on top of the great packages Plots, GR, RecipesBase, NamedTupleTools, and Tables. The overall inspiration and a few peices of code are taken directly from corner.py, whose authors IMO should be cited if you use this pacakge.","category":"page"},{"location":"modules/PairPlots/#TODO:","page":"PairPlots","title":"TODO:","text":"","category":"section"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"Support for colouring individual chains separately when using MCMCChains","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"<img height=150 src=\"docs/src/assets/logo.png\"/>","category":"page"},{"location":"modules/PlanetOrbits/#PlanetOrbits.jl","page":"PlanetOrbits","title":"PlanetOrbits.jl","text":"","category":"section"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"(Image: ) (Image: codecov)","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"Tools for solving Keplerian orbits in the context of direct imaging. The primary use case is mapping Keplerian orbital elements into Cartesian coordinates at different times. A Plots.jl recipe is included for easily plotting orbits.","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"Among other values, it calculates the projected positions of planets, as well as stellar radial velocity and proper motion anomaly. It's a great tool for visualizing different orbits (see examples) and generating nice animations (e.g. with Plots or Luxor.jl).","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"This package has been designed for good performance and composability with a wide range of packages in the Julia ecosystem, including ForwardDiff. ","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"To fit orbits to observations, see DirectDetections.jl.","category":"page"},{"location":"modules/PlanetOrbits/#Usage","page":"PlanetOrbits","title":"Usage","text":"","category":"section"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"using PlanetOrbits\n\n# See below for units and conventions on these parameters.\nelements = KeplerianElementsDeg(a=1, i=45, e=0.25, τ=0, M=1, ω=0, Ω=120, plx=35)\n\n# Display one full period of the orbit (run `using Plots` first)\nusing Plots\nplot(elements, label=\"My Planet\")","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"(Image: Orbit Plot)","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"Note that by default the horizontal axis is flipped to match how it would look in the sky. The horizontal coordinates generated by these functions are not flipped in this way. If you use these coordinates to sample an image, you will have to either flip the image or negate the x coordinate.","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"If you have an array of hundreds or thousands of orbits you want to visualize, just pass that array to plot. The opacity of the orbits will be reduced an appropriate amount.","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"Get projected cartesian coordinates in milliarcseconds at a given epoch:","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"julia> soln = orbitsolve(elements, 1.0) # at t time in modified julian days \njulia> raoff(soln) # Access components of the solution\njulia> raoff(elements, 1.0) # Or compute just one component directly","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"There are many convenience functions, including:","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"period(elements):  period of a the companion in days.\ndistance(elements):  distance to the system in pc\nmeanmotion(elements): mean motion about the primary in radians/yr\nprojectedseparation(elements, t): given orbital elements and a time, the projected separation between the primary and companion\nraoff(elements, t): as above, but only the offset in Right Ascension (milliarcseconds)\ndecoff(elements, t): as above, but only the offset in declination (milliarcseconds)\nradvel: radial velocity in m/s of the planet or star (see docstring)\npropmotionanom: proper motion anomaly of the star due to the planet in milliarseconds / year","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"Showing an orbital elements object at the REPL will print a useful summary like this:","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"julia> elements\nKeplerianElements{Float64}\n─────────────────────────\na   [au ] = 1.0\ni   [°  ] = 45.0\ne         = 0.25\nτ         = 0.0\nM   [M⊙ ] = 1.0\nω   [°  ] = 0.0\nΩ   [°  ] = 120.0\nplx [mas] = 35.0\n──────────────────────────\nperiod      [yrs ] : 1.0\ndistance    [pc  ] : 28.6\nmean motion [°/yr] : 360.0","category":"page"},{"location":"modules/PlanetOrbits/#Units-and-Conventions","page":"PlanetOrbits","title":"Units & Conventions","text":"","category":"section"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"The main constructor, KeplerianElements, accepts the following parameters:","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"a: Semi-major axis in astronomical units (AU)\ni: Inclination in radians\ne: Eccentricity in the range [0, 1)\nτ: Epoch of periastron passage, in fraction of orbit [0,1]\nM: Graviataion parameter of the central body, expressed in units of Solar mass.\nω: Argument of periastron\nΩ: Longitude of the ascending node, radians.\nplx: Distance to the system expressed in milliarcseconds of parallax.","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"Thee parameter τ represents the epoch of periastron passage as a  fraction of the planet's orbit between 0 and 1. This follows the same convention as Orbitize! and you can read more about their choice in ther FAQ.","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"Parameters can either be specified by position or as keyword arguments (but not a mix). Positional  arguments are recommended if you are creating objects in a tight loop.","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"There is also a convenience constructor KeplerianElementsDeg that accepts i, ω, and Ω in units of degrees instead of radians.","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"See this diagram from Wikipedia as a reference for the conventions used by this package (note ♈︎ is replaced by the celestial North pole). <!– ","category":"page"},{"location":"modules/PlanetOrbits/#Image-Warping","page":"PlanetOrbits","title":"Image Warping","text":"","category":"section"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"If you have an image of a system, you can warp the image as if each pixel were a test particle following Kepler's laws.  This is an easy way to see what a disk or a system of planets would look like at a time other than when it was captured.","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"To make this possible, PlanetOrbits.jl can create OrbitalTransformation objects. These follow the conventions set out in CoordinateTransformations.jl and are compatible with ImageTransformations.jl.","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"Example:","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"ot = OrbitalTransformation(\n    i = 0.3,\n    e = 0.1,\n    M = 1.0,\n    ω = 0.5,\n    Ω = 0.5,\n    plx = 30.0,\n    \n    platescale=10.0, # mas/px\n    dt = 3*365.25 # days forward in time\n)\n\nimg_centered = centered(img)\nimg_future = warp(img_centered, ot, axes(i))\n\n# Display with DirectImages.jl\nusing DirectImages\nimshow2([img; img_future], clims=(0,1), cmap=:seaborn_icefire_gradient)","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"Before, and After Orbital Transformation<br> (Image: image)","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"Note the arguments platescale and dt are required, but a and τ are not. The position of the pixel in X/Y space uniquely determines the semi-major axis and epoch of periastron passage when the rest of the orbital parameters are known. platescale in units of milliarseconds/pixel is necessary to get the overall scale of the transform correct. This is because an orbital transformation is not linear (and therefore, care must be taken when composing an OrbitalTransformation with other CoordinateTransformations). Scaling an image will change the amount of rotation that occurs at each separation. dt is the the amount of time in days to project the image forward. It can also be negative to project the image into the past.   –>","category":"page"},{"location":"modules/PlanetOrbits/#Makie-Recipe","page":"PlanetOrbits","title":"Makie Recipe","text":"","category":"section"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"There is a basic Makie plot recipe that allows you to plot a KeplerianElements:","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"using CairoMakie\nelements = KeplerianElementsDeg(a=1, i=45, e=0.25, τ=0, M=1, ω=0, Ω=120, plx=35)\nlines(elements, axis=(;autolimitaspect=1, xreversed=true))","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"Note that for Makie, you will have to reverse the x-axis manually whereas in Plots.jl it is set automatically.","category":"page"},{"location":"modules/PlanetOrbits/#Installation","page":"PlanetOrbits","title":"Installation","text":"","category":"section"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"This package is not in the General registery, but a personal registry for this and related packages. To install it, first add the DirectRegistry containing this, and other related packages:","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"(] to enter Pkg mode)","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":" pkg> registry add https://github.com/sefffal/DirectRegistry\n pkg> add PlanetOrbits","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"That's it! If you want to run it through a gauntlet of tests, type ] followed by test PlanetOrbits","category":"page"},{"location":"modules/PlanetOrbits/#Performance","page":"PlanetOrbits","title":"Performance","text":"","category":"section"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"On my 2017 Core i7 laptop, this library is able to calculate a projected position from a set of orbital elements in just 48ns (circular orbit) or 166ns (eccentric).","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"All the helper functions should work without any heap allocations when using standard numeric types.","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"Several parameters are pre-calculated when creating a KeplerianElements object. There is therefore a slight advantage to re-use the same object if you are sampling many positions from the same orbital elements (but we are only talking nanoseconds either way).","category":"page"},{"location":"modules/PlanetOrbits/#Numerical-Derivatives","page":"PlanetOrbits","title":"Numerical Derivatives","text":"","category":"section"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"This package works well with the autodiff package ForwardDiff.jl. For example:","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"using ForwardDiff\nForwardDiff.derivative(t -> radvel(elements, t), 123.0)","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"This has only a negligible overhead (maybe 15%) compared to calculating the value itself. If you need access to both the value and the derivative, I recommend you use the DiffResults package to calculate both at once for a 2x speedup:","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"using DiffResults\ng = let elements=elements\n    t -> raoff(elements, t)\nend\n\n# Set the result type\nresult_out = DiffResults.DiffResult(1.0,1.0)\n\n# Calculate both the value and derivative at once\n@btime res = ForwardDiff.derivative!($result_out, $g, 1.0)\n#  205.487 ns (0 allocations: 0 bytes)\n\n# Access each\nrv = DiffResults.value(res)\ndrvdt = DiffResults.derivative(res, Val{1})","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"The Zygote reverse diff package does not currently work with PlanetOrbits.jl. <!– ","category":"page"},{"location":"modules/PlanetOrbits/#Calculating-orbits-on-a-GPU","page":"PlanetOrbits","title":"Calculating orbits on a GPU","text":"","category":"section"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"Using the CUDA and StructArray packages, you can easily calculate ensembles of orbits on the GPU.","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"For example:","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"using PlanetOrbits\nusing StructArrays\nusing CUDA\n\n# Create a vector of different initial conditions\nelements = [KeplerianElementsDeg(\n    a=1.0,\n    i=45.,\n    e=0.1,\n    τ=0,\n    ω=20,\n    Ω=10,\n    plx=50,\n    M=3.0,\n) for a in 1:0.01:10000]\n\n# Convert the storage to a struct array instead of array of structs.\nelements_sa = StructArray(elements)\n# Send to GPU\nelements_cusa = replace_storage(CuArray, elements_sa)\n\n# Allocate output storage\nout = zeros(length(elements_sa)) # CPU\nout_cu = CUDA.zeros(length(elements_cusa)) # GPU\n\n# Calculate the radial velocity of each orbit at time zero\n@time            out .= radvel.(elements_sa, 0.0) # CPU\n@time CUDA.@sync out_cu .= radvel.(elements_cusa, 0.0) # GPU","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"On my laptop's pitiful GPU, the timing for the GPU calculation is still 17 times faster than on the CPU. –>","category":"page"},{"location":"modules/OIFITS/#OIFITS.jl","page":"OIFITS","title":"OIFITS.jl","text":"","category":"section"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"License Build Status Code Coverage\n[![][license-img]][license-url] [![][travis-img]][travis-url] [![][appveyor-img]][appveyor-url] [![][coveralls-img]][coveralls-url] [![][codecov-img]][codecov-url]","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"The OIFITS.jl package provides support for OI-FITS data in Julia language.","category":"page"},{"location":"modules/OIFITS/#OI-FITS-types","page":"OIFITS","title":"OI-FITS types","text":"","category":"section"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"OI-FITS is a standard to store optical interferometry data as a collection of data-blocks.  In the second revision of the standard (see Ref. 1 and Ref. 2), an OI-FITS file may contain the following data-blocks:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"an OI_TARGET data-block stores a list of observed targets;\neach OI_ARRAY data-block describes a given array of telescope stations;\neach OI_WAVELENGTH data-block describes a given instrument notably the effective wavelengths and bandwidths of its spectral channels;\nOI_CORR data-blocks store correlation data;\nOI_VIS data-blocks store complex visibility dat;\nOI_VIS2 data-blocks store squared visibility (powerspectrum) data;\nOI_T3 data-blocks store triple product (bispectrum) data;\nOI_FLUX data-blocks store spectral flux data;\nOI_INSPOL data-blocks store instrumental polarization data.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"These data-blocks, are stored as binary tables in a FITS data file.  The support for FITS files is provided by the FITSIO.jl package.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"The julia type of an OI-FITS data-block is named as the corresponding OI-FITS extension. In addition to these types for individual OI-FITS data-blocks, the OIFITS.jl package provides data-sets (of type OIDataSet) that contain several OI-FITS data-blocks. Each data-set is an efficient representation of the contents of a compliant OI-FITS file.","category":"page"},{"location":"modules/OIFITS/#Reading-and-writing-OI-FITS-files","page":"OIFITS","title":"Reading and writing OI-FITS files","text":"","category":"section"},{"location":"modules/OIFITS/#Reading-and-writing-OI-FITS-data-sets","page":"OIFITS","title":"Reading and writing OI-FITS data-sets","text":"","category":"section"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Reading an OI-FITS data file in Julia yields a data-set and is done by:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"using OIFITS\nds = read(OIDataSet, input)","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"where input it the name of the OI-FITS file or an instance of FITSIO.FITS which represents an open FITS file.  The above read call is equivalent to the shortcut:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"ds = OIDataSet(input)","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"It is possible to merge the contents of several OI-FITS file, say inp1, inp2, etc., by one of:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"ds = read(OIDataSet, inp1, inp2, ...)\nds = OIDataSet(inp1, inp2, ...)","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"or to merge them into an existing data-set ds:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"read!(ds, inp1, inp2, ...)","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Creating an OI-FITS file is as simple as writing the data-set ds:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"write(filename, ds)","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Overwriting is forbidden by default, but the keyword overwrite=true may be specified to allow for silently overwriting an existing file.","category":"page"},{"location":"modules/OIFITS/#Reading-individual-OI-FITS-data-blocks","page":"OIFITS","title":"Reading individual OI-FITS data-blocks","text":"","category":"section"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"It may be useful to read individual OI-FITS data-blocks, to debug or to fix the contents of a non-compliant OI-FITS file.  To that end, you must open the FITS file and can then read a given HDU as an OI-FITS data-block:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"using FITSIO, OIFITS\nf = FITS(filename, \"r\")     # open FITS file for reading\ntgt = OI_TARGET(f[i])       # read OI_TARGET extension in i-th HDU\ntgt = read(OI_TARGET, f[i]) # idem\ndb = OI_VIS2(f[j])          # read OI_VIS2 extension in j-th HDU\ndb = read(OI_VIS2, f[j])    # idem\n...","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"any OI-FITS data-block type can be used in that way.  If the type of the i-th extension is not known, OIDataBlock can be used instead but the result is not type-stable:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"db = OIDataBlock(f[i])       # read OI-FITS extension extension in i-th HDU\ndb = read(OIDataBlock, f[i]) # idem","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Writing individual OI-FITS data-blocks is also possible:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"using FITSIO, OIFITS\nf = FITS(filename, \"w\") # open FITS file for writing\nwrite(f, db)            # write db in the next HDU of f","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"To fix a non-compliant OI-FITS file (usually dupplicate target or instarument names), you can read all the data-blocks, fix those which are wrong and push them in order in an OIDataSet to have a consistent data-set which you can then directly use or write in an OI-FITS file for later.  Thanks to the automatic rewriting of target identifiers and of the fact that targets (and other dependencies) are identified by their name and consistently merged, it is possible to push an OI_TARGET with multiply defined identical targets (apart maybe their identifiers).","category":"page"},{"location":"modules/OIFITS/#Accessing-the-contents-of-data-blocks-and-data-sets","page":"OIFITS","title":"Accessing the contents of data-blocks and data-sets","text":"","category":"section"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"The contents of OI-FITS data-blocks and data-sets may be accessed by the dot notation but also by indexation.","category":"page"},{"location":"modules/OIFITS/#Contents-of-data-sets","page":"OIFITS","title":"Contents of data-sets","text":"","category":"section"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"The dot notation can be used on a data-set object, say ds, storing a consistent set of OI-FITS data-blocks.  The following properties are available:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"ds.target is the OI_TARGET data-block of the OI-FITS structure.\nds.instr is a list of OI_WAVELENGTH data-blocks indexed by a regular integer index or by the instrument name:\nds.instr[i]       # yields the i-th OI_WAVELENGTH data-block\nds.instr[insname] # yields the OI_WAVELENGTH data-block whose name matches insname\nMatching of names follows FITS conventions that case of letters and trailing spaces are ignored.  An exception is thrown if the index (integer or name) is not valid.  The get method can be used to provide a default value, for example:\nget(ds.instr, insname, nothing)\nwould yield nothing if insname is not found in ds.instr instead of throwing an exception.\nds.array is a list of OI_ARRAY data-blocks indexed like ds.instr except that interferometric array names are assumed.\nds.correl is a list of OI_CORR data-blocks indexed like ds.instr except that correlation data array names are assumed.\nds.vis is a vector of OI_VIS data-blocks.\nds.vis2 is a vector of OI_VIS2 data-blocks.\nds.t3 is a vector of OI_T3 data-blocks.\nds.flux is a vector of OI_FLUX data-blocks.\nds.inspol is a vector of OI_INSPOL data-blocks.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Other fields of data-sets shall be considered as private and not accessed directly.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Using the dot notation, it is easy to access to the different data-blocks containing measurements.  For instance:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"for db in ds.vis2\n    ...\nend","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"is convenient to loop across all OI_VIS2 instances stored by ds.","category":"page"},{"location":"modules/OIFITS/#Contents-of-data-blocks","page":"OIFITS","title":"Contents of data-blocks","text":"","category":"section"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"The contents of a data-block, say db, may also be accessed by the dot notation.  As a general rule, db.key or db.col yield the value of the keyword key or the contents of the column col of the OI-FITS table corresponding to the data-block db.  In order to follow Julia conventions and to accommodate for a number of restrictions, key or col are the FITS keyword or column name converted to lower case letters and with non-alphanumeric letters replaced by underscores.  For instance db.date_obs yields the value of the keyword DATE-OBS, that is the UTC start date of observations.  The revision number corresponding to the keyword OI_REVN is however accessed as db.revn, this is the only exception.  Other properties are also accessible via this syntax:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"db.extname yields the OI-FITS name of the extension corresponding to the data-block db (for all data-block types);\ndb.array yields the OI_ARRAY data-block associated with data-block db (only for OI_VIS, OI_VIS2, OI_T3, OI_FLUX, and OI_INSPOL data-block).  Beware that the association with an OI_ARRAY is optional, so db.array may be actually undefined; this can be checked by isdefined(db,:array).\ndb.instr yields the OI_WAVELENGTH data-block associated with data-block db (only for OI_VIS, OI_VIS2, OI_T3, and OI_FLUX data-block).\ndb.correl yields the OI_CORR data-block associated with data-block db (only for OI_VIS, OI_VIS2, OI_T3, and OI_FLUX data-block).\ndb.name is an alias for db.arrname for OI_ARRAY instances, for db.insname for OI_WAVELENGTH instances, and for db.corrname for OI_CORR instances.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Of course, getting a given property must make sense.  For example, db.sta_name is only possible for an OI_ARRAY data-block but not for an OI_WAVELENGTH data-block.  The dot notation can be however be chained and:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"db.instr.eff_wave","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"can be used to access the effective wavelengths of the measurements in db via the instrument associated to db.  Shortcuts are provided:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"λ  = db.eff_wave # get effective wavelength\nΔλ = db.eff_band # get effective bandwidth","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"for OI_WAVELENGTH data-blocks but also for OI_VIS, OI_VIS2, OI_T3, and OI_FLUX data-blocks.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Some fields of a data-block db may however be undefined because:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"the field is not yet defined (the data-block is being constructed);\nthe field is optional in the revision db.revn of the data-block;\nthe field (for example db.instr for an OI_VIS data-block) involves links with other data-blocks (the dependencies) and these links are only defined when a data-block is part of a data-set (see Building of data-sets below).","category":"page"},{"location":"modules/OIFITS/#OI_TARGET-data-blocks","page":"OIFITS","title":"OI_TARGET data-blocks","text":"","category":"section"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"For efficiency, instances of OI_TARGET data-blocks do not follow the same rules as other types of OI-FITS data-blocks whose properties are the columns of the corresponding OI-FITS table: in an OI_TARGET instance, all parameters describing a target are repesented by an OITargetEntry structure and all targets are stored as a vector of OITargetEntry.  An OI_TARGET instance, say db, has the 3 following properties:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"db.extname # yields \"OI_TARGET\"\ndb.list    # yields a vector of OITargetEntry instances\ndb.revn    # yields the revision number","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"The list of targets db.list can be indexed by an integer (as any Julia vector) or by the target name (case of letters and trailing spaces are irrelevant).","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"As an OI_TARGET data-blocks is essentially a vector of target entries, it can be used as an iterable and it can indexed by an integer index or by a target name:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"length(db) # the number of targets, shortcut for `length(db.list)`\ndb[i]      # the i-th target, shortcut for `db.list[i]`\ndb[key]    # the target whose name matches string `key`, shortcut for `db.list[key]`","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Standard methods get and haskey, applied to db.list or directly to db, work as expected and according to the type (integer or string) of the key.  For the keys method, the default is to return an iterator over the target names, but the type of the expected keys can be specified:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"get(db,key,def)   # yields `db[key]` or `def` if `key` not found\nkeys(db)          # iterator over target names\nkeys(String, db)  # idem\nkeys(Integer, db) # iterator over target indices\nkeys(Int, db)     # idem","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"The method OIFITS.get_column is a helper to recover a single target field as a vector:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"OIFITS.get_column([T,] db, col)","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"yields the column col of an OI-FITS data-block db.  Column is identified by col which is either sym or Val(sym) where sym is the symbolic name of the corresponding field in OITargetEntry.  Optional argument T is to specify the element type of the returned array.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"To build an OI_TARGET instance, you may provide the list of targets and the revision number:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"OI_TARGET(lst=OITargetEntry[]; revn=0)","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"yields an OI_TARGET data-block.  Optional argument lst is a vector of OITargetEntry specifying the targets (none by default).  Keyword revn specifies the revision number.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"A target entry may be constructed by specifying all its fields (there are many) by keywords, all of which but category are mandatory:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"x = OITargetEntry(;\n        target_id ::Integer,\n        target    ::AbstractString,\n        raep0     ::AbstractFloat,\n        decep0    ::AbstractFloat,\n        equinox   ::AbstractFloat,\n        ra_err    ::AbstractFloat,\n        dec_err   ::AbstractFloat,\n        sysvel    ::AbstractFloat,\n        veltyp    ::AbstractString,\n        veldef    ::AbstractString,\n        pmra      ::AbstractFloat,\n        pmdec     ::AbstractFloat,\n        pmra_err  ::AbstractFloat,\n        pmdec_err ::AbstractFloat,\n        parallax  ::AbstractFloat,\n        para_err  ::AbstractFloat,\n        spectyp   ::AbstractString,\n        category  ::AbstractString = \"\")","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"It is also possible to specify another target entry, say ref, which is used as a template: any unspecified keyword is assume to have the same value as in ref:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"x = OITargetEntry(ref;\n        target_id = ref.target_id,\n        target    = ref.target,\n        ...)","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Note that, when an OI_TARGET instance is pushed in a data-set, target identifiers (field target_id) are automatically rewritten to be identical to the index in the list of targets of the data-set.","category":"page"},{"location":"modules/OIFITS/#Building-of-data-sets","page":"OIFITS","title":"Building of data-sets","text":"","category":"section"},{"location":"modules/OIFITS/#Pushing-data-blocks-to-data-sets","page":"OIFITS","title":"Pushing data-blocks to data-sets","text":"","category":"section"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Reading an OI-FITS file is the easiest way to define a data-set but a new OI-FITS data-set may be built by creating an empty data-set with OIDataSet(), and then pushing OI-FITS data-blocks in order with push!(...).  Indeed, in order to ensure the consistency of a data-set, it is required to push the dependencies (OI_TARGET, OI_ARRAY, OI_WAVELENGTH, and OI_CORR data-blocks) before the data-blocks containing measurements (OI_VIS, OI_VIS2, OI_T3, OI_FLUX, and OI_INSPOL) that may refer to them.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"For example, building a new data-set, say ds, looks like:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"ds = OIDataSet() # create empty data-set\npush!(ds, arr)   # push OI_ARRAY data-block(s)\npush!(ds, ins)   # push OI_WAVELENGTH data-block(s)\npush!(ds, cor)   # push OI_CORR data-block(s)\npush!(ds, tgt)   # push OI_TARGET data-block\npush!(ds, db1)   # push data\npush!(ds, db2)   # push more data\npush!(ds, db3)   # push even more data\n...","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"with the dependencies:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"arr an OI_ARRAY instance defining the interferometric array (zero or any  number of such instances may be pushed),\nins an OI_WAVELENGTH instance defining the instrument (several such  instances can be pushed),\ncor an OI_COORREL instance defining the correlations (zero or any number  of such instances can be pushed),\ntgt an OI_TARGET instance defining the list of observed targets (at least one such instance is required, if more such instances are pushed in the same data-set, they are merged in a single one);","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"and where db1, db2, db3, etc., are instances of OI_VIS, OI_VIS2, OI_T3, OI_FLUX, or OI_INSPOL that provide measurements.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"You may push all data-blocks in a single push! call:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"ds = push!(OIDataSet(), arr, ins, cor, tgt, d1, db2, ...)","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"and the following shortcut is implemented:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"ds = OIDataSet(arr, ins, cor, tgt, d1, db2, ...)","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"These two are equivalent to the multi-line example above, but remember that pushing data-blocks in order (i.e., dependencies before they may be referenced) is required to have a consistent data-set.  Apart from this constraint, dependencies may be pushed in any order before the data-blocks with measurements and data-blocks with measurements can be be pushed in any order after dependencies.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"As a benefit of the constraint of pushing data-blocks in order, data-blocks with dependencies are automatically linked to these dependencies when pushed on the data-set (which implies that the dependencies already exist in the data-set).  This allows for syntaxic sugar like:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"ds.vis2[i].eff_wave # the wavelengths of the i-th OI_VIS2 data-block in ds\nds.t3[i].array      # the interferometric array for the i-th OI_T3 data-block in ds\nds.vis[i].instr     # the instrument used for the i-th OI_VIS data-block in ds","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Without linked dependencies, the first above example would require to (1) find in the data-set ds the OI_WAVELENGTH instance, say ins, whose name is matching ds.vi2[i].insname and (2) extract the field eff_wave of ins. The latter step is as simple as ins.eff_wave but the former one has some overheads and scales as O(n) with n the number of OI_WAVELENGTH instances in the data-set.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Since an OI-FITS data-set has a single list of targets (an OI_TARGET instance accessible via ds.target), a mean to merge list of targets had to de defined. The adopted rule is pretty simple:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"The target_id field of any data-block that is part of a data-set corresponds to the index of the target entry in the list of targets stored by the data-set.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"As a consequence, whenever a data-block is pushed into a data-set, the target identifiers of the data-block have to be rewritten according to this rule.  Of course this does not apply for data-blocks with no target_id field such as OI_ARRAY, OI_WAVELENGTH, and OI_CORR.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"To summarize, here is what happens under the hood when a data-block db is pushed into a data-set ds:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"When an OI_ARRAY, OI_WAVELENGTH, or OI_CORR instance db is pushed in a data-set ds, it is appended to the corresponding list (ds.array, ds.instr, or ds.correl) unless this list already has an entry with a name matching db.name.  In this latter case, nothing is done unless that an assertion exception is thrown if the two data-blocks whose names are matching do not have the same contents (to prevent building inconsistent data-sets).\nWhen an OI_TARGET instance is pushed in a data-set, the new targets (according to their names) are appended to the list of targets in the data-set and their identifiers set to their index in this list.  This also re-initializes an internal dictionary used to perform the conversion from all the target identifiers of the OI_TARGET instance that has been pushed to the target identifiers in the data-set.  Until it is reinitialized (by pushing another OI_TARGET instance), this mapping is used to rewrite the target identifiers of subsequent data-blocks pushed in the data-set.\nWhen an OI_VIS, OI_VIS2, OI_T3, OI_FLUX, or OI_INSPOL instance db is pushed in a data-set ds, it is appended to the corresponding list (ds.vis, ds.vis2, db.t3, db.flux, or ds.inspol), after it has been linked to its dependencies (OI_ARRAY, OI_WAVELENGTH, etc., which must already exist in the data-set), and its target identifiers have been rewritten according to the mapping defined by the last OI_TARGET instance previously pushed to the data-set.  Rewriting of the target identifiers may be avoided by using the keyword rewrite_target_id=false, this assumes that the target identifiers in the pushed data-block are already set according to the index in the list of targets ds.target.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Pushing a data-block in a data-set does check the consistency of the data-block.  This is to allow for building the data-blocks step by step so that they not need to be consistent at all times (just when pushed into a data-set).","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Pushing a data-block in a data-set lefts the data-block unchanged.  A swallow copy of it is added to the data-blocks stored by the data-set.  Most members of the pushed data-blocks are shared by the one stored by the data-set whith the notable exception of the target identifiers which are rewritten and the links to the dependencies which are updated.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"While it sounds complicated, the default rule of rewriting the target identifiers just amounts to assuming that the target identifiers of OI_VIS, OI_VIS2, OI_T3, OI_FLUX, or OI_INSPOL instances pushed in a data-set refer to the last OI_TARGET instance previously pushed on the same data-set.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Pushing several groups of data-blocks, each group making a consistent data-set, in the same data-set is easy.  Typically:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"# First push dependencies for group 1.\npush!(ds, group1_arr) # push OI_ARRAY\npush!(ds, group1_ins) # push OI_INS\npush!(ds, group1_cor) # push OI_CORR\npush!(ds, group1_tgt) # push OI_TARGET (reinitializing target_id mapping)\n# Then push data for group 1 (using current target_id mapping).\npush!(ds, group1_db1)\npush!(ds, group1_db2)\n...\n# First push dependencies for group 2.\npush!(ds, group2_arr) # push OI_ARRAY\npush!(ds, group2_ins) # push OI_INS\npush!(ds, group2_cor) # push OI_CORR\npush!(ds, group2_tgt) # push OI_TARGET (reinitializing target_id mapping)\n# Then push data for group 2 (using current target_id mapping).\npush!(ds, group2_db1)\npush!(ds, group2_db2)\n...","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Since they are referenced by their names, it is not necessary to push OI_ARRAY, OI_WAVELENGTH, and OI_COORREL dependencies if they already exist in the data-set (according to their name), but it doesn't hurt.  It is however mandatory to push an OI_TARGET instance with all targets and their identifiers as assumed by the subsequent data-blocks.","category":"page"},{"location":"modules/OIFITS/#Merging-data-sets","page":"OIFITS","title":"Merging data-sets","text":"","category":"section"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Two OI-FITS data-sets (or more), say A and B, can be consistently merged together by:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"C = merge(A, B)","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"As much as possible, the resulting data-set C will share its contents with A and/or B but without affecting A and B which are guaranteed to remain unchanged.  As for pushing data-blocks, the target identifiers (the target_id field) may be rewritten in the result.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Merging of data-sets assumes that the two merged data-sets are consistent and compatible.  Here compatible means that targets and dependencies with matching names must have the same contents.  This is checked during the merge operation.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"It is also allowed to merge several data-sets and/or merge data-sets in-place:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"ds = merge(ds1, ds2, ds3, ...) # merge ds1, ds2, ... in new data-set ds\nmerge!(ds, ds1, ds2, ds3, ...) # merge ds1, ds2, ... in existing data-set ds","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Note that merge!(ds,...) yields the destination ds.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Also note that, after merging, the internal dictionary used for rewriting target identifiers is left with the mapping built from the targets of the last merged data-set.","category":"page"},{"location":"modules/OIFITS/#Credits","page":"OIFITS","title":"Credits","text":"","category":"section"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"The development of this package has received funding from the European Community's Seventh Framework Programme (FP7/2013-2016) under Grant Agreement 312430 (OPTICON).","category":"page"},{"location":"modules/OIFITS/#References","page":"OIFITS","title":"References","text":"","category":"section"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Pauls, T. A., Young, J. S., Cotton, W. D., & Monnier, J. D. \"A data exchange standard for optical (visible/IR) interferometry.\" Publications of the Astronomical Society of the Pacific, vol. 117, no 837, p. 1255 (2005). [pdf]\nDuvert, G., Young, J., & Hummel, C. \"OIFITS 2: the 2nd version of the Data Exchange Standard for Optical (Visible/IR) Interferometry.\" arXiv preprint [arXiv:1510.04556v2.04556].","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"[doc-stable-img]: https://img.shields.io/badge/docs-stable-blue.svg [doc-stable-url]: https://emmt.github.io/OIFITS.jl/stable","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"[doc-dev-img]: https://img.shields.io/badge/docs-dev-blue.svg [doc-dev-url]: https://emmt.github.io/OIFITS.jl/dev","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"[license-url]: ./LICENSE.md [license-img]: http://img.shields.io/badge/license-MIT-brightgreen.svg?style=flat","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"[travis-img]: https://travis-ci.com/emmt/OIFITS.jl.svg?branch=master [travis-url]: https://travis-ci.com/emmt/OIFITS.jl","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"[appveyor-img]: https://ci.appveyor.com/api/projects/status/github/emmt/OIFITS.jl?branch=master [appveyor-url]: https://ci.appveyor.com/project/emmt/OIFITS-jl/branch/master","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"[coveralls-img]: https://coveralls.io/repos/emmt/OIFITS.jl/badge.svg?branch=master&service=github [coveralls-url]: https://coveralls.io/github/emmt/OIFITS.jl?branch=master","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"[codecov-img]: http://codecov.io/github/emmt/OIFITS.jl/coverage.svg?branch=master [codecov-url]: http://codecov.io/github/emmt/OIFITS.jl?branch=master","category":"page"},{"location":"modules/Optimization/optimization_packages/optimisers/#optimisers","page":"Optimisers.jl","title":"Optimisers.jl","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/optimisers/#Installation:-OptimizationFlux.jl","page":"Optimisers.jl","title":"Installation: OptimizationFlux.jl","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/optimisers/","page":"Optimisers.jl","title":"Optimisers.jl","text":"To use this package, install the OptimizationOptimisers package:","category":"page"},{"location":"modules/Optimization/optimization_packages/optimisers/","page":"Optimisers.jl","title":"Optimisers.jl","text":"import Pkg; Pkg.add(\"OptimizationOptimisers\")","category":"page"},{"location":"modules/Optimization/optimization_packages/optimisers/#Local-Unconstrained-Optimizers","page":"Optimisers.jl","title":"Local Unconstrained Optimizers","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/optimisers/","page":"Optimisers.jl","title":"Optimisers.jl","text":"Optimisers.Descent: Classic gradient descent optimizer with learning rate\nsolve(problem, Descent(η))\nη is the learning rate\nDefaults:\nη = 0.1\nOptimisers.Momentum: Classic gradient descent optimizer with learning rate and momentum\nsolve(problem, Momentum(η, ρ))\nη is the learning rate\nρ is the momentum\nDefaults:\nη = 0.01\nρ = 0.9\nOptimisers.Nesterov: Gradient descent optimizer with learning rate and Nesterov momentum\nsolve(problem, Nesterov(η, ρ))\nη is the learning rate\nρ is the Nesterov momentum\nDefaults:\nη = 0.01\nρ = 0.9\nOptimisers.RMSProp: RMSProp optimizer\nsolve(problem, RMSProp(η, ρ))\nη is the learning rate\nρ is the momentum\nDefaults:\nη = 0.001\nρ = 0.9\nOptimisers.Adam: Adam optimizer\nsolve(problem, Adam(η, β::Tuple))\nη is the learning rate\nβ::Tuple is the decay of momentums\nDefaults:\nη = 0.001\nβ::Tuple = (0.9, 0.999)\nOptimisers.RAdam: Rectified Adam optimizer\nsolve(problem, RAdam(η, β::Tuple))\nη is the learning rate\nβ::Tuple is the decay of momentums\nDefaults:\nη = 0.001\nβ::Tuple = (0.9, 0.999)\nOptimisers.RAdam: Optimistic Adam optimizer\nsolve(problem, OAdam(η, β::Tuple))\nη is the learning rate\nβ::Tuple is the decay of momentums\nDefaults:\nη = 0.001\nβ::Tuple = (0.5, 0.999)\nOptimisers.AdaMax: AdaMax optimizer\nsolve(problem, AdaMax(η, β::Tuple))\nη is the learning rate\nβ::Tuple is the decay of momentums\nDefaults:\nη = 0.001\nβ::Tuple = (0.9, 0.999)\nOptimisers.ADAGrad: ADAGrad optimizer\nsolve(problem, ADAGrad(η))\nη is the learning rate\nDefaults:\nη = 0.1\nOptimisers.ADADelta: ADADelta optimizer\nsolve(problem, ADADelta(ρ))\nρ is the gradient decay factor\nDefaults:\nρ = 0.9\nOptimisers.AMSGrad: AMSGrad optimizer\nsolve(problem, AMSGrad(η, β::Tuple))\nη is the learning rate\nβ::Tuple is the decay of momentums\nDefaults:\nη = 0.001\nβ::Tuple = (0.9, 0.999)\nOptimisers.NAdam: Nesterov variant of the Adam optimizer\nsolve(problem, NAdam(η, β::Tuple))\nη is the learning rate\nβ::Tuple is the decay of momentums\nDefaults:\nη = 0.001\nβ::Tuple = (0.9, 0.999)\nOptimisers.AdamW: AdamW optimizer\nsolve(problem, AdamW(η, β::Tuple))\nη is the learning rate\nβ::Tuple is the decay of momentums\ndecay is the decay to weights\nDefaults:\nη = 0.001\nβ::Tuple = (0.9, 0.999)\ndecay = 0\nOptimisers.ADABelief: ADABelief variant of Adam\nsolve(problem, ADABelief(η, β::Tuple))\nη is the learning rate\nβ::Tuple is the decay of momentums\nDefaults:\nη = 0.001\nβ::Tuple = (0.9, 0.999)","category":"page"},{"location":"tutorials/jwst-image-scale-bar/#tutorial-jwst-scalebar","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"","category":"section"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"This tutorial shows how to download one of the new famous JWST release images of the Carina nebula, plot it with world coordinates (RA and DEC), and add a scalebar. Let's get started!","category":"page"},{"location":"tutorials/jwst-image-scale-bar/#Packages","page":"JWST image with scale bar","title":"Packages","text":"","category":"section"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"Downloads: we'll use this built-in Julia standard library to download the raw image data\nAstroImages: we'll use this package to load and display the image\nPlots: we'll use this package to display coordinates along the image and add the scalebar","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"You can install the necessary packages by running Julia, and typing ] to enter Pkg-mode. Then: add AstroImages Plots. Alternatively, you can run using Pkg; Pkg.add([\"AstroImages\", \"Plots\"]).","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"If you will be using these tools as part of a bigger project, it's strongly recommended to create a Julia Project to record package versions.  If you're just experimenting, you can create a temporary project by running ] activate --temp.","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"If you're using Pluto notebooks, installing and recording package versions in a project are handled for you automatically.","category":"page"},{"location":"tutorials/jwst-image-scale-bar/#Downloading-the-data","page":"JWST image with scale bar","title":"Downloading the data","text":"","category":"section"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"All JWST data is available from the MAST archive. ","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"A mirror of the JWST initial release data is also hosted on AWS. We'll use this to directly download a specific famous image by URL.","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"warning: Large Download\nThe size of this image is over 3GB! Ensure you have enough space on your hard drive before running the following code.","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"using Downloads\n\nfname = Downloads.download(\n   \"https://stpubdata-jwst.stsci.edu/ero/jw02731/L3/t/\"*\n   \"jw02731-o001_t017_nircam_clear-f187n_i2d.fits\"\n)","category":"page"},{"location":"tutorials/jwst-image-scale-bar/#Loading-the-image","page":"JWST image with scale bar","title":"Loading the image","text":"","category":"section"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"We can use AstroImages.jl to load the image.","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"using AstroImages\n\ncarina_full = load(fname); # semi-colon prevents displaying the image","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"[ Info: Image was loaded from HDU 2","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"Let's check the resolution of the image:","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"size(carina)","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"(14436, 8568)","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"Wow, that's over 120 megapixels! ","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"AstroImages will fall back to downscaling it automatically before displaying it using ImageTransformations.restrict, but let's make our lives simpler and just use every 10th pixel:","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"carina = carina_full[begin:10:end, begin:10:end]","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"(Image: Carina nebula displayed as an image)","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"Since we didn't put a semi-colon, the image was displayed. This works automatically if you use the VS Code editor, Jupyter notebooks, or Pluto Notebooks. If you're using a terminal, you can use ElectronDisplay.jl or ImageView.jl to open an interactive window.","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"imview is the function that was called automatically  to display the image, but we can call it ourselves if we want to customize the display. We can make the image pop a little more by adjusting the display limits, or clims. These can be either a tuple of min and max values (i.e. (0.0, 100.0)) or a function to calculate them for us based on some criteria. We'll adjust the limits to remove the top and bottom 1% of all  pixels:","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"imview(carina; clims=Percent(98))","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"(Image: Carina nebula displayed as an image with higher contrast)","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"In Julia, keyword arguments come after positional arguments and they can be separated by a semi-colon.","category":"page"},{"location":"tutorials/jwst-image-scale-bar/#Adding-World-Coordinates","page":"JWST image with scale bar","title":"Adding World Coordinates","text":"","category":"section"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"The image header already contains WCS keys to specify the location of the image in the sky. Let's take a peek at one of these header keys:","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"println(carina[\"CTYPE1\", Comment])\nprintln(carina[\"CTYPE1\"])","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"first axis coordinate type\nRA---TAN","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"This shows that the coordinate type for the first axis is \"RA–-TAN\".","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"Now, we'll combine AstroImages with the Plots.jl library to display these coordinates.","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"using Plots\n\nimplot(carina; clims=Percent(98))","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"(Image: Carina nebula displayed in a plot)","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"The image is tilted compared to the right-ascension and declination celestial coordinate system, so the grid is rotated.","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"The colourbar on the right displays the units of the image: Mega-Janskys per steradian: units of energy per collecting area, per spectral bandwidth, per solid-angle on the sky.","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"Let's turn off the grid for now:","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"implot(carina; grid=false, clims=Percent(98))","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"(Image: Carina nebula displayed in a plot without grid lines)","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"Full documentation for the implot function is available in the AstroImages.jl docs.","category":"page"},{"location":"tutorials/jwst-image-scale-bar/#Adding-a-Scalebar","page":"JWST image with scale bar","title":"Adding a Scalebar","text":"","category":"section"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"Another way we can communicate the scale of this image is by adding a scalebar. Since we are working in spherical coordinates, the cartesian Pythagorean theorem won't quite cut it. There are approximations we can use for small angles, but let's go ahead and compute the scale bar length in a fully general way.","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"For two points of right-ascension alpha and declination delta, a=(alpha_a delta_a) and b=(alpha_b delta_b), the angular separation is","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"cos (gamma) = cos (90 - delta_a) cos (90 - delta_b) + sin (90 - delta_a) sin (90 - delta_b) cos (alpha_a - alpha_b)","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"We can calculate the length of our scalebar in pixels by picking a coordinate a, picking an angular separation gamma, and then solving for b:","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"using LinearAlgebra\n\n# Start the scalebar here in pixel coordinates\na_px = [1000, 100]\n\n# Convert to world coordinates\na_deg = pix_to_world(carina_full, a_px)\n\n# Extend by 10 arcminutes of declination\nb_deg  = a_deg .+ [0, 1/60]\n\n# Convert back to pixel coordinates\nb_px = world_to_pix(carina_full, b_deg)\n\n# Measure the angular distance in pixel coordinates\n# note: in theory this depends on where in the image we make this calculation\n# because the coordinate system is warped\narcmin_px = norm(stop_coord_pix .- start_coord_pix)\n\n# Plot our image again\nimplot(carina; grid=false, clims=Percent(98))\n\n# Overplot the scalebar\nplot!(\n    # X\n    [11000, 11000+arcmin_px],\n    # Y\n    [1000,  1000];\n    # Formatting:\n    color=:white,\n    linewidth=5,\n    label=\"\"\n)\n\n# add annotation\nannx = 11000+arcmin_px/2\nanny = 1000+100\nannotate!(\n    (annx, anny, text(\" 1' \", 10, :white, :center, :bottom))\n)","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"(Image: Carina nebula displayed with a scale bar)","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"Looking good! If we only want to communiate the scale and not the location, we can hide the tick marks and colorbar for a cleaner look:","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"\n# Hide decorations\nimplot(\n    carina[10:end-10, 10:end-10]; # crop slightly\n    grid=false,\n    ticks=false,\n    colorbar=false,\n    clims=Percent(98),\n    xlabel=\"\",\n    ylabel=\"\",\n    framestyle=:none,\n    background_outside=:transparent,\n)\n\n# Overplot the scalebar\nplot!(\n    # X\n    [11000, 11000+arcmin_px],\n    # Y\n    [1000,  1000];\n    # Formatting:\n    color=:white,\n    linewidth=5,\n    label=\"\",\n)\n\n# add annotation\nannx = 11000+arcmin_px/2\nanny = 1000+100\nannotate!(\n    (annx, anny, text(\" 1' \", 10, :white, :center, :bottom)) \n)","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"(Image: Carina nebula displayed with a scale bar and no other plot decorations)","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"To save the image, just run savefig(\"output.png\"). pdf, svg, and other file formats are also supported.","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"To learn more about displaying images and world coordinates, see the AstroImages.jl documentation.","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"For more on plotting in general, see the Plots.jl documentation.","category":"page"},{"location":"modules/Difmap/#Overview","page":"Difmap","title":"Overview","text":"","category":"section"},{"location":"modules/Difmap/","page":"Difmap","title":"Difmap","text":"Julia wrapper for the difmap program. Conveniently execute difmap scripts, handle input/output files and logs. Relies on the difmap_jll.jl package to provide the difmap binary.","category":"page"},{"location":"modules/Difmap/#Usage","page":"Difmap","title":"Usage","text":"","category":"section"},{"location":"modules/Difmap/","page":"Difmap","title":"Difmap","text":"See also the Pluto notebook that includes plots.","category":"page"},{"location":"modules/Difmap/","page":"Difmap","title":"Difmap","text":"julia> using Difmap\n\njulia> script = [\n          \"print(1 + 2)\",\n          \"exit\",\n       ];\n\njulia> res = Difmap.execute(script);\n\njulia> res.success\ntrue\n\njulia> Difmap.inout_pairs(res)[begin+1:end-1]  # first and last lines contain current time\n1-element Vector{Pair{String, Vector{String}}}:\n \"print(1 + 2)\" => [\"3\"]","category":"page"},{"location":"modules/Difmap/","page":"Difmap","title":"Difmap","text":"julia> script = [\n           \"observe vis.fits\",\n           \"select I\",\n           \"mapsize 512, 0.2\",\n           \"clean 500\",\n           \"restore\",\n           \"device tmp.ps/PS\",\n           \"mapplot cln\",\n           \"save result\",\n           \"exit\",\n       ];\n\n\njulia> vis_file = joinpath(dirname(dirname(pathof(Difmap))), \"test/data/vis.fits\");\n\njulia> res = Difmap.execute(script,\n           in_files=[vis_file => \"vis.fits\"],\n           out_files=[\"result.fits\", \"result.mod\", \"result.par\", \"result.uvf\", \"tmp.ps\"] .=> nothing,  # target is nothing - ignore these files\n       );\n\njulia> res.success\ntrue\n\njulia> Difmap.inout_pairs(res)[begin+1:end-1]  # first and last lines contain current time\n8-element Vector{Pair{String, Vector{String}}}:\n \"observe vis.fits\" => [\"Reading UV FITS file: vis.fits\", \"AN table 1: 4 integrations on 36 of 36 possible baselines.\", \"Apparent sampling: 1 visibilities/baseline/integration-bin.\", \"Found source: J0000+0248\", \"\", \"There are 8 IFs, and a total of 8 channels:\", \"\", \"IF  Channel    Frequency  Freq offset  Number of   Overall IF\", \"origin    at origin  per channel   channels    bandwidth\", \"------------------------------------------------------------- (Hz)\"  …  \"05        5    4.416e+09      3.2e+07          1      3.2e+07\", \"06        6    4.512e+09      3.2e+07          1      3.2e+07\", \"07        7    4.544e+09      3.2e+07          1      3.2e+07\", \"08        8    4.576e+09      3.2e+07          1      3.2e+07\", \"\", \"Polarization(s): RR\", \"\", \"Read 0 lines of history.\", \"\", \"Reading 1152 visibilities.\"]\n         \"select I\" => [\"Polarization I is unavailable.\", \"Selecting polarization: RR,  channels: 1..8\", \"Reading IF 1 channels: 1..1\", \"Reading IF 2 channels: 2..2\", \"Reading IF 3 channels: 3..3\", \"Reading IF 4 channels: 4..4\", \"Reading IF 5 channels: 5..5\", \"Reading IF 6 channels: 6..6\", \"Reading IF 7 channels: 7..7\", \"Reading IF 8 channels: 8..8\"]\n \"mapsize 512, 0.2\" => [\"Map grid = 512x512 pixels with 0.200x0.200 milli-arcsec cellsize.\"]\n        \"clean 500\" => [\"Inverting map and beam\", \"Estimated beam: bmin=1.195 mas, bmaj=3.79 mas, bpa=-3.012 degrees\", \"Estimated noise=0.541101 mJy/beam.\", \"clean: niter=500  gain=0.05  cutoff=0\", \"Component: 050  -  total flux cleaned = 0.0188812 Jy\", \"Component: 100  -  total flux cleaned = 0.0252178 Jy\", \"Component: 150  -  total flux cleaned = 0.0277823 Jy\", \"Component: 200  -  total flux cleaned = 0.0290343 Jy\", \"Component: 250  -  total flux cleaned = 0.0300524 Jy\", \"Component: 300  -  total flux cleaned = 0.0302839 Jy\", \"Component: 350  -  total flux cleaned = 0.0304884 Jy\", \"Component: 400  -  total flux cleaned = 0.0304353 Jy\", \"Component: 450  -  total flux cleaned = 0.0305383 Jy\", \"Component: 500  -  total flux cleaned = 0.030393 Jy\", \"Total flux subtracted in 500 components = 0.030393 Jy\", \"Clean residual min=-0.000455 max=0.000452 Jy/beam\", \"Clean residual mean=0.000001 rms=0.000189 Jy/beam\", \"Combined flux in latest and established models = 0.030393 Jy\"]\n          \"restore\" => [\"restore: Substituting estimate of restoring beam from last 'invert'.\", \"Restoring with beam: 1.195 x 3.79 at -3.012 degrees (North through East)\", \"Clean map  min=-0.0010866  max=0.019272 Jy/beam\"]\n \"device tmp.ps/PS\" => [\"Attempting to open device: 'tmp.ps/PS'\"]\n      \"mapplot cln\" => []\n      \"save result\" => [\"Writing UV FITS file: result.uvf\", \"Writing 174 model components to file: result.mod\", \"Adding 174 model components to the UV plane model.\", \"The established model now contains 174 components and 0.030393 Jy\", \"Inverting map\", \"restore: Substituting estimate of restoring beam from last 'invert'.\", \"Restoring with beam: 1.195 x 3.79 at -3.012 degrees (North through East)\", \"Clean map  min=-0.0010295  max=0.019271 Jy/beam\", \"Writing clean map to FITS file: result.fits\", \"Writing difmap environment to: result.par\"]","category":"page"},{"location":"highlevels/images/#Images-Overview","page":"Images Overview","title":"Images Overview","text":"","category":"section"},{"location":"modules/Optimization/tutorials/symbolic/#Symbolic-Problem-Building-with-ModelingToolkit","page":"Symbolic Problem Building with ModelingToolkit","title":"Symbolic Problem Building with ModelingToolkit","text":"","category":"section"},{"location":"modules/Optimization/tutorials/symbolic/","page":"Symbolic Problem Building with ModelingToolkit","title":"Symbolic Problem Building with ModelingToolkit","text":"note: Note\nThis example uses the OptimizationOptimJL.jl package. See the Optim.jl page for details on the installation and usage.","category":"page"},{"location":"modules/Optimization/tutorials/symbolic/","page":"Symbolic Problem Building with ModelingToolkit","title":"Symbolic Problem Building with ModelingToolkit","text":"ModelingToolkit.jl is a comprehensive system for symbolic modeling in Julia. Allows for doing many manipulations before the solver phase, such as detecting sparsity patterns, analytically solving parts of the model to reduce the solving complexity, and more. One of the types of system types that it supports is OptimizationSystem, i.e. the symbolic counterpart to OptimizationProblem. Let's demonstrate how to use the OptimizationSystem to construct optimized OptimizationProblems.","category":"page"},{"location":"modules/Optimization/tutorials/symbolic/","page":"Symbolic Problem Building with ModelingToolkit","title":"Symbolic Problem Building with ModelingToolkit","text":"First we need to start by defining our symbolic variables, this is done as follows:","category":"page"},{"location":"modules/Optimization/tutorials/symbolic/","page":"Symbolic Problem Building with ModelingToolkit","title":"Symbolic Problem Building with ModelingToolkit","text":"using ModelingToolkit, Optimization, OptimizationOptimJL\r\n\r\n@variables x y\r\n@parameters a b","category":"page"},{"location":"modules/Optimization/tutorials/symbolic/","page":"Symbolic Problem Building with ModelingToolkit","title":"Symbolic Problem Building with ModelingToolkit","text":"We can now construct the OptimizationSystem by building a symbolic expression  for the loss function:","category":"page"},{"location":"modules/Optimization/tutorials/symbolic/","page":"Symbolic Problem Building with ModelingToolkit","title":"Symbolic Problem Building with ModelingToolkit","text":"loss = (a - x)^2 + b * (y - x^2)^2\r\nsys = OptimizationSystem(loss,[x,y],[a,b])","category":"page"},{"location":"modules/Optimization/tutorials/symbolic/","page":"Symbolic Problem Building with ModelingToolkit","title":"Symbolic Problem Building with ModelingToolkit","text":"In order to turn it into a problem for numerical solutions, we need to specify what our parameter values are and the initial conditions. This looks like:","category":"page"},{"location":"modules/Optimization/tutorials/symbolic/","page":"Symbolic Problem Building with ModelingToolkit","title":"Symbolic Problem Building with ModelingToolkit","text":"u0 = [\r\n    x=>1.0\r\n    y=>2.0\r\n]\r\np = [\r\n    a => 6.0\r\n    b => 7.0\r\n]","category":"page"},{"location":"modules/Optimization/tutorials/symbolic/","page":"Symbolic Problem Building with ModelingToolkit","title":"Symbolic Problem Building with ModelingToolkit","text":"And now we solve.","category":"page"},{"location":"modules/Optimization/tutorials/symbolic/","page":"Symbolic Problem Building with ModelingToolkit","title":"Symbolic Problem Building with ModelingToolkit","text":"prob = OptimizationProblem(sys,u0,p,grad=true,hess=true)\r\nsolve(prob,Newton())","category":"page"},{"location":"modules/Optimization/tutorials/symbolic/","page":"Symbolic Problem Building with ModelingToolkit","title":"Symbolic Problem Building with ModelingToolkit","text":"It has a lot of other features like auto-parallelism and sparsification too. Plus you can hierarchically nest systems to have it generate huge optimization problems. Check out the ModelingToolkit.jl OptimizationSystem documentation for more information.","category":"page"},{"location":"modules/Optimization/tutorials/intro/#Basic-usage","page":"Basic usage","title":"Basic usage","text":"","category":"section"},{"location":"modules/Optimization/tutorials/intro/","page":"Basic usage","title":"Basic usage","text":"In this tutorial we introduce the basics of Optimization.jl by showing how to easily mix local optimizers from Optim.jl and global optimizers from BlackBoxOptim.jl on the Rosenbrock equation. The simplest copy-pasteable code to get started is the following:","category":"page"},{"location":"modules/Optimization/tutorials/intro/","page":"Basic usage","title":"Basic usage","text":"# Import the package and define the problem to optimize\nusing Optimization\nrosenbrock(u,p) =  (p[1] - u[1])^2 + p[2] * (u[2] - u[1]^2)^2\nu0 = zeros(2)\np  = [1.0,100.0]\n\nprob = OptimizationProblem(rosenbrock,u0,p)\n\n# Import a solver package and solve the optimization problem\nusing OptimizationOptimJL\nsol = solve(prob,NelderMead())\n\n# Import a different solver package and solve the optimization problem a different way\nusing OptimizationBBO\nprob = OptimizationProblem(rosenbrock, u0, p, lb = [-1.0,-1.0], ub = [1.0,1.0])\nsol = solve(prob,BBO_adaptive_de_rand_1_bin_radiuslimited())","category":"page"},{"location":"modules/Optimization/tutorials/intro/","page":"Basic usage","title":"Basic usage","text":"Notice that Optimization.jl is the core glue package that holds all of the common pieces, but to solve the equations we need to use a solver package. Here, OptimizationOptimJL is for Optim.jl and OptimizationBBO is for BlackBoxOptim.jl.","category":"page"},{"location":"modules/Optimization/tutorials/intro/","page":"Basic usage","title":"Basic usage","text":"The output of the first optimization task (with the NelderMead() algorithm) is given below:","category":"page"},{"location":"modules/Optimization/tutorials/intro/","page":"Basic usage","title":"Basic usage","text":"sol = solve(prob,NelderMead())","category":"page"},{"location":"modules/Optimization/tutorials/intro/","page":"Basic usage","title":"Basic usage","text":"The solution from the original solver can always be obtained via original:","category":"page"},{"location":"modules/Optimization/tutorials/intro/","page":"Basic usage","title":"Basic usage","text":"sol.original","category":"page"},{"location":"modules/Optimization/tutorials/intro/#Controlling-Gradient-Calculations-(Automatic-Differentiation)","page":"Basic usage","title":"Controlling Gradient Calculations (Automatic Differentiation)","text":"","category":"section"},{"location":"modules/Optimization/tutorials/intro/","page":"Basic usage","title":"Basic usage","text":"Notice that both of the above methods were derivative-free methods, and thus no gradients were required to do the optimization. However, in many cases first order optimization (i.e. using gradients) is much more efficient. Defining gradients can be done in two ways. One way is to manually provide a gradient definition in the OptimizationFunction constructor. However, the more convenient way to obtain gradients is to provide an AD backend type. ","category":"page"},{"location":"modules/Optimization/tutorials/intro/","page":"Basic usage","title":"Basic usage","text":"For example, let's now use the OptimizationOptimJL BFGS method to solve the same problem. We will import the forward-mode automatic differentiation library (using ForwardDiff) and then specify in the OptimizationFunction to automatically construct the derivative functions using ForwardDiff.jl. This looks like:","category":"page"},{"location":"modules/Optimization/tutorials/intro/","page":"Basic usage","title":"Basic usage","text":"using ForwardDiff\noptf = OptimizationFunction(rosenbrock, Optimization.AutoForwardDiff())\nprob = OptimizationProblem(optf, u0, p)\nsol = solve(prob,BFGS())","category":"page"},{"location":"modules/Optimization/tutorials/intro/","page":"Basic usage","title":"Basic usage","text":"We can inspect the original to see the statistics on the number of steps  required and gradients computed:","category":"page"},{"location":"modules/Optimization/tutorials/intro/","page":"Basic usage","title":"Basic usage","text":"sol.original","category":"page"},{"location":"modules/Optimization/tutorials/intro/","page":"Basic usage","title":"Basic usage","text":"Sure enough, it's a lot less than the derivative-free methods!","category":"page"},{"location":"modules/Optimization/tutorials/intro/","page":"Basic usage","title":"Basic usage","text":"However, the compute cost of forward-mode automatic differentiation scales via the number of inputs, and thus as our optimization problem grows large it slow down. To counteract this, for larger optimization problems (>100 state variables) one normally would want to use reverse-mode automatic differentiation. One common choice for reverse-mode automatic differentiation is Zygote.jl. We can demonstrate this via:","category":"page"},{"location":"modules/Optimization/tutorials/intro/","page":"Basic usage","title":"Basic usage","text":"using Zygote\noptf = OptimizationFunction(rosenbrock, Optimization.AutoZygote())\nprob = OptimizationProblem(optf, u0, p)\nsol = solve(prob,BFGS())","category":"page"},{"location":"modules/Optimization/tutorials/intro/#Setting-Box-Constraints","page":"Basic usage","title":"Setting Box Constraints","text":"","category":"section"},{"location":"modules/Optimization/tutorials/intro/","page":"Basic usage","title":"Basic usage","text":"In many cases one knows the potential bounds on the solution values. In Optimization.jl, these can be supplied as the lb and ub arguments for the lower bounds and upper bounds respectively, supplying a vector of values with one per state variable. Let's now do our gradient-based optimization with box constraints by rebuilding the OptimizationProblem:","category":"page"},{"location":"modules/Optimization/tutorials/intro/","page":"Basic usage","title":"Basic usage","text":"prob = OptimizationProblem(optf, u0, p, lb = [-1.0,-1.0], ub = [1.0,1.0])\nsol = solve(prob,BFGS())","category":"page"},{"location":"modules/Optimization/tutorials/intro/","page":"Basic usage","title":"Basic usage","text":"For more information on handling constraints, in particular equality and inequality constraints, take a look at the constraints tutorial.","category":"page"},{"location":"highlevels/timecoords/#Time,-Coordinates,-and-Units-Overview","page":"Time, Coordinates, & Units Overview","title":"Time, Coordinates, & Units Overview","text":"","category":"section"},{"location":"highlevels/timecoords/#[AstroAngles.jl](https://github.com/JuliaAstro/AstroAngles.jl)","page":"Time, Coordinates, & Units Overview","title":"AstroAngles.jl","text":"","category":"section"},{"location":"highlevels/timecoords/","page":"Time, Coordinates, & Units Overview","title":"Time, Coordinates, & Units Overview","text":"String parsing and representation of angles","category":"page"},{"location":"highlevels/timecoords/","page":"Time, Coordinates, & Units Overview","title":"Time, Coordinates, & Units Overview","text":"Parse and represent sexagesimal angles with a variety of delimiters\nMethods for converting to hour-minute-second angles from degrees and radians, and vice-versa","category":"page"},{"location":"highlevels/timecoords/#[AstroTime.jl](https://github.com/JuliaAstro/AstroTime.jl)-[![](../assets/book.png)](https://juliaastro.github.io/AstroTime.jl/stable/)","page":"Time, Coordinates, & Units Overview","title":"AstroTime.jl (Image: )","text":"","category":"section"},{"location":"highlevels/timecoords/","page":"Time, Coordinates, & Units Overview","title":"Time, Coordinates, & Units Overview","text":"Astronomical time keeping","category":"page"},{"location":"highlevels/timecoords/","page":"Time, Coordinates, & Units Overview","title":"Time, Coordinates, & Units Overview","text":"High-precision, time-scale aware, DateTime-like data type\nSupport all commonly used astronomical time scales","category":"page"},{"location":"highlevels/timecoords/#[ERFA.jl](https://github.com/JuliaAstro/ERFA.jl)","page":"Time, Coordinates, & Units Overview","title":"ERFA.jl","text":"","category":"section"},{"location":"highlevels/timecoords/","page":"Time, Coordinates, & Units Overview","title":"Time, Coordinates, & Units Overview","text":"Time systems conversions","category":"page"},{"location":"highlevels/timecoords/","page":"Time, Coordinates, & Units Overview","title":"Time, Coordinates, & Units Overview","text":"Low-level wrapper for liberfa","category":"page"},{"location":"highlevels/timecoords/#[SkyCoords.jl](https://github.com/JuliaAstro/SkyCoords.jl)","page":"Time, Coordinates, & Units Overview","title":"SkyCoords.jl","text":"","category":"section"},{"location":"highlevels/timecoords/","page":"Time, Coordinates, & Units Overview","title":"Time, Coordinates, & Units Overview","text":"Astronomical coordinate systems","category":"page"},{"location":"highlevels/timecoords/","page":"Time, Coordinates, & Units Overview","title":"Time, Coordinates, & Units Overview","text":"Supports ICRS, galactic, and FK5 coordinate systems\nFast conversion of coordinates between different systems","category":"page"},{"location":"highlevels/timecoords/#[UnitfulAstro.jl](https://github.com/JuliaAstro/UnitfulAstro.jl)-[![](../assets/book.png)](https://juliaastro.github.io/UnitfulAstro.jl/stable/)","page":"Time, Coordinates, & Units Overview","title":"UnitfulAstro.jl (Image: )","text":"","category":"section"},{"location":"highlevels/timecoords/","page":"Time, Coordinates, & Units Overview","title":"Time, Coordinates, & Units Overview","text":"Astronomical units","category":"page"},{"location":"highlevels/timecoords/","page":"Time, Coordinates, & Units Overview","title":"Time, Coordinates, & Units Overview","text":"Extension of Unitful.jl","category":"page"},{"location":"highlevels/timecoords/#[WCS.jl](https://github.com/JuliaAstro/WCS.jl)-[![](../assets/book.png)](https://juliaastro.github.io/WCS.jl/stable/)","page":"Time, Coordinates, & Units Overview","title":"WCS.jl (Image: )","text":"","category":"section"},{"location":"highlevels/timecoords/","page":"Time, Coordinates, & Units Overview","title":"Time, Coordinates, & Units Overview","text":"World Coordinate System transformations","category":"page"},{"location":"highlevels/timecoords/","page":"Time, Coordinates, & Units Overview","title":"Time, Coordinates, & Units Overview","text":"Wrapper for wcslib","category":"page"},{"location":"modules/Optimization/tutorials/constraints/#constraints","page":"Using Equality and Inequality Constraints","title":"Using Equality and Inequality Constraints","text":"","category":"section"},{"location":"modules/Optimization/tutorials/constraints/","page":"Using Equality and Inequality Constraints","title":"Using Equality and Inequality Constraints","text":"Multiple optmization packages available with the MathOptInterface and Optim's IPNewton solver can handle non-linear constraints. Optimization.jl provides a simple interface to define the constraint as a julia function and then specify the bounds for the output in OptimizationFunction to indicate if it's an equality or inequality constraint.","category":"page"},{"location":"modules/Optimization/tutorials/constraints/","page":"Using Equality and Inequality Constraints","title":"Using Equality and Inequality Constraints","text":"Let's define the rosenbrock function as our objective function and consider the below inequalities as our constraints.","category":"page"},{"location":"modules/Optimization/tutorials/constraints/","page":"Using Equality and Inequality Constraints","title":"Using Equality and Inequality Constraints","text":"beginaligned\n\nx_1^2 + x_2^2 leq 08 \n\n00 leq x_1 * x_2 leq 50\nendaligned","category":"page"},{"location":"modules/Optimization/tutorials/constraints/","page":"Using Equality and Inequality Constraints","title":"Using Equality and Inequality Constraints","text":"using Optimization, OptimizationMOI, OptimizationOptimJL, ForwardDiff, ModelingToolkit\n\nrosenbrock(x, p) = (p[1] - x[1])^2 + p[2] * (x[2] - x[1]^2)^2\nx0 = zeros(2)\n_p = [1.0, 1.0]","category":"page"},{"location":"modules/Optimization/tutorials/constraints/","page":"Using Equality and Inequality Constraints","title":"Using Equality and Inequality Constraints","text":"Next we define the sum of squares and the product of the optimization variables as our constraint functions.","category":"page"},{"location":"modules/Optimization/tutorials/constraints/","page":"Using Equality and Inequality Constraints","title":"Using Equality and Inequality Constraints","text":"cons(res, x, p) = (res .= [x[1]^2+x[2]^2, x[1]*x[2]])","category":"page"},{"location":"modules/Optimization/tutorials/constraints/","page":"Using Equality and Inequality Constraints","title":"Using Equality and Inequality Constraints","text":"We'll use the IPNewton solver from Optim to solve the problem.","category":"page"},{"location":"modules/Optimization/tutorials/constraints/","page":"Using Equality and Inequality Constraints","title":"Using Equality and Inequality Constraints","text":"optprob = OptimizationFunction(rosenbrock, Optimization.AutoForwardDiff(), cons = cons)\nprob = OptimizationProblem(optprob, x0, _p, lcons = [-Inf, -1.0], ucons = [0.8, 2.0])\nsol = solve(prob, IPNewton())","category":"page"},{"location":"modules/Optimization/tutorials/constraints/","page":"Using Equality and Inequality Constraints","title":"Using Equality and Inequality Constraints","text":"Let's check that the constraints are satisfied and the objective is lower than at initial values to be sure.","category":"page"},{"location":"modules/Optimization/tutorials/constraints/","page":"Using Equality and Inequality Constraints","title":"Using Equality and Inequality Constraints","text":"res = zeros(2)\ncons(res, sol.u, _p)\nres","category":"page"},{"location":"modules/Optimization/tutorials/constraints/","page":"Using Equality and Inequality Constraints","title":"Using Equality and Inequality Constraints","text":"prob.f(sol.u, _p)","category":"page"},{"location":"modules/Optimization/tutorials/constraints/","page":"Using Equality and Inequality Constraints","title":"Using Equality and Inequality Constraints","text":"We can also use the Ipopt library with the OptimizationMOI package.","category":"page"},{"location":"modules/Optimization/tutorials/constraints/","page":"Using Equality and Inequality Constraints","title":"Using Equality and Inequality Constraints","text":"sol = solve(prob, Ipopt.Optimizer())","category":"page"},{"location":"modules/Optimization/tutorials/constraints/","page":"Using Equality and Inequality Constraints","title":"Using Equality and Inequality Constraints","text":"res = zeros(2)\ncons(res, sol.u, _p)\nres","category":"page"},{"location":"modules/Optimization/tutorials/constraints/","page":"Using Equality and Inequality Constraints","title":"Using Equality and Inequality Constraints","text":"prob.f(sol.u, _p)","category":"page"},{"location":"modules/Optimization/tutorials/constraints/","page":"Using Equality and Inequality Constraints","title":"Using Equality and Inequality Constraints","text":"We can also use ModelingToolkit as our AD backend and generate symbolic derivatives and expression graph for the objective and constraints.","category":"page"},{"location":"modules/Optimization/tutorials/constraints/","page":"Using Equality and Inequality Constraints","title":"Using Equality and Inequality Constraints","text":"Let's modify the bounds to use the function as an equality constraint. The constraint now becomes -","category":"page"},{"location":"modules/Optimization/tutorials/constraints/","page":"Using Equality and Inequality Constraints","title":"Using Equality and Inequality Constraints","text":"beginaligned\n\nx_1^2 + x_2^2 = 10 \n\nx_1 * x_2 = 05\nendaligned","category":"page"},{"location":"modules/Optimization/tutorials/constraints/","page":"Using Equality and Inequality Constraints","title":"Using Equality and Inequality Constraints","text":"optprob = OptimizationFunction(rosenbrock, Optimization.AutoModelingToolkit(), cons = cons)\nprob = OptimizationProblem(optprob, x0, _p, lcons = [1.0, 0.5], ucons = [1.0, 0.5])","category":"page"},{"location":"modules/Optimization/tutorials/constraints/","page":"Using Equality and Inequality Constraints","title":"Using Equality and Inequality Constraints","text":"Below the AmplNLWriter.jl package is used with to use the Ipopt library to solve the problem.","category":"page"},{"location":"modules/Optimization/tutorials/constraints/","page":"Using Equality and Inequality Constraints","title":"Using Equality and Inequality Constraints","text":"using AmplNLWriter, Ipopt_jll\nsol = solve(prob, AmplNLWriter.Optimizer(Ipopt_jll.amplexe))","category":"page"},{"location":"modules/Optimization/tutorials/constraints/","page":"Using Equality and Inequality Constraints","title":"Using Equality and Inequality Constraints","text":"The constraints evaluate to 1.0 and 0.5 respectively as expected.","category":"page"},{"location":"modules/Optimization/tutorials/constraints/","page":"Using Equality and Inequality Constraints","title":"Using Equality and Inequality Constraints","text":"res = zeros(2)\ncons(res, sol.u, _p)\nprintln(res)","category":"page"},{"location":"modules/AstroAngles/#AstroAngles.jl","page":"AstroAngles","title":"AstroAngles.jl","text":"","category":"section"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"(Image: Build Status) (Image: PkgEval) (Image: Coverage) (Image: License)","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"Lightweight string parsing and representation of angles.","category":"page"},{"location":"modules/AstroAngles/#Installation","page":"AstroAngles","title":"Installation","text":"","category":"section"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"To install use Pkg. From the REPL, press ] to enter Pkg-mode","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"pkg> add AstroAngles","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"If you want to use the most up-to-date version of the code, check it out from main","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"pkg> add AstroAngles#main","category":"page"},{"location":"modules/AstroAngles/#Usage","page":"AstroAngles","title":"Usage","text":"","category":"section"},{"location":"modules/AstroAngles/#Angle-Parsing-Utilities","page":"AstroAngles","title":"Angle Parsing Utilities","text":"","category":"section"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"String representations of angles in both \"degree:arcmin:arcsec\" and  \"hour:min:sec\" format can be parsed using a variety of delimiters, which can be mixed together (e.g. can use ° after degrees but : after the arcminutes). The directions \"S\" and \"W\" are considered negative and \"-1:0:0S\" is 1 degree North, for example.","category":"page"},{"location":"modules/AstroAngles/#dms-formats","page":"AstroAngles","title":"dms formats","text":"","category":"section"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"\"[+-]xx:xx:xx.x[NESW]\"\n\"[+-]xx xx xx.x[NESW]\"\n\"[+-]xxdxxmxx.xs[NESW]\"\n\"[+-]xx°xx'xx.x\\\"[NESW]\"\n\"[+-]xx°xx′xx.x″[NESW]\" # \\prime, \\pprime","category":"page"},{"location":"modules/AstroAngles/#hms-formats","page":"AstroAngles","title":"hms formats","text":"","category":"section"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"\"[+-]xx:xx:xx.x[NESW]\"\n\"[+-]xx xx xx.x[NESW]\"\n\"[+-]xxhxxmxx.xs[NESW]\"\n\"[+-]xxhxx'xx.x\\\"[NESW]\"\n\"[+-]xx°xx′xx.x″[NESW]\"","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"the simplest way to convert is to use the @dms_str and @hms_str macros, which allows you to choose the output angle type","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"julia> dms\"12:17:25.3\"\n0.21450726764795752\n\njulia> dms\"12:17:25.3\"rad # default\n0.21450726764795752\n\njulia> dms\"12:17:25.3\"deg\n12.29036111111111\n\njulia> dms\"12:17:25.3\"ha\n0.8193574074074074","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"here is a showcase of the variety of ways to parse inputs","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"julia> dms\"10.2345d\"deg\n10.2345\n\njulia> dms\"1:2:30.43\"deg\n1.041786111111111\n\njulia> hms\"1 2 0\"ha\n1.0333333333333334\n\njulia> dms\"1°2′3″\"deg\n1.0341666666666667\n\njulia> dms\"1°2′3″N\"deg\n1.0341666666666667\n\njulia> dms\"1d2m3.4s\"deg\n1.0342777777777779\n\njulia> dms\"1d2m3.4sS\"deg\n-1.0342777777777779\n\njulia> hms\"-1h2m3s\"ha\n-1.0341666666666667\n\njulia> hms\"-1h2m3sW\"ha\n1.0341666666666667","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"for more control on the output, you can use the parse_dms and parse_hms methods, which returns a tuple of the parsed dms or hms values","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"parse_dms # string -> (deg, arcmin, arcsec)\nparse_hms # string -> (hours, mins, secs)","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"julia> parse_dms(\"12:17:25.3\")\n(12.0, 17.0, 25.3)\n\njulia> parse_hms(\"-4:4:6\")\n(-4.0, 4.0, 6.0)","category":"page"},{"location":"modules/AstroAngles/#Angle-Conversion-Utilities","page":"AstroAngles","title":"Angle Conversion Utilities","text":"","category":"section"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"The following methods are added for converting to and from hour angles","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"deg2ha # degrees -> hour angles\nrad2ha # radians -> hour angles\nha2deg # hour angles -> degrees\nha2rad # hour angles -> radians","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"The following methods convert from angles as a single number to tuples consistent with sexagesimal","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"deg2dms # degrees -> (deg, arcmin, arcsec)\nrad2dms # radians -> (deg, arcmin, arcsec)\nha2dms  # hour angles -> (deg, arcmin, arcsec)\n\ndeg2hms # degrees -> (hours, mins, secs)\nrad2hms # radians -> (hours, mins, secs)\nha2hms  # hour angles -> (hours, mins, secs)","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"and the inverse","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"dms2deg # (deg, arcmin, arcsec) -> degrees\ndms2rad # (deg, arcmin, arcsec) -> radians\ndms2ha  # (deg, arcmin, arcsec) -> hour angles\n\nhms2deg # (hours, mins, secs) -> degrees\nhms2rad # (hours, mins, secs) -> radians\nhms2ha  # (hours, mins, secs) -> hour angles","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"the above functions can take a string as input and will automatically parse it (using parse_dms or parse_hms, respectively) before converting.","category":"page"},{"location":"modules/AstroAngles/#Formatting-angles","page":"AstroAngles","title":"Formatting angles","text":"","category":"section"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"Lastly, we have some simple methods for formatting angles into strings, although for more fine-tuned control we recommend using Printf or a package like Formatting.jl. format_angle takes parts (like from deg2dms or rad2hms) and a delimiter (or collection of 3 delimiters for each value).","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"julia> format_angle(deg2dms(45.0))\n\"45:0:0.0\"\n\njulia> format_angle(deg2hms(-65.0); delim=[\"h\", \"m\", \"s\"])\n\"-4h19m59.999999999998934s\"","category":"page"},{"location":"modules/AstroAngles/#Example:-reading-coordinates-from-a-table","page":"AstroAngles","title":"Example: reading coordinates from a table","text":"","category":"section"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"Here's an example of reading sky coordinates from a CSV formatted target list and converting them to degrees-","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"julia> using AstroAngles, CSV, DataFrames\n\njulia> table = CSV.File(\"target_list.csv\") |> DataFrame;\n\njulia> [table.ra table.dec]\n203×2 Matrix{String}:\n \"00 05 01.42\"  \"40 03 35.82\"\n \"00 05 07.52\"  \"73 13 11.34\"\n \"00 36 01.40\"  \"-11 12 13.00\"\n[...]\n\njulia> ra_d = @. hms2deg(table.ra)\n203-element Vector{Float64}:\n   1.2559166666666666\n   1.2813333333333332\n   9.005833333333333\n[...]\n\njulia> dec_d = @. dms2deg(table.dec)\n203-element Vector{Float64}:\n  40.05995\n  73.21981666666667\n -11.203611111111112\n[...]","category":"page"},{"location":"modules/AstroAngles/#Contributing/Support","page":"AstroAngles","title":"Contributing/Support","text":"","category":"section"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"To contribute, feel free to open a pull request. If you run into problems, please open an issue. To discuss ideas, usage, or to plan contributions, open a new discussion.","category":"page"},{"location":"modules/AstroAngles/#License","page":"AstroAngles","title":"License","text":"","category":"section"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"This code is MIT licensed. For more information, see LICENSE.","category":"page"},{"location":"highlevels/dataio/#Data-I/O-Overview","page":"Data I/O Overview","title":"Data I/O Overview","text":"","category":"section"},{"location":"highlevels/dataio/#Data-I/O","page":"Data I/O Overview","title":"Data I/O","text":"","category":"section"},{"location":"highlevels/dataio/#[AstroImages.jl](https://github.com/JuliaAstro/AstroImages.jl)-[![](../assets/book.png)](https://juliaastro.github.io/AstroImages.jl/stable/)","page":"Data I/O Overview","title":"AstroImages.jl (Image: )","text":"","category":"section"},{"location":"highlevels/dataio/","page":"Data I/O Overview","title":"Data I/O Overview","text":"Load, manipulate, and visualize astronomical images","category":"page"},{"location":"highlevels/dataio/","page":"Data I/O Overview","title":"Data I/O Overview","text":"Works with the FileIO.jl interface","category":"page"},{"location":"highlevels/dataio/#[FITSIO.jl](https://github.com/JuliaAstro/FITSIO.jl)-[![](../assets/book.png)](https://juliaastro.github.io/FITSIO.jl/stable/)","page":"Data I/O Overview","title":"FITSIO.jl (Image: )","text":"","category":"section"},{"location":"highlevels/dataio/","page":"Data I/O Overview","title":"Data I/O Overview","text":"Reading and writing FITS files","category":"page"},{"location":"highlevels/dataio/","page":"Data I/O Overview","title":"Data I/O Overview","text":"Interact with header data units (HDUs), FITS headers, and FITS data: both images and tables\nFITS tables follow the Tables.jl interface, allowing seamless integration with the rich data ecosystem, like CSV.jl, DataFrames.jl, etc.","category":"page"},{"location":"highlevels/dataio/#[CFITSIO.jl](https://github.com/JuliaAstro/CFITSIO.jl)-[![](../assets/book.png)](https://juliaastro.github.io/FITSIO.jl/stable/)","page":"Data I/O Overview","title":"CFITSIO.jl (Image: )","text":"","category":"section"},{"location":"highlevels/dataio/","page":"Data I/O Overview","title":"Data I/O Overview","text":"Reading and writing FITS files","category":"page"},{"location":"highlevels/dataio/","page":"Data I/O Overview","title":"Data I/O Overview","text":"Low-level wrapper for cfitsio\nThe c interface can be directly accessed with the CFITSIO_jll package","category":"page"},{"location":"highlevels/dataio/#[mweastwood/CasaCore.jl](https://github.com/mweastwood/CasaCore.jl)-[![](../assets/book.png)](http://mweastwood.info/CasaCore.jl/stable/)","page":"Data I/O Overview","title":"mweastwood/CasaCore.jl (Image: )","text":"","category":"section"},{"location":"highlevels/dataio/","page":"Data I/O Overview","title":"Data I/O Overview","text":"Tables and measurement sets for radio astronomy","category":"page"},{"location":"highlevels/dataio/","page":"Data I/O Overview","title":"Data I/O Overview","text":"Wrapper for CasaCore\nInterface for CASA tables and measures","category":"page"},{"location":"highlevels/dataio/#[emmt/OIFITS.jl](https://github.com/emmt/OIFITS.jl)","page":"Data I/O Overview","title":"emmt/OIFITS.jl","text":"","category":"section"},{"location":"highlevels/dataio/","page":"Data I/O Overview","title":"Data I/O Overview","text":"Support for OI-FITS","category":"page"},{"location":"highlevels/dataio/","page":"Data I/O Overview","title":"Data I/O Overview","text":"Read and write OI-FITS optical interferometry data format","category":"page"},{"location":"highlevels/dataio/#[aplavin/VLBIData.jl](https://gitlab.com/aplavin/VLBIData.jl)-[![](../assets/book.png)](https://aplavin.github.io/VLBIData.jl/test/examples.html)","page":"Data I/O Overview","title":"aplavin/VLBIData.jl (Image: )","text":"","category":"section"},{"location":"highlevels/dataio/","page":"Data I/O Overview","title":"Data I/O Overview","text":"Work with data formats common in very long baseline interferometry (VLBI)","category":"page"},{"location":"highlevels/dataio/","page":"Data I/O Overview","title":"Data I/O Overview","text":"Read interferometric visibilities (uvfits), images (fits), and source models\nMinimal writing support for source models","category":"page"},{"location":"highlevels/dataio/#[aplavin/Difmap.jl](https://gitlab.com/aplavin/Difmap.jl)","page":"Data I/O Overview","title":"aplavin/Difmap.jl","text":"","category":"section"},{"location":"highlevels/dataio/","page":"Data I/O Overview","title":"Data I/O Overview","text":"Wrapper for the Difmap program used in synthesis imaging","category":"page"},{"location":"highlevels/dataio/","page":"Data I/O Overview","title":"Data I/O Overview","text":"Execute Difmap scripts, handle inputs/outputs and logs\nDisplay images and plots from Difmap in interactive Julia environments","category":"page"},{"location":"#JuliaAstro","page":"Home","title":"JuliaAstro","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JuliaAstro and its affiliated organizations are a community for astronomy in Julia. We have a wide variety of packages from aperture photometry to cosmology. Check out a curated list of packages in the JuliaAstro ecosystem (and beyond) on the ecosystem page.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Our contributors come from diverse backgrounds and have various levels of interactions within astronomy and academia. Use the packages, file issues, and join the conversation!","category":"page"},{"location":"","page":"Home","title":"Home","text":"JuliaAstro on GitHub\nJuliaHCI on GitHub\njulia-astro mailing list on Google Groups\nAstro/Space topics on JuliaLang Discourse\n#JuliaAstro:openastronomy.org on Matrix\n#astronomy on JuliaLang Slack","category":"page"},{"location":"#Google-Summer-of-Code-(GSoC)","page":"Home","title":"Google Summer of Code (GSoC)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Would you like to contribute to JuliaAstro through Google Summer of Code? You can! We are member of OpenAstronomy; go to the GSoC page to see how to apply and the list of ideas. You can also propose your own idea to us!","category":"page"},{"location":"#Talks-and-Presentations","page":"Home","title":"Talks and Presentations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<details>\n<summary>JuliaCon 2022</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"Julia in Astronomy & Astrophysics Research\nComrade: High-Performance Black Hole Imaging\nRVSpectML: Precision Velocities from Spectroscopic Time Series\nFinding Fast Radio Bursts, Faster\nCosmological Emulators with Flux.jl and DifferentialEquations.jl\nVisualizing astronomical data with AstroImages.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"modules/Optimization/API/optimization_function/#optfunction","page":"OptimizationFunction","title":"OptimizationFunction","text":"","category":"section"},{"location":"modules/Optimization/API/optimization_function/","page":"OptimizationFunction","title":"OptimizationFunction","text":"SciMLBase.OptimizationFunction","category":"page"},{"location":"modules/Optimization/API/optimization_function/#Automatic-Differentiation-Construction-Choice-Recommendations","page":"OptimizationFunction","title":"Automatic Differentiation Construction Choice Recommendations","text":"","category":"section"},{"location":"modules/Optimization/API/optimization_function/","page":"OptimizationFunction","title":"OptimizationFunction","text":"The choices for the auto-AD fill-ins with quick descriptions are:","category":"page"},{"location":"modules/Optimization/API/optimization_function/","page":"OptimizationFunction","title":"OptimizationFunction","text":"AutoForwardDiff(): The fastest choice for small optimizations\nAutoReverseDiff(compile=false): A fast choice for large scalar optimizations\nAutoTracker(): Like ReverseDiff but GPU-compatible\nAutoZygote(): The fastest choice for non-mutating array-based (BLAS) functions\nAutoFiniteDiff(): Finite differencing, not optimal but always applicable\nAutoModelingToolkit(): The fastest choice for large scalar optimizations","category":"page"},{"location":"modules/Optimization/API/optimization_function/#Automatic-Differentiation-Choice-API","page":"OptimizationFunction","title":"Automatic Differentiation Choice API","text":"","category":"section"},{"location":"modules/Optimization/API/optimization_function/","page":"OptimizationFunction","title":"OptimizationFunction","text":"The following sections describe the Auto-AD choices in detail.","category":"page"},{"location":"modules/Optimization/API/optimization_function/","page":"OptimizationFunction","title":"OptimizationFunction","text":"AutoForwardDiff\nAutoFiniteDiff\nAutoReverseDiff\nAutoZygote\nAutoTracker\nAutoModelingToolkit","category":"page"},{"location":"modules/Optimization/optimization_packages/multistartoptimization/#MultiStartOptimization.jl","page":"MultistartOptimization.jl","title":"MultiStartOptimization.jl","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/multistartoptimization/","page":"MultistartOptimization.jl","title":"MultistartOptimization.jl","text":"MultistartOptimization is a is a Julia package implementing a global optimization multistart method which performs local optimization after choosing multiple starting points.","category":"page"},{"location":"modules/Optimization/optimization_packages/multistartoptimization/","page":"MultistartOptimization.jl","title":"MultistartOptimization.jl","text":"MultistartOptimization requires both a global and local method to be defined. The global multistart method chooses a set of initial starting points from where local the local method starts from.","category":"page"},{"location":"modules/Optimization/optimization_packages/multistartoptimization/","page":"MultistartOptimization.jl","title":"MultistartOptimization.jl","text":"Currently, only one global method (TikTak) is implemented and called by MultistartOptimization.TikTak(n) where n is the number of initial Sobol points. ","category":"page"},{"location":"modules/Optimization/optimization_packages/multistartoptimization/#Installation:-OptimizationMultistartOptimization.jl","page":"MultistartOptimization.jl","title":"Installation: OptimizationMultistartOptimization.jl","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/multistartoptimization/","page":"MultistartOptimization.jl","title":"MultistartOptimization.jl","text":"To use this package, install the OptimizationMultistartOptimization package:","category":"page"},{"location":"modules/Optimization/optimization_packages/multistartoptimization/","page":"MultistartOptimization.jl","title":"MultistartOptimization.jl","text":"import Pkg; Pkg.add(\"OptimizationMultistartOptimization\")","category":"page"},{"location":"modules/Optimization/optimization_packages/multistartoptimization/","page":"MultistartOptimization.jl","title":"MultistartOptimization.jl","text":"note: Note\n","category":"page"},{"location":"modules/Optimization/optimization_packages/multistartoptimization/","page":"MultistartOptimization.jl","title":"MultistartOptimization.jl","text":"You also need to load the relevant subpackage for the local method of you choice, for example if you plan to use one of the NLopt.jl's optimizers, you'd install and load OptimizationNLopt as described in the NLopt.jl's section.","category":"page"},{"location":"modules/Optimization/optimization_packages/multistartoptimization/#Global-Optimizer","page":"MultistartOptimization.jl","title":"Global Optimizer","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/multistartoptimization/#Without-Constraint-Equations","page":"MultistartOptimization.jl","title":"Without Constraint Equations","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/multistartoptimization/","page":"MultistartOptimization.jl","title":"MultistartOptimization.jl","text":"The methods in MultistartOptimization are performing global optimization on problems without constraint equations. However, lower and upper constraints set by lb and ub in the OptimizationProblem are required.","category":"page"},{"location":"modules/Optimization/optimization_packages/multistartoptimization/#Examples","page":"MultistartOptimization.jl","title":"Examples","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/multistartoptimization/","page":"MultistartOptimization.jl","title":"MultistartOptimization.jl","text":"The Rosenbrock function can optimized using MultistartOptimization.TikTak() with 100 initial points and the local method NLopt.LD_LBFGS() as follows:","category":"page"},{"location":"modules/Optimization/optimization_packages/multistartoptimization/","page":"MultistartOptimization.jl","title":"MultistartOptimization.jl","text":"using OptimizationMultistartOptimization\nusing OptimizationNLopt\nrosenbrock(x, p) =  (p[1] - x[1])^2 + p[2] * (x[2] - x[1]^2)^2\nx0 = zeros(2)\np  = [1.0, 100.0]\nf = OptimizationFunction(rosenbrock)\nprob = Optimization.OptimizationProblem(f, x0, p, lb = [-1.0,-1.0], ub = [1.0,1.0])\nsol = solve(prob, MultistartOptimization.TikTak(100), NLopt.LD_LBFGS())","category":"page"},{"location":"modules/Optimization/optimization_packages/multistartoptimization/","page":"MultistartOptimization.jl","title":"MultistartOptimization.jl","text":"You can use any Optimization optimizers you like. The global method of the MultistartOptimization is a positional argument and followed by the local method. This for example means we can perform a multistartoptimization with LBFGS as the optimizer using either the NLopt.jl or Optim.jl implementation as follows. Moreover, this interface allows you access and adjust all the optimizer settings as you normally would:","category":"page"},{"location":"modules/Optimization/optimization_packages/multistartoptimization/","page":"MultistartOptimization.jl","title":"MultistartOptimization.jl","text":"using OptimizationOptimJL\nusing ForwardDiff\nrosenbrock(x, p) =  (p[1] - x[1])^2 + p[2] * (x[2] - x[1]^2)^2\nx0 = zeros(2)\np  = [1.0, 100.0]\nf = OptimizationFunction(rosenbrock, Optimization.AutoForwardDiff())\nprob = Optimization.OptimizationProblem(f, x0, p, lb = [-1.0,-1.0], ub = [1.0,1.0])\nsol = solve(prob, MultistartOptimization.TikTak(100), LBFGS(), maxiters=5)","category":"page"},{"location":"highlevels/numerical-utils/#Numerical-Utilities-Overview","page":"Numerical Utilities Overview","title":"Numerical Utilities Overview","text":"","category":"section"},{"location":"tutorials/curve-fit/#curve-fit","page":"Curve Fitting","title":"Curve Fitting","text":"","category":"section"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"This tutorial will demonstrate fitting data with a straight line (linear regression), an abitrary non-linear model, and finally a Bayesian model.","category":"page"},{"location":"tutorials/curve-fit/#Packages","page":"Curve Fitting","title":"Packages","text":"","category":"section"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"LinearAlgebra we'll use this built-in Julia standard library to perform a linear regression\nOptimization: we'll use this package to display coordinates along the image and add the scalebar\nOptimizationOptimJL: the specific optimizer backend we will use.  For your own problems, select the best backend from the Optimization.jl documentation page.\nTuring: we'll use this package for Bayesian modelling.\nPairPlots: we'll use this for creating a corner plot of the posterior from our Bayesian models.","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"You can install the necessary packages by running Julia, and typing ] to enter Pkg-mode. Then: add Plots Optimization OptimizationOptimJL Turing PairPlots. Alternatively, you can run using Pkg; Pkg.add([\"Plots\", \"Optimization\", \"OptimizationOptimJL\", \"Turing\", \"PairPlots\"]). In your own code, you most likely won't need all of these packages. Pick and choose the one that best fits your problem.","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"If you will be using these tools as part of a bigger project, it's strongly recommended to create a Julia Project to record package versions. If you're just experimenting, you can create a temporary project by running ] activate --temp.","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"If you're using Pluto notebooks, installing and recording package versions in a project are handled for you automatically.","category":"page"},{"location":"tutorials/curve-fit/#Generating-the-data","page":"Curve Fitting","title":"Generating the data","text":"","category":"section"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"We'll generate synthetic data for this problem. We'll make a weak parabola with some noise. For consitency, we'll seed the Julia random number generator so that we see the same noise each time the tutorial is run.","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"julia> using Random\njulia> Random.seed!(1234)","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"By calling seed!, the pattern of random numbers generated by rand and randn will be the same each time.","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"Now we'll generate the data:","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"julia> x = 0:5:100 # Or equivalently: range(0, 100, step=5)\n0:1:100\n\njulia> y = (x ./ 20 .- 0.2).^2 .+ 2 .+ randn(length(x))\n101-element Vector{Float64}:\n  3.010656328855214\n  1.0432815884648003\n  ⋮\n 25.653998582068482\n 26.260043796712125\n","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"The randn function generates a random value normally distributed around 0 with a standard deviation of 1. rand on the other hand creates uniformly distributed random values distributed between 0 and 1.","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"Let's plot the data to see what it looks like:","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"julia> using Plots\njulia> scatter(x, y; xlabel=\"x\", ylabel=\"y\", label=\"data\")","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"(Image: )","category":"page"},{"location":"tutorials/curve-fit/#Linear-regression","page":"Curve Fitting","title":"Linear regression","text":"","category":"section"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"Before using any packages, let's perform a linear fit from scratch using some linear algebra.","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"The equation of a line can be written in matrix form as ","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"quad\nbeginpmatrix \nN  sum y_i \nsum y_i  sum y_i^2\nendpmatrix\nbeginpmatrix\nc_1 \nc_2 \nendpmatrix=\nbeginpmatrix\nsum y_i \nsum y_i x_i\nendpmatrix","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"where c_1 and c_2 are the intercept and slope.","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"Multiplying both sides by the inverse of the first matrix gives","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"quad\nbeginpmatrix\nc_1 \nc_2 \nendpmatrix=\nbeginpmatrix \nN  sum y_i \nsum y_i  sum y_i^2\nendpmatrix^-1\nbeginpmatrix\nsum y_i \nsum y_i x_i\nendpmatrix","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"We can write the right-hand side matrix and vector (let's call them A and b) in Julia notation like so:","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"julia> A = [\n          length(x) sum(x)\n          sum(x)    sum(x.^2)\n      ]\n2×2 Matrix{Int64}:\n   21   1050\n 1050  71750\n\njulia> b = [\n           sum(y)\n           sum(y .* x)                                          \n       ]\n2-element Vector{Float64}:\n   210.4250937868108\n 15023.030866331104","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"We can now perform the linear fit by solving the system of equations with the \\ operator:","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"julia> c = A\\b\n2-element Vector{Float64}:\n -1.67268257376372\n  0.2338585027008085\n","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"Let's make a helper function linfunc that takes an x value, a slope, and an intercept and calculates the corresponding y value:","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"julia> linfunc(x; slope, intercept) = slope*x + intercept\nlinfunc (generic function with 1 method)\n","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"Finally, we can plot the solution:","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"julia> yfit = linfunc.(x; slope=c[2], intercept=c[1])\njulia> scatter(x, y, xlabel=\"x\", ylabel=\"y\", label=\"data\")\njulia> plot!(x, yfit, label=\"best fit\")","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"(Image: )","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"The packages LsqFit and GLM (for generalized linear models) contain functions for performing and evaluating these types of linear fits.","category":"page"},{"location":"tutorials/curve-fit/#(Non-)linear-curve-fit","page":"Curve Fitting","title":"(Non-)linear curve fit","text":"","category":"section"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"The packages above can be used to fit different polynomial models, but if we have a truly arbitrary Julia function we would like to fit to some data we can use the Optimization.jl package. Through its various backends, Optimization.jl supports a very wide range of algorithms for local, global, convex, and non-convex optimization. ","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"The first step is to define our objective function. We'll reuse our simple linfunc linear function from above:","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"linfunc(x; slope, intercept) = slope*x + intercept\n\n# We must supply an objective function that will be minimized\n# The u argument is a vector of parameters from the optimizer.\n# data is a vector of static parameters passed through below.\nfunction objective(u, data)\n    # Get our fit parameters from u\n    slope, intercept = u\n    # equivalent to:\n    # slope = u[1]\n    # intercept = u[2]\n\n    # Get the x and y vectors from data\n    x, y = data\n    \n    # Calculate the residuals between our model and the data\n    residuals = linfunc.(x; slope, intercept) .- y\n\n    # Return the sum of squares of the residuals to minimize\n    return sum(residuals.^2)\nend\n\n# Define the initial parameter values for slope and intercept\nu0 = [1.0, 1.0]\n# Pass through the data we want to fit\ndata = [x,y]\n\n# Create an OptimizationProblem object to hold the function, initial\n# values, and data.\nusing Optimization\nprob = OptimizationProblem(objective,u0,data)\n\n# Import the optimization backend we want to use\nusing OptimizationOptimJL\n\n# Minimize the function. Optimization.jl uses the SciML common solver\n# interface. Pass the problem you want to solve (optimization problem\n# here) and a solver to use.\n# NelderMead() is a derivative-free method for finding a function's\n# local minimum.\nsol = solve(prob,NelderMead())\n\n# Exctract the best-fitting parameters\nslope, intercept = sol.u","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"Note: the NelderMead() algorithm behaves nearly identically to MATLAB's fminsearch. ","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"We can now plot the solution:","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"julia> yfit = linfunc.(x; slope, intercept)\njulia> scatter(x, y, xlabel=\"x\", ylabel=\"y\", label=\"data\")\njulia> plot!(x, yfit, label=\"best fit\")","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"(Image: )","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"We can now test out a quadratic fit using the same package:","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"function objective(u, data)\n    x, y = data\n    \n    # Define an equation of a quadratic, e.g.:\n    # 3x^2 + 2x + 1\n    model = u[1] .* x.^2 .+ u[2] .* x .+ u[3]\n\n    # Calculate the residuals between our model and the data\n    residuals = model .- y\n\n    # Return the sum of squares of the residuals to minimize\n    return sum(residuals.^2)\nend\n\nu0 = [1.0, 1.0, 1.0]\ndata = [x,y]\nprob = OptimizationProblem(objective,u0,data)\nusing OptimizationOptimJL\nsol = solve(prob,NelderMead())\nu = sol.u\n\nyfit = u[1] .* x.^2 .+ u[2] .* x .+ u[3]\n\nscatter(x, y, xlabel=\"x\", ylabel=\"y\", label=\"data\")\nplot!(x,  yfit, label=\"quadratic fit\")","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"(Image: )","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"This is already very fast; however, as the scale of your problem grows, there are several routes you can take to improve the optimization performance. First, you can use automatic differentiation and a higher order optimization algorithm:","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"using ForwardDiff\noptf = OptimizationFunction(objective, Optimization.AutoForwardDiff())\nprob = OptimizationProblem(optf,u0,data)\n@time sol = solve(prob,BFGS())  # another good algorithm is Newton()","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"You can also write an \"in-place\" version of objective that doesn't allocate new arrays with each iteration.","category":"page"},{"location":"tutorials/curve-fit/#Bayesian-models","page":"Curve Fitting","title":"Bayesian models","text":"","category":"section"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"Let's shift gears and now create a fully Bayesian model using the Turing.jl package.","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"Instead of defining an arbitrary Julia function, this package requires us to use a macro called @model.","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"Let's start with a linear model once more, now with the Turing @model syntax:","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"# Bayesian linear regression.\n@model function linear_regression(x, y)\n    # Set variance prior.\n    σ₂ ~ truncated(Normal(0, 100), 0, Inf)\n    # Typed as \\sigma <tab> \\_2 <tab>\n\n    # Set intercept prior.\n    intercept ~ Normal(0, 5)\n\n    # Set the prior on our slope coefficient.\n    slope ~ Normal(0, 10)\n\n    # Each point is drawn from a gaussian (Normal) distribution\n    # with mean calculated form our linear model, and standard\n    # deviation as the square root of the variance variable\n    for i in eachindex(x,y)\n        y[i] ~ Normal(x[i] * slope + intercept, sqrt(σ₂))\n    end\nend\n","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"We can now draw posterior samples from this model using one of many available samplers, NUTS, the No U-Turn Sampler.","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"model = linear_regression(x, y)\nchain = sample(model, NUTS(0.65), 500)","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"┌ Info: Found initial step size\n└   ϵ = 0.003125\nSampling 100%|█████████████████████████████████████| Time: 0:00:05\nChains MCMC chain (25000×15×1 Array{Float64, 3}):\n\nIterations        = 1001:1:26000\nNumber of chains  = 1\nSamples per chain = 25000\nWall duration     = 5.88 seconds\nCompute duration  = 5.88 seconds\nparameters        = σ₂, intercept, slope\ninternals         = lp, n_steps, is_accept, acceptance_rate, log_density, hamiltonian_energy, hamiltonian_energy_error, max_hamiltonian_energy_error, tree_depth, numerical_error, step_size, nom_step_size\n\nSummary Statistics\n  parameters      mean       std   naive_se      mcse          ess      rhat   ess_per_sec \n      Symbol   Float64   Float64    Float64   Float64      Float64   Float64       Float64\n\n          σ₂    6.7431    2.6279     0.0166    0.0265   10640.9415    1.0000     1810.6077\n   intercept   -1.5979    1.0739     0.0068    0.0105   10239.7534    1.0001     1742.3436\n       slope    0.2328    0.0186     0.0001    0.0002   10306.9493    1.0001     1753.7773\n\nQuantiles\n  parameters      2.5%     25.0%     50.0%     75.0%     97.5% \n      Symbol   Float64   Float64   Float64   Float64   Float64\n\n          σ₂    3.3126    4.9457    6.1965    7.9372   13.3608\n   intercept   -3.6910   -2.2965   -1.5992   -0.9049    0.5423\n       slope    0.1959    0.2206    0.2329    0.2449    0.2690","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"intercept = chain[\"intercept\"]\nslope = chain[\"slope\"]\nσ₂ = chain[\"σ₂\"]\n\nplot(x, x .* slope' .+ intercept';\n    label=\"\",\n    color=:gray,\n    alpha=0.05\n)\nscatter!(x, y, xlabel=\"x\", ylabel=\"y\", label=\"data\", color=1)","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"(Image: )","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"Each gray curve is a sample from the posterior distribution of this model. To examine the model parameters and their covariance in greater detail, we can make a corner plot using the PairPlots.jl package. We'll need a few more samples for a nice plot, so re-run the NUTS sampler with more iterations first.","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"Random.seed!(1234)\nchain = sample(model, NUTS(0.65), 25_000)\n\nusing PairPlots\ntable = (;\n    intercept= chain[\"intercept\"],\n    slope= chain[\"slope\"],\n    σ= sqrt.(chain[\"σ₂\"])\n)\nPairPlots.corner(table)","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"(Image: )","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"Let's now repeat this proceedure with a Bayesian quadratic model.","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"@model function quad_regression(x, y)\n    # Prior on the variance of the data around the best-fit line\n    σ₂ ~ truncated(Normal(0, 10), 0, Inf)\n\n    # Priors on the three quadratic parameters\n    u1 ~ Normal(0,0.01)\n    u2 ~ Normal(0,0.1)\n    u3 ~ Normal(0,5)\n\n    for i in eachindex(x,y)\n        model = u1 * x[i]^2 + u2*x[i] + u3\n        y[i] ~ Normal(model, sqrt(σ₂))\n    end\nend\n","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"We can now draw posterior samples from this model using one of many available samplers, NUTS, or the No U-Turn Sampler.","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"model = quad_regression(x, y)\nchain = sample(model, NUTS(0.65), 500)","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"┌ Info: Found initial step size\n└   ϵ = 0.0001953125\nSampling 100%|█████████████████████████████████████| Time: 0:00:05\nChains MCMC chain (500×16×1 Array{Float64, 3}):\n\nIterations        = 251:1:750\nNumber of chains  = 1\nSamples per chain = 500\nWall duration     = 5.89 seconds\nCompute duration  = 5.89 seconds\nparameters        = σ₂, u1, u2, u3\ninternals         = lp, n_steps, is_accept, acceptance_rate, log_density, hamiltonian_energy, hamiltonian_energy_error, max_hamiltonian_energy_error, tree_depth, numerical_error, step_size, nom_step_size\n\nSummary Statistics\n  parameters      mean       std   naive_se      mcse        ess      rhat   ess_per_sec \n      Symbol   Float64   Float64    Float64   Float64    Float64   Float64       Float64\n\n          σ₂    1.5698    0.6322     0.0283    0.0518   117.5553    0.9994       19.9517\n          u1    0.0024    0.0003     0.0000    0.0000   134.9184    0.9997       22.8986\n          u2   -0.0059    0.0283     0.0013    0.0024   107.3698    0.9995       18.2230\n          u3    2.1371    0.6109     0.0273    0.0562    87.2121    0.9995       14.8018\n\nQuantiles\n  parameters      2.5%     25.0%     50.0%     75.0%     97.5% \n      Symbol   Float64   Float64   Float64   Float64   Float64\n\n          σ₂    0.8757    1.1468    1.3945    1.8181    3.3834\n          u1    0.0018    0.0022    0.0024    0.0026    0.0030\n          u2   -0.0612   -0.0237   -0.0045    0.0133    0.0438\n          u3    0.9635    1.7155    2.1211    2.5172    3.3960","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"u1 = chain[\"u1\"]\nu2 = chain[\"u2\"]\nu3 = chain[\"u3\"]\nposterior = u1' .* x.^2 .+ u2' .* x .+ u3'\n\nplot(x, posterior;\n    label=\"\",\n    color=:gray,\n    alpha=0.1\n)\nscatter!(x, y, xlabel=\"x\", ylabel=\"y\", label=\"data\", color=1)","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"(Image: )","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"Random.seed!(1)\nchain = sample(model, NUTS(0.65), 25_000)\n\nusing PairPlots\ntable = (;\n    u_1 = chain[\"u1\"],\n    u_2 = chain[\"u2\"],\n    u_3 = chain[\"u3\"],\n    σ= sqrt.(chain[\"σ₂\"])\n)\nPairPlots.corner(table)","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"(Image: )","category":"page"},{"location":"tutorials/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"tutorials/","page":"Getting Started","title":"Getting Started","text":"Welcome! This page contains links to general tutorials useful to astronomers and astrophysicists getting started with Julia.","category":"page"},{"location":"tutorials/","page":"Getting Started","title":"Getting Started","text":"In Julia, smaller focussed packages are preferred. This page shows how you can combine smaller packages to get big results!","category":"page"},{"location":"tutorials/","page":"Getting Started","title":"Getting Started","text":"For more advanced usage examples, please see the documentation pages of the individual packages linked on the Ecosystem page.","category":"page"},{"location":"tutorials/#Installing-Julia","page":"Getting Started","title":"Installing Julia","text":"","category":"section"},{"location":"tutorials/","page":"Getting Started","title":"Getting Started","text":"To install Julia, it's strongly recommended to download the official binary for your operating system.  Visit the julialang.org Downloads page, and select the latest stable version for your operating system. Currently, this is 1.7.3. Click the [help] links next to your operating system if you require more detailed instructions.","category":"page"},{"location":"tutorials/#Installing-Packages","page":"Getting Started","title":"Installing Packages","text":"","category":"section"},{"location":"tutorials/","page":"Getting Started","title":"Getting Started","text":"Julia packages are installed and managed using the built-in package manager called Pkg.jl. You can either use it interactively by entering \"Pkg mode\" in your terminal, or programatically. We'll illustrate interactive use here.","category":"page"},{"location":"tutorials/","page":"Getting Started","title":"Getting Started","text":"Start julia in a terminal by running julia.\nType ] to enter package-mode (see Julia documentation for more details)\nType add SomePackage to install a package, replacing SomePackage with the desired package name without the .jl extension.","category":"page"},{"location":"tutorials/","page":"Getting Started","title":"Getting Started","text":"This will take a little while to download all the required packages and precompile for your system. If you have several packages to install, list them all at once instead of one by one to save time: add SomePackage1 SomePackage2 SomePackage3","category":"page"},{"location":"tutorials/","page":"Getting Started","title":"Getting Started","text":"It's recommended to use Julia projects to store what packages you use and make it easier to reproduce your work. You can create or activate a previously created project by entering Pkg-mode (type ]) and running activate myproject. Another option is to create a folder for your project, and start julia in that folder with the option julia --project=./. ","category":"page"},{"location":"tutorials/","page":"Getting Started","title":"Getting Started","text":"For more information on how to use the Julia package manager, refer to the Pkg.jl documentation.","category":"page"},{"location":"tutorials/#Tutorial-Index","page":"Getting Started","title":"Tutorial Index","text":"","category":"section"},{"location":"tutorials/","page":"Getting Started","title":"Getting Started","text":"The following tutorials show how to use Julia to perform common taks in astronomy and astrophysics.","category":"page"},{"location":"tutorials/#General","page":"Getting Started","title":"General","text":"","category":"section"},{"location":"tutorials/","page":"Getting Started","title":"Getting Started","text":"Plot a JWST image with world coordinates and a scale bar\nLoad tabular data from a FITS file and plot acceleration of nearby stars\nCurve fitting: least square and Bayesian","category":"page"},{"location":"highlevels/orb-ephem/#Orbits-and-Ephemerides-Overview","page":"Orbits & Ephemerides Overview","title":"Orbits & Ephemerides Overview","text":"","category":"section"},{"location":"highlevels/orb-ephem/#[Transits.jl](https://github.com/JuliaAstro/Transits.jl)-[![](../assets/book.png)](https://juliaastro.github.io/Transits.jl/stable/)","page":"Orbits & Ephemerides Overview","title":"Transits.jl (Image: )","text":"","category":"section"},{"location":"highlevels/orb-ephem/","page":"Orbits & Ephemerides Overview","title":"Orbits & Ephemerides Overview","text":"Flexible photometric transit curves with limb darkening","category":"page"},{"location":"highlevels/orb-ephem/","page":"Orbits & Ephemerides Overview","title":"Orbits & Ephemerides Overview","text":"Inspired by exoplanet\nIncludes Keplerian orbits and generic orbits\nFully compatible with Unitful.jl","category":"page"},{"location":"highlevels/orb-ephem/#[sefffal/PlanetOrbits.jl](https://github.com/sefffal/PlanetOrbits.jl)-[![](../assets/book.png)](https://sefffal.github.io/PlanetOrbits.jl/stable/)","page":"Orbits & Ephemerides Overview","title":"sefffal/PlanetOrbits.jl (Image: )","text":"","category":"section"},{"location":"highlevels/orb-ephem/","page":"Orbits & Ephemerides Overview","title":"Orbits & Ephemerides Overview","text":"Tools for displaying and solving Keplerian orbits in the context of direct imaging","category":"page"},{"location":"highlevels/orb-ephem/#[EarthOrientation.jl](https://github.com/JuliaAstro/EarthOrientation.jl)-[![](../assets/book.png)](https://juliaastro.github.io/EarthOrientation.jl/stable/)","page":"Orbits & Ephemerides Overview","title":"EarthOrientation.jl (Image: )","text":"","category":"section"},{"location":"highlevels/orb-ephem/","page":"Orbits & Ephemerides Overview","title":"Orbits & Ephemerides Overview","text":"Earth orientation parameters","category":"page"},{"location":"highlevels/orb-ephem/","page":"Orbits & Ephemerides Overview","title":"Orbits & Ephemerides Overview","text":"Calculate Earth orientation parameters from IERS tables","category":"page"},{"location":"highlevels/orb-ephem/#[JPLEphemeris.jl](https://github.com/JuliaAstro/JPLEphemeris.jl)","page":"Orbits & Ephemerides Overview","title":"JPLEphemeris.jl","text":"","category":"section"},{"location":"highlevels/orb-ephem/","page":"Orbits & Ephemerides Overview","title":"Orbits & Ephemerides Overview","text":"JPL Development Ephemerides","category":"page"},{"location":"highlevels/orb-ephem/","page":"Orbits & Ephemerides Overview","title":"Orbits & Ephemerides Overview","text":"Calculate positions and velocities of solar system bodies","category":"page"},{"location":"highlevels/orb-ephem/#[AstroLib.jl](https://github.com/JuliaAstro/astrolib.jl)-[![](../assets/book.png)](https://juliaastro.github.io/AstroLib.jl/stable/)","page":"Orbits & Ephemerides Overview","title":"AstroLib.jl (Image: )","text":"","category":"section"},{"location":"highlevels/orb-ephem/","page":"Orbits & Ephemerides Overview","title":"Orbits & Ephemerides Overview","text":"Collection of generic astronomical and astrophysical functions","category":"page"},{"location":"highlevels/orb-ephem/","page":"Orbits & Ephemerides Overview","title":"Orbits & Ephemerides Overview","text":"Translation of many IDL AstroLib procedures","category":"page"},{"location":"ecosystem/#eco","page":"Ecosystem","title":"Ecosystem","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"The joy of our community is the many astronomy and astrophysics packages available for wide use. Packages are separated by functionality and Julia's declarative package manager takes care of resolving dependencies. You get just the functionality you need, and smaller packages lead to more rapid development.","category":"page"},{"location":"ecosystem/#Data-I/O","page":"Ecosystem","title":"Data I/O","text":"","category":"section"},{"location":"ecosystem/#[AstroImages.jl](https://github.com/JuliaAstro/AstroImages.jl)-[![](assets/book.png)](https://juliaastro.github.io/AstroImages.jl/stable/)","page":"Ecosystem","title":"AstroImages.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Load, manipulate, and visualize astronomical images","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Works with the FileIO.jl interface","category":"page"},{"location":"ecosystem/#[FITSIO.jl](https://github.com/JuliaAstro/FITSIO.jl)-[![](assets/book.png)](https://juliaastro.github.io/FITSIO.jl/stable/)","page":"Ecosystem","title":"FITSIO.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Reading and writing FITS files","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Interact with header data units (HDUs), FITS headers, and FITS data: both images and tables\nFITS tables follow the Tables.jl interface, allowing seamless integration with the rich data ecosystem, like CSV.jl, DataFrames.jl, etc.","category":"page"},{"location":"ecosystem/#[CFITSIO.jl](https://github.com/JuliaAstro/CFITSIO.jl)-[![](assets/book.png)](https://juliaastro.github.io/FITSIO.jl/stable/)","page":"Ecosystem","title":"CFITSIO.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Reading and writing FITS files","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Low-level wrapper for cfitsio\nThe c interface can be directly accessed with the CFITSIO_jll package","category":"page"},{"location":"ecosystem/#[mweastwood/CasaCore.jl](https://github.com/mweastwood/CasaCore.jl)-[![](assets/book.png)](http://mweastwood.info/CasaCore.jl/stable/)","page":"Ecosystem","title":"mweastwood/CasaCore.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Tables and measurement sets for radio astronomy","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Wrapper for CasaCore\nInterface for CASA tables and measures","category":"page"},{"location":"ecosystem/#[emmt/OIFITS.jl](https://github.com/emmt/OIFITS.jl)","page":"Ecosystem","title":"emmt/OIFITS.jl","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Support for OI-FITS","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Read and write OI-FITS optical interferometry data format","category":"page"},{"location":"ecosystem/#[aplavin/VLBIData.jl](https://gitlab.com/aplavin/VLBIData.jl)-[![](assets/book.png)](https://aplavin.github.io/VLBIData.jl/test/examples.html)","page":"Ecosystem","title":"aplavin/VLBIData.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Work with data formats common in very long baseline interferometry (VLBI)","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Read interferometric visibilities (uvfits), images (fits), and source models\nMinimal writing support for source models","category":"page"},{"location":"ecosystem/#[aplavin/Difmap.jl](https://gitlab.com/aplavin/Difmap.jl)","page":"Ecosystem","title":"aplavin/Difmap.jl","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Wrapper for the Difmap program used in synthesis imaging","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Execute Difmap scripts, handle inputs/outputs and logs\nDisplay images and plots from Difmap in interactive Julia environments","category":"page"},{"location":"ecosystem/#Visualization-and-Plotting","page":"Ecosystem","title":"Visualization and Plotting","text":"","category":"section"},{"location":"ecosystem/#[AstroImages.jl](https://github.com/JuliaAstro/AstroImages.jl)-[![](assets/book.png)](https://juliaastro.github.io/AstroImages.jl/stable/)-2","page":"Ecosystem","title":"AstroImages.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Load, manipulate, and visualize astronomical images","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Works with the FileIO.jl interface\nAutomatic visualizations are directly integrated into many environments like VSCode, Pluto.jl, and IJulia.jl\nIncludes recipes for plotting with Plots.jl","category":"page"},{"location":"ecosystem/#[SAOImageDS9.jl](https://github.com/JuliaAstro/SAOImageDS9.jl)-[![](assets/book.png)](https://juliaastro.github.io/SAOImageDS9.jl/stable/)","page":"Ecosystem","title":"SAOImageDS9.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Interface with the DS9 image viewer","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Uses XPA.jl to communicate with DS9 instances\nEasily display images in DS9 and add features like circles and lines\nLow-level API accessible with set and get","category":"page"},{"location":"ecosystem/#Image-Processing","page":"Ecosystem","title":"Image Processing","text":"","category":"section"},{"location":"ecosystem/#[CCDReduction.jl](https://github.com/JuliaAstro/CCDReduction.jl)-[![](assets/book.png)](https://juliaastro.github.io/CCDReduction.jl/stable/)","page":"Ecosystem","title":"CCDReduction.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Common CCD image processing routines","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Creation of calibration files\nDark subtraction, flat normalization, bias subtraction, cropping\nSpecialized iterator for processing directories of FITS files using a table built from the FITS headers.","category":"page"},{"location":"ecosystem/#[LACosmic.jl](https://github.com/JuliaAstro/LACosmic.jl)-[![](assets/book.png)](https://juliaastro.github.io/LACosmic.jl/stable/)","page":"Ecosystem","title":"LACosmic.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Cosmic-ray rejection by Laplacian edge detection","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Implementation of the L.A.Cosmic algorithm (van Dokkum, 2001)\nReturns bad pixel masks and cleaned data","category":"page"},{"location":"ecosystem/#[Photometry.jl](https://github.com/JuliaAstro/Photometry.jl)-[![](assets/book.png)](https://juliaastro.github.io/Photometry.jl/stable/)","page":"Ecosystem","title":"Photometry.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Aperture photometry","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Background estimation and source extraction\nFast and precise aperture photometry","category":"page"},{"location":"ecosystem/#[PSFModels.jl](https://github.com/JuliaAstro/PSFModels.jl)-[![](assets/book.png)](https://juliaastro.github.io/PSFModels.jl/stable/)","page":"Ecosystem","title":"PSFModels.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Analytical, allocation-free point-spread-functions (PSF)","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Lazy representation allows fast allocation-free calculations\nGaussian (Normal), Moffat, and Airy disk.","category":"page"},{"location":"ecosystem/#[Reproject.jl](https://github.com/JuliaAstro/Reproject.jl)-[![](assets/book.png)](https://juliaastro.github.io/Reproject.jl/stable/)","page":"Ecosystem","title":"Reproject.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Astronomical image reprojection","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Uses FITSIO.jl and WCS.jl to reproject coordinate systems between FITS images","category":"page"},{"location":"ecosystem/#[JuliaHCI/HCIToolbox.jl](https://github.com/JuliaHCI/HCIToolbox.jl)-[![](assets/book.png)](http://JuliaHCI.github.io/HCIToolbox.jl/stable/)","page":"Ecosystem","title":"JuliaHCI/HCIToolbox.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Common utilities for high-contrast imaging (HCI) processing","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Morphological operations (rotation, stacking, shifting)\nMasking routines (circles, annulus, series of annuli)\nSpectral scaling and descaling","category":"page"},{"location":"ecosystem/#[JuliaHCI/SubpixelRegistration.jl](https://github.com/JuliaHCI/SubpixelRegistration.jl)-[![](assets/book.png)](http://JuliaHCI.github.io/SubpixelRegistration.jl/stable/)","page":"Ecosystem","title":"JuliaHCI/SubpixelRegistration.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Sub-pixel registration using discrete Fourier transforms","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Uses FFTs to register images, with arbitrary precision\nIncludes methods for Fourier based image-translation (phase-shifting)","category":"page"},{"location":"ecosystem/#[JuliaHCI/ADI.jl](https://github.com/JuliaHCI/ADI.jl)-[![](assets/book.png)](http://JuliaHCI.github.io/ADI.jl/stable/)","page":"Ecosystem","title":"JuliaHCI/ADI.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Angular Differential Imaging (ADI) routines in Julia","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"PCA, NMF, LLSG, LOCI, etc.\nApply algorithms framewise or in spectral differential imaging (SDI) using Julia's multiple dispatch\nProvide an interface for using these algorithms in other tools\nCommon HCI metrics including S/N maps, contrast curves, throughput curves (from PSF injection), STIM, etc.","category":"page"},{"location":"ecosystem/#Statistics","page":"Ecosystem","title":"Statistics","text":"","category":"section"},{"location":"ecosystem/#[mileslucas/BiweightStats.jl](https://github.com/mileslucas/BiweightStats.jl)-[![](assets/book.png)](http://mileslucas.com/BiweightStats.jl/stable/)","page":"Ecosystem","title":"mileslucas/BiweightStats.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Robust statistics based on the biweight transform","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Implements the location, scale, midvariance, midcovariance, and midcorrelation statistics","category":"page"},{"location":"ecosystem/#[JuliaHCI/ADI.jl](https://github.com/JuliaHCI/ADI.jl)-[![](assets/book.png)](http://JuliaHCI.github.io/ADI.jl/stable/)-2","page":"Ecosystem","title":"JuliaHCI/ADI.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Angular Differential Imaging (ADI) routines in Julia","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"PCA, NMF, LLSG, LOCI, etc.\nApply algorithms framewise or in spectral differential imaging (SDI) using Julia's multiple dispatch\nProvide an interface for using these algorithms in other tools\nCommon HCI metrics including S/N maps, contrast curves, throughput curves (from PSF injection), STIM, etc.","category":"page"},{"location":"ecosystem/#Time,-Coordinates,-Units","page":"Ecosystem","title":"Time, Coordinates, Units","text":"","category":"section"},{"location":"ecosystem/#[AstroAngles.jl](https://github.com/JuliaAstro/AstroAngles.jl)","page":"Ecosystem","title":"AstroAngles.jl","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"String parsing and representation of angles","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Parse and represent sexagesimal angles with a variety of delimiters\nMethods for converting to hour-minute-second angles from degrees and radians, and vice-versa","category":"page"},{"location":"ecosystem/#[AstroTime.jl](https://github.com/JuliaAstro/AstroTime.jl)-[![](assets/book.png)](https://juliaastro.github.io/AstroTime.jl/stable/)","page":"Ecosystem","title":"AstroTime.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Astronomical time keeping","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"High-precision, time-scale aware, DateTime-like data type\nSupport all commonly used astronomical time scales","category":"page"},{"location":"ecosystem/#[ERFA.jl](https://github.com/JuliaAstro/ERFA.jl)","page":"Ecosystem","title":"ERFA.jl","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Time systems conversions","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Low-level wrapper for liberfa","category":"page"},{"location":"ecosystem/#[SkyCoords.jl](https://github.com/JuliaAstro/SkyCoords.jl)","page":"Ecosystem","title":"SkyCoords.jl","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Astronomical coordinate systems","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Supports ICRS, galactic, and FK5 coordinate systems\nFast conversion of coordinates between different systems","category":"page"},{"location":"ecosystem/#[UnitfulAstro.jl](https://github.com/JuliaAstro/UnitfulAstro.jl)-[![](assets/book.png)](https://juliaastro.github.io/UnitfulAstro.jl/stable/)","page":"Ecosystem","title":"UnitfulAstro.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Astronomical units","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Extension of Unitful.jl","category":"page"},{"location":"ecosystem/#[WCS.jl](https://github.com/JuliaAstro/WCS.jl)-[![](assets/book.png)](https://juliaastro.github.io/WCS.jl/stable/)","page":"Ecosystem","title":"WCS.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"World Coordinate System transformations","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Wrapper for wcslib","category":"page"},{"location":"ecosystem/#Orbits-and-Ephemerides","page":"Ecosystem","title":"Orbits and Ephemerides","text":"","category":"section"},{"location":"ecosystem/#[Transits.jl](https://github.com/JuliaAstro/Transits.jl)-[![](assets/book.png)](https://juliaastro.github.io/Transits.jl/stable/)","page":"Ecosystem","title":"Transits.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Flexible photometric transit curves with limb darkening","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Inspired by exoplanet\nIncludes Keplerian orbits and generic orbits\nFully compatible with Unitful.jl","category":"page"},{"location":"ecosystem/#[sefffal/PlanetOrbits.jl](https://github.com/sefffal/PlanetOrbits.jl)-[![](assets/book.png)](https://sefffal.github.io/PlanetOrbits.jl/stable/)","page":"Ecosystem","title":"sefffal/PlanetOrbits.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Tools for displaying and solving Keplerian orbits in the context of direct imaging","category":"page"},{"location":"ecosystem/#[EarthOrientation.jl](https://github.com/JuliaAstro/EarthOrientation.jl)-[![](assets/book.png)](https://juliaastro.github.io/EarthOrientation.jl/stable/)","page":"Ecosystem","title":"EarthOrientation.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Earth orientation parameters","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Calculate Earth orientation parameters from IERS tables","category":"page"},{"location":"ecosystem/#[JPLEphemeris.jl](https://github.com/JuliaAstro/JPLEphemeris.jl)","page":"Ecosystem","title":"JPLEphemeris.jl","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"JPL Development Ephemerides","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Calculate positions and velocities of solar system bodies","category":"page"},{"location":"ecosystem/#[AstroLib.jl](https://github.com/JuliaAstro/astrolib.jl)-[![](assets/book.png)](https://juliaastro.github.io/AstroLib.jl/stable/)","page":"Ecosystem","title":"AstroLib.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Collection of generic astronomical and astrophysical functions","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Translation of many IDL AstroLib procedures","category":"page"},{"location":"ecosystem/#General","page":"Ecosystem","title":"General","text":"","category":"section"},{"location":"ecosystem/#[AstroLib.jl](https://github.com/JuliaAstro/astrolib.jl)-[![](assets/book.png)](https://juliaastro.github.io/AstroLib.jl/stable/)-2","page":"Ecosystem","title":"AstroLib.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Collection of generic astronomical and astrophysical functions","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Translation of many IDL AstroLib procedures","category":"page"},{"location":"ecosystem/#[BoxLeastSquares.jl](https://github.com/JuliaAstro/BoxLeastSquares.jl)-[![](assets/book.png)](https://juliaastro.github.io/BoxLeastSquares.jl/stable/)","page":"Ecosystem","title":"BoxLeastSquares.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Compute box-least-squares periodogram","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Fit BLS periodograms to time-series data\nExtract best-fitting transit parameters from the BLS periodogram\nFully compatible with Unitful.jl","category":"page"},{"location":"ecosystem/#[Cosmology.jl](https://github.com/JuliaAstro/Cosmology.jl)-[![](assets/book.png)](https://juliaastro.github.io/Cosmology.jl/stable/)","page":"Ecosystem","title":"Cosmology.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Distances in the universe","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Lambda-CDM and w_0-w_a cosmologies\nOpen, closed, and flat variants\nFully compatible with Unitful.jl","category":"page"},{"location":"ecosystem/#[DustExtinction.jl](https://github.com/JuliaAstro/DustExtinction.jl)-[![](assets/book.png)](https://juliaastro.github.io/DustExtinction.jl/stable/)","page":"Ecosystem","title":"DustExtinction.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Dust extinction laws and maps","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Various empirical extinction models\nSFD (1998) galactic dust map\nFully compatible with Unitful.jl","category":"page"},{"location":"ecosystem/#[LombScargle.jl](https://github.com/JuliaAstro/LombScargle.jl)-[![](assets/book.png)](https://juliaastro.github.io/LombScargle.jl/stable/)","page":"Ecosystem","title":"LombScargle.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Compute Lomb-Scargle periodogram","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Create periodograms from unevenly sampled periodic signals\nSupports multi-threading","category":"page"},{"location":"ecosystem/#[manuelbehrendt/Mera.jl](https://github.com/ManuelBehrendt/Mera.jl)-[![](assets/book.png)](https://manuelbehrendt.github.io/Mera.jl/stable/)","page":"Ecosystem","title":"manuelbehrendt/Mera.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Working with large hydrodynamical simulation data","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Loading, writing, analysing 3D AMR/uniform-grid and N-body data sets\nMemory lightweight data processing within a database framework\nMany predefined functions and examples","category":"page"},{"location":"ecosystem/#[Photometry.jl](https://github.com/JuliaAstro/Photometry.jl)-[![](assets/book.png)](https://juliaastro.github.io/Photometry.jl/stable/)-2","page":"Ecosystem","title":"Photometry.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Aperture photometry","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Background estimation and source extraction\nFast and precise aperture photometry","category":"page"},{"location":"ecosystem/#[Transits.jl](https://github.com/JuliaAstro/Transits.jl)-[![](assets/book.png)](https://juliaastro.github.io/Transits.jl/stable/)-2","page":"Ecosystem","title":"Transits.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Flexible photometric transit curves with limb darkening","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Inspired by exoplanet\nIncludes Keplerian orbits and generic orbits\nFast polynomial limb-darkening laws based on Agol, Luger, Foreman-Mackey (2020)\nComposable limb-darkening extensions for integrated light curves and secondary light curves.\nFully compatible with Unitful.jl","category":"page"},{"location":"modules/Optimization/API/optimization_problem/#Defining-OptimizationProblems","page":"Defining OptimizationProblems","title":"Defining OptimizationProblems","text":"","category":"section"},{"location":"modules/Optimization/API/optimization_problem/","page":"Defining OptimizationProblems","title":"Defining OptimizationProblems","text":"SciMLBase.OptimizationProblem","category":"page"},{"location":"modules/Optimization/optimization_packages/blackboxoptim/#BlackBoxOptim.jl","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/blackboxoptim/","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"BlackBoxOptim is a is a Julia package implementing (Meta-)heuristic/stochastic algorithms that do not require for the optimized function to be differentiable.","category":"page"},{"location":"modules/Optimization/optimization_packages/blackboxoptim/#Installation:-OptimizationBBO.jl","page":"BlackBoxOptim.jl","title":"Installation: OptimizationBBO.jl","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/blackboxoptim/","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"To use this package, install the OptimizationBBO package:","category":"page"},{"location":"modules/Optimization/optimization_packages/blackboxoptim/","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"import Pkg; Pkg.add(\"OptimizationBBO\")","category":"page"},{"location":"modules/Optimization/optimization_packages/blackboxoptim/#Global-Optimizers","page":"BlackBoxOptim.jl","title":"Global Optimizers","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/blackboxoptim/#Without-Constraint-Equations","page":"BlackBoxOptim.jl","title":"Without Constraint Equations","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/blackboxoptim/","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"The algorithms in BlackBoxOptim are performing global optimization on problems without constraint equations. However, lower and upper constraints set by lb and ub in the OptimizationProblem are required.","category":"page"},{"location":"modules/Optimization/optimization_packages/blackboxoptim/","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"A BlackBoxOptim algorithm is called by BBO_ prefix followed by the algorithm name:","category":"page"},{"location":"modules/Optimization/optimization_packages/blackboxoptim/","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"Natural Evolution Strategies:\nSeparable NES: BBO_separable_nes()\nExponential NES: BBO_xnes()\nDistance-weighted Exponential NES: BBO_dxnes()\nDifferential Evolution optimizers, 5 different:\nAdaptive DE/rand/1/bin: BBO_adaptive_de_rand_1_bin()\nAdaptive DE/rand/1/bin with radius limited sampling: BBO_adaptive_de_rand_1_bin_radiuslimited()\nDE/rand/1/bin: BBO_de_rand_1_bin()\nDE/rand/1/bin with radius limited sampling (a type of trivial geography): BBO_de_rand_1_bin_radiuslimited()\nDE/rand/2/bin: de_rand_2_bin()\nDE/rand/2/bin with radius limited sampling (a type of trivial geography): BBO_de_rand_2_bin_radiuslimited()\nDirect search:\nGenerating set search:\nCompass/coordinate search: BBO_generating_set_search()\nDirect search through probabilistic descent: BBO_probabilistic_descent()\nResampling Memetic Searchers:\nResampling Memetic Search (RS): BBO_resampling_memetic_search()\nResampling Inheritance Memetic Search (RIS): BBO_resampling_inheritance_memetic_search()\nStochastic Approximation:\nSimultaneous Perturbation Stochastic Approximation (SPSA): BBO_simultaneous_perturbation_stochastic_approximation()\nRandomSearch (to compare to): BBO_random_search()","category":"page"},{"location":"modules/Optimization/optimization_packages/blackboxoptim/","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"The recommended optimizer is BBO_adaptive_de_rand_1_bin_radiuslimited()","category":"page"},{"location":"modules/Optimization/optimization_packages/blackboxoptim/","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"The currently available algorithms are listed here","category":"page"},{"location":"modules/Optimization/optimization_packages/blackboxoptim/#Example","page":"BlackBoxOptim.jl","title":"Example","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/blackboxoptim/","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"The Rosenbrock function can optimized using the BBO_adaptive_de_rand_1_bin_radiuslimited() as follows:","category":"page"},{"location":"modules/Optimization/optimization_packages/blackboxoptim/","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"rosenbrock(x, p) =  (p[1] - x[1])^2 + p[2] * (x[2] - x[1]^2)^2\nx0 = zeros(2)\np  = [1.0, 100.0]\nf = OptimizationFunction(rosenbrock)\nprob = Optimization.OptimizationProblem(f, x0, p, lb = [-1.0,-1.0], ub = [1.0,1.0])\nsol = solve(prob, BBO_adaptive_de_rand_1_bin_radiuslimited(), maxiters=100000, maxtime=1000.0)","category":"page"},{"location":"modules/VLBIData/","page":"VLBIData","title":"VLBIData","text":"VLBIData.jl reads a range of data formats typically used in very long baseline interferometry (VLBI).","category":"page"},{"location":"modules/VLBIData/","page":"VLBIData","title":"VLBIData","text":"See the notebook for docs and usage examples.","category":"page"},{"location":"modules/CasaCore/#CasaCore.jl","page":"CasaCore","title":"CasaCore.jl","text":"","category":"section"},{"location":"modules/CasaCore/","page":"CasaCore","title":"CasaCore","text":"<img src=\"docs/src/assets/logo.png\" alt=\"CasaCore.jl\" width=\"200\">","category":"page"},{"location":"modules/CasaCore/","page":"CasaCore","title":"CasaCore","text":"(Image: Build Status) (Image: codecov) (Image: DOI)","category":"page"},{"location":"modules/CasaCore/","page":"CasaCore","title":"CasaCore","text":"CasaCore.jl is a Julia wrapper of CasaCore, which is a commonly used library in radio astronomy.","category":"page"},{"location":"modules/CasaCore/","page":"CasaCore","title":"CasaCore","text":"Functionality is divided into two submodules:","category":"page"},{"location":"modules/CasaCore/","page":"CasaCore","title":"CasaCore","text":"CasaCore.Tables for interfacing with tables (for example Casa measurement sets), and\nCasaCore.Measures for performing coordinate system conversions (for example calculating the azimuth and elevation of an astronomical target).","category":"page"},{"location":"modules/CasaCore/","page":"CasaCore","title":"CasaCore","text":"Documentation: http://mweastwood.info/CasaCore.jl/stable/","category":"page"},{"location":"modules/CasaCore/","page":"CasaCore","title":"CasaCore","text":"Author: Michael Eastwood","category":"page"},{"location":"modules/CasaCore/","page":"CasaCore","title":"CasaCore","text":"License: GPLv3+","category":"page"},{"location":"modules/Optimization/optimization_packages/gcmaes/#GCMAES.jl","page":"GCMAES.jl","title":"GCMAES.jl","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/gcmaes/","page":"GCMAES.jl","title":"GCMAES.jl","text":"GCMAES is a Julia package implementing the Gradient-based Covariance Matrix Adaptation Evolutionary Strategy which can utilize the gradient information to speed up the optimization process.","category":"page"},{"location":"modules/Optimization/optimization_packages/gcmaes/#Installation:-OptimizationGCMAES.jl","page":"GCMAES.jl","title":"Installation: OptimizationGCMAES.jl","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/gcmaes/","page":"GCMAES.jl","title":"GCMAES.jl","text":"To use this package, install the OptimizationGCMAES package:","category":"page"},{"location":"modules/Optimization/optimization_packages/gcmaes/","page":"GCMAES.jl","title":"GCMAES.jl","text":"import Pkg; Pkg.add(\"OptimizationGCMAES\")","category":"page"},{"location":"modules/Optimization/optimization_packages/gcmaes/#Global-Optimizer","page":"GCMAES.jl","title":"Global Optimizer","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/gcmaes/#Without-Constraint-Equations","page":"GCMAES.jl","title":"Without Constraint Equations","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/gcmaes/","page":"GCMAES.jl","title":"GCMAES.jl","text":"The GCMAES algorithm is called by GCMAESOpt() and the initial search variance is set as a keyword argument σ0 (default: σ0 = 0.2)","category":"page"},{"location":"modules/Optimization/optimization_packages/gcmaes/","page":"GCMAES.jl","title":"GCMAES.jl","text":"The method in GCMAES is performing global optimization on problems without constraint equations. However, lower and upper constraints set by lb and ub in the OptimizationProblem are required.","category":"page"},{"location":"modules/Optimization/optimization_packages/gcmaes/#Example","page":"GCMAES.jl","title":"Example","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/gcmaes/","page":"GCMAES.jl","title":"GCMAES.jl","text":"The Rosenbrock function can optimized using the GCMAESOpt() without utilizing the gradient information as follows:","category":"page"},{"location":"modules/Optimization/optimization_packages/gcmaes/","page":"GCMAES.jl","title":"GCMAES.jl","text":"rosenbrock(x, p) =  (p[1] - x[1])^2 + p[2] * (x[2] - x[1]^2)^2\nx0 = zeros(2)\np  = [1.0, 100.0]\nf = OptimizationFunction(rosenbrock)\nprob = Optimization.OptimizationProblem(f, x0, p, lb = [-1.0,-1.0], ub = [1.0,1.0])\nsol = solve(prob, GCMAESOpt())","category":"page"},{"location":"modules/Optimization/optimization_packages/gcmaes/","page":"GCMAES.jl","title":"GCMAES.jl","text":"We can also utilise the gradient information of the optimization problem to aid the optimization as follows:","category":"page"},{"location":"modules/Optimization/optimization_packages/gcmaes/","page":"GCMAES.jl","title":"GCMAES.jl","text":"rosenbrock(x, p) =  (p[1] - x[1])^2 + p[2] * (x[2] - x[1]^2)^2\nx0 = zeros(2)\np  = [1.0, 100.0]\nf = OptimizationFunction(rosenbrock, Optimization.ForwardDiff)\nprob = Optimization.OptimizationProblem(f, x0, p, lb = [-1.0,-1.0], ub = [1.0,1.0])\nsol = solve(prob, GCMAESOpt())","category":"page"},{"location":"modules/Optimization/optimization_packages/nonconvex/#Nonconvex.jl","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"Nonconvex is a is a Julia package implementing and wrapping nonconvex constrained optimization algorithms.","category":"page"},{"location":"modules/Optimization/optimization_packages/nonconvex/#Installation:-OptimizationNonconvex.jl","page":"Nonconvex.jl","title":"Installation: OptimizationNonconvex.jl","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"To use this package, install the OptimizationNonconvex package:","category":"page"},{"location":"modules/Optimization/optimization_packages/nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"import Pkg; Pkg.add(\"OptimizationNonconvex\")","category":"page"},{"location":"modules/Optimization/optimization_packages/nonconvex/#Global-Optimizer","page":"Nonconvex.jl","title":"Global Optimizer","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/nonconvex/#Without-Constraint-Equations","page":"Nonconvex.jl","title":"Without Constraint Equations","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"A Nonconvex algorithm is called using one of the following:","category":"page"},{"location":"modules/Optimization/optimization_packages/nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"Method of moving asymptotes (MMA):\nMMA87()\nMMA02()\nIpopt:\nIpoptAlg()\nNLopt:\nNLoptAlg(solver) where solver can be any of the NLopt algorithms\nAugmented Lagrangian algorithm:\nAugLag()\nonly works with constraints\nMixed integer nonlinear programming (MINLP):\nJuniper + Ipopt: JuniperIpoptAlg()\nPavito + Ipopt + Cbc: PavitoIpoptCbcAlg()\nMulti-start optimization:\nHyperoptAlg(subsolver) where subalg can be any of the described Nonconvex algorithm\nSurrogate-assisted Bayesian optimization\nBayesOptAlg(subsolver) where subalg can be any of the described Nonconvex algorithm\nMultiple Trajectory Search\nMTSAlg()","category":"page"},{"location":"modules/Optimization/optimization_packages/nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"When performing optimizing a combination of integer and floating-point parameters the integer keyword has to be set. It takes a boolean vector indicating which parameter is an integer.","category":"page"},{"location":"modules/Optimization/optimization_packages/nonconvex/#Notes","page":"Nonconvex.jl","title":"Notes","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"Some optimizer may require further options to be defined in order to work.","category":"page"},{"location":"modules/Optimization/optimization_packages/nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"The currently available algorithms are listed here","category":"page"},{"location":"modules/Optimization/optimization_packages/nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"The algorithms in Nonconvex are performing global optimization on problems without constraint equations. However, lower and upper constraints set by lb and ub in the OptimizationProblem are required.","category":"page"},{"location":"modules/Optimization/optimization_packages/nonconvex/#Examples","page":"Nonconvex.jl","title":"Examples","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"The Rosenbrock function can optimized using the Method of moving asymptotes algorithm MMA02() as follows:","category":"page"},{"location":"modules/Optimization/optimization_packages/nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"rosenbrock(x, p) =  (p[1] - x[1])^2 + p[2] * (x[2] - x[1]^2)^2\nx0 = zeros(2)\np  = [1.0, 100.0]\nf = OptimizationFunction(rosenbrock)\nprob = Optimization.OptimizationProblem(f, x0, p, lb = [-1.0,-1.0], ub = [1.0,1.0])\nsol = solve(prob, MMA02(), maxiters=100000, maxtime=1000.0)","category":"page"},{"location":"modules/Optimization/optimization_packages/nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"The options of for a sub-algorithm are passed simply as a NamedTuple and GalactcOptim infers the correct Nonconvex options struct:","category":"page"},{"location":"modules/Optimization/optimization_packages/nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"rosenbrock(x, p) =  (p[1] - x[1])^2 + p[2] * (x[2] - x[1]^2)^2\nx0 = zeros(2)\np  = [1.0, 100.0]\nf = OptimizationFunction(rosenbrock)\nprob = Optimization.OptimizationProblem(f, x0, p, lb = [-1.0,-1.0], ub = [1.0,1.0])\nsol = solve(prob, HyperoptAlg(IpoptAlg()), sub_options=(;max_iter=100))","category":"page"},{"location":"modules/Optimization/optimization_packages/nonconvex/#With-Constraint-Equations","page":"Nonconvex.jl","title":"With Constraint Equations","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/nonconvex/","page":"Nonconvex.jl","title":"Nonconvex.jl","text":"While Nonconvex.jl supports such constraints, Optimization.jl currently does not relay these constraints.","category":"page"},{"location":"modules/Optimization/optimization_packages/metaheuristics/#Metaheuristics.jl","page":"Metaheuristics.jl","title":"Metaheuristics.jl","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/metaheuristics/","page":"Metaheuristics.jl","title":"Metaheuristics.jl","text":"Metaheuristics is a is a Julia package implementing metaheuristic algorithms for global optiimization that do not require for the optimized function to be differentiable.","category":"page"},{"location":"modules/Optimization/optimization_packages/metaheuristics/#Installation:-OptimizationMetaheuristics.jl","page":"Metaheuristics.jl","title":"Installation: OptimizationMetaheuristics.jl","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/metaheuristics/","page":"Metaheuristics.jl","title":"Metaheuristics.jl","text":"To use this package, install the OptimizationMetaheuristics package:","category":"page"},{"location":"modules/Optimization/optimization_packages/metaheuristics/","page":"Metaheuristics.jl","title":"Metaheuristics.jl","text":"import Pkg; Pkg.add(\"OptimizationMetaheuristics\")","category":"page"},{"location":"modules/Optimization/optimization_packages/metaheuristics/#Global-Optimizer","page":"Metaheuristics.jl","title":"Global Optimizer","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/metaheuristics/#Without-Constraint-Equations","page":"Metaheuristics.jl","title":"Without Constraint Equations","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/metaheuristics/","page":"Metaheuristics.jl","title":"Metaheuristics.jl","text":"A Metaheuristics Single-Objective algorithm is called using one of the following:","category":"page"},{"location":"modules/Optimization/optimization_packages/metaheuristics/","page":"Metaheuristics.jl","title":"Metaheuristics.jl","text":"Evolutionary Centers Algorithm: ECA()\nDifferential Evolution: DE() with 5 different stratgies\nDE(strategy=:rand1) - default strategy\nDE(strategy=:rand2)\nDE(strategy=:best1)\nDE(strategy=:best2)\nDE(strategy=:randToBest1)\nParticle Swarm Optimization: PSO()\nArtificial Bee Colony: ABC()\nGravitational Search Algorithm: CGSA()\nSimulated Annealing: SA()\nWhale Optimization Algorithm: WOA()","category":"page"},{"location":"modules/Optimization/optimization_packages/metaheuristics/","page":"Metaheuristics.jl","title":"Metaheuristics.jl","text":"Metaheuristics also performs Multiobjective optimization but this is not yet supported by Optimization.","category":"page"},{"location":"modules/Optimization/optimization_packages/metaheuristics/","page":"Metaheuristics.jl","title":"Metaheuristics.jl","text":"Each optimizer sets default settings based on the optimization problem but specific parameters can be set as shown in the original Documentation ","category":"page"},{"location":"modules/Optimization/optimization_packages/metaheuristics/","page":"Metaheuristics.jl","title":"Metaheuristics.jl","text":"Additionally, Metaheuristics common settings which would be defined by Metaheuristics.Options can be simply passed as special keywoard arguments to solve without the need to use the Metaheuristics.Options struct.","category":"page"},{"location":"modules/Optimization/optimization_packages/metaheuristics/","page":"Metaheuristics.jl","title":"Metaheuristics.jl","text":"Lastly, information about the optimization problem such as the true optimum is set via Metaheuristics.Information and passed as part of the optimizer struct to solve e.g. solve(prob, ECA(information=Metaheuristics.Inoformation(f_optimum = 0.0)))","category":"page"},{"location":"modules/Optimization/optimization_packages/metaheuristics/","page":"Metaheuristics.jl","title":"Metaheuristics.jl","text":"The currently available algorithms and their parameters are listed here.","category":"page"},{"location":"modules/Optimization/optimization_packages/metaheuristics/#Notes","page":"Metaheuristics.jl","title":"Notes","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/metaheuristics/","page":"Metaheuristics.jl","title":"Metaheuristics.jl","text":"The algorithms in Metaheuristics are performing global optimization on problems without constraint equations. However, lower and upper constraints set by lb and ub in the OptimizationProblem are required.","category":"page"},{"location":"modules/Optimization/optimization_packages/metaheuristics/#Examples","page":"Metaheuristics.jl","title":"Examples","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/metaheuristics/","page":"Metaheuristics.jl","title":"Metaheuristics.jl","text":"The Rosenbrock function can optimized using the Evolutionary Centers Algorithm ECA() as follows:","category":"page"},{"location":"modules/Optimization/optimization_packages/metaheuristics/","page":"Metaheuristics.jl","title":"Metaheuristics.jl","text":"rosenbrock(x, p) =  (p[1] - x[1])^2 + p[2] * (x[2] - x[1]^2)^2\nx0 = zeros(2)\np  = [1.0, 100.0]\nf = OptimizationFunction(rosenbrock)\nprob = Optimization.OptimizationProblem(f, x0, p, lb = [-1.0,-1.0], ub = [1.0,1.0])\nsol = solve(prob, ECA(), maxiters=100000, maxtime=1000.0)","category":"page"},{"location":"modules/Optimization/optimization_packages/metaheuristics/","page":"Metaheuristics.jl","title":"Metaheuristics.jl","text":"Per default Metaheuristics ignores the initial values x0 set in the OptimizationProblem. In order to for Optimization to use x0 we have to set use_initial=true:","category":"page"},{"location":"modules/Optimization/optimization_packages/metaheuristics/","page":"Metaheuristics.jl","title":"Metaheuristics.jl","text":"rosenbrock(x, p) =  (p[1] - x[1])^2 + p[2] * (x[2] - x[1]^2)^2\nx0 = zeros(2)\np  = [1.0, 100.0]\nf = OptimizationFunction(rosenbrock)\nprob = Optimization.OptimizationProblem(f, x0, p, lb = [-1.0,-1.0], ub = [1.0,1.0])\nsol = solve(prob, ECA(), use_initial=true, maxiters=100000, maxtime=1000.0)","category":"page"},{"location":"modules/Optimization/optimization_packages/metaheuristics/#With-Constraint-Equations","page":"Metaheuristics.jl","title":"With Constraint Equations","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/metaheuristics/","page":"Metaheuristics.jl","title":"Metaheuristics.jl","text":"While Metaheuristics.jl supports such constraints, Optimization.jl currently does not relay these constraints.","category":"page"},{"location":"highlevels/stats/#Statistics-Overview","page":"Statistics Overview","title":"Statistics Overview","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/cmaevolutionstrategy/#CMAEvolutionStrategy.jl","page":"CMAEvolutionStrategy.jl","title":"CMAEvolutionStrategy.jl","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/cmaevolutionstrategy/","page":"CMAEvolutionStrategy.jl","title":"CMAEvolutionStrategy.jl","text":"CMAEvolutionStrategy is a Julia package implementing the Covariance Matrix Adaptation Evolution Strategy algorithm. ","category":"page"},{"location":"modules/Optimization/optimization_packages/cmaevolutionstrategy/","page":"CMAEvolutionStrategy.jl","title":"CMAEvolutionStrategy.jl","text":"The CMAEvolutionStrategy algorithm is called by CMAEvolutionStrategyOpt()","category":"page"},{"location":"modules/Optimization/optimization_packages/cmaevolutionstrategy/#Installation:-OptimizationCMAEvolutionStrategy.jl","page":"CMAEvolutionStrategy.jl","title":"Installation: OptimizationCMAEvolutionStrategy.jl","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/cmaevolutionstrategy/","page":"CMAEvolutionStrategy.jl","title":"CMAEvolutionStrategy.jl","text":"To use this package, install the OptimizationCMAEvolutionStrategy package:","category":"page"},{"location":"modules/Optimization/optimization_packages/cmaevolutionstrategy/","page":"CMAEvolutionStrategy.jl","title":"CMAEvolutionStrategy.jl","text":"import Pkg; Pkg.add(\"OptimizationCMAEvolutionStrategy\")","category":"page"},{"location":"modules/Optimization/optimization_packages/cmaevolutionstrategy/#Global-Optimizer","page":"CMAEvolutionStrategy.jl","title":"Global Optimizer","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/cmaevolutionstrategy/#Without-Constraint-Equations","page":"CMAEvolutionStrategy.jl","title":"Without Constraint Equations","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/cmaevolutionstrategy/","page":"CMAEvolutionStrategy.jl","title":"CMAEvolutionStrategy.jl","text":"The method in CMAEvolutionStrategy is performing global optimization on problems without constraint equations. However, lower and upper constraints set by lb and ub in the OptimizationProblem are required.","category":"page"},{"location":"modules/Optimization/optimization_packages/cmaevolutionstrategy/#Example","page":"CMAEvolutionStrategy.jl","title":"Example","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/cmaevolutionstrategy/","page":"CMAEvolutionStrategy.jl","title":"CMAEvolutionStrategy.jl","text":"The Rosenbrock function can optimized using the CMAEvolutionStrategyOpt() as follows:","category":"page"},{"location":"modules/Optimization/optimization_packages/cmaevolutionstrategy/","page":"CMAEvolutionStrategy.jl","title":"CMAEvolutionStrategy.jl","text":"rosenbrock(x, p) =  (p[1] - x[1])^2 + p[2] * (x[2] - x[1]^2)^2\nx0 = zeros(2)\np  = [1.0, 100.0]\nf = OptimizationFunction(rosenbrock)\nprob = Optimization.OptimizationProblem(f, x0, p, lb = [-1.0,-1.0], ub = [1.0,1.0])\nsol = solve(prob, CMAEvolutionStrategyOpt())","category":"page"},{"location":"modules/Optimization/optimization_packages/quaddirect/#QuadDIRECT.jl","page":"QuadDIRECT.jl","title":"QuadDIRECT.jl","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/quaddirect/","page":"QuadDIRECT.jl","title":"QuadDIRECT.jl","text":"QuadDIRECT is a Julia package implementing QuadDIRECT algorithm (inspired by DIRECT and MCS). ","category":"page"},{"location":"modules/Optimization/optimization_packages/quaddirect/","page":"QuadDIRECT.jl","title":"QuadDIRECT.jl","text":"The QuadDIRECT algorithm is called using QuadDirect(). ","category":"page"},{"location":"modules/Optimization/optimization_packages/quaddirect/#Installation:-OptimizationQuadDIRECT.jl","page":"QuadDIRECT.jl","title":"Installation: OptimizationQuadDIRECT.jl","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/quaddirect/","page":"QuadDIRECT.jl","title":"QuadDIRECT.jl","text":"To use this package, install the OptimizationQuadDIRECT package as:","category":"page"},{"location":"modules/Optimization/optimization_packages/quaddirect/","page":"QuadDIRECT.jl","title":"QuadDIRECT.jl","text":"import Pkg; Pkg.add(url=\"https://github.com/SciML/Optimization.jl\", subdir = \"lib/OptimizationQuadDIRECT\")","category":"page"},{"location":"modules/Optimization/optimization_packages/quaddirect/","page":"QuadDIRECT.jl","title":"QuadDIRECT.jl","text":"Also note that QuadDIRECT should (for now) be installed by doing:","category":"page"},{"location":"modules/Optimization/optimization_packages/quaddirect/","page":"QuadDIRECT.jl","title":"QuadDIRECT.jl","text":"] add https://github.com/timholy/QuadDIRECT.jl.git","category":"page"},{"location":"modules/Optimization/optimization_packages/quaddirect/","page":"QuadDIRECT.jl","title":"QuadDIRECT.jl","text":"Since QuadDIRECT is not a registered package in General registry, OptimizationQuadDIRECT is not registered as well hence it can't be installed with  the traditional command.","category":"page"},{"location":"modules/Optimization/optimization_packages/quaddirect/#Global-Optimizer","page":"QuadDIRECT.jl","title":"Global Optimizer","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/quaddirect/#Without-Constraint-Equations","page":"QuadDIRECT.jl","title":"Without Constraint Equations","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/quaddirect/","page":"QuadDIRECT.jl","title":"QuadDIRECT.jl","text":"The algorithm in QuadDIRECT is performing global optimization on problems without constraint equations. However, lower and upper constraints set by lb and ub in the OptimizationProblem are required.","category":"page"},{"location":"modules/Optimization/optimization_packages/quaddirect/","page":"QuadDIRECT.jl","title":"QuadDIRECT.jl","text":"Furthermore, QuadDirect requires splits which is a list of 3-vectors with initial locations at which to evaluate the function (the values must be in strictly increasing order and lie within the specified bounds) such that solve(problem, QuadDirect(), splits).","category":"page"},{"location":"modules/Optimization/optimization_packages/quaddirect/#Example","page":"QuadDIRECT.jl","title":"Example","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/quaddirect/","page":"QuadDIRECT.jl","title":"QuadDIRECT.jl","text":"The Rosenbrock function can optimized using the QuadDirect() as follows:","category":"page"},{"location":"modules/Optimization/optimization_packages/quaddirect/","page":"QuadDIRECT.jl","title":"QuadDIRECT.jl","text":"rosenbrock(x, p) =  (p[1] - x[1])^2 + p[2] * (x[2] - x[1]^2)^2\nx0 = zeros(2)\np  = [1.0, 100.0]\nf = OptimizationFunction(rosenbrock)\nprob = Optimization.OptimizationProblem(f, x0, p, lb = [-1.0,-1.0], ub = [1.0,1.0])\nsolve(prob, QuadDirect(), splits = ([-0.9, 0, 0.9], [-0.8, 0, 0.8]))","category":"page"},{"location":"modules/Optimization/API/solve/#Common-Solver-Options-(Solve-Keyword-Arguments)","page":"Common Solver Options (Solve Keyword Arguments)","title":"Common Solver Options (Solve Keyword Arguments)","text":"","category":"section"},{"location":"modules/Optimization/API/solve/","page":"Common Solver Options (Solve Keyword Arguments)","title":"Common Solver Options (Solve Keyword Arguments)","text":"solve(::OptimizationProblem,::Any)","category":"page"},{"location":"modules/Optimization/optimization_packages/evolutionary/#Evolutionary.jl","page":"Evolutionary.jl","title":"Evolutionary.jl","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/evolutionary/","page":"Evolutionary.jl","title":"Evolutionary.jl","text":"Evolutionary is a Julia package implementing various evolutionary and genetic algorithm.","category":"page"},{"location":"modules/Optimization/optimization_packages/evolutionary/#Installation:-OptimizationEvolutionary.jl","page":"Evolutionary.jl","title":"Installation: OptimizationEvolutionary.jl","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/evolutionary/","page":"Evolutionary.jl","title":"Evolutionary.jl","text":"To use this package, install the OptimizationEvolutionary package:","category":"page"},{"location":"modules/Optimization/optimization_packages/evolutionary/","page":"Evolutionary.jl","title":"Evolutionary.jl","text":"import Pkg; Pkg.add(\"OptimizationEvolutionary\")","category":"page"},{"location":"modules/Optimization/optimization_packages/evolutionary/#Global-Optimizer","page":"Evolutionary.jl","title":"Global Optimizer","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/evolutionary/#Without-Constraint-Equations","page":"Evolutionary.jl","title":"Without Constraint Equations","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/evolutionary/","page":"Evolutionary.jl","title":"Evolutionary.jl","text":"The methods in Evolutionary are performing global optimization on problems without constraint equations. These methods work both with and without lower and upper constraints set by lb and ub in the OptimizationProblem.","category":"page"},{"location":"modules/Optimization/optimization_packages/evolutionary/","page":"Evolutionary.jl","title":"Evolutionary.jl","text":"A Evolutionary algorithm is called by one of the following:","category":"page"},{"location":"modules/Optimization/optimization_packages/evolutionary/","page":"Evolutionary.jl","title":"Evolutionary.jl","text":"Evolutionary.GA(): Genetic Algorithm optimizer\nEvolutionary.DE(): Differential Evolution optimizer\nEvolutionary.ES(): Evolution Strategy algorithm\nEvolutionary.CMAES(): Covariance Matrix Adaptation Evolution Strategy algorithm","category":"page"},{"location":"modules/Optimization/optimization_packages/evolutionary/","page":"Evolutionary.jl","title":"Evolutionary.jl","text":"Algorithm specific options are defined as kwargs. See the respective documentation for more detail.","category":"page"},{"location":"modules/Optimization/optimization_packages/evolutionary/#Example","page":"Evolutionary.jl","title":"Example","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/evolutionary/","page":"Evolutionary.jl","title":"Evolutionary.jl","text":"The Rosenbrock function can optimized using the Evolutionary.CMAES() as follows:","category":"page"},{"location":"modules/Optimization/optimization_packages/evolutionary/","page":"Evolutionary.jl","title":"Evolutionary.jl","text":"rosenbrock(x, p) =  (p[1] - x[1])^2 + p[2] * (x[2] - x[1]^2)^2\nx0 = zeros(2)\np  = [1.0, 100.0]\nf = OptimizationFunction(rosenbrock)\nprob = Optimization.OptimizationProblem(f, x0, p, lb = [-1.0,-1.0], ub = [1.0,1.0])\nsol = solve(prob, Evolutionary.CMAES(μ =40 , λ = 100))","category":"page"},{"location":"modules/Optimization/optimization_packages/nlopt/#NLopt.jl","page":"NLopt.jl","title":"NLopt.jl","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/nlopt/","page":"NLopt.jl","title":"NLopt.jl","text":"NLopt is Julia package interfacing to the free/open-source NLopt library which implements many optimization methods both global and local NLopt Documentation.","category":"page"},{"location":"modules/Optimization/optimization_packages/nlopt/#Installation:-OptimizationNLopt.jl","page":"NLopt.jl","title":"Installation: OptimizationNLopt.jl","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/nlopt/","page":"NLopt.jl","title":"NLopt.jl","text":"To use this package, install the OptimizationNLopt package:","category":"page"},{"location":"modules/Optimization/optimization_packages/nlopt/","page":"NLopt.jl","title":"NLopt.jl","text":"import Pkg; Pkg.add(\"OptimizationNLopt\")","category":"page"},{"location":"modules/Optimization/optimization_packages/nlopt/#Methods","page":"NLopt.jl","title":"Methods","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/nlopt/","page":"NLopt.jl","title":"NLopt.jl","text":"NLopt.jl algorithms are chosen either via NLopt.Opt(:algname, nstates) where nstates is the number of states to be optimized but preferably via NLopt.AlgorithmName() where `AlgorithmName can be one of the following:","category":"page"},{"location":"modules/Optimization/optimization_packages/nlopt/","page":"NLopt.jl","title":"NLopt.jl","text":"NLopt.GN_DIRECT()\nNLopt.GN_DIRECT_L()\nNLopt.GN_DIRECT_L_RAND()\nNLopt.GN_DIRECT_NOSCAL()\nNLopt.GN_DIRECT_L_NOSCAL()\nNLopt.GN_DIRECT_L_RAND_NOSCAL()\nNLopt.GN_ORIG_DIRECT()\nNLopt.GN_ORIG_DIRECT_L()\nNLopt.GD_STOGO()\nNLopt.GD_STOGO_RAND()\nNLopt.LD_LBFGS_NOCEDAL()\nNLopt.LD_LBFGS()\nNLopt.LN_PRAXIS()\nNLopt.LD_VAR1()\nNLopt.LD_VAR2()\nNLopt.LD_TNEWTON()\nNLopt.LD_TNEWTON_RESTART()\nNLopt.LD_TNEWTON_PRECOND()\nNLopt.LD_TNEWTON_PRECOND_RESTART()\nNLopt.GN_CRS2_LM()\nNLopt.GN_MLSL()\nNLopt.GD_MLSL()\nNLopt.GN_MLSL_LDS()\nNLopt.GD_MLSL_LDS()\nNLopt.LD_MMA()\nNLopt.LN_COBYLA()\nNLopt.LN_NEWUOA()\nNLopt.LN_NEWUOA_BOUND()\nNLopt.LN_NELDERMEAD()\nNLopt.LN_SBPLX()\nNLopt.LN_AUGLAG()\nNLopt.LD_AUGLAG()\nNLopt.LN_AUGLAG_EQ()\nNLopt.LD_AUGLAG_EQ()\nNLopt.LN_BOBYQA()\nNLopt.GN_ISRES()\nNLopt.AUGLAG()\nNLopt.AUGLAG_EQ()\nNLopt.G_MLSL()\nNLopt.G_MLSL_LDS()\nNLopt.LD_SLSQP()\nNLopt.LD_CCSAQ()\nNLopt.GN_ESCH()\nNLopt.GN_AGS()","category":"page"},{"location":"modules/Optimization/optimization_packages/nlopt/","page":"NLopt.jl","title":"NLopt.jl","text":"See the NLopt Documentation for more details on each optimizer.","category":"page"},{"location":"modules/Optimization/optimization_packages/nlopt/","page":"NLopt.jl","title":"NLopt.jl","text":"Beyond the common arguments the following optimizer parameters can be set as kwargs:","category":"page"},{"location":"modules/Optimization/optimization_packages/nlopt/","page":"NLopt.jl","title":"NLopt.jl","text":"stopval\nxtol_rel\nxtol_abs\nconstrtol_abs\ninitial_step\npopulation\nvector_storage","category":"page"},{"location":"modules/Optimization/optimization_packages/nlopt/#Local-Optimizer","page":"NLopt.jl","title":"Local Optimizer","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/nlopt/#Derivative-Free","page":"NLopt.jl","title":"Derivative-Free","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/nlopt/","page":"NLopt.jl","title":"NLopt.jl","text":"Derivative-free optimizers are optimizers that can be used even in cases where no derivatives or automatic differentiation is specified. While they tend to be less efficient than derivative-based optimizers, they can be easily applied to cases where defining derivatives is difficult. Note that while these methods do not support general constraints, all support bounds constraints via lb and ub in the OptimizationProblem.","category":"page"},{"location":"modules/Optimization/optimization_packages/nlopt/","page":"NLopt.jl","title":"NLopt.jl","text":"NLopt derivative-free optimizers are:","category":"page"},{"location":"modules/Optimization/optimization_packages/nlopt/","page":"NLopt.jl","title":"NLopt.jl","text":"NLopt.LN_PRAXIS()\nNLopt.LN_COBYLA()\nNLopt.LN_NEWUOA()\nNLopt.LN_NEWUOA_BOUND()\nNLopt.LN_NELDERMEAD()\nNLopt.LN_SBPLX()\nNLopt.LN_AUGLAG()\nNLopt.LN_AUGLAG_EQ()\nNLopt.LN_BOBYQA()","category":"page"},{"location":"modules/Optimization/optimization_packages/nlopt/","page":"NLopt.jl","title":"NLopt.jl","text":"The Rosenbrock function can optimized using the NLopt.LN_NELDERMEAD() as follows:","category":"page"},{"location":"modules/Optimization/optimization_packages/nlopt/","page":"NLopt.jl","title":"NLopt.jl","text":"rosenbrock(x, p) =  (p[1] - x[1])^2 + p[2] * (x[2] - x[1]^2)^2\nx0 = zeros(2)\np  = [1.0, 100.0]\nf = OptimizationFunction(rosenbrock)\nprob = Optimization.OptimizationProblem(f, x0, p, lb = [-1.0,-1.0], ub = [1.0,1.0])\nsol = solve(prob, NLopt.LN_NELDERMEAD())","category":"page"},{"location":"modules/Optimization/optimization_packages/nlopt/#Gradient-Based","page":"NLopt.jl","title":"Gradient-Based","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/nlopt/","page":"NLopt.jl","title":"NLopt.jl","text":"Gradient-based optimizers are optimizers which utilise the gradient information based on derivatives defined or automatic differentiation.","category":"page"},{"location":"modules/Optimization/optimization_packages/nlopt/","page":"NLopt.jl","title":"NLopt.jl","text":"NLopt gradient-based optimizers are:","category":"page"},{"location":"modules/Optimization/optimization_packages/nlopt/","page":"NLopt.jl","title":"NLopt.jl","text":"NLopt.LD_LBFGS_NOCEDAL()\nNLopt.LD_LBFGS()\nNLopt.LD_VAR1()\nNLopt.LD_VAR2()\nNLopt.LD_TNEWTON()\nNLopt.LD_TNEWTON_RESTART()\nNLopt.LD_TNEWTON_PRECOND()\nNLopt.LD_TNEWTON_PRECOND_RESTART()\nNLopt.LD_MMA()\nNLopt.LD_AUGLAG()\nNLopt.LD_AUGLAG_EQ()\nNLopt.LD_SLSQP()\nNLopt.LD_CCSAQ()","category":"page"},{"location":"modules/Optimization/optimization_packages/nlopt/","page":"NLopt.jl","title":"NLopt.jl","text":"The Rosenbrock function can optimized using NLopt.LD_LBFGS() as follows:","category":"page"},{"location":"modules/Optimization/optimization_packages/nlopt/","page":"NLopt.jl","title":"NLopt.jl","text":"rosenbrock(x, p) =  (p[1] - x[1])^2 + p[2] * (x[2] - x[1]^2)^2\nx0 = zeros(2)\np  = [1.0, 100.0]\nf = OptimizationFunction(rosenbrock, Optimization.AutoForwardDiff())\nprob = Optimization.OptimizationProblem(f, x0, p, lb = [-1.0,-1.0], ub = [1.0,1.0])\nsol = solve(prob, NLopt.LD_LBFGS())","category":"page"},{"location":"modules/Optimization/optimization_packages/nlopt/#Global-Optimizer","page":"NLopt.jl","title":"Global Optimizer","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/nlopt/#Without-Constraint-Equations","page":"NLopt.jl","title":"Without Constraint Equations","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/nlopt/","page":"NLopt.jl","title":"NLopt.jl","text":"The following algorithms in NLopt are performing global optimization on problems without constraint equations. However, lower and upper constraints set by lb and ub in the OptimizationProblem are required.","category":"page"},{"location":"modules/Optimization/optimization_packages/nlopt/","page":"NLopt.jl","title":"NLopt.jl","text":"NLopt global optimizers which fall into this category are:","category":"page"},{"location":"modules/Optimization/optimization_packages/nlopt/","page":"NLopt.jl","title":"NLopt.jl","text":"NLopt.GN_DIRECT()\nNLopt.GN_DIRECT_L()\nNLopt.GN_DIRECT_L_RAND()\nNLopt.GN_DIRECT_NOSCAL()\nNLopt.GN_DIRECT_L_NOSCAL()\nNLopt.GN_DIRECT_L_RAND_NOSCAL()\nNLopt.GD_STOGO()\nNLopt.GD_STOGO_RAND()\nNLopt.GN_CRS2_LM()\nNLopt.GN_MLSL()\nNLopt.GD_MLSL()\nNLopt.GN_MLSL_LDS()\nNLopt.GD_MLSL_LDS()\nNLopt.G_MLSL()\nNLopt.G_MLSL_LDS()\nNLopt.GN_ESCH()","category":"page"},{"location":"modules/Optimization/optimization_packages/nlopt/","page":"NLopt.jl","title":"NLopt.jl","text":"The Rosenbrock function can optimized using NLopt.GN_DIRECT() as follows:","category":"page"},{"location":"modules/Optimization/optimization_packages/nlopt/","page":"NLopt.jl","title":"NLopt.jl","text":"rosenbrock(x, p) =  (p[1] - x[1])^2 + p[2] * (x[2] - x[1]^2)^2\nx0 = zeros(2)\np  = [1.0, 100.0]\nf = OptimizationFunction(rosenbrock)\nprob = Optimization.OptimizationProblem(f, x0, p, lb = [-1.0,-1.0], ub = [1.0,1.0])\nsol = solve(prob, NLopt.GN_DIRECT())","category":"page"},{"location":"modules/Optimization/optimization_packages/nlopt/","page":"NLopt.jl","title":"NLopt.jl","text":"Algorithms such as NLopt.G_MLSL() or NLopt.G_MLSL_LDS() also require a local optimiser to be selected which via the local_method argument of solve.","category":"page"},{"location":"modules/Optimization/optimization_packages/nlopt/","page":"NLopt.jl","title":"NLopt.jl","text":"The Rosenbrock function can optimized using NLopt.G_MLSL_LDS() with NLopt.LN_NELDERMEAD() as the local optimizer. The local optimizer maximum iterations are set via local_maxiters:","category":"page"},{"location":"modules/Optimization/optimization_packages/nlopt/","page":"NLopt.jl","title":"NLopt.jl","text":"rosenbrock(x, p) =  (p[1] - x[1])^2 + p[2] * (x[2] - x[1]^2)^2\nx0 = zeros(2)\np  = [1.0, 100.0]\nf = OptimizationFunction(rosenbrock, Optimization.AutoForwardDiff())\nprob = Optimization.OptimizationProblem(f, x0, p, lb = [-1.0,-1.0], ub = [1.0,1.0])\nsol = solve(prob, NLopt.G_MLSL_LDS(), local_method = NLopt.LD_LBFGS(), local_maxiters=10000)","category":"page"},{"location":"modules/Optimization/optimization_packages/nlopt/#With-Constraint-Equations","page":"NLopt.jl","title":"With Constraint Equations","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/nlopt/","page":"NLopt.jl","title":"NLopt.jl","text":"The following algorithms in NLopt are performing global optimization on problems with constraint equations. However, lower and upper constraints set by lb and ub in the OptimizationProblem are required.","category":"page"},{"location":"modules/Optimization/optimization_packages/nlopt/","page":"NLopt.jl","title":"NLopt.jl","text":"note: Constraints with NLopt\nEquality and inequality equation support for NLopt via Optimization is not supported directly. However, you can use the MOI wrapper to use constraints with NLopt optimisers.","category":"page"},{"location":"modules/Optimization/optimization_packages/nlopt/","page":"NLopt.jl","title":"NLopt.jl","text":"NLopt global optimizers which fall into this category are:","category":"page"},{"location":"modules/Optimization/optimization_packages/nlopt/","page":"NLopt.jl","title":"NLopt.jl","text":"NLopt.GN_ORIG_DIRECT()\nNLopt.GN_ORIG_DIRECT_L()\nNLopt.GN_ISRES()\nNLopt.GN_AGS()","category":"page"},{"location":"modules/Optimization/optimization_packages/mathoptinterface/#MathOptInterface.jl","page":"MathOptInterface.jl","title":"MathOptInterface.jl","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/mathoptinterface/","page":"MathOptInterface.jl","title":"MathOptInterface.jl","text":"MathOptInterface is Julia abstration layer to interface with variety of mathematical optimization solvers.","category":"page"},{"location":"modules/Optimization/optimization_packages/mathoptinterface/#Installation:-OptimizationMOI.jl","page":"MathOptInterface.jl","title":"Installation: OptimizationMOI.jl","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/mathoptinterface/","page":"MathOptInterface.jl","title":"MathOptInterface.jl","text":"To use this package, install the OptimizationMOI package:","category":"page"},{"location":"modules/Optimization/optimization_packages/mathoptinterface/","page":"MathOptInterface.jl","title":"MathOptInterface.jl","text":"import Pkg; Pkg.add(\"OptimizationMOI\")","category":"page"},{"location":"modules/Optimization/optimization_packages/mathoptinterface/#Details","page":"MathOptInterface.jl","title":"Details","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/mathoptinterface/","page":"MathOptInterface.jl","title":"MathOptInterface.jl","text":"As of now, the Optimization interface to MathOptInterface implements only the maxtime common keyword argument. ","category":"page"},{"location":"modules/Optimization/optimization_packages/mathoptinterface/","page":"MathOptInterface.jl","title":"MathOptInterface.jl","text":"An optimizer which supports the MathOptInterface API can be called be called directly if no optimizer options have to be defined. ","category":"page"},{"location":"modules/Optimization/optimization_packages/mathoptinterface/","page":"MathOptInterface.jl","title":"MathOptInterface.jl","text":"For example using the Ipopt.jl optimizer:","category":"page"},{"location":"modules/Optimization/optimization_packages/mathoptinterface/","page":"MathOptInterface.jl","title":"MathOptInterface.jl","text":"sol = solve(prob, Ipopt.Optimizer())","category":"page"},{"location":"modules/Optimization/optimization_packages/mathoptinterface/","page":"MathOptInterface.jl","title":"MathOptInterface.jl","text":"The optimizer options are handled in one of two ways. They can either be set via Optimization.MOI.OptimizerWithAttributes() or as keyword argument to solve. ","category":"page"},{"location":"modules/Optimization/optimization_packages/mathoptinterface/","page":"MathOptInterface.jl","title":"MathOptInterface.jl","text":"For example using the Ipopt.jl optimizer:","category":"page"},{"location":"modules/Optimization/optimization_packages/mathoptinterface/","page":"MathOptInterface.jl","title":"MathOptInterface.jl","text":"opt = Optimization.MOI.OptimizerWithAttributes(Ipopt.Optimizer, \"option_name\" => option_value, ...)\nsol = solve(prob, opt)\n\nsol = solve(prob,  Ipopt.Optimizer(); option_name = option_value, ...)","category":"page"},{"location":"modules/Optimization/optimization_packages/mathoptinterface/#Optimizers","page":"MathOptInterface.jl","title":"Optimizers","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/mathoptinterface/#Ipopt.jl-(MathOptInterface)","page":"MathOptInterface.jl","title":"Ipopt.jl (MathOptInterface)","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/mathoptinterface/","page":"MathOptInterface.jl","title":"MathOptInterface.jl","text":"Ipopt.Optimizer\nThe full list of optimizer options can be found in the Ipopt Documentation","category":"page"},{"location":"modules/Optimization/optimization_packages/mathoptinterface/#KNITRO.jl-(MathOptInterface)","page":"MathOptInterface.jl","title":"KNITRO.jl (MathOptInterface)","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/mathoptinterface/","page":"MathOptInterface.jl","title":"MathOptInterface.jl","text":"KNITRO.Optimizer\nThe full list of optimizer options can be found in the KNITRO Documentation","category":"page"},{"location":"modules/Optimization/optimization_packages/mathoptinterface/#Juniper.jl-(MathOptInterface)","page":"MathOptInterface.jl","title":"Juniper.jl (MathOptInterface)","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/mathoptinterface/","page":"MathOptInterface.jl","title":"MathOptInterface.jl","text":"Juniper.Optimizer\nJuniper requires a nonlinear optimizer to be set via the nl_solver option, which must be a MathOptInterface-based optimizer. See the Juniper documentation for more detail.","category":"page"},{"location":"modules/Optimization/optimization_packages/mathoptinterface/","page":"MathOptInterface.jl","title":"MathOptInterface.jl","text":"using Optimization, ForwardDiff\nrosenbrock(x, p) =  (p[1] - x[1])^2 + p[2] * (x[2] - x[1]^2)^2\nx0 = zeros(2)\n_p  = [1.0, 100.0]\n\nf = OptimizationFunction(rosenbrock, Optimization.AutoForwardDiff())\nprob = Optimization.OptimizationProblem(f, x0, _p)\n\nusing Juniper, Ipopt\nopt = Optimization.MOI.OptimizerWithAttributes(\n    Juniper.Optimizer,\n    \"nl_solver\"=>Optimization.MOI.OptimizerWithAttributes(Ipopt.Optimizer, \"print_level\"=>0),\n)\nsol = solve(prob, opt)","category":"page"},{"location":"modules/Optimization/optimization_packages/nomad/#NOMAD.jl","page":"NOMAD.jl","title":"NOMAD.jl","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/nomad/","page":"NOMAD.jl","title":"NOMAD.jl","text":"NOMAD is Julia package interfacing to NOMAD,which is a C++ implementation of the Mesh Adaptive Direct Search algorithm (MADS), designed for difficult blackbox optimization problems. These problems occur when the functions defining the objective and constraints are the result of costly computer simulations. NOMAD.jl documentation","category":"page"},{"location":"modules/Optimization/optimization_packages/nomad/","page":"NOMAD.jl","title":"NOMAD.jl","text":"The NOMAD algorithm is called by NOMADOpt()","category":"page"},{"location":"modules/Optimization/optimization_packages/nomad/#Installation:-OptimizationNOMAD.jl","page":"NOMAD.jl","title":"Installation: OptimizationNOMAD.jl","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/nomad/","page":"NOMAD.jl","title":"NOMAD.jl","text":"To use this package, install the OptimizationNOMAD package:","category":"page"},{"location":"modules/Optimization/optimization_packages/nomad/","page":"NOMAD.jl","title":"NOMAD.jl","text":"import Pkg; Pkg.add(\"OptimizationNOMAD\")","category":"page"},{"location":"modules/Optimization/optimization_packages/nomad/#Global-Optimizer","page":"NOMAD.jl","title":"Global Optimizer","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/nomad/#Without-Constraint-Equations","page":"NOMAD.jl","title":"Without Constraint Equations","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/nomad/","page":"NOMAD.jl","title":"NOMAD.jl","text":"The method in NOMAD is performing global optimization on problems both with and without constraint equations. Currently however, linear and nonlinear constraints  defined in Optimization are not passed.","category":"page"},{"location":"modules/Optimization/optimization_packages/nomad/","page":"NOMAD.jl","title":"NOMAD.jl","text":"NOMAD works both with and without lower and upper boxconstraints set by lb and ub in the OptimizationProblem.","category":"page"},{"location":"modules/Optimization/optimization_packages/nomad/#Examples","page":"NOMAD.jl","title":"Examples","text":"","category":"section"},{"location":"modules/Optimization/optimization_packages/nomad/","page":"NOMAD.jl","title":"NOMAD.jl","text":"The Rosenbrock function can optimized using the NOMADOpt() with and without boxcontraints as follows:","category":"page"},{"location":"modules/Optimization/optimization_packages/nomad/","page":"NOMAD.jl","title":"NOMAD.jl","text":"rosenbrock(x, p) =  (p[1] - x[1])^2 + p[2] * (x[2] - x[1]^2)^2\nx0 = zeros(2)\np  = [1.0, 100.0]\nf = OptimizationFunction(rosenbrock)\n\nprob = OptimizationProblem(f, x0, _p)\nsol = Optimization.solve(prob,NOMADOpt())\n\nprob = OptimizationProblem(f, x0, _p, lb = [-1.0,-1.0], ub = [1.5,1.5])\nsol = Optimization.solve(prob,NOMADOpt())","category":"page"},{"location":"modules/Optimization/tutorials/minibatch/#Data-Iterators-and-Minibatching","page":"Data Iterators and Minibatching","title":"Data Iterators and Minibatching","text":"","category":"section"},{"location":"modules/Optimization/tutorials/minibatch/","page":"Data Iterators and Minibatching","title":"Data Iterators and Minibatching","text":"note: Note\nThis example uses the OptimizationOptimisers.jl package. See the  Optimisers.jl page for details on the installation and usage.","category":"page"},{"location":"modules/Optimization/tutorials/minibatch/","page":"Data Iterators and Minibatching","title":"Data Iterators and Minibatching","text":"using Flux, Optimization, OptimizationOptimisers, OrdinaryDiffEq, DiffEqSensitivity\n\nfunction newtons_cooling(du, u, p, t)\n    temp = u[1]\n    k, temp_m = p\n    du[1] = dT = -k*(temp-temp_m)\n  end\n\nfunction true_sol(du, u, p, t)\n    true_p = [log(2)/8.0, 100.0]\n    newtons_cooling(du, u, true_p, t)\nend\n\nann = Chain(FastDense(1,8,tanh), FastDense(8,1,tanh))\npp,re = Flux.destructure(ann)\n\nfunction dudt_(u,p,t)\n    re(p)(u) .* u\nend\n\ncallback = function (p,l,pred;doplot=false) #callback function to observe training\n    display(l)\n    # plot current prediction against data\n    if doplot\n      pl = scatter(t,ode_data[1,:],label=\"data\")\n      scatter!(pl,t,pred[1,:],label=\"prediction\")\n      display(plot(pl))\n    end\n    return false\nend\n\nu0 = Float32[200.0]\ndatasize = 30\ntspan = (0.0f0, 1.5f0)\n\nt = range(tspan[1], tspan[2], length=datasize)\ntrue_prob = ODEProblem(true_sol, u0, tspan)\node_data = Array(solve(true_prob, Tsit5(), saveat=t))\n\nprob = ODEProblem{false}(dudt_, u0, tspan, pp)\n\nfunction predict_adjoint(fullp, time_batch)\n    Array(solve(prob, Tsit5(), p = fullp, saveat = time_batch))\nend\n\nfunction loss_adjoint(fullp, batch, time_batch)\n    pred = predict_adjoint(fullp,time_batch)\n    sum(abs2, batch .- pred), pred\nend\n\n\nk = 10\ntrain_loader = Flux.Data.DataLoader((ode_data, t), batchsize = k)\n\nnumEpochs = 300\nl1 = loss_adjoint(pp, train_loader.data[1], train_loader.data[2])[1]\n\noptfun = OptimizationFunction((θ, p, batch, time_batch) -> loss_adjoint(θ, batch, time_batch), Optimization.AutoZygote())\noptprob = OptimizationProblem(optfun, pp)\nusing IterTools: ncycle\nres1 = Optimization.solve(optprob, Optimisers.ADAM(0.05), ncycle(train_loader, numEpochs), callback = callback)\n@test 10res1.minimum < l1","category":"page"}]
}
