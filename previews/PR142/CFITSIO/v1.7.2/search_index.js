var documenterSearchIndex = {"docs":
[{"location":"types/#Type-Conversions","page":"Type Conversions","title":"Type Conversions","text":"","category":"section"},{"location":"types/","page":"Type Conversions","title":"Type Conversions","text":"The following tables give the correspondances between CFITSIO \"types\", the BITPIX keyword and Julia types.","category":"page"},{"location":"types/#CFITSIO-Types","page":"Type Conversions","title":"CFITSIO Types","text":"","category":"section"},{"location":"types/","page":"Type Conversions","title":"Type Conversions","text":"CODE CFITSIO Julia\n int Cint\n long Clong\n LONGLONG Int64","category":"page"},{"location":"types/#FITS-BITPIX","page":"Type Conversions","title":"FITS BITPIX","text":"","category":"section"},{"location":"types/","page":"Type Conversions","title":"Type Conversions","text":"CODE CFITSIO Julia\n8 BYTE_IMG UInt8\n16 SHORT_IMG Int16\n32 LONG_IMG Int32\n64 LONGLONG_IMG Int64\n-32 FLOAT_IMG Float32\n-64 DOUBLE_IMG Float64","category":"page"},{"location":"types/#CFITSIO-Aliases","page":"Type Conversions","title":"CFITSIO Aliases","text":"","category":"section"},{"location":"types/","page":"Type Conversions","title":"Type Conversions","text":"CODE CFITSIO Julia Comments\n10 SBYTE_IMG Int8 written as: BITPIX = 8, BSCALE = 1, BZERO = -128\n20 USHORT_IMG UInt16 written as: BITPIX = 16, BSCALE = 1, BZERO = 32768\n40 LONG_IMG UInt32 written as: BITPIX = 32, BSCALE = 1, BZERO = 2147483648\n80 ULONGLONG_IMG UInt64 written as: BITPIX = 64, BSCALE = 1, BZERO = 9223372036854775808","category":"page"},{"location":"types/#FITS-Table-Data-Types","page":"Type Conversions","title":"FITS Table Data Types","text":"","category":"section"},{"location":"types/","page":"Type Conversions","title":"Type Conversions","text":"CODE CFITSIO Julia\n1 TBIT \n11 TBYTE Cuchar, UInt8\n12 TSBYTE Cchar, Int8\n14 TLOGICAL Bool\n16 TSTRING String\n20 TUSHORT Cushort\n21 TSHORT Cshort\n30 TUINT Cuint\n31 TINT Cint\n40 TULONG Culong\n41 TLONG Clong\n42 TFLOAT Cfloat\n80 TULONGLONG UInt64\n81 TLONGLONG Int64\n82 TDOUBLE Cdouble\n83 TCOMPLEX Complex{Cfloat}\n163 TDBLCOMPLEX Complex{Cdouble}","category":"page"},{"location":"types/#CFITSIO.bitpix_from_type","page":"Type Conversions","title":"CFITSIO.bitpix_from_type","text":"bitpix_from_type(::Type)::Cint\n\nReturn the FITS BITPIX code for the given Julia type\n\nExample\n\njulia> CFITSIO.bitpix_from_type(Int64)\n64\n\nSee also type_from_bitpix\n\n\n\n\n\n","category":"function"},{"location":"types/#CFITSIO.type_from_bitpix","page":"Type Conversions","title":"CFITSIO.type_from_bitpix","text":"type_from_bitpix(::Integer)::Type\n\nReturn the Julia type from the FITS BITPIX code\n\nExample\n\njulia> CFITSIO.type_from_bitpix(64)\nInt64\n\nSee also bitpix_from_type\n\n\n\n\n\n","category":"function"},{"location":"types/#CFITSIO.cfitsio_typecode","page":"Type Conversions","title":"CFITSIO.cfitsio_typecode","text":"cfitsio_typecode(::Type)::Cint\n\nReturn the CFITSIO type code for the given Julia type.\n\nExample\n\njulia> CFITSIO.cfitsio_typecode(Int64)\n81\n\n\n\n\n\n","category":"function"},{"location":"header/#Header-Keyword-Routines","page":"Header","title":"Header Keyword Routines","text":"","category":"section"},{"location":"header/#CFITSIO.fits_copy_header","page":"Header","title":"CFITSIO.fits_copy_header","text":"fits_copy_header(fin::FITSFile, fout::FITSFile)\n\nCopy the header (not the data) associated with the current HDU from fin to fout. If the current HDU in fout is not empty, it will be closed and a new HDU will be appended. An empty output HDU will be created with the header but no data.\n\nExample\n\njulia> fname_in = joinpath(mktempdir(), \"test_in.fits\");\n\njulia> fname_out = joinpath(mktempdir(), \"test_out.fits\");\n\njulia> fin = fits_create_file(fname_in);\n\njulia> fits_create_empty_img(fin)\n\njulia> fits_write_key(fin, \"KEY1\", 1, \"First keyword\")\n\njulia> fout = fits_create_file(fname_out);\n\njulia> fits_copy_header(fin, fout)\n\njulia> fits_read_key_str(fout, \"NAXIS\")\n(\"0\", \"number of data axes\")\n\njulia> fits_read_key_str(fout, \"KEY1\")\n(\"1\", \"First keyword\")\n\njulia> foreach(close, (fin, fout))\n\n\n\n\n\n","category":"function"},{"location":"header/#CFITSIO.fits_delete_key","page":"Header","title":"CFITSIO.fits_delete_key","text":"fits_delete_key(f::FITSFile, keyname::String)\n\nDelete the keyword named keyname.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_write_key(f, \"KEY1\", 1, \"First keyword\")\n\njulia> fits_read_key_str(f, \"KEY1\")\n(\"1\", \"First keyword\")\n\njulia> fits_delete_key(f, \"KEY1\") # delete the keyword\n\njulia> fits_read_key_str(f, \"KEY1\")\nERROR: CFITSIO has encountered an error. Error code 202: keyword not found in header\n[...]\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"header/#CFITSIO.fits_delete_record","page":"Header","title":"CFITSIO.fits_delete_record","text":"fits_delete_record(f::FITSFile, keynum::Integer)\n\nDelete the keyword record at the specified index.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_write_key(f, \"KEY1\", 1, \"First keyword\")\n\njulia> fits_read_key_str(f, \"KEY1\")\n(\"1\", \"First keyword\")\n\njulia> fits_delete_record(f, 7) # delete the keyword\n\njulia> fits_read_key_str(f, \"KEY1\")\nERROR: CFITSIO has encountered an error. Error code 202: keyword not found in header\n[...]\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"header/#CFITSIO.fits_hdr2str","page":"Header","title":"CFITSIO.fits_hdr2str","text":"fits_hdr2str(f::FITSFile, nocomments::Bool=false)\n\nReturn the header of the CHDU as a string. If nocomments is true, comment cards are stripped from the output.\n\n\n\n\n\n","category":"function"},{"location":"header/#CFITSIO.fits_get_hdrspace","page":"Header","title":"CFITSIO.fits_get_hdrspace","text":"fits_get_hdrspace(f::FITSFile) -> (keysexist, morekeys)\n\nReturn the number of existing keywords (not counting the END keyword) and the amount of space currently available for more keywords.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_clobber_file(fname);\n\njulia> fits_create_img(f, Int32, (2, 2));\n\njulia> nkeywords, _ = fits_get_hdrspace(f)\n(8, -1)\n\njulia> [fits_read_keyn(f, i) for i in 1:nkeywords]\n8-element Vector{Tuple{String, String, String}}:\n (\"SIMPLE\", \"T\", \"file does conform to FITS standard\")\n (\"BITPIX\", \"32\", \"number of bits per data pixel\")\n (\"NAXIS\", \"2\", \"number of data axes\")\n (\"NAXIS1\", \"2\", \"length of data axis 1\")\n (\"NAXIS2\", \"2\", \"length of data axis 2\")\n (\"EXTEND\", \"T\", \"FITS dataset may contain extensions\")\n (\"COMMENT\", \"\", \"  FITS (Flexible Image Transport System) format is defined in 'Astronomy\")\n (\"COMMENT\", \"\", \"  and Astrophysics', volume 376, page 359; bibcode: 2001A&A...376..359H\")\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"header/#CFITSIO.fits_read_key_lng","page":"Header","title":"CFITSIO.fits_read_key_lng","text":"fits_read_key_lng(f::FITSFile, keyname::String)\n\nRead the value of a keyword as a Clong, as well as the comment associated with the keyword.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_img(f, Int32, (100, 100));\n\njulia> fits_read_key_lng(f, \"NAXIS1\")\n(100, \"length of data axis 1\")\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"header/#CFITSIO.fits_read_key_str","page":"Header","title":"CFITSIO.fits_read_key_str","text":"fits_read_key_str(f::FITSFile, keyname::String)\n\nRead the value associated with the keyword as a String, along with the comment.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_read_key_str(f, \"SIMPLE\")\n(\"T\", \"file does conform to FITS standard\")\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"header/#CFITSIO.fits_read_key_unit","page":"Header","title":"CFITSIO.fits_read_key_unit","text":"fits_read_key_unit(f::FITSFile, keyname::String)\n\nRead the physical unit of the keyword keyname in the header.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_write_key(f, \"Velocity\", 2.0, \"Velocity of the object\")\n\njulia> fits_write_key_unit(f, \"Velocity\", \"m/s\")\n\njulia> fits_read_key_unit(f, \"Velocity\")\n\"m/s\"\n\njulia> fits_read_keyword(f, \"Velocity\")\n(\"2.\", \"[m/s] Velocity of the object\")\n\njulia> close(f)\n\nSee also fits_write_key_unit to write a unit to a keyword.\n\n\n\n\n\n","category":"function"},{"location":"header/#CFITSIO.fits_read_keyn","page":"Header","title":"CFITSIO.fits_read_keyn","text":"fits_read_keyn(f::FITSFile, keynum::Int) -> (name, value, comment)\n\nReturn the nth header record in the CHU. The first keyword in the header is at keynum = 1.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_read_keyn(f, 1)\n(\"SIMPLE\", \"T\", \"file does conform to FITS standard\")\n\njulia> fits_read_keyn(f, 3)\n(\"NAXIS\", \"0\", \"number of data axes\")\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"header/#CFITSIO.fits_read_keyword","page":"Header","title":"CFITSIO.fits_read_keyword","text":"fits_read_keyword(f::FITSFile, keyname::String) -> (value, comment)\n\nReturn the specified keyword value and comment (as a tuple of strings), throws and error if the keyword is not found.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_read_keyword(f, \"SIMPLE\")\n(\"T\", \"file does conform to FITS standard\")\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"header/#CFITSIO.fits_read_record","page":"Header","title":"CFITSIO.fits_read_record","text":"fits_read_record(f::FITSFile, keynum::Int)::String\n\nReturn the keynum-th header record in the CHU. The first keyword in the header is at keynum = 1.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_read_record(f, 1)\n\"SIMPLE  =                    T / file does conform to FITS standard\"\n\njulia> fits_read_record(f, 3)\n\"NAXIS   =                    0 / number of data axes\"\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"header/#CFITSIO.fits_update_key","page":"Header","title":"CFITSIO.fits_update_key","text":"fits_update_key(f::FITSFile, key::String, value, comment::Union{String,Ptr{Nothing},Nothing} = nothing)\n\nUpdate the value of an existing keyword in the FITS header, or add a new keyword if it does not exist. This function is a convenience wrapper that calls the appropriate ffuk* function based on the type of value.\n\nIf comment is provided, it is added to the keyword comment field. If value is Nothing, the keyword is set to a null value. If value is a string, it is checked to be ASCII compliant. If value is a floating-point number, it is written as a double-precision value. If value is a boolean, it is written as an integer (1 for true, 0 for false).\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_update_key(f, \"NEWKEY\", 2, \"This is a new keyword\")\n\njulia> fits_read_key_str(f, \"NEWKEY\")\n(\"2\", \"This is a new keyword\")\n\njulia> fits_update_key(f, \"NEWKEY\", 3.14, \"Updated value\")\n\njulia> fits_read_key_str(f, \"NEWKEY\")\n(\"3.14\", \"Updated value\")\n\njulia> fits_update_key(f, \"NEWKEY\", true, \"Boolean value\")\n\njulia> fits_read_key_str(f, \"NEWKEY\")\n(\"T\", \"Boolean value\")\n\njulia> fits_update_key(f, \"NEWKEY\", \"Value\", \"String value\")\n\njulia> fits_read_key_str(f, \"NEWKEY\")\n(\"Value\", \"String value\")\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"header/#CFITSIO.fits_write_comment","page":"Header","title":"CFITSIO.fits_write_comment","text":"fits_write_comment(f::FITSFile, comment::String)\n\nAppend to the keyword COMMENT in the FITS header. If the keyword does not exist, it is created.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_write_comment(f, \"This is a comment\")\n\njulia> fits_read_record(f, 7)\n\"COMMENT This is a comment\"\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"header/#CFITSIO.fits_write_date","page":"Header","title":"CFITSIO.fits_write_date","text":"fits_write_date(f::FITSFile)\n\nWrite the current date and time into the FITS header. If a DATE keyword already exists, it is replaced by the new value. The date is written in the format YYYY-MM-DDThh:mm:ss (ISO 8601).\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_write_date(f)\n\njulia> fits_read_key_str(f, \"DATE\")\n(\"2025-05-28T10:41:08\", \"file creation date (YYYY-MM-DDThh:mm:ss UT)\")\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"header/#CFITSIO.fits_write_history","page":"Header","title":"CFITSIO.fits_write_history","text":"fits_write_history(f::FITSFile, history::String)\n\nAppend to the keyword HISTORY in the FITS header. If the keyword does not exist, it is created.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_write_history(f, \"This is a history entry\")\n\njulia> fits_read_record(f, 7)\n\"HISTORY This is a history entry\"\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"header/#CFITSIO.fits_write_key","page":"Header","title":"CFITSIO.fits_write_key","text":"fits_write_key(f::FITSFile, keyname::String, value, comment::Union{String, Nothing} = nothing)\n\nWrite a keyword of the appropriate data type into the CHU. If comment is nothing, the keyword is written without a comment.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_write_key(f, \"NEWKEY\", 2, \"This is a new keyword\")\n\njulia> fits_read_key_str(f, \"NEWKEY\")\n(\"2\", \"This is a new keyword\")\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"header/#CFITSIO.fits_write_key_unit","page":"Header","title":"CFITSIO.fits_write_key_unit","text":"fits_write_key_unit(f::FITSFile, keyname::String, unit::String)\n\nWrite the physical units string into an existing keyword record. The keyword must already exist in the header. The unit string is enclosed in square brackets at the beginning of the keyword comment field.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_write_key(f, \"Velocity\", 2.0, \"Velocity of the object\")\n\njulia> fits_write_key_unit(f, \"Velocity\", \"m/s\")\n\njulia> fits_read_key_unit(f, \"Velocity\")\n\"m/s\"\n\njulia> fits_read_keyword(f, \"Velocity\")\n(\"2.\", \"[m/s] Velocity of the object\")\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"header/#CFITSIO.fits_write_record","page":"Header","title":"CFITSIO.fits_write_record","text":"fits_write_record(f::FITSFile, card::String)\n\nWrite a user specified keyword record into the CHU. This is a low–level routine which can be used to write any arbitrary record into the header. It is not recommended to use this function unless you know what you are doing. It is typically used to write hierarchical keywords in the ESO convention, which allows keyword names longer than 8 characters. It is also used to write comments or history entries directly into the header. If the keyword already exists, it is replaced by the new value. If the keyword does not exist, it is added to the header.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_write_record(f, \"HIERARCH ESO OBS ID = '12345'\")\n\njulia> fits_read_record(f, 7)\n\"HIERARCH ESO OBS ID = '12345'\"\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"misc/#Miscellaneous","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"section"},{"location":"misc/#CFITSIO.libcfitsio_version","page":"Miscellaneous","title":"CFITSIO.libcfitsio_version","text":"libcfitsio_version()::VersionNumber\n\nReturn the version of the underlying CFITSIO library\n\nExample\n\njulia> libcfitsio_version()\nv\"4.6.0\"\n\n\n\n\n\n","category":"function"},{"location":"misc/#CFITSIO.fits_get_version","page":"Miscellaneous","title":"CFITSIO.fits_get_version","text":"fits_get_version()::Cfloat\n\nReturn the version of the CFITSIO library as a floating point number.\n\nExample\n\njulia> fits_get_version()\n4.0601997f0\n\nSee also libcfitsio_version, which returns a VersionNumber.\n\n\n\n\n\n","category":"function"},{"location":"image/#Image-HDU-Routines","page":"Image","title":"Image HDU Routines","text":"","category":"section"},{"location":"image/#CFITSIO.fits_get_img_dim","page":"Image","title":"CFITSIO.fits_get_img_dim","text":"fits_get_img_dim(f::FITSFile)\n\nReturn the number of dimensions in the current image HDU.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_img(f, Int64, (2,2))\n\njulia> fits_get_img_dim(f)\n2\n\njulia> close(f)\n\nSee also fits_get_img_type, fits_get_img_size and fits_get_img_param.\n\n\n\n\n\n","category":"function"},{"location":"image/#CFITSIO.fits_get_img_size","page":"Image","title":"CFITSIO.fits_get_img_size","text":"fits_get_img_size(f::FITSFile)\n\nReturn the size along each dimension in the current Image HDU.\n\nSee also fits_get_img_type, fits_get_img_dim and fits_get_img_param.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_img(f, Int64, (2,2))\n\njulia> fits_get_img_size(f)\n2-element Vector{Int64}:\n 2\n 2\n\njulia> fits_get_img_size(f, Val(2))\n(2, 2)\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"image/#CFITSIO.fits_get_img_type","page":"Image","title":"CFITSIO.fits_get_img_type","text":"fits_get_img_type(f::FITSFile)\n\nReturn the datatype (bitpix) of the current image HDU. This may be converted to a Julia type by using the function type_from_bitpix.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_img(f, Int64, (2,2))\n\njulia> fits_get_img_type(f)\n64\n\njulia> type_from_bitpix(fits_get_img_type(f))\nInt64\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"image/#CFITSIO.fits_get_img_param","page":"Image","title":"CFITSIO.fits_get_img_param","text":"fits_get_img_param(f::FITSFile)\n\nReturn the bitpix, number of dimensions and the size along each dimension of the current image HDU.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_img(f, Int64, (2,2))\n\njulia> fits_get_img_param(f)\n(64, 2, [2, 2])\n\njulia> close(f)\n\nSee also fits_get_img_type, fits_get_img_dim and fits_get_img_size.\n\n\n\n\n\n","category":"function"},{"location":"image/#CFITSIO.fits_create_img","page":"Image","title":"CFITSIO.fits_create_img","text":"fits_create_img(f::FITSFile, T::Type, naxes::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}})\n\nCreate a new primary array or IMAGE extension with the specified data type T and size naxes.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_img(f, Int64, [2, 2])\n\njulia> fits_get_img_dim(f)\n2\n\njulia> fits_get_img_size(f)\n2-element Vector{Int64}:\n 2\n 2\n\njulia> fits_get_img_type(f)\n64\n\njulia> type_from_bitpix(fits_get_img_type(f))\nInt64\n\njulia> fits_create_img(f, Int64, (1, 3, 2))\n\njulia> fits_get_img_dim(f)\n3\n\njulia> fits_get_img_size(f)\n3-element Vector{Int64}:\n 1\n 3\n 2\n\njulia> close(f)\n\n\n\n\n\nfits_create_img(f::FITSFile, A::AbstractArray)\n\nCreate a new primary array or IMAGE extension with the element type and size of A, that is capable of storing the entire array A.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> a = rand(2, 2);\n\njulia> fits_create_img(f, a)\n\njulia> fits_get_img_dim(f)\n2\n\njulia> fits_get_img_size(f)\n2-element Vector{Int64}:\n 2\n 2\n\njulia> type_from_bitpix(fits_get_img_type(f))\nFloat64\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"image/#CFITSIO.fits_create_empty_img","page":"Image","title":"CFITSIO.fits_create_empty_img","text":"fits_create_empty_img(f::FITSFile)\n\nCreate an empty image HDU with no dimensions, and of type Int. See fits_create_img.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_get_img_dim(f)\n0\n\njulia> fits_get_img_size(f)\nInt64[]\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"image/#CFITSIO.fits_insert_img","page":"Image","title":"CFITSIO.fits_insert_img","text":"fits_insert_img(f::FITSFile, T::Type,\n                naxes::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}; prepend_primary::Bool = false)\n\nInsert a new image extension immediately following the current HDU (CHDU), or insert a new primary array at the beginning of the file.\n\nA new primary array may be inserted at the beginning of the FITS file by calling fits_insert_img with prepend_primary set to true. In this case, the existing primary HDU is converted to an image extension, and the new primary array will become the CHDU.\n\nThe inserted array has an eltype T and size naxes.\n\nfits_insert_img(f::FITSFile, a::AbstractArray{<:Real}; prepend_primary::Bool = false)\n\nInsert a new image HDU with an element type of eltype(a) and a size of size(a) that is capable of storing the array a. The flag prepend_primary may be specified to insert a new primary array at the beginning of the FITS file.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_insert_img(f, Int64, [2, 2])\n\njulia> fits_get_img_dim(f)\n2\n\njulia> fits_get_img_size(f)\n2-element Vector{Int64}:\n 2\n 2\n\njulia> type_from_bitpix(fits_get_img_type(f))\nInt64\n\njulia> fits_insert_img(f, Float64, (3, 4, 5), prepend_primary=true)\n\njulia> fits_get_img_dim(f)\n3\n\njulia> fits_get_img_size(f)\n3-element Vector{Int64}:\n 3\n 4\n 5\n\njulia> type_from_bitpix(fits_get_img_type(f))\nFloat64\n\njulia> fits_get_hdu_num(f)\n1\n\njulia> a = rand(2, 2);\n\njulia> fits_insert_img(f, a)\n\njulia> fits_get_img_dim(f)\n2\n\njulia> fits_get_img_size(f)\n2-element Vector{Int64}:\n 2\n 2\n\njulia> type_from_bitpix(fits_get_img_type(f))\nFloat64\n\njulia> fits_get_hdu_num(f)\n2\n\njulia> fits_get_num_hdus(f)\n3\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"image/#CFITSIO.fits_write_pix","page":"Image","title":"CFITSIO.fits_write_pix","text":"fits_write_pix(f::FITSFile,\n               [fpixel::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}},\n               nelements::Integer,] data::StridedArray)\n\nWrite nelements pixels from data into the FITS file starting from the pixel fpixel.\n\nThe arguments fpixel and nelements are optional, and are necessary if only a section of the array is to be written out. If these are not provided, the entire data array is written to the FITS file.\n\nnote: Note\nThe HDU must have been created previously, and its length must match the number of elements being written.\n\nnote: Note\ndata needs to be stored contiguously in memory.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_img(f, Int64, (2,))\n\njulia> A = [1 3; 2 4]\n2×2 Matrix{Int64}:\n 1  3\n 2  4\n\njulia> fits_write_pix(f, first.(axes(A)), 2, A) # write the first two elements from A\n\njulia> B = similar(A, 2);\n\njulia> fits_read_pix(f, B);\n\njulia> B\n2-element Vector{Int64}:\n 1\n 2\n\njulia> fits_create_img(f, Float64, size(A))\n\njulia> fits_write_pix(f, A) # write the entire array, implicitly casting to Float64\n\njulia> Bf = similar(A, Float64);\n\njulia> fits_read_pix(f, Bf);\n\njulia> Bf\n2×2 Matrix{Float64}:\n 1.0  3.0\n 2.0  4.0\n\njulia> close(f)\n\nSee also: fits_write_pixnull, fits_write_subset\n\n\n\n\n\n","category":"function"},{"location":"image/#CFITSIO.fits_write_pixnull","page":"Image","title":"CFITSIO.fits_write_pixnull","text":"fits_write_pixnull(f::FITSFile,\n                   [fpixel::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}},\n                   nelements::Integer,] data::StridedArray, nulval)\n\nWrite nelements pixels from data into the FITS file starting from the pixel fpixel. The argument nulval specifies the values that are to be considered as \"null values\", and replaced by appropriate numbers corresponding to the element type of data.\n\nFor integer FITS arrays, the FITS null value is defined by the BLANK keyword (an error is returned if the BLANK keyword doesn’t exist). For floating point FITS arrays, NaN of the appropriate type will be written into the FITS file.\n\nThe arguments fpixel and nelements are optional, and are necessary if only a section of the array is to be written out. If these are not provided, the entire data array is written to the FITS file.\n\nnote: Note\nThe HDU must have been created previously, and its size must match the number of elements being written.\n\nnote: Note\ndata needs to be stored contiguously in memory.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_img(f, Int64, (2, 2));\n\njulia> fits_write_key(f, \"BLANK\", 0, \"Null value for integer arrays\");\n\njulia> fits_write_pixnull(f, [1, 1], 4, [1 3; 2 4], 3);\n\njulia> B = zeros(Int64, 2, 2);\n\njulia> fits_read_pix(f, B);\n\njulia> B\n2×2 Matrix{Int64}:\n 1  0\n 2  4\n\njulia> fits_create_img(f, Float64, (2, 2));\n\njulia> fits_write_pixnull(f, [1.0 3.0; 2.0 4.0], 1.0);\n\njulia> Bf = zeros(Float64, 2, 2);\n\njulia> fits_read_pix(f, Bf);\n\njulia> Bf\n2×2 Matrix{Float64}:\n NaN    3.0\n   2.0  4.0\n\njulia> close(f);\n\nSee also: fits_write_pix, fits_write_subset.\n\n\n\n\n\n","category":"function"},{"location":"image/#CFITSIO.fits_write_subset","page":"Image","title":"CFITSIO.fits_write_subset","text":"fits_write_subset(f::FITSFile,\n                  fpixel::V, lpixel::V,\n                  data::StridedArray) where {V<:Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}}\n\nWrite a rectangular section of the FITS image. The number of pixels to be written will be computed from the first and last pixels (specified as the fpixel and lpixel arguments respectively).\n\nnote: Note\nThe HDU must have been created previously, and its size must match the number of elements being written.\n\nnote: Note\nThe section to be written out must be contiguous in memory, so all the dimensions aside from the last one must span the entire axis range. The arguments fpixel and lpixel must account for this.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_img(f, Int64, (3, 2))\n\njulia> A = reshape([1:9;], 3, 3)\n3×3 Matrix{Int64}:\n 1  4  7\n 2  5  8\n 3  6  9\n\njulia> fits_write_subset(f, [1, 1], [3, 2], A)\n\njulia> B = zeros(Int64, 3, 2);\n\njulia> fits_read_pix(f, B);\n\njulia> B\n3×2 Matrix{Int64}:\n 1  4\n 2  5\n 3  6\n\njulia> close(f)\n\nSee also: fits_write_pix, fits_write_pixnull.\n\n\n\n\n\n","category":"function"},{"location":"image/#CFITSIO.fits_read_pix","page":"Image","title":"CFITSIO.fits_read_pix","text":"fits_read_pix(f::FITSFile,\n              fpixel::NTuple{Vector{<:Integer}, Tuple{Vararg{Integer}}},\n              nelements::Integer, [nulval,] data::StridedArray)\n\nRead nelements pixels from the FITS file into data starting from the pixel fpixel. If the optional argument nulval is specified and is non-zero, any null value present in the array will be replaced by it.\n\nnote: Note\ndata needs to be stored contiguously in memory.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_img(f, Int64, (2, 2))\n\njulia> fits_write_pix(f, [1 3; 2 4])\n\njulia> B = zeros(Int64, 2, 2);\n\njulia> fits_read_pix(f, [1, 1], 4, B);\n\njulia> B\n2×2 Matrix{Int64}:\n 1  3\n 2  4\n\njulia> fits_create_img(f, Float64, (2, 2))\n\njulia> fits_write_pix(f, [1.0 3.0; NaN 4.0])\n\njulia> Bf = zeros(Float64, 2, 2);\n\njulia> fits_read_pix(f, [1, 1], 4, 2.0, Bf); # replace NaN with 2.0\n\njulia> Bf\n2×2 Matrix{Float64}:\n 1.0  3.0\n 2.0  4.0\n\njulia> close(f)\n\nSee also: fits_read_pixnull, fits_read_subset\n\n\n\n\n\nfits_read_pix(f::FITSFile, data::StridedArray, [nulval])\n\nRead length(data) pixels from the FITS file into data starting from the first pixel. The optional argument nulval, if specified and non-zero, is used to replace any null value present in the array.\n\nnote: Note\ndata needs to be stored contiguously in memory.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_img(f, Int64, (2, 2))\n\njulia> A = [1 3; 2 4]\n2×2 Matrix{Int64}:\n 1  3\n 2  4\n\njulia> fits_write_pix(f, A)\n\njulia> B = similar(A);\n\njulia> fits_read_pix(f, B);\n\njulia> B\n2×2 Matrix{Int64}:\n 1  3\n 2  4\n\njulia> close(f)\n\nSee also: fits_read_pixnull\n\n\n\n\n\n","category":"function"},{"location":"image/#CFITSIO.fits_read_pixnull","page":"Image","title":"CFITSIO.fits_read_pixnull","text":"fits_read_pixnull(f::FITSFile,\n                  fpixel::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}},\n                  nelements::Integer, data::StridedArray, nullarray::Array{UInt8})\n\nRead nelements pixels from the FITS file into data starting from the pixel fpixel. At output, the indices of nullarray where data has a corresponding null value are set to 1.\n\nnote: Note\ndata needs to be stored contiguously in memory.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> A = Float64[NaN 2; 3 4]\n2×2 Matrix{Float64}:\n NaN    2.0\n   3.0  4.0\n\njulia> fits_create_img(f, A)\n\njulia> fits_write_pix(f, A)\n\njulia> B = similar(A);\n\njulia> nullarray = zeros(UInt8, size(A));\n\njulia> fits_read_pixnull(f, first.(axes(B)), length(B), B, nullarray);\n\njulia> nullarray\n2×2 Matrix{UInt8}:\n 0x01  0x00\n 0x00  0x00\n\njulia> B[2:4] == A[2:4]\ntrue\n\njulia> close(f)\n\nSee also: fits_read_pix\n\n\n\n\n\nfits_read_pixnull(f::FITSFile, data::StridedArray, nullarray::Array{UInt8})\n\nRead length(data) pixels from the FITS file into data starting from the first pixel. At output, the indices of nullarray where data has a corresponding null value are set to 1.\n\nnote: Note\ndata needs to be stored contiguously in memory.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> A = Float64[NaN 2; 3 4]\n2×2 Matrix{Float64}:\n NaN    2.0\n   3.0  4.0\n\njulia> fits_create_img(f, A)\n\njulia> fits_write_pix(f, A)\n\njulia> B = similar(A);\n\njulia> nullarray = zeros(UInt8, size(A));\n\njulia> fits_read_pixnull(f, B, nullarray);\n\njulia> nullarray\n2×2 Matrix{UInt8}:\n 0x01  0x00\n 0x00  0x00\n\njulia> B[2:4] == A[2:4]\ntrue\n\njulia> close(f)\n\nSee also: fits_read_pix\n\n\n\n\n\n","category":"function"},{"location":"image/#CFITSIO.fits_read_subset","page":"Image","title":"CFITSIO.fits_read_subset","text":"fits_read_subset(f::FITSFile,\n                 fpixel::V, lpixel::V, inc::V,\n                 [nulval],\n                 data::StridedArray) where {V<:Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}}\n\nRead a rectangular section of the FITS image. The number of pixels to be read will be computed from the first and last pixels (specified as the fpixel and lpixel arguments respectively). The argument inc specifies the step-size in pixels along each dimension.\n\nIf the optional argument nulval is specified and is non-zero, null values in data will be replaced by it.\n\nnote: Note\ndata needs to be stored contiguously in memory, and will be populated contiguously with the pixels that are read in.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> A = [1 3; 2 4]\n2×2 Matrix{Int64}:\n 1  3\n 2  4\n\njulia> fits_create_img(f, A)\n\njulia> fits_write_pix(f, A)\n\njulia> Bf = similar(A, 2);\n\njulia> fits_read_subset(f, [1,1], [2,1], [1,1], Bf);\n\njulia> Bf\n2-element Vector{Int64}:\n 1\n 2\n\njulia> close(f)\n\nSee also: fits_read_pix\n\n\n\n\n\n","category":"function"},{"location":"image/#CFITSIO.fits_read_imghdr","page":"Image","title":"CFITSIO.fits_read_imghdr","text":"fits_read_imghdr(f::FITSFile, maxdim::Integer = 99)\n\nRead the header of an image HDU, where maxdim represents the maximum number of dimensions to read. By default, maxdim == 99 will read the size along every dimension of the image. The function returns the values of SIMPLE::Bool, BITPIX::Int, NAXIS::Int, NAXES::Vector{Int}, PCOUNT::Int, GCOUNT::Int, and EXTEND::Bool. The length of NAXES is set equal to min(NAXIS, maxdim).\n\nThe BITPIX value indicates the data type of the image, and it may be converted to a Julia type using the type_from_bitpix function.\n\nnote: Note\nPCOUNT is typically 0 for image HDUs, and GCOUNT is typically 1 for modern files.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_img(f, Int32, (100, 200))\n\njulia> fits_read_imghdr(f)\n(true, 32, 2, [100, 200], 0, 1, true)\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"image/#CFITSIO.fits_copy_image_section","page":"Image","title":"CFITSIO.fits_copy_image_section","text":"fits_copy_image_section(fin::FITSFile, fout::FITSFile, section::String)\n\nCopy a rectangular section of an image from fin and write it to a new FITS primary image or image extension in fout. The section specifier is described on the CFITSIO website.\n\nExample\n\njulia> fin_name = joinpath(mktempdir(), \"test_in.fits\");\n\njulia> fout_name = joinpath(mktempdir(), \"test_out.fits\");\n\njulia> fin = fits_create_file(fin_name);\n\njulia> fout = fits_create_file(fout_name);\n\njulia> A = reshape([1:16;], 4, 4)\n4×4 Matrix{Int64}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> fits_create_img(fin, A)\n\njulia> fits_write_pix(fin, A)\n\njulia> fits_copy_image_section(fin, fout, \"1:2,1:3\");\n\njulia> B = zeros(Int64, 2, 3);\n\njulia> fits_read_pix(fout, B);\n\njulia> B\n2×3 Matrix{Int64}:\n 1  5   9\n 2  6  10\n\njulia> foreach(close, (fin, fout));\n\n\n\n\n\n","category":"function"},{"location":"image/#CFITSIO.fits_write_null_img","page":"Image","title":"CFITSIO.fits_write_null_img","text":"fits_write_null_img(f::FITSFile, firstelem::Integer, nelements::Integer)\n\nSet a stretch of elements to the appropriate null value, starting from the pixel number firstelem and extending over nelements pixels. For Integer arrays, the BLANK keyword sets the null value, while for Float64 arrays, the NAN value is used.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> A = Float64[1 2; 3 4]\n2×2 Matrix{Float64}:\n 1.0  2.0\n 3.0  4.0\n\njulia> fits_create_img(f, A)\n\njulia> fits_write_pix(f, A)\n\njulia> fits_write_null_img(f, 1, 2)\n\njulia> B = zeros(Float64, 2, 2);\n\njulia> fits_read_pix(f, B);\n\njulia> B\n2×2 Matrix{Float64}:\n NaN  2.0\n NaN  4.0\n\njulia> fits_write_pix(f, A) # reset the image\n\njulia> fits_write_null_img(f, 3, 2) # set the last two pixels to null\n\njulia> fits_read_pix(f, B);\n\njulia> B\n2×2 Matrix{Float64}:\n 1.0  NaN\n 3.0  NaN\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"image/#CFITSIO.fits_resize_img","page":"Image","title":"CFITSIO.fits_resize_img","text":"fits_resize_img(f::FITSFile, T::Type, naxis::Integer,\n                sz::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}})\n\nModify the size, dimensions and optionally the element type of the image in f. The new image will have an element type T, be a naxis-dimensional image with size sz. If the new image is larger than the existing one, it will be zero-padded at the end. If the new image is smaller, existing image data will be truncated.\n\nnote: Note\nThis method reinterprets the data instead of coercing the elements.\n\nExample\n\njulia> f = fits_clobber_file(tempname());\n\njulia> a = [1 2; 3 4];\n\njulia> fits_create_img(f, a);\n\njulia> fits_write_pix(f, a);\n\njulia> fits_get_img_size(f)\n2-element Vector{Int64}:\n 2\n 2\n\njulia> fits_resize_img(f, [3,3]);\n\njulia> fits_get_img_size(f)\n2-element Vector{Int64}:\n 3\n 3\n\njulia> b = similar(a, (3,3));\n\njulia> fits_read_pix(f, b); b\n3×3 Matrix{Int64}:\n 1  4  0\n 3  0  0\n 2  0  0\n\njulia> fits_resize_img(f, [4]);\n\njulia> b = similar(a, (4,));\n\njulia> fits_read_pix(f, b); b\n4-element Vector{Int64}:\n 1\n 3\n 2\n 4\n\n\n\n\n\nfits_resize_img(f::FITSFile, sz::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}})\n\nResize the image to the new size sz. The element type is preserved, and the number of dimensions is set equal to length(sz).\n\n\n\n\n\nfits_resize_img(f::FITSFile, T::Type)\n\nChange the element type of the image to T, leaving the size unchanged.\n\n\n\n\n\n","category":"function"},{"location":"image/#CFITSIO.fits_get_img_equivtype","page":"Image","title":"CFITSIO.fits_get_img_equivtype","text":"fits_get_img_equivtype(f::FITSFile)\n\nReturn the equivalent datatype (bitpix) of the current image HDU. This is the same as fits_get_img_type except that it returns the bitpix value for the equivalent type, which is the type that would be used if the image were to be read as an array. The equivalent type is determined by the BSCALE and BZERO keywords in the header. If the image is not scaled, the equivalent type is the same as the type returned by fits_get_img_type.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_img(f, Int16, (2,2))\n\njulia> fits_write_key(f, \"BSCALE\", 0.1, \"Scale factor for the image\")\n\njulia> fits_write_key(f, \"BZERO\", 0.0, \"Zero point for the image\")\n\njulia> fits_get_img_equivtype(f)\n-32\n\njulia> type_from_bitpix(fits_get_img_equivtype(f))\nFloat32\n\njulia> fits_get_img_type(f)\n16\n\njulia> type_from_bitpix(fits_get_img_type(f))\nInt16\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"table/#Table-Routines","page":"Table","title":"Table Routines","text":"","category":"section"},{"location":"table/","page":"Table","title":"Table","text":"There are two functions to create a new HDU table extension: fits_create_ascii_table and fits_create_binary_table. In general, one should pick the second as binary tables require less space on the disk and are more efficient to read and write. (Moreover, a few datatypes are not supported in ASCII tables). In order to create a table, the programmer must specify the characteristics of each column by passing an array of tuples. Here is an example:","category":"page"},{"location":"table/","page":"Table","title":"Table","text":"f = fits_create_file(\"!new.fits\")\ncoldefs = [(\"SPEED\", \"1D\", \"m/s\"),\n           (\"MASS\", \"1E\", \"kg\"),\n           (\"PARTICLE\", \"20A\", \"Name\")]\nfits_create_binary_tbl(f, 10, coldefs, \"PARTICLE\")","category":"page"},{"location":"table/","page":"Table","title":"Table","text":"This example creates a table with room for 10 entries, each of them describing the characteristics of a particle: its speed, its mass, and its name (codified as a 20-character string). See the documentation of fits_create_ascii_tbl for more details.","category":"page"},{"location":"table/#CFITSIO.fits_create_ascii_tbl","page":"Table","title":"CFITSIO.fits_create_ascii_tbl","text":"fits_create_ascii_tbl(f::FITSFile, numrows::Integer,\n                      coldefs::Union{Array{NTuple{3,String}}, Array{NTuple{2,String}}},\n                      extname::Union{String, Nothing} = nothing)\n\nAppend a new HDU containing an ASCII table.\n\nThe table will have numrows rows (this parameter can be set to zero), each initialized with the default value. In order to create a table, the programmer must specify the characteristics of each column. The columns are specified by the coldefs variable, which is an array of tuples. Each tuple must have two or three string fields:\n\nThe name of the column.\nThe data type and the repetition count. It must be a string made by a number (the repetition count) followed by a letter specifying the type (in the example above, D stands for Float64, E stands for Float32, A stands for Char). Refer to the CFITSIO documentation for more information about the syntax of this parameter.\nThe unit of this field. This is used to set the corresponding TUNITn keywords. If coldefs is a two-tuple, the unit keywords are left unset. If the third field of a tuple is an empty string, the corresponding unit keyword is also left unset.\n\nThe value of extname sets the \"extended name\" of the table, i.e., a string that in some situations can be used to refer to the HDU itself. This may be omitted by setting extname to nothing (which is the default behavior).\n\nNote that, unlike for binary tables, CFITSIO puts some limitations to the types that can be used in an ASCII table column. Refer to the CFITSIO manual for further information.\n\nSee also fits_create_binary_tbl for a similar function which creates binary tables. In general, one should pick this function for creating tables in a new HDU, as binary tables require less space on the disk and are more efficient to read and write. (Moreover, a few datatypes are not supported in ASCII tables).\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> cols = [\n                (\"ID\", \"I6\", \"\"),\n                (\"VALUE\", \"F10.2\", \"meters\"),\n                (\"NAME\", \"A10\", \"\")\n            ];\n\njulia> fits_create_ascii_tbl(f, 0, cols);\n\njulia> fits_write_col(f, 1, 1, 1, Int32[1, 2, 3, 4, 5])\n\njulia> fits_write_col(f, 2, 1, 1, Float64[1.1, 2.2, 3.3, 4.4, 5.5])\n\njulia> fits_write_col(f, 3, 1, 1, [\"alpha\", \"beta\", \"gamma\", \"delta\", \"epsilon\"])\n\njulia> close(f)\n\njulia> f = fits_open_file(fname, CFITSIO.READONLY);\n\njulia> fits_get_num_hdus(f)\n2\n\njulia> fits_movabs_hdu(f, 2)\n:ascii_table\n\njulia> nrows = fits_get_num_rows(f)\n5\n\njulia> fits_get_num_cols(f)\n3\n\njulia> fits_read_col(f, 1, 1, 1, Vector{Int32}(undef, nrows))\n5-element Vector{Int32}:\n 1\n 2\n 3\n 4\n 5\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"table/#CFITSIO.fits_create_binary_tbl","page":"Table","title":"CFITSIO.fits_create_binary_tbl","text":"fits_create_binary_tbl(f::FITSFile, numrows::Integer,\n                       coldefs::Union{Array{NTuple{3,String}}, Array{NTuple{2,String}}},\n                       extname::Union{String, Nothing} = nothing)\n\nAppend a new HDU containing a binary table. The meaning of the parameters is the same as in a call to fits_create_ascii_tbl.\n\nIn general, one should pick this function for creating tables in a new HDU, as binary tables require less space on the disk and are more efficient to read and write. (Moreover, a few datatypes are not supported in ASCII tables).\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> coldefs = [\n           (\"col1\", \"1J\", \"units\"),\n           (\"col2\", \"1E\", \"\"),\n           (\"col3\", \"1A\", \"m/s\"),\n       ];\n\njulia> fits_create_binary_tbl(f, 0, coldefs);\n\njulia> fits_write_col(f, 1, 1, 1, [1, 2, 3]);\n\njulia> fits_write_col(f, 2, 1, 1, [1.0, 2.0, 3.0]);\n\njulia> fits_write_col(f, 3, 1, 1, [\"a\", \"b\", \"c\"]);\n\njulia> close(f)\n\njulia> f = fits_open_file(fname, CFITSIO.READONLY);\n\njulia> fits_get_num_hdus(f)\n2\n\njulia> fits_movabs_hdu(f, 2)\n:binary_table\n\njulia> fits_get_num_rows(f)\n3\n\njulia> fits_get_num_cols(f)\n3\n\njulia> fits_read_col(f, 1, 1, 1, zeros(Int32, 3))\n3-element Vector{Int32}:\n 1\n 2\n 3\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"table/#CFITSIO.fits_create_tbl","page":"Table","title":"CFITSIO.fits_create_tbl","text":"fits_create_tbl(f::FITSFile, tbltype, numrows::Integer,\n    ttype::Vector{String}, tform::Vector{String},\n    tunit::Union{Vector{String}, Nothing} = nothing,\n    extname::Union{String, Nothing} = nothing)\n\nCreate a new table HDU in the FITS file f with the specified parameters. The tbltype sets the type of the table, which can be either CFITSIO.ASCII_TBL or CFITSIO.BINARY_TBL. The numrows parameter reserves space for a specified number of rows in the table, and it can be set to zero if the table is populated later. The ttype and tform parameters specify the names and types of the columns in the table, respectively. The tunit parameter is optional and can be used to specify the units of the columns. If tunit is not provided, the units will not be set in the table. The extname parameter is also optional and can be used to set the extended name of the table. If extname is not provided, the table will not have an extended name. The ttype, tform, and tunit parameters must be vectors of the same length, where each element corresponds to a column in the table.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> ttype = [\"col1\", \"col2\", \"col3\"];\n\njulia> tform = [\"1J\", \"1E\", \"1A\"];\n\njulia> tunit = [\"units1\", \"units2\", \"m/s\"];\n\njulia> fits_create_tbl(f, CFITSIO.BINARY_TBL, 0, ttype, tform, tunit);\n\njulia> fits_write_col(f, 1, 1, 1, [1, 2, 3]);\n\njulia> fits_write_col(f, 2, 1, 1, [1.0, 2.0, 3.0]);\n\njulia> fits_write_col(f, 3, 1, 1, [\"a\", \"b\", \"c\"]);\n\njulia> close(f);\n\njulia> f = fits_open_file(fname, CFITSIO.READONLY);\n\njulia> fits_get_num_hdus(f)\n2\n\njulia> fits_movabs_hdu(f, 2)\n:binary_table\n\njulia> fits_get_num_rows(f)\n3\n\njulia> fits_get_num_cols(f)\n3\n\njulia> fits_read_col(f, 1, 1, 1, zeros(Int32, 3))\n3-element Vector{Int32}:\n 1\n 2\n 3\n\njulia> close(f);\n\nSee also fits_create_ascii_tbl and fits_create_binary_tbl for similar functions that create ASCII and binary tables, respectively.\n\n\n\n\n\n","category":"function"},{"location":"table/#CFITSIO.fits_delete_col","page":"Table","title":"CFITSIO.fits_delete_col","text":"fits_delete_col(f::FITSFile, colnum::Integer)\n\nDelete the column at position colnum in the current HDU.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\", \"units\"), (\"col2\", \"1E\", \"units\")]);\n\njulia> fits_write_col(f, 1, 1, 1, [1, 2, 3]);\n\njulia> fits_write_col(f, 2, 1, 1, [1.0, 2.0, 3.0]);\n\njulia> fits_get_num_cols(f)\n2\n\njulia> fits_get_coltype(f, 1)\n(41, 1, 4)\n\njulia> fits_delete_col(f, 1); # delete the first column\n\njulia> fits_get_num_cols(f)\n1\n\njulia> fits_get_coltype(f, 1)\n(42, 1, 4)\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"table/#CFITSIO.fits_delete_rowlist","page":"Table","title":"CFITSIO.fits_delete_rowlist","text":"fits_delete_rowlist(f::FITSFile, rowlist::Vector{<:Integer})\n\nDelete a list of rows from the current HDU. The rows to be deleted are specified by the rowlist vector, which contains the row numbers to be deleted. The row numbers are 1-based, so the first row is at position 1.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\", \"units\")]);\n\njulia> fits_write_col(f, 1, 1, 1, [1, 2, 3, 4, 5])\n\njulia> CFITSIO.fits_flush_file(f); # flush the file to disk\n\njulia> fits_delete_rowlist(f, [1, 3, 5]); # delete rows 1, 3 and 5\n\njulia> fits_read_col(f, 1, 1, 1, zeros(Int32, 2))\n2-element Vector{Int32}:\n 2\n 4\n\njulia> close(f);\n\n\n\n\n\n","category":"function"},{"location":"table/#CFITSIO.fits_get_colnum","page":"Table","title":"CFITSIO.fits_get_colnum","text":"fits_get_colnum(f::FITSFile, tmplt::String; case_sensitive::Bool = true)\n\nReturn the column number of the first column whose name matches the template tmplt. If no column matches, an error is thrown. The template can contain the * character, which matches any number of characters. The keyword argument case_sensitive determines whether the search is case-sensitive or not.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"Count\", \"1J\", \"units\"), (\"Energy\", \"1E\", \"eV\")]);\n\njulia> fits_get_colnum(f, \"Energy\")\n2\n\njulia> fits_get_colnum(f, \"e*\"; case_sensitive = false)\n2\n\njulia> fits_get_colnum(f, \"col\")\nERROR: CFITSIO has encountered an error. Error code 219: named column not found\nDetailed error message follows:\nffgcnn could not find column: col\n[...]\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"table/#CFITSIO.fits_get_coltype","page":"Table","title":"CFITSIO.fits_get_coltype","text":"fits_get_coltype(f::FITSFile, colnum::Integer)\n\nProvided that the current HDU contains either an ASCII or binary table, return information about the column at position colnum (counting from 1).\n\nReturns a tuple containing\n\ntypecode: CFITSIO integer type code of the column.\nrepcount: Repetition count for the column.\nwidth: Width of an individual element.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\", \"units\")]);\n\njulia> fits_get_coltype(f, 1)\n(41, 1, 4)\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"table/#CFITSIO.fits_get_eqcoltype","page":"Table","title":"CFITSIO.fits_get_eqcoltype","text":"fits_get_eqcoltype(ff::FITSFile, colnum::Integer)\n\nProvided that the current HDU contains either an ASCII or binary table, return information about the column at position colnum (counting from 1). This returns the equivalent data type of the column.\n\nReturns a tuple containing\n\ntypecode: CFITSIO integer type code of the column.\nrepcount: Repetition count for the column.\nwidth: Width of an individual element.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1I\", \"units\")]); # Int16 values\n\njulia> fits_write_key(f, \"TSCAL1\", 0.1, \"scale factor\")\n\njulia> fits_write_key(f, \"TZERO1\", 0.0, \"zero point\")\n\njulia> fits_get_eqcoltype(f, 1) # equivalent element type is Float32, code 42\n(42, 1, 2)\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"table/#CFITSIO.fits_get_num_cols","page":"Table","title":"CFITSIO.fits_get_num_cols","text":"fits_get_num_cols(f::FITSFile)\n\nReturn the number of columns in the current table HDU.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\", \"units\")]);\n\njulia> close(f)\n\njulia> f = fits_open_file(fname, CFITSIO.READONLY);\n\njulia> fits_movabs_hdu(f, 2);\n\njulia> fits_get_num_cols(f)\n1\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"table/#CFITSIO.fits_get_num_rows","page":"Table","title":"CFITSIO.fits_get_num_rows","text":"fits_get_num_rows(f::FITSFile)\n\nReturn the number of rows in the current table HDU.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\", \"units\")]);\n\njulia> fits_get_num_rows(f)\n0\n\njulia> fits_write_col(f, 1, 1, 1, [1, 2, 3]);\n\njulia> fits_get_num_rows(f)\n3\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"table/#CFITSIO.fits_get_rowsize","page":"Table","title":"CFITSIO.fits_get_rowsize","text":"fits_get_rowsize(f::FITSFile)\n\nReturn optimal number of rows to read or write at one time for maximum I/O efficiency.\n\n\n\n\n\n","category":"function"},{"location":"table/#CFITSIO.fits_insert_col","page":"Table","title":"CFITSIO.fits_insert_col","text":"fits_insert_col(f::FITSFile, colnum::Integer, ttype::String, tform::String)\n\nInsert a new column at position colnum in the current table HDU. The ttype and tform parameters specify the name and type of the column, respectively.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\", \"units\")]);\n\njulia> fits_insert_col(f, 2, \"col2\", \"1E\");\n\njulia> fits_write_col(f, 2, 1, 1, [1.0, 2.0, 3.0]);\n\njulia> fits_read_col(f, 2, 1, 1, zeros(Float32, 3))\n3-element Vector{Float32}:\n 1.0\n 2.0\n 3.0\n\njulia> close(f);\n\n\n\n\n\n","category":"function"},{"location":"table/#CFITSIO.fits_insert_cols","page":"Table","title":"CFITSIO.fits_insert_cols","text":"fits_insert_cols(f::FITSFile, colnum::Integer,\n    ttype::Vector{String}, tform::Vector{String})\n\nInsert a number of new columns at position colnum in the current table HDU. The ttype and tform parameters specify the names and types of the columns, respectively. The length of ttype and tform must match, as each column corresponds to one element in these vectors.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\", \"units\")]);\n\njulia> fits_insert_cols(f, 2, [\"col2\", \"col3\"], [\"1E\", \"1D\"]);\n\njulia> fits_write_col(f, 2, 1, 1, [1.0, 2.0, 3.0]);\n\njulia> fits_write_col(f, 3, 1, 1, [1.0, 2.0, 3.0]);\n\njulia> fits_read_col(f, 2, 1, 1, zeros(Float32, 3))\n3-element Vector{Float32}:\n 1.0\n 2.0\n 3.0\n\njulia> fits_read_col(f, 3, 1, 1, zeros(Float64, 3))\n3-element Vector{Float64}:\n 1.0\n 2.0\n 3.0\n\njulia> close(f);\n\n\n\n\n\n","category":"function"},{"location":"table/#CFITSIO.fits_insert_rows","page":"Table","title":"CFITSIO.fits_insert_rows","text":"fits_insert_rows(f::FITSFile, firstrow::Integer, nrows::Integer)\n\nInsert a number of rows equal to nrows after the row number firstrow.\n\nThe elements in each row are initialized to their default value: you can modify them later using fits_write_col.\n\nSince the first row is at position 1, in order to insert rows before the first one firstrow must be equal to zero.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\", \"units\")])\n\njulia> fits_write_col(f, 1, 1, 1, [1, 2, 3])\n\njulia> fits_insert_rows(f, 0, 2)\n\njulia> fits_write_col(f, 1, 1, 1, [4, 5])\n\njulia> fits_read_col(f, 1, 1, 1, zeros(Int32, 5))\n5-element Vector{Int32}:\n 4\n 5\n 1\n 2\n 3\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"table/#CFITSIO.fits_delete_rows","page":"Table","title":"CFITSIO.fits_delete_rows","text":"fits_delete_rows(f::FITSFile, firstrow::integer, nrows::Integer)\n\nDelete nrows rows, starting from the one at position firstrow. The index of the first row is 1.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\", \"units\")]);\n\njulia> fits_write_col(f, 1, 1, 1, [1, 2, 3]);\n\njulia> fits_delete_rows(f, 1, 2); # delete the first two rows\n\njulia> fits_read_col(f, 1, 1, 1, zeros(Int32, 1))\n1-element Vector{Int32}:\n 3\n\njulia> close(f);\n\n\n\n\n\n","category":"function"},{"location":"table/#CFITSIO.fits_read_col","page":"Table","title":"CFITSIO.fits_read_col","text":"fits_read_col(f::FITSFile, colnum::Integer, firstrow::Integer, firstelem::Integer, data::Array)\n\nRead data from one column of an ASCII/binary table into data.\n\nArguments\n\nf::FITSFile: the file to be read.\ncolnum::Integer: the column number, where the value of the first column is 1.\nfirstrow::Integer: the elements to be read start from this row.\nfirstelem::Integer: specifies which is the first element to be read, when each cell contains more than one element (i.e., the \"repetition count\" of the field is greater than one).\ndata::Array: at the end of the call, this will be filled with the elements read\n\nfrom the column. The length of the array gives the overall number of elements.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\", \"units\")]);\n\njulia> fits_write_col(f, 1, 1, 1, [1, 2, 3]);\n\njulia> fits_read_col(f, 1, 1, 1, zeros(Int32, 3))\n3-element Vector{Int32}:\n 1\n 2\n 3\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"table/#CFITSIO.fits_read_atblhdr","page":"Table","title":"CFITSIO.fits_read_atblhdr","text":"fits_read_atblhdr(f::FITSFile, maxdim::Integer = 99)\n\nRead the header of an ASCII table HDU, where maxdim represents the maximum number of columns to read. The function returns the length of a row in bytes, the number of rows, the number of columns, the column names as a Vector{String}, the byte offsets to each column, the TFORMn values as a Vector{String}, the TUNITn values as a Vector{String}, and the EXTNAME::String keyword, if any.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_ascii_tbl(f, 0, [(\"col1\", \"D10\"), (\"col2\", \"F10.2\")])\n\njulia> fits_read_atblhdr(f)\n(21, 0, 2, [\"col1\", \"col2\"], [1, 12], [\"D10\", \"F10.2\"], [\"\", \"\"], \"\")\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"table/#CFITSIO.fits_read_btblhdr","page":"Table","title":"CFITSIO.fits_read_btblhdr","text":"fits_read_btblhdr(f::FITSFile, maxdim::Integer = 99)\n\nRead the header of a binary table HDU, where maxdim represents the maximum number of columns to read. The function returns the number of rows, the number of columns, the column names as a Vector{String}, the TFORMn values  as a Vector{String}, the TUNITn values as a Vector{String}, and the EXTNAME::String and PCOUNT::Int keywords.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\"), (\"col2\", \"1E\")])\n\njulia> fits_read_btblhdr(f)\n(0, 2, [\"col1\", \"col2\"], [\"1J\", \"1E\"], [\"\", \"\"], \"\", 0)\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"table/#CFITSIO.fits_read_descript","page":"Table","title":"CFITSIO.fits_read_descript","text":"fits_read_descript(ff::FITSFile, colnum::Integer, rownum::Integer)\n\nReturn the descriptor for a variable length column in a binary table. The descriptor consists of 2 integer parameters: the number of elements in the array and the starting offset relative to the start of the heap.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1PJ\", \"units\")]) # P = variable length column\n\njulia> fits_write_col(f, 1, 1, 1, [1, 2, 3]) # write a vector to the column\n\njulia> fits_read_descript(f, 1, 1) # read the descriptor for the first row and first column\n(3, 0)\n\njulia> fits_write_col(f, 1, 2, 1, [1, 2, 3, 4])\n\njulia> fits_read_descript(f, 1, 2)\n(4, 12)\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"table/#CFITSIO.fits_read_keys_lng","page":"Table","title":"CFITSIO.fits_read_keys_lng","text":"fits_read_keys_lng(f::FITSFile, keyname::String, nstart::Integer, nmax::Integer)\n\nRead a sequence of indexed keyword values (e.g., NAXIS1, NAXIS2, ...) as an Integer vector. Return the values of the keywords as a Vector{Clong}, as well as the number of values found.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_img(f, Int32, (2, 3));\n\njulia> fits_read_keys_lng(f, \"NAXIS\", 1, 2)\n([2, 3], 2)\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"table/#CFITSIO.fits_read_tdim","page":"Table","title":"CFITSIO.fits_read_tdim","text":"fits_read_tdim(ff::FITSFile, colnum::Integer)\n\nReturn the dimensions of a multidimensional array column in a binary table. The elements are stored contiguously in the column, and the dimensions of the array are normally provided by the TDIMn keyword. If this keyword is not present, then this routine returns [r] with r equals to the repeat count in the TFORM keyword. If the TDIMn keyword is present, it returns the dimensions as specified in that keyword. If the HDU is not a binary table, an error is thrown.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"3E\", \"units\")])\n\njulia> fits_write_col(f, 1, 1, 1, [1.0 2.0 3.0])\n\njulia> fits_read_tdim(f, 1)\n1-element Vector{Int64}:\n 3\n\njulia> fits_write_tdim(f, 1, [1,3]) # specify the dimensions\n\njulia> fits_read_key_str(f, \"TDIM1\")\n(\"(1,3)\", \"size of the multidimensional array\")\n\njulia> fits_read_tdim(f, 1)\n2-element Vector{Int64}:\n 1\n 3\n\njulia> close(f)\n\nSee also fits_write_tdim for writing the dimensions of arrays stored in a column.\n\n\n\n\n\n","category":"function"},{"location":"table/#CFITSIO.fits_write_col","page":"Table","title":"CFITSIO.fits_write_col","text":"fits_write_col(f::FITSFile, colnum::Integer, firstrow::Integer, firstelem::Integer, data::Array)\n\nWrite some data in one column of a ASCII/binary table.\n\nIf there is no room for the elements, new rows will be created. (It is therefore useless to call fits_insert_rows if you only need to append elements to the end of a table.)\n\nf::FITSFile: the file in which data will be written.\ncolnum::Integer: the column number, where the value of the first column is 1.\nfirstrow::Integer: the data wil be written from this row onwards.\nfirstelem::Integer: specifies the position in the row where the first element will be written.\ndata::Array: contains the elements that are to be written to the column of the table.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\", \"units\")]);\n\njulia> fits_write_col(f, 1, 1, 1, [1, 2, 3]);\n\njulia> fits_read_col(f, 1, 1, 1, zeros(Int32, 3))\n3-element Vector{Int32}:\n 1\n 2\n 3\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"table/#CFITSIO.fits_write_tdim","page":"Table","title":"CFITSIO.fits_write_tdim","text":"fits_write_tdim(ff::FITSFile, colnum::Integer, naxes::Vector{Int64})\n\nWrite the dimensions of a multidimensional array column in a binary table. The data is stored contiguously in the column, and the dimensions are specified by the TDIMn keyword.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"3E\", \"units\")])\n\njulia> fits_write_col(f, 1, 1, 1, [1.0 2.0 3.0])\n\njulia> fits_write_tdim(f, 1, [3]) # interpret the data as a 1D array\n\njulia> fits_read_key_str(f, \"TDIM1\")\n(\"(3)\", \"size of the multidimensional array\")\n\njulia> fits_read_tdim(f, 1)\n1-element Vector{Int64}:\n 3\n\njulia> fits_delete_key(f, \"TDIM1\") # remove the TDIM keyword\n\njulia> fits_write_tdim(f, 1, [1,3]) # interpret the data as a 2D array\n\njulia> fits_read_key_str(f, \"TDIM1\")\n(\"(1,3)\", \"size of the multidimensional array\")\n\njulia> fits_read_tdim(f, 1)\n2-element Vector{Int64}:\n 1\n 3\n\njulia> close(f)\n\nSee also fits_read_tdim for reading the dimensions of arrays stored in a column.\n\n\n\n\n\n","category":"function"},{"location":"#CFITSIO.jl","page":"Home","title":"CFITSIO.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: GitHub) (Image: Build Status) (Image: PkgEval) (Image: Coverage)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This module provides an interface familiar to users of the CFITSIO C library. It can be used with","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CFITSIO","category":"page"},{"location":"","page":"Home","title":"Home","text":"The functions exported by this module operate on FITSFile objects, which is a thin wrapper around a pointer to a CFITSIO fitsfile. For the most part, the functions are thin wrappers around the CFITSIO routines of the same names. Typically, they:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Convert from Julia types to C types as necessary.\nCheck the returned status value and raise an appropriate exception if non-zero.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The functionality is described in the various sections.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = Main.pages_files","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nFor a higher-level interface, consider using FITSIO.jl.","category":"page"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"fname = tempname() * \".fits\";\nf = fits_create_file(fname);\nA = ones(2,2)\nfits_create_img(f, A)\nfits_get_hdu_type(f)\nfits_write_pix(f, A)\nB = similar(A);\nfits_read_pix(f, B);\nB\nfits_read_key_str(f, \"NAXIS\")\nfits_create_binary_tbl(f, 0, [(\"COUNT\", \"J\", \"counts\"), (\"ENERGY\", \"D\", \"energy\")], \"Spectrum\")\nfits_write_col(f, 1, 1, 1, [2, 10, 5])\nfits_write_col(f, 2, 1, 1, [10.0, 15.0, 20.0])\ncounts, energy = zeros(Int,3), zeros(Float64,3)\nfits_read_col(f, 1, 1, 1, counts)\nfits_read_col(f, 1, 1, 1, energy)\ncounts, energy\nfits_close_file(f)","category":"page"},{"location":"file/#File-access","page":"File","title":"File access","text":"","category":"section"},{"location":"file/#CFITSIO.fits_assert_open","page":"File","title":"CFITSIO.fits_assert_open","text":"fits_assert_open(f::FITSFile)\n\nAssert that the FITS file f is open, otherwise throw an error.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_assert_open(f)\n\njulia> fits_create_empty_img(f)\n\njulia> close(f)\n\njulia> fits_assert_open(f)\nERROR: ArgumentError: attempt to access a FITS file that has been closed previously\n[...]\n\n\n\n\n\n","category":"function"},{"location":"file/#CFITSIO.fits_create_file","page":"File","title":"CFITSIO.fits_create_file","text":"fits_create_file(filename::AbstractString)\n\nCreate and open a new empty output FITSFile. This methods uses the extended file name syntax to create the file.\n\nnote: Note\nThis function does not overwrite an existing file with the same name, and will throw an exception if this is the case. See fits_clobber_file to delete existing files before creating one.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_file_mode(f) # opened in read-write mode\n1\n\njulia> fits_create_empty_img(f)\n\njulia> close(f)\n\nSee also fits_create_diskfile which does not use the extended filename parser.\n\n\n\n\n\n","category":"function"},{"location":"file/#CFITSIO.fits_create_diskfile","page":"File","title":"CFITSIO.fits_create_diskfile","text":"fits_create_diskfile(filename::AbstractString)\n\nCreate and open a new empty output FITSFile. Unlike fits_create_file, this function does not use an extended filename parser and treats the string as is as the filename.\n\nnote: Note\nThis function does not overwrite an existing file with the same name, and will throw an exception if this is the case.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_diskfile(fname);\n\njulia> fits_file_mode(f) # opened in read-write mode\n1\n\njulia> fits_create_empty_img(f)\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"file/#CFITSIO.fits_clobber_file","page":"File","title":"CFITSIO.fits_clobber_file","text":"fits_clobber_file(filename::AbstractString)\n\nLike fits_create_file, but overwrites filename if it exists.\n\n\n\n\n\n","category":"function"},{"location":"file/#CFITSIO.fits_close_file","page":"File","title":"CFITSIO.fits_close_file","text":"fits_close_file(f::FITSFile)\n\nClose a previously opened FITS file. This is equivalent to calling close(f) on the FITSFile object.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_close_file(f)\n\njulia> fits_assert_open(f)\nERROR: ArgumentError: attempt to access a FITS file that has been closed previously\n[...]\n\n\n\n\n\n","category":"function"},{"location":"file/#CFITSIO.fits_delete_file","page":"File","title":"CFITSIO.fits_delete_file","text":"fits_delete_file(f::FITSFile)\n\nClose an opened FITS file (like fits_close_file) and removes it from the disk.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_delete_file(f)\n\njulia> isfile(fname)\nfalse\n\njulia> fits_assert_open(f)\nERROR: ArgumentError: attempt to access a FITS file that has been closed previously\n[...]\n\n\n\n\n\n","category":"function"},{"location":"file/#CFITSIO.fits_file_name","page":"File","title":"CFITSIO.fits_file_name","text":"fits_file_name(f::FITSFile)::String\n\nReturn the name of the file associated with object f.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_file_name(f) |> basename\n\"test.fits\"\n\njulia> fits_file_name(f) == fname\ntrue\n\njulia> fits_create_empty_img(f)\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"file/#CFITSIO.fits_file_mode","page":"File","title":"CFITSIO.fits_file_mode","text":"fits_file_mode(f::FITSFile)\n\nReturn the I/O mode of the FITS file, where 0 indicates a read-only mode and 1 indicates a read-write mode.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_file_mode(f)\n1\n\njulia> fits_create_empty_img(f)\n\njulia> close(f)\n\njulia> f = fits_open_file(fname, CFITSIO.READONLY);\n\njulia> fits_file_mode(f)\n0\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"file/#CFITSIO.fits_flush_buffer","page":"File","title":"CFITSIO.fits_flush_buffer","text":"fits_flush_buffer(f::FITSFile)\n\nFlush the buffer to disk without updating and closing the current HDU. This is faster than fits_flush_file, and may be used to write the state of the file to disk after each row of a table is written.\n\nnote: Note\nIn most cases, this function should not be needed, as the library automatically flushes the file when it is closed.\n\n\n\n\n\n","category":"function"},{"location":"file/#CFITSIO.fits_flush_file","page":"File","title":"CFITSIO.fits_flush_file","text":"fits_flush_file(f::FITSFile)\n\nFlush the file to disk. This is equivalent to closing the file and reopening it.\n\nnote: Note\nIn most cases, this function should not be needed, as the library automatically flushes the file when it is closed.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\", \"units\")])\n\njulia> fits_write_col(f, 1, 1, 1, [1, 2, 3])\n\njulia> CFITSIO.fits_flush_file(f) # flush the file to disk\n\njulia> fits_read_col(f, 1, 1, 1, zeros(Int32, 3))\n3-element Vector{Int32}:\n 1\n 2\n 3\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"file/#CFITSIO.fits_open_file","page":"File","title":"CFITSIO.fits_open_file","text":"fits_open_file(filename::String, [mode = 0])\n\nOpen an existing data file.\n\nModes:\n\n0 : Read only (equivalently denoted by CFITSIO.READONLY or CFITSIO.R)\n1 : Read-write (equivalently denoted by CFITSIO.READWRITE or CFITSIO.RW)\n\nThis function uses the extended filename syntax to open the file. See also fits_open_diskfile that does not use the extended filename parser and uses filename as is as the name of the file.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> close(f)\n\njulia> f = fits_open_file(fname, CFITSIO.READONLY);\n\njulia> fits_file_mode(f) # opened in read-only mode\n0\n\njulia> fits_movabs_hdu(f, 1) # move to primary HDU\n:image_hdu\n\njulia> fits_get_img_dim(f) # get image dimensions\n0\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"file/#CFITSIO.fits_open_diskfile","page":"File","title":"CFITSIO.fits_open_diskfile","text":"fits_open_diskfile(filename::String, [mode = 0])\n\nOpen an existing data file.\n\nModes:\n\n0 : Read only (equivalently denoted by CFITSIO.READONLY or CFITSIO.R)\n1 : Read-write (equivalently denoted by CFITSIO.READWRITE or CFITSIO.RW)\n\nThis function does not use the extended filename parser, and uses filename as is as the name of the file that is to be opened. See also fits_open_file which uses the extended filename syntax.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_diskfile(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> close(f)\n\njulia> f = fits_open_diskfile(fname, CFITSIO.READONLY);\n\njulia> fits_file_mode(f) # opened in read-only mode\n0\n\njulia> fits_movabs_hdu(f, 1) # move to primary HDU\n:image_hdu\n\njulia> fits_get_img_dim(f) # get image dimensions\n0\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"file/#CFITSIO.fits_open_table","page":"File","title":"CFITSIO.fits_open_table","text":"fits_open_table(filename::String, [mode = 0])\n\nOpen an existing data file (like fits_open_file) and move to the first HDU containing either an ASCII or a binary table.\n\nModes:\n\n0 : Read only (equivalently denoted by CFITSIO.READONLY or CFITSIO.R)\n1 : Read-write (equivalently denoted by CFITSIO.READWRITE or CFITSIO.RW)\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\"), (\"col2\", \"1D\")])\n\njulia> close(f)\n\njulia> f = fits_open_table(fname, CFITSIO.READONLY);\n\njulia> fits_get_hdu_num(f)\n2\n\njulia> fits_get_num_rows(f)\n0\n\njulia> fits_get_num_cols(f)\n2\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"file/#CFITSIO.fits_open_image","page":"File","title":"CFITSIO.fits_open_image","text":"fits_open_image(filename::String, [mode = 0])\n\nOpen an existing data file (like fits_open_file) and move to the first HDU containing an image.\n\nModes:\n\n0 : Read only (equivalently denoted by CFITSIO.READONLY or CFITSIO.R)\n1 : Read-write (equivalently denoted by CFITSIO.READWRITE or CFITSIO.RW)\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\"), (\"col2\", \"1D\")])\n\njulia> A = [1 2; 3 4];\n\njulia> fits_create_img(f, A)\n\njulia> fits_write_pix(f, A)\n\njulia> close(f)\n\njulia> f = fits_open_image(fname, CFITSIO.READONLY); # moves to the last HDU\n\njulia> fits_get_hdu_num(f)\n3\n\njulia> B = similar(A);\n\njulia> fits_read_pix(f, B);\n\njulia> B == A\ntrue\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"file/#CFITSIO.fits_open_data","page":"File","title":"CFITSIO.fits_open_data","text":"fits_open_data(filename::String, [mode = 0])\n\nOpen an existing data file (like fits_open_file) and move to the first HDU containing either an image or a table.\n\nModes:\n\n0 : Read only (equivalently denoted by CFITSIO.READONLY or CFITSIO.R)\n1 : Read-write (equivalently denoted by CFITSIO.READWRITE or CFITSIO.RW)\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> A = [1 2; 3 4];\n\njulia> fits_create_img(f, A)\n\njulia> fits_write_pix(f, A)\n\njulia> close(f)\n\njulia> f = fits_open_data(fname, CFITSIO.READONLY);\n\njulia> B = similar(A);\n\njulia> fits_read_pix(f, B);\n\njulia> B == A\ntrue\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"hdu/#HDU-Routines","page":"HDU","title":"HDU Routines","text":"","category":"section"},{"location":"hdu/","page":"HDU","title":"HDU","text":"The functions described in this section change the current HDU and to find their number and type. The following is a short example which shows how to use them:","category":"page"},{"location":"hdu/","page":"HDU","title":"HDU","text":"num = fits_get_num_hdus(f)\nprintln(\"Number of HDUs in the file: \", num)\n\nfor i = 1:num\n    hdu_type = fits_movabs_hdu(f, i)\n    println(i, \") hdu_type = \", hdu_type)\nend","category":"page"},{"location":"hdu/#CFITSIO.fits_get_num_hdus","page":"HDU","title":"CFITSIO.fits_get_num_hdus","text":"fits_get_num_hdus(f::FITSFile)\n\nReturn the number of HDUs in the file.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_img(f, [1, 2, 3]);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\", \"units\")]);\n\njulia> close(f)\n\njulia> f = fits_open_file(fname, CFITSIO.READONLY);\n\njulia> fits_get_num_hdus(f)\n2\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"hdu/#CFITSIO.fits_get_hdu_num","page":"HDU","title":"CFITSIO.fits_get_hdu_num","text":"fits_get_hdu_num(f::FITSFile)\n\nReturn the index of the current HDU in the FITS file. The primary HDU is numbered 1, the first extension HDU is numbered 2, etc.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\"), (\"col2\", \"1E\")])\n\njulia> fits_get_hdu_num(f)\n2\n\njulia> fits_movabs_hdu(f, 1) # move to the primary HDU\n:image_hdu\n\njulia> fits_get_hdu_num(f)\n1\n\njulia> fits_movabs_hdu(f, 2) # move to the binary table HDU\n:binary_table\n\njulia> fits_get_hdu_num(f)\n2\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"hdu/#CFITSIO.fits_get_hdu_type","page":"HDU","title":"CFITSIO.fits_get_hdu_type","text":"fits_get_hdu_type(f::FITSFile)\n\nReturn the type of the current HDU as a symbol. Possible symbols are: :image_hdu, :ascii_table, or :binary_table. If the HDU is not one of these types, it returns :unknown.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_get_hdu_type(f)\n:image_hdu\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\"), (\"col2\", \"1E\")])\n\njulia> fits_get_hdu_type(f)\n:binary_table\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"hdu/#CFITSIO.fits_movabs_hdu","page":"HDU","title":"CFITSIO.fits_movabs_hdu","text":"fits_movabs_hdu(f::FITSFile, hduNum::Integer)\n\nChange the current HDU to the value specified by hduNum, and return a symbol describing the type of the HDU.\n\nPossible symbols are: image_hdu, ascii_table, or binary_table. The value of hduNum must range between 1 and the value returned by fits_get_num_hdus.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\"), (\"col2\", \"1E\")])\n\njulia> fits_movabs_hdu(f, 2)\n:binary_table\n\njulia> fits_movabs_hdu(f, 1)\n:image_hdu\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"hdu/#CFITSIO.fits_movrel_hdu","page":"HDU","title":"CFITSIO.fits_movrel_hdu","text":"fits_movrel_hdu(f::FITSFile, hduNum::Integer)\n\nChange the current HDU by moving forward or backward by hduNum HDUs (positive means forward), and return the same as fits_movabs_hdu.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\"), (\"col2\", \"1E\")])\n\njulia> fits_movabs_hdu(f, 2)\n:binary_table\n\njulia> fits_movrel_hdu(f, -1) # move back to the image HDU\n:image_hdu\n\njulia> fits_movrel_hdu(f, 1) # move forward to the binary table HDU\n:binary_table\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"hdu/#CFITSIO.fits_movnam_hdu","page":"HDU","title":"CFITSIO.fits_movnam_hdu","text":"fits_movnam_hdu(f::FITSFile, extname::String, extver::Integer=0,\n                hdu_type_int::Integer=-1)\n\nChange the current HDU by moving to the (first) HDU which has the specified extension type and EXTNAME and EXTVER keyword values (or HDUNAME and HDUVER keywords).\n\nIf extver is 0 (the default) then the EXTVER keyword is ignored and the first HDU with a matching EXTNAME (or HDUNAME) keyword will be found. If hdu_type_int is -1 (the default) only the extname and extver values will be used to locate the correct extension. If no matching HDU is found in the file, the current HDU will remain unchanged.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_write_key(f, \"EXTNAME\", \"MyImage\", \"Name of the Image\")\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\"), (\"col2\", \"1E\")], \"MyTable\")\n\njulia> fits_movnam_hdu(f, \"MyImage\")\n\njulia> fits_get_hdu_type(f), fits_get_hdu_num(f)\n(:image_hdu, 1)\n\njulia> fits_movnam_hdu(f, \"MyTable\")\n\njulia> fits_get_hdu_type(f), fits_get_hdu_num(f)\n(:binary_table, 2)\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"hdu/#CFITSIO.fits_copy_file","page":"HDU","title":"CFITSIO.fits_copy_file","text":"fits_copy_file(fin::FITSFile, fout::FITSFile, previous::Bool, current::Bool, following::Bool)\n\nCopy all or a part of the HDUs from the input file fin, and append them to the output file fout. The flags previous, current and following specify which HDUs are to be copied.\n\nIf previous is true, all the HDUs prior to the current input HDU are copied.\nIf current is true, the current input HDU is copied.\nIf following is true, all the HDUs following the current input HDU are copied.\n\nThese flags may be combined, so if all are set to true then all the HDUs are copied from fin to fout.\n\nOn exit, the input is unchanged, and the last HDU in the output is set as the current HDU.\n\nExample\n\njulia> fname_in = joinpath(mktempdir(), \"test_in.fits\");\n\njulia> fname_out = joinpath(mktempdir(), \"test_out.fits\");\n\njulia> fin = fits_create_file(fname_in);\n\njulia> fits_create_empty_img(fin);\n\njulia> fits_write_key(fin, \"KEY1\", 1, \"First keyword\");\n\njulia> fits_create_binary_tbl(fin, 0, [(\"col1\", \"1J\"), (\"col2\", \"1E\")], \"MyTable\");\n\njulia> fout = fits_create_file(fname_out);\n\njulia> fits_copy_file(fin, fout, true, true, true);\n\njulia> fits_get_hdu_num(fout)\n2\n\njulia> fits_get_hdu_type(fout)\n:binary_table\n\njulia> fits_movabs_hdu(fout, 1) # move to the primary HDU\n:image_hdu\n\njulia> fits_read_key_str(fout, \"NAXIS\")\n(\"0\", \"number of data axes\")\n\njulia> fits_read_key_str(fout, \"KEY1\")\n(\"1\", \"First keyword\")\n\njulia> foreach(close, (fin, fout));\n\n\n\n\n\n","category":"function"},{"location":"hdu/#CFITSIO.fits_copy_hdu","page":"HDU","title":"CFITSIO.fits_copy_hdu","text":"fits_copy_hdu(fin::FITSFile, fout::FITSFile, morekeys::Integer = 0)\n\nCopy the current HDU from the input file fin and append it to the output file fout. Space may be reserved for morekeys additional keywords in the output header.\n\nExample\n\njulia> fname_in = joinpath(mktempdir(), \"test_in.fits\");\n\njulia> fname_out = joinpath(mktempdir(), \"test_out.fits\");\n\njulia> fin = fits_create_file(fname_in);\n\njulia> fits_create_empty_img(fin)\n\njulia> fits_write_key(fin, \"KEY1\", 1, \"First keyword\")\n\njulia> fout = fits_create_file(fname_out);\n\njulia> fits_copy_hdu(fin, fout)\n\njulia> fits_get_hdu_num(fout)\n1\n\njulia> fits_get_hdu_type(fout)\n:image_hdu\n\njulia> fits_read_key_str(fout, \"NAXIS\")\n(\"0\", \"number of data axes\")\n\njulia> fits_read_key_str(fout, \"KEY1\")\n(\"1\", \"First keyword\")\n\njulia> foreach(close, (fin, fout))\n\n\n\n\n\n","category":"function"},{"location":"hdu/#CFITSIO.fits_copy_data","page":"HDU","title":"CFITSIO.fits_copy_data","text":"fits_copy_data(fin::FITSFile, fout::FITSFile)\n\nCopy the data (not the header) from the current HDU in fin to the current HDU in fout. This will overwrite pre-existing data in the output HDU.\n\nExample\n\njulia> fname_in = joinpath(mktempdir(), \"test_in.fits\");\n\njulia> fname_out = joinpath(mktempdir(), \"test_out.fits\");\n\njulia> fin = fits_create_file(fname_in);\n\njulia> fits_create_img(fin, Int64, (2, 2))\n\njulia> fits_write_pix(fin, [1, 1], 4, [1, 2, 3, 4])\n\njulia> fits_write_key(fin, \"KEY1\", 1, \"First keyword\")\n\njulia> fout = fits_create_file(fname_out);\n\njulia> fits_create_img(fout, Int64, (2, 2));\n\njulia> fits_copy_data(fin, fout)\n\njulia> B = zeros(Int64, 2, 2);\n\njulia> fits_read_pix(fout, [1, 1], 4, B);\n\njulia> B\n2×2 Matrix{Int64}:\n 1  3\n 2  4\n\njulia> fits_read_key_str(fout, \"KEY1\") # the header isn't copied\nERROR: CFITSIO has encountered an error. Error code 202: keyword not found in header\n[...]\n\njulia> foreach(close, (fin, fout))\n\n\n\n\n\n","category":"function"},{"location":"hdu/#CFITSIO.fits_delete_hdu","page":"HDU","title":"CFITSIO.fits_delete_hdu","text":"fits_delete_hdu(f::FITSFile)\n\nDelete the HDU from the FITS file and shift the following HDUs forward. If f is the primary HDU in the file then it'll be replaced by a null primary HDU with no data and minimal header information.\n\nReturn a symbol to indicate the type of the new current HDU. Possible symbols are: :image_hdu, :ascii_table, or :binary_table. The value of hduNum must range between 1 and the value returned by fits_get_num_hdus.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\"), (\"col2\", \"1E\")])\n\njulia> fits_get_hdu_num(f)\n2\n\njulia> fits_get_hdu_type(f)\n:binary_table\n\njulia> fits_delete_hdu(f) # delete the binary table HDU\n:image_hdu\n\njulia> fits_get_hdu_num(f)\n1\n\njulia> fits_get_hdu_type(f)\n:image_hdu\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"hdu/#CFITSIO.fits_write_chksum","page":"HDU","title":"CFITSIO.fits_write_chksum","text":"fits_write_chksum(f::FITSFile)\n\nCompute and write the DATASUM and CHECKSUM keyword values for the CHDU into the current header. If the keywords already exist, their values will be updated only if necessary (i.e., if the file has been modified since the original keyword values were computed).\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\", \"units\")]);\n\njulia> fits_write_col(f, 1, 1, 1, [1, 2, 3]);\n\njulia> fits_write_chksum(f); # write the checksum keywords\n\njulia> fits_read_key_str(f, \"DATASUM\", comment = nothing)\n(\"6\", nothing)\n\njulia> fits_read_key_str(f, \"CHECKSUM\", comment = nothing)\n(\"9TbBESbA9SbACSbA\", nothing)\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"hdu/#CFITSIO.fits_update_chksum","page":"HDU","title":"CFITSIO.fits_update_chksum","text":"fits_update_chksum(f::FITSFile)\n\nUpdate the CHECKSUM keyword value in the CHDU, assuming that the DATASUM keyword exists and already has the correct value.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\", \"units\")]);\n\njulia> fits_write_col(f, 1, 1, 1, [1, 2, 3]);\n\njulia> fits_write_chksum(f); # write the checksum keywords\n\njulia> fits_read_key_str(f, \"DATASUM\", comment = nothing)\n(\"6\", nothing)\n\njulia> fits_read_key_str(f, \"CHECKSUM\", comment = nothing)\n(\"5UdCATZB7TdBATZB\", nothing)\n\njulia> fits_write_key(f, \"TEST\", \"test\", \"test comment\"); # modify the header\n\njulia> fits_update_chksum(f); # update the CHECKSUM keyword\n\njulia> fits_read_key_str(f, \"CHECKSUM\", comment = nothing)\n(\"Y3amY0UjY0ZjY0Zj\", nothing)\n\njulia> close(f)\n\n\n\n\n\n","category":"function"},{"location":"hdu/#CFITSIO.fits_verify_chksum","page":"HDU","title":"CFITSIO.fits_verify_chksum","text":"fits_verify_chksum(f::FITSFile)\n\nVerify if the checksum of the data and the HDU matches the stored values. Returns a tuple of CFITSIO.ChecksumVerificationStatus values, indicating the status of the data and HDU checksums. For either value, a status of MISSING indicates that the corresponding keyword is not present, while a status of MISMATCH indicates that the keyword is present but the value is incorrect. Finally, a value of VERIFIED indicates that the checksum was validated successfully.\n\nExample\n\njulia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\", \"units\")]);\n\njulia> fits_write_col(f, 1, 1, 1, [1, 2, 3]);\n\njulia> fits_verify_chksum(f) # no checksum keywords present\n(CFITSIO.MISSING, CFITSIO.MISSING)\n\njulia> fits_write_chksum(f); # write the checksum keywords\n\njulia> fits_verify_chksum(f)\n(CFITSIO.VERIFIED, CFITSIO.VERIFIED)\n\njulia> close(f)\n\n\n\n\n\n","category":"function"}]
}
