{
    "docs": [
        {
            "location": "/", 
            "text": "This is a julia wrapper for \nCALCEPH\n a C library for reading planetary ephemeris files, such \nINPOPxx\n, JPL DExxx and SPICE ephemeris files.\n\n\nCALCEPH\n C library is developped by \nIMCCE\n.\n\n\n\n\nQuick start\n\n\nIn the Julia interpreter, run:\n\n\nPkg.add(\nCALCEPH\n)\nusing CALCEPH\n\n# ephemeris kernels can be downloaded from many different sources\ndownload(\nftp://ftp.imcce.fr/pub/ephem/planets/inpop13c/inpop13c_TDB_m100_p100_tt.dat\n,\nplanets.dat\n)\n# WARNING this file is huge (Jupiter Moons ephemeris)\n# download(\nhttps://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/satellites/jup310.bsp\n,\njupiter_system.bsp\n)\n\n# create an ephemeris context\neph = Ephem(\nplanets.dat\n)\n# from multiple files\n# eph = Ephem([\nplanets.dat\n,\njupiter_system.bsp\n])\n\n# prefetch ephemeris files data to main memory for faster access\nprefetch(eph)\n\n# retrieve constants from ephemeris as a dictionary\ncon = constants(eph)\n# list the constants\nkeys(con)\n# get the sun J2\nJ2sun = con[:J2SUN]\n\n# retrieve the position, velocity and acceleration of Earth (geocenter) relative\n# to the Earth-Moon system barycenter in kilometers, kilometers per second and\n# kilometers per second square at JD= 2451624.5 TDB timescale\n# for best accuracy the first time argument should be the integer part and the\n# delta the fractional part\n# when using NAIF identification numbers, useNaifId has to be added to\n# the units argument.\npva=compute(eph,2451624.0,0.5,naifId.id[:earth],naifId.id[:emb],\n                        useNaifId+unitKM+unitSec,2)\nposition=pva[1:3]\nvelocity=pva[4:6]\nacceleration=pva[7:end]\n\n# what is the NAIF identification number for Deimos\nid_deimos = naifId.id[:deimos]\n\n# what does NAIF ID 0 correspond to?\nnames_0 = naifId.names[0]\n\n\n\n\n\n\nWhy use CALCEPH?\n\n\nCALCEPH functionality is also provided by \nNAIF SPICE Toolkit\n. However CALCEPH has several advantages over the SPICE toolkit:\n\n\n\n\nIt is faster at computing ephemeris data.\n\n\nIt can handle multiple ephemeris contexts whereas the SPICE toolkit cannot.\n\n\nIt is thread safe (if using one context per thread) whereas the SPICE toolkit is not.\n\n\nIt can compute higher order derivatives (acceleration and jerk) approximation using differentiation of the interpolation polynomials.\n\n\nIts ephemeris computation interface expects the time separated in two double precision floating point numbers (the SPICE toolkit interface only use one double precision floating point number to specify an epoch). This can be used to achieve higher precision in timetag (this can have a significant impact when modeling Doppler observations from a deep space probe).\n\n\nIt is distributed as a single cross platform source making it easy to integrate in other projects whereas the SPICE toolkit is distributed one source per platform.\n\n\n\n\nBut CALCEPH does not support all functions of the SPICE toolkit. If you need more functionalities \nSPICE.jl\n is a Julia wrapper for the SPICE toolkit.", 
            "title": "Quick start"
        }, 
        {
            "location": "/#quick-start", 
            "text": "In the Julia interpreter, run:  Pkg.add( CALCEPH )\nusing CALCEPH\n\n# ephemeris kernels can be downloaded from many different sources\ndownload( ftp://ftp.imcce.fr/pub/ephem/planets/inpop13c/inpop13c_TDB_m100_p100_tt.dat , planets.dat )\n# WARNING this file is huge (Jupiter Moons ephemeris)\n# download( https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/satellites/jup310.bsp , jupiter_system.bsp )\n\n# create an ephemeris context\neph = Ephem( planets.dat )\n# from multiple files\n# eph = Ephem([ planets.dat , jupiter_system.bsp ])\n\n# prefetch ephemeris files data to main memory for faster access\nprefetch(eph)\n\n# retrieve constants from ephemeris as a dictionary\ncon = constants(eph)\n# list the constants\nkeys(con)\n# get the sun J2\nJ2sun = con[:J2SUN]\n\n# retrieve the position, velocity and acceleration of Earth (geocenter) relative\n# to the Earth-Moon system barycenter in kilometers, kilometers per second and\n# kilometers per second square at JD= 2451624.5 TDB timescale\n# for best accuracy the first time argument should be the integer part and the\n# delta the fractional part\n# when using NAIF identification numbers, useNaifId has to be added to\n# the units argument.\npva=compute(eph,2451624.0,0.5,naifId.id[:earth],naifId.id[:emb],\n                        useNaifId+unitKM+unitSec,2)\nposition=pva[1:3]\nvelocity=pva[4:6]\nacceleration=pva[7:end]\n\n# what is the NAIF identification number for Deimos\nid_deimos = naifId.id[:deimos]\n\n# what does NAIF ID 0 correspond to?\nnames_0 = naifId.names[0]", 
            "title": "Quick start"
        }, 
        {
            "location": "/#why-use-calceph", 
            "text": "CALCEPH functionality is also provided by  NAIF SPICE Toolkit . However CALCEPH has several advantages over the SPICE toolkit:   It is faster at computing ephemeris data.  It can handle multiple ephemeris contexts whereas the SPICE toolkit cannot.  It is thread safe (if using one context per thread) whereas the SPICE toolkit is not.  It can compute higher order derivatives (acceleration and jerk) approximation using differentiation of the interpolation polynomials.  Its ephemeris computation interface expects the time separated in two double precision floating point numbers (the SPICE toolkit interface only use one double precision floating point number to specify an epoch). This can be used to achieve higher precision in timetag (this can have a significant impact when modeling Doppler observations from a deep space probe).  It is distributed as a single cross platform source making it easy to integrate in other projects whereas the SPICE toolkit is distributed one source per platform.   But CALCEPH does not support all functions of the SPICE toolkit. If you need more functionalities  SPICE.jl  is a Julia wrapper for the SPICE toolkit.", 
            "title": "Why use CALCEPH?"
        }, 
        {
            "location": "/install/", 
            "text": "Retrieving and installing CALCEPH.jl\n\n\nIn the Julia interpreter, run:\n\n\nPkg.add(\nCALCEPH\n)\n\n\n\n\nTo start using it:\n\n\nusing CALCEPH", 
            "title": "Install"
        }, 
        {
            "location": "/install/#retrieving-and-installing-calcephjl", 
            "text": "In the Julia interpreter, run:  Pkg.add( CALCEPH )  To start using it:  using CALCEPH", 
            "title": "Retrieving and installing CALCEPH.jl"
        }, 
        {
            "location": "/context/", 
            "text": "#\n\n\nCALCEPH.Ephem\n \n \nType\n.\n\n\nEphem\n\n\n\n\nEphemeris descriptor. Create with:\n\n\neph = Ephem(filename)\neph = Ephem([filename1,filename2...])\n\n\n\n\nThe ephemeris descriptor will be used to access the ephemeris and related   data stored in the specified files.\n\n\nBecause, Julia GC is lazy, you may want to free the memory managed by eph   before you get rid of the reference to eph with:\n\n\nfinalize(eph)\n\n\n\n\nor after by forcing the GC to run:\n\n\ngc()\n\n\n\n\nsource\n\n\n#\n\n\nCALCEPH.prefetch\n \n \nFunction\n.\n\n\nprefetch(eph)\n\n\n\n\nThis function prefetches to the main memory all files associated to the ephemeris descriptor eph.\n\n\nsource", 
            "title": "Ephemeris context"
        }, 
        {
            "location": "/units/", 
            "text": "#\n\n\nCALCEPH.unitAU\n \n \nConstant\n.\n\n\nunitAU\n\n\n\n\nAstronomical unit: distance unit\n\n\nsource\n\n\n#\n\n\nCALCEPH.unitKM\n \n \nConstant\n.\n\n\nunitKM\n\n\n\n\nkilometer: distance unit\n\n\nsource\n\n\n#\n\n\nCALCEPH.unitDay\n \n \nConstant\n.\n\n\nunitDay\n\n\n\n\nday: time unit\n\n\nsource\n\n\n#\n\n\nCALCEPH.unitSec\n \n \nConstant\n.\n\n\nunitSec\n\n\n\n\nsecond: time unit\n\n\nsource\n\n\n#\n\n\nCALCEPH.unitRad\n \n \nConstant\n.\n\n\nunitRad\n\n\n\n\nradian: angle unit\n\n\nsource\n\n\n#\n\n\nCALCEPH.useNaifId\n \n \nConstant\n.\n\n\nuseNaifId\n\n\n\n\nhas to be added to the unit argument when using NAIF integer codes for identification of center and target\n\n\nsource", 
            "title": "Units"
        }, 
        {
            "location": "/ids/", 
            "text": "#\n\n\nCALCEPH.BodyId\n \n \nType\n.\n\n\nBodyId\n\n\n\n\nBody identifiers.\n\n\nsource\n\n\n#\n\n\nCALCEPH.add!\n \n \nFunction\n.\n\n\nadd!(bid,name,id)\n\n\n\n\nAdd a new mapping name-\nid into BodyId instance bid.\n\n\nExample:\n\n\n    using CALCEPH\n    bid=CALCEPH.BodyId()\n    CALCEPH.add!(bid,:tatooine,1000001)\n    CALCEPH.add!(bid,:dagobah,1000002)\n    CALCEPH.add!(bid,:endor,1000003)\n    CALCEPH.add!(bid,:deathstar,1000004)\n    CALCEPH.add!(bid,:endor_deathstar_system_barycenter,1000005)\n    CALCEPH.add!(bid,:edsb,1000005)\n\n# output\n\n\n\n\nsource\n\n\n#\n\n\nCALCEPH.loadData!\n \n \nFunction\n.\n\n\nloadData!(bid,filename)\n\n\n\n\nLoad mapping (body name,body ID) from file into BodyId instance bid.   Names from the file are converted to lower case and have spaces replaced by   underscores before being converted to symbols/interned strings.\n\n\nExample file \nhttps://github.com/bgodard/CALCEPH.jl/blob/master/data/NaifIds.txt\n\n\nsource\n\n\n#\n\n\nCALCEPH.naifId\n \n \nConstant\n.\n\n\nnaifId\n\n\n\n\nNAIF identification numbers\n\n\nExamples:\n\n\njulia\n using CALCEPH\n\njulia\n naifId.id[:sun]\n10\n\njulia\n naifId.id[:mars]\n499\n\njulia\n naifId.names[0]\nSet(Symbol[:ssb, :solar_system_barycenter])\n\n\n\n\nsource", 
            "title": "Identifiers"
        }, 
        {
            "location": "/compute/", 
            "text": "#\n\n\nCALCEPH.compute\n \n \nFunction\n.\n\n\ncompute(eph,jd0,time,target,center)\n\n\n\n\nCompute position and velocity of target with respect to center at epoch jd0+time. This method does not support the NAIF numbering scheme. To get the best precision for the interpolation, the time is splitted in two floating-point numbers. The argument jd0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and jd0, the desired time, if you don't take care about precision.\n\n\nThis method does not support the NAIF body identification scheme.\n\n\nOutput units are:\n\n\n\n\nAU and AU/day for position and velocity\n\n\nrad and rad/day for librations\n\n\nsecond and unitless for time ephemeris and time ephemeris rate\n\n\n\n\nArguments\n\n\n\n\njd0::Float64\n: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)\n\n\ntime::Float64\n: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)\n\n\ntarget::Int\n: The body or reference point whose coordinates are required.\n\n\ncenter::Int\n: The origin of the coordinate system.\n\n\n\n\nThe possible values for target and center are :\n\n\n\n\n1 : Mercury Barycenter\n\n\n2 : Venus Barycenter\n\n\n3 : Earth\n\n\n4 : Mars Barycenter\n\n\n5 : Jupiter Barycenter\n\n\n6 : Saturn Barycenter\n\n\n7 : Uranus Barycenter\n\n\n8 : Neptune Barycenter\n\n\n9 : Pluto Barycenter\n\n\n10    : Moon\n\n\n11    : Sun\n\n\n12    : Solar Sytem barycenter\n\n\n13    : Earth-moon barycenter\n\n\n15    : Librations\n\n\n16    : TT-TDB\n\n\n17    : TCG-TCB\n\n\nasteroid number + CALCEPH_ASTEROID    : asteroid\n\n\n\n\nsource\n\n\ncompute(eph,jd0,time,target,center,unit)\n\n\n\n\nCompute position and velocity of target with respect to center at epoch jd0+time. To get the best precision for the interpolation, the time is splitted in two floating-point numbers. The argument jd0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and jd0, the desired time, if you don't take care about precision.\n\n\nArguments\n\n\n\n\njd0::Float64\n: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)\n\n\ntime::Float64\n: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)\n\n\ntarget::Int\n: The body or reference point whose coordinates are required. The numbering system depends on the parameter unit.\n\n\ncenter::Int\n: The origin of the coordinate system. The numbering system depends on the parameter unit.\n\n\nunit::Int\n : The units of the result. This integer is a sum of some unit constants (unit*) and/or the constant useNaifId. If the unit contains useNaifId, the NAIF identification numbering system is used for the target and the center. If the unit does not contain useNaifId, the old number system is used for the target and the center.\n\n\n\n\nsource\n\n\ncompute(eph,jd0,time,target,center,unit,order)\n\n\n\n\nCompute position and derivatives up to order of target with respect to center at epoch jd0+time. To get the best precision for the interpolation, the time is splitted in two floating-point numbers. The argument jd0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and jd0, the desired time, if you don't take care about precision.\n\n\nArguments\n\n\n\n\njd0::Float64\n: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)\n\n\ntime::Float64\n: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)\n\n\ntarget::Int\n: The body or reference point whose coordinates are required. The numbering system depends on the parameter unit.\n\n\ncenter::Int\n: The origin of the coordinate system. The numbering system depends on the parameter unit.\n\n\nunit::Int\n : The units of the result. This integer is a sum of some unit constants (unit*) and/or the constant useNaifId. If the unit contains useNaifId, the NAIF identification numbering system is used for the target and the center. If the unit does not contain useNaifId, the old number system is used for the target and the center.\n\n\n\n\norder::Int\n : The order of derivatives\n\n\n\n\n0: only the position is computed.\n\n\n1: only the position and velocity are computed.\n\n\n2: only the position, velocity and acceleration are computed.\n\n\n3: the position, velocity and acceleration and jerk are computed.\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nCALCEPH.orient\n \n \nFunction\n.\n\n\norient(eph,jd0,time,target,unit)\n\n\n\n\nCompute Euler angles and first derivative for the orientation of target at epoch jd0+time. To get the best precision for the interpolation, the time is splitted in two floating-point numbers. The argument jd0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and jd0, the desired time, if you don't take care about precision.\n\n\nArguments\n\n\n\n\njd0::Float64\n: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)\n\n\ntime::Float64\n: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)\n\n\ntarget::Int\n: The body whose orientation is required. The numbering system depends on the parameter unit.\n\n\nunit::Int\n : The units of the result. This integer is a sum of some unit constants (unit*) and/or the constant useNaifId. If the unit contains useNaifId, the NAIF identification numbering system is used for the target and the center. If the unit does not contain useNaifId, the old number system is used for the target and the center (see the list in the documentation of function compute). The angles are expressed in radians if unit contains unitRad.\n\n\n\n\nsource\n\n\norient(eph,jd0,time,target,unit,order)\n\n\n\n\nCompute Euler angles and derivatives up to order for the orientation of target at epoch jd0+time. To get the best precision for the interpolation, the time is splitted in two floating-point numbers. The argument jd0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and jd0, the desired time, if you don't take care about precision.\n\n\nArguments\n\n\n\n\njd0::Float64\n: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)\n\n\ntime::Float64\n: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)\n\n\ntarget::Int\n: The body whose orientation is required. The numbering system depends on the parameter unit.\n\n\nunit::Int\n : The units of the result. This integer is a sum of some unit constants (unit*) and/or the constant useNaifId. If the unit contains useNaifId, the NAIF identification numbering system is used for the target and the center. If the unit does not contain useNaifId, the old number system is used for the target and the center (see the list in the documentation of function compute).\n\n\n\n\norder::Int\n : The order of derivatives\n\n\n\n\n0: only the angles are computed.\n\n\n1: only the angles and 1st derivatives are computed.\n\n\n2: only the angles, the 1st derivatives and 2nd derivatives are computed.\n\n\n3: the angles, the 1st derivatives, 2nd derivatives and 3rd derivatives are computed.\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nCALCEPH.rotAngMom\n \n \nFunction\n.\n\n\nrotAngMom(eph,jd0,time,target,unit)\n\n\n\n\nCompute angular momentum due to rotation and first derivative of target at epoch jd0+time. To get the best precision for the interpolation, the time is splitted in two floating-point numbers. The argument jd0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and jd0, the desired time, if you don't take care about precision.\n\n\nArguments\n\n\n\n\njd0::Float64\n: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)\n\n\ntime::Float64\n: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)\n\n\ntarget::Int\n: The body whose angular momentum is required. The numbering system depends on the parameter unit.\n\n\nunit::Int\n : The units of the result. This integer is a sum of some unit constants (unit*) and/or the constant useNaifId. If the unit contains useNaifId, the NAIF identification numbering system is used for the target and the center. If the unit does not contain useNaifId, the old number system is used for the target and the center (see the list in the documentation of function compute). The angles are expressed in radians if unit contains unitRad.\n\n\n\n\nsource\n\n\nrotAngMom(eph,jd0,time,target,unit,order)\n\n\n\n\nCompute angular momentum due to rotation and derivatives up to order of target at epoch jd0+time. To get the best precision for the interpolation, the time is splitted in two floating-point numbers. The argument jd0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and jd0, the desired time, if you don't take care about precision.\n\n\nArguments\n\n\n\n\njd0::Float64\n: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)\n\n\ntime::Float64\n: jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB)\n\n\ntarget::Int\n: The body whose angular momentum is required. The numbering system depends on the parameter unit.\n\n\nunit::Int\n : The units of the result. This integer is a sum of some unit constants (unit*) and/or the constant useNaifId. If the unit contains useNaifId, the NAIF identification numbering system is used for the target and the center. If the unit does not contain useNaifId, the old number system is used for the target and the center (see the list in the documentation of function compute).\n\n\n\n\norder::Int\n : The order of derivatives\n\n\n\n\n0: only the angles are computed.\n\n\n1: only the angles and 1st derivatives are computed.\n\n\n2: only the angles, the 1st derivatives and 2nd derivatives are computed.\n\n\n3: the angles, the 1st derivatives, 2nd derivatives and 3rd derivatives are computed.\n\n\n\n\n\n\n\n\nsource", 
            "title": "Ephemeris computation"
        }, 
        {
            "location": "/constants/", 
            "text": "#\n\n\nCALCEPH.constants\n \n \nFunction\n.\n\n\nconstants(eph)\n\n\nRetrieve the constants stored in the ephemeris associated to handle eph as a dictionary\n\n\nsource", 
            "title": "Ephemeris constants"
        }, 
        {
            "location": "/introspection/", 
            "text": "#\n\n\nCALCEPH.timeScale\n \n \nFunction\n.\n\n\ntimeScale(eph)\n\n\n\n\nRetrieve the timescale associated with ephemeris handler eph    Returns 1 for TDB and 2 for TCB.\n\n\nsource\n\n\n#\n\n\nCALCEPH.PositionRecord\n \n \nType\n.\n\n\nPositionRecord\n\nstores position record metadata.\n\n\n\n\nsource\n\n\n#\n\n\nCALCEPH.positionRecords\n \n \nFunction\n.\n\n\npositionRecords(eph)\n\n\n\n\nRetrieve position records metadata in ephemeris associated to    handler eph .\n\n\nsource\n\n\n#\n\n\nCALCEPH.OrientationRecord\n \n \nType\n.\n\n\nOrientationRecord\n\nstores orientation record metadata.\n\n\n\n\nsource\n\n\n#\n\n\nCALCEPH.orientationRecords\n \n \nFunction\n.\n\n\norientationRecords(eph)\n\n\n\n\nRetrieve orientation records metadata in ephemeris associated to    handler eph .\n\n\nsource", 
            "title": "Introspection"
        }, 
        {
            "location": "/utilities/", 
            "text": "#\n\n\nCALCEPH.fivePointStencil\n \n \nFunction\n.\n\n\nfivePointStencil(f,x,n::Integer,h)\n\n\n\n\nEvaluates function f and its derivatives up to order n \u2208 [0,4] at x: $f(x),f'(x),...,f^{(n)}(x)$ The result is an array of length n+1. Derivatives are numerically computed using the 5-point stencil method with h\u22600 being the grid spacing: \nhttps://en.wikipedia.org/wiki/Five-point_stencil\n\n\nsource", 
            "title": "Utilities"
        }
    ]
}