var documenterSearchIndex = {"docs":
[{"location":"api/#API/Reference","page":"API/Reference","title":"API/Reference","text":"","category":"section"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"using PSFModels\nusing Plots","category":"page"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"","category":"page"},{"location":"api/#Gaussian","page":"API/Reference","title":"Gaussian","text":"","category":"section"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"gaussian\nnormal","category":"page"},{"location":"api/#PSFModels.gaussian","page":"API/Reference","title":"PSFModels.gaussian","text":"gaussian([T=Float64], point; x, y, fwhm, amp=1, theta=0)\ngaussian([T=Float64], px, py; x, y, fwhm, amp=1, theta=0)\n\nAn unnormalized bivariate Gaussian distribution. The position can be specified in (x, y) coordinates as a Tuple, AbstractVector, or as separate arguments. If theta is given, the PSF will be rotated by theta degrees counter-clockwise from the x-axis.\n\nThe fwhm can be a scalar (isotropic) or a vector/tuple (diagonal). Keep in mind that theta has no effect for isotropic distributions and is degenerate with the fwhm parameters (i.e., theta=90 is the same as reversing the fwhm tuple)\n\nFunctional form\n\nf(x | x̂, FWHM) = exp[-4ln(2) * ||x - x̂|| / FWHM^2]\n\nwhere x̂ and x are position vectors (indices) ||⋅|| represents the square-distance, and FWHM is the full width at half-maximum. If FWHM is a scalar, the Gaussian distribution will be isotropic. If FWHM is a vector or tuple, the weighting is applied along each axis (diagonal).\n\n\n\n\n\n","category":"function"},{"location":"api/#PSFModels.normal","page":"API/Reference","title":"PSFModels.normal","text":"normal\n\nAn alias for gaussian\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"gauss = gaussian(x=0, y=0, fwhm=10)\npsfplot(gauss, -50:50, -50:50; title=\"gaussian(fwhm=10)\",\n        colorbar_scale=:log10, clims=(1e-5, 1))","category":"page"},{"location":"api/#Airy-Disk","page":"API/Reference","title":"Airy Disk","text":"","category":"section"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"airydisk","category":"page"},{"location":"api/#PSFModels.airydisk","page":"API/Reference","title":"PSFModels.airydisk","text":"airydisk([T=Float64], point; x, y, fwhm, ratio=0, amp=1, theta=0)\nairydisk([T=Float64], px, py; x, y, fwhm, ratio=0, amp=1, theta=0)\n\nAn unnormalized Airy disk. The position can be specified in (x, y) coordinates as a Tuple, AbstractVector, or as separate arguments. If theta is given, the PSF will be rotated by theta degrees counter-clockwise from the x-axis.\n\nThe fwhm can be a scalar (isotropic) or a vector/tuple (diagonal). Keep in mind that theta has no effect for isotropic distributions and is degenerate with the fwhm parameters (i.e., theta=90 is the same as reversing the fwhm tuple)\n\nIf ratio is supplied, this will be the Airy pattern for a centrally-obscured aperture (e.g., a Newtonian telescope). This has a slightly expanded functional form, and in general the central Airy disk will be smaller and the first Airy ring will be brighter.\n\nFunctional form\n\nThe Airy disk is a distribution over the radius r (the square-Euclidean distance)\n\nf(x | x̂, FWHM) = [ 2J₁(q) / q ]^2\n\nwhere J₁ is the first-order Bessel function of the first kind and\n\nq ≈ π * r * D/ λ ≈ π * r / (0.973 * FWHM)\n\nIf user a non-zero central obscuration via ratio, the functional form becomes\n\nf(x | x̂, FWHM, ϵ) = [ 2J₁(q) / q - 2ϵJ₁(ϵq) / q ]^2 / (1 - ϵ^2)^2\n\nwhere ϵ is the ratio (0 ≤ ϵ < 1).\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"airy = airydisk(x=0, y=0, fwhm=10)\npsfplot(airy, -50:50, -50:50; title=\"airydisk(fwhm=10)\",\n        colorbar_scale=:log10, clims=(1e-5, 1))","category":"page"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"airy_obscured = airydisk(x=0, y=0, fwhm=10, ratio=0.3)\npsfplot(airy_obscured, -50:50, -50:50; title=\"airydisk(fwhm=10, ratio=0.3)\",\n        colorbar_scale=:log10, clims=(1e-5, 1))","category":"page"},{"location":"api/#Moffat","page":"API/Reference","title":"Moffat","text":"","category":"section"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"moffat","category":"page"},{"location":"api/#PSFModels.moffat","page":"API/Reference","title":"PSFModels.moffat","text":"moffat([T=Float64], point; x, y, fwhm, alpha=1, amp=1, theta=0)\nmoffat([T=Float64], px, py; x, y, fwhm, alpha=1, amp=1, theta=0)\n\nTwo dimensional Moffat model. The position can be specified in (x, y) coordinates as a Tuple, AbstractVector, or as separate arguments. If theta is given, the PSF will be rotated by theta degrees counter-clockwise from the x-axis.\n\nThe fwhm can be a scalar (isotropic) or a vector/tuple (diagonal). Keep in mind that theta has no effect for isotropic distributions and is degenerate with the fwhm parameters (i.e., theta=90 is the same as reversing the fwhm tuple)\n\nFunctional form\n\nf(x | x̂, FWHM, α) = A / (1 + ||x - x̂|| / (FWHM / 2)^2)^α\n\nwhere x̂ and x are position vectors (indices) ||⋅|| represents the square-distance, and FWHM is the full width at half-maximum. If FWHM is a vector or tuple, the weighting is applied along each axis.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"moff = moffat(x=0, y=0, fwhm=10)\npsfplot(moff, -50:50, -50:50; title=\"moffat(fwhm=10)\",\n        colorbar_scale=:log10, clims=(1e-5, 1))","category":"page"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"moff2 = moffat(x=0, y=0, fwhm=10, alpha=2)\npsfplot(moff2, -50:50, -50:50; title=\"moffat(fwhm=10, alpha=2)\",\n        colorbar_scale=:log10, clims=(1e-5, 1))","category":"page"},{"location":"api/#Comparison","page":"API/Reference","title":"Comparison","text":"","category":"section"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"xs = range(0, 50, length=1000)\nplot(\n    xs, [gauss.(xs, 0) airy.(xs, 0) moff.(xs, 0)],\n    label=[\"gaussian\" \"airydisk\" \"moffat\"], yscale=:log10,\n    xlabel=\"x\", ylabel=\"I\", ylims=(1e-5, 1)\n)","category":"page"},{"location":"api/#Fitters","page":"API/Reference","title":"Fitters","text":"","category":"section"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"PSFModels.fit","category":"page"},{"location":"api/#PSFModels.fit","page":"API/Reference","title":"PSFModels.fit","text":"PSFModels.fit(model, params, image, inds=axes(image); func_kwargs=(;), loss=abs2, maxfwhm=Inf, alg=LBFGS(), kwargs...)\n\nFit a PSF model (model) defined by the given params as a named tuple of the parameters to fit and their default values. This model is fit to the data in image at the specified inds (by default, the entire array). To pass extra keyword arguments to the model (i.e., to \"freeze\" a parameter), pass them in a named tuple to func_kwargs. The default loss function is the chi-squared loss, which uses the the square of the difference (i.e., the L2 norm). You can change this to the L1 norm, for example, by passing loss=abs. The maximum FWHM can be set with maxfwhm as a number or tuple.\n\nAdditional keyword arguments, as well as the fitting algorithm alg, are passed to Optim.optimize. By default we use forward-mode auto-differentiation (AD) to derive Jacobians for the LBFGS optimization algorithm. Refer to the Optim.jl documentation for more information.\n\nChoosing parameters\n\nThe fit function is very powerful because it gives you a great amount of flexibility in the way you fit your models. To demonstrate this, let's start with a simple isotropic gaussian.\n\nmodel = gaussian\n# match params to arguments of PSF\nparams = (x=20, y=20, fwhm=3, amp=1)\n\nNote that params can follow any order\n\nparams = (amp=1, x=20, y=20, fwhm=3)\n\nNow, to extend this interface to the bivariate PSF case, where fwhm is two values, all you need to do is use a tuple or vector\n\nparams = (x=20, y=20, fwhm=(3, 3))\n\nand, again, the order does not matter\n\nmodel = moffat\nparams = (alpha=1, x=20, y=20, fwhm=3, amp=10)\n\nFitting a PSF\n\nAfter selecting your model and parameters, fitting data is easy\n\nP = (x=12, y=13, fwhm=13.2, amp=0.1)\npsf = gaussian.(CartesianIndicies(1:25, 1:15); P...)\n\nparams, synthpsf = PSFModels.fit(gaussian, P, psf)\n\nhere params is a named tuple of the best fitting parameters. It will not include any fixed parameters.\n\nsynthpsf is the best-fitting model, for direct comparison with the input data.\n\npsf_fit = synthpsf.(CartesianIndicies(psf))\n\nTo alter parameters without fitting them (i.e., \"freeze\" them) use func_kwargs\n\nP = (x=12, y=13, fwhm=(12.4, 13.2), amp=0.1)\nfunc_kwargs = (alpha=2)\nparams, synthpsf = PSFModels.fit(moffat, P, psf; func_kwargs)\n\n\n\n\n\n","category":"function"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Fitting-a-PSF","page":"Examples","title":"Fitting a PSF","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here is a brief example which shows how to construct a loss function for fitting a PSFModel to some data.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using PSFModels\nusing PSFModels: fit\nusing HCIDatasets: BetaPictoris\nusing Plots\nusing Statistics\n\n# convenience function for plotting\nfunction imshow(data; kwargs...)\n    xlim = extrema(axes(data, 1))\n    ylim = extrema(axes(data, 2))\n    heatmap(transpose(data); xlim=xlim, ylim=ylim,\n            aspect_ratio=1, clims=(1e-5, Inf), kwargs...)\nend\n\n# get a PSF from HCIDatasets.jl;\n# you may be prompted to download the file\npsf = BetaPictoris[:psf]\ninds = CartesianIndices(psf)\n\nimshow(psf)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can fit this data with a variety of models, here showcasing the flexible PSFModels.fit function.","category":"page"},{"location":"examples/#Gaussian","page":"Examples","title":"Gaussian","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Using gaussian","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"params = (x=20, y=20, fwhm=5, amp=0.1)\nP_gauss, mod_gauss = fit(gaussian, params, psf)\npairs(P_gauss)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plot(\n    imshow(psf, title=\"Data\"),\n    imshow(mod_gauss.(inds), title=\"Model\"),\n    cbar=false,\n    ticks=false,\n    xlabel=\"\",\n    ylabel=\"\",\n    layout=2,\n    size=(600, 300)\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"and now using a rotated, elliptical Gaussian","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"params = (x=20, y=20, fwhm=(5, 5), amp=0.1, theta=0)\nP_ellip, mod_ellip = fit(gaussian, params, psf)\npairs(P_ellip)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plot(\n    imshow(psf, title=\"Data\"),\n    imshow(mod_ellip.(inds), title=\"Model\"),\n    cbar=false,\n    ticks=false,\n    xlabel=\"\",\n    ylabel=\"\",\n    layout=2,\n    size=(600, 300)\n)","category":"page"},{"location":"examples/#Airy-disk","page":"Examples","title":"Airy disk","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now with airydisk","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"params = (x=20, y=20, fwhm=5, amp=0.1, ratio=0.3)\nP_airy, mod_airy = fit(airydisk, params, psf)\npairs(P_airy)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plot(\n    imshow(psf, title=\"Data\"),\n    imshow(mod_airy.(inds), title=\"Model\"),\n    cbar=false,\n    ticks=false,\n    xlabel=\"\",\n    ylabel=\"\",\n    layout=2,\n    size=(600, 300)\n)","category":"page"},{"location":"examples/#Moffat","page":"Examples","title":"Moffat","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"And finally, with moffat","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"params = (x=20, y=20, fwhm=(5, 5), amp=0.1, theta=0, alpha=2)\nP_moff, mod_moff = fit(moffat, params, psf)\npairs(P_moff)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plot(\n    imshow(psf, title=\"Data\"),\n    imshow(mod_moff.(inds), title=\"Model\"),\n    cbar=false,\n    ticks=false,\n    xlabel=\"\",\n    ylabel=\"\",\n    layout=2,\n    size=(600, 300)\n)","category":"page"},{"location":"examples/#Changing-optimization-parameters","page":"Examples","title":"Changing optimization parameters","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Any keyword arguments get passed on to Optim.optimize, and you can change the algorithm used with the alg keyword","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# load Optim.jl to use the Newton method\nusing Optim\n\nparams = (x=20, y=20, fwhm=(5, 5), amp=0.1, theta=0, alpha=2)\nP_moff, mod_moff = fit(moffat, params, psf; alg=Newton())\npairs(P_moff)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can also \"freeze\" parameters by creating a named tuple and passing it to func_kwargs","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nparams = (;x=10, y=20, fwhm=(5, 5), amp=0.1)\nfunc_kwargs = (;alpha=2)\nP_moff2, mod_moff2 = fit(moffat, params, psf; func_kwargs)\npairs(P_moff2)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plot(\n    imshow(psf, title=\"Data\"),\n    imshow(mod_moff2.(inds), title=\"Model\"),\n    cbar=false,\n    ticks=false,\n    xlabel=\"\",\n    ylabel=\"\",\n    layout=2,\n    size=(600, 300)\n)","category":"page"},{"location":"bench/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"bench/","page":"Benchmarks","title":"Benchmarks","text":"The benchmarks can be found in the bench/ folder. To run them, first instantiate the environment","category":"page"},{"location":"bench/","page":"Benchmarks","title":"Benchmarks","text":"$ julia --project=bench -e \"using Pkg; Pkg.instantiate()\"","category":"page"},{"location":"bench/","page":"Benchmarks","title":"Benchmarks","text":"then execute the bench/bench.jl file","category":"page"},{"location":"bench/","page":"Benchmarks","title":"Benchmarks","text":"$ julia --project=bench bench/bench.jl","category":"page"},{"location":"bench/","page":"Benchmarks","title":"Benchmarks","text":"System Information","category":"page"},{"location":"bench/","page":"Benchmarks","title":"Benchmarks","text":"Julia Version 1.8.0-DEV.1437\nCommit a0093d2ffb (2022-02-01 00:11 UTC)\nPlatform Info:\n  OS: macOS (arm64-apple-darwin21.2.0)\n  CPU: Apple M1 Max\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-13.0.0 (ORCJIT, cyclone)\nEnvironment:\n  JULIA_NUM_THREADS = 1","category":"page"},{"location":"bench/","page":"Benchmarks","title":"Benchmarks","text":"","category":"page"},{"location":"bench/#Evaluation-benchmark","page":"Benchmarks","title":"Evaluation benchmark","text":"","category":"section"},{"location":"bench/","page":"Benchmarks","title":"Benchmarks","text":"This benchmark tests how long it takes to evaluate a single point in the PSF model. This may seem contrived, but we expect performance to scale directly from this measure: if it takes 1 microsecond to evaluate a single point, it should take ~1 second to evaluate a 1000x1000 image, with speedups potentially from multithreading or SIMD loop evaluation.","category":"page"},{"location":"bench/","page":"Benchmarks","title":"Benchmarks","text":"using CSV\nusing DataFrames\nusing StatsPlots\nbenchdir(args...) = joinpath(\"..\", \"..\" ,\"bench\", args...);","category":"page"},{"location":"bench/","page":"Benchmarks","title":"Benchmarks","text":"table = CSV.read(benchdir(\"evaluation_results.csv\"), DataFrame)","category":"page"},{"location":"bench/","page":"Benchmarks","title":"Benchmarks","text":"@df table groupedbar(:name, [:psfmodels :astropy];\n    ylabel=\"time (s)\", yscale=:log10, leg=:outertopright,\n    label=[\"PSFModels.jl\" \"Astropy\"], size=(500, 300))","category":"page"},{"location":"bench/#Fitting-benchmark","page":"Benchmarks","title":"Fitting benchmark","text":"","category":"section"},{"location":"bench/","page":"Benchmarks","title":"Benchmarks","text":"This benchmark tests how long it takes to fit a PSF Model to a stamp with size (39, 39). In all cases, we use equivalently complex models, the default fitters for PSFModels.jl, and the default LevMarLSQFit fitter for astropy.","category":"page"},{"location":"bench/","page":"Benchmarks","title":"Benchmarks","text":"table = CSV.read(benchdir(\"fitting_results.csv\"), DataFrame)","category":"page"},{"location":"bench/","page":"Benchmarks","title":"Benchmarks","text":"@df table groupedbar(:name, [:psfmodels :astropy];\n    ylabel=\"time (s)\", yscale=:log10, leg=:outertopright,\n    label=[\"PSFModels.jl\" \"Astropy\"], size=(500, 300))","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PSFModels","category":"page"},{"location":"#PSFModels.jl","page":"Home","title":"PSFModels.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: GitHub) (Image: Build Status) (Image: PkgEval) (Image: Coverage) (Image: License)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PSFModels can be added from the Julia package manager","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia>]\n\n(@v1.6) pkg> add PSFModels","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To import the library","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using PSFModels","category":"page"},{"location":"","page":"Home","title":"Home","text":"None of the models are exported to avoid namespace clashes, but it can be verbose to continuously rewrite PSFModels. You can either import names directly","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using PSFModels: gaussian\n\njulia> model = gaussian(x=0, y=0, fwhm=8)","category":"page"},{"location":"","page":"Home","title":"Home","text":"or you can create an alias for PSFModels","category":"page"},{"location":"","page":"Home","title":"Home","text":"# julia version 1.5 or below\nusing PSFModels\nconst M = PSFModels\n# julia version 1.6 or above\nimport PSFModels as M\n\nmodel = M.gaussian(x=0, y=0, fwhm=10)","category":"page"},{"location":"","page":"Home","title":"Home","text":"PSFModels","category":"page"},{"location":"#PSFModels.PSFModels","page":"Home","title":"PSFModels.PSFModels","text":"PSFModels\n\nStatistical models for constructing point-spread functions (PSFs).\n\nModels\n\nThe following models are currently implemented\n\ngaussian/normal\nairydisk\nmoffat\n\nParameters\n\nIn general, the PSFs have a position, a full-width at half-maximum (FWHM) measure, and an amplitude. The position follows a 1-based pixel coordinate system, where (1, 1) represents the center of the bottom left pixel. This matches the indexing style of Julia as well as DS9, IRAF, SourceExtractor, and WCS. The FWHM is a consistent scale parameter for the models. That means a gaussian with a FWHM of 5 will be visually similar to an airydisk with a FWHM of 5. All models support a scalar (isotropic) FWHM and a FWHM for each axis (diagonal), as well as arbitrarily rotating the PSF.\n\nwarning: Pixel-convention\nThe pixel convention adopted here is that the bottom-left pixel center is (1, 1). The column-major memory layout of julia puts the x axis as the rows of a matrix and the y axis as the columns. In other words, the axes unpack likexs, ys = axes(image)\n\nUsage\n\nEvaluating models\n\nDirectly evaluating the functions is the most straightforward way to use this package\n\njulia> gaussian(0, 0; x=0, y=0, fwhm=3)\n1.0\n\njulia> gaussian(BigFloat, 0, 0; x=0, y=0, fwhm=3, amp=0.1)\n0.1000000000000000055511151231257827021181583404541015625\n\nWe also provide \"curried\" versions of the functions, which allow you to specify the parameters and evaluate the PSF later\n\njulia> model = gaussian(x=0, y=0, fwhm=3);\n\njulia> model(0, 0)\n1.0\n\nIf we want to collect the model into a dense matrix, simply iterate over indices\n\njulia> inds = CartesianIndices((-2:2, -2:2));\n\njulia> model.(inds) # broadcasting\n5×5 Matrix{Float64}:\n 0.0850494  0.214311  0.291632  0.214311  0.0850494\n 0.214311   0.54003   0.734867  0.54003   0.214311\n 0.291632   0.734867  1.0       0.734867  0.291632\n 0.214311   0.54003   0.734867  0.54003   0.214311\n 0.0850494  0.214311  0.291632  0.214311  0.0850494\n\nThis makes it very easy to evaluate the PSF on the same axes as an image (array)\n\njulia> img = randn(5, 5);\n\njulia> model.(CartesianIndices(img))\n5×5 Matrix{Float64}:\n 0.54003      0.214311     0.0459292    0.00531559   0.000332224\n 0.214311     0.0850494    0.018227     0.00210949   0.000131843\n 0.0459292    0.018227     0.00390625   0.000452087  2.82555e-5\n 0.00531559   0.00210949   0.000452087  5.2322e-5    3.27013e-6\n 0.000332224  0.000131843  2.82555e-5   3.27013e-6   2.04383e-7\n\nthis is trivially expanded to fit \"stamps\" in images\n\njulia> big_img = randn(1000, 1000);\n\njulia> stamp_inds = (750:830, 400:485);\n\njulia> stamp = @view big_img[stamp_inds...];\n\njulia> stamp_model = model.(CartesianIndices(stamp_inds));\n\nor we can create a loss function for fitting PSFs without allocating any memory. We are simply iterating over the image array!\n\njulia> using Statistics\n\njulia> mse = mean(I -> (big_img[I] - model(I))^2, CartesianIndices(stamp_inds));\n\nFitting data\n\nThere exists a simple, yet powerful, API for fitting data with PSFModels.fit.\n\n# `fit` is not exported to avoid namespace clashes\nusing PSFModels: fit\n\ndata = # load data\nstamp_inds = # optionally choose indices to \"cutout\"\n\n# use an isotropic Gaussian\nparams, synthpsf = fit(gaussian, (:x, :y, :fwhm, :amp),\n                       [12, 13, 3.2, 0.1], data, stamp_inds)\n# elliptical, rotated Gaussian\nparams, synthpsf = fit(gaussian, (:x, :y, :fwhm, :amp, :theta),\n                       [12, 13, 3.2, 3.2, 0.1, 0], data, stamp_inds)\n# obscured Airy disk\nparams, synthpsf = fit(airydisk, (:x, :y, :fwhm, :amp, :ratio),\n                       [12, 13, 3.2, 0.1, 0.3], data, stamp_inds)\n# bivariate Moffat with arbitrary alpha\nparams, synthpsf = fit(moffat, (:x, :y, :fwhm, :amp, :alpha),\n                       [12, 13, 3.2, 3.2, 0.1, 1], data, stamp_inds)\n\nPlotting\n\nFinally, we provide plotting recipes (psfplot/psfplot!) from RecipesBase.jl, which can be seen in use in the API/Reference section.\n\nusing Plots\n\nmodel = gaussian(x=0, y=0, fwhm=(8, 10), theta=12)\npsfplot(model, -30:30, -30:30, colorbar_scale=:log10)\n\n\n\n\n\n","category":"module"},{"location":"#Contributing-and-Support","page":"Home","title":"Contributing and Support","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you would like to contribute, feel free to open a pull request. If you want to discuss something before contributing, head over to discussions and join or open a new topic. If you're having problems with something, please open an issue.","category":"page"}]
}
