[{"id":3,"pagetitle":"Home","title":"CALCEPH","ref":"/CALCEPH/stable/#CALCEPH","content":" CALCEPH This is a julia wrapper for  CALCEPH  a C library for reading planetary ephemeris files, such as  INPOPxx , JPL DExxx and SPICE ephemeris files. CALCEPH  C library is developped by  IMCCE ."},{"id":4,"pagetitle":"Home","title":"Quick start","ref":"/CALCEPH/stable/#Quick-start","content":" Quick start In the Julia interpreter, run: using Pkg\nPkg.add(\"CALCEPH\")\nusing CALCEPH\n\n# ephemeris kernels can be downloaded from many different sources\ndownload(\"ftp://ftp.imcce.fr/pub/ephem/planets/inpop13c/inpop13c_TDB_m100_p100_tt.dat\",\"planets.dat\")\n\n# create an ephemeris context\neph = Ephem(\"planets.dat\")\n\n# prefetch ephemeris files data to main memory for faster access\nprefetch(eph)\n\n# retrieve constants from ephemeris as a dictionary\ncon = constants(eph)\n# list the constants\nkeys(con)\n# get the sun J2\nJ2sun = con[:J2SUN]\n\n# retrieve the position, velocity and acceleration of Earth (geocenter) relative\n# to the Earth-Moon system barycenter in kilometers, kilometers per second and\n# kilometers per second square at JD= 2451624.5 TDB timescale\n# for best accuracy the first time argument should be the integer part and the\n# delta the fractional part\n# when using NAIF identification numbers, useNaifId has to be added to\n# the units argument.\npva=compute(eph,2451624.0,0.5,naifId.id[:earth],naifId.id[:emb],\n                        useNaifId+unitKM+unitSec,2)\nposition=pva[1:3]\nvelocity=pva[4:6]\nacceleration=pva[7:end]\n\n# what is the NAIF identification number for Deimos\nid_deimos = naifId.id[:deimos]\n\n# what does NAIF ID 0 correspond to?\nnames_0 = naifId.names[0]\n"},{"id":5,"pagetitle":"Home","title":"Why use CALCEPH?","ref":"/CALCEPH/stable/#Why-use-CALCEPH?","content":" Why use CALCEPH? CALCEPH functionality is also provided by  NAIF SPICE Toolkit . However CALCEPH has several advantages over the SPICE toolkit, mainly: It can handle multiple ephemeris contexts. It is thread safe (if using one context per thread). It can compute higher order derivatives (acceleration and jerk) approximation using differentiation of the interpolation polynomials. Its ephemeris computation interface expects the time separated in two double precision floating point numbers. This can be used to achieve higher precision in timetag (this can have a significant impact when modeling Doppler observations from a deep space probe). But CALCEPH does not support all functions of the SPICE toolkit. If you need more functionalities  SPICE.jl  is a Julia wrapper for the SPICE toolkit."},{"id":8,"pagetitle":"API","title":"API","ref":"/CALCEPH/stable/api/#API","content":" API"},{"id":9,"pagetitle":"API","title":"CALCEPH.CALCEPH","ref":"/CALCEPH/stable/api/#CALCEPH.CALCEPH","content":" CALCEPH.CALCEPH  —  Module CALCEPH This module is a wrapper of CALCEPH, IMCCE planetary ephemeris access   library. It supports INPOPxx, JPL DExxx and SPICE ephemeris. https://www.imcce.fr/inpop/calceph source"},{"id":10,"pagetitle":"API","title":"CALCEPH.naifId","ref":"/CALCEPH/stable/api/#CALCEPH.naifId","content":" CALCEPH.naifId  —  Constant naifId NAIF identification numbers Examples: julia> using CALCEPH\n\njulia> naifId.id[:sun]\n10\n\njulia> naifId.id[:mars]\n499\n\njulia> naifId.names[0]\nSet(Symbol[:ssb, :solar_system_barycenter])\n source"},{"id":11,"pagetitle":"API","title":"CALCEPH.outputEulerAngles","ref":"/CALCEPH/stable/api/#CALCEPH.outputEulerAngles","content":" CALCEPH.outputEulerAngles  —  Constant outputEulerAngles has to be added to the unit argument for orient to output Euler angles source"},{"id":12,"pagetitle":"API","title":"CALCEPH.outputNutationAngles","ref":"/CALCEPH/stable/api/#CALCEPH.outputNutationAngles","content":" CALCEPH.outputNutationAngles  —  Constant outputNutationAngles has to be added to the unit argument for orient to output nutation angles source"},{"id":13,"pagetitle":"API","title":"CALCEPH.unitAU","ref":"/CALCEPH/stable/api/#CALCEPH.unitAU","content":" CALCEPH.unitAU  —  Constant unitAU Astronomical unit: distance unit source"},{"id":14,"pagetitle":"API","title":"CALCEPH.unitDay","ref":"/CALCEPH/stable/api/#CALCEPH.unitDay","content":" CALCEPH.unitDay  —  Constant unitDay day: time unit source"},{"id":15,"pagetitle":"API","title":"CALCEPH.unitKM","ref":"/CALCEPH/stable/api/#CALCEPH.unitKM","content":" CALCEPH.unitKM  —  Constant unitKM kilometer: distance unit source"},{"id":16,"pagetitle":"API","title":"CALCEPH.unitRad","ref":"/CALCEPH/stable/api/#CALCEPH.unitRad","content":" CALCEPH.unitRad  —  Constant unitRad radian: angle unit source"},{"id":17,"pagetitle":"API","title":"CALCEPH.unitSec","ref":"/CALCEPH/stable/api/#CALCEPH.unitSec","content":" CALCEPH.unitSec  —  Constant unitSec second: time unit source"},{"id":18,"pagetitle":"API","title":"CALCEPH.useNaifId","ref":"/CALCEPH/stable/api/#CALCEPH.useNaifId","content":" CALCEPH.useNaifId  —  Constant useNaifId has to be added to the unit argument when using NAIF integer codes for identification of center and target source"},{"id":19,"pagetitle":"API","title":"CALCEPH.Ephem","ref":"/CALCEPH/stable/api/#CALCEPH.Ephem","content":" CALCEPH.Ephem  —  Type Ephem Ephemeris descriptor. Create with: eph = Ephem(filename)\neph = Ephem([filename1,filename2...]) The ephemeris descriptor will be used to access the ephemeris and related   data stored in the specified files. Because, Julia GC is lazy, you may want to free the memory managed by eph   before you get rid of the reference to eph with: finalize(eph) or after by forcing the GC to run: gc() source"},{"id":20,"pagetitle":"API","title":"CALCEPH.compute","ref":"/CALCEPH/stable/api/#CALCEPH.compute-Tuple{Ephem, Float64, Float64, Integer, Integer, Integer}","content":" CALCEPH.compute  —  Method compute(eph,jd0,time,target,center,unit) Compute position and velocity of target with respect to center at epoch jd0+time. To get the best precision for the interpolation, the time is split in two floating-point numbers. The argument jd0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and jd0, the desired time, if you don't care about precision. Arguments eph : ephemeris jd0::Float64 : jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB) time::Float64 : jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB) target::Integer : The body or reference point whose coordinates are required. The numbering system depends on the parameter unit. center::Integer : The origin of the coordinate system. The numbering system depends on the parameter unit. unit::Integer  : The units of the result. This integer is a sum of some unit constants (unit*) and/or the constant useNaifId. If the unit contains useNaifId, the NAIF identification numbering system is used for the target and the center. If the unit does not contain useNaifId, the old number system is used for the target and the center. source"},{"id":21,"pagetitle":"API","title":"CALCEPH.compute","ref":"/CALCEPH/stable/api/#CALCEPH.compute-Tuple{Ephem, Float64, Float64, Integer, Integer}","content":" CALCEPH.compute  —  Method compute(eph,jd0,time,target,center) Compute position and velocity of target with respect to center at epoch jd0+time. This method does not support the NAIF numbering scheme. To get the best precision for the interpolation, the time is split in two floating-point numbers. The argument jd0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and jd0, the desired time, if you don't care about precision. This method does not support the NAIF body identification scheme. Output units are: AU and AU/day for position and velocity rad and rad/day for librations second and unitless for time ephemeris and time ephemeris rate Arguments eph : ephemeris jd0::Float64 : jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB) time::Float64 : jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB) target::Integer : The body or reference point whose coordinates are required. center::Integer : The origin of the coordinate system. The possible values for target and center are : 1 : Mercury Barycenter 2 : Venus Barycenter 3 : Earth 4 : Mars Barycenter 5 : Jupiter Barycenter 6 : Saturn Barycenter 7 : Uranus Barycenter 8 : Neptune Barycenter 9 : Pluto Barycenter 10    : Moon 11    : Sun 12    : Solar Sytem barycenter 13    : Earth-moon barycenter 14    : Nutation angles 15    : Librations 16    : TT-TDB 17    : TCG-TCB asteroid number + 2000000    : asteroid source"},{"id":22,"pagetitle":"API","title":"CALCEPH.compute","ref":"/CALCEPH/stable/api/#CALCEPH.compute-Tuple{Ephem, Float64, Float64, Vararg{Integer, 4}}","content":" CALCEPH.compute  —  Method compute(eph,jd0,time,target,center,unit,order) Compute position and derivatives up to order of target with respect to center at epoch jd0+time. To get the best precision for the interpolation, the time is split in two floating-point numbers. The argument jd0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and jd0, the desired time, if you don't care about precision. Arguments eph : ephemeris jd0::Float64 : jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB) time::Float64 : jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB) target::Integer : The body or reference point whose coordinates are required. The numbering system depends on the parameter unit. center::Integer : The origin of the coordinate system. The numbering system depends on the parameter unit. unit::Integer  : The units of the result. This integer is a sum of some unit constants (unit*) and/or the constant useNaifId. If the unit contains useNaifId, the NAIF identification numbering system is used for the target and the center. If the unit does not contain useNaifId, the old number system is used for the target and the center. order::Integer  : The order of derivatives 0: only the position is computed. 1: only the position and velocity are computed. 2: only the position, velocity and acceleration are computed. 3: the position, velocity and acceleration and jerk are computed. source"},{"id":23,"pagetitle":"API","title":"CALCEPH.constants","ref":"/CALCEPH/stable/api/#CALCEPH.constants-Tuple{Ephem}","content":" CALCEPH.constants  —  Method constants(eph) Retrieve the constants stored in the ephemeris associated to handle eph as a dictionary source"},{"id":24,"pagetitle":"API","title":"CALCEPH.orient","ref":"/CALCEPH/stable/api/#CALCEPH.orient-Tuple{Ephem, Float64, Float64, Integer, Integer, Integer}","content":" CALCEPH.orient  —  Method orient(eph,jd0,time,target,unit,order) Compute Euler angles and derivatives up to order for the orientation of target at epoch jd0+time. To get the best precision for the interpolation, the time is split in two floating-point numbers. The argument jd0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and jd0, the desired time, if you don't take care about precision. Arguments eph : ephemeris jd0::Float64 : jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB) time::Float64 : jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB) target::Integer : The body whose orientation is required. The numbering system depends on the parameter unit. unit::Integer  : The units of the result. This integer is a sum of some unit constants (unit*) and/or the constant useNaifId. If the unit contains useNaifId, the NAIF identification numbering system is used for the target and the center. If the unit does not contain useNaifId, the old number system is used for the target and the center (see the list in the documentation of function compute). If the unit contains outputNutationAngles, the nutation angles are computed rather than the Euler angles. order::Integer  : The order of derivatives 0: only the angles are computed. 1: only the angles and 1st derivatives are computed. 2: only the angles, the 1st derivatives and 2nd derivatives are computed. 3: the angles, the 1st derivatives, 2nd derivatives and 3rd derivatives are computed. source"},{"id":25,"pagetitle":"API","title":"CALCEPH.orient","ref":"/CALCEPH/stable/api/#CALCEPH.orient-Tuple{Ephem, Float64, Float64, Integer, Integer}","content":" CALCEPH.orient  —  Method orient(eph,jd0,time,target,unit) Compute Euler angles and first derivative for the orientation of target at epoch jd0+time. To get the best precision for the interpolation, the time is split in two floating-point numbers. The argument jd0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and jd0, the desired time, if you don't take care about precision. Arguments eph : ephemeris jd0::Float64 : jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB) time::Float64 : jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB) target::Integer : The body whose orientation is required. The numbering system depends on the parameter unit. unit::Integer  : The units of the result. This integer is a sum of some unit constants (unit*) and/or the constant useNaifId. If the unit contains useNaifId, the NAIF identification numbering system is used for the target and the center. If the unit does not contain useNaifId, the old number system is used for the target and the center (see the list in the documentation of function compute). The angles are expressed in radians if unit contains unitRad. If the unit contains outputNutationAngles, the nutation angles are computed rather than the Euler angles. source"},{"id":26,"pagetitle":"API","title":"CALCEPH.orientationRecords","ref":"/CALCEPH/stable/api/#CALCEPH.orientationRecords-Tuple{Ephem}","content":" CALCEPH.orientationRecords  —  Method orientationRecords(eph) Retrieve orientation records metadata in ephemeris associated to    handler eph . source"},{"id":27,"pagetitle":"API","title":"CALCEPH.positionRecords","ref":"/CALCEPH/stable/api/#CALCEPH.positionRecords-Tuple{Ephem}","content":" CALCEPH.positionRecords  —  Method positionRecords(eph) Retrieve position records metadata in ephemeris associated to    handler eph . source"},{"id":28,"pagetitle":"API","title":"CALCEPH.prefetch","ref":"/CALCEPH/stable/api/#CALCEPH.prefetch-Tuple{Ephem}","content":" CALCEPH.prefetch  —  Method prefetch(eph) This function prefetches to the main memory all files associated to the ephemeris descriptor eph. source"},{"id":29,"pagetitle":"API","title":"CALCEPH.rotAngMom","ref":"/CALCEPH/stable/api/#CALCEPH.rotAngMom-Tuple{Ephem, Float64, Float64, Integer, Integer, Integer}","content":" CALCEPH.rotAngMom  —  Method rotAngMom(eph,jd0,time,target,unit,order) Compute angular momentum due to rotation and derivatives up to order of target at epoch jd0+time. To get the best precision for the interpolation, the time is split in two floating-point numbers. The argument jd0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and jd0, the desired time, if you don't take care about precision. Arguments eph : ephemeris jd0::Float64 : jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB) time::Float64 : jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB) target::Integer : The body whose angular momentum is required. The numbering system depends on the parameter unit. unit::Integer  : The units of the result. This integer is a sum of some unit constants (unit*) and/or the constant useNaifId. If the unit contains useNaifId, the NAIF identification numbering system is used for the target and the center. If the unit does not contain useNaifId, the old number system is used for the target and the center (see the list in the documentation of function compute). order::Integer  : The order of derivatives 0: only the angles are computed. 1: only the angles and 1st derivatives are computed. 2: only the angles, the 1st derivatives and 2nd derivatives are computed. 3: the angles, the 1st derivatives, 2nd derivatives and 3rd derivatives are computed. source"},{"id":30,"pagetitle":"API","title":"CALCEPH.rotAngMom","ref":"/CALCEPH/stable/api/#CALCEPH.rotAngMom-Tuple{Ephem, Float64, Float64, Integer, Integer}","content":" CALCEPH.rotAngMom  —  Method rotAngMom(eph,jd0,time,target,unit) Compute angular momentum due to rotation and first derivative of target at epoch jd0+time. To get the best precision for the interpolation, the time is split in two floating-point numbers. The argument jd0 should be an integer and time should be a fraction of the day. But you may call this function with time=0 and jd0, the desired time, if you don't take care about precision. Arguments eph : ephemeris jd0::Float64 : jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB) time::Float64 : jd0+time must be equal to the Julian Day for the time coordinate corresponding to the ephemeris (usually TDB or TCB) target::Integer : The body whose angular momentum is required. The numbering system depends on the parameter unit. unit::Integer  : The units of the result. This integer is a sum of some unit constants (unit*) and/or the constant useNaifId. If the unit contains useNaifId, the NAIF identification numbering system is used for the target and the center. If the unit does not contain useNaifId, the old number system is used for the target and the center (see the list in the documentation of function compute). The angles are expressed in radians if unit contains unitRad. source"},{"id":31,"pagetitle":"API","title":"CALCEPH.timeScale","ref":"/CALCEPH/stable/api/#CALCEPH.timeScale-Tuple{Ephem}","content":" CALCEPH.timeScale  —  Method timeScale(eph) Retrieve the timescale associated with ephemeris handler eph    Returns 1 for TDB and 2 for TCB. source"},{"id":32,"pagetitle":"API","title":"CALCEPH.timespan","ref":"/CALCEPH/stable/api/#CALCEPH.timespan-Tuple{Ephem}","content":" CALCEPH.timespan  —  Method timespan(eph::Ephem) This function returns the first and last time available in the ephemeris file associated to eph. Arguments: eph  : ephemeris Return: a tuple containing:     * firsttime: Julian date of the first time     * lasttime: Julian date of the last time     * continuous: information about the availability of the quantities over the time span     It returns the following value in the parameter continuous :\n\n    1 if the quantities of all bodies are available for any time between the first and last time.\n    2 if the quantities of some bodies are available on discontinuous time intervals between the first and last time.\n    3 if the quantities of each body are available on a continuous time interval between the first and last time,\n      but not available for any time between the first and last time. See: https://www.imcce.fr/content/medias/recherche/equipes/asd/calceph/html/c/calceph.multiple.html#menu-calceph-gettimespan source"},{"id":35,"pagetitle":"Tutorial","title":"Tutorial","ref":"/CALCEPH/stable/tutorial/#Tutorial","content":" Tutorial This tutorial will walk you through the features and functionality of  CALCEPH.jl"},{"id":36,"pagetitle":"Tutorial","title":"Ephemerides sources","ref":"/CALCEPH/stable/tutorial/#Ephemerides-sources","content":" Ephemerides sources The supported sources of ephemerides are: JPL DExxx binary ephemerides files:  https://ssd.jpl.nasa.gov/?planet eph export IMCCE INPOP ephemerides files:  https://www.imcce.fr/inpop/ some NAIF SPICE kernels:  https://naif.jpl.nasa.gov/naif/data.html Example: download(\"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/de435.bsp\",\"planets.dat\")\n# WARNING this next file is huge (Jupiter Moons ephemerides)\ndownload(\"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/satellites/jup310.bsp\",\"jupiter_system.bsp\")"},{"id":37,"pagetitle":"Tutorial","title":"Ephemerides context","ref":"/CALCEPH/stable/tutorial/#Ephemerides-context","content":" Ephemerides context The user first need to load the ephemerides files into an ephemerides context object that will be used later to retrieve position and velocities of celestial objects. A context can be made from one or several files: using CALCEPH\n\n# load a single file in context eph1\neph1 = Ephem(\"planets.dat\")\n# load multiple files in context eph2\neph2 = Ephem([\"planets.dat\",\"jupiter_system.bsp\"]) You must specify the relative or absolute path(s) of the file(s) to load. You can prefetch the ephemerides data into main memory for faster access: prefetch(eph2)"},{"id":38,"pagetitle":"Tutorial","title":"Epoch arguments","ref":"/CALCEPH/stable/tutorial/#Epoch-arguments","content":" Epoch arguments CALCEPH function takes the epoch as the sum of two double precision floating arguments jd1 and jd2. The sum jd1 + jd2 is interpreted as the julian date in the timescale of the ephemerides context (usually TDB or sometimes TCB). For maximum accuracy, it is recommended to set jd2 to the fractional part of the julian date and jd1 to the difference: jd2 magnitude should be less than one while jd1 should have an integer value. If a high accuracy in timetag is not needed, jd1 can be set to the full julian date and jd2 to zero."},{"id":39,"pagetitle":"Tutorial","title":"Options","ref":"/CALCEPH/stable/tutorial/#Options","content":" Options Many CALCEPH function takes an integer argument to store options. The value of this argument is the sum of the option to enable (each option actually corresponds to a single bit of that integer). Each option to enable can appear only once in the sum! The following options are available: unitAU = 1: set distance units it to Astronomical Unit. unitKM = 2: set distance units to kilometers. unitDay = 4: set time units to days. unitSec = 8: set time units to seconds. unitRad = 16: set angle units to radians. useNaifId = 32: set the body identification scheme to NAIF body identification scheme. outputEulerAngles = 64: when using body orientation ephemerides, this allows to choose Euler angle output. outputNutationAngles = 128: when using body orientation ephemerides, this allows to choose nutation angle output (if available). The useNaifId option controls the identification scheme for the input arguments: target and center. The units options controls the units of the outputs. It is compulsory to set the output units if the routine has the input argument options. For example to compute the position and velocity in kilometers and kilometers per second of body target (given as its NAIF identification number) with respect to center (given as its NAIF identification number), the options argument should be set as such: options = unitKM + unitSec + useNaifId"},{"id":40,"pagetitle":"Tutorial","title":"Body identification scheme","ref":"/CALCEPH/stable/tutorial/#Body-identification-scheme","content":" Body identification scheme CALCEPH has the following identification scheme for bodies: 1 : Mercury Barycenter 2 : Venus Barycenter 3 : Earth 4 : Mars Barycenter 5 : Jupiter Barycenter 6 : Saturn Barycenter 7 : Uranus Barycenter 8 : Neptune Barycenter 9 : Pluto Barycenter 10 : Moon 11 : Sun 12 : Solar Sytem barycenter 13 : Earth-moon barycenter 14 : Nutation angles 15 : Librations 16 : difference TT-TDB 17 : difference TCG-TCB asteroid number + 2000000 : asteroid If target is 14, 15, 16 or 17 (nutation, libration, TT-TDB or TCG-TCB), center must be 0. The more complete NAIF identification scheme can be used if the value useNaifId is added to the options argument."},{"id":41,"pagetitle":"Tutorial","title":"NAIF body identification scheme","ref":"/CALCEPH/stable/tutorial/#NAIF-body-identification-scheme","content":" NAIF body identification scheme See  https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/req/naif_ids.html CALCEPH uses this identification scheme only when the value useNaifId is added to the options argument. The CALCEPH julia wrapper comes with the naifId object which contains the mapping between NAIF identification numbers and names: julia> naifId.id[:sun]\n10\n\njulia> naifId.id[:mars]\n499\n\njulia> naifId.names[0]\nSet(Symbol[:ssb, :solar_system_barycenter])\n naifId also stores the following identifiers: :timecenter (1000000000): the center argument when requesting a value from a time ephemeris. :ttmtdb (1000000001): the target argument when requesting a value from the difference TT-TDB time ephemeris. :tcgmtcb (1000000002): the target argument when requesting a value from the difference TCG-TCB time ephemeris. naifId is actually an instance of mutable struct BodyId. The user can also create its own identification scheme for its SPICE kernels: const MyUniverseIds = CALCEPH.BodyId()\nCALCEPH.add!(MyUniverseIds,:tatooine,1000001)\nCALCEPH.add!(MyUniverseIds,:dagobah,1000002)\nCALCEPH.add!(MyUniverseIds,:endor,1000003)\nCALCEPH.add!(MyUniverseIds,:deathstar,1000004)\nCALCEPH.add!(MyUniverseIds,:endor_deathstar_system_barycenter,1000005)\nCALCEPH.add!(MyUniverseIds,:edsb,1000005) You can also load identification data from an external file: CALCEPH.loadData!(MyUniverseIds, \"MyUniverseIds.txt\") See example:  https://github.com/JuliaAstro/CALCEPH.jl/blob/master/data/NaifIds.txt Names from the file are converted to lower case and have spaces replaced by underscores before being converted to symbols/interned strings."},{"id":42,"pagetitle":"Tutorial","title":"Computing positions and velocities:","ref":"/CALCEPH/stable/tutorial/#Computing-positions-and-velocities:","content":" Computing positions and velocities: The following methods are available to compute position and velocity with CALCEPH: compute(eph,jd1,jd2,target,center)\ncompute(eph,jd1,jd2,target,center,options)\ncompute(eph,jd1,jd2,target,center,options,order) Those methods compute the position and its time derivatives of target with respect to center. The first argument eph is the ephemerides context. The second and third arguments jd1 and jd2 are the epoch. The third argument target is the body for which position is to be computed with respect to origin. The fourth argument center is the origin. The options argument shall specify the units. It can also be used to switch target and center numbering scheme to the NAIF identification scheme. The order argument can be set to: 0: compute position only 1: compute position and velocity 2: compute position, velocity and acceleration 3: compute position, velocity, acceleration and jerk. When order is not specified, position and velocity are computed."},{"id":43,"pagetitle":"Tutorial","title":"Example:","ref":"/CALCEPH/stable/tutorial/#Example:","content":" Example: Computing position only of Jupiter system barycenter with respect to the Earth Moon center in kilometers at JD=2456293.5 (Ephemeris Time). options = useNaifId + unitKM + unitSec\njd1 = 2456293.0\njd2 = 0.5\ncenter = naifId.id[:moon]\ntarget = naifId.id[:jupiter_barycenter]\npos = compute(eph2, jd1, jd2, target, center, options,0)"},{"id":44,"pagetitle":"Tutorial","title":"Computing orientation:","ref":"/CALCEPH/stable/tutorial/#Computing-orientation:","content":" Computing orientation: The following methods are available to compute orientation angles with CALCEPH: orient(eph,jd1,jd2,target,options)\norient(eph,jd1,jd2,target,options,order) Those methods compute the Euler angles of target and their time derivatives. The first argument eph is the ephemerides context. The second and third arguments jd1 and jd2 are the epoch. The fourth argument target is the body for which the Euler angles are to be computed. The options argument shall specify the units. It can also be used to switch target and center numbering scheme to the NAIF identification scheme and to switch between Euler angles and nutation angles. The order argument can be set to: 0: only the angles are computed. 1: only the angles and first derivatives are computed. 2: only the angles, the first and second derivatives are computed. 3: the angles, the first, second and third derivatives are computed."},{"id":45,"pagetitle":"Tutorial","title":"Example:","ref":"/CALCEPH/stable/tutorial/#Example:-2","content":" Example: JPL DE405 binary ephemerides contain Chebychev polynomials for the IAU 1980 nutation theory. Interpolating those is much faster than computing the IAU 1980 nutation series. Computing Earth nutation angles in radians at JD=2456293.5 (Ephemeris Time). download(\"ftp://ssd.jpl.nasa.gov/pub/eph/planets/Linux/de405/lnxp1600p2200.405\",\"DE405\")\neph1 = Ephem(\"DE405\")\noptions = useNaifId + unitRad + unitSec + outputNutationAngles\njd1 = 2456293.0\njd2 = 0.5\ntarget = naifId.id[:earth]\nangles = orient(eph1, jd1, jd2, target, options,0) Note that the returned value is a vector of 3 even though there are only 2 nutation angles. The last value is zero and meaningless."},{"id":46,"pagetitle":"Tutorial","title":"Computing angular momentum:","ref":"/CALCEPH/stable/tutorial/#Computing-angular-momentum:","content":" Computing angular momentum: The following methods are available to compute body angular momentum with CALCEPH: rotAngMom(eph,jd1,jd2,target,options)\nrotAngMom(eph,jd1,jd2,target,options,order) Those methods compute the angular momentum of target and their time derivatives. The first argument eph is the ephemerides context. The second and third arguments jd1 and jd2 are the epoch. The fourth argument target is the body for which the angular momentum are to be computed. The options argument shall specify the units. It can also be used to switch target numbering scheme to the NAIF identification scheme. The order argument can be set to: 0: only the angular momentum vector are computed. 1: only the angular momentum vector and first derivative are computed. 2: only the angular momentum vector, the first and second derivatives are computed. 3: the angular momentum, the first, second and third derivatives are computed."},{"id":47,"pagetitle":"Tutorial","title":"Time ephemeris","ref":"/CALCEPH/stable/tutorial/#Time-ephemeris","content":" Time ephemeris The time ephemeris TT-TDB or TCG-TCB at the geocenter can be evaluated with a suitable source. INPOP and some JPL DE ephemerides includes a numerically integrated time ephemeris for the geocenter which is usually more accurate than the analytical series: Moreover it is much faster to interpolate those ephemerides than to evaluate the analytical series. This is only for the geocenter but a simple correction can also be added for the location of the observer (and its velocity in case the observer is on a highly elliptical orbit). Files that can be used to obtain the difference between TT and TDB are, e.g.: ftp://ftp.imcce.fr/pub/ephem/planets/inpop17a/inpop17a_TDB_m100_p100_tt.dat ftp://ssd.jpl.nasa.gov/pub/eph/planets/bsp/de432t.bsp"},{"id":48,"pagetitle":"Tutorial","title":"Example:","ref":"/CALCEPH/stable/tutorial/#Example:-3","content":" Example: Computing TT-TDB at geocenter in seconds at JD=2456293.5 (Ephemeris Time). download(\"ftp://ftp.imcce.fr/pub/ephem/planets/inpop17a/inpop17a_TDB_m100_p100_tt.dat\",\"INPOP17a\")\neph1 = Ephem(\"INPOP17a\")\noptions = useNaifId + unitSec\njd1 = 2456293.0\njd2 = 0.5\ntarget = naifId.id[:ttmtdb]\ncenter = naifId.id[:timecenter]\nttmtdb = compute(eph1, jd1, jd2, target, center, options,0) Note that the returned value is a vector of 3 even though there is only one meaningful value. The last 2 values are zero and meaningless."},{"id":49,"pagetitle":"Tutorial","title":"In place methods","ref":"/CALCEPH/stable/tutorial/#In-place-methods","content":" In place methods In place versions of the methods described above are also available. Those are: unsafe_compute!(result,eph,jd1,jd2,target,center)\nunsafe_compute!(result,eph,jd1,jd2,target,center,options)\nunsafe_compute!(result,eph,jd1,jd2,target,center,options,order)\nunsafe_orient!(result,eph,jd1,jd2,target,options)\nunsafe_orient!(result,eph,jd1,jd2,target,options,order)\nunsafe_rotAngMom!(result,eph,jd1,jd2,target,options)\nunsafe_rotAngMom!(result,eph,jd1,jd2,target,options,order) Those methods do not perform any checks on their inputs. In particular, result must be a contiguous vector of double precision floating point number of dimension at least 6 when order is not specified or at least 3*(order+1) otherwise."},{"id":50,"pagetitle":"Tutorial","title":"Constants","ref":"/CALCEPH/stable/tutorial/#Constants","content":" Constants Ephemerides files may contain related constants. Those can be obtained by the  constants  method which returns a dictionary: download(\"ftp://ftp.imcce.fr/pub/ephem/planets/inpop17a/inpop17a_TDB_m100_p100_tt.dat\",\"INPOP17a\")\neph1 = Ephem(\"INPOP17a\")\n# retrieve constants from ephemeris as a dictionary\ncon = constants(eph1)\n# list the constants\nkeys(con)\n# get the sun J2\nJ2sun = con[:J2SUN]"},{"id":51,"pagetitle":"Tutorial","title":"Introspection","ref":"/CALCEPH/stable/tutorial/#Introspection","content":" Introspection"},{"id":52,"pagetitle":"Tutorial","title":"Time scale","ref":"/CALCEPH/stable/tutorial/#Time-scale","content":" Time scale timeScale(eph) returns the Ephemeris Time identifier: 1 for TDB 2 for TCB"},{"id":53,"pagetitle":"Tutorial","title":"Time span","ref":"/CALCEPH/stable/tutorial/#Time-span","content":" Time span timespan(eph) returns the triplet: julian date of first entry in ephemerides context. julian date of last entry in ephemerides context. information about the availability of the quantities over the time span: 1 if the quantities of all bodies are available for any time between the first and last time. 2 if the quantities of some bodies are available on discontinuous time intervals between the first and last time. 3 if the quantities of each body are available on a continuous time interval between the first and last time, but not available for any time between the first and last time."},{"id":54,"pagetitle":"Tutorial","title":"Position records","ref":"/CALCEPH/stable/tutorial/#Position-records","content":" Position records positionRecords(eph) retrieve position records metadata in ephemeris associated to handler eph. This is a vector of metadata about the ephemerides records ordered by priority. The compute methods use the highest priority ephemerides records when there are multiple records that could satisfy the target and epoch. Each record metadata contains the following information: target: NAIF identifier of target. center: NAIF identifier of center. startEpoch: julian date of record start. stopEpoch: julian date of record end. frame : 1 for ICRF."},{"id":55,"pagetitle":"Tutorial","title":"Orientation records","ref":"/CALCEPH/stable/tutorial/#Orientation-records","content":" Orientation records orientationRecords(eph) retrieve orientation records metadata in ephemeris associated to handler eph. This is a vector of metadata about the ephemerides records ordered by priority. The orient methods use the highest priority ephemerides records when there are multiple records that could satisfy the target and epoch. Each record metadata contains the following information: target: NAIF identifier of target. startEpoch: julian date of record start. stopEpoch: julian date of record end. frame : 1 for ICRF."},{"id":56,"pagetitle":"Tutorial","title":"Cleaning up","ref":"/CALCEPH/stable/tutorial/#Cleaning-up","content":" Cleaning up Because, Julia's garbage collector is lazy, you may want to free the memory managed by the context before you get rid of the reference to the context with eg: finalize(eph1)\neph1 = Nothing or after with eph1 = Nothing\nGC.gc()"},{"id":57,"pagetitle":"Tutorial","title":"Error handling","ref":"/CALCEPH/stable/tutorial/#Error-handling","content":" Error handling By default, the CALCEPH C library prints error messages directly to the standard output but this can be modified. The Julia wrapper provides the following interface for this purpose: CALCEPH.setCustomHandler(f) where f should be a user function taking a single argument of type String which will contain the CALCEPH error message. f should return Nothing. To disable CALCEPH error messages printout to the console: CALCEPH.setCustomHandler(s->Nothing) To get back the default behavior: CALCEPH.disableCustomHandler()"},{"id":60,"pagetitle":"Home","title":"Home","ref":"/SolarPosition/stable/#Home","content":" Home"},{"id":61,"pagetitle":"Home","title":"SolarPosition.jl","ref":"/SolarPosition/stable/#SolarPosition.jl","content":" SolarPosition.jl SolarPosition.jl provides a simple, unified interface to a collection of validated solar position algorithms written in pure, performant julia. Solar positioning algorithms are commonly used to calculate the solar zenith and azimuth angles, which are essential for various applications where the sun is important, such as: Solar energy systems Building design Climate studies Astronomy"},{"id":62,"pagetitle":"Home","title":"Extensions","ref":"/SolarPosition/stable/#Extensions","content":" Extensions SolarPosition.jl provides package extensions for advanced use cases: ModelingToolkit Extension : Integrate solar position calculations into symbolic modeling workflows. Create composable solar energy system models with ModelingToolkit.jl. See the  ModelingToolkit Extension  guide for details. Makie Extension : Plotting recipes for solar position visualization."},{"id":63,"pagetitle":"Home","title":"Acknowledgement","ref":"/SolarPosition/stable/#Acknowledgement","content":" Acknowledgement This package is based on the work done by readers in the field of solar photovoltaics in the packages  solposx  and  pvlib-python . In particular the positioning and refraction methods have been adapted from  solposx , while the SPA algorithm and the deltat calculation are ported from  pvlib-python . These packages also provide validation data necessary to ensure correctness of the algorithm implementations."},{"id":64,"pagetitle":"Home","title":"Example Usage","ref":"/SolarPosition/stable/#Example-Usage","content":" Example Usage using SolarPosition, Dates\n\n# define observer location (latitude, longitude, altitude in meters)\nobs = Observer(52.35888, 4.88185, 100.0)  # Van Gogh Museum, Amsterdam\n\n# a few hours of timestamps\ntimes = collect(DateTime(2023, 6, 21, 10):Hour(1):DateTime(2023, 6, 21, 15));\n\n# compute solar positions for all timestamps\npositions = solar_position(obs, times) 6-element StructArray(::Vector{Float64}, ::Vector{Float64}, ::Vector{Float64}) with eltype SolPos{Float64}:\n SolPos(azimuth=136.1908215897601°, elevation=55.13208390809107°, zenith=34.86791609190893°)\n SolPos(azimuth=160.3753655770986°, elevation=59.974081481305134°, zenith=30.025918518694862°)\n SolPos(azimuth=188.3992597996431°, elevation=60.87918930278924°, zenith=29.120810697210757°)\n SolPos(azimuth=214.62987222053295°, elevation=57.493462259959394°, zenith=32.5065377400406°)\n SolPos(azimuth=235.5258846451899°, elevation=50.992647293443966°, zenith=39.007352706556034°)\n SolPos(azimuth=251.77304757136397°, elevation=42.790197455865076°, zenith=47.209802544134924°)"},{"id":65,"pagetitle":"Home","title":"Solar positioning algorithms","ref":"/SolarPosition/stable/#Solar-positioning-algorithms","content":" Solar positioning algorithms Here we provide an overview of the solar positioning algorithms currently implemented in SolarPosition.jl. Each algorithm is described with its reference paper, claimed accuracy and implementation status. Algorithm Reference Accuracy Default Refraction Status PSA Blanco-Muriel et al. ±0.0083° None ✅ NOAA Global Monitoring Laboratory ±0.0167° HUGHES ✅ Walraven Walraven, 1978 ±0.0100° None ✅ USNO U.S. Naval Observatory ±0.0500° None ✅ SPA Reda & Andreas, 2004 ±0.0003° Built-in ✅"},{"id":66,"pagetitle":"Home","title":"Refraction correction algorithms","ref":"/SolarPosition/stable/#Refraction-correction-algorithms","content":" Refraction correction algorithms Atmospheric refraction correction algorithms available in SolarPosition.jl. Algorithm Reference Atmospheric Parameters Status HUGHES Hughes, 1985 Pressure, Temperature ✅ ARCHER Archer et al., 1980 None ✅ BENNETT Bennett, 1982 Pressure, Temperature ✅ MICHALSKY Michalsky, 1988 None ✅ SG2 Blanc & Wald, 2012 Pressure, Temperature ✅ SPARefraction Reda & Andreas, 2004 Pressure, Temperature ✅"},{"id":67,"pagetitle":"Home","title":"How to Cite","ref":"/SolarPosition/stable/#How-to-Cite","content":" How to Cite If you use SolarPosition.jl in your work, please cite using the reference given in  CITATION.cff ."},{"id":68,"pagetitle":"Home","title":"Contributing","ref":"/SolarPosition/stable/#Contributing","content":" Contributing If you want to make contributions of any kind, please first that a look into our  contributing guide directly on GitHub  or the  contributing page on the website"},{"id":71,"pagetitle":"Contributing guidelines","title":"Contributing guidelines","ref":"/SolarPosition/stable/contributing/#contributing","content":" Contributing guidelines First of all, thanks for the interest! We welcome all kinds of contribution, including, but not limited to code, documentation, examples, configuration, issue creating, etc. Be polite and respectful."},{"id":72,"pagetitle":"Contributing guidelines","title":"Bug reports and discussions","ref":"/SolarPosition/stable/contributing/#Bug-reports-and-discussions","content":" Bug reports and discussions If you think you found a bug, feel free to open an  issue . Focused suggestions and requests can also be opened as issues. Info Before opening a pull request, it can be productive to first start an issue or a discussion on the topic so that the maintainers and community can provide feedback."},{"id":73,"pagetitle":"Contributing guidelines","title":"Working on an issue","ref":"/SolarPosition/stable/contributing/#Working-on-an-issue","content":" Working on an issue If you found an issue that interests you, comment on that issue what your plans are. If the solution to the issue is clear, you can immediately create a pull request (see below ). Otherwise, say what your proposed solution is and wait for a discussion around it. Tip Feel free to ping us after a few days if there are no responses."},{"id":74,"pagetitle":"Contributing guidelines","title":"Adding a new algorithm","ref":"/SolarPosition/stable/contributing/#Adding-a-new-algorithm","content":" Adding a new algorithm If you want to contribute a new solar positioning or refraction algorithm, see the  Adding a New Solar Position Algorithm  tutorial for a step-by-step guide."},{"id":77,"pagetitle":"Delta T (ΔT)","title":"Delta T (ΔT)","ref":"/SolarPosition/stable/deltat/#deltat","content":" Delta T (ΔT) Delta T (ΔT) is the difference between Terrestrial Dynamical Time (TD) and Universal Time (UT): \\[\\Delta T = TD - UT\\] This correction is essential for accurate astronomical calculations because Earth's rotation rate is not constant. It varies due to tidal braking from the Moon, changes in Earth's moment of inertia, and other geophysical factors."},{"id":78,"pagetitle":"Delta T (ΔT)","title":"Implementation","ref":"/SolarPosition/stable/deltat/#Implementation","content":" Implementation SolarPosition.jl implements ΔT calculation using polynomial expressions fitted to historical observations and modern measurements from atomic clocks, based on [ NAS25 ] and [ MS04 ]: Historical data (-500 to 1950) : Based on eclipse observations Modern era (1950-2005) : Direct measurements from atomic clocks and radio observations Future (2005-2050) : Extrapolation based on recent trends Far past/future : Parabolic extrapolation formula"},{"id":79,"pagetitle":"Delta T (ΔT)","title":"Usage","ref":"/SolarPosition/stable/deltat/#Usage","content":" Usage SolarPosition.Positioning.calculate_deltat  —  Function calculate_deltat(year::Real, month::Real) -> Float64\n Compute ΔT (Delta T), the difference between Terrestrial Dynamical Time (TD) and Universal Time (UT). ΔT = TD - UT This value is needed to convert between civil time (UT) and the uniform time scale used in astronomical calculations (TD). The value changes over time due to variations in Earth's rotation rate caused by tidal braking and other factors. Arguments year::Real : Calendar year (supports -1999 to 3000, with warnings outside this range) month::Real : Month as a real number (1-12, fractional values supported for interpolation) Returns Float64 : ΔT in seconds Examples julia> using SolarPosition.Positioning: calculate_deltat\n\njulia> calculate_deltat(2020, 6)\n71.85030032812497\n\njulia> using Dates\n\njulia> calculate_deltat(Date(2020, 6, 15))\n71.87173085145835\n\njulia> calculate_deltat(DateTime(2020, 6, 15, 12, 30))\n71.87173085145835 Literature The polynomial expressions for ΔT are from [ NAS25 ], based on the work by [ MS04 ]. source"},{"id":80,"pagetitle":"Delta T (ΔT)","title":"Examples","ref":"/SolarPosition/stable/deltat/#Examples","content":" Examples"},{"id":81,"pagetitle":"Delta T (ΔT)","title":"Basic Usage","ref":"/SolarPosition/stable/deltat/#Basic-Usage","content":" Basic Usage Calculate ΔT for a specific year and month: using SolarPosition.Positioning: calculate_deltat\n\n# Calculate ΔT for June 2020\ndt = calculate_deltat(2020, 6)\nprintln(\"ΔT ≈ $(round(dt, digits=2)) seconds\") ΔT ≈ 71.85 seconds"},{"id":82,"pagetitle":"Delta T (ΔT)","title":"Using Date Objects","ref":"/SolarPosition/stable/deltat/#Using-Date-Objects","content":" Using Date Objects For more convenient usage with date objects: using SolarPosition.Positioning: calculate_deltat\nusing Dates\n\n# Using Date\ndate = Date(2020, 6, 15)\ndt1 = calculate_deltat(date)\n\n# Using DateTime\ndatetime = DateTime(2020, 6, 15, 12, 30, 45)\ndt2 = calculate_deltat(datetime)\n\n# Using ZonedDateTime\nusing TimeZones\nzdt = ZonedDateTime(2020, 6, 15, 12, 30, 45, tz\"UTC\")\ndt3 = calculate_deltat(zdt)\n\nprintln(\"Date: ΔT ≈ $(round(dt1, digits=2)) seconds\")\nprintln(\"DateTime: ΔT ≈ $(round(dt2, digits=2)) seconds\")\nprintln(\"ZonedDateTime: ΔT ≈ $(round(dt3, digits=2)) seconds\") Date: ΔT ≈ 71.87 seconds\nDateTime: ΔT ≈ 71.87 seconds\nZonedDateTime: ΔT ≈ 71.87 seconds"},{"id":83,"pagetitle":"Delta T (ΔT)","title":"Historical Values","ref":"/SolarPosition/stable/deltat/#Historical-Values","content":" Historical Values Calculate ΔT for historical dates: using SolarPosition.Positioning: calculate_deltat\n\n# Ancient Rome (year 0)\ndt_ancient = calculate_deltat(0, 6)\nprintln(\"Year 0: ΔT ≈ $(round(dt_ancient, digits=0)) seconds\")\n\n# Early telescope era (1650)\ndt_1650 = calculate_deltat(1650, 6)\nprintln(\"Year 1650: ΔT ≈ $(round(dt_1650, digits=1)) seconds\")\n\n# Near zero around 1900\ndt_1900 = calculate_deltat(1900, 6)\nprintln(\"Year 1900: ΔT ≈ $(round(dt_1900, digits=1)) seconds\") Year 0: ΔT ≈ 10579.0 seconds\nYear 1650: ΔT ≈ 49.5 seconds\nYear 1900: ΔT ≈ -2.1 seconds"},{"id":84,"pagetitle":"Delta T (ΔT)","title":"Plotting Historical Trend","ref":"/SolarPosition/stable/deltat/#Plotting-Historical-Trend","content":" Plotting Historical Trend Visualize how ΔT has changed over time, similar to the measured values derived from telescopic observations: using SolarPosition.Positioning: calculate_deltat\nusing CairoMakie\n\n# Calculate ΔT for years 1600-2000 (historical measurements)\nyears = 1600:1:2000\ndeltat_values = [calculate_deltat(year, 6) for year in years]\n\n# Create plot with transparent background\nfig = Figure(size=(800, 500), backgroundcolor=:transparent, textcolor=\"#f5ab35\")\nax = Axis(fig[1, 1],\n    xlabel = \"Year\",\n    ylabel = \"ΔT (seconds)\",\n    title = \"Historical Values of the Earth's Clock Error\",\n    backgroundcolor=:transparent,\n    xgridvisible = false,\n    ygridvisible = false,\n    xticks = 1500:100:2000,\n    xminorticks = IntervalsBetween(5),\n    xminorticksvisible = true,\n    yminorticks = IntervalsBetween(5),\n    yminorticksvisible = true\n)\n\n# Plot the measured/calculated values\nlines!(ax, years, deltat_values,\n    linewidth=2.5,\n    color=:steelblue,\n    label=\"calculated\"\n)\n\n# Add a very long-term parabolic trend line\n# Using the formula: ΔT ≈ -20 + 32 * ((year - 1820) / 100)^2\n# This represents the parabolic trend centered around 1820-1825\ntrend_years = 1560:10:2050\ntrend_values = [-20 + 32 * ((y - 1820) / 100)^2 for y in trend_years]\nlines!(ax, trend_years, trend_values,\n    linewidth=2,\n    color=:steelblue,\n    linestyle=:dash,\n    label=\"very long-term trend\"\n)\n\naxislegend(ax, position=:lb, backgroundcolor=:transparent)\nxlims!(ax, 1500, 2000)\nylims!(ax, -50, 200)\n\nfig This plot is an attempt to reproduce the result of [ MS04 , Fig 1., page 329] and shows the measured values of ΔT derived from astronomical observations since 1600 CE."},{"id":85,"pagetitle":"Delta T (ΔT)","title":"Accuracy","ref":"/SolarPosition/stable/deltat/#Accuracy","content":" Accuracy The accuracy of ΔT calculations varies depending on the time period: Modern era (1950-2025) : Very accurate (< 1 second) Historical (1600-1950) : Accurate to a few seconds Medieval (500-1600) : Accuracy decreases to ~10-30 seconds Ancient (< 500) : Accuracy decreases significantly (~50-500 seconds) Future predictions : Uncertainty increases with time The uncertainty in ΔT arises because Earth's rotation is affected by unpredictable factors like atmospheric circulation, ocean currents, and tectonic events. For more details on the polynomial expressions and methodology, see [ NAS25 ] and [ MS04 ]."},{"id":88,"pagetitle":"Benchmarking","title":"Benchmarking","ref":"/SolarPosition/stable/guides/benchmarking/#benchmarking","content":" Benchmarking This page provides comprehensive benchmarks of the solar position algorithms available in  SolarPosition.jl , comparing their computational performance and accuracy. The  SPA  algorithm is used as the reference \"gold standard\" due to its high precision (±0.0003°). using SolarPosition\nusing CairoMakie\nusing Dates\nusing DataFrames\nusing Statistics\nusing BenchmarkTools"},{"id":89,"pagetitle":"Benchmarking","title":"Algorithm Overview","ref":"/SolarPosition/stable/guides/benchmarking/#Algorithm-Overview","content":" Algorithm Overview SolarPosition.jl provides several solar positioning algorithms with different accuracy/performance trade-offs: Algorithm Claimed Accuracy Complexity SPA ±0.0003° High PSA ±0.0083° Low NOAA ±0.0167° Low Walraven ±0.0100° Low USNO ±0.0500° Low"},{"id":90,"pagetitle":"Benchmarking","title":"Accuracy Analysis","ref":"/SolarPosition/stable/guides/benchmarking/#Accuracy-Analysis","content":" Accuracy Analysis To evaluate accuracy, we compare each algorithm against SPA across a full year of hourly timestamps at various geographic locations. # Test locations representing different latitudes\nlocations = [\n    (name = \"Equator\", obs = Observer(0.0, 0.0, 0.0)),\n    (name = \"Mid-latitude (London)\", obs = Observer(51.5074, -0.1278, 11.0)),\n    (name = \"High-latitude (Oslo)\", obs = Observer(59.9139, 10.7522, 23.0)),\n    (name = \"Southern hemisphere (Sydney)\", obs = Observer(-33.8688, 151.2093, 58.0)),\n]\n\n# Generate hourly timestamps for a full year\ntimes = collect(DateTime(2024, 1, 1):Hour(1):DateTime(2024, 12, 31, 23))\nprintln(\"Testing with $(length(times)) timestamps per location\") Testing with 8784 timestamps per location Accuracy comparison using Statistics: quantile\n\n\"\"\"\nCompare algorithm accuracy against SPA reference.\nReturns DataFrame with error statistics including percentiles.\n\"\"\"\nfunction compare_accuracy(obs::Observer, times::Vector{DateTime}, algo)\n    # Get SPA reference positions\n    spa_pos = solar_position(obs, times, SPA())\n\n    # Get algorithm positions\n    algo_pos = solar_position(obs, times, algo)\n\n    # Calculate errors for all positions\n    elev_errors = abs.(algo_pos.elevation .- spa_pos.elevation)\n    azim_errors = abs.(algo_pos.azimuth .- spa_pos.azimuth)\n\n    # Handle azimuth wraparound (0° and 360° are the same)\n    azim_errors = min.(azim_errors, 360.0 .- azim_errors)\n\n    return (\n        elevation_mean = mean(elev_errors),\n        elevation_p2_5 = quantile(elev_errors, 0.025),\n        elevation_p97_5 = quantile(elev_errors, 0.975),\n        elevation_max = maximum(elev_errors),\n        azimuth_mean = mean(azim_errors),\n        azimuth_p2_5 = quantile(azim_errors, 0.025),\n        azimuth_p97_5 = quantile(azim_errors, 0.975),\n        azimuth_max = maximum(azim_errors),\n        n_samples = length(times),\n    )\nend Data collection # Algorithms to compare (excluding SPA which is the reference)\nalgorithms = [\n    (\"PSA\", PSA()),\n    (\"NOAA\", NOAA()),\n    (\"Walraven\", Walraven()),\n    (\"USNO\", USNO()),\n]\n\n# Collect accuracy data\naccuracy_results = DataFrame(\n    Algorithm = String[],\n    Location = String[],\n    Elevation_Mean_Error = Float64[],\n    Elevation_P2_5 = Float64[],\n    Elevation_P97_5 = Float64[],\n    Elevation_Max_Error = Float64[],\n    Azimuth_Mean_Error = Float64[],\n    Azimuth_P2_5 = Float64[],\n    Azimuth_P97_5 = Float64[],\n    Azimuth_Max_Error = Float64[],\n)\n\nfor (algo_name, algo) in algorithms\n    for loc in locations\n        stats = compare_accuracy(loc.obs, times, algo)\n        push!(accuracy_results, (\n            Algorithm = algo_name,\n            Location = loc.name,\n            Elevation_Mean_Error = stats.elevation_mean,\n            Elevation_P2_5 = stats.elevation_p2_5,\n            Elevation_P97_5 = stats.elevation_p97_5,\n            Elevation_Max_Error = stats.elevation_max,\n            Azimuth_Mean_Error = stats.azimuth_mean,\n            Azimuth_P2_5 = stats.azimuth_p2_5,\n            Azimuth_P97_5 = stats.azimuth_p97_5,\n            Azimuth_Max_Error = stats.azimuth_max,\n        ))\n    end\nend\n\naccuracy_results 16×10 DataFrame Row Algorithm Location Elevation_Mean_Error Elevation_P2_5 Elevation_P97_5 Elevation_Max_Error Azimuth_Mean_Error Azimuth_P2_5 Azimuth_P97_5 Azimuth_Max_Error String String Float64 Float64 Float64 Float64 Float64 Float64 Float64 Float64 1 PSA Equator 0.00121745 4.46789e-5 0.00334261 0.0038712 0.00157786 2.61068e-5 0.00831938 0.0681224 2 PSA Mid-latitude (London) 0.000689003 1.86942e-5 0.00252155 0.003289 0.00145074 6.2594e-5 0.00408151 0.00666008 3 PSA High-latitude (Oslo) 0.000581013 1.91489e-5 0.0022497 0.00295758 0.00144994 6.91808e-5 0.00382428 0.00551483 4 PSA Southern hemisphere (Sydney) 0.000940508 3.10488e-5 0.00299724 0.00378125 0.0014582 4.02358e-5 0.00560808 0.0142766 5 NOAA Equator 0.00371466 0.000131678 0.0109585 0.0128709 0.00406937 4.94055e-5 0.0247847 0.157852 6 NOAA Mid-latitude (London) 0.00274283 0.000166422 0.00698196 0.00998113 0.00401022 0.000126333 0.0118543 0.0175856 7 NOAA High-latitude (Oslo) 0.00258248 0.000203615 0.00607827 0.00882385 0.0040052 0.000137447 0.0109518 0.0149296 8 NOAA Southern hemisphere (Sydney) 0.00303157 0.00012467 0.00930871 0.012174 0.00404034 9.39007e-5 0.0159962 0.0392285 9 Walraven Equator 0.00292731 0.000122914 0.00706936 0.00835027 0.0053801 0.000219938 0.018372 0.133819 10 Walraven Mid-latitude (London) 0.00295305 9.02431e-5 0.00783931 0.00908632 0.00314946 0.00014002 0.0077489 0.0113622 11 Walraven High-latitude (Oslo) 0.00296743 9.30684e-5 0.00772813 0.00896714 0.00305173 0.000160852 0.00676189 0.00926879 12 Walraven Southern hemisphere (Sydney) 0.00304675 0.000163423 0.00714855 0.00809611 0.00369838 0.000183722 0.0118405 0.029953 13 USNO Equator 0.00251801 0.000120657 0.00681849 0.00853729 0.00352438 0.000150705 0.0136207 0.0714088 14 USNO Mid-latitude (London) 0.00268801 8.72288e-5 0.00658313 0.00795245 0.00238829 9.20632e-5 0.00663273 0.00976728 15 USNO High-latitude (Oslo) 0.00274458 9.02397e-5 0.00634479 0.00760349 0.00228672 9.7486e-5 0.00613286 0.00820491 16 USNO Southern hemisphere (Sydney) 0.00231139 7.92274e-5 0.00570601 0.00721132 0.00283971 0.000130919 0.00969949 0.0199054"},{"id":91,"pagetitle":"Benchmarking","title":"Accuracy Visualization","ref":"/SolarPosition/stable/guides/benchmarking/#Accuracy-Visualization","content":" Accuracy Visualization The following plots show the mean error with 95% confidence intervals (2.5th to 97.5th percentile) for each algorithm compared to SPA. Accuracy visualization # Aggregate results by algorithm (mean across all locations)\nalgo_stats = combine(\n    groupby(accuracy_results, :Algorithm),\n    :Elevation_Mean_Error => mean => :Elev_Mean,\n    :Elevation_P2_5 => mean => :Elev_P2_5,\n    :Elevation_P97_5 => mean => :Elev_P97_5,\n    :Azimuth_Mean_Error => mean => :Azim_Mean,\n    :Azimuth_P2_5 => mean => :Azim_P2_5,\n    :Azimuth_P97_5 => mean => :Azim_P97_5,\n)\n\n# Sort by algorithm order\nalgo_order = [\"PSA\", \"NOAA\", \"Walraven\", \"USNO\"]\nalgo_stats = algo_stats[sortperm([findfirst(==(algo), algo_order) for algo in algo_stats.Algorithm]), :]\n\nfig = Figure(size = (900, 400), backgroundcolor = :transparent, fontsize = 12, textcolor = \"#f5ab35\")\n\n# Elevation error plot with error bars\nax1 = Axis(fig[1, 1],\n    title = \"Elevation Error vs SPA (95% CI)\",\n    xlabel = \"Algorithm\",\n    ylabel = \"Error (degrees)\",\n    xticks = (1:4, algo_stats.Algorithm),\n    backgroundcolor = :transparent,\n)\n\n# Error bars showing 95% interval\nerrorbars!(ax1, 1:4, algo_stats.Elev_Mean,\n    algo_stats.Elev_Mean .- algo_stats.Elev_P2_5,\n    algo_stats.Elev_P97_5 .- algo_stats.Elev_Mean,\n    color = :steelblue, linewidth = 2, whiskerwidth = 10)\nscatter!(ax1, 1:4, algo_stats.Elev_Mean, color = :steelblue, markersize = 12)\n\n# Azimuth error plot with error bars\nax2 = Axis(fig[1, 2],\n    title = \"Azimuth Error vs SPA (95% CI)\",\n    xlabel = \"Algorithm\",\n    ylabel = \"Error (degrees)\",\n    xticks = (1:4, algo_stats.Algorithm),\n    backgroundcolor = :transparent,\n)\n\nerrorbars!(ax2, 1:4, algo_stats.Azim_Mean,\n    algo_stats.Azim_Mean .- algo_stats.Azim_P2_5,\n    algo_stats.Azim_P97_5 .- algo_stats.Azim_Mean,\n    color = :coral, linewidth = 2, whiskerwidth = 10)\nscatter!(ax2, 1:4, algo_stats.Azim_Mean, color = :coral, markersize = 12)"},{"id":92,"pagetitle":"Benchmarking","title":"PSA Error Over Time","ref":"/SolarPosition/stable/guides/benchmarking/#PSA-Error-Over-Time","content":" PSA Error Over Time To better understand how errors vary throughout the year, we compare the PSA algorithm against SPA at hourly resolution for a full year at a single location. # Generate hourly timestamps for a full year (reduces memory usage vs minute resolution)\nhourly_times = collect(DateTime(2024, 1, 1):Hour(1):DateTime(2024, 12, 31, 23))\nobs_london = Observer(51.5074, -0.1278, 11.0)\n\n# Calculate positions\nspa_positions = solar_position(obs_london, hourly_times, SPA())\npsa_positions = solar_position(obs_london, hourly_times, PSA())\n\n# Calculate errors\nelev_errors = psa_positions.elevation .- spa_positions.elevation\nazim_errors = psa_positions.azimuth .- spa_positions.azimuth\n\n# Handle azimuth wraparound\nazim_errors = [abs(e) > 180 ? e - sign(e) * 360 : e for e in azim_errors]\n\nprintln(\"PSA vs SPA at hourly resolution ($(length(hourly_times)) samples):\")\nprintln(\"  Elevation: mean=$(round(mean(abs.(elev_errors)), digits=6))°, max=$(round(maximum(abs.(elev_errors)), digits=4))°\")\nprintln(\"  Azimuth: mean=$(round(mean(abs.(azim_errors)), digits=6))°, max=$(round(maximum(abs.(azim_errors)), digits=4))°\") PSA vs SPA at hourly resolution (8784 samples):\n  Elevation: mean=0.000689°, max=0.0033°\n  Azimuth: mean=0.001451°, max=0.0067° PSA error visualization fig_err = Figure(size = (900, 500), backgroundcolor = :transparent, fontsize = 12, textcolor = \"#f5ab35\")\n\n# Convert to day of year for x-axis\nday_of_year = [Dates.dayofyear(t) for t in hourly_times]\n\nax1 = Axis(fig_err[1, 1],\n    title = \"PSA Elevation Error vs SPA (2024, London)\",\n    xlabel = \"Day of Year\",\n    ylabel = \"Error (degrees)\",\n    backgroundcolor = :transparent,\n)\nscatter!(ax1, day_of_year, elev_errors, markersize = 1.5, color = (:steelblue, 0.5))\nhlines!(ax1, [0.0], color = :gray, linestyle = :dash)\n\nax2 = Axis(fig_err[2, 1],\n    title = \"PSA Azimuth Error vs SPA (2024, London)\",\n    xlabel = \"Day of Year\",\n    ylabel = \"Error (degrees)\",\n    backgroundcolor = :transparent,\n)\nscatter!(ax2, day_of_year, azim_errors, markersize = 1.5, color = (:coral, 0.5))\nhlines!(ax2, [0.0], color = :gray, linestyle = :dash)"},{"id":93,"pagetitle":"Benchmarking","title":"Error Distribution by Location","ref":"/SolarPosition/stable/guides/benchmarking/#Error-Distribution-by-Location","content":" Error Distribution by Location Error distribution visualization fig2 = Figure(size = (900, 500), backgroundcolor = :transparent, fontsize = 11, textcolor = \"#f5ab35\")\n\nfor (i, loc) in enumerate(locations)\n    row = (i - 1) ÷ 2 + 1\n    col = (i - 1) % 2 + 1\n\n    ax = Axis(fig2[row, col],\n        title = loc.name,\n        xlabel = \"Algorithm\",\n        ylabel = \"Mean Elevation Error (°)\",\n        xticks = (1:4, [a[1] for a in algorithms]),\n        backgroundcolor = :transparent,\n    )\n\n    loc_data = filter(r -> r.Location == loc.name, accuracy_results)\n    barplot!(ax, 1:4, loc_data.Elevation_Mean_Error, color = :teal)\nend\n\nLabel(fig2[0, :], \"Elevation Error by Location\", fontsize = 14, font = :bold)"},{"id":94,"pagetitle":"Benchmarking","title":"Performance Benchmarks","ref":"/SolarPosition/stable/guides/benchmarking/#Performance-Benchmarks","content":" Performance Benchmarks We benchmark the computational performance of each algorithm across different input sizes, from single timestamp calculations to bulk operations with 100,000 timestamps. Single benchmark # Single position benchmarks\nobs = Observer(51.5074, -0.1278, 11.0)  # London\ndt = DateTime(2024, 6, 21, 12, 0, 0)\n\nsingle_benchmarks = DataFrame(\n    Algorithm = String[],\n    Time_ns = Float64[],\n    Allocations = Int[],\n)\n\nfor (name, algo) in [(\"PSA\", PSA()), (\"NOAA\", NOAA()), (\"Walraven\", Walraven()),\n                      (\"USNO\", USNO()), (\"SPA\", SPA())]\n    b = @benchmark solar_position($obs, $dt, $algo) samples=100 evals=10\n    push!(single_benchmarks, (\n        Algorithm = name,\n        Time_ns = median(b.times),\n        Allocations = b.allocs,\n    ))\nend\n\n# Add relative timing\nsingle_benchmarks.Time_μs = single_benchmarks.Time_ns ./ 1000\nspa_time = filter(row -> row.Algorithm == \"SPA\", single_benchmarks).Time_ns[1]\nsingle_benchmarks.Relative_to_SPA = single_benchmarks.Time_ns ./ spa_time\n\nsingle_benchmarks[:, [:Algorithm, :Time_μs, :Allocations, :Relative_to_SPA]] 5×4 DataFrame Row Algorithm Time_μs Allocations Relative_to_SPA String Float64 Int64 Float64 1 PSA 0.1633 0 0.0553466 2 NOAA 0.4138 0 0.140247 3 Walraven 0.1954 0 0.0662261 4 USNO 0.3807 0 0.129029 5 SPA 2.9505 0 1.0 Vector benchmark # Vector benchmarks for different sizes\nsizes = [100, 1_000, 10_000, 100_000]\n\nvector_benchmarks = DataFrame(\n    Algorithm = String[],\n    N = Int[],\n    Time_ms = Float64[],\n    Throughput = Float64[],  # positions per second\n)\n\nfor n in sizes\n    times_vec = collect(DateTime(2024, 1, 1):Hour(1):(DateTime(2024, 1, 1) + Hour(n-1)))\n\n    for (name, algo) in [(\"PSA\", PSA()), (\"NOAA\", NOAA()), (\"Walraven\", Walraven()),\n                          (\"USNO\", USNO()), (\"SPA\", SPA())]\n        b = @benchmark solar_position($obs, $times_vec, $algo) samples=10 evals=1\n        time_ms = median(b.times) / 1e6\n        push!(vector_benchmarks, (\n            Algorithm = name,\n            N = n,\n            Time_ms = time_ms,\n            Throughput = n / (time_ms / 1000),\n        ))\n    end\nend\n\n# Pivot for display\nvector_pivot = unstack(vector_benchmarks, :Algorithm, :N, :Time_ms)\nvector_pivot 5×5 DataFrame Row Algorithm 100 1000 10000 100000 String Float64? Float64? Float64? Float64? 1 PSA 0.016972 0.167457 1.70288 17.0643 2 NOAA 0.042894 0.41916 4.19889 42.7756 3 Walraven 0.0196065 0.194467 1.97723 19.8448 4 USNO 0.039038 0.376936 3.82641 38.5104 5 SPA 0.303214 3.06786 30.949 310.511"},{"id":95,"pagetitle":"Benchmarking","title":"Performance Visualization","ref":"/SolarPosition/stable/guides/benchmarking/#Performance-Visualization","content":" Performance Visualization Performance visualization fig3 = Figure(size = (900, 400), backgroundcolor = :transparent, fontsize = 12, textcolor = \"#f5ab35\")\n\n# Scaling plot (log-log)\nax1 = Axis(fig3[1, 1],\n    title = \"Computation Time vs Input Size\",\n    xlabel = \"Number of Timestamps\",\n    ylabel = \"Time (ms)\",\n    xscale = log10,\n    yscale = log10,\n    backgroundcolor = :transparent,\n)\n\ncolors = [:blue, :orange, :green, :purple, :red]\nalgo_names = [\"PSA\", \"NOAA\", \"Walraven\", \"USNO\", \"SPA\"]\n\nfor (i, algo) in enumerate(algo_names)\n    data = filter(r -> r.Algorithm == algo, vector_benchmarks)\n    lines!(ax1, data.N, data.Time_ms, label = algo, color = colors[i], linewidth = 2)\n    scatter!(ax1, data.N, data.Time_ms, color = colors[i], markersize = 8)\nend\naxislegend(ax1, position = :rb, framevisible = false, labelsize = 10)\n\n# Throughput plot\nax2 = Axis(fig3[1, 2],\n    title = \"Throughput at N=100,000\",\n    xlabel = \"Algorithm\",\n    ylabel = \"Positions per Second\",\n    xticks = (1:5, algo_names),\n    backgroundcolor = :transparent,\n)\n\nthroughput_100k = filter(r -> r.N == 100_000, vector_benchmarks)\nbarplot!(ax2, 1:5, throughput_100k.Throughput ./ 1e6, color = colors)\nax2.ylabel = \"Million Positions / Second\""},{"id":96,"pagetitle":"Benchmarking","title":"Comparison with solposx (Python)","ref":"/SolarPosition/stable/guides/benchmarking/#Comparison-with-solposx-(Python)","content":" Comparison with solposx (Python) The  solposx  package is a Python library that implements the same solar position algorithms. This section compares the performance of SolarPosition.jl against solposx to demonstrate the benefits of using Julia. Benchmarking Methodology The benchmarks below use  PythonCall.jl  to call  solposx  from within Julia. We have also benchmarked  solposx  directly in a pure Python environment (without  PythonCall.jl  overhead) and found no significant difference in the results."},{"id":97,"pagetitle":"Benchmarking","title":"Setup","ref":"/SolarPosition/stable/guides/benchmarking/#Setup","content":" Setup First, we install and import solposx using  PythonCall.jl  and  CondaPkg.jl : using CondaPkg\nCondaPkg.add_pip(\"solposx\")\nCondaPkg.add_pip(\"pandas\")\n\nusing PythonCall\n\n# Import Python modules\nsp = pyimport(\"solposx.solarposition\")\npd = pyimport(\"pandas\") Python: <module 'pandas' from '/home/runner/work/SolarPosition.jl/SolarPosition.jl/docs/.CondaPkg/.pixi/envs/default/lib/python3.13/site-packages/pandas/__init__.py'>"},{"id":98,"pagetitle":"Benchmarking","title":"Benchmark Configuration","ref":"/SolarPosition/stable/guides/benchmarking/#Benchmark-Configuration","content":" Benchmark Configuration For fair comparison, we use the same test conditions for both libraries: Observer : London (51.5074°N, 0.1278°W, 11m elevation) Timestamps : Hourly data from January 1, 2024 Algorithms : PSA, NOAA, Walraven, USNO, SPA # Helper function to create pandas DatetimeIndex\nfunction create_pandas_times(n::Int)\n    pd.date_range(start=\"2024-01-01 00:00:00\", periods=n, freq=\"h\", tz=\"UTC\")\nend\n\n# solposx algorithm mapping - use Symbol keys for kwargs\nsolposx_algorithms = Dict(\n    \"PSA\" => (sp.psa, (coefficients = 2020,)),\n    \"NOAA\" => (sp.noaa, NamedTuple()),\n    \"Walraven\" => (sp.walraven, NamedTuple()),\n    \"USNO\" => (sp.usno, NamedTuple()),\n    \"SPA\" => (sp.spa, NamedTuple()),\n)\n\nlat, lon = 51.5074, -0.1278 (51.5074, -0.1278)"},{"id":99,"pagetitle":"Benchmarking","title":"Running the Benchmarks","ref":"/SolarPosition/stable/guides/benchmarking/#Running-the-Benchmarks","content":" Running the Benchmarks We benchmark both libraries across different input sizes: Benchmark code # Benchmark sizes\nsizes = [100, 1_000, 10_000]\n\n# Results storage\ncomparison_results = DataFrame(\n    Algorithm = String[],\n    N = Int[],\n    Julia_ms = Float64[],\n    Python_ms = Float64[],\n    Speedup = Float64[],\n)\n\nfor n in sizes\n    # Create time vectors\n    julia_times_vec = collect(DateTime(2024, 1, 1):Hour(1):(DateTime(2024, 1, 1) + Hour(n-1)))\n    py_times_idx = create_pandas_times(n)\n\n    for (algo_name, algo) in [(\"PSA\", PSA()), (\"NOAA\", NOAA()), (\"Walraven\", Walraven()),\n                               (\"USNO\", USNO()), (\"SPA\", SPA())]\n        # Julia benchmark\n        julia_bench = @benchmark solar_position($obs, $julia_times_vec, $algo) samples=5 evals=1\n        julia_time_ms = median(julia_bench.times) / 1e6\n\n        # Python benchmark\n        py_func, py_kwargs = solposx_algorithms[algo_name]\n\n        # Benchmark Python function using BenchmarkTools\n        if isempty(py_kwargs)\n            py_bench = @benchmark $py_func($py_times_idx, $lat, $lon) samples=5 evals=1\n        else\n            py_bench = @benchmark $py_func($py_times_idx, $lat, $lon; $py_kwargs...) samples=5 evals=1\n        end\n        python_time_ms = median(py_bench.times) / 1e6\n\n        speedup = python_time_ms / julia_time_ms\n\n        push!(comparison_results, (\n            Algorithm = algo_name,\n            N = n,\n            Julia_ms = round(julia_time_ms, digits=3),\n            Python_ms = round(python_time_ms, digits=3),\n            Speedup = round(speedup, digits=1),\n        ))\n    end\nend\n\ncomparison_results 15×5 DataFrame Row Algorithm N Julia_ms Python_ms Speedup String Int64 Float64 Float64 Float64 1 PSA 100 0.017 2.811 164.9 2 NOAA 100 0.042 3.947 93.7 3 Walraven 100 0.02 1.236 62.5 4 USNO 100 0.039 3.014 76.9 5 SPA 100 0.303 3.17 10.5 6 PSA 1000 0.174 3.138 18.1 7 NOAA 1000 0.421 4.533 10.8 8 Walraven 1000 0.198 1.424 7.2 9 USNO 1000 0.376 6.945 18.5 10 SPA 1000 3.079 7.713 2.5 11 PSA 10000 1.812 6.927 3.8 12 NOAA 10000 4.109 10.743 2.6 13 Walraven 10000 2.001 3.996 2.0 14 USNO 10000 3.843 46.686 12.1 15 SPA 10000 31.024 50.816 1.6 Performance comparison visualization fig5 = Figure(size = (600, 750), backgroundcolor = :transparent, fontsize = 12, textcolor = \"#f5ab35\")\n\n# Group by algorithm for plotting\nalgo_names = [\"PSA\", \"NOAA\", \"Walraven\", \"USNO\", \"SPA\"]\ncolors_julia = [:blue, :green, :purple, :orange, :red]\n\nax1 = Axis(fig5[1, 1],\n    title = \"Computation Time: Julia vs Python\",\n    xlabel = \"Number of Timestamps\",\n    ylabel = \"Time (ms)\",\n    xscale = log10,\n    yscale = log10,\n    backgroundcolor = :transparent,\n)\n\n# Store line objects for legends\njulia_lines = []\npython_lines = []\n\nfor (i, algo) in enumerate(algo_names)\n    data = filter(r -> r.Algorithm == algo, comparison_results)\n\n    # Julia times (solid lines)\n    l1 = lines!(ax1, data.N, data.Julia_ms,\n        color = colors_julia[i],\n        linewidth = 2)\n    scatter!(ax1, data.N, data.Julia_ms, color = colors_julia[i], markersize = 6)\n    push!(julia_lines, l1)\n\n    # Python times (dashed lines)\n    l2 = lines!(ax1, data.N, data.Python_ms,\n        color = colors_julia[i],\n        linewidth = 2,\n        linestyle = :dash)\n    scatter!(ax1, data.N, data.Python_ms, color = colors_julia[i], markersize = 6,\n        marker = :utriangle)\n    push!(python_lines, l2)\nend\n\n# Algorithm legend (colors)\nleg1 = Legend(fig5[1, 2][1, 1], julia_lines, algo_names, \"Algorithm\",\n    framevisible = true, backgroundcolor = :transparent, labelsize = 10, titlesize = 11)\n\n# Line style legend (solid vs dashed)\nstyle_lines = [LineElement(color = :gray, linewidth = 2, linestyle = :solid),\n               LineElement(color = :gray, linewidth = 2, linestyle = :dash)]\nleg2 = Legend(fig5[1, 2][2, 1], style_lines, [\"Julia\", \"Python\"], \"Library\",\n    framevisible = true, backgroundcolor = :transparent, labelsize = 10, titlesize = 11)\n\n# Speedup bar chart\nax2 = Axis(fig5[2, 1:2],\n    title = \"Julia vs Python at N=1,000\",\n    xlabel = \"Algorithm\",\n    ylabel = \"Speedup Factor (×)\",\n    xticks = (1:5, algo_names),\n    backgroundcolor = :transparent,\n)\n\nspeedup_1k = filter(r -> r.N == 1_000, comparison_results)\nbarplot!(ax2, 1:5, speedup_1k.Speedup, color = colors_julia)\nhlines!(ax2, [1.0], color = :gray, linestyle = :dash)"},{"id":100,"pagetitle":"Benchmarking","title":"Summary","ref":"/SolarPosition/stable/guides/benchmarking/#Summary","content":" Summary The benchmarks demonstrate that SolarPosition.jl offers significant performance advantages over the solposx Python library across all tested algorithms and input sizes. Multi-threading SolarPosition.jl  can leverage Julia's native multi-threading capabilities (see  Parallel Computing ) for further performance improvements on large datasets. The benchmarks above were conducted using a single thread for fair comparison with  solposx , but enabling multi-threading can yield even greater speedups in practical applications. speedup_table = unstack(comparison_results[:, [:Algorithm, :N, :Speedup]], :Algorithm, :N, :Speedup)\nspeedup_table 5×4 DataFrame Row Algorithm 100 1000 10000 String Float64? Float64? Float64? 1 PSA 164.9 18.1 3.8 2 NOAA 93.7 10.8 2.6 3 Walraven 62.5 7.2 2.0 4 USNO 76.9 18.5 12.1 5 SPA 10.5 2.5 1.6"},{"id":103,"pagetitle":"Getting Started","title":"Getting Started","ref":"/SolarPosition/stable/guides/getting-started/#getting-started","content":" Getting Started In this tutorial, we introduduce the basics of using  SolarPosition.jl  to calculate solar positions. First, we need to import the  SolarPosition.jl  package along with some supporting packages which we need for handling dates and time zones. We also load  DataFrames.jl  because it makes it easy to work with tabular data. Info The  DateTime  type in Julia's standard library does not contain time zone information. When using  DateTime ,  it is assumed to be in UTC . Although not necessary, it is safer to work with time zone-aware  ZonedDateTime  from the  TimeZones.jl  package. # mandatory\nusing SolarPosition\nusing Dates\n\n# supporting packages\nusing TimeZones\nusing DataFrames"},{"id":104,"pagetitle":"Getting Started","title":"Defining a location","ref":"/SolarPosition/stable/guides/getting-started/#Defining-a-location","content":" Defining a location We can observe the sun from anywhere on earth. To define an observer location, we use the  Observer  struct, which takes latitude, longitude, and optionally altitude (in meters) as arguments. obs = Observer(52.35888, 4.88185, 100.0)  # Van Gogh Museum, Amsterdam Observer(latitude=52.35888°, longitude=4.88185°, altitude=100.0m)"},{"id":105,"pagetitle":"Getting Started","title":"Computing the solar vector","ref":"/SolarPosition/stable/guides/getting-started/#Computing-the-solar-vector","content":" Computing the solar vector Finally, we can calculate the solar position for a specific date and time using the  solar_position  function. The time should be provided as a  ZonedDateTime  to ensure correct handling of time zones. tz = TimeZone(\"Europe/Brussels\")\nzdt = ZonedDateTime(2023, 6, 21, 12, 0, 0, tz)  # Summer solstice noon\nposition = solar_position(obs, zdt) SolPos(azimuth=136.1908215897601°, elevation=55.13208390809107°, zenith=34.86791609190893°)"},{"id":106,"pagetitle":"Getting Started","title":"Choosing a Solar Position Algorithm","ref":"/SolarPosition/stable/guides/getting-started/#Choosing-a-Solar-Position-Algorithm","content":" Choosing a Solar Position Algorithm By default,  solar_position  uses the  PSA  (Plataforma Solar de Almería) algorithm, which has a decent tradeoff between complexity and accuracy. You can choose other algorithms as described in the  Solar Positioning Algorithms  section. First, we repeat the previous calculation using the default PSA algorithm: position_psa = solar_position(obs, zdt, PSA()) SolPos(azimuth=136.1908215897601°, elevation=55.13208390809107°, zenith=34.86791609190893°) Next, we compute the solar position using the NOAA algorithm: position_noaa = solar_position(obs, zdt, NOAA()) ApparentSolPos(azimuth=136.18912784953108°, elevation=55.133206173835674°, zenith=34.866793826164326°,\n    apparent_elevation=55.144444345946475°, apparent_zenith=34.855555654053525° As you can see, the results are very similar. With a claimed accuracy of ±0.0083° for PSA and ±0.0167° for NOAA, the differences should be small: delta_azimuth = abs(position_psa.azimuth - position_noaa.azimuth)\ndelta_elevation = abs(position_psa.elevation - position_noaa.elevation)\nprintln(\"Difference in Azimuth: $(round(delta_azimuth, digits=4))°\")\nprintln(\"Difference in Elevation: $(round(delta_elevation, digits=4))°\") Difference in Azimuth: 0.0017°\nDifference in Elevation: 0.0011° Whether the differences are significant depends on your application and required accuracy."},{"id":107,"pagetitle":"Getting Started","title":"Computing multiple timestamps simultaneously","ref":"/SolarPosition/stable/guides/getting-started/#Computing-multiple-timestamps-simultaneously","content":" Computing multiple timestamps simultaneously For more demanding applications, it is often necessary to compute solar positions for multiple timestamps at once.  SolarPosition.jl  supports this by passing a vector of  ZonedDateTime  or  DateTime  objects to the  solar_position  function. Here, we demonstrate this by calculating solar positions for every hour of a full year. # generate hourly timestamps for a whole year\ndts = collect(ZonedDateTime(DateTime(2023), tz):Hour(1):ZonedDateTime(DateTime(2024), tz))\npositions = solar_position(obs, dts) 8761-element StructArray(::Vector{Float64}, ::Vector{Float64}, ::Vector{Float64}) with eltype SolPos{Float64}:\n SolPos(azimuth=339.9139651348899°, elevation=-59.516632497943725°, zenith=149.51663249794373°)\n SolPos(azimuth=7.646701924575278°, elevation=-60.51529149754965°, zenith=150.51529149754964°)\n SolPos(azimuth=33.77454046955175°, elevation=-57.24826008871935°, zenith=147.24826008871935°)\n SolPos(azimuth=54.726212423433985°, elevation=-50.83991842657765°, zenith=140.83991842657764°)\n SolPos(azimuth=71.0627278720897°, elevation=-42.69054124991213°, zenith=132.69054124991212°)\n SolPos(azimuth=84.48676815893062°, elevation=-33.75262519360256°, zenith=123.75262519360257°)\n SolPos(azimuth=96.34620993304598°, elevation=-24.609274875219057°, zenith=114.60927487521906°)\n SolPos(azimuth=107.54782743459084°, elevation=-15.662602359963579°, zenith=105.66260235996357°)\n SolPos(azimuth=118.71570411333808°, elevation=-7.2507276199329365°, zenith=97.25072761993293°)\n SolPos(azimuth=130.29762502910458°, elevation=0.29020843900144433°, zenith=89.70979156099855°)\n ⋮\n SolPos(azimuth=224.18912990939398°, elevation=3.260699920923798°, zenith=86.7393000790762°)\n SolPos(azimuth=236.06457094625256°, elevation=-3.7583471248153963°, zenith=93.7583471248154°)\n SolPos(azimuth=247.37238100897753°, elevation=-11.809776441149609°, zenith=101.80977644114961°)\n SolPos(azimuth=258.49365667002763°, elevation=-20.547744929283503°, zenith=110.54774492928351°)\n SolPos(azimuth=269.9637073278627°, elevation=-29.640398102549234°, zenith=119.64039810254924°)\n SolPos(azimuth=282.5429720048338°, elevation=-38.72506027778869°, zenith=128.72506027778869°)\n SolPos(azimuth=297.3622699585723°, elevation=-47.31978544642601°, zenith=137.319785446426°)\n SolPos(azimuth=316.0254562973933°, elevation=-54.664978115106°, zenith=144.664978115106°)\n SolPos(azimuth=339.9570276073531°, elevation=-59.541354504666444°, zenith=149.54135450466646°) Info The returned datastructure is a  StructArray  from the  StructArrays.jl  package, which behaves similarly to a vector of  SolPos   structs but is more convenient to work with. The returned  StructArray  can be easily converted to a  DataFrame  for inspection: df = DataFrame(positions)\ndf.datetime = dts  # add datetime information\nfirst(df, 5)  # show first 5 entries 5×4 DataFrame Row azimuth elevation zenith datetime Float64 Float64 Float64 ZonedDat… 1 339.914 -59.5166 149.517 2023-01-01T00:00:00+01:00 2 7.6467 -60.5153 150.515 2023-01-01T01:00:00+01:00 3 33.7745 -57.2483 147.248 2023-01-01T02:00:00+01:00 4 54.7262 -50.8399 140.84 2023-01-01T03:00:00+01:00 5 71.0627 -42.6905 132.691 2023-01-01T04:00:00+01:00"},{"id":108,"pagetitle":"Getting Started","title":"Broadcasting Over Multiple Locations","ref":"/SolarPosition/stable/guides/getting-started/#Broadcasting-Over-Multiple-Locations","content":" Broadcasting Over Multiple Locations Thanks to Julia's broadcasting syntax it is trivial to calculate solar positions for multiple locations simultaneously. This can be useful for example when analyzing solar irradiance over a geographic region with multiple measurement stations. # Create observers at different latitudes\nobservers = Observer.([10.0, 20.0, 30.0], 10.0)\n\n# Calculate solar position for all locations at a specific time\ndt = DateTime(2020)\npositions_broadcast = solar_position.(observers, dt) 3-element Vector{SolPos{Float64}}:\n SolPos(azimuth=147.08595651159953°, elevation=-74.2404333846635°, zenith=164.2404333846635°)\n SolPos(azimuth=111.26231927619081°, elevation=-80.88815080646037°, zenith=170.88815080646037°)\n SolPos(azimuth=52.099061930554754°, elevation=-79.220339417286°, zenith=169.220339417286°)"},{"id":111,"pagetitle":"Building models with ModelingToolkit.jl","title":"Building models with ModelingToolkit.jl","ref":"/SolarPosition/stable/guides/modelingtoolkit/#Building-models-with-ModelingToolkit.jl","content":" Building models with ModelingToolkit.jl SolarPosition.jl provides a  ModelingToolkit.jl  extension that enables integration of solar position calculations into symbolic modeling workflows. This allows you to compose solar position components with other physical systems for applications like solar energy modeling, building thermal analysis, and solar tracking systems."},{"id":112,"pagetitle":"Building models with ModelingToolkit.jl","title":"Installation","ref":"/SolarPosition/stable/guides/modelingtoolkit/#Installation","content":" Installation The ModelingToolkit extension is loaded automatically when both  SolarPosition.jl  and  ModelingToolkit.jl  are loaded: using SolarPosition\nusing ModelingToolkit"},{"id":113,"pagetitle":"Building models with ModelingToolkit.jl","title":"Quick Start","ref":"/SolarPosition/stable/guides/modelingtoolkit/#Quick-Start","content":" Quick Start The extension provides the  SolarPositionBlock  component, which outputs solar azimuth, elevation, and zenith angles as time-varying quantities. using SolarPosition\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t\nusing Dates\nusing OrdinaryDiffEq # Create a solar position block\n@named sun = SolarPositionBlock()\n\n# Define observer location and reference time\nobs = Observer(51.50274937708521, -0.17782150375214803, 15.0)  # Natural History Museum\nt0 = DateTime(2024, 6, 21, 12, 0, 0)  # Summer solstice noon\n\n# Compile the system\nsys = mtkcompile(sun)\n\n# Set parameters using the compiled system's parameter references\npmap = [\n    sys.observer => obs,\n    sys.t0 => t0,\n    sys.algorithm => PSA(),\n    sys.refraction => NoRefraction(),\n]\n\n# Solve over 24 hours (time in seconds)\ntspan = (0.0, 86400.0)\nprob = ODEProblem(sys, pmap, tspan)\nsol = solve(prob; saveat = 3600.0)  # Save every hour\n\n# Show some results\nprintln(\"Solar position at noon (t=12 hours):\")\nprintln(\"  Azimuth: \", round(sol[sys.azimuth][1], digits=2), \"°\")\nprintln(\"  Elevation: \", round(sol[sys.elevation][1], digits=2), \"°\")\nprintln(\"  Zenith: \", round(sol[sys.zenith][1], digits=2), \"°\") Solar position at noon (t=12 hours):\n  Azimuth: 178.72°\n  Elevation: 61.93°\n  Zenith: 28.07°"},{"id":114,"pagetitle":"Building models with ModelingToolkit.jl","title":"SolarPositionBlock","ref":"/SolarPosition/stable/guides/modelingtoolkit/#SolarPositionBlock","content":" SolarPositionBlock The  SolarPositionBlock  is a  ModelingToolkit.jl  component that computes solar position angles based on time, observer location, and chosen positioning and refraction algorithms. SolarPosition.SolarPositionBlock  —  Function Return a  ModelingToolkit.jl  component that computes solar position as a function of time and can be integrated into symbolic modeling workflows. The  SolarPositionBlock  is a  System  which exposes  azimuth ,  elevation , and  zenith  as output variables computed from the simulation time  t  (in seconds) relative to a reference time  t0 . Note This function requires  ModelingToolkit.jl  to be loaded. The extension is automatically loaded when both  SolarPosition.jl  and  ModelingToolkit.jl  are available. Parameters observer::Observer : location (latitude, longitude, altitude). See  Observer t0::DateTime : Reference time (time when simulation time  t = 0 ) algorithm::SolarAlgorithm : Solar positioning algorithm (default:  PSA ) refraction::RefractionAlgorithm : Atmospheric refraction correction (default:  NoRefraction ) Variables (Outputs) azimuth(t) : Solar azimuth angle in degrees (0° = North, 90° = East, 180° = South, 270° = West) elevation(t) : Solar elevation angle in degrees (angle above horizon, positive when sun is visible) zenith(t) : Solar zenith angle in degrees (angle from vertical, complementary to elevation:  zenith = 90° - elevation ) Time Convention The simulation time  t  (accessed via  t_nounits ) is in  seconds  from the reference time  t0 . For example: t = 0  corresponds to  t0 t = 3600  corresponds to  t0 + 1 hour t = 86400  corresponds to  t0 + 24 hours Example using SolarPosition, ModelingToolkit\nusing ModelingToolkit: t_nounits as t, @named, mtkcompile\nusing Dates\nusing OrdinaryDiffEq: ODEProblem, solve\n\n@named sun = SolarPositionBlock()\nobs = Observer(51.5, -0.18, 15.0)\nt0 = DateTime(2024, 6, 21, 12, 0, 0)\n\nsys = mtkcompile(sun)\npmap = [\n    sys.observer => obs,\n    sys.t0 => t0,\n    sys.algorithm => PSA(),\n    sys.refraction => NoRefraction(),\n]\n\nprob = ODEProblem(sys, pmap, (0.0, 86400.0))\nsol = solve(prob; saveat = 3600.0) source"},{"id":115,"pagetitle":"Building models with ModelingToolkit.jl","title":"Composing with Other Systems","ref":"/SolarPosition/stable/guides/modelingtoolkit/#Composing-with-Other-Systems","content":" Composing with Other Systems The real power of the ModelingToolkit extension comes from composing solar position with other physical systems."},{"id":116,"pagetitle":"Building models with ModelingToolkit.jl","title":"Example: Solar Panel Power Model","ref":"/SolarPosition/stable/guides/modelingtoolkit/#Example:-Solar-Panel-Power-Model","content":" Example: Solar Panel Power Model using CairoMakie: Figure, Axis, lines!\n\n# Create solar position block\n@named sun = SolarPositionBlock()\n\n# Create a simple solar panel model\n@parameters begin\n    area = 10.0           # Panel area (m²)\n    efficiency = 0.2      # Panel efficiency (20%)\n    dni_peak = 1000.0     # Peak direct normal irradiance (W/m²)\nend\n\n@variables begin\n    irradiance(t) = 0.0   # Effective irradiance on panel (W/m²)\n    power(t) = 0.0        # Power output (W)\nend\n\n# Simplified model: irradiance depends on sun elevation\n# In reality, you'd account for panel orientation, azimuth, etc.\neqs = [\n    irradiance ~ dni_peak * max(0, sind(sun.elevation)),\n    power ~ area * efficiency * irradiance,\n]\n\n# Compose the complete system\n@named model = System(eqs, t; systems = [sun])\nsys_model = mtkcompile(model)\n\n# Set up and solve\nobs = Observer(37.7749, -122.4194, 100.0)\nt0 = DateTime(2024, 6, 21, 0, 0, 0)\n\npmap = [\n    sys_model.sun.observer => obs,\n    sys_model.sun.t0 => t0,\n    sys_model.sun.algorithm => PSA(),\n    sys_model.sun.refraction => NoRefraction(),\n]\n\nprob = ODEProblem(sys_model, pmap, (0.0, 86400.0))\nsol = solve(prob; saveat = 600.0)  # Save every 10 minutes\n\n# Plot results\nfig = Figure(size = (1000, 400))\n\nax1 = Axis(fig[1, 1]; xlabel = \"Time (hours)\", ylabel = \"Elevation (°)\", title = \"Solar Elevation\")\nlines!(ax1, sol.t ./ 3600, sol[sys_model.sun.elevation])\n\nax2 = Axis(fig[1, 2]; xlabel = \"Time (hours)\", ylabel = \"Power (W)\", title = \"Solar Panel Power\")\nlines!(ax2, sol.t ./ 3600, sol[sys_model.power])\n\nfig"},{"id":117,"pagetitle":"Building models with ModelingToolkit.jl","title":"Example: Building Thermal Model with Solar Gain","ref":"/SolarPosition/stable/guides/modelingtoolkit/#Example:-Building-Thermal-Model-with-Solar-Gain","content":" Example: Building Thermal Model with Solar Gain using CairoMakie: Figure, Axis, lines!\nusing ModelingToolkit: D_nounits as D\n\n# Solar position component\n@named sun = SolarPositionBlock()\n\n# Building thermal model with solar gain\n@parameters begin\n    mass = 1000.0         # Thermal mass (kg)\n    cp = 1000.0           # Specific heat capacity (J/(kg·K))\n    U = 0.5               # Overall heat transfer coefficient (W/(m²·K))\n    wall_area = 50.0      # Wall area (m²)\n    window_area = 5.0     # Window area (m²)\n    window_trans = 0.7    # Window transmittance\n    T_outside = 20.0      # Outside temperature (°C)\n    dni_peak = 800.0      # Peak solar irradiance (W/m²)\nend\n\n@variables begin\n    T(t) = 20.0           # Room temperature (°C)\n    Q_loss(t)             # Heat loss through walls (W)\n    Q_solar(t)            # Solar heat gain (W)\n    irradiance(t)         # Solar irradiance (W/m²)\nend\n\neqs = [\n    # Solar irradiance based on sun elevation\n    irradiance ~ dni_peak * max(0, sind(sun.elevation)),\n    # Solar heat gain through windows\n    Q_solar ~ window_area * window_trans * irradiance,\n    # Heat loss through walls\n    Q_loss ~ U * wall_area * (T - T_outside),\n    # Energy balance\n    D(T) ~ (Q_solar - Q_loss) / (mass * cp),\n]\n\n@named building = System(eqs, t; systems = [sun])\nsys_building = mtkcompile(building)\n\n# Simulate\nobs = Observer(40.7128, -74.0060, 100.0)  # New York City\nt0 = DateTime(2024, 6, 21, 0, 0, 0)\n\npmap = [\n    sys_building.sun.observer => obs,\n    sys_building.sun.t0 => t0,\n    sys_building.sun.algorithm => PSA(),\n    sys_building.sun.refraction => NoRefraction(),\n]\n\nprob = ODEProblem(sys_building, pmap, (0.0, 86400.0))\nsol = solve(prob; saveat = 600.0)\n\n# Plot temperature evolution\nfig = Figure(size = (1200, 400))\n\nax1 = Axis(fig[1, 1]; xlabel = \"Time (hours)\", ylabel = \"Temperature (°C)\", title = \"Room Temperature\")\nlines!(ax1, sol.t ./ 3600, sol[sys_building.T])\n\nax2 = Axis(fig[1, 2]; xlabel = \"Time (hours)\", ylabel = \"Solar Gain (W)\", title = \"Solar Heat Gain\")\nlines!(ax2, sol.t ./ 3600, sol[sys_building.Q_solar])\n\nax3 = Axis(fig[1, 3]; xlabel = \"Time (hours)\", ylabel = \"Elevation (°)\", title = \"Sun Elevation\")\nlines!(ax3, sol.t ./ 3600, sol[sys_building.sun.elevation])\n\nfig"},{"id":118,"pagetitle":"Building models with ModelingToolkit.jl","title":"Implementation Details","ref":"/SolarPosition/stable/guides/modelingtoolkit/#Implementation-Details","content":" Implementation Details The extension works by registering the  solar_position  function and helper functions as symbolic operations in ModelingToolkit. The actual solar position calculation happens during ODE solving, with the simulation time  t  being converted to a  DateTime  relative to the reference time  t0 ."},{"id":119,"pagetitle":"Building models with ModelingToolkit.jl","title":"Limitations","ref":"/SolarPosition/stable/guides/modelingtoolkit/#Limitations","content":" Limitations The solar position calculation is treated as a black-box function by MTK's symbolic engine, so its internals cannot be symbolically simplified."},{"id":120,"pagetitle":"Building models with ModelingToolkit.jl","title":"See Also","ref":"/SolarPosition/stable/guides/modelingtoolkit/#See-Also","content":" See Also Solar Positioning  - Available positioning algorithms Refraction Correction  - Atmospheric refraction methods ModelingToolkit.jl Documentation  - MTK framework documentation"},{"id":123,"pagetitle":"Adding a New Solar Position Algorithm","title":"Adding a New Solar Position Algorithm","ref":"/SolarPosition/stable/guides/new-algorithm/#new-algorithm","content":" Adding a New Solar Position Algorithm This tutorial walks you through the process of adding a new solar positioning algorithm to  SolarPosition.jl . We'll implement a simplified algorithm step by step, covering all the necessary components: the algorithm struct, core computation, refraction handling, exports, and tests."},{"id":124,"pagetitle":"Adding a New Solar Position Algorithm","title":"Overview","ref":"/SolarPosition/stable/guides/new-algorithm/#Overview","content":" Overview Adding a new algorithm involves these steps: Create the algorithm struct  - Define a type that subtypes  SolarAlgorithm . Implement the core function  - Write  _solar_position  for your algorithm. Handle refraction  - Define how your algorithm interacts with  DefaultRefraction . Export the algorithm  - Make it available to users. Write tests  - Validate correctness against reference values. Document  - Add docstrings and update documentation. Run pre-commit checks  - Ensure code quality and formatting. Underscore Note the underscore prefix in  _solar_position . This function is internal and should not be called directly by users. Instead, they will use the public  solar_position  function, which dispatches to your implementation based on the algorithm type struct."},{"id":125,"pagetitle":"Adding a New Solar Position Algorithm","title":"Step 1: Create the Algorithm Struct","ref":"/SolarPosition/stable/guides/new-algorithm/#step-1-create-struct","content":" Step 1: Create the Algorithm Struct Create a new file in  src/Positioning/  for your algorithm. For this example, we'll create a simplified algorithm called  SimpleAlgorithm . The struct must: Subtype  SolarAlgorithm Include a docstring with  TYPEDEF  and  TYPEDFIELDS  macros Document accuracy and provide literature references # src/Positioning/simple.jl\n\n\"\"\"\n    \\$(TYPEDEF)\n\nSimple solar position algorithm for demonstration purposes.\n\nThis algorithm uses basic spherical trigonometry to compute solar positions.\nIt is provided as a teaching example and is NOT suitable for production use.\n\n# Accuracy\nThis is a simplified algorithm with limited accuracy (±1°).\n\n# Literature\nBased on basic solar geometry principles.\n\n# Fields\n\\$(TYPEDFIELDS)\n\"\"\"\nstruct SimpleAlgorithm <: SolarAlgorithm\n    \"Optional configuration parameter\"\n    param::Float64\nend\n\n# Provide a default constructor\nSimpleAlgorithm() = SimpleAlgorithm(1.0)"},{"id":126,"pagetitle":"Adding a New Solar Position Algorithm","title":"Step 2: Implement the Core Function","ref":"/SolarPosition/stable/guides/new-algorithm/#step-2-implement-core","content":" Step 2: Implement the Core Function The core of any algorithm is the  _solar_position  function. This function: Takes an  Observer ,  DateTime , and your algorithm type Returns a  SolPos{T}  with azimuth, elevation, and zenith angles Should be type-stable and performant Here's the basic structure: function _solar_position(obs::Observer{T}, dt::DateTime, alg::SimpleAlgorithm) where {T}\n    # 1. Convert datetime to Julian date\n    jd = datetime2julian(dt)\n\n    # 2. Calculate days since J2000.0 epoch\n    n = jd - 2451545.0\n\n    # 3. Compute solar coordinates (declination, hour angle, etc.)\n    # ... your algorithm's calculations here ...\n\n    # 4. Calculate local horizontal coordinates\n    # ... azimuth and elevation calculations ...\n\n    # 5. Return the result\n    return SolPos{T}(azimuth_deg, elevation_deg, zenith_deg)\nend"},{"id":127,"pagetitle":"Adding a New Solar Position Algorithm","title":"Key Implementation Notes","ref":"/SolarPosition/stable/guides/new-algorithm/#Key-Implementation-Notes","content":" Key Implementation Notes Use helper functions  from  utils.jl : fractional_hour(dt)  - Convert time to decimal hours deg2rad(x)  /  rad2deg(x)  - Angle conversions Observer properties  are pre-computed for efficiency: obs.latitude ,  obs.longitude ,  obs.altitude  - Input values obs.latitude_rad ,  obs.longitude_rad  - Radians versions obs.sin_lat ,  obs.cos_lat  - Precomputed trigonometric values Type parameter  T  ensures numerical precision is preserved from the  Observer Angle conventions : Azimuth: 0° = North, positive clockwise, range [0°, 360°] Elevation: angle above horizon, range [-90°, 90°] Zenith: 90° - elevation, range [0°, 180°]"},{"id":128,"pagetitle":"Adding a New Solar Position Algorithm","title":"Step 3: Handle Default Refraction","ref":"/SolarPosition/stable/guides/new-algorithm/#step-3-handle-refraction","content":" Step 3: Handle Default Refraction Each algorithm must specify how it handles  DefaultRefraction . There are two common patterns:"},{"id":129,"pagetitle":"Adding a New Solar Position Algorithm","title":"Pattern A: No Refraction by Default (like PSA)","ref":"/SolarPosition/stable/guides/new-algorithm/#Pattern-A:-No-Refraction-by-Default-(like-[PSA](@ref-SolarPosition.Positioning.PSA))","content":" Pattern A: No Refraction by Default (like  PSA ) If your algorithm should NOT apply refraction by default: function _solar_position(obs, dt, alg::SimpleAlgorithm, ::DefaultRefraction)\n    return _solar_position(obs, dt, alg, NoRefraction())\nend\n\n# Return type for DefaultRefraction\nresult_type(::Type{SimpleAlgorithm}, ::Type{DefaultRefraction}, ::Type{T}) where {T} =\n    SolPos{T}"},{"id":130,"pagetitle":"Adding a New Solar Position Algorithm","title":"Pattern B: Apply Refraction by Default (like NOAA)","ref":"/SolarPosition/stable/guides/new-algorithm/#Pattern-B:-Apply-Refraction-by-Default-(like-[NOAA](@ref-SolarPosition.Positioning.NOAA))","content":" Pattern B: Apply Refraction by Default (like  NOAA ) If your algorithm should apply a specific refraction model by default: using ..Refraction: HUGHES, DefaultRefraction\n\nfunction _solar_position(obs, dt, alg::SimpleAlgorithm, ::DefaultRefraction)\n    return _solar_position(obs, dt, alg, HUGHES())\nend\n\n# Return type for DefaultRefraction\nresult_type(::Type{SimpleAlgorithm}, ::Type{DefaultRefraction}, ::Type{T}) where {T} =\n    ApparentSolPos{T} The  result_type  function tells the system what return type to expect, enabling type-stable code for vectorized operations."},{"id":131,"pagetitle":"Adding a New Solar Position Algorithm","title":"Step 4: Export the Algorithm","ref":"/SolarPosition/stable/guides/new-algorithm/#step-4-export","content":" Step 4: Export the Algorithm After implementing your algorithm, you need to export it so users can access it."},{"id":132,"pagetitle":"Adding a New Solar Position Algorithm","title":"4.1 Include in Positioning Module","ref":"/SolarPosition/stable/guides/new-algorithm/#4.1-Include-in-Positioning-Module","content":" 4.1 Include in Positioning Module Edit  src/Positioning/Positioning.jl  to include your new file: # Near the bottom of the file, with other includes\ninclude(\"utils.jl\")\ninclude(\"deltat.jl\")\ninclude(\"psa.jl\")\ninclude(\"noaa.jl\")\ninclude(\"walraven.jl\")\ninclude(\"usno.jl\")\ninclude(\"spa.jl\")\ninclude(\"simple.jl\")  # Add your new file\n\n# Add to the export list\nexport Observer,\n    PSA,\n    NOAA,\n    Walraven,\n    USNO,\n    SPA,\n    SimpleAlgorithm,  # Add your algorithm\n    solar_position,\n    solar_position!,\n    SolPos,\n    ApparentSolPos,\n    SPASolPos"},{"id":133,"pagetitle":"Adding a New Solar Position Algorithm","title":"4.2 Export from Main Module","ref":"/SolarPosition/stable/guides/new-algorithm/#4.2-Export-from-Main-Module","content":" 4.2 Export from Main Module Edit  src/SolarPosition.jl  to re-export your algorithm: using .Positioning:\n    Observer, PSA, NOAA, Walraven, USNO, SPA, SimpleAlgorithm, solar_position, solar_position!\n\n# ... later in exports ...\nexport PSA, NOAA, Walraven, USNO, SPA, SimpleAlgorithm"},{"id":134,"pagetitle":"Adding a New Solar Position Algorithm","title":"Step 5: Write Tests","ref":"/SolarPosition/stable/guides/new-algorithm/#step-5-write-tests","content":" Step 5: Write Tests Create a test file following the naming convention  test/test-simple.jl . Generating Validation Data It is required to validate your algorithm against known reference values. You can use a reference implementation of your algorithm (if available) or compare against trusted solar position calculators. Store these reference values in your test file and use  @test  statements to ensure your implementation matches them. See the existing test files like  test/test-psa.jl  for examples of how to structure these tests."},{"id":135,"pagetitle":"Adding a New Solar Position Algorithm","title":"Running Tests","ref":"/SolarPosition/stable/guides/new-algorithm/#Running-Tests","content":" Running Tests Tests are automatically discovered by  runtests.jl . Run them with: julia --project=. -e 'using Pkg; Pkg.test()' Or from the Julia REPL: using Pkg\nPkg.activate(\".\")\nPkg.test()"},{"id":136,"pagetitle":"Adding a New Solar Position Algorithm","title":"Step 6: Document Your Algorithm","ref":"/SolarPosition/stable/guides/new-algorithm/#step-6-document","content":" Step 6: Document Your Algorithm"},{"id":137,"pagetitle":"Adding a New Solar Position Algorithm","title":"Add to Documentation Pages","ref":"/SolarPosition/stable/guides/new-algorithm/#Add-to-Documentation-Pages","content":" Add to Documentation Pages Update  docs/src/positioning.md  to include your algorithm in the algorithm reference section."},{"id":138,"pagetitle":"Adding a New Solar Position Algorithm","title":"Add Literature References","ref":"/SolarPosition/stable/guides/new-algorithm/#Add-Literature-References","content":" Add Literature References If your algorithm is based on published work, add the reference to  docs/src/refs.bib : @article{YourReference,\n    author = {Author Name},\n    title = {Algorithm Title},\n    journal = {Journal Name},\n    year = {2024},\n    volume = {1},\n    pages = {1-10}\n} Then cite it in your docstring using  [YourReference](@cite) ."},{"id":139,"pagetitle":"Adding a New Solar Position Algorithm","title":"Step 7: Run Pre-commit Checks (Recommended)","ref":"/SolarPosition/stable/guides/new-algorithm/#step-7-precommit","content":" Step 7: Run Pre-commit Checks (Recommended) Before submitting a pull request, it's recommended to run pre-commit hooks locally to catch formatting and linting issues early. This saves time during code review and ensures your code meets the project's quality standards. The pre-commit configuration is defined in the  .pre-commit-config.yaml  file at the root of the repository. CI Runs Pre-commit Even if you skip this step locally, GitHub CI will automatically run pre-commit checks on your pull request. However, running them locally first helps you catch and fix issues before pushing."},{"id":140,"pagetitle":"Adding a New Solar Position Algorithm","title":"Installing Pre-commit","ref":"/SolarPosition/stable/guides/new-algorithm/#Installing-Pre-commit","content":" Installing Pre-commit # Install pre-commit (requires Python)\npip install pre-commit\n\n# Install the git hooks (run once per clone)\npre-commit install"},{"id":141,"pagetitle":"Adding a New Solar Position Algorithm","title":"Running Pre-commit","ref":"/SolarPosition/stable/guides/new-algorithm/#Running-Pre-commit","content":" Running Pre-commit # Run all hooks on all files\npre-commit run --all-files\n\n# Or run on staged files only\npre-commit run Pre-commit runs several checks including: JuliaFormatter  - Ensures consistent code formatting ExplicitImports  - Checks for explicit imports markdownlint  - Lints markdown files typos  - Catches common spelling mistakes If any checks fail, fix the issues and run pre-commit again until all checks pass."},{"id":142,"pagetitle":"Adding a New Solar Position Algorithm","title":"Checklist","ref":"/SolarPosition/stable/guides/new-algorithm/#Checklist","content":" Checklist Before submitting your algorithm for review, ensure you've completed the following: Task Description Algorithm struct Subtypes  SolarAlgorithm Docstring Includes  TYPEDEF ,  TYPEDFIELDS , accuracy, and references _solar_position Function implemented with correct signature Default refraction Handling defined for  DefaultRefraction result_type Function defined for  DefaultRefraction Export Algorithm exported from both modules Tests Cover basic functionality, refraction, vectors, and edge cases Test coverage Ensure tests cover all new code paths Pre-commit Checks pass (recommended locally, required in CI) Documentation Update algorithm lists in  positioning.md ,  README.md , and  refraction.md Literature References added to  refs.bib  and cited in docstrings"},{"id":143,"pagetitle":"Adding a New Solar Position Algorithm","title":"Additional Resources","ref":"/SolarPosition/stable/guides/new-algorithm/#Additional-Resources","content":" Additional Resources See existing implementations in  src/Positioning/  for reference: psa.jl  - Simple algorithm with no default refraction ( PSA ) noaa.jl  - Algorithm with default  HUGHES  refraction ( NOAA ) spa.jl  - Complex algorithm with additional output fields ( SPA ) Check the  Contributing Guidelines  for general contribution workflow Review the  Solar Positioning Algorithms  page for context"},{"id":146,"pagetitle":"Parallel Computing with OhMyThreads.jl","title":"Parallel Computing with OhMyThreads.jl","ref":"/SolarPosition/stable/guides/parallel/#parallel-computing","content":" Parallel Computing with OhMyThreads.jl SolarPosition.jl provides a parallel computing extension using  OhMyThreads.jl  for efficient multithreaded solar position calculations across large time series. This extension is particularly useful when processing thousands of timestamps, where parallelization can provide significant speedups."},{"id":147,"pagetitle":"Parallel Computing with OhMyThreads.jl","title":"Installation","ref":"/SolarPosition/stable/guides/parallel/#Installation","content":" Installation The OhMyThreads extension is loaded automatically when both  SolarPosition.jl  and  OhMyThreads.jl  are loaded: using SolarPosition\nusing OhMyThreads Thread Configuration Julia must be started with multiple threads to benefit from parallelization. Use  julia --threads=auto  or set the  JULIA_NUM_THREADS  environment variable. Check the number of available threads with  Threads.nthreads() ."},{"id":148,"pagetitle":"Parallel Computing with OhMyThreads.jl","title":"Quick Start","ref":"/SolarPosition/stable/guides/parallel/#Quick-Start","content":" Quick Start The extension adds new methods to  solar_position  and  solar_position!  that accept an  OhMyThreads.Scheduler  as the last argument. These methods automatically parallelize computations across the provided timestamp vector. using SolarPosition\nusing OhMyThreads\nusing Dates\nusing StructArrays\n\n# Create observer location\nobs = Observer(51.5, -0.18, 15.0)  # London\n\n# Generate a year of minute timestamps\ntimes = collect(DateTime(2024, 1, 1):Minute(1):DateTime(2025, 1, 1))\n\n# Parallel computation with DynamicScheduler\nt0 = time()\npositions = solar_position(obs, times, PSA(), NoRefraction(), DynamicScheduler())\ndt_parallel = time() - t0\nprintln(\"Time taken (parallel): $(round(dt_parallel, digits=5)) seconds\") Time taken (parallel): 0.77582 seconds Now we compare this to the serial version: # Serial computation (no scheduler argument)\nt0 = time()\npositions_serial = solar_position(obs, times, PSA(), NoRefraction())\ndt_serial = time() - t0\nprintln(\"Time taken (serial): $(round(dt_serial, digits=5)) seconds\") Time taken (serial): 0.1098 seconds We observe a speedup of: speedup = dt_serial / dt_parallel\nprintln(\"Speedup: $(round(speedup, digits=2))×\") Speedup: 0.14×"},{"id":149,"pagetitle":"Parallel Computing with OhMyThreads.jl","title":"Simplified Syntax","ref":"/SolarPosition/stable/guides/parallel/#Simplified-Syntax","content":" Simplified Syntax You can also use the simplified syntax with the scheduler as the third argument, which uses the default algorithm (PSA) and no refraction correction: # Simplified syntax with default algorithm\npositions = solar_position(obs, times, DynamicScheduler())\n@show first(positions, 3) 3-element StructArray(::Vector{Float64}, ::Vector{Float64}, ::Vector{Float64}) with eltype SolPos{Float64}:\n SolPos(azimuth=358.1624783703248°, elevation=-61.55014545423738°, zenith=151.5501454542374°)\n SolPos(azimuth=358.64510532358224°, elevation=-61.554425651495485°, zenith=151.55442565149548°)\n SolPos(azimuth=359.12783221156707°, elevation=-61.55739562548632°, zenith=151.55739562548632°)"},{"id":150,"pagetitle":"Parallel Computing with OhMyThreads.jl","title":"Available Schedulers","ref":"/SolarPosition/stable/guides/parallel/#Available-Schedulers","content":" Available Schedulers OhMyThreads.jl provides different scheduling strategies optimized for various workload characteristics:"},{"id":151,"pagetitle":"Parallel Computing with OhMyThreads.jl","title":"DynamicScheduler","ref":"/SolarPosition/stable/guides/parallel/#DynamicScheduler","content":" DynamicScheduler The  DynamicScheduler  is the default and recommended scheduler for most workloads. It dynamically balances tasks among threads, making it suitable for non-uniform workloads where computation times may vary. Please visit the  OhMyThreads.jl  documentation for more details. # Dynamic scheduling (recommended)\npositions = solar_position(obs, times, PSA(), NoRefraction(), DynamicScheduler());"},{"id":152,"pagetitle":"Parallel Computing with OhMyThreads.jl","title":"StaticScheduler","ref":"/SolarPosition/stable/guides/parallel/#StaticScheduler","content":" StaticScheduler The  StaticScheduler  partitions work statically among threads. This can be more efficient for uniform workloads where all computations take approximately the same time. # Static scheduling for uniform workloads\npositions = solar_position(obs, times, PSA(), NoRefraction(), StaticScheduler())"},{"id":153,"pagetitle":"Parallel Computing with OhMyThreads.jl","title":"In-Place Computation","ref":"/SolarPosition/stable/guides/parallel/#In-Place-Computation","content":" In-Place Computation For maximum performance and minimal allocations, use the in-place version  solar_position!  with a pre-allocated  StructVector : using StructArrays\n\n# Pre-allocate output array\npositions = StructVector{SolPos{Float64}}(undef, length(times))\n\n# Compute in-place\nsolar_position!(positions, obs, times, PSA(), NoRefraction(), DynamicScheduler()) The in-place version avoids allocating the output array and minimizes intermediate allocations, making it ideal for repeated computations or memory-constrained environments."},{"id":154,"pagetitle":"Parallel Computing with OhMyThreads.jl","title":"Performance Comparison","ref":"/SolarPosition/stable/guides/parallel/#Performance-Comparison","content":" Performance Comparison Here's a typical performance comparison between serial and parallel execution: using BenchmarkTools\n\n### Serial execution (no scheduler argument)\n@benchmark solar_position($obs, $times, PSA(), NoRefraction())\n# BenchmarkTools.Trial: 57 samples with 1 evaluation per sample.\n#  Range (min … max):  83.994 ms … 98.110 ms  ┊ GC (min … max): 0.00% … 12.50%\n#  Time  (median):     87.907 ms              ┊ GC (median):    0.66%\n#  Time  (mean ± σ):   88.194 ms ±  2.478 ms  ┊ GC (mean ± σ):  1.39% ±  2.23%\n\n#                ▁             █\n#   ▆▁▄▁▁▁▇▆▆▁▁▇▄█▄▁▇▆▇▇▄▄▁▄▄▆▆█▆▆▄▁▆▁▁▆▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▄ ▁\n#   84 ms           Histogram: frequency by time        95.8 ms <\n\n#  Memory estimate: 12.06 MiB, allocs estimate: 9.\n\n### Parallel execution with DynamicScheduler\n@benchmark solar_position($obs, $times, PSA(), NoRefraction(), DynamicScheduler())\n# BenchmarkTools.Trial: 312 samples with 1 evaluation per sample.\n#  Range (min … max):   7.588 ms … 35.575 ms  ┊ GC (min … max):  0.00% … 74.79%\n#  Time  (median):     14.718 ms              ┊ GC (median):     6.16%\n#  Time  (mean ± σ):   16.026 ms ±  6.387 ms  ┊ GC (mean ± σ):  23.51% ± 19.37%\n\n#     ▆▆█▁▃▂▅ ▁▁▁▄▁▃▅▁  ▁▄ ▁\n#   █▇███████▄████████▇▄██▆█▇▆▇█▅▆▅▆▄▄▁▅▄▁▁▄▃▄▅▄▃▃▄▃▄▆▃▃▁▄▄▁▃▁▃ ▄\n#   7.59 ms         Histogram: frequency by time        34.4 ms <\n\n#  Memory estimate: 66.59 MiB, allocs estimate: 468.\n\n### In-place parallel execution\npos = StructVector{SolPos{Float64}}(undef, length(times))\n@benchmark solar_position!($pos, $obs, $times, PSA(), NoRefraction(), DynamicScheduler())\n# BenchmarkTools.Trial: 908 samples with 1 evaluation per sample.\n#  Range (min … max):  4.061 ms …   7.846 ms  ┊ GC (min … max): 0.00% … 0.00%\n#  Time  (median):     5.532 ms               ┊ GC (median):    0.00%\n#  Time  (mean ± σ):   5.501 ms ± 644.881 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n#                                ▃▅█▄▂▂       ▁\n#   ▃▄▅▃▄▃▃▅▃▄▃▁▃▂▃▄▂▃▂▂▃▂▂▃▂▅▃▃████████▆▅▅▄▆▅██▅▅▆▄▅▄▃▂▃▃▃▃▃▂▂ ▃\n#   4.06 ms         Histogram: frequency by time        6.72 ms <\n\n#  Memory estimate: 20.47 KiB, allocs estimate: 284.\n\n### In-place parallel execution with StaticScheduler\n@benchmark solar_position!($pos, $obs, $times, PSA(), NoRefraction(), StaticScheduler())\n# BenchmarkTools.Trial: 902 samples with 1 evaluation per sample.\n#  Range (min … max):  4.027 ms …   7.228 ms  ┊ GC (min … max): 0.00% … 0.00%\n#  Time  (median):     5.842 ms               ┊ GC (median):    0.00%\n#  Time  (mean ± σ):   5.537 ms ± 802.636 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n#  ▃▁   ▁▄▃                       ▁      ▁▅▆█▂▄▇▇▅▁▃    ▁\n#  ██▃▃▅███▅▆▆▄▄▃▃▃▃▃▂▄▅▂▁▃▆▃▃▂▅▃▅█▇▆▂▃▅▅██████████████▇█▆▇▇▂▂ ▄\n#  4.03 ms         Histogram: frequency by time        6.72 ms <\n\n#  Memory estimate: 15.97 KiB, allocs estimate: 220. On a system with 32 threads processing 527,041 timestamps (one year, minutely): Method Time Speedup Allocations Serial 87.9 ms 1.0× 12.06 MiB Parallel (DynamicScheduler) 14.7 ms 6.0× 66.59 MiB In-place (DynamicScheduler) 5.53 ms 15.9× 20.47 KiB In-place (StaticScheduler) 5.84 ms 15.0× 15.97 KiB Performance Tips For the best performance: Use  solar_position!  with pre-allocated output for minimal allocations Use  DynamicScheduler()  for most workloads Ensure Julia is running with multiple threads (e.g.,  --threads=auto ) Process larger batches of timestamps to amortize threading overhead"},{"id":155,"pagetitle":"Parallel Computing with OhMyThreads.jl","title":"Working with Different Time Types","ref":"/SolarPosition/stable/guides/parallel/#Working-with-Different-Time-Types","content":" Working with Different Time Types The parallel methods work with both  DateTime  and  ZonedDateTime : using TimeZones\n\n# Using ZonedDateTime (avoiding DST transitions)\ntz = tz\"Europe/London\"\n# Use a subset of times to avoid DST transition issues in documentation\nsummer_times = collect(DateTime(2024, 6, 1):Hour(1):DateTime(2024, 7, 1))\nzoned_times = ZonedDateTime.(summer_times, tz)\n\n# Parallel computation with time zone aware timestamps\nzoned_positions = solar_position(obs, zoned_times, PSA(), NoRefraction(), DynamicScheduler())\n\nprintln(\"Computed $(length(zoned_positions)) positions with time zone awareness\") Computed 721 positions with time zone awareness"},{"id":156,"pagetitle":"Parallel Computing with OhMyThreads.jl","title":"Algorithm Comparison","ref":"/SolarPosition/stable/guides/parallel/#Algorithm-Comparison","content":" Algorithm Comparison The parallel interface works with all solar position algorithms: # Test different algorithms in parallel\nalgorithms = [PSA(), NOAA(), SPA()]\n\nfor alg in algorithms\n    pos = solar_position(obs, times[1:100], alg, NoRefraction(), DynamicScheduler())\n    println(\"$(typeof(alg).name.name): azimuth=$(round(pos.azimuth[50], digits=5))°\")\nend PSA: azimuth=21.29414°\nNOAA: azimuth=21.29068°\nSPA: azimuth=21.2971°"},{"id":157,"pagetitle":"Parallel Computing with OhMyThreads.jl","title":"Refraction Correction","ref":"/SolarPosition/stable/guides/parallel/#Refraction-Correction","content":" Refraction Correction Atmospheric refraction corrections can be applied in parallel computations: # Parallel computation with Bennett refraction correction\npositions_refracted = solar_position(\n    obs,\n    times,\n    PSA(),\n    BENNETT(),\n    DynamicScheduler()\n)\n\nprintln(\"First position with refraction:\")\nprintln(\"  Apparent elevation: $(round(positions_refracted.apparent_elevation[1], digits=2))°\") First position with refraction:\n  Apparent elevation: -61.56°"},{"id":158,"pagetitle":"Parallel Computing with OhMyThreads.jl","title":"Implementation Details","ref":"/SolarPosition/stable/guides/parallel/#Implementation-Details","content":" Implementation Details The extension uses OhMyThreads'  tmap  and  tmap!  for task-based parallelism. Each timestamp is processed independently, making the computation embarrassingly parallel with no inter-thread communication required. The results from  tmap  are automatically converted to a  StructVector  for efficient columnar storage compatible with the rest of SolarPosition.jl's API."},{"id":159,"pagetitle":"Parallel Computing with OhMyThreads.jl","title":"See Also","ref":"/SolarPosition/stable/guides/parallel/#See-Also","content":" See Also Solar Positioning  - Available positioning algorithms Refraction Correction  - Atmospheric refraction methods OhMyThreads.jl Documentation  - Task-based parallelism framework Julia Threading Documentation  - Julia's threading capabilities"},{"id":162,"pagetitle":"Plotting with Makie.jl","title":"Plotting with Makie.jl","ref":"/SolarPosition/stable/guides/plotting/#plotting-examples","content":" Plotting with Makie.jl SolarPosition.jl provides a plotting extension for  Makie.jl . To use it, simply import both the  SolarPosition  and  Makie  packages: using SolarPosition\nusing CairoMakie\n\n# supporting packages\nusing Dates\nusing TimeZones\nusing DataFrames This example notebook is based on the  pvlib sun path example ."},{"id":163,"pagetitle":"Plotting with Makie.jl","title":"Basic Sun Path Plotting","ref":"/SolarPosition/stable/guides/plotting/#Basic-Sun-Path-Plotting","content":" Basic Sun Path Plotting Let's start by defining an observer location and calculating solar positions for a whole year: # Define observer location (New Delhi, India)\n# Parameters: latitude, longitude, altitude in meters\ntz = tz\"Asia/Kolkata\"\nobs = Observer(28.6, 77.2, 0.0)\n\n# Generate hourly timestamps for a whole year\ntimes = collect(ZonedDateTime(DateTime(2019), tz):Hour(1):ZonedDateTime(DateTime(2020), tz))\n\n# This returns a StructVector with solar position data\npositions = solar_position(obs, times)\n\n# For plotting, we need to create a DataFrame that includes the timestamps\ndf = DataFrame(positions)\ndf.datetime = times\n\n# We can inspect the first few entries\nfirst(df, 5) 5×4 DataFrame Row azimuth elevation zenith datetime Float64 Float64 Float64 ZonedDat… 1 314.042 -82.2189 172.219 2019-01-01T00:00:00+05:30 2 57.3871 -80.2452 170.245 2019-01-01T01:00:00+05:30 3 81.0308 -67.8108 157.811 2019-01-01T02:00:00+05:30 4 90.0973 -54.6909 144.691 2019-01-01T03:00:00+05:30 5 96.4595 -41.5545 131.555 2019-01-01T04:00:00+05:30"},{"id":164,"pagetitle":"Plotting with Makie.jl","title":"Simple Sun Path Plot in Cartesian Coordinates","ref":"/SolarPosition/stable/guides/plotting/#Simple-Sun-Path-Plot-in-Cartesian-Coordinates","content":" Simple Sun Path Plot in Cartesian Coordinates We can visualize solar positions in cartesian coordinates using the  sunpathplot  function: fig = Figure(backgroundcolor = (:white, 0.0), textcolor= \"#f5ab35\")\nax = Axis(fig[1, 1], backgroundcolor = (:white, 0.0))\nsunpathplot!(ax, df, hour_labels = false)\nfig"},{"id":165,"pagetitle":"Plotting with Makie.jl","title":"Polar Coordinates with Hour Labels","ref":"/SolarPosition/stable/guides/plotting/#Polar-Coordinates-with-Hour-Labels","content":" Polar Coordinates with Hour Labels We can also work directly with a  DataFrame . Note that for plotting we need to include the datetime information, so we add it to the DataFrame. Plotting in polar coordinates with  sunpathpolarplot  may yield a more intuitive representation of the solar path. Here, we also enable hourly labels for better readability: fig2 = Figure(backgroundcolor = :transparent, textcolor= \"#f5ab35\", size = (800, 600))\nax2 = PolarAxis(fig2[1, 1], backgroundcolor = \"#1f2424\")\nsunpathpolarplot!(ax2, df, hour_labels = true)\n\n# Draw individual days\nline_objects = []\nfor (date, label) in [(Date(\"2019-03-21\"), \"Mar 21\"),\n                      (Date(\"2019-06-21\"), \"Jun 21\"),\n                      (Date(\"2019-12-21\"), \"Dec 21\")]\n    times = collect(ZonedDateTime(DateTime(date), tz):Minute(5):ZonedDateTime(DateTime(date) + Day(1), tz))\n    solpos = solar_position(obs, times)\n    above_horizon = solpos.elevation .> 0\n    day_df = DataFrame(solpos)\n    day_df.datetime = times\n    day_filtered = day_df[above_horizon, :]\n    line_obj = lines!(ax2, deg2rad.(day_filtered.azimuth), day_filtered.zenith,\n                      linewidth = 2, label = label)\n    push!(line_objects, line_obj)\nend\n\n# Add legend below the plot\nfig2[2, 1] = Legend(fig2, line_objects, [\"Mar 21\", \"Jun 21\", \"Dec 21\"],\n                    orientation = :horizontal, tellheight = true, backgroundcolor = :transparent)\nfig2 The figure-8 patterns are known as  analemmas , which represent the sun's position at the same time of day throughout the year. Note that in polar coordinates, the radial distance from the center represents the zenith angle (90° - elevation). Thus, points closer to the center indicate higher elevations. Conversely, a zenith angle of more than 90° (negative elevation) indicates that the sun is below the horizon. Tracing a path from right to left corresponds to the sun's movement from east to west. It tells us when the sun rises, reaches its highest point, and sets. And hence also the length of the day. From the figure we can also read that in June the days are longest, while in December they are shortest."},{"id":166,"pagetitle":"Plotting with Makie.jl","title":"Plotting without a custom axis","ref":"/SolarPosition/stable/guides/plotting/#Plotting-without-a-custom-axis","content":" Plotting without a custom axis Finally, we can also create plots without explicitly defining an axis beforehand. This is a more concise way to create plots, but it offers less customization: sunpathpolarplot(df, hour_labels = true, colorbar = true)"},{"id":169,"pagetitle":"Literature","title":"Literature","ref":"/SolarPosition/stable/literature/#Literature","content":" Literature [ABO80] C. B. Archer, W. E. Brockett and C. A. Oakes.  Collector Control System Simulation . Solar Energy Technology Conference (1980). Conference paper. [Ben82] G. G. Bennett.  The Calculation of Astronomical Refraction in Marine Navigation .  Journal of Navigation  35 , 255–259  (1982). [BW12] P. Blanc and L. Wald.  The SG2 algorithm for a fast and accurate computation of the position of the Sun for multi-decadal time period .  Solar Energy  86 , 3072–3083  (2012). [BMB20] M. J. Blanco, K. Milidonis and A. M. Bonanos.  Updating the PSA sun position algorithm .  Solar Energy  212 , 339–341  (2020). [BALL01] M. Blanco-Muriel, D. C. Alarcón-Padilla, T. López-Moratalla and M. Lara-Coira.  Computing the solar vector .  Solar Energy  70 , 431–441  (2001). [HDS+21] D. Haputhanthri, D. De Silva, S. Sierla, D. Alahakoon, R. Nawaratne, A. Jennings and V. Vyatkin.  Solar irradiance nowcasting for virtual power plants using multimodal long short-term memory networks . Frontiers in Energy Research  9 , 722212 (2021). [Hug85] G. W. Hughes.  Engineering Astronomy  (Sandia Laboratories, 1985). [Mee91] J. Meeus.  Astronomical Algorithms . 1st Edition (Willmann-Bell, 1991). [Mic88] J. J. Michalsky.  The Astronomical Almanac's algorithm for approximate solar position (1950–2050) .  Solar Energy  40 , 227–235  (1988). [MS04] L. V. Morrison and F. R. Stephenson.  Historical values of the Earth's clock error  $\\Delta$ T and the calculation of eclipses .  Journal for the History of Astronomy  35 , 327–336  (2004). [RA04] I. Reda and A. Andreas.  Solar position algorithm for solar radiation applications .  Solar Energy  76 , 577–589  (2004). Revised 2008. [Spe89] J. W. Spencer.  Comments on The Astronomical Almanac's Algorithm for Approximate Solar Position (1950–2050) .  Solar Energy  42 , 353  (1989). [Wal78] R. Walraven.  Calculating the position of the sun .  Solar Energy  20 , 393–397  (1978). [Wal79] R. Walraven.  Erratum .  Solar Energy  22 , 195  (1979). [Zim81] J. C. Zimmerman.  Sun-pointing programs and their accuracy . Technical Report SAND-81-0761 ( Sandia National Laboratories, 1981 ). [NAS25] NASA Goddard Space Flight Center.  Polynomial Expressions for Delta T ( $\\Delta$ T)  (2025). Accessed: 2025-10-15. [NOA25] NOAA Global Monitoring Laboratory.  Solar Position Calculator  (2025). Accessed: 2025-10-15. [U.S25] U.S. Naval Observatory.  Computing Altitude and Azimuth from Greenwich Apparent Sidereal Time  (2025). Accessed: 2025-10-19. [Wik16] Wikimedia Commons contributors.  Atmospheric refraction: sunset and sunrise ,  https://upload.wikimedia.org/wikipedia/commons/3/39/Atmospheric_refraction_-_sunset_and_sunrise.png  (2016). Image retrieved from Wikimedia Commons."},{"id":172,"pagetitle":"Solar Positioning","title":"Solar Positioning","ref":"/SolarPosition/stable/positioning/#solar-positioning-algorithms","content":" Solar Positioning All solar position algorithms available in  SolarPosition.jl   return solar zenith, elevation, and azimuth angles. Algorithms that include an atmospheric refraction model also return “apparent” (refraction-corrected) values by default. This behavior can be modified by specifying a different refraction algorithm or passing  NoRefraction  no refraction correction is desired. See the  Refraction Correction  page for more details on refraction models.  Figure 1: Visualization of solar position angles: azimuth and zenith. Image source:  Haputhanthri et al. . The solar azimuth angle is typically measured clockwise from true north. The solar zenith angle is the angle between the sun and the vertical direction directly overhead. The solar elevation angle is the complement of the zenith angle (i.e., elevation = 90°- zenith). Typically solar position algorithms can take the following set of inputs: Observer location: latitude, longitude, and altitude Date and time: in UTC or local time with timezone information Optional atmospheric parameters: pressure and temperature (for refraction correction)"},{"id":173,"pagetitle":"Solar Positioning","title":"Example: Solar Path Plotting","ref":"/SolarPosition/stable/positioning/#Example:-Solar-Path-Plotting","content":" Example: Solar Path Plotting Solar positions can be calculated using  solar_position  and the in-place version  solar_position!  functions. As an example, we plot the longest day of the year solar path for an observer located at the Van Gogh museum in Amsterdam (52.35888°N, 4.88185°E) on June 21, 2023: using SolarPosition, Dates, CairoMakie\n\n# define observer location (latitude, longitude, altitude in meters)\nobs = Observer(52.35888, 4.88185, 100.0)  # Van Gogh Museum, Amsterdam\ntimes = collect(DateTime(2023, 6, 21, 0):Minute(5):DateTime(2023, 6, 21, 23, 55));\npositions = solar_position(obs, times, PSA(), HUGHES());\n\n# plot elevation and azimuth over the day\nfig = Figure(backgroundcolor = :transparent, textcolor= \"#f5ab35\", size = (800, 400))\nax1 = Axis(fig[1, 1], xlabel = \"Time (hours)\", ylabel = \"Elevation (degrees)\",\n    title = \"Solar Elevation on June 21, 2023 - Amsterdam\", backgroundcolor = :transparent,\n    xticks = 0:3:24)\nax2 = Axis(fig[1, 2], xlabel = \"Time (hours)\", ylabel = \"Azimuth (degrees)\",\n    title = \"Solar Azimuth on June 21, 2023 - Amsterdam\", backgroundcolor = :transparent,\n    xticks = 0:3:24)\ntimes_hours = [Dates.hour(t) + Dates.minute(t)/60 for t in times]\nlines!(ax1, times_hours, positions.elevation, color = \"#f5ab35\")\nlines!(ax2, times_hours, positions.azimuth, color = \"#f5ab35\")\nfig"},{"id":174,"pagetitle":"Solar Positioning","title":"Available Algorithms","ref":"/SolarPosition/stable/positioning/#Available-Algorithms","content":" Available Algorithms The following solar position algorithms are currently implemented in SolarPosition.jl: Algorithm Reference Accuracy Default Refraction Status PSA [ BALL01 ] ±0.0083° None ✅ NOAA [ NOA25 ] ±0.0167° HUGHES ✅ Walraven [ Wal78 ] ±0.0100° None ✅ USNO [ U.S25 ] ±0.0500° None ✅ SPA [ RA04 ] ±0.0003° Built-in ✅"},{"id":175,"pagetitle":"Solar Positioning","title":"PSA","ref":"/SolarPosition/stable/positioning/#psa-algorithm","content":" PSA The PSA (Plataforma Solar de Almería) algorithm is the default high-accuracy solar position algorithm. The algorithm was originally published by [ BALL01 ] and was later updated by [ BMB20 ] with new coefficients for improved accuracy. SolarPosition.Positioning.PSA  —  Type struct PSA <: SolarAlgorithm PSA (Plataforma Solar de Almería) solar position algorithm. This algorithm computes the solar position with high accuracy using empirical coefficients. Two coefficient sets are available: 2001 (range 1999-2015) and 2020 (range 2020-2050). Accuracy Claimed accuracy: ±0.004° for 2020 coefficients, ±0.01° for 2001 coefficients. Literature This algorithm is based on the work by [ BALL01 ] and was updated for 2020 coefficients in [ BMB20 ]. Fields coeffs::Int64 : Coefficient set year (2001 or 2020) source"},{"id":176,"pagetitle":"Solar Positioning","title":"NOAA","ref":"/SolarPosition/stable/positioning/#noaa-algorithm","content":" NOAA The NOAA (National Oceanic and Atmospheric Administration) algorithm provides an alternative implementation based on [ NOA25 ]. SolarPosition.Positioning.NOAA  —  Type struct NOAA <: SolarAlgorithm NOAA (National Oceanic and Atmospheric Administration) solar position algorithm. This algorithm is based on NOAA's Solar Position Calculator implementation. The algorithm is from \"Astronomical Algorithms\" by Jean Meeus. By default, the NOAA algorithm uses the  HUGHES  atmospheric refraction model which is in accordance with the NOAA solar position calculator. Accuracy Claimed accuracy: ±0.0167° from years -2000 to +3000 for latitudes within ±72°. For latitudes outside this range, the accuracy is ±0.167°. Literature Based on the NOAA solar position calculator [ NOA25 ] and the work by [ Mee91 ]. Fields delta_t::Union{Nothing, Float64} : Difference between terrestrial time and UT1 [seconds]. If  nothing , uses automatic calculation. source"},{"id":177,"pagetitle":"Solar Positioning","title":"Walraven","ref":"/SolarPosition/stable/positioning/#walraven-algorithm","content":" Walraven The Walraven algorithm is a solar position algorithm published in 1978 with stated accuracy of ±0.0100°. The algorithm was originally published by [ Wal78 ] with corrections from the 1979 Erratum [ Wal79 ] and azimuth quadrant correction from [ Spe89 ]. SolarPosition.Positioning.Walraven  —  Type struct Walraven <: SolarAlgorithm Walraven solar position algorithm. The implementation accounts for the 1979 Erratum and correct azimuth quadrant selection. Accuracy Claimed accuracy is ±0.0100°. Literature This algorithm is based on [ Wal78 ] with corrections from the 1979 Erratum [ Wal79 ] and azimuth quadrant correction from [ Spe89 ]. source"},{"id":178,"pagetitle":"Solar Positioning","title":"USNO","ref":"/SolarPosition/stable/positioning/#usno-algorithm","content":" USNO The USNO (U.S. Naval Observatory) algorithm provides solar position calculations based on formulas from the USNO's Astronomical Applications Department. The algorithm offers two options for calculating Greenwich mean sidereal time, providing flexibility for different accuracy requirements. SolarPosition.Positioning.USNO  —  Type struct USNO <: SolarAlgorithm USNO (U.S. Naval Observatory) solar position algorithm. This algorithm provides solar position calculations based on the USNO's Astronomical Applications Department formulas. Accuracy The accuracy is typically within a few arcminutes for most practical applications. This algorithm is suitable for general-purpose solar position calculations. Literature The U.S. Naval Observatory (USNO) algorithm is provided in [ U.S25 ]. Fields delta_t::Union{Nothing, Float64} : Difference between terrestrial time and UT1 [seconds]. If  nothing , uses automatic calculation. gmst_option::Int64 : Option for calculating Greenwich mean sidereal time (1 or 2) source"},{"id":179,"pagetitle":"Solar Positioning","title":"SPA","ref":"/SolarPosition/stable/positioning/#spa-algorithm","content":" SPA The SPA (Solar Position Algorithm) is the highest-accuracy algorithm available in this package, with uncertainty of ±0.0003° for years between -2000 and 6000. The algorithm was published by the National Renewable Energy Laboratory (NREL) in [ RA04 ] and implements a complete heliocentric, geocentric, and topocentric solar position calculation with periodic terms for Earth heliocentric longitude and latitude. SolarPosition.Positioning.SPA  —  Type struct SPA <: SolarAlgorithm SPA (Solar Position Algorithm) from NREL. This is the most accurate algorithm for solar position calculation, suitable for high-precision applications. The algorithm implements the complete NREL Solar Position Algorithm as described in Reda and Andreas (2004, 2007). It accounts for: Heliocentric position of Earth Nutation and aberration Geocentric and topocentric corrections Atmospheric refraction Parallax effects Accuracy Claimed accuracy: ±0.0003° (±1 arcsecond) for years -2000 to 6000. Literature This algorithm is based on [ RA04 ] with corrections from the 2007 corrigendum. Fields delta_t::Union{Nothing, Float64} : Difference between terrestrial time and UT1 [seconds]. If  nothing , uses automatic calculation. pressure::Float64 : Annual average air pressure [Pa] temperature::Float64 : Annual average air temperature [°C] atmos_refract::Float64 : Approximate atmospheric refraction at sunrise/sunset [degrees] source"},{"id":182,"pagetitle":"API reference","title":"API reference","ref":"/SolarPosition/stable/reference/#reference","content":" API reference This page provides comprehensive documentation for all functions and types in SolarPosition.jl."},{"id":183,"pagetitle":"API reference","title":"Contents","ref":"/SolarPosition/stable/reference/#Contents","content":" Contents API reference Contents Index Core Functions Observer and Position Types Algorithm Base Types Modules"},{"id":184,"pagetitle":"API reference","title":"Index","ref":"/SolarPosition/stable/reference/#Index","content":" Index SolarPosition.Positioning SolarPosition.Refraction SolarPosition.Positioning.ApparentSolPos SolarPosition.Positioning.Observer SolarPosition.Positioning.SPAObserver SolarPosition.Positioning.SPASolPos SolarPosition.Positioning.SolPos SolarPosition.Positioning.SolarAlgorithm SolarPosition.Refraction.RefractionAlgorithm SolarPosition.Positioning.solar_position SolarPosition.Positioning.solar_position!"},{"id":185,"pagetitle":"API reference","title":"Core Functions","ref":"/SolarPosition/stable/reference/#Core-Functions","content":" Core Functions SolarPosition.Positioning.solar_position  —  Function solar_position(obs::Observer, dt::DateTime, alg::SolarAlgorithm=PSA(), refraction::RefractionAlgorithm=NoRefraction())\nsolar_position(obs::Observer, dt::ZonedDateTime, alg::SolarAlgorithm=PSA(), refraction::RefractionAlgorithm=NoRefraction())\nsolar_position(obs::Observer, dts::AbstractVector{DateTime}, alg::SolarAlgorithm=PSA(), refraction::RefractionAlgorithm=NoRefraction())\nsolar_position(obs::Observer, dts::AbstractVector{ZonedDateTime}, alg::SolarAlgorithm=PSA(), refraction::RefractionAlgorithm=NoRefraction()) Calculate solar position(s) for given observer location(s) and time(s). This function computes the solar position (azimuth, elevation, and zenith angles) based on an observer's geographic location and timestamp(s). It supports multiple input formats and automatically handles time zone conversions. Arguments obs::Observer : Observer location with latitude, longitude, and altitude dt::DateTime  or  dt::ZonedDateTime : Single timestamp dts::AbstractVector : Vector of timestamps (DateTime or ZonedDateTime) alg::SolarAlgorithm : Solar positioning algorithm (default:  PSA() ) refraction::RefractionAlgorithm : Atmospheric refraction correction (default:  NoRefraction() ) Returns For single timestamps: SolPos  struct when  refraction = DefaultRefraction()  (default) ApparentSolPos  struct when a refraction algorithm is provided For multiple timestamps:  StructVector  of solar position data Angles Convention All returned angles are in  degrees : Azimuth : 0° = North, positive clockwise, range [-180°, 180°] Elevation : angle above horizon, range [-90°, 90°] Zenith : angle from zenith (90° - elevation), range [0°, 180°] Apparent Elevation/Zenith : Only in  ApparentSolPos , includes atmospheric refraction Examples Single timestamp calculation (basic position) using SolarPosition, Dates, TimeZones\n\n# Define observer location (San Francisco)\nobs = Observer(37.7749, -122.4194, 100.0)\n\n# Calculate position at specific time\ndt = ZonedDateTime(2023, 6, 21, 12, 0, 0, tz\"America/Los_Angeles\")\npos = solar_position(obs, dt)\n\nprintln(\"Azimuth: $(pos.azimuth)°\")\nprintln(\"Elevation: $(pos.elevation)°\")\nprintln(\"Zenith: $(pos.zenith)°\") With refraction correction # Use a refraction algorithm (when implemented)\n# pos_apparent = solar_position(obs, dt, PSA(), MyRefractionAlg())\n# println(\"Apparent Elevation: $(pos_apparent.apparent_elevation)°\") Multiple timestamps calculation # Generate hourly timestamps for a day\ntimes = collect(DateTime(2023, 6, 21):Hour(1):DateTime(2023, 6, 22))\npositions = solar_position(obs, times)\n\n# Access as StructVector (acts like array of structs)\nprintln(\"First position: \", positions[1])\nprintln(\"All azimuths: \", positions.azimuth) Using different algorithms # Use NOAA algorithm instead of default PSA\npos_noaa = solar_position(obs, dt, NOAA()) Supported Input Types Observer :  Observer{T}  struct with lat/lon/altitude Single time :  DateTime ,  ZonedDateTime Multiple times :  Vector{DateTime} ,  Vector{ZonedDateTime} Algorithm : Any  SolarAlgorithm  subtype Refraction : Any  RefractionAlgorithm  subtype (default:  NoRefraction() ) Time Zone Handling DateTime  inputs are assumed to be in UTC ZonedDateTime  inputs are automatically converted to UTC For local solar time calculations, use appropriate time zones Performance Notes Vectorized operations are optimized for multiple timestamps Type-stable implementations for both  Float32  and  Float64 Broadcasting-friendly for large datasets See also:  solar_position! ,  Observer ,  PSA ,  NOAA source SolarPosition.Positioning.solar_position!  —  Function solar_position!(table, obs::Observer; dt_col::Symbol=:datetime, alg::SolarAlgorithm=PSA(), refraction::RefractionAlgorithm=NoRefraction(), kwargs...)\nsolar_position!(table; latitude::AbstractFloat, longitude::AbstractFloat,\n                altitude::AbstractFloat=0.0, alg::SolarAlgorithm=PSA(), refraction::RefractionAlgorithm=NoRefraction(), kwargs...) Compute solar positions for all times in a table and add the results as new columns. Arguments table  : Table-like object with datetime column (must support Tables.jl interface). obs::Observer  : Observer location (latitude, longitude, altitude). latitude, longitude, altitude  : Specify observer location directly. dt_col::Symbol  : Name of the datetime column (default:  :datetime ). alg::SolarAlgorithm  : Algorithm to use (default:  PSA() ). refraction::RefractionAlgorithm  : Refraction correction (default:  NoRefraction() ). kwargs...  : Additional keyword arguments forwarded to the algorithm. Returns Modified table with added columns:  azimuth ,  elevation ,  zenith . If refraction is applied: also adds  apparent_elevation ,  apparent_zenith . Notes The input table is modified  in-place  by adding new columns. source"},{"id":186,"pagetitle":"API reference","title":"Observer and Position Types","ref":"/SolarPosition/stable/reference/#Observer-and-Position-Types","content":" Observer and Position Types SolarPosition.Positioning.Observer  —  Type struct Observer{T<:AbstractFloat} Observer location (deg  rees, meters). Accepts a type parameter  T  for the floating point type to use (e.g.  Float32 ,  Float64 ). Fields latitude::AbstractFloat : Geodetic latitude (+N) longitude::AbstractFloat : Longitude (+E) altitude::AbstractFloat : Altitude above mean sea level (meters) latitude_rad::AbstractFloat : Latitude in radians longitude_rad::AbstractFloat : Longitude in radians sin_lat::AbstractFloat : sin(latitude) cos_lat::AbstractFloat : cos(latitude) source SolarPosition.Positioning.SolPos  —  Type struct SolPos{T} <: AbstractSolPos Represents a single solar position calculated for a given observer and time. Fields azimuth::Any : Azimuth (degrees, 0=N, +clockwise, range [-180, 180]) elevation::Any : Elevation (degrees, range [-90, 90]) zenith::Any : Zenith = 90 - elevation (degrees, range [0, 180]) source SolarPosition.Positioning.ApparentSolPos  —  Type struct ApparentSolPos{T} <: AbstractApparentSolPos Represents a single solar position calculated for a given observer and time. Also includes apparent elevation and zenith angles. Fields azimuth::Any : Azimuth (degrees, 0=N, +clockwise, range [-180, 180]) elevation::Any : Elevation (degrees, range [-90, 90]) zenith::Any : Zenith = 90 - elevation (degrees, range [0, 180]) apparent_elevation::Any : Apparent elevation (degrees, range [-90, 90]) apparent_zenith::Any : Apparent zenith (degrees, range [0, 180]) source SolarPosition.Positioning.SPASolPos  —  Type struct SPASolPos{T} <: AbstractApparentSolPos Solar position result from SPA algorithm including equation of time. Fields azimuth::Any : Azimuth (degrees, 0=N, +clockwise, range [-180, 180]) elevation::Any : Elevation (degrees, range [-90, 90]) zenith::Any : Zenith = 90 - elevation (degrees, range [0, 180]) apparent_elevation::Any : Apparent elevation (degrees, range [-90, 90]) apparent_zenith::Any : Apparent zenith (degrees, range [0, 180]) equation_of_time::Any : Equation of time (minutes) source SolarPosition.Positioning.SPAObserver  —  Type struct SPAObserver{T<:AbstractFloat} Internal Implementation This is an internal optimization type not exported to users. Use  Observer  instead. Optimized observer type for SPA algorithm with pre-computed location-dependent values. Will cache terms that depend only on observer location to speed up calculations for multiple times at the same location. Internal Fields latitude::AbstractFloat : Geodetic latitude (+N) longitude::AbstractFloat : Longitude (+E) altitude::AbstractFloat : Altitude above mean sea level (meters) latitude_rad::AbstractFloat : Latitude in radians longitude_rad::AbstractFloat : Longitude in radians sin_lat::AbstractFloat : sin(latitude) cos_lat::AbstractFloat : cos(latitude) u::AbstractFloat : Cached u term for parallax (reduced latitude) x::AbstractFloat : Cached x term for parallax correction y::AbstractFloat : Cached y term for parallax correction source"},{"id":187,"pagetitle":"API reference","title":"Algorithm Base Types","ref":"/SolarPosition/stable/reference/#Algorithm-Base-Types","content":" Algorithm Base Types SolarPosition.jl uses a type hierarchy for algorithms: SolarPosition.Positioning.SolarAlgorithm  —  Type abstract type SolarAlgorithm Abstract base type for all solar position algorithms. All concrete solar position algorithm types must inherit from this type. Examples struct MyAlgorithm <: SolarAlgorithm end source SolarPosition.Refraction.RefractionAlgorithm  —  Type abstract type RefractionAlgorithm Abstract base type for atmospheric refraction correction algorithms. Refraction algorithms compute the apparent position of the sun by correcting for atmospheric refraction effects. Examples struct MyRefraction <: RefractionAlgorithm end source"},{"id":188,"pagetitle":"API reference","title":"Modules","ref":"/SolarPosition/stable/reference/#Modules","content":" Modules SolarPosition.Positioning  —  Module Positioning This module provides the core solar position calculation algorithms, observer location handling, and result types for SolarPosition.jl. It includes implementations of various solar position algorithms such as PSA and NOAA, with support for optional atmospheric refraction corrections. Exported Types Observer : Geographic observer location SolPos : Basic solar position result ApparentSolPos : Solar position with atmospheric corrections PSA : PSA algorithm implementation NOAA : NOAA algorithm implementation RefractionAlgorithm : Base type for refraction algorithms NoRefraction : No refraction correction (default) Exported Functions solar_position : Calculate solar positions solar_position! : In-place solar position calculation source SolarPosition.Refraction  —  Module Refraction Atmospheric refraction models. Exported Types HUGHES : Hughes atmospheric refraction model ARCHER : Archer atmospheric refraction model BENNETT : Bennett atmospheric refraction model MICHALSKY : Michalsky atmospheric refraction model SG2 : Saemundsson-Garfinkel atmospheric refraction model SPA : Solar Position Algorithm refraction model Exported Functions refraction : Apply refraction correction to elevation angle(s) source"},{"id":191,"pagetitle":"Refraction Correction","title":"Refraction Correction","ref":"/SolarPosition/stable/refraction/#refraction-correction","content":" Refraction Correction Atmospheric refraction causes the apparent position of the sun to differ from its true geometric position. This effect is most pronounced near the horizon and can be corrected using various atmospheric models. The correction formula for elevation is: \\[e_{apparent} = e_{true} + R\\] Where: $e_{apparent}$  is the apparent solar elevation angle (degrees) $e_{true}$  is the true solar elevation angle (degrees) $R$  is the refraction correction (degrees), calculated based on the chosen refraction model  Figure 1: Atmospheric refraction causes the sun to appear higher in the sky than its true position, especially near the horizon. Image source:  Wikimedia Commons . SolarPosition.jl  includes several refraction correction algorithms. Below is a summary of the available algorithms: Algorithm Reference Atmospheric Parameters Status HUGHES [ Hug85 ] Pressure, Temperature ✅ ARCHER [ ABO80 ] None ✅ BENNETT [ Ben82 ] Pressure, Temperature ✅ MICHALSKY [ Mic88 ] None ✅ SG2 [ BW12 ] Pressure, Temperature ✅ SPARefraction [ RA04 ] Pressure, Temperature ✅ To calculate refraction, we can use the  refraction  function: SolarPosition.Refraction.refraction  —  Function refraction(model::RefractionAlgorithm, elevation::T) where {T<:AbstractFloat} Apply atmospheric refraction correction to the given elevation angle(s). Arguments model::RefractionAlgorithm : Refraction model to use (e.g.,  HUGHES() ) elevation::T : True (unrefracted) solar elevation angle in degrees Returns Refraction correction in degrees to be added to the elevation angle Examples using SolarPosition\nhughes = HUGHES(101325.0, 15.0)  # 15°C temperature\nelevation = 30.0  # 30 degrees\ncorrection = refraction(hughes, elevation)\napparent_elevation = elevation + correction source This function is typically used internally by the  solar_position  function when a refraction algorithm is specified, but is also a publicly available method. Info When using a refraction algorithm like  HUGHES , the  solar_position  function returns an  ApparentSolPos  struct containing both true and apparent angles. SolarPosition.Refraction.NoRefraction  —  Type struct NoRefraction <: RefractionAlgorithm Indicates that no atmospheric refraction correction should be applied. This is the default refraction setting for solar position calculations. When used, only basic solar position (azimuth, elevation, zenith) is computed. source Info When using  NoRefraction  (the default), the  solar_position  function returns a  SolPos  struct containing only the true geometric angles (azimuth, elevation, zenith). In this case, no refraction correction is applied."},{"id":192,"pagetitle":"Refraction Correction","title":"Default refraction model","ref":"/SolarPosition/stable/refraction/#Default-refraction-model","content":" Default refraction model The  DefaultRefraction  type is a special marker that indicates to use the default refraction behavior for the selected solar position algorithm. For most algorithms, this means no refraction correction (i.e., equivalent to  NoRefraction ). SolarPosition.Refraction.DefaultRefraction  —  Type struct DefaultRefraction <: RefractionAlgorithm Default refraction model used when no specific model is provided. This will depend on the solar position algorithm being used. source"},{"id":193,"pagetitle":"Refraction Correction","title":"Comparison of Refraction Models","ref":"/SolarPosition/stable/refraction/#Comparison-of-Refraction-Models","content":" Comparison of Refraction Models Several different refraction models have been proposed in the literature.  SolarPosition.jl  only implements a subset of them but PRs are always welcome! To compare the different refraction models, the refraction angle is calculated in the range -1 to 90 degree solar elevation in steps of 0.1 degrees. using SolarPosition\nusing CairoMakie\n\n# Define models and elevation range\nmodels = [(\"Archer\", SolarPosition.Refraction.ARCHER()), (\"Bennett\", SolarPosition.Refraction.BENNETT()),\n          (\"Hughes\", SolarPosition.Refraction.HUGHES()), (\"Michalsky\", SolarPosition.Refraction.MICHALSKY()),\n          (\"SG2\", SolarPosition.Refraction.SG2()), (\"SPA\", SolarPosition.Refraction.SPARefraction())]\nelevation = -1.5:0.1:90.0\n\n# Create figure with two subplots\nfig = Figure(size = (800, 400), backgroundcolor = :transparent, textcolor = \"#f5ab35\")\nax1 = Axis(fig[1, 1], xlabel = \"True elevation [degrees]\",\n    ylabel = \"Refraction correction [degrees]\", title = \"Near Horizon\",\n    backgroundcolor = :transparent, xticks = -1:1:4)\nax2 = Axis(fig[1, 2], xlabel = \"True elevation [degrees]\",\n    ylabel = \"Refraction correction [degrees]\", title = \"Full Range (Log Scale)\", yscale = log10, backgroundcolor = :transparent)\n\n# Plot refraction for each model\nfor (name, model) in models\n    ref = [SolarPosition.Refraction.refraction(model, e) for e in elevation]\n    lines!(ax1, elevation, ref, label = name)\n    mask = ref .> 0\n    lines!(ax2, elevation[mask], ref[mask])\nend\n\nxlims!(ax1, -1.5, 4); ylims!(ax1, 0, 1.0)\nxlims!(ax2, -1.5, 90); ylims!(ax2, 1e-3, 1.0)\n\nLegend(fig[0, :], ax1, orientation = :horizontal, framevisible = false,\n    tellwidth = false, tellheight = true, nbanks = 1)\nfig A comparison of the refraction models is visualized above. The plot on the left shows refraction for solar elevation angles near sunrise/sunset, where refraction is most significant. The plot on the right shows the refraction angles for the entire range of solar elevation angles. Note that for the right plot, the y-axis is a log scale, which emphasizes the difference between the models."},{"id":194,"pagetitle":"Refraction Correction","title":"Hughes","ref":"/SolarPosition/stable/refraction/#hughes-refraction","content":" Hughes The Hughes refraction model accounts for atmospheric pressure and temperature effects. This model was developed by [ Hug85 ] and is used in the SUNAEP software [ Zim81 ]. It's also the basis for the refraction correction in NOAA's solar position calculator (using fixed pressure of 101325 Pa and temperature of 10°C). SolarPosition.Refraction.HUGHES  —  Type struct HUGHES{T} <: RefractionAlgorithm Hughes refraction model. This function was developed by G. Hughes [1] and was used in the SUNAEP software [2]. It is also used to calculate the refraction correction in the NOAA solar position algorithm using a fixed pressure of 101325 Pa and a temperature of 10 degrees Celsius. Fields pressure::Any : Annual average atmospheric pressure [Pascal] temperature::Any : Annual average temperature [°C] Constructor HUGHES() : Uses default parameters: pressure = 101325 Pa, temperature = 12 °C HUGHES(pressure, temperature) : Specify custom pressure [Pa] and temperature [°C] Notes The equation to calculate the refraction correction is given by: For 5° < elevation ≤ 90°: \\[\\frac{58.1}{\\tan(el)} - \\frac{0.07}{\\tan(el)^3} + \\frac{8.6 \\times 10^{-5}}{\\tan(el)^5}\\] For -0.575° < elevation ≤ 5°: \\[el \\cdot (-518.2 + el \\cdot (103.4 + el \\cdot (-12.79 + el \\cdot 0.711))) + 1735\\] For elevation ≤ -0.575°: \\[\\frac{-20.774}{\\tan(el)}\\] where  el  is the true (unrefracted) solar elevation angle. The result is then corrected for temperature and pressure: \\[\\text{Refract} \\times \\frac{283}{273 + T} \\times \\frac{P}{101325} \\times \\frac{1}{3600}\\] Literature This function was developed by [ Hug85 ] and was used in the SUNAEP software [ Zim81 ]. It is also used to calculate the refraction correction in the NOAA solar position algorithm using a fixed pressure of 101325 Pa and a temperature of 10 degrees Celsius. Example using SolarPosition\n\n# Create Hughes refraction model with default parameters\nhughes = HUGHES()\n\n# Or specify custom atmospheric conditions\nhughes_custom = HUGHES(101325.0, 25.0)  # 25°C temperature\n\n# Apply refraction correction to elevation angle\nelevation = 30.0  # degrees\nrefraction_correction = refraction(hughes, elevation)\napparent_elevation = elevation + refraction_correction source"},{"id":195,"pagetitle":"Refraction Correction","title":"Archer","ref":"/SolarPosition/stable/refraction/#archer-refraction","content":" Archer The Archer refraction model is a cosine-based correction that does not require atmospheric parameters. This simplified model from [ ABO80 ] computes refraction based on the zenith angle using trigonometric relationships. It's useful when atmospheric data is not available. SolarPosition.Refraction.ARCHER  —  Type struct ARCHER <: RefractionAlgorithm Archer refraction model. Atmospheric refraction correction based on the Archer algorithm. This function calculates the atmospheric refraction correction of the solar elevation angle using the method described by Archer [1]. The method was originally developed to be used with the Walraven solar position algorithm [2]. Fields Constructor ARCHER() : Creates an Archer refraction model instance Notes The equation to calculate the refraction correction is given by: \\[\\begin{aligned}\nC &= \\cos(Z) + 0.0083 \\cdot \\left(\\frac{1}{0.955 + (20.267 \\cdot \\cos(Z))} - 0.047121 \\right)\\\\\nZ_a &= \\arccos(C)\\\\\n\\text{refraction} &= Z - Z_a\n\\end{aligned}\\] where  $Z$  is the true solar zenith angle and  $Z_a$  is the apparent zenith angle. Literature This method was described by [ ABO80 ] and was originally developed to be used with the Walraven solar position algorithm [ Wal78 ]. Example using SolarPosition\n\n# Create Archer refraction model\narcher = ARCHER()\n\n# Apply refraction correction to elevation angle\nelevation = 30.0  # degrees\nrefraction_correction = refraction(archer, elevation)\napparent_elevation = elevation + refraction_correction source"},{"id":196,"pagetitle":"Refraction Correction","title":"Bennett","ref":"/SolarPosition/stable/refraction/#bennett-refraction","content":" Bennett The Bennett refraction model is widely used in marine navigation and accounts for atmospheric conditions. Developed by [ Ben82 ], this model provides accurate refraction corrections with adjustments for atmospheric pressure and temperature. It's particularly effective for low elevation angles. SolarPosition.Refraction.BENNETT  —  Type struct BENNETT{T} <: RefractionAlgorithm Bennett refraction model. Atmospheric refraction correction based on the Bennett algorithm. Calculation of atmospheric refraction correction of the solar elevation angle using the method developed by Bennett [1]. Fields pressure::Any : Annual average atmospheric pressure [Pascal] temperature::Any : Annual average temperature [°C] Constructor BENNETT() : Uses default parameters: pressure = 101325 Pa, temperature = 12 °C BENNETT(pressure, temperature) : Specify custom pressure [Pa] and temperature [°C] Notes The equation to calculate the refraction correction is given by: \\[\\text{ref} = \\frac{0.28 \\cdot P}{T+273} \\cdot \\frac{0.016667}{\\tan(el + 7.31 / (el+4.4))}\\] where  $P$  is the local air pressure in hPa,  $T$  is the local air temperature in °C, and  $el$  is the true (uncorrected) solar elevation angle. Literature This method was described by [ Ben82 ]. Example using SolarPosition\n\n# Create Bennett refraction model with default parameters\nbennett = BENNETT()\n\n# Or specify custom atmospheric conditions\nbennett_custom = BENNETT(101325.0, 25.0)  # 25°C temperature\n\n# Apply refraction correction to elevation angle\nelevation = 30.0  # degrees\nrefraction_correction = refraction(bennett, elevation)\napparent_elevation = elevation + refraction_correction source"},{"id":197,"pagetitle":"Refraction Correction","title":"Michalsky","ref":"/SolarPosition/stable/refraction/#michalsky-refraction","content":" Michalsky The Michalsky refraction model uses a rational polynomial approximation. From [ Mic88 ], this algorithm is part of the Astronomical Almanac's method for approximate solar position calculations. It includes special handling for very low elevation angles. SolarPosition.Refraction.MICHALSKY  —  Type struct MICHALSKY <: RefractionAlgorithm Michalsky refraction model. Atmospheric refraction correction based on the Michalsky algorithm. This function calculates the atmospheric refraction correction of the solar elevation angle using the method described by Michalsky [1]. Fields Constructor MICHALSKY() : Creates a Michalsky refraction model instance Notes The equation to calculate the refraction correction is given by: \\[\\text{ref} = \\frac{3.51561 \\cdot (0.1594 + 0.0196 \\cdot el + 0.00002 \\cdot el^2)}{1 + 0.505 \\cdot el + 0.0845 \\cdot el^2}\\] where  $el$  is the true (uncorrected) solar elevation angle. Note that 3.51561 = 1013.2 mb / 288.2 °C. For elevation angles below -0.56°, the refraction correction is clamped to 0.56°. Literature This method was described by [ Mic88 ]. Example using SolarPosition\n\n# Create Michalsky refraction model\nmichalsky = MICHALSKY()\n\n# Apply refraction correction to elevation angle\nelevation = 30.0  # degrees\nrefraction_correction = refraction(michalsky, elevation)\napparent_elevation = elevation + refraction_correction source"},{"id":198,"pagetitle":"Refraction Correction","title":"SG2","ref":"/SolarPosition/stable/refraction/#sg2-refraction","content":" SG2 The SG2 (Second Generation) refraction algorithm is optimized for fast computation over multi-decadal periods. Developed by [ BW12 ], this algorithm uses a two-regime approach with different formulas for elevations above and below a threshold. It accounts for atmospheric pressure and temperature. SolarPosition.Refraction.SG2  —  Type struct SG2{T} <: RefractionAlgorithm SG2 refraction model. Atmospheric refraction correction based on the algorithm in SG2. This function calculates the atmospheric refraction correction of the solar elevation angle using the method developed by Ph. Blanc and L. Wald [1]. Fields pressure::Any : Annual average atmospheric pressure [Pascal] temperature::Any : Annual average temperature [°C] Constructor SG2() : Uses default parameters: pressure = 101325 Pa, temperature = 12 °C SG2(pressure, temperature) : Specify custom pressure [Pa] and temperature [°C] Notes The equation to calculate the refraction correction is given by: For  $el > -0.01$  radians: \\[\\frac{P}{1010} \\cdot \\frac{283}{273+T} \\cdot \\frac{2.96706 \\times 10^{-4}}{\\tan(el+0.0031376 \\cdot (el+0.089186)^{-1})}\\] For  $el \\leq -0.01$  radians: \\[-\\frac{P}{1010} \\cdot \\frac{283}{273+T} \\cdot \\frac{1.005516 \\times 10^{-4}}{\\tan(el)}\\] where  $el$  is the true solar elevation angle,  $P$  is the local air pressure in hPa, and  $T$  is the local air temperature in °C. Literature This method was described by [ BW12 ]. Example using SolarPosition\n\n# Create SG2 refraction model with default parameters\nsg2 = SG2()\n\n# Or specify custom atmospheric conditions\nsg2_custom = SG2(101325.0, 25.0)  # 25°C temperature\n\n# Apply refraction correction to elevation angle\nelevation = 30.0  # degrees\nrefraction_correction = refraction(sg2, elevation)\napparent_elevation = elevation + refraction_correction source"},{"id":199,"pagetitle":"Refraction Correction","title":"SPARefraction","ref":"/SolarPosition/stable/refraction/#spa-refraction","content":" SPARefraction The SPARefraction (Solar Position Algorithm) refraction model is part of NREL's high-accuracy solar position algorithm. From [ RA04 ], this is the refraction correction used in NREL's SPA algorithm, which is accurate to ±0.0003° over the years -2000 to 6000. It includes a configurable refraction limit for below-horizon calculations. SolarPosition.Refraction.SPARefraction  —  Type struct SPARefraction{T} <: RefractionAlgorithm SPARefraction - SPA (Solar Position Algorithm) refraction model. Atmospheric refraction correction from the SPA algorithm. This function calculates the atmospheric refraction correction of the solar elevation angle using the method described in Reda and Andreas's [1] Solar Position Algorithm (SPA). Fields pressure::Any : Annual average atmospheric pressure [Pascal] temperature::Any : Annual average temperature [°C] refraction_limit::Any : Minimum elevation angle for refraction correction [degrees] Constructor SPARefraction() : Uses default parameters: pressure = 101325 Pa, temperature = 12 °C, refraction_limit = -0.5667° SPARefraction(pressure, temperature) : Specify custom pressure [Pa] and temperature [°C], uses default refraction_limit SPARefraction(pressure, temperature, refraction_limit) : Also specify refraction limit [degrees] Notes The equation to calculate the refraction correction is given by: \\[\\text{ref} = \\frac{P}{1010} \\cdot \\frac{283}{273 + T} \\cdot \\frac{1.02}{60 \\cdot \\tan(el + 10.3/(el + 5.11))}\\] where  $el$  is the true solar elevation angle,  $P$  is the annual average local air pressure in hPa/mbar, and  $T$  is the annual average local air temperature in °C. The refraction limit parameter determines the solar elevation angle below which refraction is not applied, as the sun is assumed to be below horizon. Note that the sun diameter (0.26667°) is added to this limit. Literature This method was described by [ RA04 ]. Example using SolarPosition\n\n# Create SPARefraction model with default parameters\nspa = SPARefraction()\n\n# Or specify custom atmospheric conditions\nspa_custom = SPARefraction(101325.0, 25.0)  # 25°C temperature\n\n# With custom refraction limit\nspa_limit = SPARefraction(101325.0, 12.0, -1.0)  # Don't correct below -1°\n\n# Apply refraction correction to elevation angle\nelevation = 30.0  # degrees\nrefraction_correction = refraction(spa, elevation)\napparent_elevation = elevation + refraction_correction source"},{"id":202,"pagetitle":"Home","title":"SPICE.jl","ref":"/SPICE/stable/#SPICE.jl","content":" SPICE.jl SPICE.jl  is a Julia wrapper for the  SPICE toolkit  which is provided by NASA's Navigation and Ancillary Information Facility (NAIF). It provides functionality to read SPICE data files and compute derived observation geometry such as altitude, latitude/longitude and lighting angles. Please refer to its comprehensive  documentation  if you are not yet familiar with SPICE. Note:  This project is  not  affiliated with NASA, NAIF or JPL in any way."},{"id":203,"pagetitle":"Home","title":"Installation","ref":"/SPICE/stable/#Installation","content":" Installation julia> import Pkg; Pkg.add(\"SPICE\")"},{"id":204,"pagetitle":"Home","title":"Quickstart","ref":"/SPICE/stable/#Quickstart","content":" Quickstart using SPICE\nusing Downloads: download\n\nconst LSK = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/lsk/naif0012.tls\"\nconst SPK = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/de440.bsp\"\n\n# Download kernels\ndownload(LSK, \"naif0012.tls\")\ndownload(SPK, \"de440.bsp\")\n\n# Load leap seconds kernel\nfurnsh(\"naif0012.tls\")\n\n# Convert the calendar date to ephemeris seconds past J2000\net = utc2et(\"2018-02-06T20:45:00\")\n\n# Load a planetary ephemeris kernel\nfurnsh(\"de440.bsp\")\n\n# Get the position of Mars at `et` w.r.t. Earth\nspkpos(\"mars_barycenter\", et, \"J2000\", \"none\", \"earth\")"},{"id":205,"pagetitle":"Home","title":"Notable differences to CSPICE","ref":"/SPICE/stable/#Notable-differences-to-CSPICE","content":" Notable differences to CSPICE SPICE.jl follows the Julia language's style and conventions which introduces the following differences to CSPICE. SPICE.jl does not wrap all CSPICE functions since many general purpose utilities already exist in Julia's standard library or can be approximated with a Julia one-liner.  If you try to call an unwrapped function, SPICE.jl will return a deprecation warning that shows the equivalent Julia code. Functions that mutate one of their input arguments are suffixed with  !  and the to-be-mutated argument will be the first parameter, e.g.  wninsd!(window, left, right)  instead of  wninsd(left, right, window) ."},{"id":206,"pagetitle":"Home","title":"Next Steps","ref":"/SPICE/stable/#Next-Steps","content":" Next Steps Please refer to the  API  reference."},{"id":209,"pagetitle":"API","title":"API","ref":"/SPICE/stable/api/#API","content":" API"},{"id":210,"pagetitle":"API","title":"Types","ref":"/SPICE/stable/api/#Types","content":" Types SPICE.SpiceCharCell  —  Type SpiceCharCell(size, length) Create a  SpiceCharCell  that can contain up to  size  strings with  length  characters. source SPICE.SpiceDoubleCell  —  Type SpiceDoubleCell(size) Create a  SpiceDoubleCell  that can contain up to  size  elements. source SPICE.SpiceIntCell  —  Type SpiceIntCell(size) Create a  SpiceIntCell  that can contain up to  size  elements. source"},{"id":211,"pagetitle":"API","title":"Functions","ref":"/SPICE/stable/api/#Functions","content":" Functions Base.append!  —  Method append!(cell, collection) Append all items from  collection  to the char/double/integer SpiceCell  cell . source Base.copy  —  Method copy(cell::SpiceCell) Duplicate the  SpiceCell cell . source Base.diff  —  Method diff(a::T, b::T) where T <: SpiceCell Compute the difference of two sets of any data type to form a third set. Arguments a : First input set b : Second input set Output Returns a cell containing the difference of  a  and  b . References NAIF Documentation source Base.length  —  Method length(cell) Returns the cardinality (number of elements) of  cell . source Base.push!  —  Method push!(cell, items...) Insert one or more  items  at the end of the char/double/integer SpiceCell  cell . source Base.union  —  Method union(a::T, b::T) where T <: SpiceCell Compute the union of two sets of any data type to form a third set. Arguments a : First input set b : Second input set Output Returns a cell containing the union of  a  and  b . References NAIF Documentation source SPICE.appnd  —  Method appnd(item, cell) Append an  item  to the char/double/integer SpiceCell  cell . References appndc - NAIF Documentation appndd - NAIF Documentation appndi - NAIF Documentation source SPICE.axisar  —  Method axisar(axis, angle) Construct a rotation matrix that rotates vectors by a specified  angle  about a specified  axis . Arguments axis : Rotation axis angle : Rotation angle in radians Output Rotation matrix corresponding to  axis  and  angle References NAIF Documentation source SPICE.azlcpo  —  Method azlcpo(target, et, abcorr, obspos, obsctr, obsref;\n       method=\"ELLIPSOID\", azccw=true, elplsz=true) Return the azimuth/elevation coordinates of a specified target relative to an \"observer,\" where the observer has constant position in a specified reference frame. The observer's position is provided by the calling program rather than by loaded SPK files. Arguments target : Name of target ephemeris object et : Observation epoch abcorr : Aberration correction obspos : Observer position relative to center of motion obsctr : Center of motion of observer obsref : Body-fixed, body-centered frame of observer's center Keyword Arguments method : Method to obtain the surface normal vector. The only (and default) choice currently supported is  \"ELLIPSOID\" azccw : Flag indicating how azimuth is measured. If  true  (the default), the azimuth increases in the counterclockwise direction; otherwise it increases in the clockwise direction elplsz : Flag indicating how elevation is measured. If  true  (the default), the elevation increases from the XY plane toward +Z; otherwise toward -Z Output azlsta : State of target with respect to observer, in azimuth/elevation coordinates:  azlsta = [r, az, el, dr/dt, daz/dt, del/dt] lt : One-way light time between target and observer References NAIF Documentation source SPICE.azlrec  —  Method azlrec(range, az, el; azccw=true, elplsz=true) Convert from range, azimuth and elevation of a point to rectangular coordinates. Arguments range : Distance of the point from the origin az : Azimuth in radians el : Elevation in radians Keyword Arguments azccw : Flag indicating how azimuth is measured. If  true  (the default), the azimuth increases in the counterclockwise direction; otherwise it increases in the clockwise direction elplsz : Flag indicating how elevation is measured. If  true  (the default), the elevation increases from the XY plane toward +Z; otherwise toward -Z Output rectan : Rectangular coordinates of the point References NAIF Documentation source SPICE.b1900  —  Method b1900() Returns the Julian Date corresponding to Besselian date 1900.0. References NAIF Documentation source SPICE.b1950  —  Method b1950() Returns the Julian Date corresponding to Besselian date 1950.0. References NAIF Documentation source SPICE.badkpv  —  Method badkpv(caller, name, comp, size, divby, typ) Determine if a kernel pool variable is present and if so that it has the correct size and type. Arguments caller : Name of the routine calling this routine name : Name of a kernel pool variable comp : Comparison operator size : Expected size of the kernel pool variable divby : A divisor of the size of the kernel pool variable type : Expected type of the kernel pool variable Output The function returns  false  if the kernel pool variable is OK otherwise an exception is thrown. References NAIF Documentation source SPICE.bltfrm  —  Method bltfrm(frmcls) Return a SPICE set containing the frame IDs of all built-in frames of a specified class. Arguments frmcls : Frame class Output idset : Set of ID codes of frames of the specified class References NAIF Documentation source SPICE.bodc2n  —  Method bodc2n(code) Translate the SPICE integer code of a body into a common name for that body. Arguments code : Integer ID code to be translated into a name Output A common name for the body identified by code or  nothing  if none was found. References NAIF Documentation source SPICE.bodc2s  —  Method bodc2s(code) Translate a body ID code to either the corresponding name or if no name to ID code mapping exists, the string representation of the body ID value. Arguments code : Integer ID code to translate to a string Output Returns a string corresponding to  code References NAIF Documentation source SPICE.boddef  —  Method boddef(name, code) Define a body name/ID code pair for later translation via  bodn2c  or  bodc2n . Arguments name : Common name of some body code : Integer code for that body References NAIF Documentation source SPICE.bodfnd  —  Method bodfnd(body, item) Determine whether values exist for some item for any body in the kernel pool. Arguments body : ID code of body item : Item to find ( \"RADII\" ,  \"NUT_AMP_RA\" , etc.) Output Returns  true  if the item is in the kernel pool and  false  if it is not. References NAIF Documentation source SPICE.bodn2c  —  Method bodn2c(name) Translate the name of a body or object to the corresponding SPICE integer ID code. Arguments name : Body name to be translated into a SPICE ID code Output Return the SPICE integer ID code for the named body or  nothing  if none was found. References NAIF Documentation source SPICE.bods2c  —  Method bods2c(name) Translate a string containing a body name or ID code to an integer code. Arguments name : String to be translated to an ID code Output Retunrs the integer ID code corresponding to  name  or  nothing  if none as found. References NAIF Documentation source SPICE.bodvcd  —  Function bodvcd(bodyid, item) Fetch from the kernel pool the double precision values of an item associated with a body, where the body is specified by an integer ID code. Arguments bodyid : Body ID code item : Item for which values are desired. ( \"RADII\" ,  \"NUT_PREC_ANGLES\" , etc.) maxn : Maximum number of values that may be returned (default: 100) Output Returns the requested values. References NAIF Documentation source SPICE.bodvrd  —  Function bodvrd(bodynm, item) Fetch from the kernel pool the double precision values of an item associated with a body. Arguments bodynm : Body name item : Item for which values are desired. ( \"RADII\" ,  \"NUT_PREC_ANGLES\" , etc.) maxn : Maximum number of values that may be returned (default: 100) Output values : Values References NAIF Documentation source SPICE.brcktd  —  Function brcktd(number, e1, e2)\nbrckti(number, e1, e2) Deprecated Use  Base.clamp()  from Julia's standard library instead. source SPICE.brckti  —  Function brcktd(number, e1, e2)\nbrckti(number, e1, e2) Deprecated Use  Base.clamp()  from Julia's standard library instead. source SPICE.bschoc  —  Function bschoc(value, array, order)\nbschoi(value, array, order) Deprecated Use  Base.findfirst(==(value), array)  instead. source SPICE.bschoi  —  Function bschoc(value, array, order)\nbschoi(value, array, order) Deprecated Use  Base.findfirst(==(value), array)  instead. source SPICE.bsrchc  —  Function bsrchc(value, array)\nbsrchd(value, array)\nbsrchi(value, array) Deprecated Use  Base.findfirst(==(value), array)  instead. source SPICE.bsrchd  —  Function bsrchc(value, array)\nbsrchd(value, array)\nbsrchi(value, array) Deprecated Use  Base.findfirst(==(value), array)  instead. source SPICE.bsrchi  —  Function bsrchc(value, array)\nbsrchd(value, array)\nbsrchi(value, array) Deprecated Use  Base.findfirst(==(value), array)  instead. source SPICE.card  —  Method card(cell) Returns the cardinality (number of elements) of  cell . source SPICE.ccifrm  —  Method ccifrm(frclss, clssid) Return the frame name, frame ID, and center associated with a given frame class and class ID. Arguments frclss : Class of frame clssid : Class ID of frame Output Returns  nothing  if no frame was found or frcode : ID code of the frame frname : Name of the frame center : ID code of the center of the frame References NAIF Documentation source SPICE.cgv2el  —  Method cgv2el(center, vec1, vec2) Form an ellipse from a center vector and two generating vectors. Arguments center : Center vector vec1 : Generating vector vec2 : Generating vector Output Returns the ellipse defined by the input vectors. References NAIF Documentation source SPICE.chbder  —  Method chbder(cp, x2s, x, nderiv) Given the coefficients for the Chebyshev expansion of a polynomial, this returns the value of the polynomial and its first  nderiv  derivatives evaluated at the input  x . Arguments cp : Chebyshev polynomial coefficients x2s : Transformation parameters of polynomial x : Value for which the polynomial is to be evaluated nderiv : The number of derivatives to compute Output Returns the derivatives of the polynomial. References NAIF Documentation source SPICE.cidfrm  —  Method cidfrm(cent) Retrieve frame ID code and name to associate with a frame center. Arguments cent : ID code for an object for which there is a preferred reference frame Output Returns  nothing  if no frame was found or frcode : The ID code of the frame associated with  cent frname : The name of the frame with ID  frcode References NAIF Documentation source SPICE.ckcls  —  Method ckcls(handle) Close an open CK file. Arguments handle : Handle of the CK file to be closed References NAIF Documentation source SPICE.ckcov!  —  Method ckcov!(ck, idcode, needav, level, tol, timsys, cover) Find the coverage window for a specified object in a specified CK file. Arguments ck : Name of CK file idcode : ID code of object needav : Flag indicating whether angular velocity is needed level : Coverage level:  \"SEGMENT\" OR \"INTERVAL\" tol : Tolerance in ticks timsys : Time system used to represent coverage cover : Window giving coverage for  idcode . Data already present in  cover    will be combined with coverage found for the object designated by  idcode    in the file  ck . References NAIF Documentation source SPICE.ckcov  —  Method ckcov(ck, idcode, needav, level, tol, timsys) Find the coverage window for a specified object in a specified CK file. Arguments ck : Name of CK file idcode : ID code of object needav : Flag indicating whether angular velocity is needed level : Coverage level:  \"SEGMENT\" OR \"INTERVAL\" tol : Tolerance in ticks timsys : Time system used to represent coverage Output Window giving coverage for  idcode References NAIF Documentation source SPICE.ckgp  —  Method ckgp(inst, sclkdp, tol, ref) Get pointing (attitude) for a specified spacecraft clock time. Arguments inst : NAIF ID of instrument, spacecraft, or structure sclkdp : Encoded spacecraft clock time tol : Time tolerance ref : Reference frame Outputs Returns  nothing  if the requested pointing is not available or cmat : C-matrix pointing data clkout : Output encoded spacecraft clock time References NAIF Documentation source SPICE.ckgpav  —  Method ckgpav(inst, sclkdp, tol, ref) Get pointing (attitude) and angular velocity for a specified spacecraft clock time. Arguments inst : NAIF ID of instrument, spacecraft, or structure sclkdp : Encoded spacecraft clock time tol : Time tolerance ref : Reference frame Outputs Returns  nothing  if the requested pointing is not available or cmat : C-matrix pointing data av : Angular velocity vector clkout : Output encoded spacecraft clock time References NAIF Documentation source SPICE.cklpf  —  Method cklpf(filename) Load a CK pointing file for use by the CK readers.  Return that file's handle, to be used by other CK routines to refer to the file. Arguments filename : Name of the CK file to be loaded Output Loaded file's handle References NAIF Documentation source SPICE.ckobj!  —  Method ckobj!(ck, ids) Find the set of ID codes of all objects in a specified CK file. Arguments ck : Name of CK file ids : Set of ID codes of objects in CK file. Data already present in    ids  will be combined with ID code set found for the file  ck . References NAIF Documentation source SPICE.ckobj  —  Method ckobj(ck) Find the set of ID codes of all objects in a specified CK file. Arguments ck : Name of CK file Output Set of ID codes of objects in CK file. References NAIF Documentation source SPICE.ckopn  —  Function ckopn(fname, ifname=\"CK_file\", ncomch=0) Open a new CK file, returning the handle of the opened file. Arguments fname : The name of the CK file to be opened ifname : The internal filename for the CK (default: \" CK_file \") ncomch : The number of characters to reserve for comments (default: 0) Output handle : The handle of the opened CK file References NAIF Documentation source SPICE.ckupf  —  Method ckupf(handle) Unload a CK pointing file so that it will no longer be searched by the readers. Arguments handle : Handle of CK file to be unloaded References NAIF Documentation source SPICE.ckw01  —  Function ckw01(handle, begtim, endtim, inst, ref, segid, sclkdp, quats, avvs=[zeros(3)]) Add a type 1 segment to a C-kernel. Arguments handle : Handle of an open CK file begtim : The beginning encoded SCLK of the segment endtim : The ending encoded SCLK of the segment inst : The NAIF instrument ID code ref : The reference frame of the segment segid : Segment identifier sclkdp : Encoded SCLK times quats : Quaternions representing instrument pointing avvs : Angular velocity vectors (optional) References NAIF Documentation source SPICE.ckw02  —  Method ckw02(handle, begtim, endtim, inst, ref, segid, start, stop, quats, avvs, rates) Write a type 2 segment to a C-kernel. Arguments handle : Handle of an open CK file begtim : The beginning encoded SCLK of the segment endtim : The ending encoded SCLK of the segment inst : The NAIF instrument ID code ref : The reference frame of the segment segid : Segment identifier start : Encoded SCLK interval start times stop : Encoded SCLK interval stop times quats : Quaternions representing instrument pointing avvs : Angular velocity vectors rates : Number of seconds per tick for each interval References NAIF Documentation source SPICE.ckw03  —  Function ckw03(handle, begtim, endtim, inst, ref, segid, sclkdp, quats, starts, avvs=[zeros(3)]) Add a type 3 segment to a C-kernel. Arguments handle : Handle of an open CK file begtim : The beginning encoded SCLK of the segment endtim : The ending encoded SCLK of the segment inst : The NAIF instrument ID code ref : The reference frame of the segment segid : Segment identifier sclkdp : Encoded SCLK times quats : Quaternions representing instrument pointing starts : Encoded SCLK interval start times avvs : Angular velocity vectors (optional) References NAIF Documentation source SPICE.ckw05  —  Method ckw05(handle, subtyp, degree, begtim, endtim, inst, ref, avflag, segid, sclkdp, packts,\n      rate, nints, starts) Write a type 5 segment to a CK file. Arguments handle : Handle of an open CK file subtyp : CK type 5 subtype code degree : Degree of interpolating polynomials begtim : The beginning encoded SCLK of the segment endtim : The ending encoded SCLK of the segment inst : The NAIF instrument ID code ref : The reference frame of the segment avflag : True if the segment will contain angular velocity segid : Segment identifier sclkdp : Encoded SCLK times packts : Array of packets rate : Nominal SCLK rate in seconds per tick nints : Number of intervals starts : Encoded SCLK interval start times References NAIF Documentation source SPICE.cleard  —  Function cleard(array) Deprecated Use  empty!(array)  instead. source SPICE.clight  —  Method clight() Returns the speed of light in vacuum (km/sec). References NAIF Documentation source SPICE.clpool  —  Method clpool() Remove all variables from the kernel pool. Watches on kernel variables are retained. References NAIF Documentation source SPICE.cmprss  —  Method cmprss(delim, n, input) Compress a character string by removing occurrences of more than  n  consecutive occurrences of a specified character. Arguments delim : Delimiter to be compressed n : Maximum consecutive occurrences of delim input : Input string Output Returns the compressed string. References NAIF Documentation source SPICE.cnmfrm  —  Function cnmfrm(cname) Retrieve frame ID code and name to associate with an object. Arguments cname : Name of the object to find a frame for Output Returns a tuple of the ID code and the name of the frame associated with  cname  or  nothing  if no frame is found. References NAIF Documentation source SPICE.conics  —  Method conics(elts, et) Determine the state (position, velocity) of an orbiting body from a set of elliptic, hyperbolic, or parabolic orbital elements. Arguments elts : Conic elements et : Input time Output Returns the state of orbiting body at  et . References NAIF Documentation source SPICE.convrt  —  Method convrt(x, in, out) Take a measurement  x , the units associated with  x , and units to which  x  should be converted; return  y  - the value of the measurement in the output units. Arguments x : Number representing a measurement in some units in : The units in which x is measured out : Desired units for the measurement Output Returns the measurement in the desired units. References NAIF Documentation source SPICE.cpos  —  Method cpos(str, chars, start) Find the first occurrence in a string of a character belonging to a collection of characters, starting at a specified location, searching forward. Arguments str : Any character string chars : A collection of characters start : Position to begin looking for one of chars Output Returns the index of the first character of  str  that is one of the characters in string  chars . Returns -1 if none of the characters was found. References NAIF Documentation source SPICE.cposr  —  Method cposr(str, chars, start) Find the first occurrence in a string of a character belonging to a collection of characters, starting at a specified location, searching in reverse. Arguments str : Any character string chars : A collection of characters start : Position to begin looking for one of chars Output Returns the index of the last character of  str  that is one of the characters in string  chars . Returns -1 if none of the characters was found. References NAIF Documentation source SPICE.cvpool  —  Method cvpool(agent) Indicate whether or not any watched kernel variables that have a specified agent on their notification list have been updated. Arguments agent : Name of the agent to check for notices Output Returns  true  if variables for  agent  have been updated. References NAIF Documentation source SPICE.cyllat  —  Method cyllat(r, lonc, z) Convert from cylindrical to latitudinal coordinates. Arguments r : Distance of point from z axis lonc : Cylindrical angle of point from XZ plane (radians) z : Height of point above XY plane Output radius : Radius lon : Longitude (radians) lat : Latitude (radians) References NAIF Documentation source SPICE.cylrec  —  Method cylrec(r, lon, z) Convert from cylindrical to rectangular coordinates. Arguments r : Distance of the point of interest from z axis lon : Cylindrical angle (in radians) of the point of interest from XZ plane z : Height of the point above XY plane Output Returns rectangular coordinates of the point of interest. References NAIF Documentation source SPICE.cylsph  —  Method cylsph(r, lonc, z) Convert from cylindrical to spherical coordinates. Arguments r : Distance of point from z axis lonc : Angle (radians) of point from XZ plane z : Height of point above XY plane Output radius : Distance of the point from the origin colat : Polar angle (co-latitude in radians) lon : Azimuthal angle (longitude) References NAIF Documentation source SPICE.dafac  —  Method dafac(handle, buffer) Add comments from a buffer of character strings to the comment area of a binary DAF file, appending them to any comments which are already present in the file's comment area. Arguments handle : Handle of a DAF opened with write access buffer : Buffer of comments to put into the comment area References NAIF Documentation source SPICE.dafbbs  —  Method dafbbs(handle) Begin a backward search for arrays in a DAF. Arguments handle : Handle of DAF to be searched References NAIF Documentation source SPICE.dafbfs  —  Method dafbfs(handle) Begin a forward search for arrays in a DAF. Arguments handle : Handle of DAF to be searched References NAIF Documentation source SPICE.dafcls  —  Method dafcls(handle) Close the DAF associated with a given handle. Arguments handle : Handle of DAF to be closed Output Returns the handle of the closed file. References NAIF Documentation source SPICE.dafcs  —  Method dafcs(handle) Select a DAF that already has a search in progress as the one to continue searching. Arguments handle : Handle of DAF to continue searching References NAIF Documentation source SPICE.dafdc  —  Method dafdc(handle) Delete the entire comment area of a specified DAF file. Arguments handle : The handle of a binary DAF opened for writing References NAIF Documentation source SPICE.dafec  —  Method dafec(handle; bufsiz=256, lenout=1024) Extract comments from the comment area of a binary DAF. Arguments handle : Handle of binary DAF opened with read access bufsiz : Maximum size, in lines, of buffer (default: 256) lenout : Length of strings in output buffer (default: 1024) Output Returns a buffer where extracted comment lines are placed. References NAIF Documentation source SPICE.daffna  —  Method daffna() Find the next (forward) array in the current DAF. Output Returns  true  if an array was found. References NAIF Documentation source SPICE.daffpa  —  Method daffpa() Find the previous (backward) array in the current DAF. Output Returns  true  if an array was found. References NAIF Documentation source SPICE.dafgda  —  Method dafgda(handle, start, stop) Read the double precision data bounded by two addresses within a DAF. Arguments handle : Handle of a DAF start, stop : Initial, final address within file Output Returns the data contained between  start  and  stop . References NAIF Documentation source SPICE.dafgh  —  Method dafgh() Return (get) the handle of the DAF currently being searched. References NAIF Documentation source SPICE.dafgn  —  Function dafgn(lenout=128) Return (get) the name for the current array in the current DAF. Arguments lenout : Length of array name string (default: 128) Output Returns the name of the current array. References NAIF Documentation source SPICE.dafgs  —  Function dafgs(lenout=128) Return (get) the summary for the current array in the current DAF. Arguments lenout : The maximum length of the summary array Output Returns the summary for the current array. References NAIF Documentation source SPICE.dafgsr  —  Method dafgsr(handle, recno, start, stop) Read a portion of the contents of a summary record in a DAF file. Arguments handle : Handle of DAF recno : Record number start : First word to read from record stop : Last word to read from record Output Returns the contents of the record or  nothing  if none was found. References NAIF Documentation source SPICE.dafopr  —  Method dafopr(fname) Open a DAF for subsequent read requests. Arguments fname : Name of DAF to be opened Output Returns the handle assigned to DAF. References NAIF Documentation source SPICE.dafopw  —  Method dafopw(fname) Open a DAF for subsequent write requests. Arguments fname : Name of DAF to be opened Output Returns the handle assigned to DAF. References NAIF Documentation source SPICE.dafps  —  Method dafps(dc, ic) Pack (assemble) an array summary from its double precision and integer components. Arguments dc : Double precision components ic : Integer components Output Returns the array summary. References NAIF Documentation source SPICE.dafrfr  —  Function dafrfr(handle, lenout=128) Read the contents of the file record of a DAF. Arguments handle : Handle of an open DAF file lenout : Available room in the output string  ifname  (default: 128) Output nd : Number of double precision components in summaries ni : Number of integer components in summaries ifname : Internal file name fward : Forward list pointer bward : Backward list pointer free : Free address pointer References NAIF Documentation source SPICE.dafrs  —  Method dafrs(sum) Change the summary for the current array in the current DAF. Arguments sum : New summary for current array References NAIF Documentation source SPICE.dafus  —  Method dafus(sum, nd, ni) Unpack an array summary into its double precision and integer components. Arguments sum : Array summary nd : Number of double precision components ni : Number of integer components Output dc : Double precision components ic : Integer components References NAIF Documentation source SPICE.dasac  —  Method dasac(handle, buffer) Add comments from a buffer of character strings to the comment area of a binary DAS file, appending them to any comments which are already present in the file's comment area. Arguments handle : Handle of a DAS opened with write access buffer : Buffer of comments to put into the comment area References NAIF Documentation source SPICE.dascls  —  Method dascls(handle) Close the DAS associated with a given handle. Arguments handle : Handle of DAS to be closed Output Returns the handle of the closed file. References NAIF Documentation source SPICE.dasdc  —  Method dasdc(handle) Delete the entire comment area of a specified DAS file. Arguments handle : The handle of a binary DAS opened for writing References NAIF Documentation source SPICE.dasec  —  Method dasec(handle; bufsiz=256, lenout=1024) Extract comments from the comment area of a binary DAS. Arguments handle : Handle of binary DAS opened with read access bufsiz : Maximum size, in lines, of buffer (default: 256) lenout : Length of strings in output buffer (default: 1024) Output Returns a buffer where extracted comment lines are placed. References NAIF Documentation source SPICE.dashfn  —  Function dashfn(handle, namelen=256) Return the name of the DAS file associated with a handle. Arguments handle : Handle of a DAS file namlen : Length of output file name string (default: 256) Output Returns the corresponding file name. References NAIF Documentation source SPICE.dasopr  —  Method dasopr(fname) Open a DAS for subsequent read requests. Arguments fname : Name of DAS to be opened Output Returns the handle assigned to DAS. References NAIF Documentation source SPICE.dasopw  —  Method dasopw(fname) Open a DAS for subsequent write requests. Arguments fname : Name of DAS to be opened Output Returns the handle assigned to DAS. References NAIF Documentation source SPICE.dasrfr  —  Function dasrfr(handle, idwlen=128, ifnlen=256) Read the contents of the file record of a DAS. Arguments handle : DAS file handle idwlen : Length of ID word string (default: 128) ifnlen : Length of internal file name string (default: 256) Output idword : ID word ifname : DAS internal file name nresvr : Number of reserved records in file nresvc : Number of characters in use in reserved records area ncomr : Number of comment records in file ncomc : Number of characters in use in comment area References NAIF Documentation source SPICE.dazldr  —  Method dazldr(x, y, z; azccw=true, elplsz=true) Compute the Jacobian matrix of the transformation from rectangular to azimuth/elevation coordinates. Arguments x : X-coordinate of point y : Y-coordinate of point z : Z-coordinate of point Keyword Arguments azccw : Flag indicating how azimuth is measured. If  true  (the default), the azimuth increases in the counterclockwise direction; otherwise it increases in the clockwise direction elplsz : Flag indicating how elevation is measured. If  true  (the default), the elevation increases from the XY plane toward +Z; otherwise toward -Z Output Returns the matrix of partial derivatives. References NAIF Documentation source SPICE.dcyldr  —  Method dcyldr(x, y, z) Compute the Jacobian of the transformation from rectangular to cylindrical coordinates. Arguments x : X-coordinate of point y : Y-coordinate of point z : Z-coordinate of point Output Returns the matrix of partial derivatives. References NAIF Documentation source SPICE.deltet  —  Method deltet(epoch, eptype) Return the value of ΔET (ET-UTC) for an input epoch. Arguments epoch : Input epoch (seconds past J2000) eptype : Type of input epoch (\"UTC\" or \"ET\") Output Returns ΔET (ET-UTC) at input epoch. References NAIF Documentation source SPICE.dgeodr  —  Method dgeodr(x, y, z, re, f) Compute the Jacobian of the transformation from rectangular to geodetic coordinates. Arguments x : X-coordinate of point y : Y-coordinate of point z : Z-coordinate of point re : Equatorial radius of the reference spheroid f : Flattening coefficient Output Returns the matrix of partial derivatives. References NAIF Documentation source SPICE.diags2  —  Method diags2(symmat) Diagonalize a symmetric 2×2 matrix. Arguments symmat : A symmetric 2×2 matrix Output diag : A diagonal matrix similar to  symmat rotate : A rotation used as the similarity transformation References NAIF Documentation source SPICE.dlabbs  —  Method dlabbs(handle) Begin a backward segment search in a DLA file. Arguments handle : Handle of open DLA file Output Returns the descriptor of the last segment in the DLA file or  nothing  if none was found. References NAIF Documentation source SPICE.dlabfs  —  Method dlabfs(handle) Begin a forward segment search in a DLA file. Arguments handle : Handle of open DLA file Output Returns the descriptor of the first segment in the DLA file or  nothing  if none was found. References NAIF Documentation source SPICE.dlafns  —  Method dlafns(handle, descr) Find the segment following a specified segment in a DLA file. Arguments handle : Handle of open DLA file descr : Descriptor of a DLA segment Output Returns the descriptor of the next segment in the DLA file or  nothing  if none was found. References NAIF Documentation source SPICE.dlafps  —  Method dlafps(handle, descr) Find the segment preceding a specified segment in a DLA file. Arguments handle : Handle of open DLA file descr : Descriptor of a DLA segment Output Returns the descriptor of the previous segment in the DLA file or  nothing  if none was found. References NAIF Documentation source SPICE.dlatdr  —  Method dlatdr(x, y, z) Compute the Jacobian of the transformation from rectangular to latitudinal coordinates. Arguments x : X-coordinate of point y : Y-coordinate of point z : Z-coordinate of point Output Returns the matrix of partial derivatives. References NAIF Documentation source SPICE.dp2hx  —  Function dp2hx(number, lenout=128) Convert a double precision number to an equivalent character string using base 16 \"scientific notation.\" Arguments number : Number to be converted lenout : Available space for output string Output Returns the equivalent character string, left justified. References NAIF Documentation source SPICE.dpgrdr  —  Method dpgrdr(x, y, z, re, f) Compute the Jacobian of the transformation from rectangular to planetographic coordinates. Arguments body : Body with which coordinate system is associated x : X-coordinate of point y : Y-coordinate of point z : Z-coordinate of point re : Equatorial radius of the reference spheroid f : Flattening coefficient Output Returns the matrix of partial derivatives. References NAIF Documentation source SPICE.dpmax  —  Function dpmax() Deprecated Use  prevfloat(typemax(Float64))  instead. source SPICE.dpmin  —  Function dpmin() Deprecated Use  nextfloat(typemin(Float64))  instead. source SPICE.dpr  —  Function dpr() Deprecated Use  rad2deg(1.0)  instead. source SPICE.drdazl  —  Method drdazl(range, az, el; azccw=true, elplsz=true) Compute the Jacobian matrix of the transformation from azimuth/elevation to rectangular coordinates. Arguments range : Distance of a point from the origin az : Azimuth of input point in radians el : Elevation of input point in radians Keyword Arguments azccw : Flag indicating how azimuth is measured. If  true  (the default), the azimuth increases in the counterclockwise direction; otherwise it increases in the clockwise direction elplsz : Flag indicating how elevation is measured. If  true  (the default), the elevation increases from the XY plane toward +Z; otherwise toward -Z Output Returns the matrix of partial derivatives. References NAIF Documentation source SPICE.drdcyl  —  Method drdcyl(r, lon, z) Compute the Jacobian of the transformation from cylindrical to rectangular coordinates. Arguments r : Distance of a point from the origin lon : Angle of the point from the xz plane in radians z : Height of the point above the xy plane Output Returns the matrix of partial derivatives. References NAIF Documentation source SPICE.drdgeo  —  Method drdgeo(lon, lat, alt, re, f) Compute the Jacobian of the transformation from geodetic to rectangular coordinates. Arguments lon : Geodetic longitude of point (radians) lat : Geodetic latitude of point (radians) alt : Altitude of point above the reference spheroid re : Equatorial radius of the reference spheroid f : Flattening coefficient Output Returns the matrix of partial derivatives. References NAIF Documentation source SPICE.drdlat  —  Method drdlat(radius, lon, lat) Compute the Jacobian of the transformation from latitudinal to rectangular coordinates. Arguments radius : Distance of a point from the origin lon : Angle of the point from the XZ plane in radians lat : Angle of the point from the XY plane in radians Output Returns the matrix of partial derivatives. References NAIF Documentation source SPICE.drdpgr  —  Method drdpgr(body, lon, lat, alt, re, f) Compute the Jacobian matrix of the transformation from planetographic to rectangular coordinates. Arguments body : Name of body with which coordinates are associated lon : Planetographic longitude of a point (radians) lat : Planetographic latitude of a point (radians) alt : Altitude of a point above reference spheroid re : Equatorial radius of the reference spheroid f : Flattening coefficient Output Returns the matrix of partial derivatives. References NAIF Documentation source SPICE.drdsph  —  Method drdsph(r, colat, lon) Compute the Jacobian of the transformation from latitudinal to rectangular coordinates. Arguments r : Distance of a point from the origin colat : Angle of the point from the positive z-axis lon : Angle of the point from the xy plane Output Returns the matrix of partial derivatives. References NAIF Documentation source SPICE.dskb02  —  Method dskb02(handle, dladsc) Return bookkeeping data from a DSK type 2 segment. Arguments handle : DSK file handle dladsc : DLA descriptor Output nv : Number of vertices in model np : Number of plates in model nvxtot : Number of voxels in fine grid vtxbds : Vertex bounds voxsiz : Fine voxel edge length voxori : Fine voxel grid origin vgrext : Fine voxel grid exent cgscal : Coarse voxel grid scale vtxnpl : Size of vertex-plate correspondence list voxnpt : Size of voxel-plate pointer list voxnpl : Size of voxel-plate correspondence list References NAIF Documentation source SPICE.dskcls  —  Function dskcls(handle, optmiz=true) Close a DSK file. Arguments handle : Handle assigned to the opened DSK file optmiz : Flag indicating whether to segregate the DSK (default:  true ) References NAIF Documentation source SPICE.dskd02  —  Method dskd02(handle, dladsc, item, start, room) Fetch double precision data from a type 2 DSK segment. Arguments handle : DSK file handle dladsc : DLA descriptor item : Keyword identifying item to fetch start : Start index room : Amount of room in output array Output Returns an array containing the requested item. References NAIF Documentation source SPICE.dskgd  —  Method dskgd(handle, dladsc) Return the DSK descriptor from a DSK segment identified by a DAS handle and DLA descriptor. Arguments handle : Handle of a DSK file dladsc : DLA segment descriptor Output Returns the DSK segment descriptor. References NAIF Documentation source SPICE.dskgtl  —  Method dskgtl(keywrd) Retrieve the value of a specified DSK tolerance or margin parameter. Arguments keywrd : Code specifying parameter to retrieve Output Returns the value of the parameter. References NAIF Documentation source SPICE.dski02  —  Method dski02(handle, dladsc, item, start, room) Fetch integer data from a type 2 DSK segment. Arguments handle : DSK file handle dladsc : DLA descriptor item : Keyword identifying item to fetch start : Start index room : Amount of room in output array Output Returns an array containing the requested item. References NAIF Documentation source SPICE.dskmi2  —  Method dskmi2(vrtces, plates, finscl, corscl, worksz, voxpsz, voxlsz, makvtl, spaisz) Make spatial index for a DSK type 2 segment. Arguments vrtces : Vertices plates : Plates finscl : Fine voxel scale corscl : Coarse voxel scale worksz : Workspace size voxpsz : Voxel-plate pointer array size voxlsz : Voxel-plate list array size makvtl : Vertex-plate list flag spxisz : Spatial index integer component size Output spaixd : Double precision component of spatial index. spaixi : Integer component of spatial index. References NAIF Documentation source SPICE.dskn02  —  Method dskn02(handle, dladsc, plid) Compute the unit normal vector for a specified plate from a type 2 DSK segment. Arguments handle : DSK file handle dladsc : DLA descriptor plid : Plate ID Output Return the plate's unit normal vector. References NAIF Documentation source SPICE.dskobj!  —  Method dskobj!(set, dsk) Find the set of body ID codes of all objects for which topographic data are provided in a specified DSK file. Arguments dsk : Name of DSK file set  or  len : Either a preallocated  SpiceIntCell  or the  size  of the output set. Output Returns the set of ID codes of objects in the DSK file. References NAIF Documentation source SPICE.dskopn  —  Method dskopn(fname, ifname, ncomch) Open a new DSK file for subsequent write operations. Arguments fname : Name of a DSK file to be opened ifname : Internal file name ncomch : Number of comment characters to allocate Output Returns the handle assigned to the opened DSK file. References NAIF Documentation source SPICE.dskp02  —  Method dskp02(handle, dladsc, start, room) Fetch triangular plates from a type 2 DSK segment. Arguments handle : DSK file handle dladsc : DLA descriptor start : Start index room : Amount of room in output array Output Returns an array of plates. References NAIF Documentation source SPICE.dskrb2  —  Method dskrb2(vrtces, plates, corsys, corpar) Determine range bounds for a set of triangular plates to be stored in a type 2 DSK segment. Arguments vrtces : Vertices plates : Plates corsys : DSK coordinate system code corpar : DSK coordinate system parameters Output mncor3 : Lower bound on range of third coordinate mxcor3 : Upper bound on range of third coordinate References NAIF Documentation source SPICE.dsksrf!  —  Method dsksrf!(set, dsk) Find the set of surface ID codes of all objects for which topographic data are provided in a specified DSK file. Arguments dsk : Name of DSK file set  or  len : Either a preallocated  SpiceIntCell  or the  size  of the output set. Output Returns the set of ID codes of surfaces in the DSK file. References NAIF Documentation source SPICE.dskstl  —  Method dskstl(keywrd) Set the value of a specified DSK tolerance or margin parameter. Arguments keywrd : Code specifying parameter to retrieve dpval : Value of parameter References NAIF Documentation source SPICE.dskv02  —  Method dskv02(handle, dladsc, start, room) Fetch vertices from a type 2 DSK segment. Arguments handle : DSK file handle dladsc : DLA descriptor start : Start index room : Amount of room in output array Output Returns an array of vertices. References NAIF Documentation source SPICE.dskw02  —  Method dskw02(handle, center, surfid, dclass, frame, corsys, corpar, mncor1, mxcor1,\n       mncor2, mxcor2, mncor3, mxcor3, first, last, vrtces, plates, spaixd, spaixi) Write a type 2 segment to a DSK file. Arguments handle : Handle assigned to the opened DSK file center : Central body ID code surfid : Surface ID code dclass : Data class frame : Reference frame corsys : Coordinate system code corpar : Coordinate system parameters mncor1 : Minimum value of first coordinate mxcor1 : Maximum value of first coordinate mncor2 : Minimum value of second coordinate mxcor2 : Maximum value of second coordinate mncor3 : Minimum value of third coordinate mxcor3 : Maximum value of third coordinate first : Coverage start time last : Coverage stop time nv : Number of vertices vrtces : Vertices np : Number of plates plates : Plates spaixd : Double precision component of spatial index spaixi : Integer component of spatial index References NAIF Documentation source SPICE.dskx02  —  Method dskx02(handle, dladsc, vertex, raydir) Determine the plate ID and body-fixed coordinates of the intersection of a specified ray with the surface defined by a type 2 DSK plate model. Arguments handle : Handle of DSK kernel containing plate model dladsc : DLA descriptor of plate model segment vertex : Ray vertex in the body fixed frame raydir : Ray direction in the body fixed frame Output Returns  nothing  if no intercept exists or plid : ID code of the plate intersected by the ray xpt : Intercept References NAIF Documentation source SPICE.dskxsi  —  Function dskxsi(pri, target, nsurf, srflst, et, fixref, vertex, raydir, maxd=1, maxi=1) Compute a ray-surface intercept using data provided by multiple loaded DSK segments. Return information about the source of the data defining the surface on which the intercept was found: DSK handle, DLA and DSK descriptors, and DSK data type-dependent parameters. Arguments pri : Data prioritization flag target : Target body name srflst : Surface ID list et : Epoch, expressed as seconds past J2000 TDB fixref : Name of target body-fixed reference frame vertex : Vertex of ray raydir : Direction vector of ray maxd : Size of DC array (default: 1) maxi : Size of IC array (default: 1) Output Returns  nothing  if no intercept exists or xpt : Intercept point handle : Handle of segment contributing surface data dladsc : DLA descriptor of segment dskdsc : DSK descriptor of segment dc : Double precision component of source info ic : Integer component of source info References NAIF Documentation source SPICE.dskxv  —  Method dskxv(pri, target, srflst, et, fixref, nrays, vtxarr, dirarr) Compute ray-surface intercepts for a set of rays, using data provided by multiple loaded DSK segments. Arguments pri : Data prioritization flag target : Target body name srflst : Surface ID list et : Epoch, expressed as seconds past J2000 TDB fixref : Name of target body-fixed reference frame nrays : Number of rays vtxarr : Array of vertices of rays dirarr : Array of direction vectors of rays Output xptarr : Intercept point array fndarr : Found flag array References NAIF Documentation source SPICE.dskz02  —  Method dskz02(handle, dladsc) Return plate model size parameters - plate count and vertex count - for a type 2 DSK segment. Arguments handle : DSK file handle dladsc : DLA descriptor Output nv : Number of vertices np : Number of plates References NAIF Documentation source SPICE.dsphdr  —  Method dsphdr(x, y, z) Compute the Jacobian of the transformation from rectangular to spherical coordinates. Arguments x : X-coordinate of point y : Y-coordinate of point z : Z-coordinate of point Output Returns the matrix of partial derivatives. References NAIF Documentation source SPICE.dtpool  —  Method dtpool(name) Return the data about a kernel pool variable. Arguments name : Name of the variable whose value is to be returned Output Returns the tuple  (n ,vartype) . n : Number of values returned for name vartype : Type of the variable :C  if the data is character data :N  if the data is numeric :X  if there is no variable name in the pool References NAIF Documentation source SPICE.ducrss  —  Method ducrss(s1, s2) Compute the unit vector parallel to the cross product of two 3-dimensional vectors and the derivative of this unit vector. Arguments s1 : Left hand state for cross product and derivative s2 : Right hand state for cross product and derivative Output Returns the unit vector and derivative of the cross product. References NAIF Documentation source SPICE.dvcrss  —  Method dvcrss(s1, s2) Compute the cross product of two 3-dimensional vectors and the derivative of this cross product. Arguments s1 : Left hand state for cross product and derivative s2 : Right hand state for cross product and derivative Output Returns the cross product and its derivative. References NAIF Documentation source SPICE.dvdot  —  Method dvdot(s1, s2) Compute the derivative of the dot product of two double precision position vectors. Arguments s1 : First state vector in the dot product s2 : Second state vector in the dot product Output Returns the derivative of the dot product  s1 ⋅ s2 . References NAIF Documentation source SPICE.dvhat  —  Method dvhat(s1) Find the unit vector corresponding to a state vector and the derivative of the unit vector. Arguments s1 : State to be normalized Output Returns the unit vector  s1 / |s1| , and its time derivative. References NAIF Documentation source SPICE.dvnorm  —  Method dvnorm(state) Function to calculate the derivative of the norm of a 3-vector. Arguments state : A 6-vector composed of three coordinates and their derivatives. Output Returns the derivative of the norm of  state . References NAIF Documentation source SPICE.dvpool  —  Method dvpool(name) Delete a variable from the kernel pool. Arguments name : Name of the kernel variable to be deleted References NAIF Documentation source SPICE.dvsep  —  Method dvsep(s1, s2) Calculate the time derivative of the separation angle between two input states,  s1  and  s2 . Arguments s1 : State vector of the first body s2 : State vector of the second  body Output Returns the value of the time derivative of the angular separation between  s1  and  s2 . References NAIF Documentation source SPICE.edlimb  —  Method edlimb(a, b, c, viewpt) Find the limb of a triaxial ellipsoid, viewed from a specified point. Arguments a : Length of ellipsoid semi-axis lying on the x-axis b : Length of ellipsoid semi-axis lying on the y-axis c : Length of ellipsoid semi-axis lying on the z-axis viewpt : Location of viewing point Output Returns the limb of the ellipsoid as seen from the viewing point. References NAIF Documentation source SPICE.edterm  —  Method edterm(trmtyp, source, target, et, fixref, abcorr, obsrvr, npts) Compute a set of points on the umbral or penumbral terminator of a specified target body, where the target shape is modeled as an ellipsoid. Arguments trmtyp : Terminator type source : Light source target : Target body et : Observation epoch fixref : Body-fixed frame associated with target abcorr : Aberration correction obsrvr : Observer npts : Number of points in terminator set Output trgepc : Epoch associated with target center obspos : Position of observer in body-fixed frame trmpts : Terminator point set References NAIF Documentation source SPICE.ekacec  —  Method ekacec(handle, segno, recno, column, cvals, isnull) Add data to a character column in a specified EK record. Arguments handle : EK file handle segno : Index of segment containing record recno : Record to which data is to be added column : Column name cvals : Character values to add to column isnull : Flag indicating whether column entry is null References NAIF Documentation source SPICE.ekaced  —  Method ekaced(handle, segno, recno, column, dvals, isnull) Add data to an double precision column in a specified EK record. Arguments handle : EK file handle segno : Index of segment containing record recno : Record to which data is to be added column : Column name dvals : Double precision values to add to column isnull : Flag indicating whether column entry is null References NAIF Documentation source SPICE.ekacei  —  Method ekacei(handle, segno, recno, column, ivals, isnull) Add data to an integer column in a specified EK record. Arguments handle : EK file handle segno : Index of segment containing record recno : Record to which data is to be added column : Column name ivals : Integer values to add to column isnull : Flag indicating whether column entry is null References NAIF Documentation source SPICE.ekaclc  —  Method ekaclc(handle, segno, column, cvals, nlflgs, rcptrs) Add an entire character column to an EK segment. Arguments handle : EK file handle. segno : Number of segment to add column to. column : Column name. cvals : Character values to add to column. nlflgs : Array of null flags for column entries. rcptrs : Record pointers for segment. References NAIF Documentation source SPICE.ekacld  —  Method ekacld(handle, segno, column, dvals, nlflgs, rcptrs) Add an entire double precision column to an EK segment. Arguments handle : EK file handle segno : Number of segment to add column to column : Column name dvals : Double precision values to add to column nlflgs : Array of null flags for column entries rcptrs : Record pointers for segment References NAIF Documentation source SPICE.ekacli  —  Method ekacli(handle, segno, column, ivals, nlflgs, rcptrs) Add an entire integer column to an EK segment. Arguments handle : EK file handle segno : Number of segment to add column to column : Column name ivals : Integer values to add to column nlflgs : Array of null flags for column entries rcptrs : Record pointers for segment References NAIF Documentation source SPICE.ekappr  —  Method ekappr(handle, segno) Append a new, empty record at the end of a specified E-kernel segment. Arguments handle : File handle segno : Segment number Output Returns the number of appended record. References NAIF Documentation source SPICE.ekbseg  —  Method ekbseg(handle, tabnam, cnames, decls) Start a new segment in an E-kernel. Arguments handle : File handle tabnam : Table name cnames : Names of columns decls : Declarations of columns Output Returns the segment number. References NAIF Documentation source SPICE.ekccnt  —  Method ekccnt(table) Return the number of distinct columns in a specified, currently loaded table Arguments table : Name of table Output Returns the count of distinct, currently loaded columns. References NAIF Documentation source SPICE.ekcii  —  Function ekcii(table, cindex, lenout=256) Return attribute information about a column belonging to a loaded EK table, specifying the column by table and index. Arguments table : Name of table containing column cindex : Index of column whose attributes are to be found lenout : Maximum allowed length of column name (default: 256) Output column : Name of column attdsc : Column attribute descriptor References NAIF Documentation source SPICE.ekcls  —  Method ekcls(handle) Close an E-kernel. Arguments handle : EK file handle References NAIF Documentation source SPICE.ekdelr  —  Method ekdelr(handle, segno, recno) Delete a specified record from a specified E-kernel segment. Arguments handle : File handle segno : Segment number recno : Record number References NAIF Documentation source SPICE.ekffld  —  Method ekffld(handle, segno, rcptrs) Complete a fast write operation on a new E-kernel segment. Arguments handle : File handle segno : Segment number rcptrs : Record pointers References NAIF Documentation source SPICE.ekfind  —  Function ekfind(query, lenout=256) Find E-kernel data that satisfy a set of constraints. Arguments query : Query specifying data to be found. lenout : Declared length of output error message string (default: 256) Output Returns the number of matching rows. References NAIF Documentation source SPICE.ekgc  —  Function ekgc(selidx, row, elment, lenout=256) Return an element of an entry in a column of character type in a specified row. Arguments selidx : Index of parent column in SELECT clause row : Row to fetch from elment : Index of element, within column entry, to fetch lenout : Maximum length of column element (default: 256) Output Returns the character string element of column entry or  missing  if it was null or  nothing  if the column was not found. References NAIF Documentation source SPICE.ekgd  —  Method ekgd(selidx, row, element) Return an element of an entry in a column of double precision type in a specified row. Arguments selidx : Index of parent column in SELECT clause row : Row to fetch from elment : Index of element, within column entry, to fetch Output Returns the double precision element of column entry or  missing  if it was null or  nothing  if the column was not found. References NAIF Documentation source SPICE.ekgi  —  Method ekgi(selidx, row, element) Return an element of an entry in a column of integer type in a specified row. Arguments selidx : Index of parent column in SELECT clause row : Row to fetch from elment : Index of element, within column entry, to fetch Output Returns the integer element of column entry or  missing  if it was null or  nothing  if the column was not found. References NAIF Documentation source SPICE.ekifld  —  Method ekifld(handle, tabnam, nrows, cnames, decls) Initialize a new E-kernel segment to allow fast writing. Arguments handle : File handle tabnam : Table name nrows : Number of rows in the segment cnames : Names of columns decls : Declarations of columns Output segno : Segment number rcptrs : Array of record pointers References NAIF Documentation source SPICE.ekinsr  —  Method ekinsr(handle, segno, recno) Add a new, empty record to a specified E-kernel segment at a specified index. Arguments handle : File handle segno : Segment number recno : Record number References NAIF Documentation source SPICE.eklef  —  Method eklef(fname) Load an EK file, making it accessible to the EK readers. Arguments fname : Name of EK file to load Output Returns the file handle of loaded EK file. References NAIF Documentation source SPICE.eknelt  —  Method eknelt(selidx, row) Return the number of elements in a specified column entry in the current row. Arguments selidx : Index of parent column in SELECT clause row : Row containing element Output Returns the number of elements in entry in current row. References NAIF Documentation source SPICE.eknseg  —  Method eknseg(handle) Return the number of segments in a specified EK. Arguments handle : EK file handle Output Returns the number of segments in the specified E-kernel. References NAIF Documentation source SPICE.ekntab  —  Method ekntab() Return the number of loaded EK tables. References NAIF Documentation source SPICE.ekopn  —  Method ekopn(fname, ifname, ncomch) Open a new E-kernel file and prepare the file for writing. Arguments fname : Name of EK file ifname : Internal file name ncomch : The number of characters to reserve for comments Output Return the handle attached to the new EK file. References NAIF Documentation source SPICE.ekopr  —  Method ekopr(fname) Open an existing E-kernel file for reading. Arguments fname : Name of EK file Output Returns the handle attached to the EK file. References NAIF Documentation source SPICE.ekops  —  Method ekops() Open a scratch (temporary) E-kernel file and prepare the file for writing. Output Returns the handle attached to the EK file. References NAIF Documentation source SPICE.ekopw  —  Method ekopw(fname) Open an existing E-kernel file for writing. Arguments fname : Name of EK file Output Returns the handle attached to the EK file. References NAIF Documentation source SPICE.ekpsel  —  Function ekpsel(query, msglen=256, tablen=256, collen=256) Parse the SELECT clause of an EK query, returning full particulars concerning each selected item. Arguments query : EK query msglen : Available space in the output error message string (default: 256) tablen : Length of strings in  tabs  output array (default: 256) collen : Length of strings in  cols  output array (default: 256) Output xbegs : Begin positions of expressions in SELECT clause xends : End positions of expressions in SELECT clause xtypes : Data types of expressions xclass : Classes of expressions tabs : Names of tables qualifying SELECT columns cols : Names of columns in SELECT clause of query References NAIF Documentation source SPICE.ekrcec  —  Function ekrcec(handle, segno, recno, column, lenout=256, nelts=100) Read data from a character column in a specified EK record. Arguments handle : Handle attached to EK file segno : Index of segment containing record recno : Record from which data is to be read column : Column name lenout : Maximum length of output strings nelts : Maximum number of elements to return (default: 100) Output Returns the character values in column entry or  missing  if they are null. References NAIF Documentation source SPICE.ekrced  —  Function ekrced(handle, segno, recno, column, nelts=100) Read data from a double precision column in a specified EK record. Arguments handle : Handle attached to EK file segno : Index of segment containing record recno : Record from which data is to be read column : Column name nelts : Maximum number of elements to return (default: 100) Output Returns the values in column entry. References NAIF Documentation source SPICE.ekrcei  —  Function ekrcei(handle, segno, recno, column, nelts=100) Read data from an integer column in a specified EK record. Arguments handle : Handle attached to EK file segno : Index of segment containing record recno : Record from which data is to be read column : Column name nelts : Maximum number of elements to return (default: 100) Output Returns the values in column entry. References NAIF Documentation source SPICE.ekssum  —  Method ekssum(handle, segno) Return summary information for a specified segment in a specified EK. Arguments handle : Handle of EK segno : Number of segment to be summarized Output Returns the EK segment summary. References NAIF Documentation source SPICE.ektnam  —  Function ektnam(n, lenout=256) Return the name of a specified, loaded table. Arguments n : Index of table lenout : Maximum table name length (default: 256) Output Returns the name of table. References NAIF Documentation source SPICE.ekucec  —  Method ekucec(handle, segno, recno, column, cvals, isnull) Update a character column entry in a specified EK record. Arguments handle : EK file handle segno : Index of segment containing record recno : Record to which data is to be updated column : Column name cvals : Character values comprising new column entry isnull : Flag indicating whether column entry is null References NAIF Documentation source SPICE.ekuced  —  Method ekuced(handle, segno, recno, column, dvals, isnull) Update a double precision column entry in a specified EK record. Arguments handle : Handle attached to EK file segno : Index of segment containing record recno : Record in which entry is to be updated column : Column name dvals : Double precision values comprising new column entry isnull : Flag indicating whether column entry is null References NAIF Documentation source SPICE.ekucei  —  Method ekucei(handle, segno, recno, column, dvals, isnull) Update an integer column entry in a specified EK record. Arguments handle : Handle attached to EK file segno : Index of segment containing record recno : Record in which entry is to be updated column : Column name ivals : Integer values comprising new column entry isnull : Flag indicating whether column entry is null References NAIF Documentation source SPICE.ekuef  —  Method ekuef(handle) Unload an EK file, making its contents inaccessible to the EK reader routines, and clearing space in order to allow other EK files to be loaded. Arguments handle : Handle of EK file References NAIF Documentation source SPICE.el2cgv  —  Method el2cgv(ellipse) Convert an ellipse to a center vector and two generating vectors. The selected generating vectors are semi-axes of the ellipse. Arguments ellipse : An ellipse Output Returns the center and semi-axes of ellipse. References NAIF Documentation source SPICE.elemc  —  Function elemc(item, cell)\nelemd(item, cell)\nelemi(item, cell) Deprecated Use  item in cell  instead. source SPICE.elemd  —  Function elemc(item, cell)\nelemd(item, cell)\nelemi(item, cell) Deprecated Use  item in cell  instead. source SPICE.elemi  —  Function elemc(item, cell)\nelemd(item, cell)\nelemi(item, cell) Deprecated Use  item in cell  instead. source SPICE.eqncpv  —  Method eqncpv(et, epoch, eqel, rapol, decpol) Compute the state (position and velocity of an object whose trajectory is described via equinoctial elements relative to some fixed plane (usually the equatorial plane of some planet). Arguments et : Epoch in seconds past J2000 to find state epoch : Epoch of elements in seconds past J2000 eqel : Array of equinoctial elements rapol : Right Ascension of the pole of the reference plane decpol : Declination of the pole of the reference plane Output Returns the state of the object described by  eqel . References NAIF Documentation source SPICE.eqstr  —  Method eqstr(a, b) Determine whether two strings are equivalent. Arguments a ,  b : Arbitrary character strings Output Returns  true  if  a  and  b  are equivalent. References NAIF Documentation source SPICE.esrchc  —  Method esrchc(value, array) Search for a given value within a character string array. Arguments value : Key value to be found in array array : Character string array to search Output Returns the index of the first equivalent array entry, or -1 if no equivalent element is found. References NAIF Documentation source SPICE.et2lst  —  Function et2lst(et, body, lon, typ, timlen=128, ampmlen=128) Given an ephemeris epoch, compute the local solar time for an object on the surface of a body at a specified longitude. Arguments et : Epoch in seconds past J2000 epoch body : ID-code of the body of interest lon : Longitude of surface point (radians) typ : Type of longitude \"PLANETOCENTRIC\", etc timlen : Available room in output time string (default: 128) ampmlen : Available room in output  ampm  string (default: 128) Output hr : Local hour on a \"24 hour\" clock mn : Minutes past the hour sc : Seconds past the minute time : String giving local time on 24 hour clock ampm : String giving time on A.M./ P.M. scale References NAIF Documentation source SPICE.et2utc  —  Method et2utc(et, format, prec) Convert an input time from ephemeris seconds past J2000 to Calendar, Day-of-Year, or Julian Date format, UTC. Arguments et : Input epoch, given in ephemeris seconds past J2000 format : Format of output epoch. It may be any of the following: :C : Calendar format, UTC :D : Day-of-Year format, UTC :J : Julian Date format, UTC :ISOC : ISO Calendar format, UTC :ISOD : ISO Day-of-Year format, UTC prec : Digits of precision in fractional seconds or days Output Returns an output time string equivalent to the input epoch, in the specified format. References NAIF Documentation source SPICE.etcal  —  Function etcal(et, lenout=128) Convert from an ephemeris epoch measured in seconds past the epoch of J2000 to a calendar string format using a formal calendar free of leapseconds. Arguments et : Ephemeris time measured in seconds past J2000 lenout : Length of output string (default: 128) Output Returns a standard calendar representation of  et . References NAIF Documentation source SPICE.eul2m  —  Method eul2m(angle3, angle2, angle1, axis3, axis2, axis1) Construct a rotation matrix from a set of Euler angles. Arguments angle3 ,  angle2 ,  angle1 : Rotation angles about third, second, and first rotation axes (radians) axis3 ,  axis2 ,  axis1 : Axis numbers of third, second, and first rotation axes Output A rotation matrix corresponding to the product of the 3 rotations. References NAIF Documentation source SPICE.eul2xf  —  Method eul2xf(eulang, axisa, axisb, axisc) Compute a state transformation from an Euler angle factorization of a rotation and the derivatives of those Euler angles. Arguments eulang : An array of Euler angles and their derivatives axisa : Axis A of the Euler angle factorization axisb : Axis B of the Euler angle factorization axisc : Axis C of the Euler angle factorization Output Returns a state transformation matrix. References NAIF Documentation source SPICE.expool  —  Method expool(name) Confirm the existence of a kernel variable in the kernel pool. Arguments name : Name of the variable whose value is to be returned Output Returns  true  when the variable is in the pool. References NAIF Documentation source SPICE.fovray  —  Method fovray(inst, raydir, rframe, abcorr, observer, et) Determine if a specified ray is within the field-of-view (FOV) of a specified instrument at a given time. Arguments inst : Name or ID code string of the instrument raydir : Ray's direction vector rframe : Body-fixed, body-centered frame for target body abcorr : Aberration correction flag observer : Name or ID code string of the observer et : Time of the observation (seconds past J2000) Output Returns  true  if the ray is visible. References NAIF Documentation source SPICE.fovtrg  —  Method fovtrg(inst, target, tshape, tframe, abcorr, obsrvr, et) Determine if a specified ephemeris object is within the field-of-view (FOV) of a specified instrument at a given time. Arguments inst : Name or ID code string of the instrument. target : Name or ID code string of the target. tshape : Type of shape model used for the target. tframe : Body-fixed, body-centered frame for target body. abcorr : Aberration correction flag. obsrvr : Name or ID code string of the observer. et : Time of the observation (seconds past J2000). Output Returns  true  if the object is visible. References NAIF Documentation source SPICE.frame  —  Method frame(x) Given a vector  x , this routine builds a right handed orthonormal frame  x ,  y ,  z  where the output  x  is parallel to the input  x . Arguments x : Input vector Output x : Unit vector parallel to  x  on output y : Unit vector in the plane orthogonal to  x z : Unit vector given by  x × y References NAIF Documentation source SPICE.frinfo  —  Method frinfo(frcode) Retrieve the minimal attributes associated with a frame needed for converting transformations to and from it. Arguments frcode : The id code for a reference frame Output cent : The center of the frame frclss : The class (type) of the frame clssid : The idcode for the frame within its class Returns  nothing  if no frame with id  frcode  could be found. References NAIF Documentation source SPICE.frmnam  —  Method frmnam(frcode) Retrieve the name of a reference frame associated with an id code. Arguments frcode : The id code for a reference frame Output Returns the name associated with the reference frame. References NAIF Documentation source SPICE.furnsh  —  Method furnsh(kernels...) Load one or more SPICE kernels into a program. Arguments kernels : Path(s) of SPICE kernels to load References NAIF Documentation source SPICE.gcpool  —  Method gcpool(name; start=1, room=100, lenout=128) Return the value of a kernel variable from the kernel pool. Arguments name : Name of the variable whose value is to be returned start : Which component to start retrieving for name (default: 1) room : The largest number of values to return (default: 100) lenout : The length of the longest string to return (default: 128) Output Returns an array of values if the variable exists or  nothing  if not. References NAIF Documentation source SPICE.gdpool  —  Method gdpool(name; start=1, room=100) Return the value of a kernel variable from the kernel pool. Arguments name : Name of the variable whose value is to be returned start : Which component to start retrieving for name (default: 1) room : The largest number of values to return (default: 100) Output Returns an array of values if the variable exists or  nothing  if not. References NAIF Documentation source SPICE.georec  —  Method georec(lon, lat, alt, re, f) Convert geodetic coordinates to rectangular coordinates. Arguments lon : Geodetic longitude of point (radians) lat : Geodetic latitude  of point (radians) alt : Altitude of point above the reference spheroid re : Equatorial radius of the reference spheroid f : Flattening coefficient Output Returns the rectangular coordinates of point. References NAIF Documentation source SPICE.getelm  —  Method getelm(frstyr, lines) Given the \"lines\" of a two-line element set, parse the lines and return the elements in units suitable for use in SPICE software. Arguments frstyr : Year of earliest representable two-line elements lines : A pair of \"lines\" containing two-line elements Output epoch : The epoch of the elements in seconds past J2000 elems : The elements converted to SPICE units References NAIF Documentation source SPICE.getfat  —  Function getfat(file, arclen=10, typlen=10) Determine the file architecture and file type of most SPICE kernel files. Arguments file : The name of a file to be examined arclen : Maximum length of output architecture string (default: 10) typlen : Maximum length of output type string (default: 10) Output arch : The architecture of the kernel file typ : The type of the kernel file References NAIF Documentation source SPICE.getfov  —  Function getfov(instid, room=10, shapelen=128, framelen=128) Return the field-of-view (FOV) parameters for a specified instrument. The instrument is specified by its NAIF ID code. Arguments instid : NAIF ID of an instrument room : Maximum number of vectors that can be returned (default: 10) shapelen : Space available in the string  shape  (default: 128) framelen : Space available in the string  frame  (default: 128) Output Returns a tuple consisting of shape : Instrument FOV shape frame : Name of the frame in which FOV vectors are defined bsight : Boresight vector bounds : FOV boundary vectors References NAIF Documentation source SPICE.gfdist  —  Method gfdist(target, abcorr, obsrvr, relate, refval, adjust, step, nintvls, cnfine) Return the time window over which a specified constraint on observer-target distance is met. Arguments target : Name of the target body abcorr : Aberration correction flag obsrvr : Name of the observing body relate : Relational operator refval : Reference value adjust : Adjustment value for absolute extrema searches step : Step size used for locating extrema and roots nintvls : Workspace window interval count cnfine : Window to which the search is confined Output Returns a window containing the results. References NAIF Documentation source SPICE.gfevnt  —  Method gfevnt(udstep, udrefn, gquant, qnpars, lenvals, qpnams, qcpars, qdpars, qipars, qlpars,\n       op, refval, tol, adjust, rpt, udrepi, udrepu, udrepf, nintvls, bail, udbail, cnfine) Determine time intervals when a specified geometric quantity satisfies a specified mathematical condition. Arguments udstep : Name of the routine that computes and returns a time step udrefn : Name of the routine that computes a refined time gquant : Type of geometric quantity qpnams : Names of quantity definition parameters qcpars : Array of character quantity definition parameters qdpars : Array of double precision quantity definition parameters qipars : Array of integer quantity definition parameters qlpars : Array of logical quantity definition parameters op : Operator that either looks for an extreme value (max, min, local, absolute) or compares the   geometric quantity value and a number refval : Reference value tol : Convergence tolerance in second adjust : Absolute extremum adjustment value rpt : Progress reporter on ( true ) or off ( false ) udrepi : Function that initializes progress reporting udrepu : Function that updates the progress report udrepf : Function that finalizes progress reporting nintvls : Workspace window interval coun cnfine : SPICE window to which the search is restricted Output Returns a window containing the results. References NAIF Documentation source SPICE.gffove!  —  Method gffove!(inst, tshape, raydir, target, tframe, abcorr, obsrvr, tol,\n        udstep, udrefn, rpt, udrepi, udrepu, udrepf, cnfine, result) Determine time intervals when a specified target body or ray intersects the space bounded by the field-of-view (FOV) of a specified instrument. Arguments inst : Name of the instrument tshape : Type of shape model used for target body raydir : Ray's direction vector target : Name of the target body tframe : Body-fixed, body-centered frame for target body abcorr : Aberration correction flag obsrvr : Name of the observing body tol : Convergence tolerance in seconds udstep : Name of the routine returns a time step udrefn : Name of the routine that computes a refined time rpt : Progress report flag udrepi : Function that initializes progress reporting udrepu : Function that updates the progress report udrepf : Function that finalizes progress reporting cnfine : SPICE window to which the search is restricted result : Window containing the results Output Returns  result . References NAIF Documentation source SPICE.gfilum  —  Method gfilum(method, angtyp, target, illmn, fixref, abcorr, obsrvr, spoint, relate, refval,\n       adjust, step, nintvls, cnfine) Return the time window over which a specified constraint on the observed phase, solar incidence, or emission angle at a specifed target body surface point is met. Arguments method : Computation method angtyp : Type of illumination angle target : Name of the target body illmn : Name of the illumination source fixref : Body-fixed, body-centered target body frame abcorr : Aberration correction flag obsrvr : Name of the observing body spoint : Body-fixed coordinates of a target surface point relate : Relational operator refval : Reference value adjust : Adjustment value for absolute extrema searches step : Step size used for locating extrema and roots nintvls : Workspace window interval count cnfine : Window to which the search is confined Output Returns a window containing the results. References NAIF Documentation source SPICE.gfocce!  —  Method gfocce!(occtyp, front, fshape, fframe, back, bshape, bframe, abcorr, obsrvr, tol,\n        udstep, udrefn, rpt, udrepi, udrepu, udrepf, cnfine, result) Determine time intervals when an observer sees one target occulted by another. Arguments occtyp : Type of occultation front : Name of body occulting the other fshape : Type of shape model used for front body fframe : Body-fixed, body-centered frame for front body back : Name of body occulted by the other bshape : Type of shape model used for back body bframe : Body-fixed, body-centered frame for back body abcorr : Aberration correction flag obsrvr : Name of the observing body tol : Convergence tolerance in seconds udstep : Name of the routine that returns a time step udrefn : Name of the routine that computes a refined time rpt : Progress report flag udrepi : Function that initializes progress reporting udrepu : Function that updates the progress report udrepf : Function that finalizes progress reporting cnfine : SPICE window to which the search is restricted result : SPICE window containing results Output Returns  result . References NAIF Documentation source SPICE.gfoclt  —  Function gfoclt(occtyp, front, fshape, fframe, back, bshape, bframe, abcorr, obsrvr, step, cnfine,\n       maxwin=100) Determine time intervals when an observer sees one target occulted by, or in transit across, another. The surfaces of the target bodies may be represented by triaxial ellipsoids or by topographic data provided by DSK files. Arguments occtyp : Type of occultation front : Name of body occulting the other fshape : Type of shape model used for front body fframe : Body-fixed, body-centered frame for front body back : Name of body occulted by the other bshape : Type of shape model used for back body bframe : Body-fixed, body-centered frame for back body abcorr : Aberration correction flag obsrvr : Name of the observing body step : Step size in seconds for finding occultation events cnfine : Window to which the search is restricted maxwin : Maximum size of the output window (default: 100) Output Returns a window containing the results. References NAIF Documentation source SPICE.gfpa  —  Method gfpa(result, target, illmn, abcorr, obsrvr, relate, refval, adjust, step, nintvls, cnfine) Determine time intervals for which a specified constraint on the phase angle between an illumination source, a target, and observer body centers is met. Arguments target : Name of the target body illmn : Name of the illuminating body abcorr : Aberration correction flag obsrvr : Name of the observing body relate : Relational operator refval : Reference value adjust : Adjustment value for absolute extrema searches step : Step size used for locating extrema and roots nintvls : Workspace window interval count cnfine : Window to which the search is confined Output Returns a window containing the results. References NAIF Documentation source SPICE.gfposc  —  Method gfposc(target, frame, abcorr, obsrvr, crdsys, coord, relate, refval, adjust, step,\n       nintvls, cnfine) Determine time intervals for which a coordinate of an observer-target position vector satisfies a numerical constraint. Arguments target : Name of the target body frame : Name of the reference frame for coordinate calculations abcorr : Aberration correction flag obsrvr : Name of the observing body crdsys : Name of the coordinate system containing  coord coord : Name of the coordinate of interest relate : Operator that either looks for an extreme value (max, min, local, absolute) or compares   the coordinate value and refval refval : Reference value adjust : Adjustment value for absolute extrema searches step : Step size used for locating extrema and roots nintvls : Workspace window interval count cnfine : Window to which the search is restricted Output Returns a window containing the results. References NAIF Documentation source SPICE.gfrefn  —  Method gfrefn(t1, t2, s1, s2) For those times when we can't do better, we use a bisection method to find the next time at which to test for state change. Arguments t1 : One of two values bracketing a state change t2 : The other value that brackets a state change s1 : State at  t1 s2 : State at  t2 Output Returns the new value at which to check for transition. References NAIF Documentation source SPICE.gfrepf  —  Method gfrepf() Finish a GF progress report. References NAIF Documentation source SPICE.gfrepi  —  Method gfrepi(window, begmss, endmss) Initialize a search progress report. Arguments window : A window over which a job is to be performed begmss : Beginning of the text portion of the output message endmss : End of the text portion of the output message References NAIF Documentation source SPICE.gfrepu  —  Method gfrepu(ivbeg, ivend, time) Tell the progress reporting system how far a search has progressed. Arguments ivbeg : Start time of work interval ivend : End time of work interval time : Current time being examined in the search process References NAIF Documentation source SPICE.gfrfov  —  Function gfrfov(inst, raydir, rframe, abcorr, obsrvr, step, cnfine, maxwin=10000) Determine time intervals when a specified ray intersects the space bounded by the field-of-view (FOV) of a specified instrument. Arguments inst : Name of the instrument raydir : Ray's direction vector rframe : Reference frame of ray's direction vector abcorr : Aberration correction flag obsrvr : Name of the observing body step : Step size in seconds for finding FOV events cnfine : SPICE window to which the search is restricted maxwin : Maximum length of the output window (default: 10000) Output Returns a window containing the results. References NAIF Documentation source SPICE.gfrr  —  Method gfrr(target, abcorr, obsrvr, relate, refval, adjust, step, nintvls, cnfine) Determine time intervals for which a specified constraint on the observer-target range rate is met. Arguments target : Name of the target body abcorr : Aberration correction flag obsrvr : Name of the observing body relate : Relational operator refval : Reference value adjust : Adjustment value for absolute extrema searches step : Step size used for locating extrema and roots nintvls : Workspace window interval count cnfine : Window to which the search is confined Output Returns a window containing the results. References NAIF Documentation source SPICE.gfsep  —  Method Determine time intervals when the angular separation between the position vectors of two target bodies relative to an observer satisfies a numerical relationship. Arguments targ1 : Name of first body shape1 : Name of shape model describing the first body frame1 : The body-fixed reference frame of the first body targ2 : Name of second body shape2 : Name of the shape model describing the second body frame2 : The body-fixed reference frame of the second body abcorr : Aberration correction flag obsrvr : Name of the observing body relate : Operator that either looks for an extreme value (max, min, local, absolute) or compares   the angular separation value and refval refval : Reference value adjust : Absolute extremum adjustment value step : Step size in seconds for finding angular separation events nintvls : Workspace window interval count cnfine : Window to which the search is restricted Output Returns a window containing the results. References NAIF Documentation source SPICE.gfsntc  —  Method gfsntc(target, fixref, method, abcorr, obsrvr, dref, dvec, crdsys, coord, relate, refval,\n       adjust, step, nintvls, cnfine) Determine time intervals for which a coordinate of an surface intercept position vector satisfies a numerical constraint. Arguments target : Name of the target body fixref : Body fixed frame associated with  target method : Name of method type for surface intercept calculation abcorr : Aberration correction flag obsrvr : Name of the observing body dref : Reference frame of direction vector  dvec dvec : Pointing direction vector from  obsrvr crdsys : Name of the coordinate system containing COORD coord : Name of the coordinate of interest relate : Operator that either looks for an extreme value (max, min, local, absolute) or compares the coordinate value and  refval refval : Reference value adjust : Adjustment value for absolute extrema searches step : Step size used for locating extrema and roots nintvls : Workspace window interval count cnfine : Window to which the search is restricted Output Returns a window containing the results. References NAIF Documentation source SPICE.gfsstp  —  Method gfsstp(step) Set the step size to be returned by  gfstep . Arguments step : Time step to take References NAIF Documentation source SPICE.gfstep  —  Method gfstep() Return the time step set by the most recent call to  gfsstp . Arguments step : Time step to take References NAIF Documentation source SPICE.gfstol  —  Method gfstol(value) Override the default GF convergence value used in the high level GF routines. Arguments value : Double precision value returned or to store References NAIF Documentation source SPICE.gfsubc  —  Method gfsubc(target, fixref, method, abcorr, obsrvr, crdsys, coord, relate, refval, adjust, step,\n       nintvls, cnfine) Determine time intervals for which a coordinate of an subpoint position vector satisfies a numerical constraint. Arguments target : Name of the target body fixref : Body fixed frame associated with  target method : Name of method type for subpoint calculation abcorr : Aberration correction flag obsrvr : Name of the observing body crdsys : Name of the coordinate system containing  coord coord : Name of the coordinate of interest relate : Operator that either looks for an extreme value (max, min, local, absolute) or compares   the coordinate value and refval refval : Reference value adjust : Adjustment value for absolute extrema searches step : Step size used for locating extrema and roots nintvls : Workspace window interval count cnfine : Window to which the search is restricted Output Returns a window containing the results. References NAIF Documentation source SPICE.gftfov  —  Method gftfov(inst, target, tshape, tframe, abcorr, obsrvr, step, nintvls, cnfine) Determine time intervals when a specified ephemeris object intersects the space bounded by the field-of-view (FOV) of a specified instrument. Arguments inst : Name of the instrument target : Name of the target body tshape : Type of shape model used for target body tframe : Body-fixed, body-centered frame for target body abcorr : Aberration correction flag obsrvr : Name of the observing body step : Step size in seconds for finding FOV events nintvls : Workspace window interval count cnfine : Window to which the search is restricted Output Returns a window containing the results. References NAIF Documentation source SPICE.gfudb!  —  Method gfudb!(udfuns, udfunb, step, cnfine, result) Perform a GF search on a user defined boolean quantity. Arguments udfuns : Name of the routine that computes a scalar quantity of interest corresponding to an  et , e.g.  f(et) = ... udfunb : Name of the routine returning the boolean value corresponding to an  et , e.g.  g(f, et) = ... step : Step size used for locating extrema and roots cnfine : Window to which the search is restricted result : Window containing results Output Returns  result . References NAIF Documentation source SPICE.gfuds!  —  Method gfuds!(udfuns, udqdec, relate, refval, adjust, step, nintvls, cnfine, result) Perform a GF search on a user defined scalar quantity. Arguments udfuns : Name of the routine that computes the scalar quantity of interest at some time, e.g.  f(et) = ... udqdec : Name of the routine that computes whether the scalar quantity is decreasing, e.g.  g(f, et) = ... relate : Operator that either looks for an extreme value (max, min, local, absolute) or compares the geometric quantity value and a number refval : Value used as reference for scalar quantity condition adjust : Allowed variation for absolute extremal geometric conditions step : Step size used for locating extrema and roots nintvls : Workspace window interval count cnfine : SPICE window to which the search is restricted result : SPICE window containing results Output Returns  result . References NAIF Documentation source SPICE.gipool  —  Method gipool(name; start=1, room=100) Return the value of a kernel variable from the kernel pool. Arguments name : Name of the variable whose value is to be returned start : Which component to start retrieving for name (default: 1) room : The largest number of values to return (default: 100) Output Returns an array of values if the variable exists or  nothing  if not. References NAIF Documentation source SPICE.gnpool  —  Function gnpool(name, start, room, lenout=128) Return names of kernel variables matching a specified template. Arguments name : Template that names should match start : Index of first matching name to retrieve room : The largest number of values to return lenout : Length of strings in output array  kvars  (default: 128) Output Returns lernel pool variables whose names match  name . References NAIF Documentation source SPICE.halfpi  —  Function halfpi() Deprecated Use  π/2  instead. source SPICE.hrmint  —  Method hrmint(xvals, yvals, x) Evaluate a Hermite interpolating polynomial at a specified abscissa value. Arguments xvals : Abscissa values yvals : Ordinate and derivative values x : Point at which to interpolate the polynomial Output f : Interpolated function value at  x df : Interpolated function's derivative at  x References NAIF Documentation source SPICE.hx2dp  —  Method hx2dp(str) Convert a string representing a double precision number in a base 16 \"scientific notation\" into its equivalent double precision number. Arguments str : Hex form string to convert to double precision Output dp : Double precision value to be returned References NAIF Documentation source SPICE.illumf  —  Method illumf(method, target, ilusrc, et, fixref, abcorr, obsrvr, spoint) Compute the illumination angles - phase, incidence, and emission - at a specified point on a target body. Return logical flags indicating whether the surface point is visible from the observer's position and whether the surface point is illuminated. The target body's surface is represented using topographic data provided by DSK files, or by a reference ellipsoid. The illumination source is a specified ephemeris object. Arguments method : Computation method target : Name of target body ilusrc : Name of illumination source et : Epoch in TDB seconds past J2000 TDB fixref : Body-fixed, body-centered target body frame abcorr : Aberration correction flag obsrvr : Name of observing body spoint : Body-fixed coordinates of a target surface point Output trgepc : Target surface point epoch srfvec : Vector from observer to target surface point phase : Phase angle at the surface point incdnc : Source incidence angle at the surface point emissn : Emission angle at the surface point visibl : Visibility flag ( true  if visible) lit : Illumination flag ( true  if illuminated) References NAIF Documentation source SPICE.illumg  —  Method illumg(method, target, ilusrc, et, fixref, obsrvr, spoint, abcorr) Find the illumination angles (phase, incidence, and emission) at a specified surface point of a target body. The surface of the target body may be represented by a triaxial ellipsoid or by topographic data provided by DSK files. The illumination source is a specified ephemeris object. Arguments method : Computation method. target : Name of target body. ilusrc : Name of illumination source. et : Epoch in ephemeris seconds past J2000 TDB. fixref : Body-fixed, body-centered target body frame. obsrvr : Name of observing body. spoint : Body-fixed coordinates of a target surface point. abcorr : Aberration correction. Output trgepc : Sub-solar point epoch. srfvec : Vector from observer to sub-solar point. phase : Phase angle at the surface point. incdnc : Solar incidence angle at the surface point. emissn : Emission angle at the surface point. References NAIF Documentation source SPICE.ilumin  —  Method ilumin(method, target, et, fixref, obsrvr, spoint, abcorr) Find the illumination angles (phase, solar incidence, and emission) at a specified surface point of a target body. Arguments method : Computation method target : Name of target body et : Epoch in ephemeris seconds past J2000 TDB fixref : Body-fixed, body-centered target body frame obsrvr : Name of observing body spoint : Body-fixed coordinates of a target surface point abcorr : Aberration correction Output trgepc : Sub-solar point epoch srfvec : Vector from observer to sub-solar point phase : Phase angle at the surface point incdnc : Solar incidence angle at the surface point emissn : Emission angle at the surface point References NAIF Documentation source SPICE.inedpl  —  Method inedpl(a, b, c, plane) Find the intersection of a triaxial ellipsoid and a plane. Arguments a : Length of ellipsoid semi-axis lying on the x-axis b : Length of ellipsoid semi-axis lying on the y-axis c : Length of ellipsoid semi-axis lying on the z-axis plane : Plane that intersects ellipsoid Output ellipse : Intersection ellipse Returns  nothing  if no ellipse could be found. References NAIF Documentation source SPICE.inelpl  —  Method inelpl(ellips, plane) Find the intersection of an ellipse and a plane. Arguments ellips : An ellipse plane : A plane Output nxpts : Number of intersection points of ellipse and plane xpt1 ,  xpt2 : Intersection points References NAIF Documentation source SPICE.inrypl  —  Method inrypl(vertex, dir, plane) Find the intersection of a ray and a plane. Arguments vertex ,  dir : Vertex and direction vector of ray plane : A plane Output nxpts : Number of intersection points of ray and plane xpt1 ,  xpt2 : Intersection points References NAIF Documentation source SPICE.insrtc!  —  Method insrtc!(set, item) Insert an item into a character set. Arguments set : Insertion set item : Item to be inserted Output Returns the updated set. References NAIF Documentation source SPICE.insrtd!  —  Method insrtd!(set, item) Insert an item into a double set. Arguments set : Insertion set item : Item to be inserted Output Returns the updated set. References NAIF Documentation source SPICE.insrti!  —  Method insrti!(set, item) Insert an item into an integer set. Arguments set : Insertion set item : Item to be inserted Output Returns the updated set. References NAIF Documentation source SPICE.inter  —  Method inter(a, b) Intersect two sets of any data type to form a third set. Arguments a : First input set b : Second input set Output Returns intersection of a and b. References NAIF Documentation source SPICE.intmax  —  Function intmax() Deprecated Use  typemax(Cint)  instead. source SPICE.intmin  —  Function intmin() Deprecated Use  typemin(Cint)  instead. source SPICE.invert  —  Function invert(matrix) Deprecated Use  inv(matrix)  instead. source SPICE.invort  —  Function invort(matrix) Deprecated Use  inv(matrix)  instead. source SPICE.isordv  —  Function isordv(vec) Deprecated Use  isperm(vec)  instead. source SPICE.isrchc  —  Function isrchc(value, array)\nisrchd(value, array)\nisrchi(value, array) Deprecated Use  findfirst(==(value), array)  instead. source SPICE.isrchd  —  Function isrchc(value, array)\nisrchd(value, array)\nisrchi(value, array) Deprecated Use  findfirst(==(value), array)  instead. source SPICE.isrchi  —  Function isrchc(value, array)\nisrchd(value, array)\nisrchi(value, array) Deprecated Use  findfirst(==(value), array)  instead. source SPICE.isrot  —  Method isrot(m, ntol, dtol) Indicate whether a 3×3 matrix is a rotation matrix. Arguments m : A matrix to be tested ntol : Tolerance for the norms of the columns of  m dtol : Tolerance for the determinant of a matrix whose columns are the unitized columns of  m Output Returns  true  if  m  is a rotation matrix. References NAIF Documentation source SPICE.iswhsp  —  Function iswhsp(str) Deprecated Use  all(isspace, str)  instead. source SPICE.j1900  —  Method j1900() Returns the Julian Date of 1899 DEC 31 12:00:00 (1900 JAN 0.5). https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/j1900_c.html source SPICE.j1950  —  Method j1950() Returns the Julian Date of 1950 JAN 01 00:00:00 (1950 JAN 1.0). https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/j1950_c.html source SPICE.j2000  —  Method j2000() Returns the Julian Date of 2000 JAN 01 12:00:00 (2000 JAN 1.5). https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/j2000_c.html source SPICE.j2100  —  Method j2100() Returns the Julian Date of 2100 JAN 01 12:00:00 (2100 JAN 1.5). https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/j2100_c.html source SPICE.jyear  —  Method jyear() Returns the number of seconds per Julian year. https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/jyear_c.html source SPICE.kclear  —  Method kclear() Clear the KEEPER subsystem: unload all kernels, clear the kernel pool, and re-initialize the subsystem. Existing watches on kernel variables are retained. References NAIF Documentation source SPICE.kdata  —  Function kdata(which, kind, fillen=1024, srclen=256) Return data for the n-th kernel that is among a list of specified kernel types. Arguments which : Index of kernel to fetch from the list of kernels kind : The kind of kernel to which fetches are limited fillen : Available space in output file string srclen : Available space in output source string Output Returns  nothing  if no kernel was found or a tuple consisting of file : The name of the kernel file filtyp : The type of the kernel source : Name of the source file used to load file handle : The handle attached to file References NAIF Documentation source SPICE.kinfo  —  Function kinfo(file, srclen=256) Arguments file : Name of a kernel to fetch information for srclen : Available space in output source string Output Returns  nothing  if no kernel was found or a tuple consisting of filtyp : The type of the kernel source : Name of the source file used to load file handle : The handle attached to file References NAIF Documentation source SPICE.kplfrm  —  Function kplfrm(frmcls) Return a SPICE set containing the frame IDs of all reference frames of a given class having specifications in the kernel pool. Arguments frmcls : Frame class size : Size of the output set Output Returns the set of ID codes of frames of the specified class. References NAIF Documentation source SPICE.ktotal  —  Method ktotal(kind) Return the current number of kernels that have been loaded via the KEEPER interface that are of a specified type. References NAIF Documentation source SPICE.kxtrct  —  Function kxtrct(keywd, terms, string) Locate a keyword in a string and extract the substring from the beginning of the first word following the keyword to the beginning of the first subsequent recognized terminator of a list. Arguments keywd : Word that marks the beginning of text of interest terms : Set of words, any of which marks the end of text string : String containing a sequence of words Output Returns  nothing  if  keywd  was found or a tuple consisting of string : The input  string  with the text of interest removed substr : String from end of  keywd  to beginning of first  terms  item found References NAIF Documentation source SPICE.lastnb  —  Function lastnb(str) Deprecated Use  findlast(!isspace, str)  instead. source SPICE.latcyl  —  Method latcyl(radius, lon, lat) Convert from latitudinal coordinates to cylindrical coordinates. Arguments radius : Distance of a point from the origin lon : Angle of the point from the XZ plane in radians lat : Angle of the point from the XY plane in radians Output Return the tuple  (r, lonc, z) . r : Distance of the point from the z axis lonc : Angle of the point from the XZ plane in radians. 'lonc' is set equal to 'lon' z : Height of the point above the XY plane References NAIF Documentation source SPICE.latrec  —  Method latrec(radius, lon, lat) Convert from latitudinal coordinates to rectangular coordinates. Arguments radius : Distance of a point from the origin lon : Angle of the point from the XZ plane in radians lat : Angle of the point from the XY plane in radians Output Return the rectangular coordinates vector of the point. References NAIF Documentation source SPICE.latsph  —  Method latsph(radius, lon, lat) Convert from latitudinal coordinates to spherical coordinates. Arguments radius : Distance of a point from the origin lon : Angle of the point from the XZ plane in radians lat : Angle of the point from the XY plane in radians Output Return the tuple  (rho, colat, lons) . rho : Distance of the point from the origin colat : Angle of the point from positive z axis (radians) lons : Angle of the point from the XZ plane (radians) References NAIF Documentation source SPICE.latsrf  —  Method latsrf(method, target, et, fixref, npts, lonlat) Map array of planetocentric longitude/latitude coordinate pairs to surface points on a specified target body. The surface of the target body may be represented by a triaxial ellipsoid or by topographic data provided by DSK files. Arguments method : Computation method target : Name of target body et : Epoch in TDB seconds past J2000 TDB fixref : Body-fixed, body-centered target body frame lonlat : Array of longitude/latitude coordinate pairs Output Returns an array of surface points. References NAIF Documentation source SPICE.lcase  —  Function lcase(in) Deprecated Use  lowercase(in)  instead. source SPICE.ldpool  —  Method ldpool(kernel) Load the variables contained in a NAIF ASCII kernel file into the kernel pool. Arguments kernel : Name of the kernel file Output None References NAIF Documentation source SPICE.lgrind  —  Method lgrind(xvals, yvals, x) Evaluate a Lagrange interpolating polynomial for a specified set of coordinate pairs, at a specified abscissa value. Return the value of both polynomial and derivative. Arguments xvals : Abscissa values of coordinate pairs yvals : Ordinate values of coordinate pairs x : Point at which to interpolate the polynomial Output p : The value at x of the unique polynomial of      degree n-1 that fits the points in the plane      defined by xvals and yvals dp : The derivative at x of the interpolating       polynomial described above References NAIF Documentation source SPICE.limbpt  —  Method limbpt(method, target, et, fixref, abcorr, corloc, obsrvr, refvec, rolstp, ncuts, schstp,\n       soltol, maxn) Find limb points on a target body. The limb is the set of points of tangency on the target of rays emanating from the observer.  The caller specifies half-planes bounded by the observer-target center vector in which to search for limb points. The surface of the target body may be represented either by a triaxial ellipsoid or by topographic data. Arguments method : Computation method target : Name of target body et : Epoch in ephemeris seconds past J2000 TDB fixref : Body-fixed, body-centered target body frame abcorr : Aberration correction corloc : Aberration correction locus obsrvr : Name of observing body refvec : Reference vector for cutting half-planes rolstp : Roll angular step for cutting half-planes ncuts : Number of cutting half-planes schstp : Angular step size for searching soltol : Solution convergence tolerance maxn : Maximum number of entries in output arrays Output Returns the tuple  (npts, points, epochs, tangts) . npts : Counts of limb points corresponding to cuts points : Limb points epochs : Times associated with limb points tangts : Tangent vectors emanating from the observer References NAIF Documentation source SPICE.lmpool  —  Method lmpool(cvals) Load the variables contained in an internal buffer into the kernel pool. Arguments cvals : An array that contains a SPICE text kernel References NAIF Documentation source SPICE.lparse  —  Function lparse(list, delim, nmax) Deprecated Use  split(list, delim, limit=nmax)  instead. source SPICE.lparsm  —  Function lparsm(list, delims, nmax) Deprecated Use  split(list, delim, limit=nmax, keepempty=false)  instead. source SPICE.lparss  —  Function lparss(list, delims) Deprecated Use  Set(split(list, collect(delim)))  instead. source SPICE.lspcn  —  Method lspcn(body, et, abcorr) Compute L_s, the planetocentric longitude of the sun, as seen from a specified body. Arguments body : Name of the central body et : Epoch in seconds past J2000 TDB abcorr : Aberration correction Output Returns the planetocentric longitude of the sun for the specified body at the specified time in radians. References NAIF Documentation source SPICE.lstlec  —  Function lstlec(x, array) Deprecated Use  findfirst(>(item), array)  instead. source SPICE.lstled  —  Function lstled(x, array)\nlstlei(x, array) Deprecated Use  searchsortedlast(array, x)  instead. source SPICE.lstlei  —  Function lstled(x, array)\nlstlei(x, array) Deprecated Use  searchsortedlast(array, x)  instead. source SPICE.lstltc  —  Function lstltcd(x, array) Deprecated Use  findfirst(>=(item), array)  instead. source SPICE.lstltd  —  Function lstltd(x, array)\nlstlti(x, array) Deprecated Use  searchsortedlast(array, x, lt=<=)  instead. source SPICE.lstlti  —  Function lstltd(x, array)\nlstlti(x, array) Deprecated Use  searchsortedlast(array, x, lt=<=)  instead. source SPICE.ltime  —  Method ltime(etobs, obs, dir, targ) This routine computes the transmit (or receive) time of a signal at a specified target, given the receive (or transmit) time at a specified observer. The elapsed time between transmit and receive is also returned. Arguments etobs : Epoch of a signal at some observer obs : NAIF ID of some observer dir : Direction the signal travels (  \"->\"  or  \"<-\"  ) targ : Time between transmit and receipt of the signal Output ettarg : Epoch of the signal at the target obs : NAIF ID of some observer References NAIF Documentation source SPICE.lx4dec  —  Method lx4dec(string, first) Scan a string from a specified starting position for the end of a decimal number. Arguments string : Any character string first : First character to scan from in string Output last : Last character that is part of a decimal number. If there is no such         character,  last  will be returned with the value  first-1 . nchar : Number of characters in the decimal number References NAIF Documentation source SPICE.lx4num  —  Method lx4num(string, first) Scan a string from a specified starting position for the end of a number. Arguments string : Any character string first : First character to scan from in string Output last : Last character that is part of a number. If there is no such         character,  last  will be returned with the value  first-1 . nchar : Number of characters in the number References NAIF Documentation source SPICE.lx4sgn  —  Method lx4sgn(string, first) Scan a string from a specified starting position for the end of a signed integer. Arguments string : Any character string first : First character to scan from in string Output last : Last character that is part of a signed integer. If there is no such         character,  last  will be returned with the value  first-1 . nchar : Number of characters in the signed integer References NAIF Documentation source SPICE.lx4uns  —  Method lx4uns(string, first) Scan a string from a specified starting position for the end of a unsigned integer. Arguments string : Any character string first : First character to scan from in string Output last : Last character that is part of an unsigned integer. If there is no such         character,  last  will be returned with the value  first-1 . nchar : Number of characters in the unsigned integer References NAIF Documentation source SPICE.lxqstr  —  Method lxqstr(string, qchar, first) Lex (scan) a quoted string. Arguments string : String to be scanned qchar : Quote delimiter character first : Character position at which to start scanning Output last : Character position of end of token nchar : Number of characters in token References NAIF Documentation source SPICE.m2eul  —  Method m2eul(r, axis3, axis2, axis1) Factor a rotation matrix as a product of three rotations about specified coordinate axes. Arguments r : A rotation matrix to be factored axis3 : Number of the third rotation axis axis2 : Number of the second rotation axis axis1 : Number of the first rotation axis Output A tuple consisting of the third, second, and first Euler angles in radians. References NAIF Documentation source SPICE.m2q  —  Method m2q(r) Find a unit quaternion corresponding to a specified rotation matrix. Arguments r : A rotation matrix Output A unit quaternion representing  r References NAIF Documentation source SPICE.matchi  —  Method matchi(string, templ, wstr, wchar) Determine whether a string is matched by a template containing wild cards. The pattern comparison is case-insensitive. Arguments string : String to be tested templ : Template (with wild cards) to test against string wstr : Wild string token wchr : Wild character token Output Returns  true  if the string matches. References NAIF Documentation source SPICE.matchw  —  Method matchw(string, templ, wstr, wchar) Determine whether a string is matched by a template containing wild cards. Arguments string : String to be tested templ : Template (with wild cards) to test against string wstr : Wild string token wchr : Wild character token Output Returns  true  if the string matches. References NAIF Documentation source SPICE.maxd  —  Function maxd(args...)\nmaxi(args...) Deprecated Use  maximum(args)  instead. source SPICE.maxi  —  Function maxd(args...)\nmaxi(args...) Deprecated Use  maximum(args)  instead. source SPICE.mequ  —  Function mequ(m1, mout)\nmequg(m1, mout) Deprecated Use  mout .= m1  instead. source SPICE.mequg  —  Function mequ(m1, mout)\nmequg(m1, mout) Deprecated Use  mout .= m1  instead. source SPICE.mind  —  Function mind(args...)\nmini(args...) Deprecated Use  minimum(args)  instead. source SPICE.mini  —  Function mind(args...)\nmini(args...) Deprecated Use  minimum(args)  instead. source SPICE.mtxm  —  Function mtxm(m1, m2)\nmtxmg(m1, m2) Deprecated Use  m1' * m2  instead. source SPICE.mtxmg  —  Function mtxm(m1, m2)\nmtxmg(m1, m2) Deprecated Use  m1' * m2  instead. source SPICE.mtxv  —  Function mtxv(m1,v2)\nmtxvg(m1,v2) Deprecated Use  m1' * v2  instead. source SPICE.mtxvg  —  Function mtxv(m1,v2)\nmtxvg(m1,v2) Deprecated Use  m1' * v2  instead. source SPICE.mxm  —  Function mxm(m1, m2)\nmxmg(m1, m2) Deprecated Use  m1 * m2  instead. source SPICE.mxmg  —  Function mxm(m1, m2)\nmxmg(m1, m2) Deprecated Use  m1 * m2  instead. source SPICE.mxmt  —  Function mxmt(m1, m2)\nmxmtg(m1, m2) Deprecated Use  m1 * m2'  instead. source SPICE.mxmtg  —  Function mxmt(m1, m2)\nmxmtg(m1, m2) Deprecated Use  m1 * m2'  instead. source SPICE.mxv  —  Function mxv(m1,v2)\nmxvg(m1,v2) Deprecated Use  m1 * v2  instead. source SPICE.mxvg  —  Function mxv(m1,v2)\nmxvg(m1,v2) Deprecated Use  m1 * v2  instead. source SPICE.namfrm  —  Method namfrm(frname) Look up the frame ID code associated with a string. Arguments frname : The name of some reference frame Output The SPICE ID code of the frame. References NAIF Documentation source SPICE.ncpos  —  Method ncpos(str, chars, start) Find the first occurrence in a string of a character NOT belonging to a collection of characters, starting at a specified location, searching forward. Arguments str : A string chars : A collection of characters start : Position to begin looking for a character not in  chars Output Returns the index of the first character of  str  at or following index  start  that is not in the collection  chars . References NAIF Documentation source SPICE.ncposr  —  Method ncposr(str, chars, start) Find the first occurrence in a string of a character NOT belonging to a collection of characters, starting at a specified location, searching in reverse. Arguments str : A string chars : A collection of characters start : Position to begin looking for a character not in  chars Output Returns the index of the last character of  str  at or before index  start  that is not in the collection  chars . References NAIF Documentation source SPICE.nearpt  —  Method nearpt(positn, a, b, c) This routine locates the point on the surface of an ellipsoid that is nearest to a specified position. It also returns the altitude of the position above the ellipsoid. Arguments positn : Position of a point in the bodyfixed frame a : Length of semi-axis parallel to x-axis b : Length of semi-axis parallel to y-axis c : Length on semi-axis parallel to z-axis Output Returns a tuple consisting of  npoint  and  alt . npoint : Point on the ellipsoid closest to  positn alt : Altitude of  positn  above the ellipsoid References NAIF Documentation source SPICE.npedln  —  Method npedln(a, b, c, linept, linedr) Find nearest point on a triaxial ellipsoid to a specified line, and the distance from the ellipsoid to the line. Arguments a : Length of semi-axis in the x direction b : Length of semi-axis in the y direction c : Length of semi-axis in the z direction linept : Point on line linedr : Direction vector of line Output Returns a tuple consisting of  pnear  and  dist . pnear : Nearest point on ellipsoid to line dist : Distance of ellipsoid from line References NAIF Documentation source SPICE.npelpt  —  Method npelpt(point, ellips) Find the nearest point on an ellipse to a specified point, both in three-dimensional space, and find the distance between the ellipse and the point. Arguments point : Point whose distance to an ellipse is to be found ellips : A SPICE ellipse Output Returns a tuple consisting of  pnear  and  dist . pnear : Nearest point on ellipse to input point dist : Distance of input point to ellipse References NAIF Documentation source SPICE.nplnpt  —  Method nplnpt(linept, linedr, point) Find the nearest point on a line to a specified point, and find the distance between the two points. Arguments linept : Point on line linedr : Direction vector of line point : A second point Output Returns a tuple consisting of  pnear  and  dist . pnear : Nearest point on the line to  point dist : Distance between  point  and  pnear References NAIF Documentation source SPICE.nvc2pl  —  Method nvc2pl(norm, point) Make a SPICE plane from a normal vector and a point. Arguments norm : A normal vector... constant : ...and a constant defining a plane Output Returns a struct representing the plane. References NAIF Documentation source SPICE.nvp2pl  —  Method nvp2pl(norm, point) Make a SPICE plane from a normal vector and a point. Arguments norm : A normal vector... point : ...and a point defining a plane Output Returns a struct representing the plane. References NAIF Documentation source SPICE.occult  —  Method occult(targ1, shape1, frame1, targ2, shape2, frame2, abcorr, obsrvr, et) Determines the occultation condition (not occulted, partially, etc.) of one target relative to another target as seen by an observer at a given time. The surfaces of the target bodies may be represented by triaxial ellipsoids or by topographic data provided by DSK files. Arguments targ1 : Name or ID of first target. shape1 : Type of shape model used for first target. frame1 : Body-fixed, body-centered frame for first body. targ2 : Name or ID of second target. shape2 : Type of shape model used for second target. frame2 : Body-fixed, body-centered frame for second body. abcorr : Aberration correction flag. obsrvr : Name or ID of the observer. et : Time of the observation (seconds past J2000). Output Returns the occultation identification code. References NAIF Documentation source SPICE.ordc  —  Method ordc(set, item) The function returns the ordinal position of any given item in a character set. Arguments set : A set to search for a given item item : An item to locate within a set Output Returns the ordinal position or  nothing  if the items does not appear in the set. References NAIF Documentation source SPICE.ordd  —  Method ordd(set, item) The function returns the ordinal position of any given item in a character set. Arguments set : A set to search for a given item item : An item to locate within a set Output Returns the ordinal position or  nothing  if the items does not appear in the set. References NAIF Documentation source SPICE.orderc  —  Function orderc(array)\norderd(array)\norderi(array) Deprecated Use  Base.sortperm()  instead. source SPICE.orderd  —  Function orderc(array)\norderd(array)\norderi(array) Deprecated Use  Base.sortperm()  instead. source SPICE.orderi  —  Function orderc(array)\norderd(array)\norderi(array) Deprecated Use  Base.sortperm()  instead. source SPICE.ordi  —  Method ordi(set, item) The function returns the ordinal position of any given item in a character set. Arguments set : A set to search for a given item item : An item to locate within a set Output Returns the ordinal position or  nothing  if the items does not appear in the set. References NAIF Documentation source SPICE.oscelt  —  Method oscelt(state, et, mu) Determine the set of osculating conic orbital elements that corresponds to the state (position, velocity) of a body at some epoch. Arguments state : State of body at epoch of elements et : Epoch of elements mu : Gravitational parameter (GM) of primary body Output Returns the equivalent conic elements: rp : Perifocal distance ecc : Eccentricity inc : Inclination lnode : Longitude of the ascending node argp : Argument of periapsis m0 : Mean anomaly at epoch t0 : Epoch mu : Gravitational parameter References NAIF Documentation source SPICE.oscltx  —  Method oscltx(state, et, mu) Determine the set of osculating conic orbital elements that corresponds to the state (position, velocity) of a body at some epoch. In addition to the classical elements, return the true anomaly, semi-major axis, and period, if applicable. Arguments state : State of body at epoch of elements et : Epoch of elements mu : Gravitational parameter (GM) of primary body Output Returns the extended set of classical conic elements: rp : Perifocal distance. ecc : Eccentricity. inc : Inclination. lnode : Longitude of the ascending node. argp : Argument of periapsis. m0 : Mean anomaly at epoch. t0 : Epoch. mu : Gravitational parameter. nu : True anomaly at epoch. a : Semi-major axis. A is set to zero if it is not computable. tau : Orbital period. Applicable only for elliptical orbits. Set to zero otherwise. References NAIF Documentation source SPICE.pckcls  —  Method pckcls(handle) Close an open PCK file. Arguments handle : Handle of the PCK file to be closed References NAIF Documentation source SPICE.pckcov!  —  Method pckcov!(cover, pck, idcode) Find the coverage window for a specified reference frame in a specified binary PCK file. Arguments cover : An initalized window  SpiceDoubleCell pck : Path of PCK file idcode : Class ID code of PCK reference frame Output Returns  cover  containing coverage in  pck  for  idcode References NAIF Documentation source SPICE.pckfrm!  —  Method pckfrm!(ids, pck) Find the set of reference frame class ID codes of all frames in a specified binary PCK file. Arguments ids : An initalized  SpiceIntCell pck : Path of PCK file Output Returns  ids  containing a set of frame class ID codes of frames in PCK file. References NAIF Documentation source SPICE.pcklof  —  Method pcklof(filename) Load a binary PCK file for use by the readers. Return the handle of the loaded file which is used by other PCK routines to refer to the file. Arguments filename : Path of the PCK file Output Returns an integer handle. References NAIF Documentation source SPICE.pckopn  —  Method pckopn(name, ifname, ncomch) Create a new PCK file, returning the handle of the opened file. Arguments name : The name of the PCK file to be opened ifname : The internal filename for the PCK ncomch : The number of characters to reserve for comments Output Returns the handle of the opened PCK file. References NAIF Documentation source SPICE.pckuof  —  Method pckuof(handle) Unload a binary PCK file so that it will no longer be searched by the readers. Arguments handle : Integer handle of a PCK file References NAIF Documentation source SPICE.pckw02  —  Method pckw02(handle, clssid, frame, first, last, segid, intlen, cdata, btime) Write a type 2 segment to a PCK binary file given the file handle, frame class ID, base frame, time range covered by the segment, and the Chebyshev polynomial coefficients. Arguments handle : Handle of binary PCK file open for writing. clssid : Frame class ID of body-fixed frame. frame : Name of base reference frame. first : Start time of interval covered by segment. last : End time of interval covered by segment. segid : Segment identifier. intlen : Length of time covered by logical record. cdata : Array of Chebyshev coefficients. btime : Begin time of first logical record. References NAIF Documentation source SPICE.pcpool  —  Method pcpool(name, vals) Insert character data into the kernel pool. Arguments name : The kernel pool name to associate with  vals vals : An array of values to insert into the kernel pool References NAIF Documentation source SPICE.pdpool  —  Method pdpool(name, vals) Insert double precision data into the kernel pool. Arguments name : The kernel pool name to associate with  vals vals : An array of values to insert into the kernel pool References NAIF Documentation source SPICE.pgrrec  —  Method pgrrec(body, lon, lat, alt, re, f) Convert planetographic coordinates to rectangular coordinates. Arguments body : Body with which coordinate system is associated. lon : Planetographic longitude of a point (radians). lat : Planetographic latitude of a point (radians). alt : Altitude of a point above reference spheroid. re : Equatorial radius of the reference spheroid. f : Flattening coefficient. Output Returns the rectangular coordinates of the point. References NAIF Documentation source SPICE.phaseq  —  Method phaseq(et, target, illmn, obsrvr, abcorr) Compute the apparent phase angle for a target, observer, illuminator set of ephemeris objects. Arguments et : Ephemeris seconds past J2000 TDB target : Target body name illmn : Illuminating body name obsrvr : Observer body abcorr : Aberration correction flag Output Returns the value of the phase angle. References NAIF Documentation source SPICE.pipool  —  Method pipool(name, ivals) Insert integer data into the kernel pool. Arguments name : The kernel pool name to associate with the values ivals : An array of integers to insert into the pool References NAIF Documentation source SPICE.pjelpl  —  Method pjelpl(elin, plane) Project an ellipse onto a plane, orthogonally. Arguments elin : An ellipse to be projected plane : A plane onto which  elin  is to be projected Output Returns the ellipse resulting from the projection. References NAIF Documentation source SPICE.pl2nvc  —  Method pl2nvc(plane) Return a unit normal vector and constant that define a specified plane. Arguments plane : A plane Output Returns a tuple consisting of normal : A normal vector and... constant : ... constant defining the geometric plane represented by  plane References NAIF Documentation source SPICE.pl2nvp  —  Method pl2nvp(plane) Return a unit normal vector and point that define a specified plane. Arguments plane : A plane Output Returns a tuple consisting of normal : A normal vector and... point : ... point defining the geometric plane represented by  plane References NAIF Documentation source SPICE.pl2psv  —  Method pl2psv(plane) Return a point and two orthogonal spanning vectors that define a specified plane. Arguments plane : A plane Output Returns a tuple consisting of a point in the  plane  and two vectors spanning the input plane. References NAIF Documentation source SPICE.pltar  —  Method pltar(vrtces, plates) Compute the total area of a collection of triangular plates. Arguments vrtces : Array of vertices plates : Array of plates Output Returns the area. References NAIF Documentation source SPICE.pltexp  —  Method pltexp(iverts, delta) Expand a triangular plate by a specified amount. The expanded plate is co-planar with, and has the same orientation as, the original. The centroids of the two plates coincide. Arguments iverts : Vertices of the plate to be expanded delta : Fraction by which the plate is to be expanded Output Returns the vertices of the expanded plate. References NAIF Documentation source SPICE.pltnp  —  Method pltnp(point, v1, v2, v3) Find the nearest point on a triangular plate to a given point. Arguments point : A point in 3-dimensional space. v1 ,  v2 ,  v3 : Vertices of a triangular plate Output Returns a tuple consisting of pnear : Nearest point on the plate to  point dist : Distance between  pnear  and  point References NAIF Documentation source SPICE.pltnrm  —  Method pltnrm(v1, v2, v3) Compute an outward normal vector of a triangular plate.  The vector does not necessarily have unit length. Arguments v1 ,  v2 ,  v3 : Vertices of a plate Output Returns the plate's outward normal vector. References NAIF Documentation source SPICE.pltvol  —  Method pltvol(vrtces, plates) Compute the volume of a three-dimensional region bounded by a collection of triangular plates. Arguments vrtces : Array of vertices plates : Array of plates Output Returns the volume of the spatial region bounded by the plates. References NAIF Documentation source SPICE.polyds  —  Method polyds(coeffs, nderiv, t) Compute the value of a polynomial and it's first  nderiv  derivatives at the value  t . Arguments coeffs : Coefficients of the polynomial to be evaluated nderiv : Number of derivatives to compute t : Point to evaluate the polynomial and derivatives Output Returns the value of the polynomial and the derivatives as an array. References NAIF Documentation source SPICE.pos  —  Function pos(str, substr, start) Deprecated Use  first(findnext(substr, str, start))  instead. source SPICE.posr  —  Function posr(str, substr, start) Deprecated Use  first(findprev(substr, str, start))  instead. source SPICE.prop2b  —  Method prop2b(gm, pvinit, dt) Given a central mass and the state of massless body at time  t_0 , this routine determines the state as predicted by a two-body force model at time  t_0 + dt . Arguments gm : Gravity of the central mass. pvinit : Initial state from which to propagate a state. dt : Time offset from initial state to propagate to. Output Returns the propagated state. References NAIF Documentation source SPICE.prsdp  —  Function prsdp(str) Deprecated Use  parse(Float64, str)  instead. source SPICE.prsint  —  Function prsint(str) Deprecated Use  parse(Int, str)  instead. source SPICE.psv2pl  —  Method psv2pl(point, span1, span2) Make a plane from a point and two spanning vectors. Arguments point ,  span1 ,  span2 : A point and two spanning vectors defining a plane Output Returns the plane. References NAIF Documentation source SPICE.pxform  —  Method pxform(from, to, et) Return the matrix that transforms position vectors from one specified frame to another at a specified epoch. Arguments from : Name of the frame to transform from to : Name of the frame to transform to et : Epoch of the rotation matrix Output Returns the rotation matrix. References NAIF Documentation source SPICE.pxfrm2  —  Method pxfrm2(from, to, etfrom, etto) Return the 3×3 matrix that transforms position vectors from one specified frame at a specified epoch to another specified frame at another specified epoch. Arguments from : Name of the frame to transform from to : Name of the frame to transform to etfrom : Evaluation time of  from  frame etto : Evaluation time of  to  frame Output Returns a position transformation matrix from frame  from  to frame  to . References NAIF Documentation source SPICE.q2m  —  Method q2m(q) Find the rotation matrix corresponding to a specified unit quaternion. Arguments q : A unit quaternion Output A rotation matrix corresponding to  q . References NAIF Documentation source SPICE.qdq2av  —  Method qdq2av(q, dq) Derive angular velocity from a unit quaternion and its derivative with respect to time. Arguments q : Unit SPICE quaternion (as any kind of iterable with four elements) dq : Derivative of  q  with respect to time Output Angular velocity vector defined by  q  and  dq References NAIF Documentation source SPICE.qxq  —  Method qxq(q1, q2) Multiply two quaternions. Arguments q1 : First SPICE quaternion factor (as any kind of iterable with four elements) q2 : Second SPICE quaternion factor (as any kind of iterable with four elements) Output A quaternion corresponding to the product of  q1  and  q2 References NAIF Documentation source SPICE.radrec  —  Method radrec(range, ra, dec) Convert from range, right ascension, and declination to rectangular coordinates. Arguments range : Distance of a point from the origin ra : Right ascension of point in radians dec : Declination of point in radians Output Returns the rectangular coordinates of the point. References NAIF Documentation source SPICE.rav2xf  —  Method rav2xf(rot, av) Determine a state transformation matrix from a rotation matrix and the angular velocity of the rotation. Arguments rot : Rotation matrix av : Angular velocity vector Output Returns state transformation matrix associated with  rot  and  av . References NAIF Documentation source SPICE.raxisa  —  Method raxisa(matrix) Compute the axis of the rotation given by an input matrix and the angle of the rotation about that axis. Arguments matrix : A 3×3 rotation matrix Output axis : Axis of the rotation angle : Angle through which the rotation is performed References NAIF Documentation source SPICE.recazl  —  Method recazl(rectan; azccw=true, elplsz=true) Convert rectangular coordinates of a point to range, azimuth and elevation. Arguments rectan : Rectangular coordinates of a point Keyword Arguments azccw : Flag indicating how azimuth is measured. If  true  (the default), the azimuth increases in the counterclockwise direction; otherwise it increases in the clockwise direction elplsz : Flag indicating how elevation is measured. If  true  (the default), the elevation increases from the XY plane toward +Z; otherwise toward -Z Output Returns a tuple consisting of: range : Distance of the point from the origin az : Azimuth in radians el : Elevation in radians References NAIF Documentation source SPICE.reccyl  —  Method reccyl(rectan) Convert from rectangular to cylindrical coordinates. Arguments rectan : Rectangular coordinates of a point Output r : Distance of the point from the Z axis lon : Angle (radians) of the point from the XZ plane z : Height of the point above the XY plane References NAIF Documentation source SPICE.recgeo  —  Method recgeo(rectan, re, f) Convert from rectangular coordinates to geodetic coordinates. Arguments rectan : Rectangular coordinates of a point re : Equatorial radius of the reference spheroid f : Flattening coefficient Output lon : Geodetic longitude of the point (radians) lat : Geodetic latitude  of the point (radians) alt : Altitude of the point above reference spheroid References NAIF Documentation source SPICE.reclat  —  Method reclat(rectan) Convert from rectangular coordinates to latitudinal coordinates. Arguments rectan : Rectangular coordinates of a point Output Returns a tuple consisting of: rad : Distance of the point from the origin lon : Longitude of the point (radians) lat : Latitude of the point (radians) References NAIF Documentation source SPICE.recpgr  —  Method recpgr(body, rectan, re, f) Convert rectangular coordinates to planetographic coordinates. Arguments body : Body with which coordinate system is associated rectan : Rectangular coordinates of a point re : Equatorial radius of the reference spheroid f : flattening coefficient Output lon : Planetographic longitude of the point (radians). lat : Planetographic latitude of the point (radians). alt : Altitude of the point above reference spheroid. References NAIF Documentation source SPICE.recrad  —  Method recrad(rectan) Convert rectangular coordinates to range, right ascension, and declination. Arguments rectan : Rectangular coordinates of a point Output Return the tuple  (range, ra, dec) . range : Distance of the point from the origin ra : Right ascension in radians dec : Declination in radians References NAIF Documentation source SPICE.recsph  —  Method recsph(rectan) Convert from rectangular coordinates to spherical coordinates. Arguments rectan : Rectangular coordinates of a point Output r : Distance of the point from the origin colat : Angle of the point from the Z-axis in radian lon : Longitude of the point in radians References NAIF Documentation source SPICE.removc!  —  Method removc!(set, item) Remove an item from a character set. Arguments set : A set item : Item to be removed Output Returns the updated set. References NAIF Documentation source SPICE.removd!  —  Method removd!(set, item) Remove an item from a double set. Arguments set : A set item : Item to be removed Output Returns the updated set. References NAIF Documentation source SPICE.removi!  —  Method removi!(set, item) Remove an item from a character set. Arguments set : A set item : Item to be removed Output Returns the updated set. References NAIF Documentation source SPICE.reordc  —  Function reordc(iorder, array)\nreordd(iorder, array)\nreordi(iorder, array)\nreordl(iorder, array) Deprecated Use  array[iorder]  instead. source SPICE.reordd  —  Function reordc(iorder, array)\nreordd(iorder, array)\nreordi(iorder, array)\nreordl(iorder, array) Deprecated Use  array[iorder]  instead. source SPICE.reordi  —  Function reordc(iorder, array)\nreordd(iorder, array)\nreordi(iorder, array)\nreordl(iorder, array) Deprecated Use  array[iorder]  instead. source SPICE.reordl  —  Function reordc(iorder, array)\nreordd(iorder, array)\nreordi(iorder, array)\nreordl(iorder, array) Deprecated Use  array[iorder]  instead. source SPICE.repmc  —  Function repmc(input, marker, value) Deprecated Use  replace(input, marker=>value)  instead. source SPICE.repmct  —  Function repmct\nrepmd\nrepmf\nrepmi\nrepmot Deprecated Use  replace  instead. source SPICE.repmd  —  Function repmct\nrepmd\nrepmf\nrepmi\nrepmot Deprecated Use  replace  instead. source SPICE.repmf  —  Function repmct\nrepmd\nrepmf\nrepmi\nrepmot Deprecated Use  replace  instead. source SPICE.repmi  —  Function repmct\nrepmd\nrepmf\nrepmi\nrepmot Deprecated Use  replace  instead. source SPICE.repmot  —  Function repmct\nrepmd\nrepmf\nrepmi\nrepmot Deprecated Use  replace  instead. source SPICE.rotate  —  Method rotate(angle, iaxis) Calculate the 3×3 rotation matrix generated by a rotation of a specified angle about a specified axis. This rotation is thought of as rotating the coordinate system. Arguments angle : Angle of rotation (radians) iaxis : Axis of rotation (X=1, Y=2, Z=3) Output Returns rotation matrix associated with  angle  and  iaxis . References NAIF Documentation source SPICE.rotmat  —  Method rotmat(m1, angle, iaxis) Applies a rotation of  angle  radians about axis  iaxis  to a matrix  m1 . This rotation is thought of as rotating the coordinate system. Arguments m1 : Matrix to be rotated angle : Angle of rotation (radians) iaxis : Axis of rotation (X=1, Y=2, Z=3) Output Returns the resulting rotated matrix. References NAIF Documentation source SPICE.rotvec  —  Method rotvec(v1, angle, iaxis) Transform a vector to a new coordinate system rotated by  angle  radians about axis  iaxis . This transformation rotates  v1  by  -angle  radians about the specified axis. Arguments v1 : Vector whose coordinate system is to be rotated angle : Angle of rotation in radians iaxis : Axis of rotation (X=1, Y=2, Z=3) Output Returns the resulting vector expressed in the new coordinate system. References NAIF Documentation source SPICE.rpd  —  Function rpd() Deprecated Use  deg2rad  instead. source SPICE.rquad  —  Method rquad(a, b, c) Find the roots of a quadratic equation. Arguments a : Coefficient of quadratic term b : Coefficient of linear term c : Constant Output root1 : Root built from positive discriminant term root2 : Root built from negative discriminant term References NAIF Documentation source SPICE.saelgv  —  Method saelgv(vec1, vec2) Find semi-axis vectors of an ellipse generated by two arbitrary three-dimensional vectors. Arguments vec1 ,  vec2 : Two vectors used to generate an ellipse Output smajor : Semi-major axis of ellipse sminor : Semi-minor axis of ellipse References NAIF Documentation source SPICE.scard!  —  Method scard!(cell::SpiceCell{T}, card) where T Set the cardinality of a cell. Arguments cell : The cell card : Cardinality of (number of elements in) the cell Output Returns  cell  with its cardinality set to  card . References NAIF Documentation source SPICE.scdecd  —  Function scdecd(sc, sclkdp, lenout=128) Convert double precision encoding of spacecraft clock time into a character representation. Arguments sc : NAIF spacecraft identification code sclkdp : Encoded representation of a spacecraft clock count lenout : Maximum allowed length of output SCLK string Output Returns the character representation of a clock count. References NAIF Documentation source SPICE.sce2c  —  Method sce2c(sc, et) Convert ephemeris seconds past J2000 (ET) to continuous encoded spacecraft clock (\"ticks\"). Non-integral tick values may be returned. Arguments sc : NAIF spacecraft ID code et : Ephemeris time, seconds past J2000 Output Returns SCLK, encoded as ticks since spacecraft clock start. References NAIF Documentation source SPICE.sce2s  —  Function sce2s(sc, et, lenout=128) Convert an epoch specified as ephemeris seconds past J2000 (ET) to a character string representation of a spacecraft clock value (SCLK). Arguments sc : NAIF spacecraft identification code et : Ephemeris time, specified as seconds past J2000 lenout : Maximum allowed length of output SCLK string Output Returns an SCLK string. References NAIF Documentation source SPICE.sce2t  —  Method sce2t(sc, et) Convert ephemeris seconds past J2000 (ET) to integral encoded spacecraft clock (\"ticks\"). For conversion to fractional ticks, (required for C-kernel production), see the routine  sce2c . Arguments sc : NAIF spacecraft ID code et : Ephemeris time, seconds past J2000 Output Returns SCLK, encoded as ticks since spacecraft clock start. References NAIF Documentation source SPICE.scencd  —  Method scencd(sc, sclkch) Encode character representation of spacecraft clock time into a double precision number. Arguments sc : NAIF spacecraft identification code sclkch : Character representation of a spacecraft clock Output Returns the encoded representation of the clock count. References NAIF Documentation source SPICE.scfmt  —  Function scfmt(sc, ticks, lenout=128) Convert encoded spacecraft clock ticks to character clock format. Arguments sc : NAIF spacecraft identification code ticks : Encoded representation of a spacecraft clock count lenout : Maximum allowed length of output string Output Returns a character representation of a clock count. References NAIF Documentation source SPICE.scpart  —  Method scpart(sc) Get spacecraft clock partition information from a spacecraft clock kernel file. Arguments sc : NAIF spacecraft identification code Output pstart : Array of partition start times pstop : Array of partition stop times References NAIF Documentation source SPICE.scs2e  —  Method scs2e(sc, sclkch) Convert a spacecraft clock string to ephemeris seconds past J2000 (ET). Arguments sc : NAIF integer code for a spacecraft sclkch : An SCLK string Output Returns ephemeris time seconds past J2000. References NAIF Documentation source SPICE.sct2e  —  Method sct2e(sc, sclkdp) Convert encoded spacecraft clock (\"ticks\") to ephemeris seconds past J2000 (ET). Arguments sc : NAIF integer code for a spacecraft sclkdp : SCLK, encoded as ticks since spacecraft clock start. Output Returns ephemeris time seconds past J2000. References NAIF Documentation source SPICE.sctiks  —  Method sctiks(sc, clkstr) Convert a spacecraft clock format string to number of \"ticks\". Arguments sc : NAIF spacecraft identification code clkstr : Character representation of a spacecraft clock Output Returns the number of ticks represented by the clock string. References NAIF Documentation source SPICE.sdiff  —  Method sdiff(a::T, b::T) where T <: SpiceCell Compute the symmetric difference of two sets of any data type to form a third set. Arguments a : First input set b : Second input set Output Returns a cell containing the symmetric difference of  a  and  b . References NAIF Documentation source SPICE.set  —  Method set(a::T, b::T) where T <: SpiceCell Given a relational operator, compare two sets of any data type. Arguments a : First set op : Comparison operator b : Second set Output Returns the result of the comparison:  a (op) b . References NAIF Documentation source SPICE.shellc  —  Function shellc(array)\nshelld(array)\nshelli(array) Deprecated Use  Base.sort!(array)  instead. source SPICE.shelld  —  Function shellc(array)\nshelld(array)\nshelli(array) Deprecated Use  Base.sort!(array)  instead. source SPICE.shelli  —  Function shellc(array)\nshelld(array)\nshelli(array) Deprecated Use  Base.sort!(array)  instead. source SPICE.sincpt  —  Method sincpt(method, target, et, fixref, abcorr, obsrvr, dref, dvec) Given an observer and a direction vector defining a ray, compute the surface intercept of the ray on a target body at a specified epoch, optionally corrected for light time and stellar aberration. The surface of the target body may be represented by a triaxial ellipsoid or by topographic data provided by DSK files. Arguments method : Computation method target : Name of target body et : Epoch in TDB seconds past J2000 TDB fixref : Body-fixed, body-centered target body frame abcorr : Aberration correction flag obsrvr : Name of observing body dref : Reference frame of ray's direction vector dvec : Ray's direction vector Output Returns a tuple consisting of the following data or  nothing  if no intercept was found. spoint : Surface intercept point on the target body trgepc : Intercept epoch srfvec : Vector from observer to intercept point References NAIF Documentation source SPICE.size_c  —  Method size_c(cell::SpiceCell) Returns the maximum number of elements that  cell  can hold. source SPICE.spd  —  Method spd() Returns the number of seconds in a day. References NAIF Documentation source SPICE.sphcyl  —  Method sphcyl(radius, colat, slon) Converts from spherical coordinates to cylindrical coordinates. Arguments radius : Distance of point from origin colat : Polar angle (co-latitude in radians) of point slon : Azimuthal angle (longitude) of point (radians) Output r : Distance of point from Z axis lon : Angle (radians) of point from XZ plane z : Height of point above XY plane References NAIF Documentation source SPICE.sphlat  —  Method sphlat(r, colat, lons) Convert from spherical coordinates to latitudinal coordinates. Arguments r : Distance of the point from the origin colat : Angle of the point from positive z axis (radians) lons : Angle of the point from the XZ plane (radians) Output radius : Distance of a point from the origin lon : Angle of the point from the XZ plane in radians lat : Angle of the point from the XY plane in radians References NAIF Documentation source SPICE.sphrec  —  Method sphrec(r, colat, lon) Convert from spherical coordinates to rectangular coordinates. Arguments r : Distance of a point from the origin colat : Angle of the point from the Z-axis in radians lon : Angle of the point from the XZ plane in radians Output Returns the rectangular coordinates of the point. References NAIF Documentation source SPICE.spk14a  —  Method spk14a(handle, ncsets, coeffs, epochs) Add data to a type 14 SPK segment associated with  handle . See also  spk14b  and  spk14e . Arguments handle : The handle of an SPK file open for writing ncsets : The number of coefficient sets and epochs coeffs : The collection of coefficient sets epochs : The epochs associated with the coefficient sets References NAIF Documentation source SPICE.spk14b  —  Method spk14b(handle, segid, body, center, frame, first, last, chbdeg) Begin a type 14 SPK segment in the SPK file associated with  handle . See also  spk14a  and  spk14e . Arguments handle : The handle of an SPK file open for writing segid : The string to use for segment identifier body : The NAIF ID code for the body of the segment center : The center of motion for body frame : The reference frame for this segment first : The first epoch for which the segment is valid last : The last epoch for which the segment is valid chbdeg : The degree of the Chebyshev Polynomial used References NAIF Documentation source SPICE.spk14e  —  Method spk14e(handle) End the type 14 SPK segment currently being written to the SPK file associated with  handle . See also  spk14a  and  spk14b . Arguments handle : The handle of an SPK file open for writing Output Returns the handle of the SPK file. References NAIF Documentation source SPICE.spkacs  —  Method spkacs(targ, et, ref, abcorr, obs, starg, lt, dlt) Return the state (position and velocity) of a target body relative to an observer, optionally corrected for light time and stellar aberration, expressed relative to an inertial reference frame. Arguments targ : Target body et : Observer epoch ref : Inertial reference frame of output state abcorr : Aberration correction flag obs : Observer Output starg : State of target lt : One way light time between observer and target dlt : Derivative of light time with respect to time References NAIF Documentation source SPICE.spkapo  —  Method spkapo(targ, et, ref, sobs, abcorr) Return the position of a target body relative to an observer, optionally corrected for light time and stellar aberration. Arguments targ : Target body et : Observer epoch ref : Inertial reference frame of observer's state sobs : State of observer wrt. solar system barycenter abcorr : Aberration correction flag Output ptarg : Position of target lt : One way light time between observer and target References NAIF Documentation source SPICE.spkaps  —  Method spkaps(targ, et, ref, abcorr, stobs, accobs) Given the state and acceleration of an observer relative to the solar system barycenter, return the state (position and velocity) of a target body relative to the observer, optionally corrected for light time and stellar aberration. All input and output vectors are expressed relative to an inertial reference frame. Users normally should call the high-level API routines  spkezr  or  spkez  rather than this routine. Arguments targ : Target body. et : Observer epoch. ref : Inertial reference frame of output state. abcorr : Aberration correction flag. stobs : State of the observer relative to the SSB. accobs : Acceleration of the observer relative to the SSB. Output starg : State of target. lt : One way light time between observer and target. dlt : Derivative of light time with respect to time. References NAIF Documentation source SPICE.spkcls  —  Method spkcls(handle) Close an open SPK file. Arguments handle : Handle of the SPK file to be closed Output Returns the handle of the closed file. References NAIF Documentation source SPICE.spkcov!  —  Method spkcov!(cover, spk, idcode) Find the coverage window for a specified ephemeris object in a specified SPK file. Arguments cover : Window giving coverage in  spk  for  idcode spk : Name of the SPK file idcode : ID code of ephemeris object Output Returns the extended coverage window. References NAIF Documentation source SPICE.spkcpo  —  Method spkcpo(target, et, outref, refloc, abcorr, obspos, obsctr, obsref) Return the state of a specified target relative to an \"observer,\" where the observer has constant position in a specified reference frame. The observer's position is provided by the calling program rather than by loaded SPK files. Arguments target : Name of target ephemeris object et : Observation epoch outref : Reference frame of output state refloc : Output reference frame evaluation locus abcorr : Aberration correction obspos : Observer position relative to center of motion obsctr : Center of motion of observer obsref : Frame of observer position Output state : State of target with respect to observer lt : One way light time between target and observer References NAIF Documentation source SPICE.spkcpt  —  Method spkcpt(trgpos, trgctr, trgref, et, outref, refloc, abcorr, obsrvr) Return the state, relative to a specified observer, of a target having constant position in a specified reference frame. The target's position is provided by the calling program rather than by loaded SPK files. Arguments trgpos : Target position relative to center of motion trgctr : Center of motion of target trgref : Frame of target position et : Observation epoch outref : Reference frame of output state refloc : Output reference frame evaluation locus abcorr : Aberration correction obsrvr : Name of observing ephemeris object Output state : State of target with respect to observer lt : One way light time between target and observer References NAIF Documentation source SPICE.spkcvo  —  Method spkcvo(target, et, outref, refloc, abcorr, obssta, obsepc, obsctr, obsref) Return the state of a specified target relative to an \"observer,\" where the observer has constant velocity in a specified reference frame.  The observer's state is provided by the calling program rather than by loaded SPK files. Arguments target : Name of target ephemeris object et : Observation epoch outref : Reference frame of output state refloc : Output reference frame evaluation locus abcorr : Aberration correction obssta : Observer state relative to center of motion obsepc : Epoch of observer state obsctr : Center of motion of observer obsref : Frame of observer state Output state : State of target with respect to observer lt : One way light time between target and observer References NAIF Documentation source SPICE.spkcvt  —  Method spkcvt(trgsta, trgepc, trgctr, trgref, et, outref, refloc, abcorr, obsrvr) Return the state, relative to a specified observer, of a target having constant velocity in a specified reference frame. The target's state is provided by the calling program rather than by loaded SPK files. Arguments trgsta : Target state relative to center of motion trgepc : Epoch of target state trgctr : Center of motion of target trgref : Frame of target state et : Observation epoch outref : Reference frame of output state refloc : Output reference frame evaluation locus abcorr : Aberration correction obsrvr : Name of observing ephemeris object Output state : State of target with respect to observer lt : One way light time between target and observer References NAIF Documentation source SPICE.spkez  —  Method spkez(targ, et, ref, abcorr, obs) Return the state (position and velocity) of a target body relative to an observing body, optionally corrected for light time (planetary aberration) and stellar aberration. Arguments targ : Target body et : Observer epoch ref : Reference frame of output state vector abcorr : Aberration correction flag obs : Observing body Output starg : State of target lt : One way light time between observer and target References NAIF Documentation source SPICE.spkezp  —  Method spkezp(targ, et, ref, abcorr, obs) Return the position of a target body relative to an observing body, optionally corrected for light time (planetary aberration) and stellar aberration. Arguments targ : Target body et : Observer epoch ref : Reference frame of output state vector abcorr : Aberration correction flag obs : Observing body Output ptarg : Position of target lt : One way light time between observer and target References NAIF Documentation source SPICE.spkezr  —  Method spkezr(targ, et, ref, abcorr, obs) Return the state (position and velocity) of a target body relative to an observing body, optionally corrected for light time (planetary aberration) and stellar aberration. Arguments targ : Target body name et : Observer epoch ref : Reference frame of output state vector abcorr : Aberration correction flag obs : Observing body name Output starg : State of target lt : One way light time between observer and target References NAIF Documentation source SPICE.spkgeo  —  Method spkgeo(targ, et, ref, obs) Compute the geometric state (position and velocity) of a target body relative to an observing body. Arguments targ : Target body. et : Target epoch. ref : Target reference frame. obs : Observing body. Output state : State of target. lt : Light time. References NAIF Documentation source SPICE.spkgps  —  Method spkgps(targ, et, ref, obs) Compute the geometric position of a target body relative to an observing body. Arguments targ : Target body et : Target epoch ref : Target reference frame obs : Observing body Output pos : Position of target lt : Light time References NAIF Documentation source SPICE.spklef  —  Method spklef(fname) Load an ephemeris file for use by the readers. Return that file's handle, to be used by other SPK routines to refer to the file. Arguments fname : Name of the file to be loaded Output handle : Loaded file's handle References NAIF Documentation source SPICE.spkltc  —  Method spkltc(targ, et, ref, abcorr, stobs) Return the state (position and velocity) of a target body relative to an observer, optionally corrected for light time, expressed relative to an inertial reference frame. Arguments targ : Target body et : Observer epoch ref : Inertial reference frame of output state abcorr : Aberration correction flag stobs : State of the observer relative to the SSB Output starg : State of target lt : One way light time between observer and target dlt : Derivative of light time with respect to time References NAIF Documentation source SPICE.spkobj!  —  Method spkobj!(ids, spk) Find the set of ID codes of all objects in a specified SPK file. Arguments ids : A preallocated set of ID codes of objects in SPK file spk : Name of the SPK file Output Returns the set of id codes. References NAIF Documentation source SPICE.spkopa  —  Method spkopa(file) Open an existing SPK file for subsequent write. Arguments file : The name of an existing SPK file Output Returns a handle attached to the SPK file opened to append. References NAIF Documentation source SPICE.spkopn  —  Function spkopn(name, ifname=\"\", ncomch=0) Create a new SPK file, returning the handle of the opened file. Arguments name : The name of the new SPK file to be created ifname : The internal filename for the SPK file (default:  \"\" ) ncomch : The number of characters to reserve for comments (default: 0) Output Returns the handle of the opened SPK file. References NAIF Documentation source SPICE.spkpds  —  Method spkpds(body, center, frame, typ, first, last) Perform routine error checks and if all checks pass, pack the descriptor for an SPK segment. Arguments body : The NAIF ID code for the body of the segment center : The center of motion for body frame : The frame for this segment type : The type of SPK segment to create first : The first epoch for which the segment is valid last : The last  epoch for which the segment is valid Output Returns an SPK segment descriptor. References NAIF Documentation source SPICE.spkpos  —  Method spkpos(targ, et, ref, abcorr, obs) Return the position of a target body relative to an observing body, optionally corrected for light time (planetary aberration) and stellar aberration. Arguments targ : Target body name et : Observer epoch ref : Reference frame of output position vector abcorr : Aberration correction flag obs : Observing body name Output ptarg : Position of target lt : One way light time between observer and target References NAIF Documentation source SPICE.spkpvn  —  Method spkpvn(handle, descr, et) For a specified SPK segment and time, return the state (position and velocity) of the segment's target body relative to its center of motion. Arguments handle : File handle descr : Segment descriptor et : Evaluation epoch Output ref : Segment reference frame ID code state : Output state vector center : Center of state References NAIF Documentation source SPICE.spksfs  —  Method spksfs(body, et) Search through loaded SPK files to find the highest-priority segment applicable to the body and time specified. Arguments body : Body ID et : Ephemeris time Output Returns  nothing  if no segment was found or a tuple consisting of: handle : Handle of file containing the applicable segment descr : Descriptor of the applicable segment ident : Identifier of the applicable segment References NAIF Documentation source SPICE.spkssb  —  Method spkssb(targ, et, ref) Return the state (position and velocity) of a target body relative to the solar system barycenter. Arguments targ : Target body et : Target epoch ref : Target reference frame Output Returns the state of target. References NAIF Documentation source SPICE.spksub!  —  Method spksub!(newh, handle, descr, ident, start, stop) Extract a subset of the data in an SPK segment into a separate segment. Arguments newh : Handle of new segment handle : Handle of source segment descr : Descriptor of source segment ident : Identifier of source segment start : Beginning (initial epoch) of subset stop : End (final epoch) of subset References NAIF Documentation source SPICE.spkuds  —  Method spkuds(descr) Unpack the contents of an SPK segment descriptor. Arguments descr : An SPK segment descriptor Output body : The NAIF ID code for the body of the segment center : The center of motion for body frame : The ID code for the frame of this segment type : The type of SPK segment first : The first epoch for which the segment is valid last : The last  epoch for which the segment is valid start : Beginning DAF address of the segment stop : Ending DAF address of the segment References NAIF Documentation source SPICE.spkuef  —  Method spkuef(handle) Unload an ephemeris file so that it will no longer be searched by the readers. Arguments handle : Handle of file to be unloaded References NAIF Documentation source SPICE.spkw02  —  Method spkw02(handle, body, center, frame, first, last, segid, intlen, cdata, btime) Write a type 2 segment to an SPK file. Arguments handle : Handle of an SPK file open for writing body : Body code for ephemeris object center : Body code for the center of motion of the body frame : The reference frame of the states first : First valid time for which states can be computed last : Last valid time for which states can be computed segid : Segment identifier intlen : Length of time covered by logical record cdata : Array of Chebyshev coefficients btime : Begin time of first logical record References NAIF Documentation source SPICE.spkw03  —  Method spkw03(handle, body, center, frame, first, last, segid, intlen, cdata, btime) Write a type 3 segment to an SPK file. Arguments handle : Handle of an SPK file open for writing body : Body code for ephemeris object center : Body code for the center of motion of the body frame : The reference frame of the states first : First valid time for which states can be computed last : Last valid time for which states can be computed segid : Segment identifier intlen : Length of time covered by logical record cdata : Array of Chebyshev coefficients btime : Begin time of first logical record References NAIF Documentation source SPICE.spkw05  —  Method spkw05(handle, body, center, frame, first, last, segid, gm, states, epochs) Write an SPK segment of type 5 given a time-ordered set of discrete states and epochs, and the gravitational parameter of a central body. Arguments handle : Handle of an SPK file open for writing body : Body code for ephemeris object center : Body code for the center of motion of the body frame : The reference frame of the states first : First valid time for which states can be computed last : Last valid time for which states can be computed segid : Segment identifier gm : Gravitational parameter of central body states : States epochs : Epochs References NAIF Documentation source SPICE.spkw08  —  Method spkw08(handle, body, center, frame, first, last, segid, degree, states, epoch1, step) Write a type 8 segment to an SPK file. Arguments handle : Handle of an SPK file open for writing body : Body code for ephemeris object center : Body code for the center of motion of the body frame : The reference frame of the states first : First valid time for which states can be computed last : Last valid time for which states can be computed segid : Segment identifier degree : Degree of interpolating polynomials states : States epoch1 : Epoch of first state in states array step : Time step separating epochs of states References NAIF Documentation source SPICE.spkw09  —  Method spkw09(handle, body, center, frame, first, last, segid, degree, states, epochs) Write a type 9 segment to an SPK file. Arguments handle : Handle of an SPK file open for writing body : Body code for ephemeris object center : Body code for the center of motion of the body frame : The reference frame of the states first : First valid time for which states can be computed last : Last valid time for which states can be computed segid : Segment identifier degree : Degree of interpolating polynomials states : States epochs : Epochs References NAIF Documentation source SPICE.spkw10  —  Method spkw10(handle, body, center, frame, first, last, segid, consts, elems, epochs) Write a type 10 segment to an SPK file. Arguments handle : The handle of a DAF file open for writing body : The NAIF ID code for the body of the segment center : The center of motion for body frame : The reference frame for this segment first : The first epoch for which the segment is valid last : The last  epoch for which the segment is valid segid : The string to use for segment identifier consts : The array of geophysical constants for the segmen elems : The collection of \"two-line\" element sets epochs : The epochs associated with the element sets References NAIF Documentation source SPICE.spkw12  —  Method spkw12(handle, body, center, frame, first, last, segid, degree, states, epoch1, step) Write a type 12 segment to an SPK file. Arguments handle : Handle of an SPK file open for writing body : Body code for ephemeris object center : Body code for the center of motion of the body frame : The reference frame of the states first : First valid time for which states can be computed last : Last valid time for which states can be computed segid : Segment identifier degree : Degree of interpolating polynomials states : States epoch1 : Epoch of first state in states array step : Time step separating epochs of states References NAIF Documentation source SPICE.spkw13  —  Method spkw13(handle, body, center, frame, first, last, segid, degree, states, epochs) Write a type 13 segment to an SPK file. Arguments handle : Handle of an SPK file open for writing body : Body code for ephemeris object center : Body code for the center of motion of the body frame : The reference frame of the states first : First valid time for which states can be computed last : Last valid time for which states can be computed segid : Segment identifier degree : Degree of interpolating polynomials states : States epochs : Epochs References NAIF Documentation source SPICE.spkw15  —  Method spkw15(handle, body, center, frame, first, last, segid,\n       epoch, tp, pa, p, ecc, j2flg, pv, gm, j2, radius) Write a type 15 segment to an SPK file. Arguments handle : Handle of an SPK file open for writing body : Body code for ephemeris object center : Body code for the center of motion of the body frame : The reference frame of the states first : First valid time for which states can be computed last : Last valid time for which states can be computed segid : Segment identifier epoch : Epoch of the periapse tp : Trajectory pole vector pa : Periapsis vector p : Semi-latus rectum ecc : Eccentricity j2flg : J2 processing flag pv : Central body pole vector gm : Central body GM j2 : Central body J2 radius : Equatorial radius of central body References NAIF Documentation source SPICE.spkw17  —  Method spkw17(handle, body, center, frame, first, last, segid, epoch, eqel, rapol, decpol) Write a type 17 segment to an SPK file. Arguments handle : Handle of an SPK file open for writing body : Body code for ephemeris object center : Body code for the center of motion of the body frame : The reference frame of the states first : First valid time for which states can be computed last : Last valid time for which states can be computed segid : Segment identifier epoch : Epoch of elements in seconds past J2000 eqel : Array of equinoctial elements rapol : Right Ascension of the pole of the reference plane decpol : Declination of the pole of the reference plane References NAIF Documentation source SPICE.spkw18  —  Method spkw18(handle, subtyp, body, center, frame, first, last, segid, degree, packts, epochs) Write a type 18 segment to an SPK file. Arguments handle : Handle of an SPK file open for writing subtyp : SPK type 18 subtype code, either  :S18TP0  or  :S18TP1 body : NAIF code for an ephemeris object center : NAIF code for center of motion of body frame : Reference frame name first : Start time of interval covered by segment last : End time of interval covered by segment segid : Segment identifier degree : Degree of interpolating polynomials packts : Time-ordered array of data packets representing geometric states of body For  :S18TP0 :  [x,  y,  z,  dx/dt,  dy/dt,  dz/dt, vx, vy, vz, dvx/dt, dvy/dt, dvz/dt] For  :S18TP1 :  [x,  y,  z,  dx/dt,  dy/dt,  dz/dt] epochs : Array of epochs corresponding to states. References NAIF Documentation source SPICE.spkw20  —  Method spkw20(handle, body, center, frame, first, last, segid, intlen, n, polydg, cdata, dscale,\n       tscale, initjd, initfr) Write a type 20 segment to an SPK file. Arguments handle : Handle of SPK file open for writing body : NAIF code for ephemeris object center : NAIF code for the center of motion of the body frame : Reference frame name first : Start time of interval covered by segment last : End time of interval covered by segment segid : Segment identifier intlen : Length of time covered by logical record (days) cdata : Array of Chebyshev coefficients and positions dscale : Distance scale of data tscale : Time scale of data initjd : Integer part of begin time (TDB Julian date) of first record initfr : Fractional part of begin time (TDB Julian date) of first record References NAIF Documentation source SPICE.srfc2s  —  Method srfc2s(code, bodyid) Translate a surface ID code, together with a body ID code, to the corresponding surface name. If no such name exists, return a string representation of the surface ID code. Arguments code : Integer surface ID code to translate to a string bodyid : ID code of body associated with surface Output srfstr : String corresponding to surface ID code isname : Logical flag indicating output is a surface name References NAIF Documentation source SPICE.srfcss  —  Method srfcss(code, bodstr) Translate a surface ID code, together with a body string, to the corresponding surface name. If no such surface name exists, return a string representation of the surface ID code. Arguments code : Integer surface ID code to translate to a string bodstr : Name or ID of body associated with surface Output srfstr : String corresponding to surface ID code isname : Logical flag indicating output is a surface name References NAIF Documentation source SPICE.srfnrm  —  Method srfnrm(method, target, et, fixref, npts, srfpts) Map array of surface points on a specified target body to the corresponding unit length outward surface normal vectors. The surface of the target body may be represented by a triaxial ellipsoid or by topographic data provided by DSK files. Arguments method : Computation method target : Name of target body et : Epoch in TDB seconds past J2000 TDB fixref : Body-fixed, body-centered target body frame srfpts : Array of surface points Output Returns an array of outward, unit length normal vectors. References NAIF Documentation source SPICE.srfrec  —  Method srfrec(body, longitude, latitude) Convert planetocentric latitude and longitude of a surface point on a specified body to rectangular coordinates. Arguments body : NAIF integer code of an extended body. longitude : Longitude of point in radians. latitude : Latitude of point in radians. Output Returns the rectangular coordinates of the point. References NAIF Documentation source SPICE.srfs2c  —  Method srfs2c(srfstr, bodstr) Translate a surface string, together with a body string, to the corresponding surface ID code. The input strings may contain names or integer ID codes. Arguments srfstr : Surface name or ID string bodstr : Body name or ID string Output Returns the surface ID code if it was found or  nothing  otherwise. References NAIF Documentation source SPICE.srfscc  —  Method srfscc(srfstr, bodyid) Translate a surface string, together with a body ID code, to the corresponding surface ID code. The input surface string may contain a name or an integer ID code. Arguments srfstr : Surface name or ID string bodyid : Body ID code. Output Returns the surface ID code if it was found or  nothing  otherwise. References NAIF Documentation source SPICE.srfxpt  —  Function srfxpt Deprecated Use  sincpt  instead. source SPICE.ssize!  —  Method ssize!(cell, size) Set the size (maximum cardinality) of a cell of any data type. Arguments cell : The cell size : Size (maximum cardinality) of the cell Output Returns the updated cell. References NAIF Documentation source SPICE.stelab  —  Method stelab(pobj, vobs) Correct the apparent position of an object for stellar aberration. Arguments pobj : Position of an object with respect to the observer vobs : Velocity of the observer with respect to the Solar System barycenter Output Returns the apparent position of the object with respect to the observer, corrected for stellar aberration. References NAIF Documentation source SPICE.stpool  —  Function stpool(item, nth, contin, lenout=1024) Retrieve the nth string from the kernel pool variable, where the string may be continued across several components of the kernel pool variable. Arguments item : Name of the kernel pool variable nth : Index of the full string to retrieve contin : Character sequence used to indicate continuation lenout : Available space in output string (default: 1024) Output Returns the full string concatenated across continuations if the kernel variable was found or  nothing  otherwise. References NAIF Documentation source SPICE.str2et  —  Method str2et(str) Convert a string representing an epoch to a double precision value representing the number of TDB seconds past the J2000 epoch corresponding to the input epoch. Arguments str : A string representing an epoch Output Returns the equivalent value in seconds past J2000, TDB. References NAIF Documentation source SPICE.subpnt  —  Method subpnt(method, target, et, fixref, obsrvr, abcorr) Compute the rectangular coordinates of the sub-observer point on a target body at a specified epoch, optionally corrected for light time and stellar aberration. Arguments method : Computation method target : Name of target body et : Epoch in ephemeris seconds past J2000 TDB fixref : Body-fixed, body-centered target body frame abcorr : Aberration correction obsrvr : Name of observing body Output spoint : Sub-solar point on the target body trgepc : Sub-solar point epoch srfvec : Vector from observer to sub-solar point References NAIF Documentation source SPICE.subpt  —  Function subpt Deprecated Use  subpnt  instead. source SPICE.subpt_pl02  —  Function subpt_pl02 Deprecated Use  subpnt  instead. source SPICE.subslr  —  Method subslr(method, target, et, fixref, abcorr, obsrvr) Compute the rectangular coordinates of the sub-solar point on a target body at a specified epoch, optionally corrected for light time and stellar aberration. Arguments method : Computation method target : Name of target body et : Epoch in ephemeris seconds past J2000 TDB fixref : Body-fixed, body-centered target body frame abcorr : Aberration correction obsrvr : Name of observing body Output spoint : Sub-solar point on the target body trgepc : Sub-solar point epoch srfvec : Vector from observer to sub-solar point References NAIF Documentation source SPICE.subsol  —  Function subsol Deprecated Use  subslr  instead. source SPICE.subsol_pl02  —  Function subsol_pl02 Deprecated Use  subslr  instead. source SPICE.sumad  —  Function sumad(array)\nsumai(array) Deprecated Use  Base.sum(array)  instead. source SPICE.sumai  —  Function sumad(array)\nsumai(array) Deprecated Use  Base.sum(array)  instead. source SPICE.surfnm  —  Method surfnm(a, b, c, point) Computes the outward-pointing, unit normal vector from a point on the surface of an ellipsoid. Arguments a : Length of the ellisoid semi-axis along the x-axis b : Length of the ellisoid semi-axis along the y-axis c : Length of the ellisoid semi-axis along the z-axis point : Body-fixed coordinates of a point on the ellipsoid Output Return the outward pointing unit normal to ellipsoid at point References NAIF Documentation source SPICE.surfpt  —  Method surfpt(positn, u, a, b, c) Determine the intersection of a line-of-sight vector with the surface of an ellipsoid. Arguments positn : Position of the observer in body-fixed frame u : Vector from the observer in some direction a : Length of the ellipsoid semi-axis along the x-axis b : Length of the ellipsoid semi-axis along the y-axis c : Length of the ellipsoid semi-axis along the z-axis Output Returns the point on the ellipsoid pointed to by u or  nothing  if none was found. References NAIF Documentation source SPICE.surfpv  —  Method surfpv(stvrtx, stdir, a, b, c) Find the state (position and velocity) of the surface intercept defined by a specified ray, ray velocity, and ellipsoid. Arguments stvrtx : State of ray's vertex stdir : State of ray's direction vector a : Length of ellipsoid semi-axis along the x-axis b : Length of ellipsoid semi-axis along the y-axis c : Length of ellipsoid semi-axis along the z-axis Output Return the state of surface intercept or  nothing  if none was found. References NAIF Documentation source SPICE.swpool  —  Method swpool(agent, names) Add a name to the list of agents to notify whenever a member of a list of kernel variables is updated. Arguments agent : The name of an agent to be notified after updates names : Variable names whose update causes the notice References NAIF Documentation source SPICE.sxform  —  Method sxform(from, to, et) Return the state transformation matrix from one frame to another at a specified epoch. Arguments from : Name of the frame to transform from to : Name of the frame to transform to et : Epoch of the state transformation matrix Output Returns the state transformation matrix. References NAIF Documentation source SPICE.szpool  —  Method szpool(name) Return the kernel pool size limitations. Arguments name : Name of the parameter to be returned Output Returns the value of the parameter specified by  name  or  nothing  if none was found. References NAIF Documentation source SPICE.termpt  —  Method termpt(method, ilusrc, target, et, fixref, abcorr, corloc, obsrvr, refvec, rolstp,\n       ncuts, schstp, soltol, maxn) Find terminator points on a target body. The caller specifies half-planes, bounded by the illumination source center-target center vector, in which to search for terminator points. The terminator can be either umbral or penumbral. The umbral terminator is the boundary of the region on the target surface where no light from the source is visible. The penumbral terminator is the boundary of the region on the target surface where none of the light from the source is blocked by the target itself. The surface of the target body may be represented either by a triaxial ellipsoid or by topographic data. Arguments method : Computation method ilusrc : Illumination source target : Name of target body et : Epoch in ephemeris seconds past J2000 TDB fixref : Body-fixed, body-centered target body frame abcorr : Aberration correction corloc : Aberration correction locus obsrvr : Name of observing body refvec : Reference vector for cutting half-planes rolstp : Roll angular step for cutting half-planes ncuts : Number of cutting planes schstp : Angular step size for searching soltol : Solution convergence tolerance maxn : Maximum number of entries in output arrays Output npts : Counts of terminator points corresponding to cuts points : Terminator points epochs : Times associated with terminator points trmvcs : Terminator vectors emanating from the observer References NAIF Documentation source SPICE.timdef  —  Function timdef(action, item, value=\"\") Set and retrieve the defaults associated with calendar input strings. Arguments action : The kind of action to take, either  :SET  or  :GET item : The default item of interest. The items that may be requested are: :CALENDAR  with allowed values: \"GREGORIAN\" \"JULIAN\" \"MIXED\" :SYSTEM  with allowed values: \"TDB\" \"TDT\" \"UTC\" :ZONE  with allowed values ( 0 <= HR < 13  and  0 <= MN < 60 ): \"EST\" \"EDT\" \"CST\" \"CDT\" \"MST\" \"MDT\" \"PST\" \"PDT\" \"UTC+$HR\" \"UTC-$HR\" \"UTC+$HR:$MN\" \"UTC-$HR:$MN\" Output Returns the value associated with the default item. References NAIF Documentation source SPICE.timout  —  Function timout(et, pictur, lenout=128) This routine converts an input epoch represented in TDB seconds past the TDB epoch of J2000 to a character string formatted to the specifications of a user's format picture. Arguments et : An epoch in seconds past the ephemeris epoch J2000 pictur : A format specification for the output string lenout : The length of the output string plus 1 (default: 128) Output Returns a string representation of the input epoch. References NAIF Documentation source SPICE.tipbod  —  Method tipbod(ref, body, et) Return a 3×3 matrix that transforms positions in inertial coordinates to positions in body-equator-and-prime-meridian coordinates. Arguments ref : Name of inertial reference frame to transform from body : ID code of body et : Epoch of transformation Output Returns transformation matrix from intertial position to prime meridian. References NAIF Documentation source SPICE.tisbod  —  Method tisbod(ref, body, et) Return a 6×6 matrix that transforms states in inertial coordinates to states in body-equator-and-prime-meridian coordinates. Arguments ref : Name of inertial reference frame to transform from body : ID code of body et : Epoch of transformation Output Returns transformation matrix from intertial state to prime meridian. References NAIF Documentation source SPICE.tkvrsn  —  Function tkvrsn(item=:TOOLKIT) Given an item such as the Toolkit or an entry point name, return the latest version string. References NAIF Documentation source SPICE.tparse  —  Method tparse(string) Parse a time string and return seconds past the J2000 epoch on a formal calendar. Arguments string : Input time string in UTC Output Returns UTC expressed in seconds since J2000. References NAIF Documentation source SPICE.tpictr  —  Function tpictr(sample, lenout=80) Given a sample time string, create a time format picture suitable for use by the routine  timout . Arguments sample : A sample time string lenout : The length for the output picture string (default: 80) Output Returns a format picture that describes sample. References NAIF Documentation source SPICE.trace  —  Function trace(matrix) Deprecated Use  LinearAlgebra.tr(matrix)  instead. source SPICE.tsetyr  —  Method tsetyr(year) Set the lower bound on the 100 year range. Arguments year : Lower bound on the 100 year interval of expansion References NAIF Documentation source SPICE.twopi  —  Function twopi() Deprecated Use  2π  instead. source SPICE.twovec  —  Method twovec(axdef, indexa, plndef, indexp) Find the transformation to the right-handed frame having a given vector as a specified axis and having a second given vector lying in a specified coordinate plane. Arguments axdef : Vector defining a principal axis indexa : Principal axis number of axdef (X=1, Y=2, Z=3) plndef : Vector defining (with axdef) a principal plane indexp : Second axis number (with indexa) of principal plane Output Returns output rotation matrix. References NAIF Documentation source SPICE.tyear  —  Method tyear() Returns the number of seconds per tropical year. References NAIF Documentation source SPICE.ucase  —  Function ucase(in) Deprecated Use  uppercase(in)  instead. source SPICE.ucrss  —  Function ucrss(v1, v2) Deprecated Use  LinearAlgebra.normalize(LinearAlgebra.cross(v1, v2))  instead. source SPICE.uddf  —  Method uddf(udfunc, x, dx) Routine to calculate the first derivative of a caller-specified function using a three-point estimation. Arguments udfunc : A callable that computes the scalar value of interest,   e.g.  f(x::Float64) -> Float64 x : Independent variable of  udfunc dx : Interval from  x  for derivative calculation Output Returns the approximate derivative of  udfunc  at  x . References NAIF Documentation source SPICE.unitim  —  Method unitim(epoch, insys, outsys) Transform time from one uniform scale to another. Arguments epoch : An epoch to be converted insys : The time scale associated with the input epoch outsys : The time scale associated with the function value The uniform time scales are: :TAI :TDT :TDB :ET :JED :JDTDB :JDTDT Output Returns the time in the system specified by  outsys  that is equivalent to the  epoch  in the  insys  time scale. References NAIF Documentation source SPICE.unload  —  Method unload(file) Unload a SPICE kernel. Arguments file : The file name of a kernel to unload References NAIF Documentation source SPICE.unorm  —  Function unorm(v1) Deprecated Use  (LinearAlgebra.normalize(v1), LinearAlgebra.norm(v1))  instead. source SPICE.unormg  —  Function unormg(v1) Deprecated Use  (LinearAlgebra.normalize(v1), LinearAlgebra.norm(v1))  instead. source SPICE.utc2et  —  Method utc2et(utcstr) Convert an input time from Calendar or Julian Date format, UTC, to ephemeris seconds past J2000. Arguments utcstr : Input time string, UTC Output Returns the equivalent of utcstr, expressed in ephemeris seconds past J2000. References NAIF Documentation source SPICE.vadd  —  Function vadd(v1, v2)\nvaddg(v1, v2) Deprecated Use  v1 .+ v2  instead. source SPICE.vaddg  —  Function vadd(v1, v2)\nvaddg(v1, v2) Deprecated Use  v1 .+ v2  instead. source SPICE.valid!  —  Method valid!(set::SpiceCell{T}) where T Create a valid SPICE set from a SPICE Cell of any data type. Arguments set : Set to be validated Output Returns the validated set with ordered elements and duplicates removed. References NAIF Documentation source SPICE.vcrss  —  Function vcrss(v1, v2) Deprecated Use  LinearAlgebra.cross(v1, v2)  instead. source SPICE.vdist  —  Function vdist(v1, v2)\nvdistg(v1, v2) Deprecated Use  LinearAlgebra.norm(v1 - v2)  instead. source SPICE.vdistg  —  Function vdist(v1, v2)\nvdistg(v1, v2) Deprecated Use  LinearAlgebra.norm(v1 - v2)  instead. source SPICE.vdot  —  Function vdot(v1, v2)\nvdotg(v1, v2) Deprecated Use  LinearAlgebra.dot(v1, v2)  instead. source SPICE.vdotg  —  Function vdot(v1, v2)\nvdotg(v1, v2) Deprecated Use  LinearAlgebra.dot(v1, v2)  instead. source SPICE.vequ  —  Function vequ(v1, v2)\nvequg(v1, v2) Deprecated Use  v1 .= v2  instead. source SPICE.vequg  —  Function vequ(v1, v2)\nvequg(v1, v2) Deprecated Use  v1 .= v2  instead. source SPICE.vhat  —  Function vhat(v1)\nvhatg(v1) Deprecated Use  LinearAlgebra.normalize(v1)  instead. source SPICE.vhatg  —  Function vhat(v1)\nvhatg(v1) Deprecated Use  LinearAlgebra.normalize(v1)  instead. source SPICE.vlcom  —  Function vlcom(a, v1, b, v2)\nvlcomg(a, v1, b, v2) Deprecated Use  a .* v1 .+ b .* v2  instead. source SPICE.vlcom3  —  Function vlcom3(a, v1, b, v2, c, v3) Deprecated Use  a .* v1 .+ b .* v2 .+ c .* v3  instead. source SPICE.vlcomg  —  Function vlcom(a, v1, b, v2)\nvlcomg(a, v1, b, v2) Deprecated Use  a .* v1 .+ b .* v2  instead. source SPICE.vminug  —  Function vminug(vin)\nvminus(vin) Deprecated Use  -vin  instead. source SPICE.vminus  —  Function vminug(vin)\nvminus(vin) Deprecated Use  -vin  instead. source SPICE.vnorm  —  Function vnorm(v1)\nvnormg(v1) Deprecated Use  LinearAlgebra.norm(v1)  instead. source SPICE.vnormg  —  Function vnorm(v1)\nvnormg(v1) Deprecated Use  LinearAlgebra.norm(v1)  instead. source SPICE.vpack  —  Function vpack(x, y, z) Deprecated Use  [x, y, z]  instead. source SPICE.vperp  —  Method vperp(a, b) Find the component of a vector that is perpendicular to a second vector. Arguments a : The vector whose orthogonal component is sought b : The vector used as the orthogonal reference Output Returns the component  a  orthogonal to  b . References NAIF Documentation source SPICE.vprjp  —  Method vprjp(vin, plane) Project a vector onto a specified plane, orthogonally. Arguments vin : Vector to be projected plane : Plane onto which vin is projected Output Returns the vector resulting from the projection. References NAIF Documentation source SPICE.vprjpi  —  Method vprjpi(vin, projpl, invpl) Find the vector in a specified plane that maps to a specified vector in another plane under orthogonal projection. Arguments vin : The projected vector projpl : Plane containing  vin invpl : Plane containing inverse image of  vin Output Returns the inverse projection of  vin  or  nothing  if  vin  could not be calculated. References NAIF Documentation source SPICE.vproj  —  Method vproj(a, b) Finds the projection of one vector onto another vector. All vectors are 3-dimensional. Arguments a : The vector to be projected b : The vector onto which  a  is to be projected Output Returns the projection of  a  onto  b . References NAIF Documentation source SPICE.vrel  —  Method vrel(v1, v2) Return the relative difference between two 3-dimensional vectors. Arguments v1 ,  v2 : Two three-dimensional input vectors Output Returns the relative differences between  v1  and  v2 . References NAIF Documentation source SPICE.vrelg  —  Method vrelg(v1, v2) Return the relative difference between two vectors. Arguments v1 ,  v2 : Input vectors Output Returns the relative differences between  v1  and  v2 . References NAIF Documentation source SPICE.vrotv  —  Method vrotv(v, axis, theta) Rotate a vector about a specified axis vector by a specified angle and return the rotated vector. Arguments v : Vector to be rotated axis : Axis of the rotation theta : Angle of rotation (radians) Output Result of rotating  v  about  axis  by  theta . References NAIF Documentation source SPICE.vscl  —  Function vscl(s, v1) Deprecated Use  s .* v1  instead. source SPICE.vsclg  —  Function vsclg(s, v1) Deprecated Use  s .* v1  instead. source SPICE.vsep  —  Method vsep(v1, v2) Return the sepative difference between two 3-dimensional vectors. Arguments v1 ,  v2 : Two three-dimensional input vectors Output Returns the angle between  v1  and  v2  in radians. References NAIF Documentation source SPICE.vsepg  —  Method vsepg(v1, v2) Return the sepative difference between two vectors. Arguments v1 ,  v2 : Input vectors Output Returns the angle between  v1  and  v2  in radians. References NAIF Documentation source SPICE.vsub  —  Function vsub(v1, v2)\nvsubg(v1, v2) Deprecated Use  v1 .- v2  instead. source SPICE.vsubg  —  Function vsub(v1, v2)\nvsubg(v1, v2) Deprecated Use  v1 .- v2  instead. source SPICE.vtmv  —  Function vtmv(v1, matrix, v2)\nvtmvg(v1, matrix, v2) Deprecated Use  v1' * matrix * v2  instead. source SPICE.vtmvg  —  Function vtmv(v1, matrix, v2)\nvtmvg(v1, matrix, v2) Deprecated Use  v1' * matrix * v2  instead. source SPICE.vupack  —  Function vupack(v) Deprecated Use  x, y, z = v  instead. source SPICE.vzero  —  Function vzero(v1)\nvzerog(v1, v2) Deprecated Use  Base.iszero(v1)  instead. source SPICE.vzerog  —  Function vzero(v1)\nvzerog(v1, v2) Deprecated Use  Base.iszero(v1)  instead. source SPICE.wncard  —  Method wncard(window) Return the cardinality (number of intervals) of a double precision window. Arguments window : Input window References NAIF Documentation source SPICE.wncomd  —  Method wncomd(window, left, right) Determine the complement of a double precision window with respect to a specified interval. Arguments window : Input window left :  Left endpoint of the complement interval right :  Right endpoint of the complement interval Output Returns the complement of  window  with respect to  [left,right] . References NAIF Documentation source SPICE.wncond!  —  Method wncond!(window, left, right) Contract each of the intervals of a double precision window. Arguments window : Window to be contracted left :  Amount added to each left endpoint right : Amount subtracted from each right endpoint Output Returns the contracted window. References NAIF Documentation source SPICE.wndifd  —  Method wndifd(a, b) Place the difference of two double precision windows into a third window. Arguments a : Input window b : Input window Output Returns a window containing the difference of  a  and  b . References NAIF Documentation source SPICE.wnelmd  —  Method wnelmd(window, point) Determine whether a point is an element of a double precision window. Arguments window : Input window point : Input point Output Returns  true  if  point  is an element of  window . References NAIF Documentation source SPICE.wnexpd!  —  Method wnexpd(window, left, right) Expand each of the intervals of a double precision window. Arguments left : Amount subtracted from each left endpoint right : Amount added to each right endpoint Output Returns the expanded window. References NAIF Documentation source SPICE.wnextd!  —  Method wnextd!(window, side) Extract the left or right endpoints from a double precision window. Arguments window : Window to be extracted side : Extract left ( :L ) or right ( :R ) endpoints Output Returns the extracted window. References NAIF Documentation source SPICE.wnfetd  —  Method wnfetd(window, n) Fetch a particular interval from a double precision window. Arguments window : Input window n : Index of interval to be fetched Output Returns a tuple consisting of the left and right endpoints of the n-th interval in the input window. References NAIF Documentation source SPICE.wnfild!  —  Method wnfild!(window, small) Fill small gaps between adjacent intervals of a double precision window. Arguments window : Window to be filled small : Limiting measure of small gaps Output Returns the updated window. References NAIF Documentation source SPICE.wnfltd!  —  Method wnfild!(window, small) Filter (remove) small intervals from a double precision window. Arguments window : Window to be filtered small : Limiting measure of small intervals Output Returns the updated window. References NAIF Documentation source SPICE.wnincd  —  Method wnincd(window, left, right) Determine whether an interval is included in a double precision window. Arguments window : Input window left : Left endpoint of the input interval right : Right endpoint of the input interval Output Returns  true  when  (left, right)  is contained in  window . References NAIF Documentation source SPICE.wninsd!  —  Method wninsd!(window, left, right) Insert an interval into a double precision window. Arguments window : Input window left : Left endpoint of the new interval right : Right endpoint of the new interval Output Returns the updated windows. References NAIF Documentation source SPICE.wnintd  —  Method wnintd(a, b) Place the intersection of two double precision windows into a third window. Arguments a : Input window b : Input window Output Returns a window containing the intersection of  a  and  b . References NAIF Documentation source SPICE.wnreld  —  Method wnreld(a, op, b) Compare two double precision windows. Note Consider using overloaded operators instead, i.e.  a == b ,  a ⊆ b , and  a ⊊ b . Arguments a : First window op : Comparison operator b : Second window Output Returns the result of comparison  a (op) b . References NAIF Documentation source SPICE.wnsumd  —  Method wnsumd(window) Summarize the contents of a double precision window. Arguments window : Window to be summarized Output Returns a tuple consisting of: meas : Total measure of intervals in window avg : Average measure stddev : Standard deviation shortest : Location of shortest interval longest : Location of longest interval References NAIF Documentation source SPICE.wnunid  —  Method wnunid(a, b) Place the union of two double precision windows into a third window. Arguments a : Input window b : Input window Output Returns a window containing the union of  a  and  b . References NAIF Documentation source SPICE.wnvald!  —  Method wnvald!(window) Form a valid double precision window from the contents of a window array. Arguments window : A (possibly uninitialized)  SpiceDoubleCell  containing endpoints of   (possibly unordered and non-disjoint) intervals. Output Returns the validated window. References NAIF Documentation source SPICE.xf2eul  —  Method xf2eul(xform, axisa, axisb, axisc) Convert a state transformation matrix to Euler angles and their derivatives with respect to a specified set of axes. Arguments xform : A state transformation matrix axisa : Axis A of the Euler angle factorization axisb : Axis B of the Euler angle factorization axisc : Axis C of the Euler angle factorization Output Returns a tuple of an array of Euler angles and their derivatives and a boolean that indicates whether these are a unique representation. References NAIF Documentation source SPICE.xf2rav  —  Method xf2rav(xform) Determines the rotation matrix and angular velocity of the rotation from a state transformation matrix. Arguments xform : State transformation matrix Output Returns a tuple of the rotation matrix and the angular velocity vector associated with  xform . References NAIF Documentation source SPICE.xfmsta  —  Method xfmsta(input_state, input_coord_sys, output_coord_sys, body) Transform a state between coordinate systems. Arguments input_state : Input state input_coord_sys : Current (input) coordinate system output_coord_sys : Desired (output) coordinate system body : Name or NAIF ID of body with which coordinates are associated (if applicable) Output Returns the converted output state. References NAIF Documentation source SPICE.xpose  —  Function xpose(matrix)\nxpose6(matrix)\nxposeg(matrix) Deprecated Use  Base.transpose(matrix)  instead. source SPICE.xpose6  —  Function xpose(matrix)\nxpose6(matrix)\nxposeg(matrix) Deprecated Use  Base.transpose(matrix)  instead. source SPICE.xposeg  —  Function xpose(matrix)\nxpose6(matrix)\nxposeg(matrix) Deprecated Use  Base.transpose(matrix)  instead. source"},{"id":214,"pagetitle":"Executables","title":"SPICEApplications.jl","ref":"/SPICE/stable/executables/#SPICEApplications.jl","content":" SPICEApplications.jl Note The  SPICEApplications  module is not included within  SPICE . To access the functions documented on this page, install  SPICEApplications  using Julia's package manager:  Pkg.install(\"SPICEApplications\") . The JPL SPICE Toolkit provides executables for interacting with SPICE kernels, such as  mkspk ,  brief , and others.  SPICEApplications.jl  provides idiomatic Julia interfaces to these executables, which themselves are packaged by  CSPICE_jll.jl ."},{"id":215,"pagetitle":"Executables","title":"Usage","ref":"/SPICE/stable/executables/#Usage","content":" Usage Each executable can be called through its corresponding function without arguments, or programatically using function arguments. For example, the SPICE Toolkit's  BRIEF  program prints the description of a provided kernel. When the  brief  executable is called without arguments, it prints its \"help\" text; this can be replicated by calling  SPICEApplications.brief()  without arguments. Alternatively, you can pass the kernel that you want to inspect as a positional argument:  brief(kernel_file) . All SPICE Toolkit executables are documented within the  SPICE Toolkit Documentation . julia> using SPICEApplications julia> kernel = download(\"https://naif.jpl.nasa.gov/pub/naif/CASSINI/kernels/spk/000202R_SK_V1P32_V2P12.bsp\") \"/tmp/jl_yjuTWZ/000202R_SK_V1P32_V2P12.bsp\" julia> brief(kernel);  \nBRIEF -- Version 4.1.0, September 17, 2021 -- Toolkit Version N0067\n \n \nSummary for: /tmp/jl_yjuTWZ/000202R_SK_V1P32_V2P12.bsp\n \nBody: CASSINI (-82)\n      Start of Interval (ET)              End of Interval (ET)\n      -----------------------------       -----------------------------\n      1998 MAY 28 21:23:03.184            1999 JUL 06 16:01:04.183"},{"id":216,"pagetitle":"Executables","title":"Example","ref":"/SPICE/stable/executables/#Example","content":" Example For a concrete usage example, see how  SPICEApplications  is used to   generate   docstrings for  SPICEKernels.jl ."},{"id":217,"pagetitle":"Executables","title":"Reference","ref":"/SPICE/stable/executables/#Reference","content":" Reference SPICEApplications.SPICEApplications  —  Module Call all SPICE Utilities from within Julia! Warning This package is not affiliated with or endorsed by NASA, JPL, Caltech, or any other organization! This is an independently written package by an astrodynamics hobbyist. Extended help README SPICEApplications Generate ephemeris kernel files using NASA JPL's  SPICEApplications  program, all from within Julia! Installation Choose one of the following two lines! import Pkg; Pkg.add(\"SPICEApplications\"); ]add SPICEApplications # in Julia's REPL Documentation The documentation for  SPICEApplications.jl  is hosted within the  SPICE.jl documentation . Credits NASA JPL developed and maintains the  NAIF SPICE Toolkit , including  SPICEApplications . Helge Eichhorn developed and maintains  SPICE.jl , as well as the  Julia wrappers  around the SPICE Toolkit. License Exports brief chronos ckbrief commnt dskbrief dskexp frmdiff inspekt mkdsk mkspk msopck spacit spkdiff spkmerge tobin toxfr Imports Base DocStringExtensions source SPICEApplications.brief  —  Method brief(\n    file;\n    tabular,\n    single,\n    centers,\n    utc,\n    utcdoy,\n    etsec,\n    sec,\n    min,\n    hour,\n    day,\n    bytime,\n    bycoverage,\n    byid,\n    byname,\n    body,\n    center,\n    at,\n    from,\n    to,\n    listfile,\n    help,\n    version,\n    stdout,\n    stderr,\n    stdin,\n    append,\n    wait\n)\n BRIEF is a command-line utility program that displays a contents and time coverage summary for one or more binary SPK or binary PCK files. Extended Help Warning All descriptions below were manually parsed from the commandline program's help/usage output. Argument Equivalent Description tabular -t Display summary in a tabular format single -a Treat all files as a single file centers -c Displays centers of motion/relative-to frames utc -utc Display times in UTC calendar date format (needs LSK) utcdoy -utcdoy Display times in UTC day-of-year format (needs LSK) etsec -etsec Display times as ET seconds past J2000 sec -sec Display times \"rounded inward\" to second min -min Display times \"rounded inward\" to minute hour -hour Display times \"rounded inward\" to hour day -day Display times \"rounded inward\" to day bytime -s Display summary sorted by start time for each body/frame bycoverage -g Display summary grouped by coverage byid -n Display bodies/frames using numeric id-codes byname -o Display summary ordered by body/frame name body -sb[bod] Display summary for body [bod] center -sc[cen] Display summary for center of motion/relative-to frame [cen] at -at [time] Display summary if coverage contains epoch [time] from -from [beg] Display summary if coverage contains interval [beg]:[end] to -to [end] Display summary if coverage contains interval [beg]:[end] listfile -f [list] Summarize kernels listed in the [list] file help -h Display help version -v Display version source SPICEApplications.chronos  —  Method chronos(\n    file;\n    from,\n    fromtype,\n    to,\n    totype,\n    format,\n    time,\n    sc,\n    center,\n    landingtime,\n    sol1index,\n    nolabel,\n    trace,\n    help,\n    usage,\n    template,\n    stdout,\n    stderr,\n    stdin,\n    append,\n    wait\n)\n CHRONOS is a command-line program that converts between several time systems and time formats. Extended Help Warning All descriptions below were manually parsed from the commandline program's help/usage output. Argument Equivalent Description from -FROM <arg> \"from\" time system fromtype -FROMTYPE <arg> \"from\" time system type to -TO <arg> \"to\" time system totype -TOTYPE <arg> \"to\" time system  type format -FORMAT <arg> output time format picture time -TIME <time> input time sc -SC <ID> sc ID center -CENTER <ID> central body ID landingtime -LANDINGTIME <time> UTC time of the landing sol1index -SOL1INDEX <index> index of the first SOL nolabel -NOLABEL trace -TRACE help -HELP display help usage -USAGE display usage template -TEMPLATE display setup file template source SPICEApplications.ckbrief  —  Method ckbrief(\n    file;\n    dump,\n    boundaries,\n    relframes,\n    idframes,\n    tabular,\n    single,\n    bycoverage,\n    utc,\n    utcdoy,\n    sclk,\n    dpsclk,\n    id,\n    summarize,\n    help,\n    version,\n    stdout,\n    stderr,\n    stdin,\n    append,\n    wait\n)\n CKBRIEF is a command-line utility program that displays a contents and time coverage summary for one or more binary CK files. Extended Help Warning All descriptions below were manually parsed from the commandline program's help/usage output. Argument Equivalent Description dump -dump display interpolation intervals boundaries boundaries -nm display segment boundaries relframes -rel display relative-to frames idframes -n display frames associated with structure IDs tabular -t display summary in a tabular format single -a treat all files as a single file bycoverage -g display summary grouped by coverage utc -utc display times in UTC calendar date format utcdoy -utcdoy display times in UTC day-of-year format sclk -sclk display times as SCLK strings dpsclk -dpsclk display times as SCLK ticks id [ID] display summmary for structure with [ID] summarize -f summarize kernels listed in the  [list]  file help -h display help version -v display version source SPICEApplications.commnt  —  Function commnt(; ...)\ncommnt(kernelfile; ...)\ncommnt(\n    kernelfile,\n    commentfile;\n    add,\n    extract,\n    read,\n    delete,\n    help,\n    stdout,\n    stderr,\n    stdin,\n    append,\n    wait\n)\n COMMNT is a command-line program that reads, adds, extracts, or deletes comments from SPICE binary kernel files. Extended Help Warning All descriptions below were manually parsed from the commandline program's help/usage output. Argument Equivalent Description add -a add comments to binary kernel extract -e extract comments from a binary kernel read -r read the comments in a binary kernel delete -d delete the comments from the binary kernel help -h display the help message source SPICEApplications.dskbrief  —  Method dskbrief(\n    file;\n    single,\n    gaps,\n    extended,\n    timebounds,\n    bysegment,\n    full,\n    sigdigs,\n    version,\n    help,\n    usage,\n    stdout,\n    stderr,\n    stdin,\n    append,\n    wait\n)\n DSKBRIEF is a command-line utility program that displays a summary of the spatial coverage and additional attributes of one or more binary Digital Shape Kernel (DSK) files. Extended Help Warning All descriptions below were manually parsed from the commandline program's help/usage output. Argument Equivalent Description single -a treat all DSK files as a single file gaps -gaps display coverage gaps (aplies only when  -a  is used) extended -ext display extended summaries: these include data type, data class, and time bounds timebounds -tg require segment time bounds to match when grouping segments full -full display a detailed summary for each segment, including data-type-specific parameters sigdigs -d <n> display  n  significant digits of floating point values version -v display the version of the program help -h display help text usage -u display usage text source SPICEApplications.dskexp  —  Method dskexp(\n;\n    dsk,\n    text,\n    format,\n    precision,\n    stdout,\n    stderr,\n    stdin,\n    append,\n    wait\n)\n DSKEXP is a command-line program that exports data from DSK files to text files. Extended Help Warning All descriptions below were manually parsed from the commandline program's help/usage output. Argument Equivalent Description dsk -dsk <arg> DSK kernel text -text <name> output name format -format <arg> MKSDK format code/name precision -prec <number> number of vertex mantissa digits source SPICEApplications.frmdiff  —  Method frmdiff(\n;\n    kernels,\n    from1,\n    to1,\n    frame1,\n    supporting_kernels1,\n    from2,\n    to2,\n    frame2,\n    supporting_kernels2,\n    angular,\n    angularframe,\n    start,\n    stop,\n    numpoints,\n    timestep,\n    timeformat,\n    report,\n    rotation,\n    units,\n    sigdigs,\n    stdout,\n    stderr,\n    stdin,\n    append,\n    wait\n)\n FRMDIFF is a program that samples orientation of a reference frame known to SPICE or computes differences between orientations of two reference frames known to SPICE, and either displays this orientation or these differences, or shows statistics about it or them. Extended Help Warning All descriptions below were manually parsed from the commandline program's help/usage output. Argument Equivalent Description kernels -k  <kernels> supporting kernel(s) name(s) from1 -f1 <arg> first \"from\" frame, name or ID to1 -t1 <arg> first \"to\" frame, name or ID frame1 -c1 <arg> first frame for coverage look up, name or ID supporting_kernels1 -k1 <kernels> additional supporting kernel(s) for first file from2 -f2 <arg> second \"from\" frame, name or ID to2 -t2 <arg> second \"to\" frame, name or ID frame2 -c2 <arg> second frame for coverage look up, name or ID supporting_kernels2 -k2 <kernels> additional supporting kernel(s) for second file angular `-a  <yes no>` angularframe `-m  <from to>` start -b  <start> interval start time stop -e  <stop> interval stop time numpoints -n  <number> number of points 1 to 1000000 (default: 1000) timestep -s  <time step> time step in seconds timeformat -f  <format> time format: one of  et ,  sclk ,  sclkd ,  ticks ,  picture_for_TIMOUT , (default:  et ) report -t  <report options> report options:  basic ,  stats ,  dumpaa ,  dumpm ,  dumpqs ,  dumpqo ,  dumpea ,  dumpc ,  dumpg rotation -o  <order> rotation axes order (default: z y x) units -x  <units> units for output angles (only for  -t dumpaa  and  -t dumpea ) sigdigs -d  <num> number of significant digits (6 to 17, default 14) source SPICEApplications.inspekt  —  Method inspekt(; stdout, stderr, stdin, append, wait)\n INSPEKT is an interactive program that examines the contents of an events component (ESQ) of an E-kernel. source SPICEApplications.mkdsk  —  Method mkdsk(\n;\n    setup,\n    input,\n    output,\n    help,\n    template,\n    usage,\n    version,\n    stdout,\n    stderr,\n    stdin,\n    append,\n    wait\n)\n MKDSK is a utility program that creates a SPICE Digital Shape Kernel (DSK) file from a text file containing shape data for an extended object. Extended Help Warning All descriptions below were manually parsed from the commandline program's help/usage output. Argument Equivalent Description setup -setup <filename> setup file name input -input <filename> input shape data file name output -output <filename> output DSK file name help -h , -help display help template -t , -template display template usage -u , -usage display usage version -v , -version display version source SPICEApplications.mkspk  —  Method mkspk(\n;\n    setup,\n    input,\n    output,\n    add,\n    usage,\n    help,\n    template,\n    stdout,\n    stderr,\n    stdin,\n    append,\n    wait\n)\n MKSPK is a program that creates an SPK file from a text file containing trajectory information. Extended Help Warning All descriptions below were manually parsed from the commandline program's help/usage output. Argument Equivalent Description setup -setup <filename> setup file name input -input <filename> input shape data file name output -output <filename> output DSK file name add -append append; output file must be new help -h , -help display help template -t , -template display template usage -u , -usage display usage source SPICEApplications.msopck  —  Method msopck(\n;\n    setup,\n    input,\n    output,\n    stdout,\n    stderr,\n    stdin,\n    append,\n    wait\n)\n MSOPCK is a command-line program that converts attitude data provided in a text file as UTC, SCLK, or ET-tagged quaternions, Euler angles, or matrices, optionally accompanied by angular velocities, into a type 1, 2, or 3 SPICE C-kernel. source SPICEApplications.spacit  —  Method spacit(; stdout, stderr, stdin, append, wait)\n SPACIT is an interactive program that converts kernels in transfer format to binary format, converts binary kernels to transfer format, and summarizes the contents of binary kernels. source SPICEApplications.spkdiff  —  Method spkdiff(\n;\n    kernels,\n    body1,\n    center1,\n    frame1,\n    supporting_kernels1,\n    body2,\n    center2,\n    frame2,\n    supporting_kernels2,\n    start,\n    stop,\n    timestep,\n    numstates,\n    timeformat,\n    sigdigs,\n    report,\n    stdout,\n    stderr,\n    stdin,\n    append,\n    wait\n)\n SPKDIFF provides means for comparing the trajectories of two bodies or sampling the trajectory of a single body using data from SPICE kernels. Extended Help Warning All descriptions below were manually parsed from the commandline program's help/usage output. Argument Equivalent Description kernels -k  <kernels> supporting kernel(s) name(s) body1 -b1 <arg> first body name or ID center1 -c1 <arg> first center name or ID frame1 -r1 <arg> first reference frame name supporting_kernels1 -k1 <kernels> additional supporting kernel(s) for first SPK body2 -b2 <arg> second body name or ID center2 -c2 <arg> second center name or ID frame2 -r2 <arg> second reference frame name supporting_kernels2 -k2 <kernels> additional supporting kernel(s) for second SPK start -b  <start> interval start time stop -e  <stop> interval stop time timestep -s  <time step> time step in seconds numstates -n  <number> number of states: 2 to 1000000 (default: 1000) timeformat -f  <arg> output time format (default: TDB seconds past J2000) sigdigs1 -d  <arg> number of significant digits: 6 to 17 (default: 14) report -t  <type> report type:  basic , stats , dump , dumpvf , dumpc , dumpg  (def.:  basic , dump ) source SPICEApplications.spkmerge  —  Function spkmerge(; ...)\nspkmerge(commandfile; stdout, stderr, stdin, append, wait)\n SPKMERGE is a program that subsets or merges one or more SPK files into a single SPK file. source SPICEApplications.tobin  —  Function tobin(; ...)\ntobin(kernelfile; stdout, stderr, stdin, append, wait)\n TOBIN is a command-line program that converts transfer format SPK, CK, PCK, DSK and EK files to binary format. source SPICEApplications.toxfr  —  Function toxfr(; ...)\ntoxfr(kernelfile; stdout, stderr, stdin, append, wait)\n TOXFR is a command-line program that converts binary format SPK, CK, PCK, DSK and EK files to transfer format. source"},{"id":220,"pagetitle":"Home","title":"Orbits.jl","ref":"/Orbits/stable/#Orbits.jl","content":" Orbits.jl Flexible and fast astronomical orbits (originally a submodule of  Transits.jl ). The goals of this package are, in this order: have a simple interface with high  composability be flexible with respect to numeric types and application be fully compatible with  ChainRules.jl  automatic differentiation (AD) system to leverage the derived analytical gradients provide a codebase that is well-organized, instructive, and easy to extend maintain high performance: at least as fast as similar tools"},{"id":221,"pagetitle":"Home","title":"Installation","ref":"/Orbits/stable/#Installation","content":" Installation To install use  Pkg . From the REPL, press  ]  to enter Pkg-mode pkg> add Orbits If you want to use the most up-to-date version of the code, check it out from  main pkg> add Orbits#main"},{"id":222,"pagetitle":"Home","title":"Contributing and Support","ref":"/Orbits/stable/#Contributing-and-Support","content":" Contributing and Support If you would like to contribute, feel free to open a  pull request . If you want to discuss something before contributing, head over to  discussions  and join or open a new topic."},{"id":225,"pagetitle":"API/Reference","title":"API/Reference","ref":"/Orbits/stable/api/#API/Reference","content":" API/Reference"},{"id":226,"pagetitle":"API/Reference","title":"Index","ref":"/Orbits/stable/api/#Index","content":" Index Orbits.KeplerianOrbit Orbits.SimpleOrbit Orbits.flip Orbits.position_angle Orbits.relative_position Orbits.separation"},{"id":227,"pagetitle":"API/Reference","title":"Orbits.SimpleOrbit","ref":"/Orbits/stable/api/#Orbits.SimpleOrbit","content":" Orbits.SimpleOrbit  —  Type SimpleOrbit(; period, duration, t0=0, b=0.0) Circular orbit parameterized by the basic observables of a transiting system. Parameters period  - The orbital period of the planets, nominally in days duration  - The duration of the transit, similar units as  period . t0  - The midpoint time of the reference transit, similar units as  period b  - The impact parameter of the orbit, unitless source"},{"id":228,"pagetitle":"API/Reference","title":"Orbits.KeplerianOrbit","ref":"/Orbits/stable/api/#Orbits.KeplerianOrbit","content":" Orbits.KeplerianOrbit  —  Type KeplerianOrbit(; kwargs...) Keplerian orbit parameterized by the basic observables of a transiting 2-body system. The following units are used by default:     * d: Days     * R⊙: Solar radius     * M⊙: Solar mass     * M⊙/R⊙³: Solar density     * rad: Radians  Parameters period / P  – The orbital period of the planet [d]. t0 / t_0  – The midpoint time of the reference transit [d]. tp / t_p  – The time of periastron [d]. duration / τ / T  – The transit duration [d]. a  – The semi-major axis [R⊙]. aR_star / aRs  – The ratio of the semi-major axis to star radius. R_planet / Rp  – The radius of the planet [R⊙]. R_star / Rs  – The radius of the star [R⊙]. rho_star / ρ_star  – The spherical star density [M⊙/R⊙³]. r / RpRs  – The ratio of the planet radius to star radius. b  – The impact parameter, bounded between 0 ≤ b ≤ 1. ecc / e  – The eccentricity of the closed orbit, bounded between 0 ≤ ecc < 1. incl  – The inclination of the orbital plane relative to the axis perpendicular to the          reference plane [rad] omega / ω  – The argument of periapsis [rad]. cos_omega / cos_ω  – The cosine of the argument of periapsis. sin_omega / sin_ω  – The sine of the argument of periapsis. Omega / Ω  – The longitude of the ascending node [rad]. M_planet / Mp  – The mass of the planet [M⊙]. M_star / Ms  – The mass of the star [M⊙]. Valid combinations The following flowchart can be used to determine which parameters can define a  KeplerianOrbit : The  period  or  a  must be given. If both given, then neither  M_star  or  rho_star  can be defined because the stellar density is now implied. Only  incl  or  b  can be given. If  ecc  is given, then  omega  must also be given. If no stellar parameters are given, the central body is assumed to be the Sun. If only  rho_star  is given, then  R_star  is defined to be 1 solar radius. Otherwise, at most two of  M_star ,  R_star , and  rho_star  can be given. Either  t0  or  tp  must be given, but not both. source"},{"id":229,"pagetitle":"API/Reference","title":"Orbits.relative_position","ref":"/Orbits/stable/api/#Orbits.relative_position","content":" Orbits.relative_position  —  Function relative_position(::AbstractOrbit, t) The relative position,  [x, y, z] , of the companion compared to the host at time  t . In other words, this is the vector pointing from the host to the companion along the line of sight. Nominally, the units of this distance are relative to the host's radius. For example, a distance of 2 is 2  stellar  radii. source"},{"id":230,"pagetitle":"API/Reference","title":"Orbits.separation","ref":"/Orbits/stable/api/#Orbits.separation","content":" Orbits.separation  —  Function separation(::AbstractOrbit, t) Calculates the separation of the companion at time  t source"},{"id":231,"pagetitle":"API/Reference","title":"Orbits.position_angle","ref":"/Orbits/stable/api/#Orbits.position_angle","content":" Orbits.position_angle  —  Function position_angle(::AbstractOrbit, t) Calculates the position angle (in degrees) of the companion at time  t source"},{"id":232,"pagetitle":"API/Reference","title":"Orbits.flip","ref":"/Orbits/stable/api/#Orbits.flip","content":" Orbits.flip  —  Function flip(::AbstractOrbit) Return a new orbit with the primary and secondary swapped. source"},{"id":235,"pagetitle":"Getting Started","title":"Getting Started","ref":"/Orbits/stable/gettingstarted/#Getting-Started","content":" Getting Started"},{"id":236,"pagetitle":"Getting Started","title":"Keplerian Orbits","ref":"/Orbits/stable/gettingstarted/#Keplerian-Orbits","content":" Keplerian Orbits Let's dive straight into some of the features Orbits.jl offers. Keplerian orbits are the backbone of astrodynamics, and we provide a \"kitchen-sink\" style  KeplerianOrbit . This means it will try and parse whichever keyword arguments you provide, with units, uncertainties, and more thanks to Julia's composability. Here we present the orbital solution for the binary system SAO 136799, as derived by Tokovinin et al. 2015 [1] using Measurements\nusing Orbits\nusing Plots\nusing Unitful\nusing UnitfulAstro\nusing UnitfulRecipes\n\ndistance = inv(6.92e-3)u\"pc\"\n\norbit = KeplerianOrbit(;\n    period = (40.57 ± 0.19)u\"yr\",\n    ecc = 0.42 ± 0.009,\n    Omega = (318.6 ± 0.6)u\"°\",\n    tp = (1972.12 ± 0.16)u\"yr\",\n    incl = (54.7 ± 0.6)u\"°\",\n    a = (0.154 ± 0.001)u\"arcsecond\" * distance |> u\"AU\",\n    omega = (72.6 ± 0.8)u\"°\",\n)\nplot(orbit; label=\"\")\nscatter!([0], [0], c=:black, marker=:+, lab=\"SAO 136799A\") we can show the orbit in sky angles by providing the distance to the system plot(orbit; label=\"\", distance)\nscatter!([0], [0], c=:black, marker=:+, lab=\"SAO 136799A\")"},{"id":237,"pagetitle":"Getting Started","title":"Calculating ephemerides","ref":"/Orbits/stable/gettingstarted/#Calculating-ephemerides","content":" Calculating ephemerides Using our above orbit, let's figure out the position of the secondary star on a specific date using Dates\n\nfunction year_as_decimal(date::DateTime)\n    year_start = DateTime(Dates.year(date), 1, 1)\n    year_end = DateTime(Dates.year(date) + 1, 1, 1)\n    fraction = (date - year_start) / (year_end - year_start)\n    return (Dates.year(year_start) + fraction)u\"yr\"\nend\n\nobs_time = DateTime(2022, 2, 19, 10, 29, 45)\ntime = year_as_decimal(obs_time) 2022.1354447298327 yr pos = relative_position(orbit, time)\n# convert to angles for plot\nra, dec, _ = @. pos / distance |> u\"arcsecond\"\nscatter!([ra], [dec], lab=\"SAO 136799B\")"},{"id":238,"pagetitle":"Getting Started","title":"Getting binary parameters","ref":"/Orbits/stable/gettingstarted/#Getting-binary-parameters","content":" Getting binary parameters Continuing our above example, let's calculate the position angle and separation of the binary at the observing date above using Orbits: position_angle, separation\n\npa = position_angle(orbit, time)\nsep = separation(orbit, time) / distance |> u\"arcsecond\"\npa, sep (118.4 ± 1.5, 0.1646 ± 0.0016 ″) let's show that with a polar plot; keep in mind the polar plot has 0 degrees as the positive x-axis, but parallactic angles start at the axis with the north celestial pole, which is 90 degrees in the polar plot. scatter([deg2rad(pa - 270)], [sep], proj=:polar, lab=\"SAO 136799B\")"},{"id":239,"pagetitle":"Getting Started","title":"SkyCoords.jl","ref":"/Orbits/stable/gettingstarted/#SkyCoords.jl","content":" SkyCoords.jl These ephemerides can be translated into  SkyCoords  easily using AstroAngles\nusing SkyCoords\n\norigin = ICRSCoords(dms\"09 22 50.8563427\", hms\"-09 50 19.659199\") SkyCoords.ICRSCoords{Float64}(0.16372573177725708, -2.575790303986864) using Measurements: value\n\ncoord = offset(origin, value(sep), deg2rad(value(pa))) SkyCoords.ICRSCoords{Float64}(1.999785964591127, -0.5658019707093447) 1 Tokovinin et al. (2015) \"Speckle Interferometry at SOAR in 2014\" ( ads )"},{"id":242,"pagetitle":"Home","title":"Transits.jl","ref":"/Transits/stable/#Transits.jl","content":" Transits.jl Transits.jl provides flexible and powerful occultation curves with limb darkening. The goals of this package are, in this order have a simple interface with high  composability be flexible with respect to numeric types and application be fully compatible with  ChainRules.jl  automatic differentiation (AD) system to leverage the derived analytical gradients provide a codebase that is well-organized, instructive, and easy to extend maintain high performance: at least as fast as similar tools In particular,  PolynomialLimbDark  implements the \"starry\" limb darkening method, which solves the flux integral analytically. This provides floating-point errors and runtimes that are best in class."},{"id":243,"pagetitle":"Home","title":"Installation","ref":"/Transits/stable/#Installation","content":" Installation To install use  Pkg . From the REPL, press  ]  to enter Pkg-mode pkg> add Transits If you want to use the most up-to-date version of the code, check it out from  main pkg> add Transits#main"},{"id":244,"pagetitle":"Home","title":"Citations","ref":"/Transits/stable/#Citations","content":" Citations If you use Transits.jl or a derivative of it in your work please consider citing it at the  Zenodo DOI . If you use  PolynomialLimbDark  or  QuadLimbDark  please also cite  Agol et al. (2020)  and  Luger et al. (2019) . If you use  Kipping13  please cite  Kipping (2013) . BibTeX for all those citations can be found in  CITATIONS.bib ."},{"id":247,"pagetitle":"API/Reference","title":"API/Reference","ref":"/Transits/stable/api/#API/Reference","content":" API/Reference"},{"id":248,"pagetitle":"API/Reference","title":"Index","ref":"/Transits/stable/api/#Index","content":" Index Transits.AbstractLimbDark Transits.AbstractLimbDark Transits.IntegratedLimbDark Transits.Kipping13 Transits.PolynomialLimbDark Transits.QuadLimbDark Transits.SecondaryLimbDark Transits.compute Transits.compute"},{"id":249,"pagetitle":"API/Reference","title":"Light Curves","ref":"/Transits/stable/api/#Light-Curves","content":" Light Curves"},{"id":250,"pagetitle":"API/Reference","title":"Transits.AbstractLimbDark","ref":"/Transits/stable/api/#Transits.AbstractLimbDark","content":" Transits.AbstractLimbDark  —  Type AbstractLimbDark A limb dark law need only need to implement  compute(::Law, b, r)  to extend the limb darkening interface. See also compute source"},{"id":251,"pagetitle":"API/Reference","title":"Transits.AbstractLimbDark","ref":"/Transits/stable/api/#Transits.AbstractLimbDark-Tuple","content":" Transits.AbstractLimbDark  —  Method (::AbstractLimbDark)(b, r) An alias for calling  compute Examples julia> ld = PolynomialLimbDark([0.4, 0.26]);\n\njulia> ld(0, 0.01)\n0.9998785437247428 source"},{"id":252,"pagetitle":"API/Reference","title":"Transits.PolynomialLimbDark","ref":"/Transits/stable/api/#Transits.PolynomialLimbDark","content":" Transits.PolynomialLimbDark  —  Type PolynomialLimbDark(u::AbstractVector) Polynomial limb darkening using analytical integrals. The length of the  u  vector is equivalent to the order of polynomial used; e.g.,  [0.2, 0.3]  corresponds to quadratic limb darkening. Mathematical form \\[I(\\mu) \\propto 1 - u_1(1-\\mu) - u_2(1-\\mu)^2 - \\dots - u_N(1-\\mu)^N\\] which is equivalent to the series \\[I(\\mu) \\propto -\\sum_{i=0}^N{u_i(1-\\mu)^i}\\] with the definition  $u_0 \\equiv -1$ . Examples u = [0.4, 0.26] # quadratic and below is 100% analytical\nld = PolynomialLimbDark(u)\nld(0.1, 0.01)\n\n# output\n0.9998787880717668 u2 = vcat(u, ones(12) ./ 12)\nld2 = PolynomialLimbDark(u2)\nld2(0.1, 0.01)\n\n# output\n0.9998740059086433 References Agol, Luger, Foreman-Mackey (2020) \"Analytic Planetary Transit Light Curves and Derivatives for Stars with Polynomial Limb Darkening\" Luger et al. (2019) \"starry: Analytic Occultation Light Curves\" source"},{"id":253,"pagetitle":"API/Reference","title":"Transits.QuadLimbDark","ref":"/Transits/stable/api/#Transits.QuadLimbDark","content":" Transits.QuadLimbDark  —  Type QuadLimbDark(u::AbstractVector) A specialized implementation of  PolynomialLimbDark  with a maximum of two terms (quadratic form). This has a completely closed-form solution without any numerical integration. This means there are no intermediate allocations and reduced numerical error. Mathematical form \\[I(\\mu) \\propto 1 - u_1(1-\\mu) - u_2(1-\\mu)^2\\] Higher-order terms Higher-order terms will be  ignored ; no error will be thrown Examples ld = QuadLimbDark(Float64[]) # constant term only\n\nb = [0, 1, 2] # impact parameter\nr = 0.01 # radius ratio\nld.(b, r)\n\n# output\n3-element Vector{Float64}:\n 0.9999\n 0.9999501061035608\n 1.0 ld = QuadLimbDark([0.4, 0.26]) # max two terms\nld.(b, r)\n\n# output\n3-element Vector{Float64}:\n 0.9998785437247428\n 0.999974726693709\n 1.0 References See references for  PolynomialLimbDark source"},{"id":254,"pagetitle":"API/Reference","title":"Transits.IntegratedLimbDark","ref":"/Transits/stable/api/#Transits.IntegratedLimbDark","content":" Transits.IntegratedLimbDark  —  Type IntegratedLimbDark(limbdark; N=21, basis=:legendre)\nIntegratedLimbDark(u; kwargs...) Computes the time-averaged flux in the middle of an exposure by wrapping a limb darkening law  limbdark  with a quadrature scheme. For each time step  t ,  N  extra points are  super-sampled  from  t-texp/2  to  t+texp/2 and the time-averaged flux is calculated via quadrature. If a set of limb darkening coefficients,  u , is provided, a  PolynomialLimbDark  law will be used by default. Mathematical form \\[\\bar{F}(t) = \\frac{1}{\\Delta t}\\int_{t-\\Delta t / 2}^{t+\\Delta t / 2}{F(t')dt'}\\] where  $F$  is the wrapped limb darkening law and  $\\Delta t$  is the exposure time. Quadrature The integration is approximated via  Guassian quadrature \\[\\frac{1}{\\Delta t} \\int{F(t')dt'} \\approx \\frac12\\sum_i^N{w_i * F(\\frac{\\Delta t}{2}\\xi_i + t)}\\] where the weights  w_i  and nodes  ξ_i  are defined by the given quadrature rule. The nodes are defined by evaluating orthogonal polynomials  N  times between -1 and 1. Notice the change of interval required to go from the natural bounds of the orthogonal polynomial basis,  -1, 1 , to the range defined by the exposure time. The following bases are available from  FastGaussQuadrature.jl . In addition, a function can be passed which calculates  nodes, weights = f(N) . :legendre  - Legendre polynomial base on the open  (-1, 1) :radau  - Legendre polynomial base on the semi-open  [-1, 1)  interval :lobatto  - Legendre polynomial base on the closed  [-1, 1]  interval source"},{"id":255,"pagetitle":"API/Reference","title":"Transits.SecondaryLimbDark","ref":"/Transits/stable/api/#Transits.SecondaryLimbDark","content":" Transits.SecondaryLimbDark  —  Type SecondaryLimbDark(primary::AbstractLimbDark,\n                  secondary::AbstractLimbDark; \n                  brightness_ratio=1)\nSecondaryLimbDark(u_p::AbstractVector, u_s=u_p; kwargs...) Compose two limb darkening laws together to add a secondary eclipse. If vectors of coefficients are provided, laws will automatically be constructed using  PolynomialLimbDark . The surface brightness ratio is given in terms of the host; e.g., if the companion is half as bright as the host, the ratio would be 0.5. Interface SecondaryLimbDark  only works with an orbit, since the companion's reference frame needs to be calculated. This means you can't call it using an impact parameter like  ld(b, r)  directly. Mathematical form \\[f(t, r) = \\frac{2f_p(t, r) + \\eta r^2 f_s(t', r')}{1 + f_p(t, r) + \\eta r^2 f_s(t', r')}\\] where  $f_p$  is to the primary flux,  $f_s$  is to the secondary flux, and  $\\eta$  is the surface brightness ratio.  $t'$  and  $r'$  correspond to the time and radius ratio from the companion's reference frame. Examples using Orbits\n# equal size and limb darkening\nr = 1.0\nu = [0.4, 0.26]\n# companion is 1/10 as bright\nbrightness_ratio = 0.1\nld = SecondaryLimbDark(u; brightness_ratio)\norbit = SimpleOrbit(period=2, duration=0.5)\nfp = ld(orbit, 0, r) # primary egress\nfs = ld(orbit, 1, r) # secondary egress\n\nfp ≈ brightness_ratio * fs\n\n# output\ntrue source"},{"id":256,"pagetitle":"API/Reference","title":"Transits.compute","ref":"/Transits/stable/api/#Transits.compute","content":" Transits.compute  —  Function compute(::AbstractLimbDark, b, r; kwargs...) Compute the relative flux for the given impact parameter  b  and radius ratio  r . The impact parameter is unitless. The radius ratio is given in terms of the host; e.g., if the companion is half the size of the host, r=0.5. source"},{"id":257,"pagetitle":"API/Reference","title":"Transits.compute","ref":"/Transits/stable/api/#Transits.compute-Tuple{AbstractLimbDark, Orbits.AbstractOrbit, Any, Any}","content":" Transits.compute  —  Method compute(::AbstractLimbDark, orbit::AbstractOrbit, t, r) Compute the relative flux by calculating the impact parameter at time  t  from the given orbit. The time needs to be compatible with the period of the orbit, nominally in days. Examples julia> using Orbits\n\njulia> ld = PolynomialLimbDark([0.4, 0.26]);\n\njulia> orbit = SimpleOrbit(period=3, duration=1);\n\njulia> ld(orbit, 0, 0.1) # primary egress\n0.9878664434953113\n\njulia> ld(orbit, 0.1, 0.1) # 0.1 d\n0.9879670695533511 this works effortlessly with libraries like  Unitful.jl julia> using Unitful\n\njulia> orbit = SimpleOrbit(period=3u\"d\", duration=3u\"hr\");\n\njulia> ld(orbit, 0u\"d\", 0.1)\n0.9878664434953113 source"},{"id":258,"pagetitle":"API/Reference","title":"Gradients","ref":"/Transits/stable/api/#Gradients","content":" Gradients Gradients and jacobians are integrated directly into  ChainRules.jl  via  frule s and  rrule s.  For most users, this just means using AD libraries like  ForwardDiff.jl  and  Zygote.jl  is effortless and fast . using Transits\nusing Zygote\n\nlightcurve(X) = compute(PolynomialLimbDark(X[3:end]), X[1], X[2])\ngrad(X) = lightcurve'(X) # Zygote gradient\ngrad([0.1, 0.1, 0.4, 0.26])\n\n# output\n4-element Vector{Float64}:\n  0.0004972185834858653\n -0.2419262730830416\n -0.0048107583897073185\n -0.0024501564976671724 To help demonstrate the logic behind these chain rules, here we derive a simple gradient function manually. using ChainRulesCore\n\nu_n = [0.4, 0.26]\nμ = 0.1\nror = 0.1\nX0 = [μ, ror, u_n...]\n\nfunction gradr(X)\n    ld, ld_pullback = rrule(PolynomialLimbDark, X[3:end])\n    f, f_pullback = rrule(compute, ld, X[1], X[2])\n\n    f̄ = one(eltype(X))\n    _, l̄d, b̄, r̄ = f_pullback(f̄)\n    _, ū_n = ld_pullback(l̄d)\n    return [b̄, r̄, ū_n...]\nend\n\ngradr([0.1, 0.1, 0.4, 0.26])\n\n# output\n4-element Vector{Float64}:\n  0.0004972185834858653\n -0.2419262730830416\n -0.0048107583897073185\n -0.0024501564976671724 For the most granular support for gradients and jacobians, peer into the depths of  polynomial/poly-grad.jl  and  polynomial/quad-grad.jl . These functions are not part of the public API and are not guaranteed any stability according to  semantic versioning ."},{"id":259,"pagetitle":"API/Reference","title":"Distributions","ref":"/Transits/stable/api/#Distributions","content":" Distributions"},{"id":260,"pagetitle":"API/Reference","title":"Transits.Kipping13","ref":"/Transits/stable/api/#Transits.Kipping13","content":" Transits.Kipping13  —  Type Kipping13() A non-informative prior for two-parameter limb-darkening coefficients using  triangular sampling  ( Kipping 2013 ). Examples julia> using StableRNGs; rng = StableRNG(10);\n\njulia> rand(rng, Kipping13())\n2-element Vector{Float64}:\n  0.3361047299132651\n -0.025681638815114587\n\njulia> rand(rng, Kipping13(), 5)\n2×5 Matrix{Float64}:\n 0.0621057   0.992689   1.77965    0.784055  0.186386\n 0.0659477  -0.236613  -0.795884  -0.187791  0.592194 References Kipping (2013) \"Efficient, uninformative sampling of limb darkening coefficients for two-parameter laws\" source"},{"id":263,"pagetitle":"Benchmarks","title":"Benchmarks","ref":"/Transits/stable/bench/#Benchmarks","content":" Benchmarks Transits.jl aims to be at least as fast as similar tools.  Limbdark.jl  is also written in Julia and  Agol  et al.  (2020)  showed it outperforms starry, PyTransit, and batman in both runtime speed and numerical accuracy. The following benchmarks are works in progress, but they already show a marginal improvement on the Limbdark.jl implementation."},{"id":264,"pagetitle":"Benchmarks","title":"Setup","ref":"/Transits/stable/bench/#Setup","content":" Setup Warning These benchmarks are works in progress The code can be found in  bench/ . You'll need to set up the environment yourself, including the installation of Limbdark.jl."},{"id":265,"pagetitle":"Benchmarks","title":"Performance","ref":"/Transits/stable/bench/#Performance","content":" Performance"},{"id":266,"pagetitle":"Benchmarks","title":"Comparison with Limbdark.jl","ref":"/Transits/stable/bench/#Comparison-with-Limbdark.jl","content":" Comparison with Limbdark.jl"},{"id":267,"pagetitle":"Benchmarks","title":"References","ref":"/Transits/stable/bench/#References","content":" References Agol, E.; Luger, R. and Foreman-Mackey, D. (2020).  Analytic Planetary Transit Light Curves and Derivatives for Stars with Polynomial Limb Darkening .  The Astronomical Journal  159 , 123 ,  arXiv:1908.03222 [astro-ph.EP] ."},{"id":270,"pagetitle":"Getting Started","title":"Getting Started","ref":"/Transits/stable/gettingstarted/#Getting-Started","content":" Getting Started"},{"id":271,"pagetitle":"Getting Started","title":"Usage","ref":"/Transits/stable/gettingstarted/#Usage","content":" Usage using Orbits\nusing Transits\n\norbit = SimpleOrbit(period=3, duration=1)\nu = [0.4, 0.26] # quad limb dark\nld = PolynomialLimbDark(u)\n\nt = range(-1, 1, length=1000) # days from t0\nrs = range(0, 0.2, length=10) # radius ratio\n\nfluxes = @. ld(orbit, t, rs')"},{"id":272,"pagetitle":"Getting Started","title":"Integrated and Secondary Curves","ref":"/Transits/stable/gettingstarted/#Integrated-and-Secondary-Curves","content":" Integrated and Secondary Curves IntegratedLimbDark  can be used to numerically integrate each light curve exposure in time ld = IntegratedLimbDark([0.4, 0.26])\norbit = SimpleOrbit(period=3, duration=1)\nt = range(-1, 1, length=1000)\ntexp = [0.1 0.2 0.3]\n# no extra calculations made\nflux = @. ld(orbit, t, 0.2)\n# use quadrature to find time-averaged flux for each t\nflux_int = @. ld(orbit, t, 0.2, texp) SecondaryLimbDark  can be used to generate secondary eclipses given a surface brightness ratio ld = SecondaryLimbDark([0.4, 0.26], brightness_ratio=0.1)\nld_int = IntegratedLimbDark(ld) # composition works flawlessly\n\norbit = SimpleOrbit(period=4, duration=1)\nt = range(-1.25, 2.75, length=1000)\nrs = range(0.01, 0.1, length=6)\n\nf = @. ld(orbit, t, rs')\nf_int = @. ld_int(orbit, t, rs', texp=0.3)"},{"id":273,"pagetitle":"Getting Started","title":"Using Units","ref":"/Transits/stable/gettingstarted/#Using-Units","content":" Using Units Units from  Unitful.jl  are a drop-in substitution for numbers using Unitful\norbit = SimpleOrbit(period=10u\"d\", duration=5u\"hr\")\nt = range(-6, 6, length=1000)u\"hr\"\nflux = @. ld(orbit, t, 0.1)"},{"id":274,"pagetitle":"Getting Started","title":"Gradients","ref":"/Transits/stable/gettingstarted/#Gradients","content":" Gradients Gradients are provided in the form of  chain rules . The easiest way to access them is using an automatic differentiation (AD) library like  ForwardDiff.jl  or  Zygote.jl . using Zygote\n\nts = range(-1, 1, length=1000) # days from t0\nror = 0.1\nu_n = [0.4, 0.26]\n\norbit = SimpleOrbit(period=3, duration=1)\nlightcurve(X) = compute(PolynomialLimbDark(X[3:end]), orbit, X[1], X[2])\n\n# use Zygote for gradient\nflux = [lightcurve([t, ror, u_n...]) for t in ts]\ngrads = mapreduce(hcat, ts) do t\n    grad = lightcurve'([t, ror, u_n...])\n    return grad === nothing ? zeros(4) : grad\nend"},{"id":277,"pagetitle":"Introduction","title":"Introduction","ref":"/Transits/stable/introduction/#Introduction","content":" Introduction"},{"id":278,"pagetitle":"Introduction","title":"Historical overview","ref":"/Transits/stable/introduction/#Historical-overview","content":" Historical overview Transit light curves are an essential tool used for the detection of  exoplanets . To date, there have been over 4,300 confirmed planets discovered in over 3,400 different star systems, with an additional 2,400 candidates currently awaiting follow-up analysis and validation. [1]  Since the first confirmed discovery of an exoplanet – as part of a multi-planetary system in 1992 ( Wolszczan and Frail, 1992 ), and the first exoplanet discovered around a Sun-like star shortly after in 1995 ( Mayor and Queloz, 1995 ) – there has been an explosion in new discoveries, thanks in large part to the successful  Kepler/K2  and  TESS  space missions. The large majority of these planets have been detected via the  transit method : Exoplanet Archive"},{"id":279,"pagetitle":"Introduction","title":"Transit method","ref":"/Transits/stable/introduction/#Transit-method","content":" Transit method This method works by observing the dimming in apparent brightness of a star as a planet passes in front of it from our point of view. The plot of the star's brightness as a function of time defines the  white light curve  as seen in the schematic below: \"How Do You Find an Exoplanet?\" by John Asher Johnson Even just starting with a simple single planet system in a circular orbit, there is already a wealth of information encoded in this diagram. These observations give us insight not only into the bulk properties of the planet, but into the architecture of its orbital system and characteristics of its host star as well. For example,  direct observables  from the light curve like the  transit duration $(T)$  and  ingress/egress  time  $(\\tau)$  give us information about how tilted its orbit is and how fast the planet is traveling, while the  transit depth $(\\delta)$  gives us a direct measure of the size of the planet relative to its star. For circular orbits, these are nicely summarized by: \\[\\begin{aligned}\n\\frac{R_\\text{p}}{R_*} &= \\delta^{1/2} \\\\\n\nb^2 &= 1 - \\delta^{1/2}\\frac{T}{t} \\\\\n\n\\frac{a}{R_*} &= \\frac{P\\delta^{1/4}}{2\\pi}\n\\left(\\frac{4}{T\\tau}\\right)^{1/2} \\\\\n\n\\rho_* &= \\frac{3P}{G\\pi^2}\\left(\\frac{\\delta^{1/4}}{\\sqrt{T\\tau}}\\right)^3 \\quad,\n\\end{aligned}\\] where  $P$  is the period of the planet's orbit and  $a$  its semi-major axis,  $b$  is the impact parameter,  $R_*$  is the radius of its star, and  $\\rho_*$  is the stellar density."},{"id":280,"pagetitle":"Introduction","title":"Limb darkening","ref":"/Transits/stable/introduction/#Limb-darkening","content":" Limb darkening Not shown above is an added dimension that  Transits.jl  excels in,  limb darkening , demonstrated in the schematic below: ASTR 236 class notes This effect is intimately related to the shape of the light curve, and allows us to constrain the brightness profile of the star itself. As we will see next, the method of transit light curves is not just useful for the detection of exoplanets, but also for taking it to the next step of characterizing its atmosphere."},{"id":281,"pagetitle":"Introduction","title":"Transmission spectroscopy","ref":"/Transits/stable/introduction/#Transmission-spectroscopy","content":" Transmission spectroscopy If we perform the technique of transit light curve modeling on a wavelength-by-wavelength basis, we can further probe the properties of the host star and begin to make predictions about the properties of the planet's atmosphere, such as its chemical composition and whether clouds/hazes are likely to be present at higher altitudes. This analysis begins in the same way as with the white light curve seen above, only now a  wavelength binned light curve  is measured at a range of different wavelengths:  Adapted from Weaver et al. (2021,  submitted ) Plotting these wavelength dependent transit depths then builds a  transmission spectrum , which is filled with information about the planet's atmosphere and its star, summarized below: Benneke and Seager (2012) Rackham  et al.  (2018) Performing forward modeling (see, e.g.,  Kempton  et al.  (2017) ,  Goyal  et al.  (2018) ) and retrievals (see, e.g.,  Barstow  et al.  (2020)  and references therein) using these frameworks then allows us to explore exoplanetary atmospheres in never before seen detail."},{"id":282,"pagetitle":"Introduction","title":"Summary","ref":"/Transits/stable/introduction/#Summary","content":" Summary The detection and characterization of exoplanets through their transit light curves is a relatively new technique in the field of astronomy, with recent advances only being made possible through novel uses of large, ground-based telescopes and soon in the future with planned  ELTs  and space based missions like  JWST . Studies using these observing facilities will require the fast and precise computation of transit light curves, which  Transits.jl  aims to provide."},{"id":283,"pagetitle":"Introduction","title":"Footnotes and references","ref":"/Transits/stable/introduction/#Footnotes-and-references","content":" Footnotes and references Barstow, J. K.; Changeat, Q.; Garland, R.; Line, M. R.; Rocchetto, M. and Waldmann, I. P. (2020).  A comparison of exoplanet spectroscopic retrieval tools .  Monthly Notices of the Royal Astronomical Society  493 , 4884–4909 ,  arXiv:2002.01063 [astro-ph.EP] . Benneke, B. and Seager, S. (2012).  Atmospheric Retrieval for Super-Earths: Uniquely Constraining the Atmospheric Composition with Transmission Spectroscopy .  The Astrophysical Journal  753 , 100 ,  arXiv:1203.4018 [astro-ph.EP] . Goyal, J. M.; Mayne, N.; Sing, D. K.; Drummond, B.; Tremblin, P.; Amundsen, D. S.; Evans, T.; Carter, A. L.; Spake, J.; Baraffe, I.; Nikolov, N.; Manners, J.; Chabrier, G. and Hebrard, E. (2018).  A library of ATMO forward model transmission spectra for hot Jupiter exoplanets .  Monthly Notices of the Royal Astronomical Society  474 , 5158–5185 ,  arXiv:1710.10269 [astro-ph.EP] . Johnson, J. (2015).  How Do You Find an Exoplanet? Princeton Frontiers in Physics  (Princeton University Press). Kempton, E. M.-R.; Lupu, R.; Owusu-Asare, A.; Slough, P. and Cale, B. (2017).  Exo-Transmit: An Open-Source Code for Calculating Transmission Spectra for Exoplanet Atmospheres of Varied Composition .  Publications of the Astronomical Society of the Pacific  129 , 044402 ,  arXiv:1611.03871 [astro-ph.EP] . Mayor, M. and Queloz, D. (1995).  A Jupiter-mass companion to a solar-type star .  Nature  378 , 355–359 . Rackham, B. V.; Apai, D. and Giampapa, M. S. (2018).  The Transit Light Source Effect: False Spectral Features and Incorrect Densities for M-dwarf Transiting Planets .  The Astrophysical Journal  853 , 122 ,  arXiv:1711.05691 [astro-ph.EP] . Wolszczan, A. and Frail, D. (1992).  A planetary system around the millisecond pulsar PSR1257 + 12 .  Nature  355 , 145–147 . 1 https://exoplanetarchive.ipac.caltech.edu/"},{"id":286,"pagetitle":"Home","title":"Cosmology.jl","ref":"/Cosmology/stable/#Cosmology.jl","content":" Cosmology.jl Cosmology.jl  provides functions for quick cosmological calculations, written in pure Julia."},{"id":287,"pagetitle":"Home","title":"Installation","ref":"/Cosmology/stable/#Installation","content":" Installation To install the package, enter  pkg  mode ( ] ) pkg> add Cosmology Then, to load the package julia> using Cosmology"},{"id":288,"pagetitle":"Home","title":"Contributing","ref":"/Cosmology/stable/#Contributing","content":" Contributing If you would like to contribute to  Cosmology.jl , head over to our  GitHub page  and open an issue or pull request! For any new features, we ask the contributors to add any relevant unit tests and bump the package version by one minor version."},{"id":291,"pagetitle":"API/Reference","title":"API/Reference","ref":"/Cosmology/stable/api/#API/Reference","content":" API/Reference Unitful Unitful.jl  works seamlessly with Cosmology.jl. In order to use its features, make sure it is installed and imported, along with  UnitfulAstro . pkg> add Unitful UnitfulAstro\njulia> using Unitful, UnitfulAstro"},{"id":292,"pagetitle":"API/Reference","title":"Cosmological Models","ref":"/Cosmology/stable/api/#Cosmological-Models","content":" Cosmological Models"},{"id":293,"pagetitle":"API/Reference","title":"Cosmology.cosmology","ref":"/Cosmology/stable/api/#Cosmology.cosmology","content":" Cosmology.cosmology  —  Function cosmology(; h = 0.69,\n            Neff = 3.04,\n            OmegaK = 0,\n            OmegaM = 0.29,\n            OmegaR = nothing,\n            Tcmb = 2.7255,\n            w0 = -1,\n            wa = 0) Parameters h  - Dimensionless Hubble constant Neff  - Effective number of massless neutrino species; used to compute Ω_ν OmegaK  - Curvature density (Ω_k) OmegaM  - Matter density (Ω_m) OmegaR  - Radiation density (Ω_r) Tcmb  - CMB temperature in Kelvin; used to compute Ω_γ w0  - CPL dark energy equation of state;  w = w0 + wa(1-a) wa  - CPL dark energy equation of state;  w = w0 + wa(1-a) Examples julia> c = cosmology()\nCosmology.FlatLCDM{Float64}(0.69, 0.7099122024007928, 0.29, 8.77975992071536e-5)\n\njulia> c = cosmology(OmegaK=0.1)\nCosmology.OpenLCDM{Float64}(0.69, 0.1, 0.6099122024007929, 0.29, 8.77975992071536e-5)\n\njulia> c = cosmology(w0=-0.9, OmegaK=-0.1)\nCosmology.ClosedWCDM{Float64}(0.69, -0.1, 0.8099122024007929, 0.29, 8.77975992071536e-5, -0.9, 0.0) source"},{"id":294,"pagetitle":"API/Reference","title":"Distances","ref":"/Cosmology/stable/api/#Distances","content":" Distances"},{"id":295,"pagetitle":"API/Reference","title":"Cosmology.angular_diameter_dist","ref":"/Cosmology/stable/api/#Cosmology.angular_diameter_dist","content":" Cosmology.angular_diameter_dist  —  Function angular_diameter_dist([u::Unitlike,] c::AbstractCosmology, [z₁,] z₂) Ratio of the proper transverse size in Mpc of an object at redshift  z₂  to its angular size in radians, as seen by an observer at  z₁ .  Redshift  z₁  defaults to 0 if omitted.  Will convert to compatible unit  u  if provided. source"},{"id":296,"pagetitle":"API/Reference","title":"Cosmology.comoving_radial_dist","ref":"/Cosmology/stable/api/#Cosmology.comoving_radial_dist","content":" Cosmology.comoving_radial_dist  —  Function comoving_radial_dist([u::Unitlike,] c::AbstractCosmology, [z₁,] z₂) Comoving radial distance ( $D_C$ ) in Mpc at redshift  z₂  as seen by an observer at  z₁ . Redshift  z₁  defaults to 0 if omitted.  Will convert to compatible unit  u  if provided. It's calculated as  $D_C = D_{H0} Z$ , where  $D_{H0}$  is the Hubble distance at the present epoch and,  $Z = \\int_{z_1}^{z_2} \\frac{dz}{E(z)}$ . source"},{"id":297,"pagetitle":"API/Reference","title":"Cosmology.luminosity_dist","ref":"/Cosmology/stable/api/#Cosmology.luminosity_dist","content":" Cosmology.luminosity_dist  —  Function luminosity_dist([u::Unitlike,] c::AbstractCosmology, z) Bolometric luminosity distance in Mpc at redshift  z . Will convert to compatible unit  u  if provided. source"},{"id":298,"pagetitle":"API/Reference","title":"Cosmology.distmod","ref":"/Cosmology/stable/api/#Cosmology.distmod","content":" Cosmology.distmod  —  Function distmod(c::AbstractCosmology, z) Distance modulus in magnitudes at redshift  z . source"},{"id":299,"pagetitle":"API/Reference","title":"Cosmology.hubble_dist","ref":"/Cosmology/stable/api/#Cosmology.hubble_dist","content":" Cosmology.hubble_dist  —  Function hubble_dist(c::AbstractCosmology, z) Hubble distance  $D_H$ , defined as the product of the speed of light and the Hubble time. That is,  $D_H(z) = c / H(z)$ . See also hubble_time source"},{"id":300,"pagetitle":"API/Reference","title":"Examples","ref":"/Cosmology/stable/api/#Examples","content":" Examples julia> c = cosmology(OmegaM=0.26)\nCosmology.FlatLCDM{Float64}(0.69, 0.7399122024007928, 0.26, 8.77975992071536e-5)\n\njulia> angular_diameter_dist(c, 1.2)\n1784.0089227105113 Mpc\n\njulia> angular_diameter_dist(c, 0.7, 1.2)\n606.6521737365097 Mpc\n\njulia> luminosity_dist(c, 1.5)\n11420.338287150073 Mpc\n\njulia> luminosity_dist(u\"Gpc\", c, 1.5) # Can convert to appropriate unit\n11.420338287150074 Gpc"},{"id":301,"pagetitle":"API/Reference","title":"Volumes","ref":"/Cosmology/stable/api/#Volumes","content":" Volumes"},{"id":302,"pagetitle":"API/Reference","title":"Cosmology.comoving_volume_element","ref":"/Cosmology/stable/api/#Cosmology.comoving_volume_element","content":" Cosmology.comoving_volume_element  —  Function comoving_volume_element([u::Unitlike,] c::AbstractCosmology, z) Comoving volume element in Gpc out to redshift  z . Will convert to compatible unit  u  if provided. source"},{"id":303,"pagetitle":"API/Reference","title":"Cosmology.comoving_volume","ref":"/Cosmology/stable/api/#Cosmology.comoving_volume","content":" Cosmology.comoving_volume  —  Function comoving_volume([u::Unitlike,] c::AbstractCosmology, z) Comoving volume in cubic Gpc out to redshift  z . Will convert to compatible unit  u  if provided. source"},{"id":304,"pagetitle":"API/Reference","title":"Examples","ref":"/Cosmology/stable/api/#Examples-2","content":" Examples julia> c = cosmology(OmegaM=0.26)\nCosmology.FlatLCDM{Float64}(0.69, 0.7399122024007928, 0.26, 8.77975992071536e-5)\n\njulia> comoving_volume_element(c, 2.1)\n46.74459228888613 Gpc^3\n\njulia> comoving_volume(c, 0.6)\n49.3633436631307 Gpc^3\n\njulia> comoving_volume(u\"ly^3\", c, 0.6)\n1.7127035381753e30 ly^3"},{"id":305,"pagetitle":"API/Reference","title":"Times","ref":"/Cosmology/stable/api/#Times","content":" Times"},{"id":306,"pagetitle":"API/Reference","title":"Cosmology.age","ref":"/Cosmology/stable/api/#Cosmology.age","content":" Cosmology.age  —  Function age([u::Unitlike,] c::AbstractCosmology, z) Age of the universe in Gyr at redshift  z . Will convert to compatible unit  u  if provided. source"},{"id":307,"pagetitle":"API/Reference","title":"Cosmology.lookback_time","ref":"/Cosmology/stable/api/#Cosmology.lookback_time","content":" Cosmology.lookback_time  —  Function lookback_time([u::Unitlike,] c::AbstractCosmology, z) Difference between age at redshift 0 and age at redshift  z  in Gyr. Will convert to compatible unit  u  if provided. source"},{"id":308,"pagetitle":"API/Reference","title":"Cosmology.hubble_time","ref":"/Cosmology/stable/api/#Cosmology.hubble_time","content":" Cosmology.hubble_time  —  Function hubble_time(c::AbstractCosmology, z) Hubble time, defined as the inverse of the Hubble parameter. That is,  $t_H(z) = 1/H(z)$ . See also hubble_dist source"},{"id":309,"pagetitle":"API/Reference","title":"Examples","ref":"/Cosmology/stable/api/#Examples-3","content":" Examples julia> c = cosmology(OmegaM=0.26)\nCosmology.FlatLCDM{Float64}(0.69, 0.7399122024007928, 0.26, 8.77975992071536e-5)\n\njulia> age(c, 1.2)\n5.4454795007229455 Gyr\n\njulia> lookback_time(u\"yr\", c, 1.2)\n8.761465604385489e9 yr"},{"id":310,"pagetitle":"API/Reference","title":"Miscellaneous","ref":"/Cosmology/stable/api/#Miscellaneous","content":" Miscellaneous"},{"id":311,"pagetitle":"API/Reference","title":"Cosmology.H","ref":"/Cosmology/stable/api/#Cosmology.H","content":" Cosmology.H  —  Function H(c::AbstractCosmology, z) Hubble parameter at redshift  z . source"},{"id":312,"pagetitle":"API/Reference","title":"Cosmology.scale_factor","ref":"/Cosmology/stable/api/#Cosmology.scale_factor","content":" Cosmology.scale_factor  —  Function scale_factor(z) Return the scale factor  $a(t)$  for a given redshift  $z(t)$ . According to the  Friedmann–Lemaître–Robertson–Walker metric  it's given as  $a = 1/(1 + z)$  ( Schneider 2015, p. 186 ). A scale factor of 1, i.e., a redshift of 0, refers to the present epoch. source"},{"id":313,"pagetitle":"API/Reference","title":"Bibliography","ref":"/Cosmology/stable/api/#Bibliography","content":" Bibliography Schneider, P. (2015).  Extragalactic Astronomy and Cosmology: An Introduction . 2nd Edition (Springer, Berlin, Heidelberg)."},{"id":316,"pagetitle":"Internals","title":"Internals","ref":"/Cosmology/stable/internals/#Internals","content":" Internals The following types and methods are internal, and should not be considered safe for public use."},{"id":317,"pagetitle":"Internals","title":"Types","ref":"/Cosmology/stable/internals/#Types","content":" Types"},{"id":318,"pagetitle":"Internals","title":"Cosmology.AbstractCosmology","ref":"/Cosmology/stable/internals/#Cosmology.AbstractCosmology","content":" Cosmology.AbstractCosmology  —  Type abstract type AbstractCosmology Abstract supertype for all cosmological models. source"},{"id":319,"pagetitle":"Internals","title":"Cosmology.FlatLCDM","ref":"/Cosmology/stable/internals/#Cosmology.FlatLCDM","content":" Cosmology.FlatLCDM  —  Type struct FlatLCDM{T<:Real} <: Cosmology.AbstractFlatCosmology ΛCDM model of the universe with  $Ω_k = 0$ . source"},{"id":320,"pagetitle":"Internals","title":"Cosmology.ClosedLCDM","ref":"/Cosmology/stable/internals/#Cosmology.ClosedLCDM","content":" Cosmology.ClosedLCDM  —  Type struct ClosedLCDM{T<:Real} <: Cosmology.AbstractClosedCosmology ΛCDM model of the universe with  $Ω_k < 0$ . source"},{"id":321,"pagetitle":"Internals","title":"Cosmology.OpenLCDM","ref":"/Cosmology/stable/internals/#Cosmology.OpenLCDM","content":" Cosmology.OpenLCDM  —  Type struct OpenLCDM{T<:Real} <: Cosmology.AbstractOpenCosmology ΛCDM model of the universe with  $Ω_k > 0$ . source"},{"id":322,"pagetitle":"Internals","title":"Methods","ref":"/Cosmology/stable/internals/#Methods","content":" Methods"},{"id":323,"pagetitle":"Internals","title":"Cosmology.E","ref":"/Cosmology/stable/internals/#Cosmology.E","content":" Cosmology.E  —  Function E(c::AbstractCosmology, z) Dimensionless Hubble function  $E(z)$  at redshift  z . It's defined as \\[E(z) ≡ \\frac{H(z)}{H_0} = \\frac{H(z)}{(100\\mathrm{km/s/Mpc}) h}\\] where  $H_0 = H(z=0)$  is the Hubble parameter at the present epoch ( Schneider 2015, p. 183 ). source"},{"id":324,"pagetitle":"Internals","title":"Cosmology.Z","ref":"/Cosmology/stable/internals/#Cosmology.Z","content":" Cosmology.Z  —  Function Z(c::AbstractCosmology, z, nothing; kws...)\nZ(c::AbstractCosmology, z₁, z₂; kws...) The line-of-sight comoving distance contributions for comoving radial distance. It performs the integral \\[Z = \\int_{z_1}^{z_2} \\frac{dz}{E(z)} = \\int_{a_2}^{a_1} \\frac{da}{a^2 E(a)}\\] where we can perform a change of variables with  $a = 1/(1+z)$ , and  $dz = -da/a^2$ . If  nothing  is used for the second bound of integration, it defaults to  z₁ = 0  (i.e.,  a₁ = 1 ). See also comoving_radial_dist source"},{"id":325,"pagetitle":"Internals","title":"Cosmology.a2E","ref":"/Cosmology/stable/internals/#Cosmology.a2E","content":" Cosmology.a2E  —  Function a2E(c::Union{FlatLCDM,ClosedLCDM,OpenLCDM}, a) Calculates the intermediate quantity  $a^2 E(a)$ . This is an internal function used to simplify computation. Mathematical definition (for ΛCDM models): \\[a^2 E(a) = \\sqrt{Ω_r + Ω_m a + Ω_k a^2 + Ω_Λ a^4}\\] where  $Ω_k = 0$  for a flat cosmological model. source"},{"id":326,"pagetitle":"Internals","title":"Cosmology.a2E","ref":"/Cosmology/stable/internals/#Cosmology.a2E-Tuple{Union{Cosmology.ClosedWCDM, Cosmology.FlatWCDM, Cosmology.OpenWCDM}, Any}","content":" Cosmology.a2E  —  Method a2E(c::Union{FlatWCDM,ClosedWCDM,OpenWCDM}, a) The implementation of  $a^2 E(a)$  for WCDM models. Mathematical definition (for WCDM models): \\[a^2 E(a) = \\sqrt{Ω_r + Ω_m a + Ω_k a^2 + Ω_Λ a_{de}}\\] where  $a_{de} = \\exp[(1 - 3 w_0 - 3 w_a) \\log(a) + 3 w_a (a - 1)]$ . source"},{"id":327,"pagetitle":"Internals","title":"Cosmology.hubble_dist0","ref":"/Cosmology/stable/internals/#Cosmology.hubble_dist0","content":" Cosmology.hubble_dist0  —  Function hubble_dist0(c::AbstractCosmology) Hubble distance at redshift 0. See also hubble_dist source"},{"id":328,"pagetitle":"Internals","title":"Cosmology.hubble_time0","ref":"/Cosmology/stable/internals/#Cosmology.hubble_time0","content":" Cosmology.hubble_time0  —  Function hubble_time0(c::AbstractCosmology) Hubble time at redshift 0. See also hubble_time source"},{"id":331,"pagetitle":"Home","title":"DustExtinction.jl","ref":"/DustExtinction/stable/#DustExtinction.jl","content":" DustExtinction.jl This package implements different empirical dust measurements for use in astronomy. This package is written in pure Julia and is built with first-class support with  Unitful.jl  and  Measurements.jl ."},{"id":332,"pagetitle":"Home","title":"About","ref":"/DustExtinction/stable/#About","content":" About Extinction describes the effect of dust grains on observations of stars in space. Light that travels through dust is absorbed and scatterred as natural processes of light's interactions with materials. This obfuscation can be modeled and removed from our data in order to more properly retrieve the star's flux. When dealing with multiple stars, or large clusters or galaxies, this process is considered dust attenuation and is not provided for in this package."},{"id":333,"pagetitle":"Home","title":"Installation","ref":"/DustExtinction/stable/#Installation","content":" Installation From the REPL, press  ]  to enter Pkg mode pkg> add DustExtinction\n\njulia> using DustExtinction"},{"id":334,"pagetitle":"Home","title":"Usage","ref":"/DustExtinction/stable/#Usage","content":" Usage julia> using DustExtinction\n\njulia> CCM89(Rv=3.1)(4000)\n1.464555702942584 For more examples, view the  Color Laws  and  Dust Maps  sections."},{"id":335,"pagetitle":"Home","title":"Citations","ref":"/DustExtinction/stable/#Citations","content":" Citations There are various citations relevant to this work. Please be considerate when using this work or any derivate of it by adding the appropriate citations. Law Reference BibTeX CCM89 Clayton, Cardelli and Mathis (1989) download OD94 O'Donnell (1994) download CAL00 Calzetti et al. (2000) download VCG04 Valencic, Clayton, & Gordon (2004) download GCC09 Gordon, Cartledge, & Clayton (2009) download FM90 Fitzpatrick & Massa (1990) download G16 Gordon et al (2016)  download SFD98Map Schlegel, Finkbeiner and Davis (1998) download F99 Fitzpatrick (1999) download F04 Fitzpatrick (2004) download F19 Fitzpatrick (2019) download M14 Maiz Apellaniz et al. (2014) download"},{"id":336,"pagetitle":"Home","title":"Index","ref":"/DustExtinction/stable/#Index","content":" Index DustExtinction.bounds DustExtinction.checkbounds DustExtinction.deredden DustExtinction.redden DustExtinction.CAL00 DustExtinction.CCM89 DustExtinction.ExtinctionLaw DustExtinction.F04 DustExtinction.F19 DustExtinction.F99 DustExtinction.FM90 DustExtinction.G03_LMCAve DustExtinction.G03_SMCBar DustExtinction.G16 DustExtinction.GCC09 DustExtinction.M14 DustExtinction.OD94 DustExtinction.SFD98Map DustExtinction.VCG04"},{"id":337,"pagetitle":"Home","title":"Contributing","ref":"/DustExtinction/stable/#Contributing","content":" Contributing If you are interested in contributing, feel free to make a pull request or open an issue for discussion."},{"id":340,"pagetitle":"Color Laws","title":"Color laws","ref":"/DustExtinction/stable/color_laws/#laws","content":" Color laws The following empirical laws allow us to model the reddening of light as it travels to us. The law you use should depend on the type of data you have and the goal of its use.  CCM89  is very common for use in removing extinction from stellar observations, but  CAL00 , for instance, is suited for galaxies with massive stars. Look through the citations and documentation for each law to get a better idea of what sort of physics it targets."},{"id":341,"pagetitle":"Color Laws","title":"Usage","ref":"/DustExtinction/stable/color_laws/#Usage","content":" Usage Color laws are constructed and then used as a function for passing wavelengths. Wavelengths are assumed to be in units of angstroms. julia> CCM89(Rv=3.1)(4000)\n1.464555702942584 These laws can be applied across higher dimension arrays using the  .  operator julia> CCM89(Rv=3.1).([4000, 5000])\n2-element Vector{Float64}:\n 1.464555702942584\n 1.1222468788993019 these laws return magnitudes, which we can apply directly to flux by mulitplication with a base-2.5 logarithmic system (because astronomers are fun): \\[f = f \\cdot 10 ^ {-0.4A_v\\cdot mag}\\] To make this easier, we provide a convenience  redden  and  deredden  functions for applying these color laws to flux measurements. julia> wave = range(4000, 5000, length=4)\n4000.0:333.3333333333333:5000.0\n\njulia> flux = 1e-8 .* wave .+ 1e-2\n0.01004:3.3333333333333333e-6:0.01005\n\njulia> redden.(CCM89, wave, flux; Av=0.3)\n4-element Vector{Float64}:\n 0.00669864601545475\n 0.006918253926353551\n 0.007154659823737299\n 0.007370491272731541\n\njulia> deredden.(CCM89(Rv=3.1), wave, ans; Av=0.3) ≈ flux\ntrue\n"},{"id":342,"pagetitle":"Color Laws","title":"Advanced Usage","ref":"/DustExtinction/stable/color_laws/#color_laws_advanced_usage","content":" Advanced Usage The color laws also have built-in support for uncertainties using  Measurements.jl . julia> using Measurements\n\njulia> CCM89(Rv=3.1).([4000. ± 10.5, 5000. ± 10.2])\n2-element Vector{Measurement{Float64}}:\n 1.4646 ± 0.0033\n 1.1222 ± 0.003\n and also support units via  Unitful.jl  and its subsidiaries. Notice how the output type is now  Unitful.Gain . julia> using Unitful, UnitfulAstro\n\njulia> mags = CCM89(Rv=3.1).([4000u\"angstrom\", 0.5u\"μm\"])\n2-element Vector{Gain{Unitful.LogInfo{:Magnitude, 10, -2.5}, :?, Float64}}:\n 1.464555702942584 mag\n 1.1222468788993019 mag\n You can even combine the two above to get some really nice workflows exploiting all Julia has to offer! This example shows how you could redden some OIR observational data with uncertainties in the flux density. julia> using Measurements, Unitful, UnitfulAstro\n\njulia> wave = range(0.3, 1.0, length=5)u\"μm\"\n(0.3:0.175:1.0) μm\n\njulia> err = randn(length(wave))\n5-element Vector{Float64}:\n -0.07058313895389791\n  0.5314767537831963\n -0.806852326006714\n  2.456991333983293\n  1.1648740735275196\n\njulia> flux = @.(300 / ustrip(wave)^4 ± err)*u\"Jy\"\n5-element Vector{Quantity{Measurement{Float64}, 𝐌 𝐓^-2, Unitful.FreeUnits{(Jy,), 𝐌 𝐓^-2, nothing}}}:\n 37037.037 ± -0.071 Jy\n   5893.14 ± 0.53 Jy\n   1680.61 ± -0.81 Jy\n     647.6 ± 2.5 Jy\n     300.0 ± 1.2 Jy\n\njulia> redden.(CCM89, wave, flux; Av=0.3)\n5-element Vector{Quantity{Measurement{Float64}, 𝐌 𝐓^-2, Unitful.FreeUnits{(Jy,), 𝐌 𝐓^-2, nothing}}}:\n 22410.804 ± 0.043 Jy\n   4229.74 ± 0.38 Jy\n   1337.12 ± 0.64 Jy\n     554.3 ± 2.1 Jy\n     268.3 ± 1.0 Jy\n"},{"id":343,"pagetitle":"Color Laws","title":"Parametric Extinction Laws","ref":"/DustExtinction/stable/color_laws/#Parametric-Extinction-Laws","content":" Parametric Extinction Laws These laws are all parametrized by the selective extinction  Rv . Mathematically, this is the ratio of the total extinction by the reddening \\[R_V = \\frac{A_V}{E(B-V)}\\] and is loosely associated with the size of the dust grains in the interstellar medium. Index: CCM89 OD94 CAL00 VCG04 GCC09 F99 F04 F19"},{"id":344,"pagetitle":"Color Laws","title":"Clayton, Cardelli and Mathis (1989)","ref":"/DustExtinction/stable/color_laws/#Clayton,-Cardelli-and-Mathis-(1989)","content":" Clayton, Cardelli and Mathis (1989)"},{"id":345,"pagetitle":"Color Laws","title":"DustExtinction.CCM89","ref":"/DustExtinction/stable/color_laws/#DustExtinction.CCM89","content":" DustExtinction.CCM89  —  Type CCM89(;Rv=3.1) Clayton, Cardelli and Mathis (1989) dust law. Returns A(λ)/A(V) at the given wavelength relative to the extinction at 5494.5 Å. The default support is [1000, 33333]. Outside of that range this will return 0.  Rv  is the selective extinction and is valid over [2, 6]. A typical value for the Milky Way is 3.1. References Clayton,Cardelli and Mathis (1989) source"},{"id":346,"pagetitle":"Color Laws","title":"O'Donnell 1994","ref":"/DustExtinction/stable/color_laws/#O'Donnell-1994","content":" O'Donnell 1994"},{"id":347,"pagetitle":"Color Laws","title":"DustExtinction.OD94","ref":"/DustExtinction/stable/color_laws/#DustExtinction.OD94","content":" DustExtinction.OD94  —  Type OD94(;Rv=3.1) O'Donnell (1994) dust law. This is identical to the Clayton, Cardelli and Mathis (1989) dust law, except for different coefficients used in the optical (3030.3 Å to 9090.9 Å). References O'Donnell (1994) See Also CCM89 source"},{"id":348,"pagetitle":"Color Laws","title":"Calzetti et al. (2000)","ref":"/DustExtinction/stable/color_laws/#Calzetti-et-al.-(2000)","content":" Calzetti et al. (2000)"},{"id":349,"pagetitle":"Color Laws","title":"DustExtinction.CAL00","ref":"/DustExtinction/stable/color_laws/#DustExtinction.CAL00","content":" DustExtinction.CAL00  —  Type CAL00(;Rv=4.05) Calzetti et al. (2000) Dust Law. Returns A(λ)/A(V) at the given wavelength.  λ  is the wavelength in Å and has support over [1200, 22000]. Outside of that range this will return 0. Calzetti et al. (2000) developed a recipe for dereddening the spectra of galaxies where massive stars dominate the radiation output. They found the best fit value for such galaxies was 4.05±0.80. References Calzetti et al. (2000) source"},{"id":350,"pagetitle":"Color Laws","title":"Valencic, Clayton, & Gordon (2004)","ref":"/DustExtinction/stable/color_laws/#Valencic,-Clayton,-and-Gordon-(2004)","content":" Valencic, Clayton, & Gordon (2004)"},{"id":351,"pagetitle":"Color Laws","title":"DustExtinction.VCG04","ref":"/DustExtinction/stable/color_laws/#DustExtinction.VCG04","content":" DustExtinction.VCG04  —  Type VCG04(;Rv=3.1) Valencic, Clayton, & Gordon (2004) dust law. This model applies to the UV spectral region all the way to 912 Å. This model was not derived for the optical or NIR. References Valencic, Clayton, & Gordon (2004) source"},{"id":352,"pagetitle":"Color Laws","title":"Gordon, Cartledge, & Clayton (2009)","ref":"/DustExtinction/stable/color_laws/#Gordon,-Cartledge,-and-Clayton-(2009)","content":" Gordon, Cartledge, & Clayton (2009)"},{"id":353,"pagetitle":"Color Laws","title":"DustExtinction.GCC09","ref":"/DustExtinction/stable/color_laws/#DustExtinction.GCC09","content":" DustExtinction.GCC09  —  Type GCC09(;Rv=3.1) Gordon, Cartledge, & Clayton (2009) dust law. This model applies to the UV spectral region all the way to 909.09 Å. This model was not derived for the optical or NIR. References Gordon, Cartledge, & Clayton (2009) source"},{"id":354,"pagetitle":"Color Laws","title":"Fitzpatrick (1999)","ref":"/DustExtinction/stable/color_laws/#Fitzpatrick-(1999)","content":" Fitzpatrick (1999)"},{"id":355,"pagetitle":"Color Laws","title":"DustExtinction.F99","ref":"/DustExtinction/stable/color_laws/#DustExtinction.F99","content":" DustExtinction.F99  —  Type F99(;Rv=3.1) Fitzpatrick (1999) dust law. Returns A(λ)/A(V) at the given wavelength relative to the extinction. This model applies to the UV and optical to NIR spectral range. The default support is [1000, 33333] Å. Outside of that range this will return 0. Rv is the selective extinction and is valid over [2, 6]. A typical value for the Milky Way is 3.1. References Fitzpatrick (1999) source"},{"id":356,"pagetitle":"Color Laws","title":"Fitzpatrick (2004)","ref":"/DustExtinction/stable/color_laws/#Fitzpatrick-(2004)","content":" Fitzpatrick (2004)"},{"id":357,"pagetitle":"Color Laws","title":"DustExtinction.F04","ref":"/DustExtinction/stable/color_laws/#DustExtinction.F04","content":" DustExtinction.F04  —  Type F04(;Rv=3.1) Fitzpatrick (2004) dust law. Returns A(λ)/A(V) at the given wavelength relative to the extinction. This model applies to the UV and optical to NIR spectral range. The default support is [1000, 33333] Å. Outside of that range this will return 0. Rv is the selective extinction and is valid over [2, 6]. A typical value for the Milky Way is 3.1. Equivalent to the F99 model with an updated NIR Rv dependence See also Fitzpatrick & Massa (2007, ApJ, 663, 320) References Fitzpatrick (2004) source"},{"id":358,"pagetitle":"Color Laws","title":"Fitzpatrick (2019)","ref":"/DustExtinction/stable/color_laws/#Fitzpatrick-(2019)","content":" Fitzpatrick (2019)"},{"id":359,"pagetitle":"Color Laws","title":"DustExtinction.F19","ref":"/DustExtinction/stable/color_laws/#DustExtinction.F19","content":" DustExtinction.F19  —  Type F19(;Rv=3.1) Fitzpatrick (2019) dust law. Returns A(λ)/A(V) at the given wavelength relative to the extinction. This model applies to the UV and optical to NIR spectral range. The default support is [1149, 33333] Å. Outside of that range this will return 0. Rv is the selective extinction and is valid over [2, 6]. A typical value for the Milky Way is 3.1. Fitzpatrick, Massa, Gordon et al. (2019, ApJ, 886, 108) model. Based on a sample of stars observed spectroscopically in the optical with HST/STIS. References Fitzpatrick (2019) source"},{"id":360,"pagetitle":"Color Laws","title":"Maiz Apellaniz et al. (2014)","ref":"/DustExtinction/stable/color_laws/#Maiz-Apellaniz-et-al.-(2014)","content":" Maiz Apellaniz et al. (2014)"},{"id":361,"pagetitle":"Color Laws","title":"DustExtinction.M14","ref":"/DustExtinction/stable/color_laws/#DustExtinction.M14","content":" DustExtinction.M14  —  Type M14(;Rv=3.1) Maiz Apellaniz et al (2014) Milky Way & LMC R(V) dependent model. Returns A(λ)/A(V) at the given wavelength relative to the extinction. The published UV extinction curve is identical to Clayton, Cardelli, and Mathis (1989, CCM). Forcing the optical section to match smoothly with CCM introduces a non-physical feature at high values of R5495 around 3.9 inverse microns; see section 5 in Maiz Apellaniz et al. (2014) for more discussion. For that reason, we provide the M14 model only through 3.3 inverse microns, the limit of the optical in CCM. Outside of that range this will return 0. Rv is the selective extinction and is valid over [2, 6]. A typical value for the Milky Way is 3.1. R5495 = A(5485)/E(4405-5495) Spectral equivalent to photometric R(V). References Maiz Apellaniz et al. (2014) source"},{"id":362,"pagetitle":"Color Laws","title":"Fittable Extinction Laws","ref":"/DustExtinction/stable/color_laws/#Fittable-Extinction-Laws","content":" Fittable Extinction Laws"},{"id":363,"pagetitle":"Color Laws","title":"Fitzpatrick & Massa (1990)","ref":"/DustExtinction/stable/color_laws/#Fitzpatrick-and-Massa-(1990)","content":" Fitzpatrick & Massa (1990)"},{"id":364,"pagetitle":"Color Laws","title":"DustExtinction.FM90","ref":"/DustExtinction/stable/color_laws/#DustExtinction.FM90","content":" DustExtinction.FM90  —  Type FM90(;c1=0.10, c2=0.70, c3=3.23, c4=0.41, x0=4.60, gamma=0.9)\nFM90(coeffs, x0=4.60, gamma=0.9) Fitzpatrick & Massa (1990) generative model for ultraviolet dust extinction. The default values are the published values for the Milky Way average. Parameters c1  - y-intercept of linear term c2  - slope of liner term c3  - amplitude of 2175 Å bump c4  - amplitude of FUV rise x0  - centroid of 2175 Å bump gamma  - width of 2175 Å bump If  λ  is a  Unitful.Quantity  it will be automatically converted to Å and the returned value will be  UnitfulAstro.mag . Examples julia> model = FM90(c1=0.2, c2=0.7, c3=3.23, c4=0.41, x0=4.6, gamma=0.99);\n\njulia> model(1500)\n5.2521258452800135\n\njulia> FM90()(1500)\n5.152125845280013\n\njulia> FM90(c1=0.2, c2=0.7, c3=3.23, c4=0.41, x0=4.6, gamma=0.99).([1000, 1200, 1800])\n3-element Vector{Float64}:\n 12.562237969522851\n  7.769215017329513\n  4.890128210972148\n Extended Help The model has form  $c_1 + c_2x + c_3D(x; γ, x_0) + c_4 F(x)$  where  $x$  is the wavenumber in inverse microns,  $D(x)$  is a Drude profile (modified Lorentzian) used to model the 2175 Å bump with the scale-free parameters  $x_0$  (central wavenumber) and  $γ$  (damping coefficient), and  $F(x)$ , a piecewise function for the far-UV. Note that the coefficients will change the overall normalization, possibly changing the expected behavior of reddening via the parameter  $A_V$ . References Fitzpatrick & Massa (1990) source"},{"id":365,"pagetitle":"Color Laws","title":"Mixture Extinction Laws","ref":"/DustExtinction/stable/color_laws/#Mixture-Extinction-Laws","content":" Mixture Extinction Laws"},{"id":366,"pagetitle":"Color Laws","title":"Gordon et al. (2003)","ref":"/DustExtinction/stable/color_laws/#Gordon-et-al.-(2003)","content":" Gordon et al. (2003)"},{"id":367,"pagetitle":"Color Laws","title":"DustExtinction.G03_SMCBar","ref":"/DustExtinction/stable/color_laws/#DustExtinction.G03_SMCBar","content":" DustExtinction.G03_SMCBar  —  Type G03_SMCBar(;Rv=2.74) <Internal function> Gordon et al. (2003) SMCBar Average Extinction Curve. The observed A(lambda)/A(V) values at 2.198 and 1.25 microns were changed to provide smooth interpolation as noted in Gordon et al. (2016, ApJ, 826, 104) Reference Gordon et al. (2003) source"},{"id":368,"pagetitle":"Color Laws","title":"DustExtinction.G03_LMCAve","ref":"/DustExtinction/stable/color_laws/#DustExtinction.G03_LMCAve","content":" DustExtinction.G03_LMCAve  —  Type G03_LMCAve(;Rv=3.41) <Internal function> Gordon et al. (2003) LMCAve Average Extinction Curve. Reference Gordon et al. (2003) source"},{"id":369,"pagetitle":"Color Laws","title":"Gordon et al. (2016)","ref":"/DustExtinction/stable/color_laws/#Gordon-et-al.-(2016)","content":" Gordon et al. (2016)"},{"id":370,"pagetitle":"Color Laws","title":"DustExtinction.G16","ref":"/DustExtinction/stable/color_laws/#DustExtinction.G16","content":" DustExtinction.G16  —  Type G16(;Rv=3.1, f_A=1.0) Gordon et al. (2016) Milky Way, LMC, & SMC R(V) and f_A dependent model Returns A(λ)/A(V) at the given wavelength relative to the extinction. This is mixture model between the F99 R(V) dependent model (component A) and the  G03_SMCBar  model (component B). The default support is [1000, 33333] Å. Outside of that range this will return 0. Rv is the selective extinction and is valid over [2, 6]. A typical value for the Milky Way is 3.1. References Gordon et al. (2016) source"},{"id":371,"pagetitle":"Color Laws","title":"API/Reference","ref":"/DustExtinction/stable/color_laws/#API/Reference","content":" API/Reference"},{"id":372,"pagetitle":"Color Laws","title":"DustExtinction.redden","ref":"/DustExtinction/stable/color_laws/#DustExtinction.redden","content":" DustExtinction.redden  —  Function redden(::ExtinctionLaw, wave, flux; Av=1)\nredden(::Type{ExtinctionLaw}, wave, flux; Av=1, law_kwargs...) Redden the given  flux  using the given extinction law at the given wavelength. If  wave  is  <:Real  then it is expected to be in angstrom and if it is  <:Unitful.Quantity  it will be automatically converted.  Av  is the total extinction value. The extinction law can be a constructed struct or a  Type . If it is a  Type ,  law_kwargs  will be passed to the constructor. Examples julia> wave = 3000; flux = 1000;\n\njulia> redden(CCM89, wave, flux; Rv=3.1)\n187.38607779757183\n\njulia> redden(CCM89(Rv=3.1), wave, flux; Av=2)\n35.11354215235764 See Also deredden source"},{"id":373,"pagetitle":"Color Laws","title":"DustExtinction.deredden","ref":"/DustExtinction/stable/color_laws/#DustExtinction.deredden","content":" DustExtinction.deredden  —  Function deredden(::ExtinctionLaw, wave, flux; Av=1)\nderedden(::Type{ExtinctionLaw}, wave, flux; Av=1, law_kwargs...) Deredden the given  flux  using the given extinction law at the given wavelength. If  wave  is  <:Real  then it is expected to be in angstrom and if it is  <:Unitful.Quantity  it will be automatically converted.  Av  is the total extinction value. The extinction law can be a constructed struct or a  Type . If it is a  Type ,  law_kwargs  will be passed to the constructor. Examples julia> wave = 3000; flux = 187.386;\n\njulia> deredden(CCM89, wave, flux; Rv=3.1)\n999.9995848273642\n\njulia> deredden(CCM89(Rv=3.1), wave, flux; Av=2)\n5336.573541539394 See Also redden source"},{"id":374,"pagetitle":"Color Laws","title":"DustExtinction.ExtinctionLaw","ref":"/DustExtinction/stable/color_laws/#DustExtinction.ExtinctionLaw","content":" DustExtinction.ExtinctionLaw  —  Type abstract type DustExtinction.ExtinctionLaw The abstract supertype for dust extinction laws. See the extended help ( ??DustExtinction.ExtinctionLaw  from the REPL) for more information about the interface. Extended Help Interface Here's how to make a new extinction law, called  MyLaw Create your struct. We strongly recommend using keyword arguments if your model is parameterized, which allows convenient usage with  redden  and  deredden . struct MyLaw <: DustExtinction.ExtinctionLaw end (Optional) Define the limits. This will default to  (0, Inf) . Currently, this is used within the  DustExtinction.checkbounds  function and in the future will be used for plotting recipes. DustExtinction.bounds(::Type{<:MyLaw}) = (min, max) Define the law. You only need to provide one function which takes wavelength as angstrom. If your law is naturally written for inverse-micron, there is a helper function  aa_to_invum . (::MyLaw)(wavelength::Real) (Optional) enable  Unitful.jl  support by adding this function. If you are building a new law within  DustExtinction.jl  you can add your law to the code-gen list inside  DustExtinction.jl/src/DustExtinction.jl . (l::MyLaw)(wavelength::Unitful.Quantity) = l(ustrip(u\"angstrom\", wavelength)) * u\"mag\" source"},{"id":375,"pagetitle":"Color Laws","title":"DustExtinction.bounds","ref":"/DustExtinction/stable/color_laws/#DustExtinction.bounds","content":" DustExtinction.bounds  —  Function DustExtinction.bounds(::ExtinctionLaw)::Tuple\nDustExtinction.bounds(::Type{<:ExtinctionLaw})::Tuple Get the natural wavelengths bounds for the extinction law, in angstrom source"},{"id":376,"pagetitle":"Color Laws","title":"DustExtinction.checkbounds","ref":"/DustExtinction/stable/color_laws/#DustExtinction.checkbounds","content":" DustExtinction.checkbounds  —  Function DustExtinction.checkbounds(::ExtinctionLaw, wavelength)::Bool\nDustExtinction.checkbounds(::Type{<:ExtinctionLaw, wavelength}::Bool Helper function that uses  DustExtinction.bounds  to return whether the given wavelength is in the support for the law. source"},{"id":379,"pagetitle":"Dust Maps","title":"Dust Maps","ref":"/DustExtinction/stable/dust_maps/#maps","content":" Dust Maps"},{"id":380,"pagetitle":"Dust Maps","title":"Usage","ref":"/DustExtinction/stable/dust_maps/#Usage","content":" Usage julia> dustmap = SFD98Map();\n\njulia> dustmap(0, 2)\n0.020303287464050277\n\njulia> l = range(-π, π, length=5)\n-3.141592653589793:1.5707963267948966:3.141592653589793\n\njulia> b = range(-π/2, π/2, length=5)\n-1.5707963267948966:0.7853981633974483:1.5707963267948966\n\njulia> [dustmap(l[i], b[j]) for i in 1:length(l), j in 1:length(b)]\n5×5 Matrix{Float64}:\n 0.0159853  0.105782    1.40486  0.0158918  0.0119615\n 0.0159853  0.0268289   3.47788  0.0654852  0.0119615\n 0.0159853  0.0343457  99.6976   0.103875   0.0119615\n 0.0159853  0.0432165   2.60569  0.0178195  0.0119615\n 0.0159853  0.105782    1.40486  0.0158918  0.0119615\n"},{"id":381,"pagetitle":"Dust Maps","title":"Advanced Usage","ref":"/DustExtinction/stable/dust_maps/#Advanced-Usage","content":" Advanced Usage Our dust maps also have native support for  Unitful.jl  and  Measurements.jl . julia> using Measurements, Unitful\n\njulia> using Unitful: °\n\njulia> l = 45°; b = 0°;\n\njulia> dustmap = SFD98Map();\n\njulia> dustmap(l, b)\n6.4290331211742355 mag\n\njulia> l = l ± 0.1°; b = b ± 0.3°;\n\njulia> dustmap(l, b)\n6.4 ± 5.7 mag\n"},{"id":382,"pagetitle":"Dust Maps","title":"API/Reference","ref":"/DustExtinction/stable/dust_maps/#API/Reference","content":" API/Reference"},{"id":383,"pagetitle":"Dust Maps","title":"DustExtinction.SFD98Map","ref":"/DustExtinction/stable/dust_maps/#DustExtinction.SFD98Map","content":" DustExtinction.SFD98Map  —  Type SFD98Map([mapdir]) Schlegel, Finkbeiner and Davis (1998) dust map. The first time this is constructed, the data files required will be downloaded and stored in a directory following the semantics of  DataDeps.jl . To avoid being asked to download the files, set the environment variable  DATADEPS_ALWAYS_ACCEPT  to  true . You can also provide the directory of the two requisite files manually instead of relying on DataDeps.jl. Internally, this type keeps the FITS files defining the map open, speeding up repeated queries for E(B-V) values. References Schlegel, Finkbeiner and Davis (1998) source (dustmap::SFD98Map)(l::Real, b::Real)\n(dustmap::SFD98Map)(l::Quantity, b::Quantity) Get E(B-V) value from a  SFD98Map  instance at galactic coordinates ( l ,  b ), given in radians. Uses bilinear interpolation between pixel values. If  l  and  b  are  Unitful.Quantity  they will be converted to radians and the output will be given as  UnitfulAstro.mag . Example julia> using DustExtinction\n\njulia> m = SFD98Map();\n\njulia> m(1, 2)\n0.013439524544325624\n\njulia> l = 0:0.5:2; b = 0:0.5:2;\n\njulia> m.(l, b)\n5-element Vector{Float64}:\n 99.69757461547852\n  0.10180447359074371\n  0.019595484241066132\n  0.010238757633890877\n  0.01862100327420125 source"},{"id":386,"pagetitle":"Plotting","title":"Plotting","ref":"/DustExtinction/stable/plotting/#plotting","content":" Plotting DustExtinction.jl is designed to work automatically with many of Makie.jl's core plotting functions, which can then be composed together to form more complex figures. Below we show a few practical applications. Note By default, all plots adopt the wavelength limits (in units of 1/μm) defined by  DustExtinction.bounds ."},{"id":387,"pagetitle":"Plotting","title":"Model plot example","ref":"/DustExtinction/stable/plotting/#Model-plot-example","content":" Model plot example For a given  DustExtinction.ExtinctionLaw , Makie's usual PointBased plotting functions (e.g.,  lines ,  scatter ,  stairs , etc.) should work right out-of-the-box: using DustExtinction, CairoMakie model = CCM89() CCM89(3.1) # Automatic limits defined by model\nlines(model; linewidth=3, color=:cornflowerblue) # Or plot(model; [plot options]) # Custom limits\nfig = Figure()\nax1 = Axis(fig[1, 1])\nax2 = Axis(fig[1, 2]; limits=(3, 6, 0, 5))\n\nlines!(ax1, model)\nstairs!(ax2, model; color=:orange)\n\nlinkyaxes!(ax1, ax2)\n\nfig A predefined vector of wavelengths can also be passed to these plotting functions directly. Let's combine this with Makie's integration with Measurements.jl to visualize the underlying uncertainty in our data: using Measurements, Unitful, UnitfulAstro\n\nwavs = let\n    x = range(2_000, 3_000; length=1_000)\n    x = x .± 1e5 * inv.(ustrip.(x)) # \"Å\"\nend\n\nextinction = model.(wavs) # mag\n\nwavs_sampled, extinction_sampled = let\n    N_samples = 7\n    wavs[range(begin, step=end ÷ N_samples; length=N_samples)],\n    extinction[range(begin, step=end ÷ N_samples; length=N_samples)]\nend\n\nfig, ax, p = band(wavs, extinction; alpha=0.5, label=\"model uncertainty\")\n\nlines!(ax, wavs, extinction; label=\"model: CCM89\")\n\nscatter!(ax, wavs_sampled, extinction_sampled; color=:orange, label=\"observations\")\n\n# Currently ambiguous for both x and y being Measurements\n# so we focus on the y-uncertainty instead\nerrorbars!(ax, Measurements.value.(wavs_sampled), extinction_sampled;\n    whiskerwidth = 10,\n    color = :orange,\n    label = \"obs. uncertainty\",\n)\n\naxislegend()\nax.xlabel = \"Wavelength [Å]\"\nax.ylabel = \"A(x) / A(V) [mag]\"\n\nfig"},{"id":388,"pagetitle":"Plotting","title":"Dust map example","ref":"/DustExtinction/stable/plotting/#Dust-map-example","content":" Dust map example A  heatmap  plot also works automatically for  DustExtinction.SFD98Map : dustmap = SFD98Map()\n\nheatmap(dustmap; colorrange=(0, 3), colormap=:cividis) # Or plot(dustmap; [plot kwargs]) Similarly to the extinction law plots, we can create our own custom dust map plots. Here is an example using  Unitful.jl 's integration: using Unitful\n\nlrange = range(-1, 1; length=400)u\"°\"\nbrange = range(-0.25, 0.25; length=300)u\"°\"\n\nfig, ax, p = heatmap(lrange, brange, dustmap; colorrange=(0, 3), colormap=:cividis)\n\nax.xlabel = \"l [°]\"\nax.ylabel = \"b [°]\"\n\nColorbar(fig[1, 2], p; label=\"E(B - V) [mag]\")\n\nfig Tip See  plotting.jl  for more plotting examples. The convenience functions defined there are used to generate the other figures shown in this documentation."},{"id":391,"pagetitle":"Home","title":"CCDReduction.jl","ref":"/CCDReduction/stable/#CCDReduction.jl","content":" CCDReduction.jl This package provides tools for basic reduction methods of CCD images."},{"id":392,"pagetitle":"Home","title":"Installation","ref":"/CCDReduction/stable/#Installation","content":" Installation From Julia enter Pkg mode (by pressing  ]  in the Julia REPL) julia> ]\n\npkg> add CCDReduction"},{"id":393,"pagetitle":"Home","title":"Usage","ref":"/CCDReduction/stable/#Usage","content":" Usage You'll recognize most of the familiar reduction operations allow us to quickly and easily operate on data. using CCDReduction\n\nnoise = randn(512, 512)\nbias_frame = reshape(1:262144, 512, 512) |> collect\nimg = reshape(1:262144, 512, 512) .+ noise\n\nsubtract_bias(img, bias_frame) In addition to working on array-like data, we can directly load from a  FITSIO.ImageHDU  or from a filename using FITSIO\n\n# make fits file\nbias_frame = reshape(1:262144, 512, 512) |> collect\nFITS(\"master_bias.fits\", \"w\") do f\n    write(f, bias_frame)\nend\nimg = 10 .* randn(512, 512)\ndebiased = subtract_bias(img, \"master_bias.fits\") Finally, we can use function chaining (or tools like  Underscores.jl ) for creating a simple processing pipeline! using Underscores\n\n# 5 science frames\nimgs = (10 .* randn(512, 524) for _ in 1:5)\n\n# create pipeline using Underscores.jl\npipeline(img) = @_ img |>\n    subtract_overscan(__, (:, 513:524)) |>\n    trim(__, (:, 513:524)) |>\n    subtract_bias(__, \"master_bias.fits\")\n\n# apply pipeline to images using broadcast syntax\ncalib_imgs = pipeline.(imgs)"},{"id":394,"pagetitle":"Home","title":"License","ref":"/CCDReduction/stable/#License","content":" License This work is distributed under the MIT \"expat\" license. See  LICENSE  for more information."},{"id":397,"pagetitle":"API/Reference","title":"API/Reference","ref":"/CCDReduction/stable/api/#API/Reference","content":" API/Reference For now, here is a list of all documented functions."},{"id":398,"pagetitle":"API/Reference","title":"Index","ref":"/CCDReduction/stable/api/#Index","content":" Index CCDReduction.AbstractCCDData CCDReduction.CCDData CCDReduction.CCDData CCDReduction.CCDData CCDReduction.arrays CCDReduction.arrays CCDReduction.ccds CCDReduction.ccds CCDReduction.combine CCDReduction.crop CCDReduction.cropview CCDReduction.filenames CCDReduction.filenames CCDReduction.find_ccd CCDReduction.fitscollection CCDReduction.flat_correct CCDReduction.flat_correct! CCDReduction.getdata CCDReduction.subtract_bias CCDReduction.subtract_bias! CCDReduction.subtract_dark CCDReduction.subtract_dark! CCDReduction.subtract_overscan CCDReduction.subtract_overscan! CCDReduction.trim CCDReduction.trimview CCDReduction.writefits"},{"id":399,"pagetitle":"API/Reference","title":"API/Reference","ref":"/CCDReduction/stable/api/#API/Reference-2","content":" API/Reference"},{"id":400,"pagetitle":"API/Reference","title":"CCDReduction.AbstractCCDData","ref":"/CCDReduction/stable/api/#CCDReduction.AbstractCCDData","content":" CCDReduction.AbstractCCDData  —  Type abstract type AbstractCCDData{T} <: AbstractMatrix{T} Supertype for  CCDData  based on  AbstractMatrix  interface. Every subtype of this type should have methods  data  and  hdr  defined. source"},{"id":401,"pagetitle":"API/Reference","title":"CCDReduction.CCDData","ref":"/CCDReduction/stable/api/#CCDReduction.CCDData","content":" CCDReduction.CCDData  —  Type CCDData <: AbstractCCDData\nCCDData(data::AbstractMatrix, [hdr::FITSHeader]) Struct to store  ImageHDU , derived from  AbstractCCDData . CCDData  acts like a matrix with a header associated. ccd = CCDData(zeros(4, 4))\n\nccd[1] This accesses the 1st element in matrix associated with  ccd . ccd[\"SIMPLE\"] One can also access the header directly from  ccd , the key can be  Symbol  as well. ccd[:SIMPLE] = false Header values can be directly modified from  ccd . One can perform arithmetic operations on it as well: ccd1 = CCDData(zeros(4, 4))\nccd2 = CCDData(ones(4, 4))\nsum_ccd1 = ccd1 + ccd2\nsum_ccd2 = ccd2 + ccd1 sum_ccd1  has the header of  ccd1  whereas  sum_ccd2  has the header  ccd2 . If header is not provided in the  CCDData  constructor,  default_header  is used to generate the header. source"},{"id":402,"pagetitle":"API/Reference","title":"CCDReduction.CCDData","ref":"/CCDReduction/stable/api/#CCDReduction.CCDData-Tuple{AbstractString}","content":" CCDReduction.CCDData  —  Method CCDData(path::AbstractString; hdu = 1) Loads HDU from  hdu  index in  FITS  file at  path  as  CCDData . source"},{"id":403,"pagetitle":"API/Reference","title":"CCDReduction.CCDData","ref":"/CCDReduction/stable/api/#CCDReduction.CCDData-Tuple{FITSIO.ImageHDU}","content":" CCDReduction.CCDData  —  Method CCDData(hdu::ImageHDU) Loads  ImageHDU  as  CCDData . source"},{"id":404,"pagetitle":"API/Reference","title":"CCDReduction.arrays","ref":"/CCDReduction/stable/api/#CCDReduction.arrays","content":" CCDReduction.arrays  —  Function arrays(collection) Generator for arrays of images of entries in data frame. Iterates over  collection  using each  path  and  hdu  to load data into an  Array . Examples collection = fitscollection(\"~/data/tekdata\")\ndata = arrays(collection) |> collect This returns all image arrays present in  collection . This can also be used via a for-loop collection = fitscollection(\"~/data/tekdata\")\nfor arr in arrays(collection)\n    @assert arr isa Array\n    println(size(arr))\nend\n\n# output\n(1048, 1068)\n(1048, 1068)\n... source"},{"id":405,"pagetitle":"API/Reference","title":"CCDReduction.arrays","ref":"/CCDReduction/stable/api/#CCDReduction.arrays-Tuple{Any, Any}","content":" CCDReduction.arrays  —  Method arrays(f,\n       collection;\n       path = nothing,\n       save_prefix = nothing,\n       save_suffix = nothing,\n       save = any(!isnothing, (save_prefix, path, save_suffix)),\n       save_delim = \"_\",\n       ext = r\"fits(\\.tar\\.gz)?\"i,\n       kwargs...) Iterates over the image arrays of the collection applying function  f  at each step. The output from  f  can be saved using the appropriate keyword arguments. The  save_prefix  argument will add a prefix to each filename delimited by  save_delim .  save_suffix  will add a suffix prior to the extension, which can be manually provided via  ext , similar to  fitscollection . Files will be saved in the directory they are stored unless  path  is given. Finally,  save  will default to  true  if any of the previous arguments are set, but can be manually overridden (useful for testing). Files will be saved using  CCDReduction.writefits . Examples collection = fitscollection(\"~/data/tekdata\")\nprocessed_images = map(arrays(collection)) do arr\n    trim(arr, (:, 1040:1059))\nend The above generates  processed_images  which consists of trimmed versions of image arrays present in  collection . For saving the  processed_images  simultaneously with the operations performed processed_images = map(arrays(collection; path = \"~/data/tekdata\", save_prefix = \"trimmed\")) do img\n    trim(img, (:, 1040:1059))\nend The trimmed image arrays are saved as  trimmed_(original_name)  (FITS files) at  path = \"~/data/tekdata\"  as specified by the user. source"},{"id":406,"pagetitle":"API/Reference","title":"CCDReduction.ccds","ref":"/CCDReduction/stable/api/#CCDReduction.ccds","content":" CCDReduction.ccds  —  Function ccds(collection) Generator for  CCDData s of entries in data frame. Iterates over  collection  using each  path  and  hdu  to load data into a  CCDData . Examples collection = fitscollection(\"~/data/tekdata\")\nfor hdu in ccds(collection)\n    @assert hdu isa CCDData\nend source"},{"id":407,"pagetitle":"API/Reference","title":"CCDReduction.ccds","ref":"/CCDReduction/stable/api/#CCDReduction.ccds-Tuple{Any, Any}","content":" CCDReduction.ccds  —  Method ccds(f,\n     collection;\n     path = nothing,\n     save_prefix = nothing,\n     save_suffix = nothing,\n     save = any(!isnothing, (save_prefix, path, save_suffix)),\n     save_delim = \"_\",\n     ext = r\"fits(\\.tar\\.gz)?\"i,\n     kwargs...) Iterates over the  CCDData s of the collection applying function  f  at each step. The output from  f  can be saved using the appropriate keyword arguments. The  save_prefix  argument will add a prefix to each filename delimited by  save_delim .  save_suffix  will add a suffix prior to the extension, which can be manually provided via  ext , similar to  fitscollection . Files will be saved in the directory they are stored unless  path  is given. Finally,  save  will default to  true  if any of the previous arguments are set, but can be manually overridden (useful for testing). Files will be saved using  CCDReduction.writefits . Example collection = fitscollection(\"~/data/tekdata\")\nprocessed_images = map(ccds(collection)) do img\n    trim(img, (:, 1040:1059))\nend The above generates  processed_images  which consists of trimmed versions of images present in  collection . For saving the  processed_images  simultaneously with the operations performed processed_images = map(ccds(collection; path = \"~/data/tekdata\", save_prefix = \"trimmed\")) do img\n    trim(img, (:, 1040:1059))\nend The trimmed images are saved as  trimmed_(original_name)  (FITS files) at  path = \"~/data/tekdata\"  as specified by the user. source"},{"id":408,"pagetitle":"API/Reference","title":"CCDReduction.combine","ref":"/CCDReduction/stable/api/#CCDReduction.combine-Tuple{Vararg{AbstractArray{<:Number}}}","content":" CCDReduction.combine  —  Method combine(frames...; method = median, [hdu = 1], [header_hdu = 1])\ncombine(frames; method = median, [hdu = 1], [header_hdu = 1]) Combine multiple frames using  method . Multiple frames can also be passed in a vector or as generators for combining. To pass a custom method, it must have a signature like  method(::AbstractArray; dims) . If  frames  are strings, they will be loaded into  CCDData s first. The HDU indices can be specified with  hdu  as either an integer or a tuple corresponding to each file. Header of output file (if applicable) is specified by  header_hdu  which by default is 1. Examples julia> frame = [reshape(1.0:4.0, (2, 2)) for i = 1:4];\n\njulia> combine(frame)\n2×2 Matrix{Float64}:\n 1.0  3.0\n 2.0  4.0\n\njulia> combine(frame, method = sum)\n2×2 Matrix{Float64}:\n 4.0  12.0\n 8.0  16.0\n source"},{"id":409,"pagetitle":"API/Reference","title":"CCDReduction.crop","ref":"/CCDReduction/stable/api/#CCDReduction.crop-Tuple{Any, Any}","content":" CCDReduction.crop  —  Method crop(frame, shape; force_equal = true, [hdu = 1]) Crops  frame  to the size specified by  shape  anchored by the frame center. This will remove rows/cols of the  frame  equally on each side. When there is an uneven difference in sizes (e.g. size 9 -> 6 can't be removed equally) the default is to increase the output size (e.g. 6 -> 7) so there is equal removal on each side. To disable this, set  force_equal=false , which will remove the extra slice from the end of the axis. If  frame  is a string, it will be loaded into  CCDData  first. The HDU loaded can be specified by  hdu  which by default is 1. Examples julia> frame = reshape(1:25, (5, 5));\n\njulia> crop(frame, (3, 3))\n3×3 Matrix{Int64}:\n 7  12  17\n 8  13  18\n 9  14  19\n\njulia> crop(frame, (4, 3), force_equal = false)\n4×3 Matrix{Int64}:\n 6  11  16\n 7  12  17\n 8  13  18\n 9  14  19 See Also cropview source"},{"id":410,"pagetitle":"API/Reference","title":"CCDReduction.cropview","ref":"/CCDReduction/stable/api/#CCDReduction.cropview-Tuple{AbstractArray, Any}","content":" CCDReduction.cropview  —  Method cropview(frame, shape; force_equal = true) Crops  frame  to the size specified by  shape  anchored by the frame center. This function is same as the  crop  function but returns a view of the frame. Note This function returns a view of the frame, so any modification to output array will result in modification of frame. See Also crop source"},{"id":411,"pagetitle":"API/Reference","title":"CCDReduction.filenames","ref":"/CCDReduction/stable/api/#CCDReduction.filenames","content":" CCDReduction.filenames  —  Function filenames(collection) Generator for filenames of entries in data frame. Iterates over  collection  using each  path . Examples collection = fitscollection(\"~/data/tekdata\")\nfor path in filenames(collection)\n    @assert path isa String\n    println(path)\nend\n\n# output\n\"~/data/tekdata/tek001.fits\"\n\"~/data/tekdata/tek002.fits\"\n... source"},{"id":412,"pagetitle":"API/Reference","title":"CCDReduction.filenames","ref":"/CCDReduction/stable/api/#CCDReduction.filenames-Tuple{Any, Any}","content":" CCDReduction.filenames  —  Method filenames(f,\n          collection;\n          path = nothing,\n          save_prefix = nothing,\n          save_suffix = nothing,\n          save = any(!isnothing, (save_prefix, path, save_suffix)),\n          save_delim = \"_\",\n          ext = r\"fits(\\.tar\\.gz)?\"i,\n          kwargs...) Iterates over the file paths of the collection applying function  f  at each step. The output from  f  can be saved using the appropriate keyword arguments. The  save_prefix  argument will add a prefix to each filename delimited by  save_delim .  save_suffix  will add a suffix prior to the extension, which can be manually provided via  ext , similar to  fitscollection . Files will be saved in the directory they are stored unless  path  is given. Finally,  save  will default to  true  if any of the previous arguments are set, but can be manually overridden (useful for testing). Files will be saved using  CCDReduction.writefits . Examples collection = fitscollection(\"~/data/tekdata\")\ndata = map(filenames(collection)) do path\n    fh = FITS(path)\n    data = getdata(fh[1]) # assuming all 1-hdu are ImageHDUs\n    close(fh)\n    data\nend The above generates  data  which consists of image arrays corresponding to 1st hdu of FITS file paths present in  collection . For saving the  data  simultaneously with the operations performed data = map(filenames(collection; path = \"~/data/tekdata\", save_prefix = \"retrieved_from_filename\")) do img\n    fh = FITS(path)\n    data = getdata(fh[1]) # assuming all 1-hdu are ImageHDUs\n    close(fh)\n    data\nend The retrieved data is saved as  retrieved_from_filename_(original_name)  (FITS files) at  path = \"~/data/tekdata\"  as specified by the user. source"},{"id":413,"pagetitle":"API/Reference","title":"CCDReduction.find_ccd","ref":"/CCDReduction/stable/api/#CCDReduction.find_ccd-Tuple{Base.Broadcast.Broadcasted}","content":" CCDReduction.find_ccd  —  Method find_ccd(As) Return the first  CCDData  among the arguments. source"},{"id":414,"pagetitle":"API/Reference","title":"CCDReduction.fitscollection","ref":"/CCDReduction/stable/api/#CCDReduction.fitscollection-Tuple{String}","content":" CCDReduction.fitscollection  —  Method fitscollection(dir;\n               recursive=true,\n               abspath=true,\n               keepext=true,\n               ext=r\"fits(\\.tar\\.gz)?\",\n               exclude=nothing,\n               exclude_dir=nothing,\n               exclude_key=(\"\", \"HISTORY\")) Walk through  dir  collecting FITS files, scanning their headers, and culminating into a  DataFrame  that can be used with the generators for iterating over many files and processing them. If  recursive  is false, no subdirectories will be walked through. The table returned will contain the path to the file, the name of the file, and index of the corresponding HDU, and each FITS header column and value. If two FITS files have distinct columns, they will both appear in the table with  missing  in the appropriate rows. Duplicate Keys In certain cases, there are multiple FITS headers with the same key, e.g.,  COMMENT . In these cases, only the first instance of the key-value pair will be stored. If  abspath  is true, the path in the table will be absolute. If  keepext  is true, the name in the table will include the file extension, given by  ext .  ext  will be used with  endswith  to filter for fits files compatible with  FITSIO.FITS .  exclude  is a pattern that can be used with  occursin  to exclude certain filenames. For example, to exclude any files containing \"sky\", fitscollection(...; exclude=\"sky\") to exclude exact filenames,  regex strings  will prove powerful fitscollection(...; exclude=r\"^tek001\\d\") finally, using external tools like  Glob.jl  allows further customization using Glob\nfitscollection(...; exclude=fn\"tek001*.fits\") # same as regex match above Similarly,  exclude_dir  allows excluding entire folders using pattern matching (e.g. skipping a backup folder  exclude_dir=\"backup\" ).  exclude_key  allows excluding certain entries in the header unit of  ImageHDU  in FITS files (e.g. skipping  \"HISTORY\"  and  \"\" exclude_key = (\"HISTORY\", \"\") ). For more information about the file matching and path deconstruction, see the extended help ( ??fitscollection ) Extended Help Parts of a path Let's look at some file paths starting from  \"/data\" . Here are examples of how they would be parsed  root  dir   base   ext\n[----][---][------][---]\n/data/test/tek0001.fits\n\n root    dir     base   ext\n[----][-------][------][---]\n/data/test/sci/tek0001.fits If  keepext  is  true ,  name=base * ext , otherwise it is just  base . If  abspath  is  true , the path will be  root * dir * base * ext , otherwise it will be  dir * base * ext . These options allow flexility in creating a table that can be easily saved and loaded to avoid having to manually filter files. Especially consider how  abspath  can allow keeping tables that will transfer easily between computers or between data sources with common structures. source"},{"id":415,"pagetitle":"API/Reference","title":"CCDReduction.flat_correct!","ref":"/CCDReduction/stable/api/#CCDReduction.flat_correct!-Tuple{AbstractArray, AbstractArray}","content":" CCDReduction.flat_correct!  —  Method flat_correct!(frame, flat_frame; norm_value = mean(flat_frame), [hdu = 1]) In-place version of  flat_correct See Also flat_correct source"},{"id":416,"pagetitle":"API/Reference","title":"CCDReduction.flat_correct","ref":"/CCDReduction/stable/api/#CCDReduction.flat_correct-Union{Tuple{S}, Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{S}}} where {T, S}","content":" CCDReduction.flat_correct  —  Method flat_correct(frame, flat_frame; norm_value = mean(flat_frame), [hdu = 1]) Correct  frame  for non-uniformity using the calibrated  flat_frame . By default, the  flat_frame  is normalized by its mean, but this can be changed by providing a custom  norm_value . If either are strings, they will be loaded into  CCDData  first. The HDU loaded can be specified by  hdu  as either an integer or a tuple corresponding to each file. Note This function may introduce non-finite values if  flat_frame  contains values very close to  0  due to dividing by zero. The default behavior will return  Inf  if the frame value is non-zero, and  Nan  if the frame value is  0 . Examples julia> frame = ones(3, 3);\n\njulia> flat = fill(2.0, (3, 3));\n\njulia> flat_correct(frame, flat, norm_value = 1.0)\n3×3 Matrix{Float64}:\n 0.5  0.5  0.5\n 0.5  0.5  0.5\n 0.5  0.5  0.5\n\njulia> flat_correct(frame, flat)\n3×3 Matrix{Float64}:\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n 1.0  1.0  1.0 See Also flat_correct! source"},{"id":417,"pagetitle":"API/Reference","title":"CCDReduction.getdata","ref":"/CCDReduction/stable/api/#CCDReduction.getdata-Tuple{FITSIO.ImageHDU}","content":" CCDReduction.getdata  —  Method CCDReduction.getdata(::FITSIO.ImageHDU) Loads the given HDU as an  Array , permuting the dimensions appropriately. FITSIO.jl takes over memory read in by cfitsio, which reads in row-major form, whereas when Julia takes that memory, it is assumed as column major. Therefore all data read by  FITSIO.read  is transposed. This function allows the user to read data in a consistent way to  Array  by transposing after reading. source"},{"id":418,"pagetitle":"API/Reference","title":"CCDReduction.subtract_bias!","ref":"/CCDReduction/stable/api/#CCDReduction.subtract_bias!-Tuple{AbstractArray, AbstractArray}","content":" CCDReduction.subtract_bias!  —  Method subtract_bias!(frame, bias_frame; [hdu = 1]) In-place version of  subtract_bias See Also subtract_bias source"},{"id":419,"pagetitle":"API/Reference","title":"CCDReduction.subtract_bias","ref":"/CCDReduction/stable/api/#CCDReduction.subtract_bias-Tuple{AbstractArray, AbstractArray}","content":" CCDReduction.subtract_bias  —  Method subtract_bias(frame, bias_frame; [hdu = 1]) Subtract the  bias_frame  from  frame . If either are strings, they will be loaded into  CCDData  first. The HDU loaded can be specified by  hdu  as either an integer or a tuple corresponding to each file. Examples julia> frame = [1.0 2.2 3.3 4.5];\n\njulia> bias = [0.0 0.2 0.3 0.5];\n\njulia> subtract_bias(frame, bias)\n1×4 Matrix{Float64}:\n 1.0  2.0  3.0  4.0\n See Also subtract_bias! source"},{"id":420,"pagetitle":"API/Reference","title":"CCDReduction.subtract_dark!","ref":"/CCDReduction/stable/api/#CCDReduction.subtract_dark!-Tuple{AbstractArray, AbstractArray}","content":" CCDReduction.subtract_dark!  —  Method subtract_dark!(frame, dark_frame; data_exposure = 1, dark_exposure = 1, [hdu = 1]) In-place version of  subtract_dark See Also subtract_dark source"},{"id":421,"pagetitle":"API/Reference","title":"CCDReduction.subtract_dark","ref":"/CCDReduction/stable/api/#CCDReduction.subtract_dark-Union{Tuple{S}, Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{S}}} where {T, S}","content":" CCDReduction.subtract_dark  —  Method subtract_dark(frame, dark_frame; data_exposure = 1, dark_exposure = 1, [hdu = 1]) Subtract the  dark_frame  from  frame . If either are strings, they will be loaded into  CCDData  first. The HDU loaded can be specified by  hdu  as either an integer or a tuple corresponding to each file. Examples julia> frame = ones(3, 3);\n\njulia> dark_frame = ones(3, 3);\n\njulia> subtract_dark(frame, dark_frame)\n3×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\njulia> subtract_dark(frame, dark_frame, data_exposure = 1, dark_exposure = 4)\n3×3 Matrix{Float64}:\n 0.75  0.75  0.75\n 0.75  0.75  0.75\n 0.75  0.75  0.75\n See Also subtract_dark! source"},{"id":422,"pagetitle":"API/Reference","title":"CCDReduction.subtract_overscan!","ref":"/CCDReduction/stable/api/#CCDReduction.subtract_overscan!-Union{Tuple{T}, Tuple{AbstractArray{T}, Any}} where T","content":" CCDReduction.subtract_overscan!  —  Method subtract_overscan!(frame, idxs; dims = axes_min_length(idxs)) In-place version of  subtract_overscan See Also subtract_overscan source"},{"id":423,"pagetitle":"API/Reference","title":"CCDReduction.subtract_overscan","ref":"/CCDReduction/stable/api/#CCDReduction.subtract_overscan-Tuple{Any, Any}","content":" CCDReduction.subtract_overscan  —  Method subtract_overscan(frame, idxs; dims = axes_min_length(idxs), [hdu = 1]) Subtract the overscan frame from image. dims  is the dimension along which  overscan_frame  is combined. The default value of  dims  is the axis with smaller length in overscan region. If  idxs  is a string it will be parsed as FITS-style indices. If  frame  is a string, it will be loaded into  CCDData  first. The HDU loaded can be specified by  hdu  which by default is 1. Examples julia> frame = [4.0 2.0 3.0 1.0 1.0];\n\njulia> subtract_overscan(frame, (:, 4:5), dims = 2)\n1×5 Matrix{Float64}:\n 3.0  1.0  2.0  0.0  0.0\n\njulia> subtract_overscan(frame, \"[4:5, 1:1]\", dims = 2)\n1×5 Matrix{Float64}:\n 3.0  1.0  2.0  0.0  0.0 See Also subtract_overscan! source"},{"id":424,"pagetitle":"API/Reference","title":"CCDReduction.trim","ref":"/CCDReduction/stable/api/#CCDReduction.trim-Tuple{Any, Any}","content":" CCDReduction.trim  —  Method trim(frame, idxs; [hdu = 1]) Trims the  frame  to remove the region specified by idxs. This function trims the array in a manner such that final array should be rectangular. The indices follow standard Julia convention, so  (:, 45:60)  trims all columns from 45 to 60 and  (1:20, :)  trims all the rows from 1 to 20. The function also supports FITS-style indices. If  frame  is a string, it will be loaded into  CCDData  first. The HDU loaded can be specified by  hdu  which by default is 1. Examples julia> frame = ones(5, 5);\n\njulia> trim(frame, (:, 2:5))\n5×1 Matrix{Float64}:\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n\njulia> trim(frame, \"[2:5, 1:5]\")\n5×1 Matrix{Float64}:\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n See Also trimview source"},{"id":425,"pagetitle":"API/Reference","title":"CCDReduction.trimview","ref":"/CCDReduction/stable/api/#CCDReduction.trimview-Tuple{AbstractArray, Any}","content":" CCDReduction.trimview  —  Method trimview(frame, idxs) Trims the  frame  to remove the region specified by idxs. This function is same as the  trim  function but returns a view of the frame. Note This function returns a view of the frame, so any modification to output array will result in modification of frame. See Also trim source"},{"id":426,"pagetitle":"API/Reference","title":"CCDReduction.writefits","ref":"/CCDReduction/stable/api/#CCDReduction.writefits-Tuple{Any, Any}","content":" CCDReduction.writefits  —  Method CCDReduction.writefits(file_path, data; header = nothing)\nCCDReduction.writefits(file_path, ccd::CCDData) Writes  data / ccd  in FITS format at  file_path . FITSIO  takes over memory write in by  cfitsio , which writes in row-major form, whereas when Julia gives that memory, it is assumed as column major. Therefore all data written by  FITSIO.write  is transposed. This function allows the user to write the data in a consistent     way to FITS file by transposing before writing. source"},{"id":429,"pagetitle":"Home","title":"LACosmic.jl","ref":"/LACosmic/stable/#LACosmic.jl","content":" LACosmic.jl Laplacian cosmic-ray detection (L.A.Cosmic) in pure Julia."},{"id":430,"pagetitle":"Home","title":"Installation","ref":"/LACosmic/stable/#Installation","content":" Installation To use the LACosmic library, first install it using  Pkg julia> ]add LACosmic"},{"id":431,"pagetitle":"Home","title":"Usage","ref":"/LACosmic/stable/#Usage","content":" Usage To import the library using LACosmic there is one exported function:  lacosmic clean_image, mask = lacosmic(image)"},{"id":432,"pagetitle":"Home","title":"Contributing and Support","ref":"/LACosmic/stable/#Contributing-and-Support","content":" Contributing and Support If you would like to contribute, feel free to open a  pull request . If you want to discuss something before contributing, head over to  discussions  and join or open a new topic. If you're having problems with something, please open an  issue ."},{"id":435,"pagetitle":"API/Reference","title":"API/Reference","ref":"/LACosmic/stable/api/#API/Reference","content":" API/Reference LACosmic.lacosmic LACosmic.subsample"},{"id":436,"pagetitle":"API/Reference","title":"LACosmic.lacosmic","ref":"/LACosmic/stable/api/#LACosmic.lacosmic-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","content":" LACosmic.lacosmic  —  Method lacosmic(data::AbstractMatrix; \n    noise=nothing,\n    gain=1,\n    background=0,\n    readnoise=0,\n    mask=falses(size(data)),\n    sigma_clip=4.5,\n    contrast=5,\n    neighbor_thresh=0.3,\n    maxiter=4,\n    saturation_level=2^16,\n    block_size=2) Laplacian cosmic ray detection (LACosmic). This algorithm implements the algorithm presented in  lacosmicx . The return values are the cleaned image and the bad pixel mask. The image cleaning is done via median interpolation. Parameters noise  is the pre-determined estimate of the data noise (square root of variance), if any gain  is the image gain in electrons per data number background  is pre-determined image background, if any readnoise  is the read noise of the image in electrons mask  is an input bad pixel mask, where  true  represents a bad pixel sigma_clip  is the Laplacian signal-to-noise ratio for flagging bad pixels contrast  is the minimum contrast required to flag a bad pixel in the ratio of the Laplacian image to the fine-structure image neighbor_thresh  is the fractional detection limit for cosmic rays surrounding other cosmic rays. Should be a number between 0 and 1. maxiter  is the maximum number of iterations used for detecting bad pixels saturation_level  is the saturation value in electrons block_size  is the subsampling factor for the Laplacian filter image. Examples julia> image = 100 .* randn(1001, 1001) .+ 1000;\n\njulia> clean_image, mask = lacosmic(image, gain=4); References van Dokkum, P.G. (2001)  - \"Cosmic-Ray Rejection by Laplacian Edge Detection\" source"},{"id":437,"pagetitle":"API/Reference","title":"LACosmic.subsample","ref":"/LACosmic/stable/api/#LACosmic.subsample","content":" LACosmic.subsample  —  Function LACosmic.subsample(array, block_size=2) Subsample  array  by the given factor without copying or allocating. This effectively treats each pixel as  block_size  x  block_size  pixels. The value of each pixel is not normalized or averaged. This is a view into the parent array, and if the data was changed this view would change subsequently. Examples julia> arr = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> sub = LACosmic.subsample(arr)\n4×4 LACosmic.SubsampledArray{Int64, 2, Matrix{Int64}}:\n 1  1  2  2\n 1  1  2  2\n 3  3  4  4\n 3  3  4  4\n\njulia> all(sub[1:2, 1:2] .=== arr[1, 1])\ntrue\n\njulia> sub[3, 3] = 5;\n\njulia> sub\n4×4 LACosmic.SubsampledArray{Int64, 2, Matrix{Int64}}:\n 1  1  2  2\n 1  1  2  2\n 3  3  5  5\n 3  3  5  5 source"},{"id":440,"pagetitle":"Examples","title":"Examples","ref":"/LACosmic/stable/examples/#Examples","content":" Examples"},{"id":441,"pagetitle":"Examples","title":"Setup","ref":"/LACosmic/stable/examples/#Setup","content":" Setup You will need the following packages installed to replicate this tutorial julia> ]add Distributions LACosmic Plots PSFModels"},{"id":442,"pagetitle":"Examples","title":"Removing bad pixels with LACosmic.jl","ref":"/LACosmic/stable/examples/#Removing-bad-pixels-with-LACosmic.jl","content":" Removing bad pixels with LACosmic.jl First, let's create some fake data with Gaussian sources using Distributions\nusing PSFModels: Gaussian\nusing Random\n\nfunction make_data(rng, N; N_sources=20, N_cosmics=20)\n    imdata = fill(200.0, (N, N))\n\n    # Add some fake sources\n    for _ in 1:N_sources\n        x = rand(rng, Uniform(1, N + 1))\n        y = rand(rng, Uniform(1, N + 1))\n        brightness = rand(rng, Uniform(1000, 30000)) / (2π * 3.5^2)\n\t\tmodel = Gaussian(;x, y, fwhm=3.5, amp=brightness)\n        imdata .+= model[axes(imdata)...]\n\tend\n\n    # Add the poisson noise\n    imdata .= rand.(rng, Poisson.(imdata))\n\n    # Add readnoise\n    imdata .+= rand(rng, Normal(0, 10), (N, N))\n\n    clean_image = copy(imdata)\n\n    # Add Nc fake cosmic rays\n    crmask = falses((N, N))\n\tfor i in 1:N_cosmics\n    \tcr_x = round(Int, rand(rng, Uniform(6, N - 5)))\n    \tcr_y = round(Int, rand(rng, Uniform(6, N - 5)))\n    \tcr_brightnesses = rand(rng, Uniform(1000, 30000))\n    \timdata[cr_y, cr_x] += cr_brightnesses\n    \tcrmask[cr_y, cr_x] = true\n\tend\n\n    # Make a mask where the detected cosmic rays should be\n    return (image=imdata, clean_image, mask=crmask)\nend\n\nrng = MersenneTwister(808)\ndata = make_data(rng, 201) (image = [188.58170768150052 214.09362006840362 … 204.15202016042792 174.58109503250085; 202.09914267128877 183.6972497338309 … 203.6666879254898 204.72346481491394; … ; 193.09513217045617 166.82428246193842 … 163.70511533689998 183.12325388575027; 228.6225661704681 189.5528435387213 … 202.46161451180063 199.53550046618867], clean_image = [188.58170768150052 214.09362006840362 … 204.15202016042792 174.58109503250085; 202.09914267128877 183.6972497338309 … 203.6666879254898 204.72346481491394; … ; 193.09513217045617 166.82428246193842 … 163.70511533689998 183.12325388575027; 228.6225661704681 189.5528435387213 … 202.46161451180063 199.53550046618867], mask = Bool[0 0 … 0 0; 0 0 … 0 0; … ; 0 0 … 0 0; 0 0 … 0 0]) let's inspect it using Plots\n\nfunction imshow(image; kwargs...)\n\taxy, axx = axes(image)\n\theatmap(axy, axx, image;\n        aspect_ratio=1,\n        ticks=false,\n        xlim=extrema(axx),\n        ylim=extrema(axy),\n        kwargs...)\nend\n\nplot(\n    imshow(log10.(data.clean_image), title=\"original image\"),\n    imshow(log10.(data.image), title=\"image w/cosmics\"),\n    size=(775, 350)\n) now we can clean it using  lacosmic using LACosmic\n\nclean_image, mask = lacosmic(data.image, sigma_clip=6, contrast=5, neighbor_thresh=1)\n\nplot(\n    imshow(log10.(data.clean_image), title=\"original image\"),\n    imshow(log10.(clean_image), title=\"cleaned image\"),\n    size=(775, 350)\n) plot(\n    imshow(data.mask, title=\"true cosmics\", cbar=false),\n    imshow(mask, title=\"detected cosmics\", cbar=false),\n    size=(700, 400)\n) data.mask == mask true"},{"id":447,"pagetitle":"Home","title":"Photometry.jl","ref":"/Photometry/stable/#Photometry.jl","content":" Photometry.jl"},{"id":448,"pagetitle":"Home","title":"Installation","ref":"/Photometry/stable/#Installation","content":" Installation To install from the REPL, enter Pkg-mode ( ] ) pkg> add Photometry"},{"id":449,"pagetitle":"Home","title":"Getting Started","ref":"/Photometry/stable/#Getting-Started","content":" Getting Started Here is a basic example to do some aperture photometry using  CircularAperture . The  photometry  function performs the photometry using a given method. using Photometry\ndata = ones(100, 100)\nerr = ones(100, 100)\n\nap1 = CircularAperture(50, 50, 3)\n# partial overlap\nap2 = CircularAperture(0.5, 0.5, 5)\n\nresults = photometry([ap1, ap2], data, err)\n@assert results.aperture_sum[1] ≈ 9π\n@assert results.aperture_sum[2] ≈ 25π / 4\n\nresults Table with 4 columns and 2 rows:\n     xcenter  ycenter  aperture_sum  aperture_sum_err\n   ┌─────────────────────────────────────────────────\n 1 │ 50.0     50.0     28.2743       5.31736\n 2 │ 0.5      0.5      19.635        4.43113"},{"id":450,"pagetitle":"Home","title":"Contributing","ref":"/Photometry/stable/#Contributing","content":" Contributing If you're interested in contributing, go ahead and check out the  issues  or make a  pull request . If you add a new feature, please write appropriate unit tests for it and bump the package's minor version."},{"id":451,"pagetitle":"Home","title":"License","ref":"/Photometry/stable/#License","content":" License The work derived from  astropy/photutils  is BSD 3-clause and the work derived from  kbarbary/sep  is BSD 3-clause. All other work is considered MIT expat. Therefore this work as a whole is BSD 3-clause.  LICENSE  contains all licenses and any files using derived work are noted at the top of the file."},{"id":454,"pagetitle":"Getting Started","title":"Aperture Photometry","ref":"/Photometry/stable/apertures/#Aperture-Photometry","content":" Aperture Photometry"},{"id":455,"pagetitle":"Getting Started","title":"Introduction","ref":"/Photometry/stable/apertures/#Introduction","content":" Introduction Aperture photometry uses  Apertures  to cut out and sum values in an image. A very basic mask might be a square of pixels at a certain position. We can model this as a matrix of ones and zeros like ⎡0 0 0 0 0⎤\n⎢0 1 1 1 0⎥\n⎢0 1 1 1 0⎥\n⎢0 1 1 1 0⎥\n⎣0 0 0 0 0⎦ If we have some data like ⎡7 9 6 0 8⎤\n⎢8 5 8 7 9⎥\n⎢5 6 2 2 7⎥\n⎢9 7 3 4 1⎥\n⎣7 8 0 9 8⎦ then the result of our aperture photometry looks like ⎡0 0 0 0 0⎤    ⎡7 9 6 0 8⎤     ⎡0 0 0 0 0⎤\n⎢0 1 1 1 0⎥    ⎢8 5 8 7 9⎥     ⎢0 5 8 7 0⎥\n⎢0 1 1 1 0⎥ .* ⎢5 6 2 2 7⎥  =  ⎢0 6 2 2 0⎥\n⎢0 1 1 1 0⎥    ⎢9 7 3 4 1⎥     ⎢0 7 3 4 0⎥\n⎣0 0 0 0 0⎦    ⎣7 8 0 9 8⎦     ⎣0 0 0 0 0⎦\n\nsum(result) = 44 This module uses the above principal with common aperture shapes in a fast and precise manner, including exact overlaps between apertures and pixels. The majority of the lifting is done with the  photometry  function with common shapes being described in  Apertures . It is possible to create a custom aperture by sub-typing the  Aperture.AbstractAperture  class, although it may be easier to perform PSF photometry instead."},{"id":456,"pagetitle":"Getting Started","title":"Pixel Convention","ref":"/Photometry/stable/apertures/#Pixel-Convention","content":" Pixel Convention Photometry.jl  follows the same convention as FITS, WCS, IRAF, DS9, and SourceExtractor with  (1, 1)  being the  center  on the bottom-left pixel. This means the exact bottom-left corner is at  (0.5, 0.5) . Pixels increase up and to the right until  axis_length + 0.5 ."},{"id":457,"pagetitle":"Getting Started","title":"API/Reference","ref":"/Photometry/stable/apertures/#API/Reference","content":" API/Reference"},{"id":458,"pagetitle":"Getting Started","title":"Photometry.Aperture.photometry","ref":"/Photometry/stable/apertures/#Photometry.Aperture.photometry","content":" Photometry.Aperture.photometry  —  Function photometry(::AbstractAperture, data::AbstractMatrix, [error]; [f = sum])\nphotometry(::AbstractVector{<:AbstractAperture}, data::AbstractMatrix, [error]; [f = sum]) Perform aperture photometry on  data  given aperture(s). If  error  (the pixel-wise standard deviation) is provided, will calculate sum error. If a list of apertures is provided the output will be a  TypedTables.Table , otherwise a  NamedTuple . An optional function  f  can be passed to return additional statistics within each aperture. This can be useful for, e.g., computing the PSF of each source. By default, just the sum within each aperture is returned. Tip This code is automatically multi-threaded. To take advantage of this please make sure  JULIA_NUM_THREADS  is set before starting your runtime. source"},{"id":459,"pagetitle":"Getting Started","title":"Performance","ref":"/Photometry/stable/apertures/#Performance","content":" Performance Below are some benchmarks comparing the aperture photometry capabilities of  Photometry.jl  with the  photutils  asropy package. The benchmark code can be found in the  bench  folder . Note that for the multi-threaded examples my machine has 4 physical cores with 8 threads. julia> versioninfo()\nJulia Version 1.5.0\nCommit 96786e22cc (2020-08-01 23:44 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin18.7.0)\n  CPU: Intel(R) Core(TM) i5-8259U CPU @ 2.30GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-9.0.1 (ORCJIT, skylake)"},{"id":460,"pagetitle":"Getting Started","title":"Number of Apertures","ref":"/Photometry/stable/apertures/#Number-of-Apertures","content":" Number of Apertures This benchmark shows how performance scales as we increase the number of apertures. The apertures are distributed randomly across the image with a fixed radius of 10. The image size is (512, 512). We see an improvement of ~10-100x (depending on multithreading) over photutils."},{"id":461,"pagetitle":"Getting Started","title":"Size of Apertures","ref":"/Photometry/stable/apertures/#Size-of-Apertures","content":" Size of Apertures This benchmark analyzes how the aperture size affects performance. Theoretically it should increase with  O(n^2)  complexity. For aperture sizes increasing from 1 to 200,  located in the center of a an image of size (512, 512)."},{"id":464,"pagetitle":"Apertures","title":"Apertures","ref":"/Photometry/stable/apertures/apertures/#Apertures","content":" Apertures All apertures will rely on a position and the shape parameters. aperture = Aperture(x0, y0, shape_params...) The position can be pixels or sky coordinates. The sky coordinate positions utilize  SkyCoords.jl  and  WCS.jl  for conversion. Warning Sky coordinates are not supported yet. Note See  Pixel Convention  - The origin is the bottom-left with  (1, 1)  being the center of the pixel."},{"id":465,"pagetitle":"Apertures","title":"API/Reference","ref":"/Photometry/stable/apertures/apertures/#API/Reference","content":" API/Reference"},{"id":466,"pagetitle":"Apertures","title":"Photometry.Aperture.AbstractAperture","ref":"/Photometry/stable/apertures/apertures/#Photometry.Aperture.AbstractAperture","content":" Photometry.Aperture.AbstractAperture  —  Type AbstractAperture{T} <: AbstractMatrix{T} The abstract super-type for Apertures. Apertures can be thought of as a cutout or stamp of a geometric shape with shading applied. For example, a circular aperture with a diameter of 3 pixels will require a 5x5 pixel grid (when perfectly on-grid) to represent. julia> ap = CircularAperture(3, 3, 2.5)\n5×5 CircularAperture{Float64} with indices 1:5×1:5:\n 0.136857  0.769325  0.983232  0.769325  0.136857\n 0.769325  1.0       1.0       1.0       0.769325\n 0.983232  1.0       1.0       1.0       0.983232\n 0.769325  1.0       1.0       1.0       0.769325\n 0.136857  0.769325  0.983232  0.769325  0.136857 This is a useful way of thinking about apertures: if we have some data, we can weight the data with the aperture. julia> data = fill(2, 5, 5);\n\njulia> idxs = map(intersect, axes(ap), axes(data)) |> CartesianIndices;\n\njulia> weighted_cutout = data[idxs] .* ap[idxs]\n5×5 Matrix{Float64}:\n 0.273713  1.53865  1.96646  1.53865  0.273713\n 1.53865   2.0      2.0      2.0      1.53865\n 1.96646   2.0      2.0      2.0      1.96646\n 1.53865   2.0      2.0      2.0      1.53865\n 0.273713  1.53865  1.96646  1.53865  0.273713 Performing aperture photometry is merely summing the weighted cutout shown above. julia> flux = sum(weighted_cutout)\n39.269908169872416\n\njulia> flux ≈ (π * 2.5^2) * 2 # area of circle times intensity of 2\ntrue What's interesting about the implementation of apertures, though, is they are lazy. This means there is no stored matrix of aperture values; rather, they are calculated on the fly as needed. julia> axes(ap)\n(1:5, 1:5)\n\njulia> ap[-10, -10] # out-of-bounds, but calculated on the fly\n0.0\n\njulia> ap .* ones(5, 7) # broadcasts to eachindex(data), regardless of ap bound\n5×7 Matrix{Float64}:\n 0.136857  0.769325  0.983232  0.769325  0.136857  0.0  0.0\n 0.769325  1.0       1.0       1.0       0.769325  0.0  0.0\n 0.983232  1.0       1.0       1.0       0.983232  0.0  0.0\n 0.769325  1.0       1.0       1.0       0.769325  0.0  0.0\n 0.136857  0.769325  0.983232  0.769325  0.136857  0.0  0.0 This allows extremely efficient computation of aperture photometry from small to medium sized apertures. julia> using BenchmarkTools\n\njulia> @btime sum(idx -> $ap[idx] * $data[idx], $idxs)\n  1.097 μs (0 allocations: 0 bytes)\n39.26990816987243 This is essentially the full implementation of  photometry , save for the packing of additional information into a tabular form. source"},{"id":467,"pagetitle":"Apertures","title":"Photometry.Aperture.Subpixel","ref":"/Photometry/stable/apertures/apertures/#Photometry.Aperture.Subpixel","content":" Photometry.Aperture.Subpixel  —  Type Subpixel(ap, N=1) <: AbstractAperture Use a subpixel quadrature approximation for pixel shading instead of exact geometric methods. For any pixel laying on the border of  ap , this alters the shading algorithm by breaking the border pixel up into  (N, N)  subpixels. The shading value is the fraction of these subpixels within the geometric border of  ap . Using a subpixel shading method is sometimes faster than exact methods at the cost of accuracy. For  CircularAperture  the subpixel method is only faster than the exact method for  N  ~ 7. for  EllipticalAperture  the cutoff is  N  ~ 12, and for  RectangularAperture  the cutoff is  N  ~ 20. Examples julia> ap = CircularAperture(3, 3, 2.5)\n5×5 CircularAperture{Float64} with indices 1:5×1:5:\n 0.136857  0.769325  0.983232  0.769325  0.136857\n 0.769325  1.0       1.0       1.0       0.769325\n 0.983232  1.0       1.0       1.0       0.983232\n 0.769325  1.0       1.0       1.0       0.769325\n 0.136857  0.769325  0.983232  0.769325  0.136857\n\njulia> sub_ap = Subpixel(ap, 5)\n5×5 Subpixel{Float64, CircularAperture{Float64}} with indices 1:5×1:5:\n 0.12  0.76  1.0  0.76  0.12\n 0.76  1.0   1.0  1.0   0.76\n 1.0   1.0   1.0  1.0   1.0\n 0.76  1.0   1.0  1.0   0.76\n 0.12  0.76  1.0  0.76  0.12 Note photutils  offers a  center  shading method which is equivalent to using the  Subpixel  method with 1 subpixel. To avoid unneccessary namespace cluttering, we simply instruct users to use  Subpixel(ap)  instead. source"},{"id":468,"pagetitle":"Apertures","title":"Photometry.Aperture.area_arc","ref":"/Photometry/stable/apertures/apertures/#Photometry.Aperture.area_arc","content":" Photometry.Aperture.area_arc  —  Function Area of a circular segment above a chord between two points with circle radius  r Reference source"},{"id":469,"pagetitle":"Apertures","title":"Photometry.Aperture.circular_overlap_core","ref":"/Photometry/stable/apertures/apertures/#Photometry.Aperture.circular_overlap_core","content":" Photometry.Aperture.circular_overlap_core  —  Function Core of circular overlap routine source"},{"id":470,"pagetitle":"Apertures","title":"Photometry.Aperture.circular_overlap_single_exact","ref":"/Photometry/stable/apertures/apertures/#Photometry.Aperture.circular_overlap_single_exact","content":" Photometry.Aperture.circular_overlap_single_exact  —  Function Area of overlap between a rectangle and a circle source"},{"id":471,"pagetitle":"Apertures","title":"Photometry.Aperture.inside_ellipse","ref":"/Photometry/stable/apertures/apertures/#Photometry.Aperture.inside_ellipse","content":" Photometry.Aperture.inside_ellipse  —  Function inside_ellipse(x, y, h, k, cxx, cyy, cxy) x: x coordinate of the test point y: y coordinate of the test point h: x coordinate of the center of ellipse k: y coordinate of the center of ellipse cxx, cyy, cxy: coefficients of equation of ellipse Utility function to find whether a point is inside ellipse or not. If point inside ellipse: Returns true else returns false General equation of ellipse:     cxx * (x - h)^2 + cxy * (x - h) * (y - k) + cyy * (y - k)^2 = 1 source"},{"id":472,"pagetitle":"Apertures","title":"Base.size","ref":"/Photometry/stable/apertures/apertures/#Base.size-Tuple{Photometry.Aperture.AbstractAperture}","content":" Base.size  —  Method size(::AbstractAperture) Return ( ny ,  nx ) of the aperture. source"},{"id":473,"pagetitle":"Apertures","title":"Photometry.Aperture.area_triangle","ref":"/Photometry/stable/apertures/apertures/#Photometry.Aperture.area_triangle","content":" Photometry.Aperture.area_triangle  —  Function Area of a triangle defined by three vertices source"},{"id":474,"pagetitle":"Apertures","title":"Photometry.Aperture.inside_rectangle","ref":"/Photometry/stable/apertures/apertures/#Photometry.Aperture.inside_rectangle","content":" Photometry.Aperture.inside_rectangle  —  Function intersection with rectangular using implicit Lamé curve source"},{"id":475,"pagetitle":"Apertures","title":"Photometry.Aperture.bounds","ref":"/Photometry/stable/apertures/apertures/#Photometry.Aperture.bounds","content":" Photometry.Aperture.bounds  —  Function bounds(::AbstractAperture) Return the ( xlow ,  xhigh ,  ylow ,  yhigh ) bounds for a given Aperture. source"},{"id":476,"pagetitle":"Apertures","title":"Circular Apertures","ref":"/Photometry/stable/apertures/apertures/#Circular-Apertures","content":" Circular Apertures These apertures are parameterized by radius."},{"id":477,"pagetitle":"Apertures","title":"Photometry.Aperture.CircularAperture","ref":"/Photometry/stable/apertures/apertures/#Photometry.Aperture.CircularAperture","content":" Photometry.Aperture.CircularAperture  —  Type CircularAperture(x, y, r)\nCircularAperture(position, r) A circular aperture. A circular aperture with radius  r .  r  must be greater than or equal to 0. Examples julia> ap = CircularAperture(0, 0, 10)\n21×21 CircularAperture{Int64} with indices -10:10×-10:10:\n 0          0         0           …  0           0         0\n 0          0         0              0           0         0\n 0          0         0              0           0         0\n 0          0         0.00571026     0.00571026  0         0\n 0          0         0.491844       0.491844    0         0\n 0          0.170878  0.982952    …  0.982952    0.170878  0\n 0          0.659735  1              1           0.659735  0\n 0.0590655  0.975524  1              1           0.975524  0.0590655\n 0.293527   1         1              1           1         0.293527\n 0.445643   1         1              1           1         0.445643\n ⋮                                ⋱                        ⋮\n 0.293527   1         1              1           1         0.293527\n 0.0590655  0.975524  1              1           0.975524  0.0590655\n 0          0.659735  1              1           0.659735  0\n 0          0.170878  0.982952    …  0.982952    0.170878  0\n 0          0         0.491844       0.491844    0         0\n 0          0         0.00571026     0.00571026  0         0\n 0          0         0              0           0         0\n 0          0         0              0           0         0\n 0          0         0           …  0           0         0 source"},{"id":478,"pagetitle":"Apertures","title":"Photometry.Aperture.CircularAnnulus","ref":"/Photometry/stable/apertures/apertures/#Photometry.Aperture.CircularAnnulus","content":" Photometry.Aperture.CircularAnnulus  —  Type CircularAnnulus(x, y, r_in, r_out)\nCircularAnnulus(position, r_in, r_out) A circular annulus with inner radius  r_in  and outer radius  r_out . 0 ≤  r_in  ≤  r_out . Examples julia> ap = CircularAnnulus(0, 0, 5, 10)\n21×21 CircularAnnulus{Int64} with indices -10:10×-10:10:\n 0          0         0           …  0           0         0\n 0          0         0              0           0         0\n 0          0         0              0           0         0\n 0          0         0.00571026     0.00571026  0         0\n 0          0         0.491844       0.491844    0         0\n 0          0.170878  0.982952    …  0.982952    0.170878  0\n 0          0.659735  1              1           0.659735  0\n 0.0590655  0.975524  1              1           0.975524  0.0590655\n 0.293527   1         1              1           1         0.293527\n 0.445643   1         1              1           1         0.445643\n ⋮                                ⋱                        ⋮\n 0.293527   1         1              1           1         0.293527\n 0.0590655  0.975524  1              1           0.975524  0.0590655\n 0          0.659735  1              1           0.659735  0\n 0          0.170878  0.982952    …  0.982952    0.170878  0\n 0          0         0.491844       0.491844    0         0\n 0          0         0.00571026     0.00571026  0         0\n 0          0         0              0           0         0\n 0          0         0              0           0         0\n 0          0         0           …  0           0         0 source"},{"id":479,"pagetitle":"Apertures","title":"Elliptical Apertures","ref":"/Photometry/stable/apertures/apertures/#Elliptical-Apertures","content":" Elliptical Apertures These apertures are parameterized by the semi-major axis  a , semi-minor axis  b  and position angle in degrees counter-clockwise from the positive x-axis  θ"},{"id":480,"pagetitle":"Apertures","title":"Photometry.Aperture.EllipticalAperture","ref":"/Photometry/stable/apertures/apertures/#Photometry.Aperture.EllipticalAperture","content":" Photometry.Aperture.EllipticalAperture  —  Type EllipticalAperture(x, y, a, b, θ=0)\nEllipticalAperture(position, a, b, θ=0) An elliptical aperture with semi-major axis  a , semi-minor axis  b , and position angle  θ .  a  and  b  must be ≥ 0,  θ  is measured in degrees counter-clockwise the standard x-axis. Examples julia> ap = EllipticalAperture(0, 0, 4, 2, 35)\n7×5 EllipticalAperture{Int64} with indices -3:3×-2:2:\n 0.873382  0.844185  0.324917  0         0\n 1         1         0.997821  0.435284  0\n 1         1         1         0.990119  0.23968\n 0.796137  1         1         1         0.796137\n 0.23968   0.990119  1         1         1\n 0         0.435284  0.997821  1         1\n 0         0         0.324917  0.844185  0.873382 source"},{"id":481,"pagetitle":"Apertures","title":"Photometry.Aperture.EllipticalAnnulus","ref":"/Photometry/stable/apertures/apertures/#Photometry.Aperture.EllipticalAnnulus","content":" Photometry.Aperture.EllipticalAnnulus  —  Type EllipticalAnnulus(x, y, a_in, a_out, b_out, θ=0)\nEllipticalAnnulus(position, a_in, a_out, b_out, θ=0) An elliptical annulus with inner semi-major axis  a_in , outer semi-major axis  a_out , outer semi-minor axis  b_out , and position angle  θ .  a_out  ≥  a_in  ≥ 0 and  b_out  must be ≥ 0,  θ  is measured in degrees counter-clockwise the standard x-axis. b_in  will automatically be calculated from  (a_in / a_out) * b_out . Note this may cause a type instability. Examples julia> ap = EllipticalAnnulus(0, 0, 4, 10, 5, 45)\n15×15 EllipticalAnnulus{Float64} with indices -7:7×-7:7:\n 0.594853   1.0       1.0       1.0         …  0.0       0.0       0.0\n 1.0        1.0       1.0       1.0            0.0       0.0       0.0\n 1.0        1.0       1.0       1.0            0.0       0.0       0.0\n 1.0        1.0       1.0       1.0            0.0       0.0       0.0\n 1.0        1.0       1.0       1.0            0.0       0.0       0.0\n 0.814163   1.0       1.0       1.0         …  0.414163  0.0       0.0\n 0.369432   1.0       1.0       1.0            0.975704  0.193728  0.0\n 0.0112571  0.809079  1.0       1.0            1.0       0.809079  0.0112571\n 0.0        0.193728  0.975704  1.0            1.0       1.0       0.369432\n 0.0        0.0       0.414163  1.0            1.0       1.0       0.814163\n 0.0        0.0       0.0       0.546165    …  1.0       1.0       1.0\n 0.0        0.0       0.0       0.00252321     1.0       1.0       1.0\n 0.0        0.0       0.0       0.0            1.0       1.0       1.0\n 0.0        0.0       0.0       0.0            1.0       1.0       1.0\n 0.0        0.0       0.0       0.0            1.0       1.0       0.594853 source"},{"id":482,"pagetitle":"Apertures","title":"Rectangular Apertures","ref":"/Photometry/stable/apertures/apertures/#Rectangular-Apertures","content":" Rectangular Apertures These apertures are parameterized by width  w , height  h , and position angle in degrees counter-clockwise from the positive x-axis  θ ."},{"id":483,"pagetitle":"Apertures","title":"Photometry.Aperture.RectangularAperture","ref":"/Photometry/stable/apertures/apertures/#Photometry.Aperture.RectangularAperture","content":" Photometry.Aperture.RectangularAperture  —  Type RectangularAperture(x, y, w, h, θ=0)\nRectangularAperture(position, w, h, θ=0) A rectangular aperture. A rectangular aperture with width  w , height  h , and position angle  θ  in degrees. Examples julia> ap = RectangularAperture(0, 0, 10, 4, 0)\n11×5 RectangularAperture{Int64} with indices -5:5×-2:2:\n 0.25  0.5  0.5  0.5  0.25\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.25  0.5  0.5  0.5  0.25 source"},{"id":484,"pagetitle":"Apertures","title":"Photometry.Aperture.RectangularAnnulus","ref":"/Photometry/stable/apertures/apertures/#Photometry.Aperture.RectangularAnnulus","content":" Photometry.Aperture.RectangularAnnulus  —  Type RectangularAnnulus(x, y, w_in, w_out, h_out, θ=0)\nRectangularAnnulus(position, w_in, w_out, h_out, θ=0) A rectangular annulus with inner width  w_in , outer width  w_out , outer height  h_out , and position angle  θ  in degrees.  h_in  is automatically calculated from  w_in / w_out * h_out . Note that  w_out ≥ w_in > 0 . Examples julia> ap = RectangularAnnulus(0, 0, 5, 10, 8, 45)\n13×13 RectangularAnnulus{Float64} with indices -6:6×-6:6:\n 0.0       0.0       0.0         …  0.0         0.0       0.0\n 0.0       0.0       0.0            0.0         0.0       0.0\n 0.0       0.0       0.00252532     0.0         0.0       0.0\n 0.0       0.0       0.568542       0.0         0.0       0.0\n 0.0       0.568542  1.0            0.215729    0.0       0.0\n 0.528175  1.0       1.0         …  1.0         0.215729  0.0\n 0.215729  1.0       1.0            1.0         1.0       0.215729\n 0.0       0.215729  1.0            1.0         1.0       0.528175\n 0.0       0.0       0.215729       1.0         0.568542  0.0\n 0.0       0.0       0.0            0.568542    0.0       0.0\n 0.0       0.0       0.0         …  0.00252532  0.0       0.0\n 0.0       0.0       0.0            0.0         0.0       0.0\n 0.0       0.0       0.0            0.0         0.0       0.0 source"},{"id":487,"pagetitle":"Examples","title":"Examples","ref":"/Photometry/stable/apertures/examples/#Examples","content":" Examples"},{"id":488,"pagetitle":"Examples","title":"Plotting","ref":"/Photometry/stable/apertures/examples/#Plotting","content":" Plotting We have recipes for all our aperture types, so you can easily create overlays on your images. using Photometry\nusing Plots\n\nplot(CircularAperture(2, 3, 4), c=1, xlims=(-1, 12), ylims=(0, 9))\nplot!(CircularAnnulus(5, 5, 2.1, 3), c=2)\nplot!(EllipticalAperture(0, 0, 10, 1, 32), c=3)\nplot!(EllipticalAnnulus(5, 5, 4, 5, 2, -32), c=4)\nplot!(RectangularAperture(0, 0, 4, 4, 4), c=5)\nplot!(RectangularAnnulus(5, 1, 3, 4, 4, 4), c=6)"},{"id":489,"pagetitle":"Examples","title":"Simple Stars","ref":"/Photometry/stable/apertures/examples/#Simple-Stars","content":" Simple Stars Here is an example where we will find aperture fluxes for stars from M67. The dataset is provided as part of the  astropy/photutils-datasets  repository. Let's start by downloading and showing our image using Photometry\nusing Plots\nusing FITSIO\n\n# Load data in\nurl = \"https://rawcdn.githack.com/astropy/photutils-datasets/8c97b4fa3a6c9e6ea072faeed2d49a20585658ba/data/M6707HH.fits\"\nhdu = FITS(download(url))\nchunk = read(hdu[1], 81:155, 71:150)\n\n# Plot\nfunction imshow(image; kwargs...)\n    xs, ys = axes(image)\n    data = transpose(image)\n    heatmap(xs, ys, data; aspect_ratio=1, xlim=extrema(xs), ylim=extrema(ys), kwargs...)\nend\n\nimshow(chunk) Now let's add some apertures! positions = [\n    [47.5 , 67.5],\n    [29.5 , 62.5],\n    [23.5 , 48.5],\n    [17.5 , 29.5],\n    [13.25, 10.5],\n    [65.5 , 14.0]\n]\n\nradii = [3, 3, 2.7, 2, 2.7, 3]\n\naps = CircularAperture.(positions, radii) 6-element Vector{CircularAperture{Float64}}:\n CircularAperture(47.5, 67.5, r=3.0)\n CircularAperture(29.5, 62.5, r=3.0)\n CircularAperture(23.5, 48.5, r=2.7)\n CircularAperture(17.5, 29.5, r=2.0)\n CircularAperture(13.25, 10.5, r=2.7)\n CircularAperture(65.5, 14.0, r=3.0) now let's plot them up imshow(chunk)\nplot!(aps, c=:white) and finally let's get our output table for the photometry table = photometry(aps, chunk) Table with 3 columns and 6 rows:\n     xcenter  ycenter  aperture_sum\n   ┌───────────────────────────────\n 1 │ 47.5     67.5     2.48267e5\n 2 │ 29.5     62.5     2.25989e5\n 3 │ 23.5     48.5     1.49979e5\n 4 │ 17.5     29.5     72189.4\n 5 │ 13.25    10.5     1.48118e5\n 6 │ 65.5     14.0     2.02803e5"},{"id":490,"pagetitle":"Examples","title":"Stars with Spatial Background Subtraction and PSF Fitting","ref":"/Photometry/stable/apertures/examples/#Stars-with-Spatial-Background-Subtraction-and-PSF-Fitting","content":" Stars with Spatial Background Subtraction and PSF Fitting This example will be the same as  Simple Stars  but will add background and PSF estimation using the tools in  Background Estimation  and  PSFModels.jl . clipped = sigma_clip(chunk, 1, fill=NaN)\n# Estimate 2D spatial background using boxes of size (5, 5)\nbkg, bkg_rms = estimate_background(clipped, 5)\n\nplot(\n    imshow(chunk, title=\"Original\"),\n    imshow(clipped, title=\"Sigma-Clipped\"),\n    imshow(bkg, title=\"Background\"),\n    imshow(bkg_rms, title=\"Background RMS\");\n    layout=(2, 2), size=(600, 600), ticks=false\n) Now, using the same apertures, let's find the output using the background-subtracted image plot(\n    imshow(chunk, title=\"Original\"),\n    imshow(chunk .- bkg, title=\"Subtracted\");\n    layout=2, size=(600, 260), ticks=false, colorbar=false\n)\nplot!(aps, c=:white, subplot=1)\nplot!(aps, c=:white, subplot=2) using PSFModels\n\nfunction fit_psf(img_ap)\n    # Normalize\n    psf_data = collect(Float32, img_ap)\n    psf_data ./= maximum(psf_data)\n\n    # Set params\n    y, x = Tuple(argmax(psf_data))\n    fwhm = 5.0\n    params = (; x, y, fwhm)\n\n    # Fit\n    psf_params, psf_model = PSFModels.fit(gaussian, params, psf_data; x_abstol = 2e-6)\n\n    # Could also return a Tuple to display more information.\n    # Just returning fitted FWHM here for simplicity.\n    return psf_params.fwhm\nend\n\ntable = photometry(aps, chunk .- bkg, bkg_rms; f = fit_psf) Table with 5 columns and 6 rows:\n     xcenter  ycenter  aperture_sum  aperture_sum_err  aperture_f\n   ┌─────────────────────────────────────────────────────────────\n 1 │ 47.5     67.5     2.13534e5     431.48            4.19789\n 2 │ 29.5     62.5     114217.0      887.37            3.46587\n 3 │ 23.5     48.5     59230.7       1061.28           2.58725\n 4 │ 17.5     29.5     23159.6       697.556           2.32789\n 5 │ 13.25    10.5     54638.1       1048.67           2.51242\n 6 │ 65.5     14.0     91179.1       1168.71           3.09683"},{"id":493,"pagetitle":"Getting Started","title":"Background Estimation","ref":"/Photometry/stable/background/#Background-Estimation","content":" Background Estimation The module provides tools and algorithms for estimating the background of astronomical data."},{"id":494,"pagetitle":"Getting Started","title":"Usage","ref":"/Photometry/stable/background/#Usage","content":" Usage Estimating backgrounds is an important step in performing photometry. Ideally, we could perfectly describe the background with a scalar value or with some distribution. Unfortunately, it's impossible for us to precisely separate the background and foreground signals. Here, we use mixture of robust statistical estimators and meshing to let us get the spatially varying background from an astronomical photo. Let's show an example using Photometry\nusing FITSIO\nusing Plots\n\n# Download our image, courtesy of astropy\nurl = \"https://rawcdn.githack.com/astropy/photutils-datasets/8c97b4fa3a6c9e6ea072faeed2d49a20585658ba/data/M6707HH.fits\"\nhdu = FITS(download(url))\nimage = read(hdu[1])\n\n# Plot\nfunction imshow(image; kwargs...)\n    xs, ys = axes(image)\n    data = transpose(image)\n    heatmap(xs, ys, data;\n            aspect_ratio=1,\n            xlim=extrema(xs), ylim=extrema(ys),\n            kwargs...)\nend\n\nimshow(image) Now let's try and estimate the background using  estimate_background . First, we'll sigma-clip to try and remove the signals from the stars. Then, the background is broken down into boxes, in this case of size  (50, 50) . Within each box, the given statistical estimators get the background value and RMS. By default, we use  SourceExtractorBackground  and  StdRMS . This creates a low-resolution image, which we then need to resize. We can accomplish this using an interpolator, by default a cubic-spline interpolator via  ZoomInterpolator . The end result is a smooth estimate of the spatially varying background and background RMS. # sigma-clip\nclipped = sigma_clip(image, 1, fill=NaN)\n\n# get background and background rms with box-size (50, 50)\nbkg, bkg_rms = estimate_background(clipped, 50)\n\n# plot\nplot(\n    imshow(image, title=\"Original\"),\n    imshow(clipped, title=\"Sigma-Clipped\"),\n    imshow(bkg, title=\"Background\"),\n    imshow(bkg_rms, title=\"Background RMS\"),\n    layout=(2, 2), ticks=false,\n) We could apply a median filter, too, by specifying  filter_size # get background and background rms with box-size (50, 50) and filter_size (5, 5)\nbkg_f, bkg_rms_f = estimate_background(clipped, 50, filter_size=5)\n\n# plot\nplot(\n    imshow(bkg, title=\"Unfiltered\", ylabel=\"Background\"),\n    imshow(bkg_f, title=\"Filtered\"),\n    imshow(bkg_rms, ylabel=\"RMS\"),\n    imshow(bkg_rms_f);\n    layout=(2, 2), ticks=false,\n) Now we can see our image after subtracting the filtered background and ready for  Aperture Photometry ! subt = image .- bkg_f[axes(image)...]\nplot(\n    imshow(image, title=\"Original\", colorbar=false),\n    imshow(subt, title=\"Subtracted\");\n    layout=(1, 2), size=(600, 260),\n    xlims=(400, 800), ylims=(400, 800),\n    clims=(minimum(subt), maximum(image)),\n    ticks=false, aspect_ratio=1,\n)"},{"id":495,"pagetitle":"Getting Started","title":"IDW Interpolator","ref":"/Photometry/stable/background/#IDW-Interpolator","content":" IDW Interpolator Here is a quick example using the  IDWInterpolator b1, r1 = estimate_background(clipped, 50, filter_size=5)\nb2, r2 = estimate_background(clipped, 50, itp=IDWInterpolator(50), filter_size=5)\n\nplot(\n    imshow(b1, title=\"ZoomInterpolator\", ylabel=\"Background\"),\n    imshow(b2, title=\"IDWInterpolator\"),\n    imshow(r1, ylabel=\"RMS\"),\n    imshow(r2);\n    layout=(2, 2), ticks=false,\n)"},{"id":496,"pagetitle":"Getting Started","title":"API/Reference","ref":"/Photometry/stable/background/#API/Reference","content":" API/Reference"},{"id":497,"pagetitle":"Getting Started","title":"Photometry.Background.estimate_background","ref":"/Photometry/stable/background/#Photometry.Background.estimate_background","content":" Photometry.Background.estimate_background  —  Function estimate_background(data;\n    location=SourceExtractorBackground(),\n    rms=StdRMS(),\n    dims=:) Perform scalar background estimation using the given estimators. The value returned will be two values corresponding to the estimated background and the estimated background RMS. The dimensionality will depend on the  dims  keyword. location  and  rms  can be anything that is callable, for example  median , or one of the estimators we provide in  Background Estimators . Examples julia> data = ones(3, 5);\n\njulia> bkg, bkg_rms = estimate_background(data)\n(1.0, 0.0)\n\njulia> using Statistics: median\n\njulia> bkg, bkg_rms = estimate_background(data; location=median, rms=MADStdRMS())\n(1.0, 0.0) See Also Location Estimators ,  RMS Estimators source estimate_background(data, box_size;\n    location=SourceExtractorBackground(),\n    rms=StdRMS(),\n    itp=ZoomInterpolator(box_size),\n    edge_method=:pad,\n    [filter_size]) Perform 2D background estimation using the given estimators mapped over windows of the data. This function will estimate backgrounds in boxes of size  box_size . When  size(data)  is not an integer multiple of the box size, there are two edge methods:  :pad  and  :crop . The default is to pad (and is recommend to avoid losing image data). If  box_size  is an integer, the implicit shape will be square (eg.  box_size=4  is equivalent to  box_size=(4,4) ). For evaluating the meshes, each box will be passed into  location  to estimate the background and then into  rms  to estimate the background root-mean-square value. These can be anything that is callable, like  median  or one of our  Background Estimators . Once the meshes are created they will be median filtered if  filter_size  is given.  filter_size  can be either an integer or a tuple, with the integer being converted to a tuple the same way  box_size  is. Filtering is done via  ImageFiltering.MapWindow.mapwindow .  filter_size  must be odd. After filtering (if applicable), the meshes are passed to the  itp  to recreate a low-order estimate of the background at the same resolution as the input. Note If your  box_size  is not an integer multiple of the input size, the output background and rms arrays will not have the same size. See Also Location Estimators ,  RMS Estimators ,  Interpolators source"},{"id":498,"pagetitle":"Getting Started","title":"Photometry.Background.sigma_clip","ref":"/Photometry/stable/background/#Photometry.Background.sigma_clip","content":" Photometry.Background.sigma_clip  —  Function sigma_clip(x, sigma; fill=:clamp, center=median(x), std=std(x, corrected=false))\nsigma_clip(x, sigma_low, sigma_high; fill=:clamp, center=median(x), std=std(x, corrected=false)) This function returns sigma-clipped values of the input  x . Specify the upper and lower bounds with  sigma_low  and  sigma_high , otherwise assume they are equal.  center  and  std  are optional keyword arguments which are functions for finding central element and standard deviation. If  fill === :clamp , this will clamp values in  x  lower than  center - sigma_low * std  and values higher than  center + sigma_high * std . Otherwise, they will be replaced with  fill . Examples julia> x = randn(100_000);\n\njulia> extrema(x)\n(-4.65966935309312, 3.9422613516325216)\n\njulia> x_clip = sigma_clip(x, 1);\n\njulia> extrema(x_clip) # should be close to (-1, 1)\n(-1.0041231879487236, 0.9956450634240993) source"},{"id":499,"pagetitle":"Getting Started","title":"Photometry.Background.sigma_clip!","ref":"/Photometry/stable/background/#Photometry.Background.sigma_clip!","content":" Photometry.Background.sigma_clip!  —  Function sigma_clip!(x, sigma; fill=:clamp, center=median(x), std=std(x))\nsigma_clip!(x, sigma_low, sigma_high; fill=:clamp, center=median(x), std=std(x)) In-place version of  sigma_clip Warning sigma_clip!  mutates the element in place and mutation cannot lead to change in type. Please be considerate of your input type, because if you are using  Int64  and we try to clip it to  0.5  an  InexactError  will be thrown. To avoid this, we recommend converting to float before clipping, or using  sigma_clip  which does this internally. source"},{"id":500,"pagetitle":"Getting Started","title":"Photometry.Background.validate_SE","ref":"/Photometry/stable/background/#Photometry.Background.validate_SE","content":" Photometry.Background.validate_SE  —  Function Utility function for SourceExtractorBackground algorithm source"},{"id":503,"pagetitle":"Background Estimators","title":"Background Estimators","ref":"/Photometry/stable/background/estimators/#Background-Estimators","content":" Background Estimators All of these estimators are subtypes of  Background.LocationEstimator  or  Background.RMSEstimator  and are derived using various statistical and image processing methods."},{"id":504,"pagetitle":"Background Estimators","title":"Location Estimators","ref":"/Photometry/stable/background/estimators/#Location-Estimators","content":" Location Estimators These estimators are used for estimating the background using some form of a central statistic."},{"id":505,"pagetitle":"Background Estimators","title":"Photometry.Background.LocationEstimator","ref":"/Photometry/stable/background/estimators/#Photometry.Background.LocationEstimator","content":" Photometry.Background.LocationEstimator  —  Type Background.LocationEstimator This abstract type embodies the possible background estimation algorithms for dispatch with  estimate_background . To implement a new estimator, you must define the struct and define a method like  (::MyEstimator)(data::AbstractArray; dims=:) . See Also Location Estimators source"},{"id":506,"pagetitle":"Background Estimators","title":"Photometry.Background.MMMBackground","ref":"/Photometry/stable/background/estimators/#Photometry.Background.MMMBackground","content":" Photometry.Background.MMMBackground  —  Type MMMBackground(median_factor=3, mean_factor=2) Estimate the background using a mode estimator of the form  median_factor * median - mean_factor * mean . This algorithm is based on the  MMMBackground  routine originally implemented in DAOPHOT.  MMMBackground  uses factors of  median_factor=3  and  mean_factor=2  by default. This estimator assumes that contaminated sky pixel values overwhelmingly display positive departures from the true value. Examples julia> x = ones(3, 5);\n\njulia> MMMBackground()(x)\n1.0\n\njulia> MMMBackground(median_factor=4, mean_factor=3)(x, dims = 1)\n1×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0 See Also SourceExtractorBackground source"},{"id":507,"pagetitle":"Background Estimators","title":"Photometry.Background.SourceExtractorBackground","ref":"/Photometry/stable/background/estimators/#Photometry.Background.SourceExtractorBackground","content":" Photometry.Background.SourceExtractorBackground  —  Type SourceExtractorBackground() This estimator returns the background of the input using the SourceExtractorBackground algorithm. The background is calculated using a mode estimator of the form  (2.5 * median) - (1.5 * mean) . If  (mean - median) / std > 0.3  then the median is used and if  std = 0  then the mean is used. Examples julia> data = ones(3, 5);\n\njulia> SourceExtractorBackground()(data)\n1.0\n\njulia> SourceExtractorBackground()(data, dims=1)\n1×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0 source"},{"id":508,"pagetitle":"Background Estimators","title":"Photometry.Background.BiweightLocationBackground","ref":"/Photometry/stable/background/estimators/#Photometry.Background.BiweightLocationBackground","content":" Photometry.Background.BiweightLocationBackground  —  Type BiweightLocationBackground(c = 6.0, M = nothing) Estimate the background using the robust biweight location statistic. \\[ξ_{biloc} = M + \\frac{∑_{|uᵢ|<1}{(xᵢ - M)(1 - uᵢ²)²}}{∑_{|uᵢ|<1}{(1-uᵢ²)²}}\\] \\[u_i = \\frac{(x_i - M)}{c⋅\\mathrm{MAD}(x)}\\] Where  $\\mathrm{MAD}(x)$  is median absolute deviation of  x . Examples julia> x = ones(3,5);\n\njulia> BiweightLocationBackground()(x)\n1.0\n\njulia> BiweightLocationBackground(c=5.5)(x; dims = 1)\n1×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0 source"},{"id":509,"pagetitle":"Background Estimators","title":"RMS Estimators","ref":"/Photometry/stable/background/estimators/#RMS-Estimators","content":" RMS Estimators These estimators are used for estimating the root-mean-square (RMS) of the background using some form of a deviation statistic."},{"id":510,"pagetitle":"Background Estimators","title":"Photometry.Background.RMSEstimator","ref":"/Photometry/stable/background/estimators/#Photometry.Background.RMSEstimator","content":" Photometry.Background.RMSEstimator  —  Type Background.RMSEstimator This abstract type embodies the possible background RMS estimation algorithms for dispatch with  estimate_background . To implement a new estimator, you must define the struct and define a method like  (::MyRMSEstimator)(data::AbstractArray; dims=:) . See Also RMS Estimators source"},{"id":511,"pagetitle":"Background Estimators","title":"Photometry.Background.StdRMS","ref":"/Photometry/stable/background/estimators/#Photometry.Background.StdRMS","content":" Photometry.Background.StdRMS  —  Type StdRMS() Uses the standard deviation statistic for background RMS estimation. Examples julia> data = ones(3, 5);\n\njulia> StdRMS()(data)\n0.0\n\njulia> StdRMS()(data, dims=1)\n1×5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0 source"},{"id":512,"pagetitle":"Background Estimators","title":"Photometry.Background.MADStdRMS","ref":"/Photometry/stable/background/estimators/#Photometry.Background.MADStdRMS","content":" Photometry.Background.MADStdRMS  —  Type MADStdRMS() Uses the standard median absolute deviation (MAD) statistic for background RMS estimation. This is typically given as $σ ≈ 1.4826 ⋅ \\mathrm{MAD}$ Examples julia> data = ones(3, 5);\n\njulia> MADStdRMS()(data)\n0.0\n\njulia> MADStdRMS()(data, dims=1)\n1×5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0 source"},{"id":513,"pagetitle":"Background Estimators","title":"Photometry.Background.BiweightScaleRMS","ref":"/Photometry/stable/background/estimators/#Photometry.Background.BiweightScaleRMS","content":" Photometry.Background.BiweightScaleRMS  —  Type BiweightScaleRMS(c=9.0, M=nothing) Uses the robust biweight scale statistic for background RMS estimation. The biweight scale is the square root of the biweight midvariance. The biweight midvariance uses a tuning constant,  c , and an optional initial guess of the central value  M . \\[ζ²_{biscl} = \\frac{n ∑_{|uᵢ|<1}{(xᵢ - M)²(1 - uᵢ²)⁴}}{\\left[∑_{|uᵢ|<1}{(1-uᵢ²)(1-5uᵢ²)}\\right]²}\\] \\[uᵢ = \\frac{(xᵢ - M)}{c⋅\\mathrm{MAD}(x)}\\] Where  $\\mathrm{MAD}(x)$  is median absolute deviation of  x . Examples julia> data = ones(3, 5);\n\njulia> BiweightScaleRMS()(data)\n0.0\n\njulia> BiweightScaleRMS(c=3.0)(data, dims=1)\n1×5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0 source"},{"id":516,"pagetitle":"Background Interpolators","title":"Background Interpolators","ref":"/Photometry/stable/background/interpolators/#Background-Interpolators","content":" Background Interpolators Background interpolators provide a method for converting a low-resolution mesh into a low-order high-resolution image."},{"id":517,"pagetitle":"Background Interpolators","title":"Photometry.Background.BackgroundInterpolator","ref":"/Photometry/stable/background/interpolators/#Photometry.Background.BackgroundInterpolator","content":" Photometry.Background.BackgroundInterpolator  —  Type Background.BackgroundInterpolator This abstract type embodies the different ways of converting a low-resolution mesh into a high-resolution image, especially for dispatch with  estimate_background To implement a new interpolation scheme, you must define the struct and define a method like  (::MyInterpolator)(mesh) See Also Interpolators source"},{"id":518,"pagetitle":"Background Interpolators","title":"Interpolators","ref":"/Photometry/stable/background/interpolators/#Interpolators","content":" Interpolators"},{"id":519,"pagetitle":"Background Interpolators","title":"Photometry.Background.ZoomInterpolator","ref":"/Photometry/stable/background/interpolators/#Photometry.Background.ZoomInterpolator","content":" Photometry.Background.ZoomInterpolator  —  Type ZoomInterpolator(factors) Use a cubic-spline interpolation scheme to increase resolution of a mesh. factors  represents the level of \"zoom\", so an input mesh of size  (10, 10)  with factors  (2, 2)  will have an output size of  (20, 20) . If only an integer is provided, it will be used as the factor for every axis. Examples julia> ZoomInterpolator(2)([1 0; 0 1])\n4×4 Matrix{Float64}:\n  1.0          0.75   0.25   -2.77556e-17\n  0.75         0.625  0.375   0.25\n  0.25         0.375  0.625   0.75\n -5.55112e-17  0.25   0.75    1.0\n\njulia> ZoomInterpolator(3, 1)([1 0; 0 1])\n6×2 Matrix{Float64}:\n  1.0          -2.77556e-17\n  1.0          -2.77556e-17\n  0.666667      0.333333\n  0.333333      0.666667\n -5.55112e-17   1.0\n -5.55112e-17   1.0\n source"},{"id":520,"pagetitle":"Background Interpolators","title":"Photometry.Background.IDWInterpolator","ref":"/Photometry/stable/background/interpolators/#Photometry.Background.IDWInterpolator","content":" Photometry.Background.IDWInterpolator  —  Type IDWInterpolator(factors; leafsize=10, k=8, power=1, reg=0, conf_dist=1e-12) Use Shepard Inverse Distance Weighing interpolation scheme to increase resolution of a mesh. factors  represents the level of \"zoom\", so an input mesh of size  (10, 10)  with factors  (2, 2)  will have an output size of  (20, 20) . If only an integer is provided, it will be used as the factor for every axis. The interpolator can be called with some additional parameters: leaf_size  determines at what number of points to stop splitting the tree further, k  which is the number of nearest neighbors to be considered, power  is the exponent for distance in the weighing factor, reg  is the offset for the weighing factor in denominator, conf_dist  is the distance below which two points would be considered as the same point. Examples julia> IDWInterpolator(2, k=2)([1 0; 0 1])\n4×4 Matrix{Float64}:\n 1.0   0.75      0.25      0.0\n 0.75  0.690983  0.309017  0.25\n 0.25  0.309017  0.690983  0.75\n 0.0   0.25      0.75      1.0\n\njulia> IDWInterpolator(3, 1; k=2, power=4)([1 0; 0 1])\n6×2 Matrix{Float64}:\n 1.0        0.0\n 1.0        0.0\n 0.941176   0.0588235\n 0.0588235  0.941176\n 0.0        1.0\n 0.0        1.0 source"},{"id":523,"pagetitle":"Getting Started","title":"Source Detection","ref":"/Photometry/stable/detection/#Source-Detection","content":" Source Detection The module provides tools and algorithms for detecting and extracting point-like sources."},{"id":524,"pagetitle":"Getting Started","title":"API/Reference","ref":"/Photometry/stable/detection/#API/Reference","content":" API/Reference"},{"id":525,"pagetitle":"Getting Started","title":"Photometry.Detection.extract_sources","ref":"/Photometry/stable/detection/#Photometry.Detection.extract_sources","content":" Photometry.Detection.extract_sources  —  Function extract_sources(::SourceFinder, data, [error]; sorted=true) Uses  method  to find and extract point-like sources. Returns a  TypedTables.Table  with positions and information related to the  method . For instance, using  PeakMesh  returns a table a column for the peak values. data  is assumed to be background-subtracted. If  error  is provided it will be propagated into the detection algorithm. If  sorted  is  true  the sources will be sorted by their amplitude. See Also Source Detection Algorithms source"},{"id":528,"pagetitle":"Algorithms","title":"Source Detection Algorithms","ref":"/Photometry/stable/detection/algs/#Source-Detection-Algorithms","content":" Source Detection Algorithms"},{"id":529,"pagetitle":"Algorithms","title":"Photometry.Detection.SourceFinder","ref":"/Photometry/stable/detection/algs/#Photometry.Detection.SourceFinder","content":" Photometry.Detection.SourceFinder  —  Type Detection.SourceFinder Abstract super type for source detection algorithms used with  extract_sources . source"},{"id":530,"pagetitle":"Algorithms","title":"API/Reference","ref":"/Photometry/stable/detection/algs/#API/Reference","content":" API/Reference"},{"id":531,"pagetitle":"Algorithms","title":"Photometry.Detection.PeakMesh","ref":"/Photometry/stable/detection/algs/#Photometry.Detection.PeakMesh","content":" Photometry.Detection.PeakMesh  —  Type PeakMesh(box_size=(3, 3), nsigma=3.0) Detect sources by finding peaks above a threshold in grids across the image. This creates a pixel-wise threshold for sources by calculating  error * nsigma  when used with  extract_sources . The peaks are found by searching the image in boxes of size  box_size . If the maximum value in that box is greater than the threshold set above, the point is extracted. source"},{"id":534,"pagetitle":"Home","title":"PhotometricFilters","ref":"/PhotometricFilters/stable/#PhotometricFilters","content":" PhotometricFilters This package provides access to, and operations on, photometric filter curves. Such filter curves are defined by a filter's transmission as a function of wavelength. Transmission and wavelength vectors are therefore the foundation of a filter curve, but it is also important to note whether the filter is used for photon counter or energy counter detectors, as the integrals used to calculate statistics over a filter curve are different between these two types of detectors."},{"id":535,"pagetitle":"Home","title":"Types","ref":"/PhotometricFilters/stable/#Types","content":" Types All photometric filter types should be subtypes of the  AbstractFilter  type. We define a minimal API that should be followed so that new types can make use of the generic filter operations we define. The simplest concrete filter type we provide to represent photometric filters is  PhotometricFilter ."},{"id":536,"pagetitle":"Home","title":"PhotometricFilters.PhotometricFilter","ref":"/PhotometricFilters/stable/#PhotometricFilters.PhotometricFilter","content":" PhotometricFilters.PhotometricFilter  —  Type PhotometricFilter(wavelength::AbstractVector, throughput::AbstractVector{T};\n                  detector::DetectorType=Photon(), filtername::Union{String, Nothing}=nothing) where T Struct representing a photometric filter, defined by vectors of wavelengths ( wavelength ) and filter throughputs ( throughput ).  wavelength  can have  Unitful  units attached, otherwise they are assumed to be Å. Optional keyword arguments define the detector type for which the filter is valid and a name to identify the filter. julia> using PhotometricFilters: PhotometricFilter, Photon, wavelength, throughput\n\njulia> using Unitful\n\njulia> f = PhotometricFilter(1000:2000, vcat(fill(0.25, 250), fill(0.5, 500), fill(0.25, 251))) # Specify only wavelength and throughput\n1001-element PhotometricFilter{Float64}: nothing\n reference wave.: 1478.1028279485677 Å\n min. wave.: 1000 Å\n max. wave.: 2000 Å\n effective wave.: 1602.7669435459648 Å\n mean wave.: 1499.8333333333333 Å\n central wave.: 1499.5 Å\n pivot wave.: 1478.1028279485677 Å\n eff. width: 750.0 Å\n fwhm: 501.0 Å\n\njulia> f == PhotometricFilter(uconvert.(Unitful.nm, wavelength(f)), throughput(f)) # Can also specify wavelength argument with Unitful units\ntrue\n\njulia> f[10] # Indexing into the filter as `f[i]` returns `(wavelength(f)[i], throughput(f)[i])`\n(1009 Å, 0.25)\n\njulia> f(1001.1) # Calling `f` like a function interpolates the throughput\n0.25\n\njulia> f(100.11 * Unitful.nm) # Can also specify wavelength with units\n0.25 source The data contained in the struct can be accessed with the following methods:"},{"id":537,"pagetitle":"Home","title":"PhotometricFilters.filtername","ref":"/PhotometricFilters/stable/#PhotometricFilters.filtername","content":" PhotometricFilters.filtername  —  Function filtername(f::AbstractFilter) Returns a string indicating a human-readable name for the filter (e.g., \"SDSS_u\"). julia> using PhotometricFilters: SDSS_u, filtername\n\njulia> filtername(SDSS_u())\n\"SDSS_u\" source"},{"id":538,"pagetitle":"Home","title":"PhotometricFilters.wavelength","ref":"/PhotometricFilters/stable/#PhotometricFilters.wavelength","content":" PhotometricFilters.wavelength  —  Function wavelength(f::AbstractFilter) Returns the wavelength vector of the filter transmission curve with proper  Unitful.jl  units. julia> using PhotometricFilters: SDSS_u, wavelength\n\njulia> using Unitful: Quantity\n\njulia> wavelength(SDSS_u()) isa Vector{<:Quantity}\ntrue source"},{"id":539,"pagetitle":"Home","title":"PhotometricFilters.throughput","ref":"/PhotometricFilters/stable/#PhotometricFilters.throughput","content":" PhotometricFilters.throughput  —  Function throughput(f::AbstractFilter) Returns the throughput vector of the filter transmission curve (no units). julia> using PhotometricFilters: SDSS_u, throughput\n\njulia> throughput(SDSS_u()) isa Vector{<:Number}\ntrue source"},{"id":540,"pagetitle":"Home","title":"PhotometricFilters.detector_type","ref":"/PhotometricFilters/stable/#PhotometricFilters.detector_type","content":" PhotometricFilters.detector_type  —  Function detector_type(f::AbstractFilter) Return an instance of  PhotometricFilters.Energy  if the filter is defined for energy-counting detectors or  PhotometricFilters.Photon  for photon-counting detectors. julia> using PhotometricFilters: SDSS_u, detector_type, Photon\n\njulia> detector_type(SDSS_u()) === Photon()\ntrue source Users can construct their own filter curvers from raw data using this type."},{"id":541,"pagetitle":"Home","title":"Accessing Filter Curves","ref":"/PhotometricFilters/stable/#Accessing-Filter-Curves","content":" Accessing Filter Curves We provide a modest collection of filter curves through a data dependency. The available filter curves are accessible via the  FILTER_NAMES  module constant, using PhotometricFilters\nPhotometricFilters.FILTER_NAMES |> println [\"2MASS_H\", \"2MASS_J\", \"2MASS_Ks\", \"CFHT_CFH12K_CFH7406\", \"CFHT_CFH12K_CFH7504\", \"CFHT_MEGAPRIME_CFH7605\", \"CFHT_MEGAPRIME_CFH7701\", \"CFHT_MEGAPRIME_CFH7803\", \"CFHT_MEGAPRIME_CFH9301\", \"CFHT_MEGAPRIME_CFH9401\", \"CFHT_MEGAPRIME_CFH9601\", \"CFHT_MEGAPRIME_CFH9701\", \"CFHT_MEGAPRIME_CFH9702\", \"CFHT_MEGAPRIME_CFH9801\", \"CFHT_WIRCAM_CFH8002\", \"CFHT_WIRCAM_CFH8101\", \"CFHT_WIRCAM_CFH8102\", \"CFHT_WIRCAM_CFH8103\", \"CFHT_WIRCAM_CFH8104\", \"CFHT_WIRCAM_CFH8201\", \"CFHT_WIRCAM_CFH8202\", \"CFHT_WIRCAM_CFH8203\", \"CFHT_WIRCAM_CFH8204\", \"CFHT_WIRCAM_CFH8301\", \"CFHT_WIRCAM_CFH8302\", \"CFHT_WIRCAM_CFH8303\", \"CFHT_WIRCAM_CFH8304\", \"CFHT_WIRCAM_CFH8305\", \"GALEX_FUV\", \"GALEX_NUV\", \"GROUND_BESSELL_H\", \"GROUND_BESSELL_J\", \"GROUND_BESSELL_K\", \"GROUND_COUSINS_I\", \"GROUND_COUSINS_R\", \"GROUND_JOHNSON_B\", \"GROUND_JOHNSON_U\", \"GROUND_JOHNSON_V\", \"GaiaDR2_BP\", \"GaiaDR2_G\", \"GaiaDR2_RP\", \"GaiaDR2_weiler_BPbright\", \"GaiaDR2_weiler_BPfaint\", \"GaiaDR2_weiler_G\", \"GaiaDR2_weiler_RP\", \"GaiaDR2v2_BP\", \"GaiaDR2v2_G\", \"GaiaDR2v2_RP\", \"Gaia_BP\", \"Gaia_G\", \"Gaia_MAW_BP_bright\", \"Gaia_MAW_BP_faint\", \"Gaia_MAW_G\", \"Gaia_MAW_RP\", \"Gaia_RP\", \"Gaia_rvs\", \"HERSCHEL_PACS_BLUE\", \"HERSCHEL_PACS_GREEN\", \"HERSCHEL_PACS_RED\", \"HERSCHEL_SPIRE_PLW\", \"HERSCHEL_SPIRE_PLW_EXT\", \"HERSCHEL_SPIRE_PMW\", \"HERSCHEL_SPIRE_PSW\", \"HERSCHEL_SPIRE_PSW_EXT\", \"HST_ACS_HRC_F220W\", \"HST_ACS_HRC_F250W\", \"HST_ACS_HRC_F330W\", \"HST_ACS_HRC_F344N\", \"HST_ACS_HRC_F435W\", \"HST_ACS_HRC_F475W\", \"HST_ACS_HRC_F502N\", \"HST_ACS_HRC_F550M\", \"HST_ACS_HRC_F555W\", \"HST_ACS_HRC_F606W\", \"HST_ACS_HRC_F625W\", \"HST_ACS_HRC_F658N\", \"HST_ACS_HRC_F660N\", \"HST_ACS_HRC_F775W\", \"HST_ACS_HRC_F814W\", \"HST_ACS_HRC_F850LP\", \"HST_ACS_HRC_F892N\", \"HST_ACS_WFC_F435W\", \"HST_ACS_WFC_F475W\", \"HST_ACS_WFC_F502N\", \"HST_ACS_WFC_F550M\", \"HST_ACS_WFC_F555W\", \"HST_ACS_WFC_F606W\", \"HST_ACS_WFC_F625W\", \"HST_ACS_WFC_F658N\", \"HST_ACS_WFC_F660N\", \"HST_ACS_WFC_F775W\", \"HST_ACS_WFC_F814W\", \"HST_ACS_WFC_F850LP\", \"HST_ACS_WFC_F892N\", \"HST_NIC2_F110W\", \"HST_NIC2_F160W\", \"HST_NIC2_F205W\", \"HST_NIC3_F108N\", \"HST_NIC3_F110W\", \"HST_NIC3_F113N\", \"HST_NIC3_F150W\", \"HST_NIC3_F160W\", \"HST_NIC3_F164N\", \"HST_NIC3_F166N\", \"HST_NIC3_F175W\", \"HST_NIC3_F187N\", \"HST_NIC3_F190N\", \"HST_NIC3_F196N\", \"HST_NIC3_F200N\", \"HST_NIC3_F205M\", \"HST_NIC3_F212N\", \"HST_NIC3_F215N\", \"HST_NIC3_F222M\", \"HST_NIC3_F240M\", \"HST_WFC3_F098M\", \"HST_WFC3_F105W\", \"HST_WFC3_F110W\", \"HST_WFC3_F125W\", \"HST_WFC3_F126N\", \"HST_WFC3_F127M\", \"HST_WFC3_F128N\", \"HST_WFC3_F130N\", \"HST_WFC3_F132N\", \"HST_WFC3_F139M\", \"HST_WFC3_F140W\", \"HST_WFC3_F153M\", \"HST_WFC3_F160W\", \"HST_WFC3_F164N\", \"HST_WFC3_F167N\", \"HST_WFC3_F200LP\", \"HST_WFC3_F218W\", \"HST_WFC3_F225W\", \"HST_WFC3_F275W\", \"HST_WFC3_F280N\", \"HST_WFC3_F300X\", \"HST_WFC3_F336W\", \"HST_WFC3_F343N\", \"HST_WFC3_F350LP\", \"HST_WFC3_F373N\", \"HST_WFC3_F390M\", \"HST_WFC3_F390W\", \"HST_WFC3_F395N\", \"HST_WFC3_F410M\", \"HST_WFC3_F438W\", \"HST_WFC3_F467M\", \"HST_WFC3_F469N\", \"HST_WFC3_F475W\", \"HST_WFC3_F475X\", \"HST_WFC3_F487N\", \"HST_WFC3_F502N\", \"HST_WFC3_F547M\", \"HST_WFC3_F555W\", \"HST_WFC3_F600LP\", \"HST_WFC3_F606W\", \"HST_WFC3_F621M\", \"HST_WFC3_F625W\", \"HST_WFC3_F631N\", \"HST_WFC3_F645N\", \"HST_WFC3_F656N\", \"HST_WFC3_F657N\", \"HST_WFC3_F658N\", \"HST_WFC3_F665N\", \"HST_WFC3_F673N\", \"HST_WFC3_F680N\", \"HST_WFC3_F689M\", \"HST_WFC3_F763M\", \"HST_WFC3_F775W\", \"HST_WFC3_F814W\", \"HST_WFC3_F845M\", \"HST_WFC3_F850LP\", \"HST_WFC3_F953N\", \"HST_WFC3_FQ232N\", \"HST_WFC3_FQ243N\", \"HST_WFC3_FQ378N\", \"HST_WFC3_FQ387N\", \"HST_WFC3_FQ422M\", \"HST_WFC3_FQ436N\", \"HST_WFC3_FQ437N\", \"HST_WFC3_FQ492N\", \"HST_WFC3_FQ508N\", \"HST_WFC3_FQ575N\", \"HST_WFC3_FQ619N\", \"HST_WFC3_FQ634N\", \"HST_WFC3_FQ672N\", \"HST_WFC3_FQ674N\", \"HST_WFC3_FQ727N\", \"HST_WFC3_FQ750N\", \"HST_WFC3_FQ889N\", \"HST_WFC3_FQ906N\", \"HST_WFC3_FQ924N\", \"HST_WFC3_FQ937N\", \"HST_WFPC2_F170W\", \"HST_WFPC2_F218W\", \"HST_WFPC2_F255W\", \"HST_WFPC2_F300W\", \"HST_WFPC2_F336W\", \"HST_WFPC2_F439W\", \"HST_WFPC2_F450W\", \"HST_WFPC2_F555W\", \"HST_WFPC2_F606W\", \"HST_WFPC2_F622W\", \"HST_WFPC2_F675W\", \"HST_WFPC2_F791W\", \"HST_WFPC2_F814W\", \"HST_WFPC2_F850LP\", \"JWST_NIRCAM_F070W\", \"JWST_NIRCAM_F090W\", \"JWST_NIRCAM_F115W\", \"JWST_NIRCAM_F140M\", \"JWST_NIRCAM_F150W\", \"JWST_NIRCAM_F150W2\", \"JWST_NIRCAM_F162M\", \"JWST_NIRCAM_F164N\", \"JWST_NIRCAM_F182M\", \"JWST_NIRCAM_F187N\", \"JWST_NIRCAM_F200W\", \"JWST_NIRCAM_F210M\", \"JWST_NIRCAM_F212N\", \"JWST_NIRCAM_F250M\", \"JWST_NIRCAM_F277W\", \"JWST_NIRCAM_F300M\", \"JWST_NIRCAM_F322W2\", \"JWST_NIRCAM_F323N\", \"JWST_NIRCAM_F335M\", \"JWST_NIRCAM_F356W\", \"JWST_NIRCAM_F360M\", \"JWST_NIRCAM_F405N\", \"JWST_NIRCAM_F410M\", \"JWST_NIRCAM_F430M\", \"JWST_NIRCAM_F444W\", \"JWST_NIRCAM_F460M\", \"JWST_NIRCAM_F466N\", \"JWST_NIRCAM_F470N\", \"JWST_NIRCAM_F480M\", \"KEPLER_Kp\", \"NGTS_I\", \"PS1_g\", \"PS1_i\", \"PS1_r\", \"PS1_w\", \"PS1_y\", \"PS1_z\", \"SDSS_g\", \"SDSS_i\", \"SDSS_r\", \"SDSS_u\", \"SDSS_z\", \"SPITZER_IRAC_36\", \"SPITZER_IRAC_45\", \"SPITZER_IRAC_58\", \"SPITZER_IRAC_80\", \"STROMGREN_b\", \"STROMGREN_u\", \"STROMGREN_v\", \"STROMGREN_y\", \"TESS\", \"TYCHO_B_MvB\", \"TYCHO_V_MvB\", \"WISE_RSR_W1\", \"WISE_RSR_W2\", \"WISE_RSR_W3\", \"WISE_RSR_W4\", \"ZTF_g\", \"ZTF_i\", \"ZTF_r\"] These included filter curves can be accessed like so, using PhotometricFilters: SDSS_u, SDSS_g, SDSS_r, SDSS_i, SDSS_z, fwhm\nfilts = [SDSS_u(), SDSS_g(), SDSS_r(), SDSS_i(), SDSS_z()] 5-element Vector{PhotometricFilter{Float64, Vector{Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(Å,), 𝐋, nothing}}}, PhotometricFilters.Photon, Vector{Float64}, String, Interpolations.FilledExtrapolation{Float64, 1, Interpolations.GriddedInterpolation{Float64, 1, Vector{Float64}, Interpolations.Gridded{Interpolations.Linear{Interpolations.Throw{Interpolations.OnGrid}}}, Tuple{Vector{Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(Å,), 𝐋, nothing}}}}}, Interpolations.Gridded{Interpolations.Linear{Interpolations.Throw{Interpolations.OnGrid}}}, Float64}}}:\n SDSS_u\n SDSS_g\n SDSS_r\n SDSS_i\n SDSS_z NOTE THAT THESE INCLUDED FILTER CURVES ARE NOT GUARANTEED TO BE UP-TO-DATE.  If you are using a filter/instrument that may have recently had its filter curves updated (e.g., JWST/NIRCAM), you should use our SVO query interface to make sure you get the most up-to-date filter curves. SVO also provides additional metadata that is useful for some applications (e.g., filter zeropoints). If you know the SVO-designated name of the filter you want, you can use  get_filter  to retrieve its transmission data, which returns an instance of  SVOFilter ."},{"id":542,"pagetitle":"Home","title":"PhotometricFilters.get_filter","ref":"/PhotometricFilters/stable/#PhotometricFilters.get_filter","content":" PhotometricFilters.get_filter  —  Function get_filter(filtername::AbstractString, magsys::Symbol=:Vega) Query the online  SVO filter service  for data on a photometric filter. Arguments filtername::AbstractString : The desired filter ID, in the correct SVO specification (e.g.,  \"2MASS/2MASS.J\" ). magsys::Symbol : Desired magnitude system for associated metadata (e.g.,  \"ZeroPoint\" ). Can be any of  (:AB, :Vega, :ST) . SVO uses Vega by default, so we mirror that choice here. Returns An  SVOFilter  instance containing the results of the query. Examples julia> using PhotometricFilters: get_filter\n\njulia> filt = get_filter(\"2MASS/2MASS.J\", :Vega)\n107-element PhotometricFilters.SVOFilter{PhotometricFilter{Float64}}: 2MASS/2MASS.J\n reference wave.: 12350.0 Å\n min. wave.: 10806.470589792389 Å\n max. wave.: 14067.974683578484 Å\n effective wave.: 12284.994608629975 Å\n mean wave.: 12410.5170694321 Å\n central wave.: 12390.584132888223 Å\n pivot wave.: 12393.093155655275 Å\n eff. width: 1624.3245065600008 Å\n fwhm: 2149.1445403830403 Å source"},{"id":543,"pagetitle":"Home","title":"PhotometricFilters.SVOFilter","ref":"/PhotometricFilters/stable/#PhotometricFilters.SVOFilter","content":" PhotometricFilters.SVOFilter  —  Type SVOFilter(filter::PhotometricFilter, metadata) <: AbstractFilter Type for containing the photometric filter information returned by the SVO filter service. A result of this type is returned by  get_filter . Contains two fields: filter  is a  PhotometricFilter  type that is used to support common operations. metadata  is a dictionary (currently an  OrderedCollections.OrderedDict ) that contains the metadata returned by SVO. These fields are considered internal (subject to change) and users should interact with instances of this type via the public accessor methods instead. Example usage is below. julia> using PhotometricFilters: get_filter, SVOFilter, PhotometricFilter\n\njulia> filt = get_filter(\"2MASS/2MASS.J\", :Vega);\n\njulia> filt isa SVOFilter\ntrue\n\njulia> PhotometricFilter(filt) isa PhotometricFilter # Access simpler PhotometricFilter type\ntrue\n\njulia> Dict(filt) isa Dict # Retrieve full metadata dictionary\ntrue\n\njulia> filt[\"ZeroPoint\"] # Can retrieve metadata directly\n1594.0 Jy\n\njulia> filtername(filt) # `filtername`, `detector_type`, `wavelength`, `throughput` all work\n\"2MASS/2MASS.J\" source If you'd like to perform a search on the filters available through the SVO filter service, you can use  query_filters ."},{"id":544,"pagetitle":"Home","title":"PhotometricFilters.query_filters","ref":"/PhotometricFilters/stable/#PhotometricFilters.query_filters","content":" PhotometricFilters.query_filters  —  Function query_filters(; queries...) Queries the filters available from the SVO filter service with search parameters and returns a table of the filters found. The available search parameters can be found with  PhotometricFilters.get_metadata . The following should be available in general: WavelengthRef : Tuple of Numbers WavelengthMean : Tuple of Numbers WavelengthEff : Tuple of Numbers WavelengthMin : Tuple of Numbers WavelengthMax : Tuple of Numbers WidthEff : Tuple of Numbers FWHM : Tuple of Numbers Instrument : String Facility : String PhotSystem : String The returned table is a  DataFrame  from the  DataFrames  package with all the columns of the response VOTable. The filter information and transmission data can be obtained by calling  get_filter  with the ID obtained from the  filterID  column. Examples julia> using PhotometricFilters: query_filters, SVOFilter\n\njulia> using DataFrames: DataFrame\n\njulia> df = query_filters(; Facility=\"SLOAN\", WavelengthEff=(1000, 5000));\n\njulia> df isa DataFrame\ntrue\n\njulia> id = df.filterID[3]\n\"SLOAN/SDSS.g\"\n\njulia> get_filter(id) isa SVOFilter\ntrue # Other examples for querying\nquery_filters(; Facility=\"SLOAN\") # all filters from a given facility\nquery_filters(; Instrument=\"BUSCA\", WavelengthEff=(1000u\"angstrom\", 5000u\"angstrom\")) # Unitful wavelengths source"},{"id":545,"pagetitle":"Home","title":"Interacting with the Filter Cache","ref":"/PhotometricFilters/stable/#Interacting-with-the-Filter-Cache","content":" Interacting with the Filter Cache After you first access a filter with  get_filter , it is cached to disk for future use. It is expected that users should not typically have to manually interact with the cache. As such, the cache-related utilities discussed here are not exported from the package and must be explicitly imported (e.g.,  using PhotometricFilters: update_filters; update_filters() ) or used via the qualified syntax (e.g.,  using PhotometricFilters; PhotometricFilters.update_filters() ). You can list the currently cached filters with  PhotometricFilters.cached_filters . To update cached filters, ensuring you have the most up-to-date data, you can use  PhotometricFilters.update_filter . You can delete filters from the cache with  PhotometricFilters.clear_filter ."},{"id":546,"pagetitle":"Home","title":"PhotometricFilters.cached_filters","ref":"/PhotometricFilters/stable/#PhotometricFilters.cached_filters","content":" PhotometricFilters.cached_filters  —  Function cached_filters() Returns a  Vector{Tuple{String, Symbol}}  containing the filter identifier and magnitude system for each SVO filter in the cache. julia> using PhotometricFilters: cached_filters, get_filter\n\njulia> get_filter(\"2MASS/2MASS.J\", :Vega); # Load SVO filter, will be cached if not already\n\njulia> (\"2MASS/2MASS.J\", :Vega) in cached_filters() # Check that filter is in the cache\ntrue source"},{"id":547,"pagetitle":"Home","title":"PhotometricFilters.update_filter","ref":"/PhotometricFilters/stable/#PhotometricFilters.update_filter","content":" PhotometricFilters.update_filter  —  Function update_filter(f::AbstractString, magsys::Symbol) Reacquires filter with SVO identifier  f  in the magnitude system  magsys  from SVO and saves it into the cache. Returns the updated filter. julia> using PhotometricFilters: cached_filters, update_filter, SVOFilter\n\njulia> get_filter(\"2MASS/2MASS.J\", :Vega); # Load SVO filter, will be cached if not already\n\njulia> update_filter(\"2MASS/2MASS.J\", :Vega) isa SVOFilter # Updates cached file, returns filter\ntrue source update_filter() When called with no arguments, updates all filters in the cache. Returns  nothing . source"},{"id":548,"pagetitle":"Home","title":"PhotometricFilters.clear_filter","ref":"/PhotometricFilters/stable/#PhotometricFilters.clear_filter","content":" PhotometricFilters.clear_filter  —  Function clear_filter(f::AbstractString, magsys::Symbol) Deletes filter  f  in magnitude system  magsys  from the cache. julia> using PhotometricFilters: get_filter, clear_filter, cached_filters\n\njulia> get_filter(\"2MASS/2MASS.J\", :Vega); # Ensure filter in cache\n\njulia> clear_filter(\"2MASS/2MASS.J\", :Vega) # Remove filter from cache\n\njulia> (\"2MASS/2MASS.J\", :Vega) in cached_filters() # Check that filter was removed from cache\nfalse source clear_filter() When called with no arguments, deletes all filters from the cache. source We include functions for performing many common operations on photometric filters, summarized below."},{"id":549,"pagetitle":"Home","title":"Applying Filter Curves to Spectra","ref":"/PhotometricFilters/stable/#Applying-Filter-Curves-to-Spectra","content":" Applying Filter Curves to Spectra"},{"id":550,"pagetitle":"Home","title":"PhotometricFilters.apply_throughput","ref":"/PhotometricFilters/stable/#PhotometricFilters.apply_throughput","content":" PhotometricFilters.apply_throughput  —  Function apply_throughput(f::AbstractFilter, wavelengths, flux) Use linear interpolation to map the wavelengths of the photometric filter  f  to the given  wavelengths  and apply the filter throughput to the  flux . The provided  wavelengths  and those of the filter must be compatible. This means if one has units, the other one needs units, too. julia> using PhotometricFilters: SDSS_u, wave_unit, apply_throughput\n\njulia> f = SDSS_u();\n\njulia> λ = 3000:4000\n3000:4000\n\njulia> flux = fill(1.0, length(λ)); # If `flux` is all `1`, `apply_throughput` reduces to `f` interpolated at `λ`\n\njulia> apply_throughput(f, λ, flux) == f(λ)\ntrue\n\njulia> λ_u = λ .* wave_unit # Can also put units on λ\n(3000:4000) Å\n\njulia> apply_throughput(f, λ_u, flux) == f.(λ_u)\ntrue source"},{"id":551,"pagetitle":"Home","title":"PhotometricFilters.apply_throughput!","ref":"/PhotometricFilters/stable/#PhotometricFilters.apply_throughput!","content":" PhotometricFilters.apply_throughput!  —  Function apply_throughput!(f::AbstractFilter, wavelengths, flux, out) In-place version of  apply_throughput  which modifies  out . It should have a compatible element type with  flux . source"},{"id":552,"pagetitle":"Home","title":"PhotometricFilters.mean_flux_density","ref":"/PhotometricFilters/stable/#PhotometricFilters.mean_flux_density","content":" PhotometricFilters.mean_flux_density  —  Function mean_flux_density(filt::AbstractFilter, wavelengths, flux) Returns the mean flux density of a spectrum (defined by wavelengths  wavelengths  and fluxes  flux ) when integrated over the provided filter  filt . For photon counting detectors, this is \\[\\overline{f_\\lambda} = \\frac{\\int_\\lambda \\lambda \\, f_\\lambda \\, T(\\lambda) \\, d\\lambda}{\\int_\\lambda \\lambda \\, T(\\lambda) \\, d\\lambda}\\] which can also be interpreted as the mean photon rate density, while for energy counting detectors, this is \\[\\overline{f_\\lambda} = \\frac{\\int_\\lambda f_\\lambda \\, T(\\lambda) \\, d\\lambda}{\\int_\\lambda T(\\lambda) \\, d\\lambda}\\] which is essentially just the mean flux weighted by the filter throughput. Below we show example usage that can be compared against  this example  from pyphot. julia> using PhotometricFilters: mean_flux_density, HST_WFC3_F110W, Vega\n\njulia> using Unitful, UnitfulAstro\n\njulia> v = Vega(\"alpha_lyr_stis_006\");\n\njulia> mfd = mean_flux_density(HST_WFC3_F110W(), v.wave, v.flux);\n\njulia> isapprox(mfd, 4.082289e-10 * u\"erg/s/cm^2/angstrom\"; rtol=1e-3)\ntrue source"},{"id":553,"pagetitle":"Home","title":"PhotometricFilters.F_nu","ref":"/PhotometricFilters/stable/#PhotometricFilters.F_nu","content":" PhotometricFilters.F_nu  —  Function F_nu(F_lambda::SpectralFluxDensity, λref)\nF_nu(F_lambda::SpectralFluxDensity, f::AbstractFilter) Convert a spectral flux density  F_lambda  into a spectral energy density. Assuming  F_lambda  in  erg / s / cm^2 / Angstrom , and  F_nu  in  Jy , this conversion is \\[F_\\nu = \\frac{10^5}{10^{-8} \\, c} \\, \\lambda^2_r \\, F_\\lambda\\] where  $c$  is the speed of light in  m/s  and  $\\lambda_r$  is the reference wavelength ( λref ) in  Angstroms . If providing an  AbstractFilter  as the second argument, the reference wavelength will be automatically computed with  reference_wavelength . source"},{"id":554,"pagetitle":"Home","title":"PhotometricFilters.F_lambda","ref":"/PhotometricFilters/stable/#PhotometricFilters.F_lambda","content":" PhotometricFilters.F_lambda  —  Function F_lambda(F_nu::SpectralEnergyDensity, λref)\nF_lambda(F_nu::SpectralEnergyDensity, f::AbstractFilter) Convert a spectral energy density  F_nu  into a spectral flux density. Assuming  F_nu  in  Jy  and  F_lambda  in  erg / s / cm^2 / Angstrom , this conversion is \\[F_\\lambda = \\frac{10^{-8} \\, c}{10^5} \\, \\lambda^{-2}_r \\, F_\\nu\\] where  $c$  is the speed of light in  m/s  and  $\\lambda_r$  is the reference wavelength ( λref ) in  Angstroms . If providing an  AbstractFilter  as the second argument, the reference wavelength will be automatically computed with  reference_wavelength . source"},{"id":555,"pagetitle":"Home","title":"Zero Points","ref":"/PhotometricFilters/stable/#Zero-Points","content":" Zero Points We utilize multiple dispatch to support dynamic calculation of zeropoints in the magnitude systems below."},{"id":556,"pagetitle":"Home","title":"PhotometricFilters.MagnitudeSystem","ref":"/PhotometricFilters/stable/#PhotometricFilters.MagnitudeSystem","content":" PhotometricFilters.MagnitudeSystem  —  Type Abstract supertype for magnitude systems like  AB ,  ST , and  Vega . Subtypes should implement  zeropoint_mag ,  zeropoint_flux , and  zeropoint_Jy . source"},{"id":557,"pagetitle":"Home","title":"PhotometricFilters.AB","ref":"/PhotometricFilters/stable/#PhotometricFilters.AB","content":" PhotometricFilters.AB  —  Type AB() <: MagnitudeSystem Singleton struct representing the AB magnitude system. This system is defined such that \\[m_\\text{AB} = -2.5 \\ \\text{log} \\left( \\bar{f_ν} \\right) - 48.60\\] when  $f_ν$  is in units of erg / s / cm^2 / Hz. This corresponds to a constant   zeropoint_Jy  value in all filters of  exp10(48.6 / -2.5 + 23)  ≈ 3631 Jy. When passed to methods such as  zeropoint_flux , indicates that you wish to have the AB zeropoint flux returned. source"},{"id":558,"pagetitle":"Home","title":"PhotometricFilters.ST","ref":"/PhotometricFilters/stable/#PhotometricFilters.ST","content":" PhotometricFilters.ST  —  Type ST() <: MagnitudeSystem Singleton struct representing the ST magnitude system. This system is defined so that a source with uniform  $f_\\lambda$  has identical magnitude in every filter. \\[m_\\text{ST} = -2.5 \\ \\text{log} \\left( \\bar{f_\\lambda} \\right) - 21.1\\] When passed to methods such as  zeropoint_flux , indicates that you wish to have the ST zeropoint flux returned. source"},{"id":559,"pagetitle":"Home","title":"PhotometricFilters.Vega","ref":"/PhotometricFilters/stable/#PhotometricFilters.Vega","content":" PhotometricFilters.Vega  —  Type Vega(wave, flux, name::String) <: MagnitudeSystem Struct for containing a Vega reference spectrum with wavelengths  wave  and flux values  flux .  wave  should be provided in units of Å and  flux should be provided in  $f_λ$  units of erg / s / cm^2 / Angstrom. The Vega magnitude system is defined so that the star Alpha Lyr (i.e., Vega) has magnitude 0 in every filter. \\[m_\\text{Vega} = -2.5 \\ \\text{log} \\left( \\frac{\\bar{f_\\lambda}}{\\bar{f_\\lambda} \\left( \\text{Vega} \\right)} \\right)\\] When passed to methods such as  zeropoint_flux , indicates that you wish to have the Vega zeropoint flux returned. source Any reference spectrum hosted by  CALSPEC  can be used to construct an instance of  Vega  using the method below."},{"id":560,"pagetitle":"Home","title":"PhotometricFilters.Vega","ref":"/PhotometricFilters/stable/#PhotometricFilters.Vega-Tuple{String}","content":" PhotometricFilters.Vega  —  Method Vega(name::String = \"alpha_lyr_stis_011\") Loads the reference spectrum with filename  name  and returns an appropriate instance of  Vega  that can be used to compute zeropoints and magnitudes in the Vega magnitude system. If the provided  name  is the full path to the existing file on disk, the spectrum is loaded from that file. Otherwise, it is downloaded from the  CALSPEC database  of standard stars maintained by STScI. Files downloaded this way are cached for future use. Specifically, we draw from the extended catalog  here . The CALSPEC catalog with the most recent reference spectrum for each star is located  here . Standard Vega spectra start with  \"alpha_lyr\" .  name s like  \"alpha_lyr_stis_XXX\"  are based on composites of calibrated stellar models and HST/STIS data, while  \"alpha_lyr_mod_XXX\"  are based on stellar models only. Sometimes Vega is not used as the standard star for photometric systems even when the system follows the Vega magnitude convention. For example, in the near-IR Sirius is often used as the standard reference spectrum rather than Vega. This is the case for the definition of the  JWST zeropoints , which presently use the  \"sirius_stis_005.fits\"  CALSPEC spectrum as their standard. To load a different standard, simply provide the corresponding  name  to  Vega . For example, to load the Sirius spectrum, use  Vega(\"sirius_stis_005\")  (the  \".fits\"  extension is optional). source The list of available spectral standards can be retrieved with  PhotometricFilters.get_calspec_names ."},{"id":561,"pagetitle":"Home","title":"PhotometricFilters.get_calspec_names","ref":"/PhotometricFilters/stable/#PhotometricFilters.get_calspec_names","content":" PhotometricFilters.get_calspec_names  —  Function get_calspec_names([substring::AbstractString]) Returns a list of the names of the available spectral standards that can be download from CALSPEC and used as a standard in the Vega magnitude system. If the optional  substring::AbstractString  argument is provided, then the list of names is filtered to only include those that contain the provided substring. This method is not currently exported. julia> using PhotometricFilters: Vega, get_calspec_names\n\njulia> names = get_calspec_names();\n\njulia> names isa Vector{String}\ntrue\n\njulia> Vega(names[1]) isa Vega\ntrue\n\njulia> vega_standards = get_calspec_names(\"alpha_lyr\");\n\njulia> all(map(x -> occursin(\"alpha_lyr\", x), vega_standards))\ntrue source Zeropoints can be computed with methods below."},{"id":562,"pagetitle":"Home","title":"PhotometricFilters.zeropoint_flux","ref":"/PhotometricFilters/stable/#PhotometricFilters.zeropoint_flux","content":" PhotometricFilters.zeropoint_flux  —  Function zeropoint_flux(f::AbstractFilter, T::MagnitudeSystem) Returns the flux zero point of the filter  f  in magnitude system  T  in units of erg / s / cm^2 / Angstrom. julia> using PhotometricFilters: zeropoint_flux, AB, ST, Vega, HST_WFC3_F110W\n\njulia> using Unitful\n\njulia> isapprox(zeropoint_flux(HST_WFC3_F110W(), AB()), 8.159816925e-10 * u\"erg/s/cm^2/angstrom\"; rtol=1e-3)\ntrue\n\njulia> isapprox(zeropoint_flux(HST_WFC3_F110W(), ST()), 3.6307805e-9 * u\"erg/s/cm^2/angstrom\"; rtol=1e-3)\ntrue\n\njulia> isapprox(zeropoint_flux(HST_WFC3_F110W(), Vega(\"alpha_lyr_stis_006\")), 4.082289e-10 * u\"erg/s/cm^2/angstrom\"; rtol=1e-3)\ntrue source"},{"id":563,"pagetitle":"Home","title":"PhotometricFilters.zeropoint_Jy","ref":"/PhotometricFilters/stable/#PhotometricFilters.zeropoint_Jy","content":" PhotometricFilters.zeropoint_Jy  —  Function zeropoint_Jy(f::AbstractFilter, T::MagnitudeSystem) Returns the flux zeropoint in Jansky in magnitude system  T . Note that for the  AB  system, this is often approximated as 3631 Jy, following from the definition  $m_\\text{AB} = -2.5 \\, \\text{log} \\left( \\bar{f_\\nu} \\right) - 48.6$  where  $\\bar{f_\\nu}$  is in units of erg / s / cm^2 / Hz. This can be solved for  $m_\\text{AB} = 0$  to give  $\\bar{f}_{\\nu, 0} = 10^{\\frac{48.6}{-2.5}}$  which is approximately  $3.631 \\times 10^{-20}$  erg / s / cm^2 / Hz, or ≈ 3631 Jy. This function returns the exact value. julia> using PhotometricFilters: zeropoint_Jy, AB, ST, Vega, HST_WFC3_F110W\n\njulia> using Unitful, UnitfulAstro\n\njulia> isapprox(zeropoint_Jy(HST_WFC3_F110W(), AB()), 3630.78054 * u\"Jy\"; rtol=1e-3)\ntrue\n\njulia> isapprox(zeropoint_Jy(HST_WFC3_F110W(), ST()), 16155.46954* u\"Jy\"; rtol=1e-3)\ntrue\n\njulia> isapprox(zeropoint_Jy(HST_WFC3_F110W(), Vega(\"alpha_lyr_stis_006\")), 1816.43597 * u\"Jy\"; rtol=1e-3)\ntrue source"},{"id":564,"pagetitle":"Home","title":"PhotometricFilters.zeropoint_mag","ref":"/PhotometricFilters/stable/#PhotometricFilters.zeropoint_mag","content":" PhotometricFilters.zeropoint_mag  —  Function zeropoint_mag(f::AbstractFilter, T::MagnitudeSystem) Returns the magnitude zero point of the filter  f  in the magnitude system  T . This is used by the  magnitude  method to calculate magnitudes from spectra in units of  F_lambda  as \\[m_{\\text{AB}} = -2.5 * \\text{log} \\left( \\bar{f_\\lambda} \\right) - \\text{Zpt}\\] For the  ST  magnitude system, this is always equal to 21.1 by definition. julia> using PhotometricFilters: zeropoint_mag, AB, ST, Vega, HST_WFC3_F110W\n\njulia> isapprox(zeropoint_mag(HST_WFC3_F110W(), AB()), 22.7207989; rtol=1e-3)\ntrue\n\njulia> isapprox(float(zeropoint_mag(HST_WFC3_F110W(), ST())), 21.1; rtol=1e-3)\ntrue\n\njulia> isapprox(zeropoint_mag(HST_WFC3_F110W(), Vega(\"alpha_lyr_stis_006\")), 23.4727487; rtol=1e-3)\ntrue source"},{"id":565,"pagetitle":"Home","title":"Synthetic Photometry","ref":"/PhotometricFilters/stable/#Synthetic-Photometry","content":" Synthetic Photometry"},{"id":566,"pagetitle":"Home","title":"PhotometricFilters.magnitude","ref":"/PhotometricFilters/stable/#PhotometricFilters.magnitude","content":" PhotometricFilters.magnitude  —  Function magnitude(f::AbstractFilter, T::MagnitudeSystem, wavelengths, flux) Calculates the magnitude in the given filter  f  in the magnitude system  T  from a spectrum defined by arrays  wavelengths  and  flux , both of which must have valid Unitful units. julia> using PhotometricFilters: magnitude, Vega, ST, AB, HST_WFC3_F110W\n\njulia> v = Vega(\"alpha_lyr_stis_006\");\n\njulia> isapprox(magnitude(HST_WFC3_F110W(), AB(), v.wave, v.flux), 0.7519497; rtol=1e-3)\ntrue\n\njulia> isapprox(magnitude(HST_WFC3_F110W(), ST(), v.wave, v.flux), 2.372748728; rtol=1e-3)\ntrue\n\njulia> isapprox(magnitude(HST_WFC3_F110W(), v, v.wave, v.flux), 0; rtol=1e-3)\ntrue source"},{"id":567,"pagetitle":"Home","title":"Statistics","ref":"/PhotometricFilters/stable/#Statistics","content":" Statistics"},{"id":568,"pagetitle":"Home","title":"PhotometricFilters.reference_wavelength","ref":"/PhotometricFilters/stable/#PhotometricFilters.reference_wavelength","content":" PhotometricFilters.reference_wavelength  —  Function reference_wavelength(f::AbstractFilter) Returns the reference wavelength of the filter  f , used for conversions of the flux and for determination of magnitudes. By default the pivot wavelength is returned ( pivot_wavelength ), but filter providers sometimes provide their own specified values. source"},{"id":569,"pagetitle":"Home","title":"PhotometricFilters.mean_wavelength","ref":"/PhotometricFilters/stable/#PhotometricFilters.mean_wavelength","content":" PhotometricFilters.mean_wavelength  —  Function mean_wavelength(f::AbstractFilter) Returns the mean wavelength of the filter  f , defined as \\[\\frac{\\int \\lambda \\, T(\\lambda) \\, d\\lambda}{\\int T(\\lambda) \\, d\\lambda}\\] source"},{"id":570,"pagetitle":"Home","title":"PhotometricFilters.central_wavelength","ref":"/PhotometricFilters/stable/#PhotometricFilters.central_wavelength","content":" PhotometricFilters.central_wavelength  —  Function central_wavelength(f::AbstractFilter) Returns the central wavelength of the filter  f , defined as the central wavelength between the two wavelengths used for the FWHM ( fwhm ). source"},{"id":571,"pagetitle":"Home","title":"PhotometricFilters.effective_wavelength","ref":"/PhotometricFilters/stable/#PhotometricFilters.effective_wavelength","content":" PhotometricFilters.effective_wavelength  —  Function effective_wavelength(f::AbstractFilter, v::Vega = Vega()) Returns the effective wavelength of the filter  f  using the Vega spectrum contained in  v  as a standard. Defined as \\[\\frac{\\int \\lambda \\, T(\\lambda) \\text{Vg}(\\lambda) \\, d\\lambda}{\\int T(\\lambda) \\text{Vg}(\\lambda) \\, d\\lambda}\\] where  $T(\\lambda)$  is the filter transmission at wavelength  $\\lambda$  and  $\\text{Vg}(\\lambda)$  is the spectrum of Vega. source"},{"id":572,"pagetitle":"Home","title":"PhotometricFilters.pivot_wavelength","ref":"/PhotometricFilters/stable/#PhotometricFilters.pivot_wavelength","content":" PhotometricFilters.pivot_wavelength  —  Function pivot_wavelength(f::AbstractFilter) Returns the pivot wavelength of the filter  f , defined for filters with  Energy  detector types as \\[\\sqrt{ \\frac{\\int T(\\lambda) \\, d\\lambda}{\\int T(\\lambda) / \\lambda^2 \\, d\\lambda} }\\] For filters with  Photon  detector types,  $\\lambda \\, T(\\lambda)$  is substituted for  $T(\\lambda)$  in the above expression. Internally integration is carried out using trapezoidal integration. It can be convenient to think of this as the \"center of mass\" of the filter. source"},{"id":573,"pagetitle":"Home","title":"PhotometricFilters.min_wave","ref":"/PhotometricFilters/stable/#PhotometricFilters.min_wave","content":" PhotometricFilters.min_wave  —  Function min_wave(f::AbstractFilter; level=0.01) Returns the shortest wavelength at which the filter transmission is equal to  level * maximum(transmission) . source"},{"id":574,"pagetitle":"Home","title":"PhotometricFilters.max_wave","ref":"/PhotometricFilters/stable/#PhotometricFilters.max_wave","content":" PhotometricFilters.max_wave  —  Function max_wave(f::AbstractFilter; level=0.01) Returns the longest wavelength at which the filter transmission is equal to  level * maximum(transmission) . source"},{"id":575,"pagetitle":"Home","title":"PhotometricFilters.fwhm","ref":"/PhotometricFilters/stable/#PhotometricFilters.fwhm","content":" PhotometricFilters.fwhm  —  Function fwhm(f::AbstractFilter) Returns the difference between the furthest two wavelengths for which the filter transmission is equal to half its maximum value. source"},{"id":576,"pagetitle":"Home","title":"PhotometricFilters.width","ref":"/PhotometricFilters/stable/#PhotometricFilters.width","content":" PhotometricFilters.width  —  Function width(f::AbstractFilter) Returns the effective width of the filter, defined as the horizontal size of a rectangle with height equal to the maximum transmission of the filter such that the area of the rectangle is equal to the area under the filter transmission curve. This is calculated as \\[\\frac{\\int T(\\lambda) \\, d\\lambda}{\\text{max}(T(\\lambda))}\\] source"},{"id":577,"pagetitle":"Home","title":"Internals","ref":"/PhotometricFilters/stable/#Internals","content":" Internals"},{"id":578,"pagetitle":"Home","title":"PhotometricFilters.AbstractFilter","ref":"/PhotometricFilters/stable/#PhotometricFilters.AbstractFilter","content":" PhotometricFilters.AbstractFilter  —  Type AbstractFilter{T} Abstract supertype for representing photometric filters. Most functions provided by this package (e.g.,  effective_wavelength  and similar methods) are designed to work with any subtype of  AbstractFilter  so long as a minimal API is defined for new subtypes. The methods that should be implemented for new types to conform to this API are summarized below: filtername(f::NewType)  should return a string indicating a human-readable name for the filter (e.g., \"SDSS_u\"). wavelength(f::NewType)  should return the wavelength vector of the filter transmission curve with proper  Unitful.jl  units. throughput(f::NewType)  should return the throughput vector of the filter transmission curve (no units). detector_type(f::NewType)  should return an instance of  PhotometricFilters.Energy  if the filter is defined for energy-counting detectors or  PhotometricFilters.Photon  for photon-counting detectors. Additionally, all subtypes should support filter interpolation at user-defined wavelengths with a call signature  (f::NewType)(wavelengths) . To support this, new types should implement a method like  (f::PhotometricFilter)(wavelength::Q) where Q <: Unitful.Length . A generic fallback for inputs without units is already defined. source"},{"id":579,"pagetitle":"Home","title":"PhotometricFilters.get_metadata","ref":"/PhotometricFilters/stable/#PhotometricFilters.get_metadata","content":" PhotometricFilters.get_metadata  —  Function get_metadata() Returns a table of the available parameters that can be used to query the SVO filter service from the  FORMAT=metadata  VOTable they provide. The table is a  DataFrame  from the  DataFrames  package with the following columns: parameter : parameter name that can be used for queries using  query_filters unit :  Unitful  unit of the parameter datatype :  Type  of the parameter description : description of the parameter values : vector of the possible values that the respective parameter can take on (e.g. for Instrument), or a vector of the minimum and maximum values that the parameter can assume (e.g. for WavelengthEff) Example julia> using DataFrames: DataFrame\n\njulia> df = PhotometricFilters.get_metadata();\n\njulia> df isa DataFrame\ntrue\n\njulia> facilities = df[findfirst(==(\"Facility\"), df.parameter), :].values;\n\njulia> facilities isa Vector{String}\ntrue This is not exported. source"},{"id":580,"pagetitle":"Home","title":"Index","ref":"/PhotometricFilters/stable/#Index","content":" Index PhotometricFilters.AB PhotometricFilters.AbstractFilter PhotometricFilters.MagnitudeSystem PhotometricFilters.PhotometricFilter PhotometricFilters.ST PhotometricFilters.SVOFilter PhotometricFilters.Vega PhotometricFilters.Vega PhotometricFilters.F_lambda PhotometricFilters.F_nu PhotometricFilters.apply_throughput PhotometricFilters.apply_throughput! PhotometricFilters.cached_filters PhotometricFilters.central_wavelength PhotometricFilters.clear_filter PhotometricFilters.detector_type PhotometricFilters.effective_wavelength PhotometricFilters.filtername PhotometricFilters.fwhm PhotometricFilters.get_calspec_names PhotometricFilters.get_filter PhotometricFilters.get_metadata PhotometricFilters.magnitude PhotometricFilters.max_wave PhotometricFilters.mean_flux_density PhotometricFilters.mean_wavelength PhotometricFilters.min_wave PhotometricFilters.pivot_wavelength PhotometricFilters.query_filters PhotometricFilters.reference_wavelength PhotometricFilters.throughput PhotometricFilters.update_filter PhotometricFilters.wavelength PhotometricFilters.width PhotometricFilters.zeropoint_Jy PhotometricFilters.zeropoint_flux PhotometricFilters.zeropoint_mag"},{"id":583,"pagetitle":"Home","title":"PSFModels.jl","ref":"/PSFModels/stable/#PSFModels.jl","content":" PSFModels.jl"},{"id":584,"pagetitle":"Home","title":"Installation","ref":"/PSFModels/stable/#Installation","content":" Installation PSFModels can be added from the Julia package manager julia> ] # pressing ']' should drop you into pkg-mode\npkg> add PSFModels"},{"id":585,"pagetitle":"Home","title":"Getting Started","ref":"/PSFModels/stable/#Getting-Started","content":" Getting Started To import the library julia> using PSFModels None of the models are exported to avoid namespace clashes, but it can be verbose to continuously rewrite  PSFModels . You can either import names directly julia> using PSFModels: gaussian\n\njulia> model = gaussian(x=0, y=0, fwhm=8) or you can create an alias for  PSFModels # julia version 1.5 or below\nusing PSFModels\nconst M = PSFModels\n# julia version 1.6 or above\nimport PSFModels as M\n\nmodel = M.gaussian(x=0, y=0, fwhm=10)"},{"id":586,"pagetitle":"Home","title":"Contributing and Support","ref":"/PSFModels/stable/#Contributing-and-Support","content":" Contributing and Support If you would like to contribute, feel free to open a  pull request . If you want to discuss something before contributing, head over to  discussions  and join or open a new topic. If you're having problems with something, please open an  issue ."},{"id":589,"pagetitle":"API/Reference","title":"API/Reference","ref":"/PSFModels/stable/api/#API/Reference","content":" API/Reference PSFModels.airydisk PSFModels.fit PSFModels.gaussian PSFModels.moffat PSFModels.normal"},{"id":590,"pagetitle":"API/Reference","title":"Gaussian","ref":"/PSFModels/stable/api/#Gaussian","content":" Gaussian"},{"id":591,"pagetitle":"API/Reference","title":"PSFModels.gaussian","ref":"/PSFModels/stable/api/#PSFModels.gaussian","content":" PSFModels.gaussian  —  Function gaussian([T=Float64], point; x, y, fwhm, amp=1, theta=0, bkg=0)\ngaussian([T=Float64], px, py; x, y, fwhm, amp=1, theta=0, bkg=0) An unnormalized bivariate Gaussian distribution. The position can be specified in  (x, y)  coordinates as a  Tuple ,  AbstractVector , or as separate arguments. If  theta  is given, the PSF will be rotated by  theta  degrees counter-clockwise from the x-axis. If  bkg  is given it will be added as a scalar to the PSF. The  fwhm  can be a scalar (isotropic) or a vector/tuple (diagonal). Keep in mind that  theta  has no effect for isotropic distributions and is degenerate with the  fwhm  parameters (i.e., theta=90 is the same as reversing the  fwhm  tuple) Functional form \\[f(x | x̂, \\mathrm{FWHM}) = \\exp[-4 \\ln(2) ⋅ ||x - x̂|| / \\mathrm{FWHM}^2]\\] where  x̂  and  x  are position vectors (indices)  ||⋅||  represents the square-distance, and  FWHM  is the full width at half-maximum. If  FWHM  is a scalar, the Gaussian distribution will be isotropic. If  FWHM  is a vector or tuple, the weighting is applied along each axis (diagonal). source"},{"id":592,"pagetitle":"API/Reference","title":"PSFModels.normal","ref":"/PSFModels/stable/api/#PSFModels.normal","content":" PSFModels.normal  —  Function normal An alias for  gaussian source gauss = gaussian(x=0, y=0, fwhm=10)\npsfplot(gauss, -50:50, -50:50; title=\"gaussian(fwhm=10)\",\n        colorbar_scale=:log10, clims=(1e-5, 1))"},{"id":593,"pagetitle":"API/Reference","title":"Airy Disk","ref":"/PSFModels/stable/api/#Airy-Disk","content":" Airy Disk"},{"id":594,"pagetitle":"API/Reference","title":"PSFModels.airydisk","ref":"/PSFModels/stable/api/#PSFModels.airydisk","content":" PSFModels.airydisk  —  Function airydisk([T=Float64], point; x, y, fwhm, ratio=0, amp=1, theta=0, bkg=0)\nairydisk([T=Float64], px, py; x, y, fwhm, ratio=0, amp=1, theta=0, bkg=0) An unnormalized Airy disk. The position can be specified in  (x, y)  coordinates as a  Tuple ,  AbstractVector , or as separate arguments. If  theta  is given, the PSF will be rotated by  theta  degrees counter-clockwise from the x-axis. If  bkg  is given it will be added as a scalar to the PSF. The  fwhm  can be a scalar (isotropic) or a vector/tuple (diagonal). Keep in mind that  theta  has no effect for isotropic distributions and is degenerate with the  fwhm  parameters (i.e., theta=90 is the same as reversing the  fwhm  tuple) If  ratio  is supplied, this will be the Airy pattern for a centrally-obscured aperture (e.g., a Newtonian telescope). This has a slightly expanded functional form, and in general the central Airy disk will be smaller and the first Airy ring will be brighter. Functional form The Airy disk is a distribution over the radius  r  (the square-Euclidean distance) \\[f(x | x̂, \\mathrm{FWHM}) = [ 2J₁(q) / q ]^2\\] where  J₁  is the first-order Bessel function of the first kind and \\[q ≈ π r D / λ ≈ π r / (0.973 × \\mathrm{FWHM})\\] If user a non-zero central obscuration via  ratio , the functional form becomes \\[f(x | x̂, \\mathrm{FWHM}, ϵ) = [ 2J₁(q) / q - 2ϵJ₁(ϵq) / q ]^2 / (1 - ϵ^2)^2\\] where  $ϵ$  is the ratio ( $0 ≤ ϵ < 1$ ). source airy = airydisk(x=0, y=0, fwhm=10)\npsfplot(airy, -50:50, -50:50; title=\"airydisk(fwhm=10)\",\n        colorbar_scale=:log10, clims=(1e-5, 1)) airy_obscured = airydisk(x=0, y=0, fwhm=10, ratio=0.3)\npsfplot(airy_obscured, -50:50, -50:50; title=\"airydisk(fwhm=10, ratio=0.3)\",\n        colorbar_scale=:log10, clims=(1e-5, 1))"},{"id":595,"pagetitle":"API/Reference","title":"Moffat","ref":"/PSFModels/stable/api/#Moffat","content":" Moffat"},{"id":596,"pagetitle":"API/Reference","title":"PSFModels.moffat","ref":"/PSFModels/stable/api/#PSFModels.moffat","content":" PSFModels.moffat  —  Function moffat([T=Float64], point; x, y, fwhm, alpha=1, amp=1, theta=0, bkg=0)\nmoffat([T=Float64], px, py; x, y, fwhm, alpha=1, amp=1, theta=0, bkg=0) Two dimensional Moffat model. The position can be specified in  (x, y)  coordinates as a  Tuple ,  AbstractVector , or as separate arguments. If  theta  is given, the PSF will be rotated by  theta  degrees counter-clockwise from the x-axis. If  bkg  is given it will be added as a scalar to the PSF. The  fwhm  can be a scalar (isotropic) or a vector/tuple (diagonal). Keep in mind that  theta  has no effect for isotropic distributions and is degenerate with the  fwhm  parameters (i.e., theta=90 is the same as reversing the  fwhm  tuple) Functional form \\[f(x | x̂, \\mathrm{FWHM}, α) = A (1 + (||x - x̂|| / \\mathrm{FWHM} / 2)^2)^{-α}\\] where  x̂  and  x  are position vectors (indices)  ||⋅||  represents the distance, and  FWHM  is the full width at half-maximum. If  fwhm  is a vector or tuple, the weighting is applied along each axis. Note that this function technically uses the half width at half-maximum, defined as  $\\mathrm{HWHM} = \\mathrm{FWHM}/2$ , but for compatibility with the other models,  fwhm  is used as an input parameter instead. source moff = moffat(x=0, y=0, fwhm=10)\npsfplot(moff, -50:50, -50:50; title=\"moffat(fwhm=10)\",\n        colorbar_scale=:log10, clims=(1e-5, 1)) moff2 = moffat(x=0, y=0, fwhm=10, alpha=2)\npsfplot(moff2, -50:50, -50:50; title=\"moffat(fwhm=10, alpha=2)\",\n        colorbar_scale=:log10, clims=(1e-5, 1))"},{"id":597,"pagetitle":"API/Reference","title":"Comparison","ref":"/PSFModels/stable/api/#Comparison","content":" Comparison xs = range(0, 50, length=1000)\nplot(\n    xs, [gauss.(xs, 0) airy.(xs, 0) moff.(xs, 0)],\n    label=[\"gaussian\" \"airydisk\" \"moffat\"], yscale=:log10,\n    xlabel=\"x\", ylabel=\"I\", ylims=(1e-5, 1)\n)"},{"id":598,"pagetitle":"API/Reference","title":"Fitting","ref":"/PSFModels/stable/api/#Fitting","content":" Fitting"},{"id":599,"pagetitle":"API/Reference","title":"PSFModels.fit","ref":"/PSFModels/stable/api/#PSFModels.fit","content":" PSFModels.fit  —  Function PSFModels.fit(model, params, image, inds=axes(image);\n              func_kwargs=(;), loss=abs2, maxfwhm=Inf, alg=LBFGS(),\n              kwargs...) Fit a PSF model ( model ) defined by the given  params  as a named tuple of the parameters to fit and their default values. This model is fit to the data in  image  at the specified  inds  (by default, the entire array). To pass extra keyword arguments to the  model  (i.e., to \"freeze\" a parameter), pass them in a named tuple to  func_kwargs . The default loss function is the chi-squared loss, which uses the the square of the difference (i.e., the L2 norm). You can change this to the L1 norm, for example, by passing  loss=abs . The maximum FWHM can be set with  maxfwhm  as a number or tuple. Additional keyword arguments, as well as the fitting algorithm  alg , are passed to  Optim.optimize  as an  Optim.Option . By default we use forward-mode auto-differentiation (AD) to derive Jacobians for the  Newton with Trust Region  optimization algorithm. Refer to the  Optim.jl documentation  for more information. Choosing parameters The  fit  function is very powerful because it gives you a great amount of flexibility in the way you fit your models. To demonstrate this, let's start with a simple isotropic  gaussian . model = gaussian\n# match params to arguments of PSF\nparams = (x=20, y=20, fwhm=3, amp=1) Note that  params  can follow any order params = (amp=1, x=20, y=20, fwhm=3) Now, to extend this interface to the bivariate PSF case, where  fwhm  is two values, all you need to do is use a tuple or vector params = (x=20, y=20, fwhm=(3, 3)) and, again, the order does not matter model = moffat\nparams = (alpha=1, x=20, y=20, fwhm=3, amp=10) Fitting a PSF After selecting your model and parameters, fitting data is easy P = (x=12, y=13, fwhm=13.2, amp=0.1)\npsf = gaussian.(CartesianIndicies(1:25, 1:15); P...)\n\nparams, synthpsf = PSFModels.fit(gaussian, P, psf) here  params  is a named tuple of the best fitting parameters. It will not include any fixed parameters. synthpsf  is the best-fitting model, for direct comparison with the input data. psf_fit = synthpsf.(CartesianIndicies(psf)) To alter parameters without fitting them (i.e., \"freeze\" them) use  func_kwargs P = (x=12, y=13, fwhm=(12.4, 13.2), amp=0.1)\nfunc_kwargs = (alpha=2)\nparams, synthpsf = PSFModels.fit(moffat, P, psf; func_kwargs) source"},{"id":602,"pagetitle":"Benchmarks","title":"Benchmarks","ref":"/PSFModels/stable/bench/#Benchmarks","content":" Benchmarks The benchmarks can be found in the  bench/  folder. To run them, first instantiate the environment $ julia --project=bench -e \"using Pkg; Pkg.instantiate()\" then execute the  bench/bench.jl  file $ julia --project=bench bench/bench.jl System Information Julia Version 1.10.4\nCommit 48d4fd48430 (2024-06-04 10:41 UTC)\nBuild Info:\n  Official https://julialang.org/ release\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 16 × 13th Gen Intel(R) Core(TM) i5-1340P\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-15.0.7 (ORCJIT, goldmont)\nThreads: 1 default, 0 interactive, 1 GC (on 16 virtual cores)"},{"id":603,"pagetitle":"Benchmarks","title":"Evaluation benchmark","ref":"/PSFModels/stable/bench/#Evaluation-benchmark","content":" Evaluation benchmark This benchmark tests how long it takes to evaluate a single point in the PSF model. This may seem contrived, but we expect performance to scale directly from this measure: if it takes 1 microsecond to evaluate a single point, it should take ~1 second to evaluate a 1000×1000 image, with speedups potentially from multithreading or SIMD loop evaluation. table = CSV.read(benchdir(\"evaluation_results.csv\"), DataFrame) 3×3 DataFrame\n Row │ name      psfmodels   astropy\n     │ String15  Float64     Float64\n─────┼─────────────────────────────────\n   1 │ Gaussian  2.33112e-8  7.1579e-5\n   2 │ AiryDisk  1.9672e-8   5.7172e-5\n   3 │ Moffat    2.33253e-8  5.3287e-5 @df table groupedbar(\n    :name, [:psfmodels :astropy];\n    ylabel=\"time (s)\", yscale=:log10, legend=:outertopright,\n    label=[\"PSFModels.jl\" \"Astropy\"], size=(500, 300),\n)"},{"id":604,"pagetitle":"Benchmarks","title":"Fitting benchmark","ref":"/PSFModels/stable/bench/#Fitting-benchmark","content":" Fitting benchmark This benchmark tests how long it takes to fit a PSF Model to a stamp with size (39, 39). In all cases, we use equivalently complex models, the default fitters for PSFModels.jl, and the default  LevMarLSQFit  fitter for astropy. table = CSV.read(benchdir(\"fitting_results.csv\"), DataFrame) 3×3 DataFrame\n Row │ name      psfmodels   astropy\n     │ String15  Float64     Float64\n─────┼──────────────────────────────────\n   1 │ Gaussian  0.00349649  0.00731791\n   2 │ AiryDisk  0.00849787  0.00952454\n   3 │ Moffat    0.00393968  0.00754826 @df table groupedbar(\n    :name, [:psfmodels :astropy];\n    ylabel=\"time (s)\", yscale=:log10, legend=:outertopright,\n    label=[\"PSFModels.jl\" \"Astropy\"], size=(500, 300),\n)"},{"id":607,"pagetitle":"Examples","title":"Examples","ref":"/PSFModels/stable/examples/#Examples","content":" Examples"},{"id":608,"pagetitle":"Examples","title":"Fitting a PSF","ref":"/PSFModels/stable/examples/#Fitting-a-PSF","content":" Fitting a PSF Here is a brief example which shows how to construct a loss function for fitting a  PSFModel  to some data. using PSFModels\nusing PSFModels: fit\nusing HCIDatasets: BetaPictoris\nusing Plots\nusing Statistics\n\n# convenience function for plotting\nfunction imshow(data; kwargs...)\n    xlim = extrema(axes(data, 1))\n    ylim = extrema(axes(data, 2))\n    heatmap(transpose(data); xlim=xlim, ylim=ylim,\n            aspect_ratio=1, clims=(1e-5, Inf), kwargs...)\nend\n\n# get a PSF from HCIDatasets.jl;\n# you may be prompted to download the file\npsf = BetaPictoris[:psf]\ninds = CartesianIndices(psf)\n\nimshow(psf) We can fit this data with a variety of models, here showcasing the flexible  PSFModels.fit  function."},{"id":609,"pagetitle":"Examples","title":"Gaussian","ref":"/PSFModels/stable/examples/#Gaussian","content":" Gaussian Using  gaussian params = (x=20, y=20, fwhm=5, amp=0.1)\nP_gauss, mod_gauss = fit(gaussian, params, psf)\npairs(P_gauss) pairs(::NamedTuple) with 4 entries:\n  :x    => 20.0191\n  :y    => 20.01\n  :fwhm => 4.80293\n  :amp  => 0.100216 plot(\n    imshow(psf, title=\"Data\"),\n    imshow(mod_gauss.(inds), title=\"Model\"),\n    cbar=false,\n    ticks=false,\n    layout=2,\n    size=(600, 300)\n) and now using a rotated, elliptical Gaussian params = (x=20, y=20, fwhm=(5, 5), amp=0.1, theta=0)\nP_ellip, mod_ellip = fit(gaussian, params, psf)\npairs(P_ellip) pairs(::NamedTuple) with 5 entries:\n  :x     => 20.0192\n  :y     => 20.011\n  :fwhm  => (4.6758, 4.92609)\n  :amp   => 0.100322\n  :theta => -38.445 plot(\n    imshow(psf, title=\"Data\"),\n    imshow(mod_ellip.(inds), title=\"Model\"),\n    cbar=false,\n    ticks=false,\n    layout=2,\n    size=(600, 300)\n)"},{"id":610,"pagetitle":"Examples","title":"Airy disk","ref":"/PSFModels/stable/examples/#Airy-disk","content":" Airy disk Now with  airydisk params = (x=20, y=20, fwhm=5, amp=0.1, ratio=0.3)\nP_airy, mod_airy = fit(airydisk, params, psf)\npairs(P_airy) pairs(::NamedTuple) with 5 entries:\n  :x     => 20.0\n  :y     => 20.0\n  :fwhm  => 5.0\n  :amp   => 0.1\n  :ratio => 0.3 plot(\n    imshow(psf, title=\"Data\"),\n    imshow(mod_airy.(inds), title=\"Model\"),\n    cbar=false,\n    ticks=false,\n    layout=2,\n    size=(600, 300)\n)"},{"id":611,"pagetitle":"Examples","title":"Moffat","ref":"/PSFModels/stable/examples/#Moffat","content":" Moffat And finally, with  moffat params = (x=20, y=20, fwhm=(5, 5), amp=0.1, theta=0, alpha=2)\nP_moff, mod_moff = fit(moffat, params, psf)\npairs(P_moff) pairs(::NamedTuple) with 6 entries:\n  :x     => 20.0366\n  :y     => 20.0154\n  :fwhm  => (3.95567, 3.78329)\n  :amp   => 0.11638\n  :theta => 42.3943\n  :alpha => 1.46268 plot(\n    imshow(psf, title=\"Data\"),\n    imshow(mod_moff.(inds), title=\"Model\"),\n    cbar=false,\n    ticks=false,\n    layout=2,\n    size=(600, 300)\n)"},{"id":612,"pagetitle":"Examples","title":"Changing optimization parameters","ref":"/PSFModels/stable/examples/#Changing-optimization-parameters","content":" Changing optimization parameters Any keyword arguments get passed on to  Optim.optimize , and you can change the algorithm used with the  alg  keyword # load Optim.jl to use the Newton method\nusing Optim\n\nparams = (x=20, y=20, fwhm=(5, 5), amp=0.1, theta=0, alpha=2)\nP_moff, mod_moff = fit(moffat, params, psf; alg=Newton())\npairs(P_moff) pairs(::NamedTuple) with 6 entries:\n  :x     => 20.0359\n  :y     => 20.0151\n  :fwhm  => (3.87008, 3.8665)\n  :amp   => 0.116352\n  :theta => 1.29441f-5\n  :alpha => 1.46154 We can also \"freeze\" parameters by creating a named tuple and passing it to  func_kwargs params = (;x=10, y=20, fwhm=(5, 5), amp=0.1)\nfunc_kwargs = (;alpha=2)\nP_moff2, mod_moff2 = fit(moffat, params, psf; func_kwargs)\npairs(P_moff2) pairs(::NamedTuple) with 4 entries:\n  :x    => 20.0349\n  :y    => 20.0144\n  :fwhm => (4.19137, 4.19478)\n  :amp  => 0.110515 plot(\n    imshow(psf, title=\"Data\"),\n    imshow(mod_moff2.(inds), title=\"Model\"),\n    cbar=false,\n    ticks=false,\n    layout=2,\n    size=(600, 300)\n)"},{"id":615,"pagetitle":"Introduction","title":"Introduction","ref":"/PSFModels/stable/introduction/#Introduction","content":" Introduction Statistical models for constructing point-spread functions (PSFs)."},{"id":616,"pagetitle":"Introduction","title":"Models","ref":"/PSFModels/stable/introduction/#Models","content":" Models The following models are currently implemented gaussian / normal airydisk moffat"},{"id":617,"pagetitle":"Introduction","title":"Parameters","ref":"/PSFModels/stable/introduction/#Parameters","content":" Parameters In general, the PSFs have a position, a full-width at half-maximum (FWHM) measure, and an amplitude. The position follows a 1-based pixel coordinate system, where  (1, 1)  represents the  center  of the bottom left pixel. This matches the indexing style of Julia as well as DS9, IRAF, SourceExtractor, and WCS. The FWHM is a consistent scale parameter for the models. That means a  gaussian  with a FWHM of 5 will be visually similar to an  airydisk  with a FWHM of 5. All models support a scalar (isotropic) FWHM and a FWHM for each axis (diagonal), as well as arbitrarily rotating the PSF. Pixel-convention The pixel convention adopted here is that the bottom-left pixel  center  is  (1, 1) . The column-major memory layout of julia puts the  x  axis as the rows of a matrix and the  y  axis as the columns. In other words, the axes unpack like xs, ys = axes(image)"},{"id":618,"pagetitle":"Introduction","title":"Usage","ref":"/PSFModels/stable/introduction/#Usage","content":" Usage"},{"id":619,"pagetitle":"Introduction","title":"Evaluating models","ref":"/PSFModels/stable/introduction/#Evaluating-models","content":" Evaluating models Directly evaluating the functions is the most straightforward way to use this package julia> gaussian(0, 0; x=0, y=0, fwhm=3)\n1.0\n\njulia> gaussian(BigFloat, 0, 0; x=0, y=0, fwhm=3, amp=0.1, bkg=1)\n1.100000000000000088817841970012523233890533447265625 We also provide \"curried\" versions of the functions, which allow you to specify the parameters and evaluate the PSF later julia> model = gaussian(x=0, y=0, fwhm=3);\n\njulia> model(0, 0)\n1.0 If we want to collect the model into a dense matrix, simply iterate over indices julia> inds = CartesianIndices((-2:2, -2:2));\n\njulia> model.(inds) # broadcasting\n5×5 Matrix{Float64}:\n 0.0850494  0.214311  0.291632  0.214311  0.0850494\n 0.214311   0.54003   0.734867  0.54003   0.214311\n 0.291632   0.734867  1.0       0.734867  0.291632\n 0.214311   0.54003   0.734867  0.54003   0.214311\n 0.0850494  0.214311  0.291632  0.214311  0.0850494 This makes it very easy to evaluate the PSF on the same axes as an image (array) julia> img = randn(5, 5);\n\njulia> model.(CartesianIndices(img))\n5×5 Matrix{Float64}:\n 0.54003      0.214311     0.0459292    0.00531559   0.000332224\n 0.214311     0.0850494    0.018227     0.00210949   0.000131843\n 0.0459292    0.018227     0.00390625   0.000452087  2.82555e-5\n 0.00531559   0.00210949   0.000452087  5.2322e-5    3.27013e-6\n 0.000332224  0.000131843  2.82555e-5   3.27013e-6   2.04383e-7 this is trivially expanded to fit \"stamps\" in images julia> big_img = randn(1000, 1000);\n\njulia> stamp_inds = (750:830, 400:485);\n\njulia> stamp = @view big_img[stamp_inds...];\n\njulia> stamp_model = model.(CartesianIndices(stamp_inds)); or we can create a loss function for fitting PSFs without allocating any memory. We are simply iterating over the image array! julia> using Statistics\n\njulia> mse = mean(I -> (big_img[I] - model(I))^2, CartesianIndices(stamp_inds));"},{"id":620,"pagetitle":"Introduction","title":"Fitting data","ref":"/PSFModels/stable/introduction/#Fitting-data","content":" Fitting data There exists a simple, yet powerful, API for fitting data with  PSFModels.fit . # `fit` is not exported to avoid namespace clashes\nusing PSFModels: fit\n\ndata = # load data\nstamp_inds = # optionally choose indices to \"cutout\"\n\n# use an isotropic Gaussian\nparams, synthpsf = fit(gaussian, (x=12, y=13, fwhm=3.2, amp=0.1),\n                       data, stamp_inds)\n\n# elliptical, rotated Gaussian\nparams, synthpsf = fit(gaussian, (x=12, y=13, fwhm=(3.2, 3.2), amp=0.1, theta=0)\n                       data, stamp_inds)\n\n# obscured Airy disk\nparams, synthpsf = fit(airydisk, (x=12, y=13, fwhm=3.2, amp=0.1, ratio=0.3),\n                       data, stamp_inds)\n\n# bivariate Moffat with arbitrary alpha\nparams, synthpsf = fit(moffat, (x=12, y=13, fwhm=(3.2, 3.2), amp=0.1, alpha=1),\n                       data, stamp_inds)"},{"id":621,"pagetitle":"Introduction","title":"Plotting","ref":"/PSFModels/stable/introduction/#Plotting","content":" Plotting Finally, we provide plotting recipes ( psfplot / psfplot! ) from  RecipesBase.jl , which can be seen in use in the  API/Reference  section. using Plots\n\nmodel = gaussian(x=0, y=0, fwhm=(8, 10), theta=12)\npsfplot(model, -30:30, -30:30, colorbar_scale=:log10)"},{"id":624,"pagetitle":"Introduction","title":"Introduction","ref":"/SAOImageDS9/stable/#Introduction","content":" Introduction The  SAOImageDS9  package provides an interface between  Julia  and the image viewer  SAOImage/DS9  via  XPA.jl , a Julia interface to the  XPA Messaging System ."},{"id":625,"pagetitle":"Introduction","title":"Table of contents","ref":"/SAOImageDS9/stable/#Table-of-contents","content":" Table of contents Installation Starting SAOImage/DS9 requests Set requests Get requests Connection to a specific server Drawing in SAOImage/DS9 Examples Basic examples Frame settings Other examples Package library Requests to SAOImage/DS9 Connection Drawing Utilities"},{"id":626,"pagetitle":"Introduction","title":"Method index","ref":"/SAOImageDS9/stable/#Method-index","content":" Method index SAOImageDS9.accesspoint SAOImageDS9.bitpix_of SAOImageDS9.bitpix_to_type SAOImageDS9.byte_order SAOImageDS9.connect SAOImageDS9.draw SAOImageDS9.get SAOImageDS9.set"},{"id":629,"pagetitle":"Connection to a specific server","title":"Connection to a specific server","ref":"/SAOImageDS9/stable/connect/#Connection-to-a-specific-server","content":" Connection to a specific server When  SAOImageDS9.connect()  is called without any argument, all subsequent requests will be sent to the first SAOImage/DS9 instance found by the XPA name server.  To send further requests to a specific SAOImage/DS9 server, you may do: SAOImageDS9.connect(apt) -> ident where  apt  is a string identifying a specific XPA access point.  The returned value is the fully qualified identifier of the access point, it has the form  host:port  for a TCP/IP socket or it is the path to the socket file for an AF/Unix socket.  The access point  apt  may be a fully qualified identifier or a template of the form  class:name  like  \"DS9:*\"  which corresponds to any server of the class  \"DS9\" .  Note that  name  is the argument of the  -title  option when SAOImage/DS9 is launched.  See  XPA Template  for a complete description.  When  SAOImageDS9.connect()  is called with no arguments or with a template containing wild characters, it automatically connects to the first access point matching the template ( \"DS9.*\"  by default) with a warning if no access points, or if more than one access point are found. To retrieve the identifier of the current access point to SAOImage/DS9, you may call: SAOImageDS9.accesspoint() which yields an empty string if there are no current connection. Remember that all requests are sent to a given access point, but you may switch between SAOImage/DS9 servers.  For instance: apt1 = SAOImageDS9.accesspoint()             # retrieve current access point\napt2 = SAOImageDS9.connect(\"DS9:some_name\")  # second access point\nSAOImageDS9.set(arr)                         # send an image to apt2\nSAOImageDS9.connect(apt1);                   # switch to apt1\nSAOImageDS9.set(\"zoom to\", 1.4)              # set zoom in apt1"},{"id":632,"pagetitle":"Drawing in SAOImage/DS9","title":"Drawing in SAOImage/DS9","ref":"/SAOImageDS9/stable/drawing/#Drawing-in-SAOImage/DS9","content":" Drawing in SAOImage/DS9 SAOImageDS9  can be used to quickly draw or display things in SAOImage/DS9. For instance, assuming  img  is a 2-dimensional Julia array, to display  img  as an image in SAOImage/DS9, call: SAOImageDS9.draw(img; kwds...) The main difference with  SAOImageDS9.set(img)  is that a number of keywords are supported: Use keyword  frame  to specify the frame number. Use keyword  cmap  to specify the name of the colormap.  For instance,  cmap=\"gist_stern\" . Use keyword  zoom  to specify the zoom factor. Use keywords  min  and/or  max  to specify the scale limits. The  SAOImageDS9.draw  method can be called with other kinds of arguments such as instances (or array or tuple) of  TwoDimensional.Point  to draw point(s) or instances of  TwoDimensional.BoundingBox  to draw rectangle(s)."},{"id":635,"pagetitle":"Examples","title":"Examples","ref":"/SAOImageDS9/stable/examples/#Examples","content":" Examples"},{"id":636,"pagetitle":"Examples","title":"Basic examples","ref":"/SAOImageDS9/stable/examples/#Basic-examples","content":" Basic examples import SAOImageDS9\nusing SAOImageDS9: TupleOf\nSAOImageDS9.connect() For a 512×861 image  img  with  Float32  pixels,  SAOImageDS9.set(img)  takes 8.502 ms (28 allocations: 1.30 KiB) while  SAOImageDS9.get(Array)  takes 5.844 ms (50 allocations: 1.68 MiB). Query parameters of the image displayed in the current DS9 frame: SAOImageDS9.get(Int, \"fits width\")         # get the width of the image\nSAOImageDS9.get(Int, \"fits height\")        # get the height of the image\nSAOImageDS9.get(Int, \"fits depth\")         # get the depth of the image\nSAOImageDS9.get(Int, \"fits bitpix\")        # get the bits per pixel of the image\nSAOImageDS9.get(TupleOf{Int}, \"fits size\") # get the dimensions of the image The dimensions are ordered as  width ,  height  and  depth . To retrieve or set the dimensions of the display window: SAOImageDS9.get(Int, \"width\")    # get the width of the image display window\nSAOImageDS9.get(Int, \"height\")   # get the height of the image display window\nSAOImageDS9.set(\"width\", n)      # set the width of the image display window\nSAOImageDS9.set(\"height\", n)     # set the height of the image display window Display an image and set the scale limits: SAOImageDS9.set(img)\nSAOImageDS9.set(\"scale limits\", 0, maximum(img))"},{"id":637,"pagetitle":"Examples","title":"Frame settings","ref":"/SAOImageDS9/stable/examples/#Frame-settings","content":" Frame settings"},{"id":638,"pagetitle":"Examples","title":"Set frame settings","ref":"/SAOImageDS9/stable/examples/#Set-frame-settings","content":" Set frame settings SAOImageDS9.set(\"frame center\")       # center current frame\nSAOImageDS9.set(\"frame center\",1)     # center 'Frame1'\nSAOImageDS9.set(\"frame center all\")   # center all frames\nSAOImageDS9.set(\"frame clear\")        # clear current frame\nSAOImageDS9.set(\"frame new\")          # create new frame\nSAOImageDS9.set(\"frame new rgb\")      # create new rgb frame\nSAOImageDS9.set(\"frame delete\")       # delete current frame\nSAOImageDS9.set(\"frame reset\")        # reset current frame\nSAOImageDS9.set(\"frame refresh\")      # refresh current frame\nSAOImageDS9.set(\"frame hide\")         # hide current frame\nSAOImageDS9.set(\"frame show\",1)       # show frame 'Frame1'\nSAOImageDS9.set(\"frame move first\")   # move frame to first in order\nSAOImageDS9.set(\"frame move back\")    # move frame back in order\nSAOImageDS9.set(\"frame move forward\") # move frame forward in order\nSAOImageDS9.set(\"frame move last\")    # move frame to last in order\nSAOImageDS9.set(\"frame first\")        # goto first frame\nSAOImageDS9.set(\"frame prev\")         # goto prev frame\nSAOImageDS9.set(\"frame next\")         # goto next frame\nSAOImageDS9.set(\"frame last\")         # goto last frame\nSAOImageDS9.set(\"frame frameno 4\")    # goto frame 'Frame4',create if needed\nSAOImageDS9.set(\"frame\", 3)           # goto frame 'Frame3',create if needed\nSAOImageDS9.set(\"frame match wcs\")\nSAOImageDS9.set(\"frame lock wcs\")"},{"id":639,"pagetitle":"Examples","title":"Get frame settings","ref":"/SAOImageDS9/stable/examples/#Get-frame-settings","content":" Get frame settings SAOImageDS9.get(Int, \"frame\")            # returns the id of the current frame\nSAOImageDS9.get(Int, \"frame frameno\")    # returns the id of the current frame\nSAOImageDS9.get(TupleOf{Int}, \"frame all\")    # returns the id of all frames\nSAOImageDS9.get(TupleOf{Int}, \"frame active\") # returns the id of all active frames\nSAOImageDS9.get(String, \"frame lock\")\nSAOImageDS9.get(Bool, \"frame has amplifier\")\nSAOImageDS9.get(Bool, \"frame has datamin\")\nSAOImageDS9.get(Bool, \"frame has datasec\")\nSAOImageDS9.get(Bool, \"frame has detector\")\nSAOImageDS9.get(Bool, \"frame has grid\")\nSAOImageDS9.get(Bool, \"frame has iis\")\nSAOImageDS9.get(Bool, \"frame has irafmin\")\nSAOImageDS9.get(Bool, \"frame has physical\")\nSAOImageDS9.get(Bool, \"frame has smooth\")\nSAOImageDS9.get(Bool, \"frame has contour\")\nSAOImageDS9.get(Bool, \"frame has contour aux\")\nSAOImageDS9.get(Bool, \"frame has fits\")\nSAOImageDS9.get(Bool, \"frame has fits bin\")\nSAOImageDS9.get(Bool, \"frame has fits cube\")\nSAOImageDS9.get(Bool, \"frame has fits mosaic\")\nSAOImageDS9.get(Bool, \"frame has marker highlite\")\nSAOImageDS9.get(Bool, \"frame has marker paste\")\nSAOImageDS9.get(Bool, \"frame has marker select\")\nSAOImageDS9.get(Bool, \"frame has marker undo\")\nSAOImageDS9.get(Bool, \"frame has system physical\")\nSAOImageDS9.get(Bool, \"frame has wcs wcsa\")\nSAOImageDS9.get(Bool, \"frame has wcs equatorial wcsa\")\nSAOImageDS9.get(Bool, \"frame has wcs linear wcsa\")"},{"id":640,"pagetitle":"Examples","title":"Other examples","ref":"/SAOImageDS9/stable/examples/#Other-examples","content":" Other examples Get  about  string: SAOImageDS9.get(String, \"about\") Get version number: SAOImageDS9.get(VersionNumber, \"version\") Exit SAOImage/DS9: SAOImageDS9.set(\"exit\") Is SAOImage/DS9 iconified? SAOImageDS9.get(Bool, \"iconify\") (De)iconify SAOImage/DS9: SAOImageDS9.set(\"iconify\", bool) SAOImageDS9.set(\"lower\")\nSAOImageDS9.set(\"raise\") # can be used to de-iconify Get/set zoom level: SAOImageDS9.get(Float64, \"zoom\")  # get current zoom level\nSAOImageDS9.set(\"zoom\", value)\nSAOImageDS9.set(\"zoom to\", value)\nSAOImageDS9.set(\"zoom to fit\") Rotation: SAOImageDS9.get(Float64, \"rotate\")\nSAOImageDS9.set(\"rotate\", value)\nSAOImageDS9.set(\"rotate to\", value)\nSAOImageDS9.set(\"rotate open\")\nSAOImageDS9.set(\"rotate close\") SAOImageDS9.get(String, \"orient\")\nSAOImageDS9.set(\"orient\", value) #iexam(;event::Union{AbstractString,Symbol}=:button) = get_words(\"iexam\", event)\n\niexam(args...; event::Union{AbstractString,Symbol}=:button) =\n    get_words(\"iexam\", event, args...)\n\nSAOImageDS9.get(Int, :threads)  # get threads\nSAOImageDS9.set(\"threads\", n)"},{"id":643,"pagetitle":"Installation","title":"Installation","ref":"/SAOImageDS9/stable/install/#Installation","content":" Installation To use this package, the SAOImage/DS9 program and the  XPA  dynamic library and headers must be installed on your computer.  If this is not the case, they are available for different operating systems.  For example, on Debian or Ubuntu-like Linux system, you can call  apt  (or  apt-get  on older systems) from the command line: sudo apt install saods9 libxpa-dev SAOImageDS9  can be can be installed by Julia's package manager. In the Julia REPL, press  ]  to drop into package mode, then run pkg> add SAOImageDS9 Another possibility from Julia's REPL or in a Julia script: using Pkg\nPkg.add(\"SAOImageDS9\")\n# or\nPkg.add(PackageSpec(name=\"SAOImageDS9\", rev=\"master\")) See  XPA.jl site  for instructions about how to install this package if the installation of  SAOImageDS9  fails to properly install this required package. To upgrade the  SAOImageDS9  package: using Pkg\nPkg.update(\"SAOImageDS9\") There is nothing to build."},{"id":646,"pagetitle":"Package library","title":"Package library","ref":"/SAOImageDS9/stable/library/#Package-library","content":" Package library"},{"id":647,"pagetitle":"Package library","title":"Requests to SAOImage/DS9","ref":"/SAOImageDS9/stable/library/#Requests-to-SAOImage/DS9","content":" Requests to SAOImage/DS9"},{"id":648,"pagetitle":"Package library","title":"SAOImageDS9.get","ref":"/SAOImageDS9/stable/library/#SAOImageDS9.get","content":" SAOImageDS9.get  —  Function SAOImageDS9.get([T, [dims,]] args...) sends a \"get\" request to the SAOImage/DS9 server.  The request is made of arguments  args...  converted into strings and merged with separating spaces. An exception is thrown in case of error. The returned value depends on the optional arguments  T  and  dims : If neither  T  nor  dims  are specified, an instance of  XPA.Reply  is returned with at most one answer (see documentation for  XPA.get  for more details). If only  T  is specified, it can be: String  to return the answer as a single string; Vector{String}}  or  Tuple{Vararg{String}}  to return the answer split in words as a vector or as a tuple of strings; T  where  T<:Real  to return a value of type  T  obtained by parsing the textual answer. Tuple{Vararg{T}}  where  T<:Real  to return a value of type  T  obtained by parsing the textual answer; Vector{T}  where  T  is not  String  to return the binary contents of the answer as a vector of type  T ; If both  T  and  dims  are specified,  T  can be an array type like  Array{S}  or  Array{S,N}  and  dims  a list of  N  dimensions to retrieve the binary contents of the answer as an array of type  Array{S,N} . As a special case: SAOImageDS9.get(Array; endian=:native) -> arr yields the contents of current SAOImage/DS9 frame as an array (or as  nothing  if the frame is empty). Keyword  endian  can be used to specify the byte order of the received values (see  SAOImageDS9.byte_order ). See also SAOImageDS9.connect ,  SAOImageDS9.set  and  XPA.get . source SAOImageDS9.get(VersionNumber) Retrieve the version of the SAOImage/DS9 program. source"},{"id":649,"pagetitle":"Package library","title":"SAOImageDS9.set","ref":"/SAOImageDS9/stable/library/#SAOImageDS9.set","content":" SAOImageDS9.set  —  Function SAOImageDS9.set(args...; data=nothing) sends command and/or data to the SAOImage/DS9 server.  The command is made of arguments  args...  converted into strings and merged with a separating spaces. Keyword  data  can be used to specify the data to send.  An exception is thrown in case of error. As a special case: SAOImageDS9.set(arr; mask=false, new=false, endian=:native) set the contents of the current SAOImage/DS9 frame to be array  arr .  Keyword  new  can be set true to create a new frame for displyaing the array.  Keyword  endian  can be used to specify the byte order of the values in  arr  (see  SAOImageDS9.byte_order . See also  SAOImageDS9.connect ,  SAOImageDS9.get  and  XPA.set . source"},{"id":650,"pagetitle":"Package library","title":"Connection","ref":"/SAOImageDS9/stable/library/#Connection","content":" Connection"},{"id":651,"pagetitle":"Package library","title":"SAOImageDS9.connect","ref":"/SAOImageDS9/stable/library/#SAOImageDS9.connect","content":" SAOImageDS9.connect  —  Function SAOImageDS9.connect(ident=\"DS9:*\") -> apt set the access point for further SAOImage/DS9 commands. Argument  ident  identifies the XPA access point, it can be a template string like  \"DS9:*\"  which is the default value or a regular expression. The returned value is the name of the access point. To retrieve the name of the current SAOImage/DS9 access point, call the  SAOImageDS9.accesspoint  method. source"},{"id":652,"pagetitle":"Package library","title":"SAOImageDS9.accesspoint","ref":"/SAOImageDS9/stable/library/#SAOImageDS9.accesspoint","content":" SAOImageDS9.accesspoint  —  Function SAOImageDS9.accesspoint() yields the XPA access point which identifies the SAOImage/DS9 server.  This access point can be set by calling the  SAOImageDS9.connect  method. An empty string is returned if no access point has been chosen.  To automatically connect to SAOImage/DS9 if not yet done, you can do: if SAOImageDS9.accesspoint() == \"\"\n    SAOImageDS9.connect()\nend See also  SAOImageDS9.connect  and  SAOImageDS9.accesspoint . source"},{"id":653,"pagetitle":"Package library","title":"Drawing","ref":"/SAOImageDS9/stable/library/#Drawing","content":" Drawing"},{"id":654,"pagetitle":"Package library","title":"SAOImageDS9.draw","ref":"/SAOImageDS9/stable/library/#SAOImageDS9.draw","content":" SAOImageDS9.draw  —  Function SAOImageDS9.draw(args...; kwds...) draws something in SAOImage/DS9 application.  The operation depends on the type of the arguments. source SAOImageDS9.draw(img::AbstractMatrix; kwds...) displays image  img  (a 2-dimensional Julia array) in SAOImage/DS9. The following keywords are possible: Keyword  frame  can be used to specify the frame number. Keyword  cmap  can be used to specify the name of the colormap.  For instance,  cmap=\"gist_stern\" . Keyword  zoom  can be used to specify the zoom factor. Keywords  min  and/or  max  can be used to specify the scale limits. source SAOImageDS9.draw(pnt; kwds...) draws  pnt  as point(s) in SAOImage/DS9,  pnt  is a  Point , an array or a tuple of  Point . source SAOImageDS9.draw(box; kwds...) draws  box  as rectangle(s) in SAOImage/DS9,  box  is a  BoundingBox , an array or a tuple of  BoundingBox . source"},{"id":655,"pagetitle":"Package library","title":"Utilities","ref":"/SAOImageDS9/stable/library/#Utilities","content":" Utilities"},{"id":656,"pagetitle":"Package library","title":"SAOImageDS9.bitpix_of","ref":"/SAOImageDS9/stable/library/#SAOImageDS9.bitpix_of","content":" SAOImageDS9.bitpix_of  —  Function SAOImageDS9.bitpix_of(x) -> bp yields FITS bits-per-pixel (BITPIX) value for  x  which can be an array or a type. A value of 0 is returned if  x  is not of a supported type. See also  SAOImageDS9.bitpix_to_type . source"},{"id":657,"pagetitle":"Package library","title":"SAOImageDS9.bitpix_to_type","ref":"/SAOImageDS9/stable/library/#SAOImageDS9.bitpix_to_type","content":" SAOImageDS9.bitpix_to_type  —  Function SAOImageDS9.bitpix_to_type(bp) -> T yields Julia type corresponding to FITS bits-per-pixel (BITPIX) value  bp . The type  Nothing  is returned if  bp  is unknown. See also  SAOImageDS9.bitpix_of . source"},{"id":658,"pagetitle":"Package library","title":"SAOImageDS9.byte_order","ref":"/SAOImageDS9/stable/library/#SAOImageDS9.byte_order","content":" SAOImageDS9.byte_order  —  Function SAOImageDS9.byte_order(endian) yields the byte order for retrieving the elements of a SAOImage/DS9 array. Argument can be one of the strings (or the equivalent symbol):  \"big\"  for most significant byte first,  \"little\"  for least significant byte first or  \"native\"  to yield the byte order of the machine. See also  SAOImageDS9.get ,  SAOImageDS9.set . source"},{"id":661,"pagetitle":"SAOImage/DS9 requests","title":"SAOImage/DS9 requests","ref":"/SAOImageDS9/stable/requests/#SAOImage/DS9-requests","content":" SAOImage/DS9 requests There are two kinds of requests:  get  requests to retrieve some information or data from SAOImage/DS9 and  set  requests to send some data to SAOImage/DS9 or to set some of its parameters."},{"id":662,"pagetitle":"SAOImage/DS9 requests","title":"Set requests","ref":"/SAOImageDS9/stable/requests/#Set-requests","content":" Set requests The general syntax to perform a  set  request to the current SAOImage/DS9 access point is: SAOImageDS9.set(args...; data=nothing) where  args...  are any number of arguments which will be automatically converted in a string where the arguments are separated by spaces.  The keyword  data  may be used to specify the data to send with the request, it may be  nothing  (the default) or a Julia array.  For instance, the following 3 calls will set the current zoom to be equal to 3.7: SAOImageDS9.set(:zoom,:to,3.7)\nSAOImageDS9.set(\"zoom to\",3.7)\nSAOImageDS9.set(\"zoom to 3.7\") where the last line shows the string which is effectively sent to SAOImage/DS9 via the  XPA.set  method in the 3 above cases. As a special case,  args...  can be a single array to send to SAOImage/DS9 for being displayed: SAOImageDS9.set(arr) where  arr  is a 2D or 3D Julia array.  SAOImage/DS9 will display the values of  arr  as an image (if  arr  is a 2D array) or a sequence of images (if  arr  is a 3D array) in the currently selected frame with the current scale parameters, zoom, orientation, rotation, etc.  Keyword  order  can be used to specify the byte ordering.  Keyword  new  can be set true to display the image in a new SAOImage/DS9 frame."},{"id":663,"pagetitle":"SAOImage/DS9 requests","title":"Get requests","ref":"/SAOImageDS9/stable/requests/#Get-requests","content":" Get requests To perform a  get  request, the general syntax is: SAOImageDS9.get([T, [dims,]] args...) where the  args...  arguments are treated as for the  SAOImageDS9.set  method (that is converted into a single text string with separating spaces).  Optional arguments  T  and  dims  are to specify the type of the expected result and, possibly, its list of dimensions. If neither  T  nor  dims  are specified, the result of the  SAOImageDS9.get(args...)  call is an instance of  XPA.Reply  (see documentation about XPA.jl package for how to deal with the contents of such an instance). The following methods can be used to issue a  get  request to the current DS9 access point depending on the expected type of result: SAOImageDS9.get(Vector{UInt8}, args...)         -> buf\nSAOImageDS9.get(String, args...)                -> str\nSAOImageDS9.get(Vector{String}, args...;\n                delim=isspace, keepempty=false) -> arr\nSAOImageDS9.get(Tuple{Vararg{String}}, args...;\n                delim=isspace, keepempty=false) -> tup where  args...  are treated as for the  SAOImageDS9.set  method.  The returned values are respectively a vector of bytes, a single string (with the last end-of-line removed if any), an array of strings (one for each line of the result and empty line removed unless keyword  keepempty  is set  true ), or an array of (non-empty) words. If a single scalar integer or floating point is expected, two methods are available: SAOImageDS9.get(Int, args...)    -> scalar\nSAOImageDS9.get(Float, args...)  -> scalar which return respectively an  Int  and a  Float64 . To retrieve the array displayed by the current SAOImage/DS9 frame, do: arr = SAOImageDS9.get(Array); Keyword  order  can be used to specify the byte ordering."},{"id":666,"pagetitle":"Starting","title":"Starting","ref":"/SAOImageDS9/stable/starting/#Starting","content":" Starting To use  SAOImageDS9  package, type: using SAOImageDS9 will import the symbol  DS9  which can be used to prefix all methods available in  SAOImageDS9  instead of the full package name which can be a bit tedious in interactive sessions.  If you prefer another prefix, say  sao , you can do: import SAOImageDS9\nconst sao = SAOImageDS9 or (provided your Julia version is at least 1.6): import SAOImageDS9 as sao You may also just  import SAOImageDS9  and keep the  SAOImageDS9  prefix. Throughout all the remaining documentation, no shortcut is assumed. You may call the  SAOImageDS9.connect  method to specify the access point to a given running SAOImage/DS9 application.  If no given access point is specified,  SAOImageDS9  will automatically attempts to connect to the first access point matching  \"DS9.*\"  when a command is sent to SAOImage/DS9.  The method  SAOImageDS9.accesspoint()  yields the name of the current access point to SAOImage/DS9, or an empty string if none has been chosen. To check the connection to SAOImage/DS9, you can type: SAOImageDS9.get(VersionNumber) which should yield the version of the SAOImage/DS9 to which you are connected."},{"id":669,"pagetitle":"Home","title":"AstroTime","ref":"/AstroTime/stable/#AstroTime","content":" AstroTime Astronomical time keeping in Julia AstroTime.jl provides a high-precision, time-scale aware,  DateTime -like data type which supports all commonly used astronomical time scales."},{"id":670,"pagetitle":"Home","title":"Installation","ref":"/AstroTime/stable/#Installation","content":" Installation The package can be installed through Julia's package manager: julia> import Pkg; Pkg.add(\"AstroTime\")"},{"id":671,"pagetitle":"Home","title":"Quickstart","ref":"/AstroTime/stable/#Quickstart","content":" Quickstart Create an Epoch based on the TT (Terrestial Time) scale julia> tt = TTEpoch(\"2018-01-01T12:00:00\")\n2018-01-01T12:00:00.000 TT Transform to TAI (International Atomic Time) julia> tai = TAIEpoch(tt)\n2018-01-01T11:59:27.816 TAI Transform to TDB (Barycentric Dynamical Time) julia> tdb = TDBEpoch(tai)\n2018-01-01T11:59:59.999 TDB Shift an Epoch by one day julia> another_day = tt + 1days\n2018-01-02T12:00:00.000 TT"},{"id":672,"pagetitle":"Home","title":"Next Steps","ref":"/AstroTime/stable/#Next-Steps","content":" Next Steps Follow the  Tutorial  to get an in-depth look at AstroTime.jl's functionality."},{"id":675,"pagetitle":"Epochs","title":"Epochs","ref":"/AstroTime/stable/api/epochs/#Epochs","content":" Epochs"},{"id":676,"pagetitle":"Epochs","title":"AstroTime.Epochs.Epoch","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.Epoch","content":" AstroTime.Epochs.Epoch  —  Type Epoch(str[, format]) Construct an  Epoch  from a string  str . Optionally a  format  definition can be passed as a  DateFormat  object or as a string. In addition to the character codes supported by  DateFormat  the character code  D  is supported which is parsed as \"day of year\" (see the example below) and the character code  t  which is parsed as the time scale.  The default format is  yyyy-mm-ddTHH:MM:SS.sss ttt . Note:  Please be aware that this constructor requires that the time scale is part of  str , e.g.  2018-02-06T00:00 TAI . Otherwise use an explicit constructor, e.g.  Epoch{TAI} . Example julia> Epoch(\"2018-02-06T20:45:00.0 TAI\")\n2018-02-06T20:45:00.000 TAI\n\njulia> Epoch(\"2018-037T00:00 TAI\", \"yyyy-DDDTHH:MM ttt\")\n2018-02-06T00:00:00.000 TAI source"},{"id":677,"pagetitle":"Epochs","title":"AstroTime.Epochs.Epoch","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.Epoch-Union{Tuple{AbstractString}, Tuple{S}, Tuple{AbstractString, Dates.DateFormat}} where S","content":" AstroTime.Epochs.Epoch  —  Method Epoch{S}(str[, format]) where S Construct an  Epoch  with time scale  S  from a string  str . Optionally a  format  definition can be passed as a  DateFormat  object or as a string. In addition to the character codes supported by  DateFormat  the code  D  can be used which is parsed as \"day of year\" (see the example below).  The default format is  yyyy-mm-ddTHH:MM:SS.sss . Example julia> Epoch{InternationalAtomicTime}(\"2018-02-06T20:45:00.0\")\n2018-02-06T20:45:00.000 TAI\n\njulia> Epoch{InternationalAtomicTime}(\"February 6, 2018\", \"U d, y\")\n2018-02-06T00:00:00.000 TAI\n\njulia> Epoch{InternationalAtomicTime}(\"2018-037T00:00\", \"yyyy-DDDTHH:MM\")\n2018-02-06T00:00:00.000 TAI source"},{"id":678,"pagetitle":"Epochs","title":"AstroTime.Epochs.Epoch","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.Epoch-Union{Tuple{Epoch{S1}}, Tuple{S2}, Tuple{S1}} where {S1<:TimeScale, S2<:TimeScale}","content":" AstroTime.Epochs.Epoch  —  Method Epoch{S2}(ep::Epoch{S1}) where {S1, S2} Convert  ep , an  Epoch  with time scale  S1 , to an  Epoch  with time scale  S2 . Examples julia> ep = TTEpoch(2000,1,1)\n2000-01-01T00:00:00.000 TT\n\njulia> TAIEpoch(ep)\n1999-12-31T23:59:27.816 TAI source"},{"id":679,"pagetitle":"Epochs","title":"AstroTime.Epochs.Epoch","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.Epoch-Union{Tuple{Int64, Int64, Int64}, NTuple{4, Int64}, NTuple{5, Int64}, Tuple{S}, Tuple{Int64, Int64, Int64, Int64, Int64, Float64, Vararg{Any}}} where S","content":" AstroTime.Epochs.Epoch  —  Method Epoch{S}(year, month, day, hour=0, minute=0, second=0.0) where S Construct an  Epoch  with time scale  S  from date and time components. Example julia> Epoch{InternationalAtomicTime}(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TAI\n\njulia> Epoch{InternationalAtomicTime}(2018, 2, 6)\n2018-02-06T00:00:00.000 TAI source"},{"id":680,"pagetitle":"Epochs","title":"AstroTime.Epochs.Epoch","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.Epoch-Union{Tuple{S2}, Tuple{S1}, Tuple{Any, Epoch{S1}}} where {S1<:TimeScale, S2<:TimeScale}","content":" AstroTime.Epochs.Epoch  —  Method Epoch{S}(Δtai, ep::TAIEpoch) where S Convert  ep , a  TAIEpoch , to an  Epoch  with time scale  S  by overriding the offset between  S2  and  TAI  with  Δtai . Examples julia> ep = TAIEpoch(2000,1,1)\n2000-01-01T00:00:00.000 TAI\n\njulia> TTEpoch(32.184, ep)\n2000-01-01T00:00:32.184 TT source"},{"id":681,"pagetitle":"Epochs","title":"AstroTime.Epochs.Epoch","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.Epoch-Union{Tuple{S2}, Tuple{S1}, Tuple{Epoch{S1}, S2}} where {S1<:TimeScale, S2<:TimeScale}","content":" AstroTime.Epochs.Epoch  —  Method Epoch(ep::Epoch{S1}, scale::S2) where {S1, S2} Convert  ep , an  Epoch  with time scale  S1 , to an  Epoch  with time scale  S2 . Examples julia> ep = TTEpoch(2000,1,1)\n2000-01-01T00:00:00.000 TT\n\njulia> Epoch(ep, TAI)\n1999-12-31T23:59:27.816 TAI source"},{"id":682,"pagetitle":"Epochs","title":"AstroTime.Epochs.Epoch","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.Epoch-Union{Tuple{T}, Tuple{S}, Tuple{T, T, Vararg{Any}}} where {S, T<:AstroPeriod}","content":" AstroTime.Epochs.Epoch  —  Method Epoch{S}(jd1::T, jd2::T=zero(T); origin=:j2000) where {S, T<:AstroPeriod} Construct an  Epoch  with time scale  S  from a Julian date (optionally split into  jd1  and  jd2 ).  origin  determines the variant of Julian date that is used. Possible values are: :j2000 : J2000 Julian date, starts at  2000-01-01T12:00 :julian : Julian date, starts at  -4712-01-01T12:00 :modified_julian : Modified Julian date, starts at  1858-11-17T00:00 Examples julia> Epoch{InternationalAtomicTime}(0.0days, 0.5days)\n2000-01-02T00:00:00.000 TAI\n\njulia> Epoch{InternationalAtomicTime}(2.451545e6days, origin=:julian)\n2000-01-01T12:00:00.000 TAI source"},{"id":683,"pagetitle":"Epochs","title":"AstroTime.Epochs.TAIEpoch","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.TAIEpoch-Tuple{AbstractString}","content":" AstroTime.Epochs.TAIEpoch  —  Method TAIEpoch(str[, format]) Construct a TAIEpoch from a string  str . Optionally a  format  definition can be passed as a  DateFormat  object or as a string. In addition to the character codes supported by  DateFormat  the code  D  is supported which is parsed as \"day of year\" (see the example below). The default format is  yyyy-mm-ddTHH:MM:SS.sss . Example julia> TAIEpoch(\"2018-02-06T20:45:00.0\")\n2018-02-06T20:45:00.000 TAI\n\njulia> TAIEpoch(\"February 6, 2018\", \"U d, y\")\n2018-02-06T00:00:00.000 TAI\n\njulia> TAIEpoch(\"2018-37T00:00\", \"yyyy-DDDTHH:MM\")\n2018-02-06T00:00:00.000 TAI source"},{"id":684,"pagetitle":"Epochs","title":"AstroTime.Epochs.TAIEpoch","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.TAIEpoch-Tuple{Int64, Int64, Int64}","content":" AstroTime.Epochs.TAIEpoch  —  Method TAIEpoch(year, month, day, hour=0, minute=0, second=0.0) Construct a TAIEpoch from date and time components. Example julia> TAIEpoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TAI\n\njulia> TAIEpoch(2018, 2, 6)\n2018-02-06T00:00:00.000 TAI source"},{"id":685,"pagetitle":"Epochs","title":"AstroTime.Epochs.TAIEpoch","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.TAIEpoch-Tuple{Number, Number}","content":" AstroTime.Epochs.TAIEpoch  —  Method TAIEpoch(jd1::T, jd2::T=zero(T); origin=:j2000) where T<:AstroPeriod Construct a TAIEpoch from a Julian date (optionally split into  jd1  and  jd2 ).  origin  determines the variant of Julian date that is used. Possible values are: :j2000 : J2000 Julian date, starts at  2000-01-01T12:00 :julian : Julian date, starts at  -4712-01-01T12:00 :modified_julian : Modified Julian date, starts at  1858-11-17T00:00 Examples julia> TAIEpoch(0.0days, 0.5days)\n2000-01-02T00:00:00.000 TAI\n\njulia> TAIEpoch(2.451545e6days, origin=:julian)\n2000-01-01T12:00:00.000 TAI source"},{"id":686,"pagetitle":"Epochs","title":"AstroTime.Epochs.TCBEpoch","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.TCBEpoch-Tuple{AbstractString}","content":" AstroTime.Epochs.TCBEpoch  —  Method TCBEpoch(str[, format]) Construct a TCBEpoch from a string  str . Optionally a  format  definition can be passed as a  DateFormat  object or as a string. In addition to the character codes supported by  DateFormat  the code  D  is supported which is parsed as \"day of year\" (see the example below). The default format is  yyyy-mm-ddTHH:MM:SS.sss . Example julia> TCBEpoch(\"2018-02-06T20:45:00.0\")\n2018-02-06T20:45:00.000 TCB\n\njulia> TCBEpoch(\"February 6, 2018\", \"U d, y\")\n2018-02-06T00:00:00.000 TCB\n\njulia> TCBEpoch(\"2018-37T00:00\", \"yyyy-DDDTHH:MM\")\n2018-02-06T00:00:00.000 TCB source"},{"id":687,"pagetitle":"Epochs","title":"AstroTime.Epochs.TCBEpoch","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.TCBEpoch-Tuple{Int64, Int64, Int64}","content":" AstroTime.Epochs.TCBEpoch  —  Method TCBEpoch(year, month, day, hour=0, minute=0, second=0.0) Construct a TCBEpoch from date and time components. Example julia> TCBEpoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TCB\n\njulia> TCBEpoch(2018, 2, 6)\n2018-02-06T00:00:00.000 TCB source"},{"id":688,"pagetitle":"Epochs","title":"AstroTime.Epochs.TCBEpoch","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.TCBEpoch-Tuple{Number, Number}","content":" AstroTime.Epochs.TCBEpoch  —  Method TCBEpoch(jd1::T, jd2::T=zero(T); origin=:j2000) where T<:AstroPeriod Construct a TCBEpoch from a Julian date (optionally split into  jd1  and  jd2 ).  origin  determines the variant of Julian date that is used. Possible values are: :j2000 : J2000 Julian date, starts at  2000-01-01T12:00 :julian : Julian date, starts at  -4712-01-01T12:00 :modified_julian : Modified Julian date, starts at  1858-11-17T00:00 Examples julia> TCBEpoch(0.0days, 0.5days)\n2000-01-02T00:00:00.000 TCB\n\njulia> TCBEpoch(2.451545e6days, origin=:julian)\n2000-01-01T12:00:00.000 TCB source"},{"id":689,"pagetitle":"Epochs","title":"AstroTime.Epochs.TCGEpoch","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.TCGEpoch-Tuple{AbstractString}","content":" AstroTime.Epochs.TCGEpoch  —  Method TCGEpoch(str[, format]) Construct a TCGEpoch from a string  str . Optionally a  format  definition can be passed as a  DateFormat  object or as a string. In addition to the character codes supported by  DateFormat  the code  D  is supported which is parsed as \"day of year\" (see the example below). The default format is  yyyy-mm-ddTHH:MM:SS.sss . Example julia> TCGEpoch(\"2018-02-06T20:45:00.0\")\n2018-02-06T20:45:00.000 TCG\n\njulia> TCGEpoch(\"February 6, 2018\", \"U d, y\")\n2018-02-06T00:00:00.000 TCG\n\njulia> TCGEpoch(\"2018-37T00:00\", \"yyyy-DDDTHH:MM\")\n2018-02-06T00:00:00.000 TCG source"},{"id":690,"pagetitle":"Epochs","title":"AstroTime.Epochs.TCGEpoch","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.TCGEpoch-Tuple{Int64, Int64, Int64}","content":" AstroTime.Epochs.TCGEpoch  —  Method TCGEpoch(year, month, day, hour=0, minute=0, second=0.0) Construct a TCGEpoch from date and time components. Example julia> TCGEpoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TCG\n\njulia> TCGEpoch(2018, 2, 6)\n2018-02-06T00:00:00.000 TCG source"},{"id":691,"pagetitle":"Epochs","title":"AstroTime.Epochs.TCGEpoch","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.TCGEpoch-Tuple{Number, Number}","content":" AstroTime.Epochs.TCGEpoch  —  Method TCGEpoch(jd1::T, jd2::T=zero(T); origin=:j2000) where T<:AstroPeriod Construct a TCGEpoch from a Julian date (optionally split into  jd1  and  jd2 ).  origin  determines the variant of Julian date that is used. Possible values are: :j2000 : J2000 Julian date, starts at  2000-01-01T12:00 :julian : Julian date, starts at  -4712-01-01T12:00 :modified_julian : Modified Julian date, starts at  1858-11-17T00:00 Examples julia> TCGEpoch(0.0days, 0.5days)\n2000-01-02T00:00:00.000 TCG\n\njulia> TCGEpoch(2.451545e6days, origin=:julian)\n2000-01-01T12:00:00.000 TCG source"},{"id":692,"pagetitle":"Epochs","title":"AstroTime.Epochs.TDBEpoch","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.TDBEpoch-Tuple{AbstractString}","content":" AstroTime.Epochs.TDBEpoch  —  Method TDBEpoch(str[, format]) Construct a TDBEpoch from a string  str . Optionally a  format  definition can be passed as a  DateFormat  object or as a string. In addition to the character codes supported by  DateFormat  the code  D  is supported which is parsed as \"day of year\" (see the example below). The default format is  yyyy-mm-ddTHH:MM:SS.sss . Example julia> TDBEpoch(\"2018-02-06T20:45:00.0\")\n2018-02-06T20:45:00.000 TDB\n\njulia> TDBEpoch(\"February 6, 2018\", \"U d, y\")\n2018-02-06T00:00:00.000 TDB\n\njulia> TDBEpoch(\"2018-37T00:00\", \"yyyy-DDDTHH:MM\")\n2018-02-06T00:00:00.000 TDB source"},{"id":693,"pagetitle":"Epochs","title":"AstroTime.Epochs.TDBEpoch","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.TDBEpoch-Tuple{Int64, Int64, Int64}","content":" AstroTime.Epochs.TDBEpoch  —  Method TDBEpoch(year, month, day, hour=0, minute=0, second=0.0) Construct a TDBEpoch from date and time components. Example julia> TDBEpoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TDB\n\njulia> TDBEpoch(2018, 2, 6)\n2018-02-06T00:00:00.000 TDB source"},{"id":694,"pagetitle":"Epochs","title":"AstroTime.Epochs.TDBEpoch","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.TDBEpoch-Tuple{Number, Number}","content":" AstroTime.Epochs.TDBEpoch  —  Method TDBEpoch(jd1::T, jd2::T=zero(T); origin=:j2000) where T<:AstroPeriod Construct a TDBEpoch from a Julian date (optionally split into  jd1  and  jd2 ).  origin  determines the variant of Julian date that is used. Possible values are: :j2000 : J2000 Julian date, starts at  2000-01-01T12:00 :julian : Julian date, starts at  -4712-01-01T12:00 :modified_julian : Modified Julian date, starts at  1858-11-17T00:00 Examples julia> TDBEpoch(0.0days, 0.5days)\n2000-01-02T00:00:00.000 TDB\n\njulia> TDBEpoch(2.451545e6days, origin=:julian)\n2000-01-01T12:00:00.000 TDB source"},{"id":695,"pagetitle":"Epochs","title":"AstroTime.Epochs.TTEpoch","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.TTEpoch-Tuple{AbstractString}","content":" AstroTime.Epochs.TTEpoch  —  Method TTEpoch(str[, format]) Construct a TTEpoch from a string  str . Optionally a  format  definition can be passed as a  DateFormat  object or as a string. In addition to the character codes supported by  DateFormat  the code  D  is supported which is parsed as \"day of year\" (see the example below). The default format is  yyyy-mm-ddTHH:MM:SS.sss . Example julia> TTEpoch(\"2018-02-06T20:45:00.0\")\n2018-02-06T20:45:00.000 TT\n\njulia> TTEpoch(\"February 6, 2018\", \"U d, y\")\n2018-02-06T00:00:00.000 TT\n\njulia> TTEpoch(\"2018-37T00:00\", \"yyyy-DDDTHH:MM\")\n2018-02-06T00:00:00.000 TT source"},{"id":696,"pagetitle":"Epochs","title":"AstroTime.Epochs.TTEpoch","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.TTEpoch-Tuple{Int64, Int64, Int64}","content":" AstroTime.Epochs.TTEpoch  —  Method TTEpoch(year, month, day, hour=0, minute=0, second=0.0) Construct a TTEpoch from date and time components. Example julia> TTEpoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TT\n\njulia> TTEpoch(2018, 2, 6)\n2018-02-06T00:00:00.000 TT source"},{"id":697,"pagetitle":"Epochs","title":"AstroTime.Epochs.TTEpoch","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.TTEpoch-Tuple{Number, Number}","content":" AstroTime.Epochs.TTEpoch  —  Method TTEpoch(jd1::T, jd2::T=zero(T); origin=:j2000) where T<:AstroPeriod Construct a TTEpoch from a Julian date (optionally split into  jd1  and  jd2 ).  origin  determines the variant of Julian date that is used. Possible values are: :j2000 : J2000 Julian date, starts at  2000-01-01T12:00 :julian : Julian date, starts at  -4712-01-01T12:00 :modified_julian : Modified Julian date, starts at  1858-11-17T00:00 Examples julia> TTEpoch(0.0days, 0.5days)\n2000-01-02T00:00:00.000 TT\n\njulia> TTEpoch(2.451545e6days, origin=:julian)\n2000-01-01T12:00:00.000 TT source"},{"id":698,"pagetitle":"Epochs","title":"AstroTime.Epochs.UT1Epoch","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.UT1Epoch-Tuple{AbstractString}","content":" AstroTime.Epochs.UT1Epoch  —  Method UT1Epoch(str[, format]) Construct a UT1Epoch from a string  str . Optionally a  format  definition can be passed as a  DateFormat  object or as a string. In addition to the character codes supported by  DateFormat  the code  D  is supported which is parsed as \"day of year\" (see the example below). The default format is  yyyy-mm-ddTHH:MM:SS.sss . Example julia> UT1Epoch(\"2018-02-06T20:45:00.0\")\n2018-02-06T20:45:00.000 UT1\n\njulia> UT1Epoch(\"February 6, 2018\", \"U d, y\")\n2018-02-06T00:00:00.000 UT1\n\njulia> UT1Epoch(\"2018-37T00:00\", \"yyyy-DDDTHH:MM\")\n2018-02-06T00:00:00.000 UT1 source"},{"id":699,"pagetitle":"Epochs","title":"AstroTime.Epochs.UT1Epoch","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.UT1Epoch-Tuple{Int64, Int64, Int64}","content":" AstroTime.Epochs.UT1Epoch  —  Method UT1Epoch(year, month, day, hour=0, minute=0, second=0.0) Construct a UT1Epoch from date and time components. Example julia> UT1Epoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 UT1\n\njulia> UT1Epoch(2018, 2, 6)\n2018-02-06T00:00:00.000 UT1 source"},{"id":700,"pagetitle":"Epochs","title":"AstroTime.Epochs.UT1Epoch","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.UT1Epoch-Tuple{Number, Number}","content":" AstroTime.Epochs.UT1Epoch  —  Method UT1Epoch(jd1::T, jd2::T=zero(T); origin=:j2000) where T<:AstroPeriod Construct a UT1Epoch from a Julian date (optionally split into  jd1  and  jd2 ).  origin  determines the variant of Julian date that is used. Possible values are: :j2000 : J2000 Julian date, starts at  2000-01-01T12:00 :julian : Julian date, starts at  -4712-01-01T12:00 :modified_julian : Modified Julian date, starts at  1858-11-17T00:00 Examples julia> UT1Epoch(0.0days, 0.5days)\n2000-01-02T00:00:00.000 UT1\n\njulia> UT1Epoch(2.451545e6days, origin=:julian)\n2000-01-01T12:00:00.000 UT1 source"},{"id":701,"pagetitle":"Epochs","title":"AstroTime.AstroDates.fractionofday","ref":"/AstroTime/stable/api/epochs/#AstroTime.AstroDates.fractionofday-Tuple{Epoch}","content":" AstroTime.AstroDates.fractionofday  —  Method fractionofday(ep::Epoch) Get the time of the day of the epoch  ep  as a fraction. source"},{"id":702,"pagetitle":"Epochs","title":"AstroTime.AstroDates.fractionofsecond","ref":"/AstroTime/stable/api/epochs/#AstroTime.AstroDates.fractionofsecond-Tuple{Epoch}","content":" AstroTime.AstroDates.fractionofsecond  —  Method fractionofsecond(ep::Epoch) Get the fraction of the current second of the epoch  ep . source"},{"id":703,"pagetitle":"Epochs","title":"AstroTime.AstroDates.j2000","ref":"/AstroTime/stable/api/epochs/#AstroTime.AstroDates.j2000-Tuple{Epoch}","content":" AstroTime.AstroDates.j2000  —  Method j2000(ep) Return the J2000 Julian Date for epoch  ep . Example julia> j2000(TAIEpoch(2000, 1, 1, 12))\n0.0 days source"},{"id":704,"pagetitle":"Epochs","title":"AstroTime.AstroDates.julian","ref":"/AstroTime/stable/api/epochs/#AstroTime.AstroDates.julian-Tuple{Epoch}","content":" AstroTime.AstroDates.julian  —  Method julian(ep) Return the Julian Date for epoch  ep . Example julia> julian(TAIEpoch(2000, 1, 1, 12))\n2.451545e6 days source"},{"id":705,"pagetitle":"Epochs","title":"AstroTime.AstroDates.julian_twopart","ref":"/AstroTime/stable/api/epochs/#AstroTime.AstroDates.julian_twopart-Tuple{Epoch}","content":" AstroTime.AstroDates.julian_twopart  —  Method julian_twopart(ep) Return the two-part Julian Date for epoch  ep , which is a tuple consisting of the Julian day number and the fraction of the day. Example julia> julian_twopart(TAIEpoch(2000, 1, 2))\n(2.451545e6 days, 0.5 days) source"},{"id":706,"pagetitle":"Epochs","title":"AstroTime.AstroDates.subsecond","ref":"/AstroTime/stable/api/epochs/#AstroTime.AstroDates.subsecond-Tuple{Epoch, Any}","content":" AstroTime.AstroDates.subsecond  —  Method subsecond(ep::Epoch, n) Get the number of fractional seconds with the unit  $s * \\frac{1}{10^n}$ , e.g.  subsecond(ep, 3)  for milliseconds, of the epoch  ep .  n  must be divisible by 3. source"},{"id":707,"pagetitle":"Epochs","title":"AstroTime.Epochs.from_utc","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.from_utc","content":" AstroTime.Epochs.from_utc  —  Function from_utc(str::AbstractString, dateformat::Dates.DateFormat; scale=TAI)\nfrom_utc(dt::Dates.DateTime; scale=TAI)\nfrom_utc(year, month, day, hour=0, minute=0, second=0, fraction=0.0; scale=TAI)\nfrom_utc(year, month, day, hour, minute, seconds; scale=TAI) Create an  Epoch  in  scale  based on a UTC timestamp,  Dates.DateTime  or date and time components. Examples julia> from_utc(2016, 12, 31, 23, 59, 60, 0.0)\n2017-01-01T00:00:36.000 TAI\n\njulia> from_utc(2016, 12, 31, 23, 59, 60.0)\n2017-01-01T00:00:36.000 TAI\n\njulia> from_utc(\"2016-12-31T23:59:60.0\")\n2017-01-01T00:00:36.000 TAI\n\njulia> from_utc(\"2016-12-31T23:59:60.0\", scale=TDB)\n2017-01-01T00:01:08.183 TDB source"},{"id":708,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset","content":" AstroTime.Epochs.getoffset  —  Function getoffset(TAI, UT1, second, fraction[, eop]) Return the offset between  TAI  and  UT1  for the current epoch ( second  after J2000 and  fraction ) in seconds. Optionally, a custom Earth orientation data struct  eop  can be provided, see  EarthOrientation.jl . Example julia> getoffset(TAI, UT1, 0, 0.0)\n-31.644974644349812 source"},{"id":709,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset","content":" AstroTime.Epochs.getoffset  —  Function getoffset(UT1, TAI, second, fraction[, eop]) Return the offset between  UT1  and  TAI  for the current epoch ( second  after J2000 and  fraction ) in seconds. Optionally, a custom Earth orientation data struct  eop  can be provided, see  EarthOrientation.jl . Example julia> getoffset(UT1, TAI, 0, 0.0)\n31.644974965344606 source"},{"id":710,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Tuple{BarycentricCoordinateTime, BarycentricDynamicalTime, Any, Any}","content":" AstroTime.Epochs.getoffset  —  Method getoffset(TCB, TDB, second, fraction) Return the linear offset between  TCB  and  TDB  for the current epoch ( second  after J2000 and  fraction ) in seconds. Example julia> getoffset(TCB, TDB, 0, 0.0)\n-11.253721593757295 source"},{"id":711,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Tuple{BarycentricDynamicalTime, BarycentricCoordinateTime, Any, Any}","content":" AstroTime.Epochs.getoffset  —  Method getoffset(TDB, TCB, second, fraction) Return the linear offset between  TDB  and  TCB  for the current epoch ( second  after J2000 and  fraction ) in seconds. Example julia> getoffset(TDB, TCB, 0, 0.0)\n11.253721768248475 source"},{"id":712,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Tuple{BarycentricDynamicalTime, TerrestrialTime, Any, Any}","content":" AstroTime.Epochs.getoffset  —  Method getoffset(TDB, TT, second, fraction[, eop]) Return the offset between  TDB  and  TT  for the current epoch ( second  after J2000 and  fraction ) in seconds. This routine is accurate to ~40 microseconds over the interval 1900-2100. Note An accurate transformation between TDB and TT depends on the trajectory of the observer. For two observers fixed on Earth's surface the quantity TDB-TT can differ by as much as ~4 microseconds. See  here . Example julia> getoffset(TDB, TT, 0, 0.0)\n7.273677616693264e-5 References https://www.cv.nrao.edu/~rfisher/Ephemerides/times.html#TDB Issue #26 source"},{"id":713,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Tuple{BarycentricDynamicalTime, TerrestrialTime, Vararg{Any, 5}}","content":" AstroTime.Epochs.getoffset  —  Method getoffset(TDB, TT, second, fraction[, eop]) Return the offset between  TDB  and  TT  for the current epoch ( second  after J2000 and  fraction ) for an observer on earth in seconds. Arguments second ,  fraction : Current epoch elong : Longitude (east positive, radians) u : Distance from Earth's spin axis (km) v : Distance north of equatorial plane (km) Example julia> getoffset(TDB, TT, 0, 0.0, π, 6371.0, 0.0)\n9.928419814106208e-5 References ERFA source"},{"id":714,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Tuple{GeocentricCoordinateTime, TerrestrialTime, Any, Any}","content":" AstroTime.Epochs.getoffset  —  Method getoffset(TCG, TT, second, fraction) Return the linear offset between  TCG  and  TT  for the current epoch ( second  after J2000 and  fraction ) in seconds. Example julia> getoffset(TCG, TT, 0, 0.0)\n-0.5058332856685995 source"},{"id":715,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Tuple{InternationalAtomicTime, TerrestrialTime, Vararg{Any}}","content":" AstroTime.Epochs.getoffset  —  Method getoffset(TAI, TT, args...) Return the fixed offset between  TAI  and  TT  in seconds. Example julia> getoffset(TAI, TT)\n32.184 source"},{"id":716,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Tuple{TerrestrialTime, BarycentricDynamicalTime, Any, Any}","content":" AstroTime.Epochs.getoffset  —  Method getoffset(TT, TDB, second, fraction[, eop]) Return the offset between  TT  and  TDB  for the current epoch ( second  after J2000 and  fraction ) in seconds. This routine is accurate to ~40 microseconds over the interval 1900-2100. Note An accurate transformation between TDB and TT depends on the trajectory of the observer. For two observers fixed on Earth's surface the quantity TDB-TT can differ by as much as ~4 microseconds. See  here . Example julia> getoffset(TT, TDB, 0, 0.0)\n-7.273677619130569e-5 References https://www.cv.nrao.edu/~rfisher/Ephemerides/times.html#TDB Issue #26 source"},{"id":717,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Tuple{TerrestrialTime, BarycentricDynamicalTime, Vararg{Any, 5}}","content":" AstroTime.Epochs.getoffset  —  Method getoffset(TT, TDB, second, fraction[, eop]) Return the offset between  TT  and  TDB  for the current epoch ( second  after J2000 and  fraction ) for an observer on earth in seconds. Arguments second ,  fraction : Current epoch elong : Longitude (east positive, radians) u : Distance from Earth's spin axis (km) v : Distance north of equatorial plane (km) Example julia> getoffset(TT, TDB, 0, 0.0, π, 6371.0, 0.0)\n-9.928419818977206e-5 References ERFA source"},{"id":718,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Tuple{TerrestrialTime, GeocentricCoordinateTime, Any, Any}","content":" AstroTime.Epochs.getoffset  —  Method getoffset(TT, TCG, second, fraction) Return the linear offset between  TT  and  TCG  for the current epoch ( second  after J2000 and  fraction ) in seconds. Example julia> getoffset(TT, TCG, 0, 0.0)\n0.5058332860211293 source"},{"id":719,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Tuple{TerrestrialTime, InternationalAtomicTime, Vararg{Any}}","content":" AstroTime.Epochs.getoffset  —  Method getoffset(TT, TAI, args...) Return the fixed offset between  TT  and  TAI  in seconds. Example julia> getoffset(TT, TAI)\n-32.184 source"},{"id":720,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Union{Tuple{S}, Tuple{Epoch{S}, TimeScale, Vararg{Any}}} where S<:TimeScale","content":" AstroTime.Epochs.getoffset  —  Method getoffset(ep::Epoch, scale::TimeScale) For a given epoch  ep  return the offset between its time scale and another time  scale  in seconds. Example julia> tai = TAIEpoch(2000, 1, 1)\n2000-01-01T00:00:00.000 TAI\n\njulia> getoffset(tai, TT)\n32.184 source"},{"id":721,"pagetitle":"Epochs","title":"AstroTime.Epochs.julian_period","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.julian_period-Tuple{Epoch}","content":" AstroTime.Epochs.julian_period  —  Method julian_period([T,] ep::Epoch; origin=:j2000, scale=timescale(ep), unit=days) Return the period since Julian Epoch  origin  within the time scale  scale  expressed in  unit  for a given epoch  ep . The result is an  AstroPeriod  object by default. If the type argument  T  is present, the result is converted to  T  instead. Example julia> ep = TAIEpoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TAI\n\njulia> julian_period(ep; scale=TT)\n6611.364955833334 days\n\njulia> julian_period(ep; unit=years)\n18.100929728496464 years\n\njulia> julian_period(Float64, ep)\n6611.364583333333 source"},{"id":722,"pagetitle":"Epochs","title":"AstroTime.Epochs.modified_julian","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.modified_julian-Tuple{Epoch}","content":" AstroTime.Epochs.modified_julian  —  Method modified_julian(ep) Return the Modified Julian Date for epoch  ep . Example julia> modified_julian(TAIEpoch(2000, 1, 1, 12))\n51544.5 days source"},{"id":723,"pagetitle":"Epochs","title":"AstroTime.Epochs.timescale","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.timescale-Tuple{Epoch}","content":" AstroTime.Epochs.timescale  —  Method timescale(ep) Return the time scale of epoch  ep . Example julia> ep = TTEpoch(2000, 1, 1)\n2000-01-01T00:00:00.000 TT\n\njulia> timescale(ep)\nTT source"},{"id":724,"pagetitle":"Epochs","title":"AstroTime.Epochs.to_utc","ref":"/AstroTime/stable/api/epochs/#AstroTime.Epochs.to_utc","content":" AstroTime.Epochs.to_utc  —  Function to_utc(ep)\nto_utc(::Type{DateTime}, ep)\nto_utc(::Type{Dates.DateTime}, ep)\nto_utc(::Type{String}, ep, dateformat=Dates.default_format(DateTime)) Create a UTC timestamp or  Dates.DateTime  from an  Epoch ep . Examples julia> tai = from_utc(Dates.DateTime(2018, 2, 6, 20, 45, 0, 0))\n2018-02-06T20:45:37.000 TAI\n\njulia> to_utc(tai)\n\"2018-02-06T20:45:00.000\"\n\njulia> to_utc(String, tai, Dates.dateformat\"yyyy-mm-dd\")\n\"2018-02-06\"\n\njulia> to_utc(Dates.DateTime, tai)\n2018-02-06T20:45:00 source"},{"id":725,"pagetitle":"Epochs","title":"Base.:-","ref":"/AstroTime/stable/api/epochs/#Base.:--Union{Tuple{S}, Tuple{Epoch{S}, Epoch{S}}} where S<:TimeScale","content":" Base.:-  —  Method -(a::Epoch, b::Epoch) Return the duration between epoch  a  and epoch  b . Examples julia> TAIEpoch(2018, 2, 6, 20, 45, 20.0) - TAIEpoch(2018, 2, 6, 20, 45, 0.0)\n20.0 seconds source"},{"id":726,"pagetitle":"Epochs","title":"Dates.day","ref":"/AstroTime/stable/api/epochs/#Dates.day-Tuple{Epoch}","content":" Dates.day  —  Method day(ep::Epoch) Get the day of the epoch  ep . source"},{"id":727,"pagetitle":"Epochs","title":"Dates.dayofyear","ref":"/AstroTime/stable/api/epochs/#Dates.dayofyear-Tuple{Epoch}","content":" Dates.dayofyear  —  Method dayofyear(ep::Epoch) Get the day of the year of the epoch  ep . source"},{"id":728,"pagetitle":"Epochs","title":"Dates.hour","ref":"/AstroTime/stable/api/epochs/#Dates.hour-Tuple{Epoch}","content":" Dates.hour  —  Method hour(ep::Epoch) Get the hour of the epoch  ep . source"},{"id":729,"pagetitle":"Epochs","title":"Dates.microsecond","ref":"/AstroTime/stable/api/epochs/#Dates.microsecond-Tuple{Epoch}","content":" Dates.microsecond  —  Method microsecond(ep::Epoch) Get the number of microseconds of the epoch  ep . source"},{"id":730,"pagetitle":"Epochs","title":"Dates.millisecond","ref":"/AstroTime/stable/api/epochs/#Dates.millisecond-Tuple{Epoch}","content":" Dates.millisecond  —  Method millisecond(ep::Epoch) Get the number of milliseconds of the epoch  ep . source"},{"id":731,"pagetitle":"Epochs","title":"Dates.minute","ref":"/AstroTime/stable/api/epochs/#Dates.minute-Tuple{Epoch}","content":" Dates.minute  —  Method minute(ep::Epoch) Get the minute of the epoch  ep . source"},{"id":732,"pagetitle":"Epochs","title":"Dates.month","ref":"/AstroTime/stable/api/epochs/#Dates.month-Tuple{Epoch}","content":" Dates.month  —  Method month(ep::Epoch) Get the month of the epoch  ep . source"},{"id":733,"pagetitle":"Epochs","title":"Dates.nanosecond","ref":"/AstroTime/stable/api/epochs/#Dates.nanosecond-Tuple{Epoch}","content":" Dates.nanosecond  —  Method nanosecond(ep::Epoch) Get the number of nanoseconds of the epoch  ep . source"},{"id":734,"pagetitle":"Epochs","title":"Dates.now","ref":"/AstroTime/stable/api/epochs/#Dates.now-Union{Tuple{Type{Epoch{S}}}, Tuple{S}} where S","content":" Dates.now  —  Method now(::Type{Epoch})\nnow(::Type{Epoch{S}}) where S<:TimeScale Get the current date and time as an  Epoch . The default time scale is TAI. Example julia> now(Epoch)\n2021-04-11T13:20:29.160 TAI\n\njulia> now(TDBEpoch)\n2021-04-11T13:21:21.518 TDB source"},{"id":735,"pagetitle":"Epochs","title":"Dates.second","ref":"/AstroTime/stable/api/epochs/#Dates.second-Tuple{Any, Epoch}","content":" Dates.second  —  Method second(type, ep::Epoch) Get the second of the epoch  ep  as a  type . source"},{"id":736,"pagetitle":"Epochs","title":"Dates.second","ref":"/AstroTime/stable/api/epochs/#Dates.second-Tuple{Epoch}","content":" Dates.second  —  Method second(ep::Epoch) -> Int Get the second of the epoch  ep  as an  Int . source"},{"id":737,"pagetitle":"Epochs","title":"Dates.year","ref":"/AstroTime/stable/api/epochs/#Dates.year-Tuple{Epoch}","content":" Dates.year  —  Method year(ep::Epoch) Get the year of the epoch  ep . source"},{"id":738,"pagetitle":"Epochs","title":"Dates.yearmonthday","ref":"/AstroTime/stable/api/epochs/#Dates.yearmonthday-Tuple{Epoch}","content":" Dates.yearmonthday  —  Method yearmonthday(ep::Epoch) Get the year, month, and day of the epoch  ep  as a tuple. source"},{"id":739,"pagetitle":"Epochs","title":"AstroTime.AstroDates.DateTime","ref":"/AstroTime/stable/api/epochs/#AstroTime.AstroDates.DateTime","content":" AstroTime.AstroDates.DateTime  —  Type DateTime(ep::Epoch) Convert the epoch  ep  to an  AstroDates.DateTime . source"},{"id":740,"pagetitle":"Epochs","title":"AstroTime.AstroDates.Date","ref":"/AstroTime/stable/api/epochs/#AstroTime.AstroDates.Date","content":" AstroTime.AstroDates.Date  —  Type Date(ep::Epoch) Get the  Date  of the epoch  ep . source"},{"id":741,"pagetitle":"Epochs","title":"AstroTime.AstroDates.Time","ref":"/AstroTime/stable/api/epochs/#AstroTime.AstroDates.Time","content":" AstroTime.AstroDates.Time  —  Type Time(ep::Epoch) Get the  Time  of the epoch  ep . source"},{"id":744,"pagetitle":"Periods","title":"Periods","ref":"/AstroTime/stable/api/periods/#Periods","content":" Periods"},{"id":745,"pagetitle":"Periods","title":"AstroTime.Periods.AstroPeriod","ref":"/AstroTime/stable/api/periods/#AstroTime.Periods.AstroPeriod","content":" AstroTime.Periods.AstroPeriod  —  Type AstroPeriod{U, T}(unit, Δt) where {U<:TimeUnit, T} An  AstroPeriod  object represents a time interval of  Δt  with a  TimeUnit  of  unit .  Periods should be constructed via the shorthand syntax shown in the examples below. Examples julia> 3.0seconds\n3.0 seconds\n\njulia> 1.0minutes\n1.0 minutes\n\njulia> 12hours\n12.0 hours\n\njulia> days_per_year = 365\n365\njulia> days_per_year * days\n365.0 days\n\njulia> 10.0years\n10.0 years\n\njulia> 1centuries\n1.0 centuries source"},{"id":746,"pagetitle":"Periods","title":"AstroTime.Periods.TimeUnit","ref":"/AstroTime/stable/api/periods/#AstroTime.Periods.TimeUnit","content":" AstroTime.Periods.TimeUnit  —  Type All time units are subtypes of the abstract type  TimeUnit . The following time units are defined: Second Minute Hour Day Year Century source"},{"id":747,"pagetitle":"Periods","title":"AstroTime.Periods.unit","ref":"/AstroTime/stable/api/periods/#AstroTime.Periods.unit-Tuple{AstroPeriod}","content":" AstroTime.Periods.unit  —  Method unit(p::AstroPeriod) Return the unit of the period  p . Examples julia> unit(3.0seconds)\nAstroTime.Periods.Second() source"},{"id":748,"pagetitle":"Periods","title":"AstroTime.Periods.value","ref":"/AstroTime/stable/api/periods/#AstroTime.Periods.value-Tuple{AstroPeriod}","content":" AstroTime.Periods.value  —  Method value(p::AstroPeriod) Return the unitless value of the period  p . Examples julia> value(3.0seconds)\n3.0 source"},{"id":751,"pagetitle":"Time Scales","title":"Time Scales","ref":"/AstroTime/stable/api/timescales/#Time-Scales","content":" Time Scales"},{"id":752,"pagetitle":"Time Scales","title":"AstroTime.update","ref":"/AstroTime/stable/api/timescales/#AstroTime.update","content":" AstroTime.update  —  Function AstroTime.update() Download up-to-date IERS tables from the internet to enable transformations to and from the  UT1  time scale. source"},{"id":753,"pagetitle":"Time Scales","title":"AstroTime.@timescale","ref":"/AstroTime/stable/api/timescales/#AstroTime.@timescale","content":" AstroTime.@timescale  —  Macro @timescale scale [parent[, oneway]] Define a new time scale and the corresponding  Epoch  type alias. Arguments scale : The name of the time scale parent : The \"parent\" time scale to which it should be linked (optional) oneway : If  true , only the transformation from  parent  to  scale  is   registered (optional, default:  false ) Example julia> @timescale GMT TAI\n\njulia> GMT isa TimeScale\ntrue\n\njulia> GMTEpoch\nEpoch{GMTScale}\n\njulia> find_path(TT, GMT)\n3-element Vector{TimeScale}:\n TT\n TAI\n GMT source"},{"id":754,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.TAI","ref":"/AstroTime/stable/api/timescales/#AstroTime.TimeScales.TAI","content":" AstroTime.TimeScales.TAI  —  Constant TAI The singleton instance of the  InternationalAtomicTime  type representing the International Atomic Time (TAI) time scale. References Wikipedia source"},{"id":755,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.TCB","ref":"/AstroTime/stable/api/timescales/#AstroTime.TimeScales.TCB","content":" AstroTime.TimeScales.TCB  —  Constant TCB The singleton instance of the  BarycentricCoordinateTime  type representing the Barycentric Coordinate Time (TCB) time scale. References Wikipedia source"},{"id":756,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.TCG","ref":"/AstroTime/stable/api/timescales/#AstroTime.TimeScales.TCG","content":" AstroTime.TimeScales.TCG  —  Constant TCG The singleton instance of the  GeocentricCoordinateTime  type representing the Geocentric Coordinate Time (TCG) time scale. References Wikipedia source"},{"id":757,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.TDB","ref":"/AstroTime/stable/api/timescales/#AstroTime.TimeScales.TDB","content":" AstroTime.TimeScales.TDB  —  Constant TDB The singleton instance of the  BarycentricDynamicalTime  type representing the Barycentric Dynamical Time (TDB) time scale. References Wikipedia source"},{"id":758,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.TT","ref":"/AstroTime/stable/api/timescales/#AstroTime.TimeScales.TT","content":" AstroTime.TimeScales.TT  —  Constant TT The singleton instance of the  TerrestrialTime  type representing the Terrestrial Time (TT) time scale. References Wikipedia source"},{"id":759,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.UT1","ref":"/AstroTime/stable/api/timescales/#AstroTime.TimeScales.UT1","content":" AstroTime.TimeScales.UT1  —  Constant UT1 The singleton instance of the  UniversalTime  type representing the Universal Time (UT1) time scale. References Wikipedia source"},{"id":760,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.BarycentricCoordinateTime","ref":"/AstroTime/stable/api/timescales/#AstroTime.TimeScales.BarycentricCoordinateTime","content":" AstroTime.TimeScales.BarycentricCoordinateTime  —  Type BarycentricCoordinateTime A type representing the Barycentric Coordinate Time (TCB) time scale. References Wikipedia source"},{"id":761,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.BarycentricDynamicalTime","ref":"/AstroTime/stable/api/timescales/#AstroTime.TimeScales.BarycentricDynamicalTime","content":" AstroTime.TimeScales.BarycentricDynamicalTime  —  Type BarycentricDynamicalTime A type representing the Barycentric Dynamical Time (TDB) time scale. References Wikipedia source"},{"id":762,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.GeocentricCoordinateTime","ref":"/AstroTime/stable/api/timescales/#AstroTime.TimeScales.GeocentricCoordinateTime","content":" AstroTime.TimeScales.GeocentricCoordinateTime  —  Type GeocentricCoordinateTime A type representing the Geocentric Coordinate Time (TCG) time scale. References Wikipedia source"},{"id":763,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.InternationalAtomicTime","ref":"/AstroTime/stable/api/timescales/#AstroTime.TimeScales.InternationalAtomicTime","content":" AstroTime.TimeScales.InternationalAtomicTime  —  Type InternationalAtomicTime A type representing the International Atomic Time (TAI) time scale. References Wikipedia source"},{"id":764,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.TerrestrialTime","ref":"/AstroTime/stable/api/timescales/#AstroTime.TimeScales.TerrestrialTime","content":" AstroTime.TimeScales.TerrestrialTime  —  Type TerrestrialTime A type representing the Terrestrial Time (TT) time scale. References Wikipedia source"},{"id":765,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.TimeScale","ref":"/AstroTime/stable/api/timescales/#AstroTime.TimeScales.TimeScale","content":" AstroTime.TimeScales.TimeScale  —  Type All timescales are subtypes of the abstract type  TimeScale . The following timescales are defined: UT1  — Universal Time TAI  — International Atomic Time TT  — Terrestrial Time TCG  — Geocentric Coordinate Time TCB  — Barycentric Coordinate Time TDB  — Barycentric Dynamical Time source"},{"id":766,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.UniversalTime","ref":"/AstroTime/stable/api/timescales/#AstroTime.TimeScales.UniversalTime","content":" AstroTime.TimeScales.UniversalTime  —  Type UniversalTime A type representing the Universal Time (UT1) time scale. References Wikipedia source"},{"id":769,"pagetitle":"Tutorial","title":"Tutorial","ref":"/AstroTime/stable/tutorial/#Tutorial","content":" Tutorial This tutorial will walk you through the features and functionality of AstroTime.jl. Everything in this package revolves around the  Epoch  data type.  Epochs  are a high-precision, time-scale aware version of the  DateTime  type from Julia's standard library. This means that while  DateTime  timestamps are always assumed to be based on Universal Time (UT),  Epochs  can be created in several pre-defined time scales or custom user-defined time scales."},{"id":770,"pagetitle":"Tutorial","title":"Creating Epochs","ref":"/AstroTime/stable/tutorial/#Creating-Epochs","content":" Creating Epochs You construct  Epoch  instances similar to  DateTime  instances, for example by using date and time components. The main difference is that you need to supply the time scale to be used. Out of the box, the following time scales are defined: TAI :  International Atomic Time UT1 :  Universal Time [1] TT :  Terrestrial Time TCG :  Geocentric Coordinate Time TCB :  Barycentric Coordinate Time TDB :  Barycentric Dynamical Time Conspicuously missing from this list is  Coordinated Universal Time (UTC) . While AstroTime.jl does support UTC, it requires special treatment due to the discontinuities in the time scale from the introduction of leap seconds. See  UTC and Leap Seconds  for more details. using AstroTime\n\nep = Epoch{InternationalAtomicTime}(2018, 2, 6, 20, 45, 0.0)\n\n# The following shorthand syntax also works\nep = TAIEpoch(2018, 2, 6, 20, 45, 0.0)\n\n# Or in another time scale\nep = TTEpoch(2018, 2, 6, 20, 45, 0.0)\n\n# Or use UTC with leap second handling\nep = from_utc(2018, 2, 6, 20, 45, 0.0) You can also parse an  Epoch  from a string. AstroTime.jl uses the  DateFormat  type and specification language from the  Dates  module from Julia's standard library. For example: ep = TAIEpoch(\"2018-02-06T20:45:00.000\", \"yyyy-mm-ddTHH:MM:SS.fff\")\n\n# The format string above `yyyy-mm-ddTHH:MM:SS.fff` is also the default format.\n# Thus, this also works...\nep = TAIEpoch(\"2018-02-06T20:45:00.000\")\n\nimport Dates\n\n# You can also reuse the format string\ndf = Dates.dateformat\"dd.mm.yyyy HH:MM\"\n\nutc = from_utc(\"06.02.2018 20:45\", df)\ntai = TAIEpoch(\"06.02.2018 20:45\", df) There are three additional character codes supported. f : This character code is parsed as the fraction of the current second and supports an arbitrary number of decimal places. t : This character code is parsed as the time scale. D : This character code is parsed as the day number within a year. The time scale can be omitted from the constructor in the first example because it is already defined in the input string julia> Epoch(\"2018-02-06T20:45:00.000 TAI\", \"yyyy-mm-ddTHH:MM:SS.fff ttt\")\n2018-02-06T20:45:00.000 TAI julia> TAIEpoch(\"2018-037T20:45:00.000\", \"yyyy-DDDTHH:MM:SS.fff\") # February 6 is the 37th day of the year\n2018-02-06T20:45:00.000 TAI When printing  Epochs , you can format the output in the same way. julia> ep = TAIEpoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TAI\n\njulia> AstroTime.format(ep, \"dd.mm.yyyy HH:MM ttt\")\n06.02.2018 20:45 TAI"},{"id":771,"pagetitle":"Tutorial","title":"Working with Epochs and Periods","ref":"/AstroTime/stable/tutorial/#Working-with-Epochs-and-Periods","content":" Working with Epochs and Periods You can shift an  Epoch  in time by adding or subtracting an  AstroPeriod  to it. AstroTime.jl provides a convenient way to construct periods by multiplying a value with a time unit. julia> 23 * seconds\n23 seconds\n\njulia> 1hours # You can use Julia's factor juxtaposition syntax and omit the `*`\n1 hour The following time units are available: seconds minutes hours days years centuries To shift an  Epoch  forward in time add an  AstroPeriod  to it. julia> ep = TAIEpoch(2000, 1, 1)\n2000-01-01T00:00:00.000 TAI\n\njulia> ep + 1days\n2000-01-02T00:00:00.000 TAI Or subtract it to shift the  Epoch  backwards. julia> ep = TAIEpoch(2000, 1, 1)\n2000-01-01T00:00:00.000 TAI\n\njulia> ep - 1days\n1999-12-31T00:00:00.000 TAI If you subtract two epochs you will receive the time between them as an  AstroPeriod . julia> ep1 = TAIEpoch(2000, 1, 1)\n2000-01-01T00:00:00.000 TAI\n\njulia> ep2 = TAIEpoch(2000, 1, 2)\n2000-01-02T00:00:00.000 TAI\n\njulia> ep2 - ep1\n86400.0 seconds You can also construct an  AstroPeriod  with a different time unit from another  AstroPeriod . julia> dt = 86400.0seconds\n86400.0 seconds\n\njulia> days(dt)\n1.0 days To access the raw value of a period, i.e. without a unit, use the  value  function. julia> dt = 86400.0seconds\n86400.0 seconds\n\njulia> value(days(dt))\n1.0"},{"id":772,"pagetitle":"Tutorial","title":"Ranges","ref":"/AstroTime/stable/tutorial/#Ranges","content":" Ranges You can also construct ranges of  Epoch s. The default step size one second. julia> TAIEpoch(2021, 7, 30, 17, 34, 30.0):TAIEpoch(2021, 7, 30, 17, 34, 31.0)\n2021-07-30T17:34:30.000 TAI:1.0 seconds:2021-07-30T17:34:31.000 TAI Or you can adjust the step size with any of the units supported. julia> collect(TAIEpoch(2000, 1, 1):1days:TAIEpoch(2000, 1, 5))\n5-element Vector{TAIEpoch{Float64}}:\n 2000-01-01T00:00:00.000 TAI\n 2000-01-02T00:00:00.000 TAI\n 2000-01-03T00:00:00.000 TAI\n 2000-01-04T00:00:00.000 TAI\n 2000-01-05T00:00:00.000 TAI"},{"id":773,"pagetitle":"Tutorial","title":"Converting Between Time Scales","ref":"/AstroTime/stable/tutorial/#Converting-Between-Time-Scales","content":" Converting Between Time Scales You convert an  Epoch  to another time scale by constructing a new  Epoch  with the target time scale from it. julia> tai = TAIEpoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TAI\n\njulia> tt = TTEpoch(tai) # Convert to TT\n2018-02-06T20:45:32.184 TT"},{"id":774,"pagetitle":"Tutorial","title":"UTC and Leap Seconds","ref":"/AstroTime/stable/tutorial/#UTC-and-Leap-Seconds","content":" UTC and Leap Seconds UTC is the primary civil time standard and aims to provide a time scale based on TAI and uniform SI seconds that is at the same time aligned with UT1 which is based on solar time and governed by the rotation of the Earth. The problem is that Earth's rotation speed is much more irregular compared to atomic clocks which define the SI second. Over the past decades, Earth's rotation has continuously slowed and thus TAI has been running ahead of UT1. Leap seconds are inserted into the UTC time scale to keep it within 0.9 seconds of UT1. This introduces ambiguities in AstroTime.jl's data model (see  #50 ). As a consequence,  UTCEpoch s are not supported. Nevertheless, UTC is supported as an I/O format for timestamps through the  from_utc  and  to_utc  functions. The last leap second was introduced at the end of December 31, 2016. You can create a  TAIEpoch  (or other  Epoch s) from a UTC date with proper leap second handling: julia> from_utc(2016, 12, 31, 23, 59, 60.0)\n2017-01-01T00:00:36.000 TAI\n\njulia> from_utc(\"2016-12-31T23:59:60.0\")\n2017-01-01T00:00:36.000 TAI\n\njulia> from_utc(\"2016-12-31T23:59:60.0\", scale=TDB)\n2017-01-01T00:01:08.183 TDB You can also use  Dates.DateTime  but note that you cannot represent a leap second date with it. julia> tai = from_utc(Dates.DateTime(2018, 2, 6, 20, 45, 0, 0))\n2018-02-06T20:45:37.000 TAI And go back to UTC: julia> to_utc(tai)\n\"2018-02-06T20:45:00.000\"\n\njulia> to_utc(String, tai, Dates.dateformat\"yyyy-mm-dd\")\n\"2018-02-06\"\n\njulia> to_utc(Dates.DateTime, tai)\n2018-02-06T20:45:00"},{"id":775,"pagetitle":"Tutorial","title":"High-Precision Conversions and Custom Offsets","ref":"/AstroTime/stable/tutorial/#High-Precision-Conversions-and-Custom-Offsets","content":" High-Precision Conversions and Custom Offsets Some time scale transformations depend on measured quantities which cannot be accurately predicted (e.g. UT1) or there are different algorithms which offer variable levels of accuracy. For the former, AstroTime.jl can download the required data automatically from the internet. You need to run  AstroTime.update()  periodically (weekly) to keep this data up-to-date. For the latter, AstroTime.jl will use the alogrithm which provides the best trade-off between accuracy and performance for most applications. If you cannot use the internet or want to use a different data source, e.g. a time ephemeris, to obtain the offset between time scales, you can use the following constructor for epochs which overrides the default algorithms. # AstroTime.jl provides a higher precision TDB<->TT transformation that is dependent on\n# the position of the observer on Earth\n\ntt = TTEpoch(2018, 2, 6, 20, 46, 9.184)\ndt = getoffset(tt, TDB, elong, u, v)\n\n# Use the custom offset for the transformation\ntdb = TDBEpoch(dt, tt)"},{"id":776,"pagetitle":"Tutorial","title":"Working with Julian Dates","ref":"/AstroTime/stable/tutorial/#Working-with-Julian-Dates","content":" Working with Julian Dates Epochs can be converted to and from  Julian Dates . Three different base epochs are supported: The (default) J2000 date which starts at January 1, 2000, at 12h, the standard Julian date which starts at January 1, 4712BC, at 12h, and the Modified Julian date which starts at November 17, 1858, at midnight. You can get Julian date in days from an  Epoch  like this: julia> ep = TTEpoch(2000,1,2)\n2000-01-02T00:00:00.000 TT\n\njulia> j2000(ep)\n0.5 days\n\njulia> julian(ep)\n2.4515455e6 days\n\njulia> modified_julian(ep)\n51545.0 days To construct an  Epoch  from a Julian date do this: julia> TTEpoch(0.5days) # J2000 is the default\n2000-01-02T00:00:00.000 TT\n\njulia> TTEpoch(0.5days, origin=:j2000)\n2000-01-02T00:00:00.000 TT\n\njulia> TTEpoch(2.4515455e6days, origin=:julian)\n2000-01-02T00:00:00.000 TT\n\njulia> TTEpoch(51545.0days, origin=:modified_julian)\n2000-01-02T00:00:00.000 TT\n\njulia> TTEpoch(86400.0seconds, origin=:j2000)\n2000-01-02T12:00:00.000 TT Some libraries (such as  ERFA ) expect a two-part Julian date as input. You can use  julian_twopart(ep)  in this case. If you need more control over the output, have a look at the  julian_period  function. Warning You should not convert an  Epoch  to a Julian date to do arithmetic because this will result in a loss of accuracy."},{"id":777,"pagetitle":"Tutorial","title":"Converting to Standard Library Types","ref":"/AstroTime/stable/tutorial/#Converting-to-Standard-Library-Types","content":" Converting to Standard Library Types Epoch  instances satisfy the  AbstractDateTime  interface specified in the  Dates  module of Julia's standard library.  Thus, you should be able to pass them to other libraries which expect a standard  DateTime . Please open an issue on  the issue tracker  if you encounter any problems with this. It is nevertheless possible to convert an  Epoch  to a  DateTime  if it should become necessary. Please note that the time scale information will be lost in the process. julia> ep = TTEpoch(2000,1,1)\n2000-01-01T00:00:00.000 TT\n\njulia> import Dates; Dates.DateTime(ep)\n2000-01-01T00:00:00"},{"id":778,"pagetitle":"Tutorial","title":"Defining Custom Time Scales","ref":"/AstroTime/stable/tutorial/#Defining-Custom-Time-Scales","content":" Defining Custom Time Scales AstroTime.jl enables you to create your own first-class time scales via the  @timescale  macro. The macro will define the necessary structs and register the new time scale. Let's start with a simple example and assume that you want to define  EphemerisTime  as an alias for  TDB . You need to provide the name of the time scale and optionally a \"parent\" time scale to which it is linked. @timescale EphemerisTime TDB At this point, you can already use the new time scale to create epochs. julia> EphemerisTime\nEphemerisTime\n\njulia> typeof(EphemerisTime)\nEphemerisTimeScale\n\njulia> et = EphemerisTimeEpoch(2000, 1, 1)\n2000-01-01T00:00:00.000 EphemerisTime Conversion to other  Epoch  types will not yet work for the newly created time because you need to provide the necessary methods for  getoffset . If you are unsure which methods are needed, you can try to transform the epoch and the resulting error message will provide a hint. julia> TDBEpoch(et)\nERROR: No conversion 'EphemerisTime->TDB' available. If one of these is a custom time scale,\nyou may need to define `AstroTime.Epochs.getoffset(::EphemerisTimeScale, ::BarycentricDynamicalTime, second, fraction, args...)`. To enable transformations between  EphemerisTime  and  TDB  in both directions you need to define the following methods. Since  EphemerisTime  and  TDB  are identical, the offset between them is zero. AstroTime.Epochs.getoffset(::EphemerisTimeType, ::CoordinatedUniversalTime, second, fraction) = 0.0\nAstroTime.Epochs.getoffset(::CoordinatedUniversalTime, ::EphemerisTimeType, second, fraction) = 0.0 You can now use  EphemerisTimeEpoch  like any other epoch type, e.g. julia> ep = TDBEpoch(2000, 1, 1)\n2000-01-01T00:00:00.000 TDB\n\njulia> EphemerisTimeEpoch(ep)\n2000-01-01T00:00:00.000 EphemerisTime For a more complex example, let's reimplement the Geocentric Coordinate Time (TCG) scale. It is a linear transformation from Terrestrial Time (TT), i.e. the transformation is dependent on the point in time in the current time scale (the  second  and  fraction  arguments to  getoffset ). @timescale CustomTCG TT\n\n# The reference point\nconst JD77_SEC = -7.25803167816e8\n# The linear rate of change\nconst LG_RATE = 6.969290134e-10\n\nfunction getoffset(::CustomTCGScale, ::TerrestrialTime, second, fraction)\n    # `second` is the number of full seconds since 2000-01-01\n    # `fraction` is the fraction of the current second\n    dt = second - JD77_SEC + fraction\n    return -LG_RATE * dt\nend\n\nfunction getoffset(::TerrestrialTime, ::CustomTCGScale, second, fraction)\n    # The inverse rate for the backwards transformation\n    rate = LG_RATE / (1.0 - LG_RATE)\n    dt = second - JD77_SEC + fraction\n    return rate * dt\nend\n Let's assume that you want to define a time scale that determines the  Spacecraft Event Time  which takes the one-way light time into account. You could use the following definitions adding the  distance  parameter which is the distance of the spacecraft from Earth. const speed_of_light = 299792458.0 # m/s\n\n@timescale SCET TAI\n\nfunction AstroTime.Epochs.getoffset(::SCETScale, ::InternationalAtomicTime,\n                                    second, fraction, distance)\n    return distance / speed_of_light\nend\nfunction AstroTime.Epochs.getoffset(::InternationalAtomicTime, ::SCETScale,\n                                    second, fraction, distance)\n    return -distance / speed_of_light\nend If you want to convert another epoch to  SCET , you now need to pass this additional parameter. For example, for a spacecraft that is one astronomical unit away from Earth: julia> astronomical_unit = 149597870700.0 # m\n149597870700.0\n\njulia> ep = TAIEpoch(2000, 1, 1)\n2000-01-01T00:00:00.000 TAI\n\njulia> SCETEpoch(ep, astronomical_unit)\n1999-12-31T23:51:40.995 SCET Note At this time, custom epochs with additional parameters cannot be parsed from strings. You can also introduce time scales that are disjoint from AstroTime.jl's default graph of time scales by defining a time scale without a parent. julia> @timescale Disjoint\n\njulia> typeof(Disjoint)\nDisjointScale By defining additional time scales connected to this scale and the appropriate  getoffset  methods, you can create your own graph of time scales that is completely independent of the defaults provided by the library. 1 Transformations to and from UT1 depend on the measured quantity ΔUT1 which is published in  IERS  tables on a weekly basis. AstroTime.jl can automatically fetch these tables by running  AstroTime.update() . If you work with  UT1 , you need to run this function periodically."},{"id":781,"pagetitle":"Home","title":"EarthOrientation.jl","ref":"/EarthOrientation/stable/#EarthOrientation.jl","content":" EarthOrientation.jl Calculate Earth orientation parameters from IERS tables in Julia."},{"id":782,"pagetitle":"Home","title":"Installation","ref":"/EarthOrientation/stable/#Installation","content":" Installation The package can be installed through Julia's package manager: Pkg.add(\"EarthOrientation\")"},{"id":783,"pagetitle":"Home","title":"Quickstart","ref":"/EarthOrientation/stable/#Quickstart","content":" Quickstart Fetch the latest [IERS][iers-link] tables: using EarthOrientation\nEarthOrientation.update() Get the current Earth orientation parameters, e.g. for polar motion: xp, yp = polarmotion(now()) # arcseconds Or the current difference between UT1 and UTC and the associated prediction error: ΔUT1 = getΔUT1(now()) # seconds\nΔUT1_err = getΔUT1_err(now()) # seconds"},{"id":784,"pagetitle":"Home","title":"Available data","ref":"/EarthOrientation/stable/#Available-data","content":" Available data Polar motion: x-coordinate of Earth's north pole:  getxp y-coordinate of Earth's north pole:  getyp both:  polarmotion Earth rotation Difference between UT1 and UTC:  getΔUT1 Difference between UT1 and TAI:  getΔUT1_TAI Excess length of day:  getlod Precession and nutation based on the 1980 IAU conventions Correction to the nutation of the ecliptic:  getdψ Correction to the obliquity of the ecliptic:  getdϵ both:  precession_nutation80 Precession and nutation based on the 2000 IAU conventions Correction to the celestial pole's x-coordinate:  getdx Correction to the celestial pole's y-coordinate:  getdy both:  precession_nutation00 There is an associated function that returns the prediction error for each data type, e.g.  getxp_err ."},{"id":785,"pagetitle":"Home","title":"Manual Data Management","ref":"/EarthOrientation/stable/#Manual-Data-Management","content":" Manual Data Management By default the files downloaded by  EarthOrientation.update()  will be used. It is also possible to pass different  finals.all  and  finals2000A.all  files in CSV format. using EarthOrientation\n\npush!(EOP_DATA, \"finals.csv\", \"finals2000A.csv\")"},{"id":788,"pagetitle":"API","title":"API","ref":"/EarthOrientation/stable/api/#API","content":" API"},{"id":789,"pagetitle":"API","title":"EarthOrientation.EOParams","ref":"/EarthOrientation/stable/api/#EarthOrientation.EOParams-Tuple{String,String}","content":" EarthOrientation.EOParams  —  Method EOParams(iau1980file::String, iau2000file::String) Parse IERS data files into a  EOParams  object.  iau1980file  and  iau2000file  are the paths to a 'finals.all' and a 'finals2000A.all' CSV file, respectively. source"},{"id":790,"pagetitle":"API","title":"EarthOrientation.getdx","ref":"/EarthOrientation/stable/api/#EarthOrientation.getdx-Tuple{Any,Any}","content":" EarthOrientation.getdx  —  Method getdx(date; outside_range=:warn) Get the celestial pole x-coordinate correction for a certain  date  in milliarcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":791,"pagetitle":"API","title":"EarthOrientation.getdx_err","ref":"/EarthOrientation/stable/api/#EarthOrientation.getdx_err-Tuple{Any,Any}","content":" EarthOrientation.getdx_err  —  Method getdx_err(date; outside_range=:warn) Get the error in celestial pole x-coordinate correction for a certain  date  in milliarcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":792,"pagetitle":"API","title":"EarthOrientation.getdy","ref":"/EarthOrientation/stable/api/#EarthOrientation.getdy-Tuple{Any,Any}","content":" EarthOrientation.getdy  —  Method getdy(date; outside_range=:warn) Get the celestial pole y-coordinate correction for a certain  date  in milliarcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":793,"pagetitle":"API","title":"EarthOrientation.getdy_err","ref":"/EarthOrientation/stable/api/#EarthOrientation.getdy_err-Tuple{Any,Any}","content":" EarthOrientation.getdy_err  —  Method getdy_err(date; outside_range=:warn) Get the error in celestial pole y-coordinate correction for a certain  date  in milliarcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":794,"pagetitle":"API","title":"EarthOrientation.getdψ","ref":"/EarthOrientation/stable/api/#EarthOrientation.getdψ-Tuple{Any,Any}","content":" EarthOrientation.getdψ  —  Method getdψ(date; outside_range=:warn) Get the ecliptic nutation correction for a certain  date  in milliarcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":795,"pagetitle":"API","title":"EarthOrientation.getdψ_err","ref":"/EarthOrientation/stable/api/#EarthOrientation.getdψ_err-Tuple{Any,Any}","content":" EarthOrientation.getdψ_err  —  Method getdψ_err(date; outside_range=:warn) Get the error in the ecliptic nutation correction for a certain  date  in milliarcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":796,"pagetitle":"API","title":"EarthOrientation.getdϵ","ref":"/EarthOrientation/stable/api/#EarthOrientation.getdϵ-Tuple{Any,Any}","content":" EarthOrientation.getdϵ  —  Method getdϵ(date; outside_range=:warn) Get the ecliptic obliquity correction for a certain  date  in milliarcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":797,"pagetitle":"API","title":"EarthOrientation.getdϵ_err","ref":"/EarthOrientation/stable/api/#EarthOrientation.getdϵ_err-Tuple{Any,Any}","content":" EarthOrientation.getdϵ_err  —  Method getdϵ_err(date; outside_range=:warn) Get the error in the ecliptic obliquity correction for a certain  date  in milliarcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":798,"pagetitle":"API","title":"EarthOrientation.getlod","ref":"/EarthOrientation/stable/api/#EarthOrientation.getlod-Tuple{Any,Any}","content":" EarthOrientation.getlod  —  Method getlod(date; outside_range=:warn) Get the excess length of day for a certain  date  in milliseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":799,"pagetitle":"API","title":"EarthOrientation.getlod_err","ref":"/EarthOrientation/stable/api/#EarthOrientation.getlod_err-Tuple{Any,Any}","content":" EarthOrientation.getlod_err  —  Method getlod_err(date; outside_range=:warn) Get the error in the excess length of day for a certain  date  in milliseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":800,"pagetitle":"API","title":"EarthOrientation.getxp","ref":"/EarthOrientation/stable/api/#EarthOrientation.getxp-Tuple{Any,Any}","content":" EarthOrientation.getxp  —  Method getxp(date; outside_range=:warn) Get the x-coordinate of Earth's north pole w.r.t. the CIO for a certain  date  in arcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":801,"pagetitle":"API","title":"EarthOrientation.getxp_err","ref":"/EarthOrientation/stable/api/#EarthOrientation.getxp_err-Tuple{Any,Any}","content":" EarthOrientation.getxp_err  —  Method getxp_err(date; outside_range=:warn) Get the error for the x-coordinate of Earth's north pole w.r.t. the CIO for a certain  date  in arcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":802,"pagetitle":"API","title":"EarthOrientation.getyp","ref":"/EarthOrientation/stable/api/#EarthOrientation.getyp-Tuple{Any,Any}","content":" EarthOrientation.getyp  —  Method getyp(date; outside_range=:warn) Get the y-coordinate of Earth's north pole w.r.t. the CIO for a certain  date  in arcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":803,"pagetitle":"API","title":"EarthOrientation.getyp_err","ref":"/EarthOrientation/stable/api/#EarthOrientation.getyp_err-Tuple{Any,Any}","content":" EarthOrientation.getyp_err  —  Method getyp_err(date; outside_range=:warn) Get the error for the y-coordinate of Earth's north pole w.r.t. the CIO for a certain  date  in arcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":804,"pagetitle":"API","title":"EarthOrientation.getΔUT1","ref":"/EarthOrientation/stable/api/#EarthOrientation.getΔUT1-Tuple{Any,Any}","content":" EarthOrientation.getΔUT1  —  Method getΔUT1(date; outside_range=:warn) Get the difference between UTC and UT1 for a certain  date  in seconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":805,"pagetitle":"API","title":"EarthOrientation.getΔUT1_TAI","ref":"/EarthOrientation/stable/api/#EarthOrientation.getΔUT1_TAI-Tuple{Any,Any}","content":" EarthOrientation.getΔUT1_TAI  —  Method getΔUT1_TAI(date; outside_range=:warn) Get the difference between TAI and UT1 for a certain  date  in seconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":806,"pagetitle":"API","title":"EarthOrientation.getΔUT1_err","ref":"/EarthOrientation/stable/api/#EarthOrientation.getΔUT1_err-Tuple{Any,Any}","content":" EarthOrientation.getΔUT1_err  —  Method getΔUT1_err(date; outside_range=:warn) Get the error in the difference between UTC and UT1 for a certain  date  in seconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":807,"pagetitle":"API","title":"EarthOrientation.polarmotion","ref":"/EarthOrientation/stable/api/#EarthOrientation.polarmotion-Tuple{Any,Any}","content":" EarthOrientation.polarmotion  —  Method polarmotion(date; outside_range=:warn) Get the coordinates of Earth's north pole w.r.t. the CIO for a certain  date  in arcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":808,"pagetitle":"API","title":"EarthOrientation.precession_nutation00","ref":"/EarthOrientation/stable/api/#EarthOrientation.precession_nutation00-Tuple{Any,Any}","content":" EarthOrientation.precession_nutation00  —  Method precession_nutation00(date; outside_range=:warn) Get the celestial pole coordinate corrections for a certain  date  in milliarcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":809,"pagetitle":"API","title":"EarthOrientation.precession_nutation80","ref":"/EarthOrientation/stable/api/#EarthOrientation.precession_nutation80-Tuple{Any,Any}","content":" EarthOrientation.precession_nutation80  —  Method precession_nutation80(date; outside_range=:warn) Get the ecliptic corrections for a certain  date  in milliarcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":812,"pagetitle":"Internals","title":"Internals","ref":"/EarthOrientation/stable/internals/#Internals","content":" Internals"},{"id":813,"pagetitle":"Internals","title":"EarthOrientation.getdate","ref":"/EarthOrientation/stable/internals/#EarthOrientation.getdate-Tuple{Any}","content":" EarthOrientation.getdate  —  Method getdate(data) Determine the creation date of an IERS table by finding the last entry which is marked as \"final\". source"},{"id":814,"pagetitle":"Internals","title":"EarthOrientation.update","ref":"/EarthOrientation/stable/internals/#EarthOrientation.update-Tuple{}","content":" EarthOrientation.update  —  Method update(; force=false) Download weekly EOP data from the IERS servers if newer files are available or no data has been downloaded previously. If the keyword  force  is  true , then all the files will be downloaded again. source"},{"id":819,"pagetitle":"Tutorial","title":"Tutorial","ref":"/EarthOrientation/stable/tutorial/#Tutorial","content":" Tutorial EarthOrientation.jl  downloads, parses, and interpolates weekly-updated tables from the  IERS  that contain the following Earth Orientation Parameters (EOP): Polar motion: x-coordinate of Earth's north pole:  $x_p$ y-coordinate of Earth's north pole:  $y_p$ Earth rotation Difference between UT1 and UTC:  $\\Delta UT1$ Excess length of day:  $LOD$ Precession and nutation based on the 1980 IAU conventions Correction to the nutation of the ecliptic:  $d\\psi$ Correction to the obliquity of the ecliptic:  $d\\epsilon$ Precession and nutation based on the 2000 IAU conventions Correction to the celestial pole's x-coordinate:  $dx$ Correction to the celestial pole's y-coordinate:  $dy$ These parameters are required for precise transformations between quasi-inertial and rotating terrestrial reference frames."},{"id":820,"pagetitle":"Tutorial","title":"Getting Earth Orientation Data","ref":"/EarthOrientation/stable/tutorial/#Getting-Earth-Orientation-Data","content":" Getting Earth Orientation Data When the package is imported for the first time the required data will be automatically downloaded from the IERS servers. After that the data needs to be updated manually like shown below. using EarthOrientation\nEarthOrientation.update()"},{"id":821,"pagetitle":"Tutorial","title":"Loading Earth Orientation Data","ref":"/EarthOrientation/stable/tutorial/#Loading-Earth-Orientation-Data","content":" Loading Earth Orientation Data The downloaded data is parsed into an  EOParams  object: eop = EOParams() By default the files downloaded by  EarthOrientation.update()  will be used. It is also possible to manually pass the required  finals.all  and  finals2000A.all  files in CSV format. eop = EOParams(\"finals.csv\", \"finals2000A.csv\") This is useful if the data should not be managed by  EarthOrientation.jl  but by a different system instead."},{"id":822,"pagetitle":"Tutorial","title":"Interpolating Earth Orientation Data","ref":"/EarthOrientation/stable/tutorial/#Interpolating-Earth-Orientation-Data","content":" Interpolating Earth Orientation Data Get the current Earth orientation parameters, e.g. for polar motion: xp, yp = polarmotion(eop, now()) # arcseconds Or the current difference between UT1 and UTC and the associated prediction error: ΔUT1 = getΔUT1(eop, now()) # seconds\nΔUT1_err = getΔUT1_err(eop, now()) # milliseconds"},{"id":825,"pagetitle":"Home","title":"ERFA.jl","ref":"/ERFA/stable/#ERFA.jl","content":" ERFA.jl Julia wrapper for  liberfa ."},{"id":826,"pagetitle":"Home","title":"Installation","ref":"/ERFA/stable/#Installation","content":" Installation julia> import Pkg; Pkg.add(\"ERFA\")"},{"id":827,"pagetitle":"Home","title":"Example","ref":"/ERFA/stable/#Example","content":" Example julia> using ERFA\n\njulia> u1, u2 = dtf2d(\"UTC\", 2010, 7, 24, 11, 18, 7.318)\n(2.4554015e6, 0.47091803240740737)\n\njulia> a1, a2 = utctai(u1, u2)\n(2.4554015e6, 0.4713115509259259)\n\njulia> t1, t2 = taitt(a1, a2)\n(2.4554015e6, 0.4716840509259259)\n\njulia> d2dtf(\"TT\", 3, t1, t2)\n(2010, 7, 24, 11, 19, 13, 502)"},{"id":830,"pagetitle":"Functions","title":"Functions","ref":"/ERFA/stable/api/functions/#Functions","content":" Functions"},{"id":831,"pagetitle":"Functions","title":"ERFA.a2af","ref":"/ERFA/stable/api/functions/#ERFA.a2af","content":" ERFA.a2af  —  Function a2af(ndp, a) Decompose radians into degrees, arcminutes, arcseconds, fraction. Given ndp : Resolution (Note 1) angle : Angle in radians Returned sign : '+' or '-' idmsf : Degrees, arcminutes, arcseconds, fraction Called d2tf : decompose days to hms Notes The argument ndp is interpreted as follows: ndp resolution : ...0000 00 00 -7 1000 00 00 -6 100 00 00 -5 10 00 00 -4 1 00 00 -3 0 10 00 -2 0 01 00 -1 0 00 10 0 0 00 01 1 0 00 00.1 2 0 00 00.01 3 0 00 00.001 : 0 00 00.000... The largest positive useful value for ndp is determined by the size of angle, the format of doubles on the target platform, and the risk of overflowing idmsf[3].  On a typical platform, for angle up to 2pi, the available floating-point precision might correspond to ndp=12.  However, the practical limit is typically ndp=9, set by the capacity of a 32-bit int, or ndp=4 if int is only 16 bits. The absolute value of angle may exceed 2pi.  In cases where it does not, it is up to the caller to test for and handle the case where angle is very nearly 2pi and rounds up to 360 degrees, by testing for idmsf[0]=360 and setting idmsf[0-3] to zero. source"},{"id":832,"pagetitle":"Functions","title":"ERFA.a2tf","ref":"/ERFA/stable/api/functions/#ERFA.a2tf","content":" ERFA.a2tf  —  Function a2tf(ndp, a) Decompose radians into hours, minutes, seconds, fraction. Given ndp : Resolution (Note 1) angle : Angle in radians Returned sign : '+' or '-' ihmsf : Hours, minutes, seconds, fraction Called d2tf : decompose days to hms Notes The argument ndp is interpreted as follows: ndp resolution : ...0000 00 00 -7 1000 00 00 -6 100 00 00 -5 10 00 00 -4 1 00 00 -3 0 10 00 -2 0 01 00 -1 0 00 10 0 0 00 01 1 0 00 00.1 2 0 00 00.01 3 0 00 00.001 : 0 00 00.000... The largest positive useful value for ndp is determined by the size of angle, the format of doubles on the target platform, and the risk of overflowing ihmsf[3].  On a typical platform, for angle up to 2pi, the available floating-point precision might correspond to ndp=12.  However, the practical limit is typically ndp=9, set by the capacity of a 32-bit int, or ndp=4 if int is only 16 bits. The absolute value of angle may exceed 2pi.  In cases where it does not, it is up to the caller to test for and handle the case where angle is very nearly 2pi and rounds up to 24 hours, by testing for ihmsf[0]=24 and setting ihmsf[0-3] to zero. source"},{"id":833,"pagetitle":"Functions","title":"ERFA.ab","ref":"/ERFA/stable/api/functions/#ERFA.ab-NTuple{4, Any}","content":" ERFA.ab  —  Method ab(pnat, v, s, bm1) Apply aberration to transform natural direction into proper direction. Given pnat : Natural direction to the source (unit vector) v : Observer barycentric velocity in units of c s : Distance between the Sun and the observer (au) bm1 :  $\\sqrt{1-|v|^2}$  reciprocal of Lorenz factor Returned ppr : Proper direction to source (unit vector) Notes The algorithm is based on Expr. (7.40) in the Explanatory Supplement (Urban & Seidelmann 2013), but with the following changes: Rigorous rather than approximate normalization is applied. The gravitational potential term from Expr. (7) in  Klioner (2003) is added, taking into account only the Sun's  contribution.  This has a maximum effect of about  0.4 microarcsecond. In almost all cases, the maximum accuracy will be limited by the supplied velocity.  For example, if the ERFA  epv00  function is used, errors of up to 5 microarcseconds could occur. References Urban, S. & Seidelmann, P. K. (eds), Explanatory Supplement to   the Astronomical Almanac, 3rd ed., University Science Books   (2013). Klioner, Sergei A., \"A practical relativistic model for micro-   arcsecond astrometry in space\", Astr. J. 125, 1580-1597 (2003). Called pdp : scalar product of two p-vectors source"},{"id":834,"pagetitle":"Functions","title":"ERFA.ae2hd","ref":"/ERFA/stable/api/functions/#ERFA.ae2hd-Tuple{Any, Any, Any}","content":" ERFA.ae2hd  —  Method ae2hd(az, el, phi) Horizon to equatorial coordinates:  transform azimuth and altitude to hour angle and declination. Given az : Azimuth el : Altitude (informally, elevation) phi : Site latitude Returned ha : Hour angle (local) dec : Declination Notes All the arguments are angles in radians. The sign convention for azimuth is north zero, east +pi/2. HA is returned in the range +/-pi.  Declination is returned in the range +/-pi/2. The latitude phi is pi/2 minus the angle between the Earth's rotation axis and the adopted zenith.  In many applications it will be sufficient to use the published geodetic latitude of the site.  In very precise (sub-arcsecond. applications, phi can be corrected for polar motion. The azimuth az must be with respect to the rotational north pole, as opposed to the ITRS pole, and an azimuth with respect to north on a map of the Earth's surface will need to be adjusted for polar motion if sub-arcsecond accuracy is required. Should the user wish to work with respect to the astronomical zenith rather than the geodetic zenith, phi will need to be adjusted for deflection of the vertical (often tens of arcseconds), and the zero point of ha will also be affected. The transformation is the same as  Ve = Ry(phi-pi/2)*Rz(pi)*Vh , where Ve and Vh are lefthanded unit vectors in the (ha,dec. and (az,el. systems respectively and Rz and Ry are rotations about first the z-axis and then the y-axis.  (n.b. Rz(pi. simply reverses the signs of the x and y components.. For efficiency, the algorithm is written out rather than calling other utility functions.  For applications that require even greater efficiency, additional savings are possible if constant terms such as functions of latitude are computed once and for all. Again for efficiency, no range checking of arguments is carried out. source"},{"id":835,"pagetitle":"Functions","title":"ERFA.af2a","ref":"/ERFA/stable/api/functions/#ERFA.af2a-NTuple{4, Any}","content":" ERFA.af2a  —  Method af2a(s, ideg, iamin, asec) Convert degrees, arcminutes, arcseconds to radians. Given s : Sign:  '-' = negative, otherwise positive ideg : Degrees iamin : Arcminutes asec : Arcseconds Returned rad : Angle in radians Notes The result is computed even if any of the range checks fail. Negative ideg, iamin and/or asec produce a warning status, but  the absolute value is used in the conversion. If there are multiple errors, the status value reflects only the  first, the smallest taking precedence. source"},{"id":836,"pagetitle":"Functions","title":"ERFA.anp","ref":"/ERFA/stable/api/functions/#ERFA.anp","content":" ERFA.anp  —  Function anp(a) Normalize angle into the range 0 <= a < 2pi. Deprecated Use  Base.mod2pi  instead. Given a : Angle (radians) Returned Angle in range 0-2pi source"},{"id":837,"pagetitle":"Functions","title":"ERFA.anpm","ref":"/ERFA/stable/api/functions/#ERFA.anpm-Tuple{Any}","content":" ERFA.anpm  —  Method anpm(a) Normalize angle into the range -pi <= a < +pi. Given a : Angle (radians) Returned Angle in range +/-pi source"},{"id":838,"pagetitle":"Functions","title":"ERFA.apcg","ref":"/ERFA/stable/api/functions/#ERFA.apcg-NTuple{4, Any}","content":" ERFA.apcg  —  Method apcg(date1, date2, ebpv, ehp) For a geocentric observer, prepare star-independent astrometry parameters for transformations between ICRS and GCRS coordinates. The Earth ephemeris is supplied by the caller. The parameters produced by this function are required in the parallax, light deflection and aberration parts of the astrometric transformation chain. Given date1 : TDB as a 2-part... date2 : ...Julian Date (Note 1) ebpv : Earth barycentric pos/vel (au, au/day) ehp : Earth heliocentric position (au) Returned astrom : Star-independent astrometry parameters: pmt : PM time interval (SSB, Julian years) eb : SSB to observer (vector, au) eh : Sun to observer (unit vector) em : Distance from Sun to observer (au) v : Barycentric observer velocity (vector, c) bm1 :  $\\sqrt{1-|v|^2}$  Reciprocal of Lorenz factor bpn : Bias-precession-nutation matrix along : unchanged xpl : unchanged ypl : unchanged sphi : unchanged cphi : unchanged diurab : unchanged l : unchanged refa : unchanged refb : unchanged Notes The TDB date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TDB)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience.  For most applications of this function the choice will not be at all critical. TT can be used instead of TDB without any significant impact on accuracy. All the vectors are with respect to BCRS axes. This is one of several functions that inserts into the astrom structure star-independent parameters needed for the chain of astrometric transformations ICRS <-> GCRS <-> CIRS <-> observed. The various functions support different classes of observer and portions of the transformation chain: Functions Observer Transformation apcg apcg13 geocentric ICRS <-> GCRS apci apci13 terrestrial ICRS <-> CIRS apco apco13 terrestrial ICRS <-> observed apcs apcs13 space ICRS <-> GCRS aper aper13 terrestrial update Earth rotation apio apio13 terrestrial CIRS <-> observed Those with names ending in \"13\" use contemporary ERFA models to compute the various ephemerides.  The others accept ephemerides supplied by the caller. The transformation from ICRS to GCRS covers space motion, parallax, light deflection, and aberration.  From GCRS to CIRS comprises frame bias and precession-nutation.  From CIRS to observed takes account of Earth rotation, polar motion, diurnal aberration and parallax (unless subsumed into the ICRS <-> GCRS transformation), and atmospheric refraction. The context structure astrom produced by this function is used by  atciq*  and  aticq* . Called apcs : astrometry parameters, ICRS-GCRS, space observer source"},{"id":839,"pagetitle":"Functions","title":"ERFA.apcg13","ref":"/ERFA/stable/api/functions/#ERFA.apcg13-Tuple{Any, Any}","content":" ERFA.apcg13  —  Method apcg13(date1, date2) For a geocentric observer, prepare star-independent astrometry parameters for transformations between ICRS and GCRS coordinates. The caller supplies the date, and ERFA models are used to predict the Earth ephemeris. The parameters produced by this function are required in the parallax, light deflection and aberration parts of the astrometric transformation chain. Given date1 : TDB as a 2-part... date2 : ...Julian Date (Note 1) Returned astrom : Star-independent astrometry parameters: pmt : PM time interval (SSB, Julian years) eb : SSB to observer (vector, au) eh : Sun to observer (unit vector) em : Distance from Sun to observer (au) v : Barycentric observer velocity (vector, c) bm1 :  $\\sqrt{1-|v|^2}$  Reciprocal of Lorenz factor bpn : Bias-precession-nutation matrix along : unchanged xpl : unchanged ypl : unchanged sphi : unchanged cphi : unchanged diurab : unchanged l : unchanged refa : unchanged refb : unchanged Notes The TDB date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TDB)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience.  For most applications of this function the choice will not be at all critical. TT can be used instead of TDB without any significant impact on accuracy. All the vectors are with respect to BCRS axes. In cases where the caller wishes to supply his own Earth ephemeris, the function  apcg  can be used instead of the present function. This is one of several functions that inserts into the astrom structure star-independent parameters needed for the chain of astrometric transformations ICRS <-> GCRS <-> CIRS <-> observed. The various functions support different classes of observer and portions of the transformation chain: Functions Observer Transformation apcg apcg13 geocentric ICRS <-> GCRS apci apci13 terrestrial ICRS <-> CIRS apco apco13 terrestrial ICRS <-> observed apcs apcs13 space ICRS <-> GCRS aper aper13 terrestrial update Earth rotation apio apio13 terrestrial CIRS <-> observed Those with names ending in \"13\" use contemporary ERFA models to compute the various ephemerides.  The others accept ephemerides supplied by the caller. The transformation from ICRS to GCRS covers space motion, parallax, light deflection, and aberration.  From GCRS to CIRS comprises frame bias and precession-nutation.  From CIRS to observed takes account of Earth rotation, polar motion, diurnal aberration and parallax (unless subsumed into the ICRS <-> GCRS transformation), and atmospheric refraction. The context structure astrom produced by this function is used by  atciq*  and  aticq* . Called epv00 : Earth position and velocity apcg : astrometry parameters, ICRS-GCRS, geocenter source"},{"id":840,"pagetitle":"Functions","title":"ERFA.apci","ref":"/ERFA/stable/api/functions/#ERFA.apci-NTuple{7, Any}","content":" ERFA.apci  —  Method apci(date1, date2, ebpv, ehp, x, y, s) For a terrestrial observer, prepare star-independent astrometry parameters for transformations between ICRS and geocentric CIRS coordinates.  The Earth ephemeris and CIP/CIO are supplied by the caller. The parameters produced by this function are required in the parallax, light deflection, aberration, and bias-precession-nutation parts of the astrometric transformation chain. Given date1 : TDB as a 2-part... date2 : ...Julian Date (Note 1) ebpv : Earth barycentric position/velocity (au, au/day) ehp : Earth heliocentric position (au) x ,  y : CIP X,Y (components of unit vector) s : The CIO locator s (radians) Returned astrom : Star-independent astrometry parameters: pmt : PM time interval (SSB, Julian years) eb : SSB to observer (vector, au) eh : Sun to observer (unit vector) em : Distance from Sun to observer (au) v : Barycentric observer velocity (vector, c) bm1 :  $\\sqrt{1-|v|^2}$  Reciprocal of Lorenz factor bpn : Bias-precession-nutation matrix along : unchanged xpl : unchanged ypl : unchanged sphi : unchanged cphi : unchanged diurab : unchanged l : unchanged refa : unchanged refb : unchanged Notes The TDB date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TDB)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience.  For most applications of this function the choice will not be at all critical. TT can be used instead of TDB without any significant impact on accuracy. All the vectors are with respect to BCRS axes. In cases where the caller does not wish to provide the Earth ephemeris and CIP/CIO, the function  apci13  can be used instead of the present function.  This computes the required quantities using other ERFA functions. This is one of several functions that inserts into the astrom structure star-independent parameters needed for the chain of astrometric transformations ICRS <-> GCRS <-> CIRS <-> observed. The various functions support different classes of observer and portions of the transformation chain: Functions Observer Transformation apcg apcg13 geocentric ICRS <-> GCRS apci apci13 terrestrial ICRS <-> CIRS apco apco13 terrestrial ICRS <-> observed apcs apcs13 space ICRS <-> GCRS aper aper13 terrestrial update Earth rotation apio apio13 terrestrial CIRS <-> observed Those with names ending in \"13\" use contemporary ERFA models to compute the various ephemerides.  The others accept ephemerides supplied by the caller. The transformation from ICRS to GCRS covers space motion, parallax, light deflection, and aberration.  From GCRS to CIRS comprises frame bias and precession-nutation.  From CIRS to observed takes account of Earth rotation, polar motion, diurnal aberration and parallax (unless subsumed into the ICRS <-> GCRS transformation), and atmospheric refraction. The context structure astrom produced by this function is used by  atciq*  and  aticq* . Called apcg : astrometry parameters, ICRS-GCRS, geocenter c2ixys : celestial-to-intermediate matrix, given X,Y and s source"},{"id":841,"pagetitle":"Functions","title":"ERFA.apci13","ref":"/ERFA/stable/api/functions/#ERFA.apci13-Tuple{Any, Any}","content":" ERFA.apci13  —  Method apci13(date1, date2) For a terrestrial observer, prepare star-independent astrometry parameters for transformations between ICRS and geocentric CIRS coordinates.  The caller supplies the date, and ERFA models are used to predict the Earth ephemeris and CIP/CIO. The parameters produced by this function are required in the parallax, light deflection, aberration, and bias-precession-nutation parts of the astrometric transformation chain. Given date1 : TDB as a 2-part... date2 : ...Julian Date (Note 1) Returned astrom : Star-independent astrometry parameters: pmt : PM time interval (SSB, Julian years) eb : SSB to observer (vector, au) eh : Sun to observer (unit vector) em : Distance from Sun to observer (au) v : Barycentric observer velocity (vector, c) bm1 :  $\\sqrt{1-|v|^2}$  Reciprocal of Lorenz factor bpn : Bias-precession-nutation matrix along : unchanged xpl : unchanged ypl : unchanged sphi : unchanged cphi : unchanged diurab : unchanged l : unchanged refa : unchanged refb : unchanged eo : Equation of the origins (ERA-GST) Notes The TDB date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TDB)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience.  For most applications of this function the choice will not be at all critical. TT can be used instead of TDB without any significant impact on accuracy. All the vectors are with respect to BCRS axes. In cases where the caller wishes to supply his own Earth ephemeris and CIP/CIO, the function  apci  can be used instead of the present function. This is one of several functions that inserts into the astrom structure star-independent parameters needed for the chain of astrometric transformations ICRS <-> GCRS <-> CIRS <-> observed. The various functions support different classes of observer and portions of the transformation chain: Functions Observer Transformation apcg apcg13 geocentric ICRS <-> GCRS apci apci13 terrestrial ICRS <-> CIRS apco apco13 terrestrial ICRS <-> observed apcs apcs13 space ICRS <-> GCRS aper aper13 terrestrial update Earth rotation apio apio13 terrestrial CIRS <-> observed Those with names ending in \"13\" use contemporary ERFA models to compute the various ephemerides.  The others accept ephemerides supplied by the caller. The transformation from ICRS to GCRS covers space motion, parallax, light deflection, and aberration.  From GCRS to CIRS comprises frame bias and precession-nutation.  From CIRS to observed takes account of Earth rotation, polar motion, diurnal aberration and parallax (unless subsumed into the ICRS <-> GCRS transformation), and atmospheric refraction. The context structure astrom produced by this function is used by  atciq*  and  aticq* . Called epv00 : Earth position and velocity pnm06a : classical NPB matrix, IAU 2006/2000A bpn2xy : extract CIP X,Y coordinates from NPB matrix s06 : the CIO locator s, given X,Y, IAU 2006 apci : astrometry parameters, ICRS-CIRS eors : equation of the origins, given NPB matrix and s source"},{"id":842,"pagetitle":"Functions","title":"ERFA.apco","ref":"/ERFA/stable/api/functions/#ERFA.apco-NTuple{16, Any}","content":" ERFA.apco  —  Method apco(date1, date2, ebpv, ehp, x, y, s, theta, elong, phi, hm, xp, yp, sp, refa, refb) For a terrestrial observer, prepare star-independent astrometry parameters for transformations between ICRS and observed coordinates.  The caller supplies the Earth ephemeris, the Earth rotation information and the refraction constants as well as the site coordinates. Given date1 : TDB as a 2-part... date2 : ...Julian Date (Note 1) ebpv : Earth barycentric PV (au, au/day, Note 2) ehp : Earth heliocentric P (au, Note 2) x ,  y : CIP X,Y (components of unit vector) s : The CIO locator s (radians) theta : Earth rotation angle (radians) elong : Longitude (radians, east +ve, Note 3) phi : Latitude (geodetic, radians, Note 3) hm : Height above ellipsoid (m, geodetic, Note 3) xp ,  yp : Polar motion coordinates (radians, Note 4) sp : The TIO locator s' (radians, Note 4) refa : Refraction constant A (radians, Note 5) refb : Refraction constant B (radians, Note 5) Returned astrom : Star-independent astrometry parameters: pmt : PM time interval (SSB, Julian years) eb : SSB to observer (vector, au) eh : Sun to observer (unit vector) em : Distance from Sun to observer (au) v : Barycentric observer velocity (vector, c) bm1 :  $\\sqrt{1-|v|^2}$  Reciprocal of Lorenz factor bpn : Bias-precession-nutation matrix along : Longitude + s' (radians) xp1 : Polar motion xp wrt local meridian (radians) yp1 : Polar motion yp wrt local meridian (radians) sphi : Sine of geodetic latitude cphi : Cosine of geodetic latitude diurab : Magnitude of diurnal aberration vector l : \"Local\" Earth rotation angle (radians) refa : Refraction constant A (radians) refb : Refraction constant B (radians) Notes The TDB date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TDB)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience.  For most applications of this function the choice will not be at all critical. TT can be used instead of TDB without any significant impact on accuracy. The vectors eb, eh, and all the astrom vectors, are with respect to BCRS axes. The geographical coordinates are with respect to the  WGS84  reference ellipsoid.  TAKE CARE WITH THE LONGITUDE SIGN CONVENTION:  the longitude required by the present function is right-handed, i.e. east-positive, in accordance with geographical convention. xp and yp are the coordinates (in radians) of the Celestial Intermediate Pole with respect to the International Terrestrial Reference System (see IERS Conventions), measured along the meridians 0 and 90 deg west respectively.  sp is the TIO locator s', in radians, which positions the Terrestrial Intermediate Origin on the equator.  For many applications, xp, yp and (especially) sp can be set to zero. Internally, the polar motion is stored in a form rotated onto the local meridian. The refraction constants refa and refb are for use in a  $dZ = A*\\tan(Z)+B*\\tan^3(Z)$  model, where Z is the observed (i.e. refracted) zenith distance and dZ is the amount of refraction. It is advisable to take great care with units, as even unlikely values of the input parameters are accepted and processed in accordance with the models used. In cases where the caller does not wish to provide the Earth Ephemeris, the Earth rotation information and refraction constants, the function  apco13  can be used instead of the present function.  This starts from UTC and weather readings etc. and computes suitable values using other ERFA functions. This is one of several functions that inserts into the astrom structure star-independent parameters needed for the chain of astrometric transformations ICRS <-> GCRS <-> CIRS <-> observed. The various functions support different classes of observer and portions of the transformation chain: Functions Observer Transformation apcg apcg13 geocentric ICRS <-> GCRS apci apci13 terrestrial ICRS <-> CIRS apco apco13 terrestrial ICRS <-> observed apcs apcs13 space ICRS <-> GCRS aper aper13 terrestrial update Earth rotation apio apio13 terrestrial CIRS <-> observed Those with names ending in \"13\" use contemporary ERFA models to compute the various ephemerides.  The others accept ephemerides supplied by the caller. The transformation from ICRS to GCRS covers space motion, parallax, light deflection, and aberration.  From GCRS to CIRS comprises frame bias and precession-nutation.  From CIRS to observed takes account of Earth rotation, polar motion, diurnal aberration and parallax (unless subsumed into the ICRS <-> GCRS transformation), and atmospheric refraction. The context structure astrom produced by this function is used by  atioq ,  atoiq ,  atciq  and  aticq . Called aper : astrometry parameters: update ERA c2ixys : celestial-to-intermediate matrix, given X,Y and s pvtob : position/velocity of terrestrial station trxpv : product of transpose of r-matrix and pv-vector apcs : astrometry parameters, ICRS-GCRS, space observer cr : copy r-matrix source"},{"id":843,"pagetitle":"Functions","title":"ERFA.apco13","ref":"/ERFA/stable/api/functions/#ERFA.apco13-NTuple{12, Any}","content":" ERFA.apco13  —  Method apco13(utc1, utc2, dut1, elong, phi, hm, xp, yp, phpa, tk, rh, wl) For a terrestrial observer, prepare star-independent astrometry parameters for transformations between ICRS and observed coordinates.  The caller supplies UTC, site coordinates, ambient air conditions and observing wavelength, and ERFA models are used to obtain the Earth ephemeris, CIP/CIO and refraction constants. The parameters produced by this function are required in the parallax, light deflection, aberration, and bias-precession-nutation parts of the ICRS/CIRS transformations. Given utc1 : UTC as a 2-part... utc2 : ...quasi Julian Date (Notes 1,2) dut1 : UT1-UTC (seconds, Note 3) elong : Longitude (radians, east +ve, Note 4) phi : Latitude (geodetic, radians, Note 4) hm : Height above ellipsoid (m, geodetic, Notes 4,6) xp ,  yp : Polar motion coordinates (radians, Note 5) phpa : Pressure at the observer (hPa = mB, Note 6) tc : Ambient temperature at the observer (deg C) rh : Relative humidity at the observer (range 0-1) wl : Wavelength (micrometers, Note 7) Returned astrom : Star-independent astrometry parameters: pmt : PM time interval (SSB, Julian years) eb : SSB to observer (vector, au) eh : Sun to observer (unit vector) em : Distance from Sun to observer (au) v : Barycentric observer velocity (vector, c) bm1 :  $\\sqrt{1-|v|^2}$  Reciprocal of Lorenz factor bpn : Bias-precession-nutation matrix along : Longitude + s' (radians) xp1 : Polar motion xp wrt local meridian (radians) yp1 : Polar motion yp wrt local meridian (radians) sphi : Sine of geodetic latitude cphi : Cosine of geodetic latitude diurab : Magnitude of diurnal aberration vector l : \"Local\" Earth rotation angle (radians) refa : Refraction constant A (radians) refb : Refraction constant B (radians) eo : Equation of the origins (ERA-GST) Notes utc1+utc2 is quasi Julian Date (see Note 2), apportioned in any  convenient way between the two arguments, for example where utc1  is the Julian Day Number and utc2 is the fraction of a day. However, JD cannot unambiguously represent UTC during a leap  second unless special measures are taken.  The convention in the  present function is that the JD day represents UTC days whether  the length is 86399, 86400 or 86401 SI seconds. Applications should use the function  dtf2d  to convert from  calendar date and time of day into 2-part quasi Julian Date, as  it implements the leap-second-ambiguity convention just  described. The warning status \"dubious year\" flags UTCs that predate the  introduction of the time scale or that are too far in the  future to be trusted.  See  dat  for further details. UT1-UTC is tabulated in IERS bulletins.  It increases by exactly  one second at the end of each positive UTC leap second,  introduced in order to keep UT1-UTC within +/- 0.9s.  n.b. This  practice is under review, and in the future UT1-UTC may grow  essentially without limit. The geographical coordinates are with respect to the  WGS84   reference ellipsoid.  TAKE CARE WITH THE LONGITUDE SIGN:  the  longitude required by the present function is east-positive  (i.e. right-handed), in accordance with geographical convention. The polar motion xp,yp can be obtained from IERS bulletins.  The  values are the coordinates (in radians) of the Celestial  Intermediate Pole with respect to the International Terrestrial  Reference System (see IERS Conventions 2003), measured along the  meridians 0 and 90 deg west respectively.  For many  applications, xp and yp can be set to zero. Internally, the polar motion is stored in a form rotated onto  the local meridian. If hm, the height above the ellipsoid of the observing station  in meters, is not known but phpa, the pressure in hPa (=mB), is  available, an adequate estimate of hm can be obtained from the  expression hm = -29.3 * tsl * log ( phpa / 1013.25 ); where tsl is the approximate sea-level air temperature in K  (See Astrophysical Quantities, C.W.Allen, 3rd edition, section  52).  Similarly, if the pressure phpa is not known, it can be  estimated from the height of the observing station, hm, as  follows: phpa = 1013.25 * exp ( -hm / ( 29.3 * tsl ) ); Note, however, that the refraction is nearly proportional to  the pressure and that an accurate phpa value is important for  precise work. The argument wl specifies the observing wavelength in  micrometers.  The transition from optical to radio is assumed to  occur at 100 micrometers (about 3000 GHz). It is advisable to take great care with units, as even unlikely  values of the input parameters are accepted and processed in  accordance with the models used. In cases where the caller wishes to supply his own Earth  ephemeris, Earth rotation information and refraction constants,  the function  apco  can be used instead of the present function. This is one of several functions that inserts into the astrom  structure star-independent parameters needed for the chain of  astrometric transformations ICRS <-> GCRS <-> CIRS <-> observed. The various functions support different classes of observer and  portions of the transformation chain: Functions Observer Transformation apcg apcg13 geocentric ICRS <-> GCRS apci apci13 terrestrial ICRS <-> CIRS apco apco13 terrestrial ICRS <-> observed apcs apcs13 space ICRS <-> GCRS aper aper13 terrestrial update Earth rotation apio apio13 terrestrial CIRS <-> observed Those with names ending in \"13\" use contemporary ERFA models to  compute the various ephemerides.  The others accept ephemerides  supplied by the caller. The transformation from ICRS to GCRS covers space motion,  parallax, light deflection, and aberration.  From GCRS to CIRS  comprises frame bias and precession-nutation.  From CIRS to  observed takes account of Earth rotation, polar motion, diurnal  aberration and parallax (unless subsumed into the ICRS <-> GCRS  transformation), and atmospheric refraction. The context structure astrom produced by this function is used  by  atioq ,  atoiq ,  atciq*  and  aticq* . Called utctai : UTC to TAI taitt : TAI to TT utcut1 : UTC to UT1 epv00 : Earth position and velocity pnm06a : classical NPB matrix, IAU 2006/2000A bpn2xy : extract CIP X,Y coordinates from NPB matrix s06 : the CIO locator s, given X,Y, IAU 2006 era00 : Earth rotation angle, IAU 2000 sp00 : the TIO locator s', IERS 2000 refco : refraction constants for given ambient conditions apco : astrometry parameters, ICRS-observed eors : equation of the origins, given NPB matrix and s source"},{"id":844,"pagetitle":"Functions","title":"ERFA.apcs","ref":"/ERFA/stable/api/functions/#ERFA.apcs-NTuple{5, Any}","content":" ERFA.apcs  —  Method apcs(date1, date2, pv, ebpv, ehp) For an observer whose geocentric position and velocity are known, prepare star-independent astrometry parameters for transformations between ICRS and GCRS.  The Earth ephemeris is supplied by the caller. The parameters produced by this function are required in the space motion, parallax, light deflection and aberration parts of the astrometric transformation chain. Given date1 : TDB as a 2-part... date2 : ...Julian Date (Note 1) pv : Observer's geocentric pos/vel (m, m/s) ebpv : Earth barycentric PV (au, au/day) ehp : Earth heliocentric P (au) Returned astrom : Star-independent astrometry parameters: pmt : PM time interval (SSB, Julian years) eb : SSB to observer (vector, au) eh : Sun to observer (unit vector) em : Distance from Sun to observer (au) v : Barycentric observer velocity (vector, c) bm1 :  $\\sqrt{1-|v|^2}$  Reciprocal of Lorenz factor bpn : Bias-precession-nutation matrix along : unchanged xpl : unchanged ypl : unchanged sphi : unchanged cphi : unchanged diurab : unchanged l : unchanged refa : unchanged refb : unchanged Notes The TDB date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TDB)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience.  For most applications of this function the choice will not be at all critical. TT can be used instead of TDB without any significant impact on accuracy. All the vectors are with respect to BCRS axes. Providing separate arguments for (i) the observer's geocentric position and velocity and (ii) the Earth ephemeris is done for convenience in the geocentric, terrestrial and Earth orbit cases. For deep space applications it maybe more convenient to specify zero geocentric position and velocity and to supply the observer's position and velocity information directly instead of with respect to the Earth.  However, note the different units: m and m/s for the geocentric vectors, au and au/day for the heliocentric and barycentric vectors. In cases where the caller does not wish to provide the Earth ephemeris, the function  apcs13  can be used instead of the present function.  This computes the Earth ephemeris using the ERFA function  epv00 . This is one of several functions that inserts into the astrom structure star-independent parameters needed for the chain of astrometric transformations ICRS <-> GCRS <-> CIRS <-> observed. The various functions support different classes of observer and portions of the transformation chain: Functions Observer Transformation apcg apcg13 geocentric ICRS <-> GCRS apci apci13 terrestrial ICRS <-> CIRS apco apco13 terrestrial ICRS <-> observed apcs apcs13 space ICRS <-> GCRS aper aper13 terrestrial update Earth rotation apio apio13 terrestrial CIRS <-> observed Those with names ending in \"13\" use contemporary ERFA models to compute the various ephemerides.  The others accept ephemerides supplied by the caller. The transformation from ICRS to GCRS covers space motion, parallax, light deflection, and aberration.  From GCRS to CIRS comprises frame bias and precession-nutation.  From CIRS to observed takes account of Earth rotation, polar motion, diurnal aberration and parallax (unless subsumed into the ICRS <-> GCRS transformation), and atmospheric refraction. The context structure astrom produced by this function is used by  atciq*  and  aticq* . Called erfa_cp : copy p-vector pm : modulus of p-vector pn : decompose p-vector into modulus and direction ir : initialize r-matrix to identity source"},{"id":845,"pagetitle":"Functions","title":"ERFA.apcs13","ref":"/ERFA/stable/api/functions/#ERFA.apcs13-Tuple{Any, Any, Any}","content":" ERFA.apcs13  —  Method apcs13(date1, date2, pv) For an observer whose geocentric position and velocity are known, prepare star-independent astrometry parameters for transformations between ICRS and GCRS.  The Earth ephemeris is from ERFA models. The parameters produced by this function are required in the space motion, parallax, light deflection and aberration parts of the astrometric transformation chain. Given date1 : TDB as a 2-part... date2 : ...Julian Date (Note 1) pv : Observer's geocentric pos/vel (Note 3) Returned EraASTROM*   star-independent astrometry parameters: pmt : PM time interval (SSB, Julian years) eb : SSB to observer (vector, au) eh : Sun to observer (unit vector) em : Distance from Sun to observer (au) v : Barycentric observer velocity (vector, c) bm1 :  $\\sqrt{1-|v|^2}$  Reciprocal of Lorenz factor bpn : Bias-precession-nutation matrix along : unchanged xpl : unchanged ypl : unchanged sphi : unchanged cphi : unchanged diurab : unchanged l : unchanged refa : unchanged refb : unchanged Notes The TDB date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TDB)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience.  For most applications of this function the choice will not be at all critical. TT can be used instead of TDB without any significant impact on accuracy. All the vectors are with respect to BCRS axes. The observer's position and velocity pv are geocentric but with respect to BCRS axes, and in units of m and m/s.  No assumptions are made about proximity to the Earth, and the function can be used for deep space applications as well as Earth orbit and terrestrial. In cases where the caller wishes to supply his own Earth ephemeris, the function  apcs  can be used instead of the present function. This is one of several functions that inserts into the astrom structure star-independent parameters needed for the chain of astrometric transformations ICRS <-> GCRS <-> CIRS <-> observed. The various functions support different classes of observer and portions of the transformation chain: Functions Observer Transformation apcg apcg13 geocentric ICRS <-> GCRS apci apci13 terrestrial ICRS <-> CIRS apco apco13 terrestrial ICRS <-> observed apcs apcs13 space ICRS <-> GCRS aper aper13 terrestrial update Earth rotation apio apio13 terrestrial CIRS <-> observed Those with names ending in \"13\" use contemporary ERFA models to compute the various ephemerides.  The others accept ephemerides supplied by the caller. The transformation from ICRS to GCRS covers space motion, parallax, light deflection, and aberration.  From GCRS to CIRS comprises frame bias and precession-nutation.  From CIRS to observed takes account of Earth rotation, polar motion, diurnal aberration and parallax (unless subsumed into the ICRS <-> GCRS transformation), and atmospheric refraction. The context structure astrom produced by this function is used by  atciq*  and  aticq* . Called epv00 : Earth position and velocity apcs : astrometry parameters, ICRS-GCRS, space observer source"},{"id":846,"pagetitle":"Functions","title":"ERFA.aper","ref":"/ERFA/stable/api/functions/#ERFA.aper-Tuple{Any, Any}","content":" ERFA.aper  —  Method aper(theta, astrom) In the star-independent astrometry parameters, update only the Earth rotation angle, supplied by the caller explicitly. Given theta : Earth rotation angle (radians, Note 2) astrom : Star-independent astrometry parameters: pmt : unchanged eb : unchanged eh : unchanged em : unchanged v : unchanged bm1 : unchanged bpn : unchanged along : Longitude + s' (radians) xpl : unchanged ypl : unchanged sphi : unchanged cphi : unchanged diurab : unchanged l : unchanged refa : unchanged refb : unchanged Returned astrom : Star-independent astrometry parameters: pmt : unchanged eb : unchanged eh : unchanged em : unchanged v : unchanged bm1 : unchanged bpn : unchanged along : unchanged xpl : unchanged ypl : unchanged sphi : unchanged cphi : unchanged diurab : unchanged l : \"Local\" Earth rotation angle (radians) refa : unchanged refb : unchanged Notes This function exists to enable sidereal-tracking applications to avoid wasteful recomputation of the bulk of the astrometry parameters:  only the Earth rotation is updated. For targets expressed as equinox based positions, such as classical geocentric apparent (RA,Dec), the supplied theta can be Greenwich apparent sidereal time rather than Earth rotation angle. The function  aper13  can be used instead of the present function, and starts from UT1 rather than ERA itself. This is one of several functions that inserts into the astrom structure star-independent parameters needed for the chain of astrometric transformations ICRS <-> GCRS <-> CIRS <-> observed. The various functions support different classes of observer and portions of the transformation chain: Functions Observer Transformation apcg apcg13 geocentric ICRS <-> GCRS apci apci13 terrestrial ICRS <-> CIRS apco apco13 terrestrial ICRS <-> observed apcs apcs13 space ICRS <-> GCRS aper aper13 terrestrial update Earth rotation apio apio13 terrestrial CIRS <-> observed Those with names ending in \"13\" use contemporary ERFA models to compute the various ephemerides.  The others accept ephemerides supplied by the caller. The transformation from ICRS to GCRS covers space motion, parallax, light deflection, and aberration.  From GCRS to CIRS comprises frame bias and precession-nutation.  From CIRS to observed takes account of Earth rotation, polar motion, diurnal aberration and parallax (unless subsumed into the ICRS <-> GCRS transformation), and atmospheric refraction. source"},{"id":847,"pagetitle":"Functions","title":"ERFA.aper13","ref":"/ERFA/stable/api/functions/#ERFA.aper13-Tuple{Any, Any, Any}","content":" ERFA.aper13  —  Method aper13(ut11, ut12, astrom) In the star-independent astrometry parameters, update only the Earth rotation angle.  The caller provides UT1, (n.b. not UTC). Given ut11 : UT1 as a 2-part... ut12 : ...Julian Date (Note 1) astrom : Star-independent astrometry parameters: pmt : unchanged eb : unchanged eh : unchanged em : unchanged v : unchanged bm1 : unchanged bpn : unchanged along : Longitude + s' (radians) xpl : unchanged ypl : unchanged sphi : unchanged cphi : unchanged diurab : unchanged l : unchanged refa : unchanged refb : unchanged Returned astrom : Star-independent astrometry parameters: pmt : unchanged eb : unchanged eh : unchanged em : unchanged v : unchanged bm1 : unchanged bpn : unchanged along : unchanged xpl : unchanged ypl : unchanged sphi : unchanged cphi : unchanged diurab : unchanged l : \"Local\" Earth rotation angle (radians) refa : unchanged refb : unchanged Notes The UT1 date (n.b. not UTC) ut11+ut12 is a Julian Date, apportioned in any convenient way between the arguments ut11 and ut12.  For example, JD(UT1)=2450123.7 could be expressed in any of these ways, among others: ut11 ut12 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 and MJD methods are good compromises between resolution and convenience.  The date & time method is best matched to the algorithm used:  maximum precision is delivered when the ut11 argument is for 0hrs UT1 on the day in question and the ut12 argument lies in the range 0 to 1, or vice versa. If the caller wishes to provide the Earth rotation angle itself, the function  aper  can be used instead.  One use of this technique is to substitute Greenwich apparent sidereal time and thereby to support equinox based transformations directly. This is one of several functions that inserts into the astrom structure star-independent parameters needed for the chain of astrometric transformations ICRS <-> GCRS <-> CIRS <-> observed. The various functions support different classes of observer and portions of the transformation chain: Functions Observer Transformation apcg apcg13 geocentric ICRS <-> GCRS apci apci13 terrestrial ICRS <-> CIRS apco apco13 terrestrial ICRS <-> observed apcs apcs13 space ICRS <-> GCRS aper aper13 terrestrial update Earth rotation apio apio13 terrestrial CIRS <-> observed Those with names ending in \"13\" use contemporary ERFA models to compute the various ephemerides.  The others accept ephemerides supplied by the caller. The transformation from ICRS to GCRS covers space motion, parallax, light deflection, and aberration.  From GCRS to CIRS comprises frame bias and precession-nutation.  From CIRS to observed takes account of Earth rotation, polar motion, diurnal aberration and parallax (unless subsumed into the ICRS <-> GCRS transformation), and atmospheric refraction. Called aper : astrometry parameters: update ERA era00 : Earth rotation angle, IAU 2000 source"},{"id":848,"pagetitle":"Functions","title":"ERFA.apio","ref":"/ERFA/stable/api/functions/#ERFA.apio-NTuple{9, Any}","content":" ERFA.apio  —  Method apio(sp, theta, elong, phi, hm, xp, yp, refa, refb) For a terrestrial observer, prepare star-independent astrometry parameters for transformations between CIRS and observed coordinates.  The caller supplies the Earth orientation information and the refraction constants as well as the site coordinates. Given sp : The TIO locator s' (radians, Note 1) theta : Earth rotation angle (radians) elong : Longitude (radians, east +ve, Note 2) phi : Geodetic latitude (radians, Note 2) hm : Height above ellipsoid (m, geodetic Note 2) xp ,  yp : Polar motion coordinates (radians, Note 3) refa : Refraction constant A (radians, Note 4) refb : Refraction constant B (radians, Note 4) Returned astrom : Star-independent astrometry parameters: pmt : unchanged eb : unchanged eh : unchanged em : unchanged v : unchanged bm1 : unchanged bpn : unchanged along : Longitude + s' (radians) xp1 : Polar motion xp wrt local meridian (radians) yp1 : Polar motion yp wrt local meridian (radians) sphi : Sine of geodetic latitude cphi : Cosine of geodetic latitude diurab : Magnitude of diurnal aberration vector l : \"Local\" Earth rotation angle (radians) refa : Refraction constant A (radians) refb : Refraction constant B (radians) Notes sp, the TIO locator s', is a tiny quantity needed only by the most precise applications.  It can either be set to zero or predicted using the ERFA function  sp00 . The geographical coordinates are with respect to the  WGS84  reference ellipsoid.  TAKE CARE WITH THE LONGITUDE SIGN:  the longitude required by the present function is east-positive (i.e. right-handed), in accordance with geographical convention. The polar motion xp,yp can be obtained from IERS bulletins.  The values are the coordinates (in radians) of the Celestial Intermediate Pole with respect to the International Terrestrial Reference System (see IERS Conventions 2003), measured along the meridians 0 and 90 deg west respectively.  For many applications, xp and yp can be set to zero. Internally, the polar motion is stored in a form rotated onto the local meridian. The refraction constants refa and refb are for use in a  $dZ = A*\\tan(Z)+B*\\tan^3(Z)$  model, where Z is the observed (i.e. refracted) zenith distance and dZ is the amount of refraction. It is advisable to take great care with units, as even unlikely values of the input parameters are accepted and processed in accordance with the models used. In cases where the caller does not wish to provide the Earth rotation information and refraction constants, the function  apio13  can be used instead of the present function.  This starts from UTC and weather readings etc. and computes suitable values using other ERFA functions. This is one of several functions that inserts into the astrom structure star-independent parameters needed for the chain of astrometric transformations ICRS <-> GCRS <-> CIRS <-> observed. The various functions support different classes of observer and portions of the transformation chain: Functions Observer Transformation apcg apcg13 geocentric ICRS <-> GCRS apci apci13 terrestrial ICRS <-> CIRS apco apco13 terrestrial ICRS <-> observed apcs apcs13 space ICRS <-> GCRS aper aper13 terrestrial update Earth rotation apio apio13 terrestrial CIRS <-> observed Those with names ending in \"13\" use contemporary ERFA models to compute the various ephemerides.  The others accept ephemerides supplied by the caller. The transformation from ICRS to GCRS covers space motion, parallax, light deflection, and aberration.  From GCRS to CIRS comprises frame bias and precession-nutation.  From CIRS to observed takes account of Earth rotation, polar motion, diurnal aberration and parallax (unless subsumed into the ICRS <-> GCRS transformation), and atmospheric refraction. The context structure astrom produced by this function is used by  atioq  and  atoiq . Called pvtob : position/velocity of terrestrial station aper : astrometry parameters: update ERA source"},{"id":849,"pagetitle":"Functions","title":"ERFA.apio13","ref":"/ERFA/stable/api/functions/#ERFA.apio13-NTuple{12, Any}","content":" ERFA.apio13  —  Method apio13(utc1, utc2, dut1, elong, phi, hm, xp, yp, phpa, tk, rh, wl) For a terrestrial observer, prepare star-independent astrometry parameters for transformations between CIRS and observed coordinates.  The caller supplies UTC, site coordinates, ambient air conditions and observing wavelength. Given utc1 : UTC as a 2-part... utc2 : ...quasi Julian Date (Notes 1,2) dut1 : UT1-UTC (seconds) elong : Longitude (radians, east +ve, Note 3) phi : Geodetic latitude (radians, Note 3) hm : Height above ellipsoid (m, geodetic Notes 4,6) xp ,  yp : Polar motion coordinates (radians, Note 5) phpa : Pressure at the observer (hPa = mB, Note 6) tc : Ambient temperature at the observer (deg C) rh : Relative humidity at the observer (range 0-1) wl : Wavelength (micrometers, Note 7) Returned astrom : Star-independent astrometry parameters: pmt : unchanged eb : unchanged eh : unchanged em : unchanged v : unchanged bm1 : unchanged bpn : unchanged along : Longitude + s' (radians) xp1 : Polar motion xp wrt local meridian (radians) yp1 : Polar motion yp wrt local meridian (radians) sphi : Sine of geodetic latitude cphi : Cosine of geodetic latitude diurab : Magnitude of diurnal aberration vector l : \"Local\" Earth rotation angle (radians) refa : Refraction constant A (radians) refb : Refraction constant B (radians) Notes utc1+utc2 is quasi Julian Date (see Note 2), apportioned in any  convenient way between the two arguments, for example where utc1  is the Julian Day Number and utc2 is the fraction of a day. However, JD cannot unambiguously represent UTC during a leap  second unless special measures are taken.  The convention in the  present function is that the JD day represents UTC days whether  the length is 86399, 86400 or 86401 SI seconds. Applications should use the function  dtf2d  to convert from  calendar date and time of day into 2-part quasi Julian Date, as  it implements the leap-second-ambiguity convention just  described. The warning status \"dubious year\" flags UTCs that predate the  introduction of the time scale or that are too far in the future  to be trusted.  See  dat  for further details. UT1-UTC is tabulated in IERS bulletins.  It increases by exactly  one second at the end of each positive UTC leap second,  introduced in order to keep UT1-UTC within +/- 0.9s.  n.b. This  practice is under review, and in the future UT1-UTC may grow  essentially without limit. The geographical coordinates are with respect to the  WGS84   reference ellipsoid.  TAKE CARE WITH THE LONGITUDE SIGN:  the  longitude required by the present function is east-positive  (i.e. right-handed), in accordance with geographical convention. The polar motion xp,yp can be obtained from IERS bulletins.  The  values are the coordinates (in radians) of the Celestial  Intermediate Pole with respect to the International Terrestrial  Reference System (see IERS Conventions 2003), measured along the  meridians 0 and 90 deg west respectively.  For many applications,  xp and yp can be set to zero. Internally, the polar motion is stored in a form rotated onto  the local meridian. If hm, the height above the ellipsoid of the observing station  in meters, is not known but phpa, the pressure in hPa (=mB), is  available, an adequate estimate of hm can be obtained from the  expression hm = -29.3 * tsl * log ( phpa / 1013.25 ); where tsl is the approximate sea-level air temperature in K  (See Astrophysical Quantities, C.W.Allen, 3rd edition, section  52).  Similarly, if the pressure phpa is not known, it can be  estimated from the height of the observing station, hm, as  follows: phpa = 1013.25 * exp ( -hm / ( 29.3 * tsl ) ); Note, however, that the refraction is nearly proportional to the  pressure and that an accurate phpa value is important for  precise work. The argument wl specifies the observing wavelength in  micrometers.  The transition from optical to radio is assumed to  occur at 100 micrometers (about 3000 GHz). It is advisable to take great care with units, as even unlikely  values of the input parameters are accepted and processed in  accordance with the models used. In cases where the caller wishes to supply his own Earth  rotation information and refraction constants, the function   apc*  can be used instead of the present function. This is one of several functions that inserts into the astrom  structure star-independent parameters needed for the chain of  astrometric transformations ICRS <-> GCRS <-> CIRS <-> observed. The various functions support different classes of observer and  portions of the transformation chain: Functions Observer Transformation apcg apcg13 geocentric ICRS <-> GCRS apci apci13 terrestrial ICRS <-> CIRS apco apco13 terrestrial ICRS <-> observed apcs apcs13 space ICRS <-> GCRS aper aper13 terrestrial update Earth rotation apio apio13 terrestrial CIRS <-> observed Those with names ending in \"13\" use contemporary ERFA models to  compute the various ephemerides.  The others accept ephemerides  supplied by the caller. The transformation from ICRS to GCRS covers space motion,  parallax, light deflection, and aberration.  From GCRS to CIRS  comprises frame bias and precession-nutation.  From CIRS to  observed takes account of Earth rotation, polar motion, diurnal  aberration and parallax (unless subsumed into the ICRS <-> GCRS  transformation), and atmospheric refraction. The context structure astrom produced by this function is used  by  atioq  and  atoiq . Called utctai : UTC to TAI taitt : TAI to TT utcut1 : UTC to UT1 sp00 : the TIO locator s', IERS 2000 era00 : Earth rotation angle, IAU 2000 refco : refraction constants for given ambient conditions apio : astrometry parameters, CIRS-observed source"},{"id":850,"pagetitle":"Functions","title":"ERFA.atcc13","ref":"/ERFA/stable/api/functions/#ERFA.atcc13-NTuple{8, Any}","content":" ERFA.atcc13  —  Method atcc13(rc, dc, pr, pd, px, rv, date1, date2) Transform a star's ICRS catalog entry (epoch J2000.0) into ICRS astrometric place. Given rc : ICRS right ascension at J2000.0 (radians, Note 1) dc : ICRS declination at J2000.0 (radians, Note 1) pr : RA proper motion (radians/year, Note 2) pd : Dec proper motion (radians/year) px : parallax (arcsec) rv : radial velocity (km/s, +ve if receding) date1 : TDB as a 2-part... date2 : ...Julian Date (Note 3) Returned ra ,  da : ICRS astrometric RA,Dec (radians) Notes Star data for an epoch other than J2000.0 (for example from the Hipparcos catalog, which has an epoch of J1991.25) will require a preliminary call to eraPmsafe before use. The proper motion in RA is dRA/dt rather than cos(Dec)*dRA/dt. The TDB date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TDB)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience.  For most applications of this function the choice will not be at all critical. TT can be used instead of TDB without any significant impact on accuracy. Called apci13 : astrometry parameters, ICRS-CIRS, 2013 atccq : quick catalog ICRS to astrometric source"},{"id":851,"pagetitle":"Functions","title":"ERFA.atccq","ref":"/ERFA/stable/api/functions/#ERFA.atccq-NTuple{7, Any}","content":" ERFA.atccq  —  Method atccq(rc, dc, pr, pd, px, rv, astrom) Quick transformation of a star's ICRS catalog entry (epoch J2000.0) into ICRS astrometric place, given precomputed star-independent astrometry parameters. Use of this function is appropriate when efficiency is important and where many star positions are to be transformed for one date.  The star-independent parameters can be obtained by calling one of the functions  apci ,  apci13 ,  apcg ,  apcg13 ,  apco ,  apco13 ,  apcs ,  apcs13 . If the parallax and proper motions are zero the transformation has no effect. Given rc ,  dc : ICRS RA,Dec at J2000.0 (radians) pr : RA proper motion (radians/year, Note 3) pd : Dec proper motion (radians/year) px : parallax (arcsec) rv : radial velocity (km/s, +ve if receding) astrom : Star-independent astrometry parameters: pmt : unchanged eb : unchanged eh : unchanged em : unchanged v : unchanged bm1 : unchanged bpn : unchanged along : Longitude + s' (radians) xp1 : Polar motion xp wrt local meridian (radians) yp1 : Polar motion yp wrt local meridian (radians) sphi : Sine of geodetic latitude cphi : Cosine of geodetic latitude diurab : Magnitude of diurnal aberration vector l : \"Local\" Earth rotation angle (radians) refa : Refraction constant A (radians) refb : Refraction constant B (radians) Returned ra ,  da : ICRS astrometric RA,Dec (radians) Notes All the vectors are with respect to BCRS axes. Star data for an epoch other than J2000.0 (for example from the Hipparcos catalog, which has an epoch of J1991.25) will require a preliminary call to eraPmsafe before use. The proper motion in RA is dRA/dt rather than cos(Dec)*dRA/dt. Called pmpx : proper motion and parallax c2s : p-vector to spherical anp : normalize angle into range 0 to 2pi source"},{"id":852,"pagetitle":"Functions","title":"ERFA.atci13","ref":"/ERFA/stable/api/functions/#ERFA.atci13-NTuple{8, Any}","content":" ERFA.atci13  —  Method atci13(rc, dc, pr, pd, px, rv, date1, date2) Transform ICRS star data, epoch J2000.0, to CIRS. Given rc : ICRS right ascension at J2000.0 (radians, Note 1) dc : ICRS declination at J2000.0 (radians, Note 1) pr : RA proper motion (radians/year; Note 2) pd : Dec proper motion (radians/year) px : Parallax (arcsec) rv : Radial velocity (km/s, +ve if receding) date1 : TDB as a 2-part... date2 : ...Julian Date (Note 3) Returned ri ,  di : CIRS geocentric RA,Dec (radians) eo : Equation of the origins (ERA-GST, Note 5) Notes Star data for an epoch other than J2000.0 (for example from the Hipparcos catalog, which has an epoch of J1991.25) will require a preliminary call to  pmsafe  before use. The proper motion in RA is dRA/dt rather than cos(Dec)*dRA/dt. The TDB date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TDB)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience.  For most applications of this function the choice will not be at all critical. TT can be used instead of TDB without any significant impact on accuracy. The available accuracy is better than 1 milliarcsecond, limited mainly by the precession-nutation model that is used, namely IAU 2000A/2006.  Very close to solar system bodies, additional errors of up to several milliarcseconds can occur because of unmodeled light deflection;  however, the Sun's contribution is taken into account, to first order.  The accuracy limitations of the ERFA function  epv00  (used to compute Earth position and velocity) can contribute aberration errors of up to 5 microarcseconds.  Light deflection at the Sun's limb is uncertain at the 0.4 mas level. Should the transformation to (equinox based) apparent place be required rather than (CIO based) intermediate place, subtract the equation of the origins from the returned right ascension: RA = RI - EO. (The  anp  function can then be applied, as required, to keep the result in the conventional 0-2pi range.) Called apci13 : astrometry parameters, ICRS-CIRS, 2013 atciq : quick ICRS to CIRS source"},{"id":853,"pagetitle":"Functions","title":"ERFA.atciq","ref":"/ERFA/stable/api/functions/#ERFA.atciq-NTuple{7, Any}","content":" ERFA.atciq  —  Method atciq(rc, dc, pr, pd, px, rv, astrom) Quick ICRS, epoch J2000.0, to CIRS transformation, given precomputed star-independent astrometry parameters. Use of this function is appropriate when efficiency is important and where many star positions are to be transformed for one date.  The star-independent parameters can be obtained by calling one of the functions  apci[13] ,  apcg[13] ,  apco[13]  or  apcs[13] . If the parallax and proper motions are zero the  atciqz  function can be used instead. Given rc ,  dc : ICRS RA,Dec at J2000.0 (radians) pr : RA proper motion (radians/year; Note 3) pd : Dec proper motion (radians/year) px : Parallax (arcsec) rv : Radial velocity (km/s, +ve if receding) astrom : Star-independent astrometry parameters: pmt : PM time interval (SSB, Julian years) eb : SSB to observer (vector, au) eh : Sun to observer (unit vector) em : Distance from Sun to observer (au) v : Barycentric observer velocity (vector, c) bm1 :  $\\sqrt{1-|v|^2}$  Reciprocal of Lorenz factor bpn : Bias-precession-nutation matrix along : Longitude + s' (radians) xp1 : Polar motion xp wrt local meridian (radians) yp1 : Polar motion yp wrt local meridian (radians) sphi : Sine of geodetic latitude cphi : Cosine of geodetic latitude diurab : Magnitude of diurnal aberration vector l : \"Local\" Earth rotation angle (radians) refa : Refraction constant A (radians) refb : Refraction constant B (radians) Returned ri ,  di : CIRS RA,Dec (radians) Notes All the vectors are with respect to BCRS axes. Star data for an epoch other than J2000.0 (for example from the Hipparcos catalog, which has an epoch of J1991.25) will require a preliminary call to  pmsafe  before use. The proper motion in RA is dRA/dt rather than cos(Dec)*dRA/dt. Called pmpx : proper motion and parallax ldsun : light deflection by the Sun ab : stellar aberration rxp : product of r-matrix and pv-vector c2s : p-vector to spherical anp : normalize angle into range 0 to 2pi source"},{"id":854,"pagetitle":"Functions","title":"ERFA.atciqn","ref":"/ERFA/stable/api/functions/#ERFA.atciqn-Tuple{Any, Any, Any, Any, Any, Any, Any, Vector{ERFA.LDBODY}}","content":" ERFA.atciqn  —  Method atciqn(rc, dc, pr, pd, px, rv, astrom, b::Vector{LDBODY}) Quick ICRS, epoch J2000.0, to CIRS transformation, given precomputed star-independent astrometry parameters plus a list of light- deflecting bodies. Use of this function is appropriate when efficiency is important and where many star positions are to be transformed for one date.  The star-independent parameters can be obtained by calling one of the functions  apci[13] ,  apcg[13] ,  apco[13]  or  apcs[13] . If the only light-deflecting body to be taken into account is the Sun, the  atciq  function can be used instead.  If in addition the parallax and proper motions are zero, the  atciqz  function can be used. Given rc ,  dc : ICRS RA,Dec at J2000.0 (radians) pr : RA proper motion (radians/year; Note 3) pd : Dec proper motion (radians/year) px : Parallax (arcsec) rv : Radial velocity (km/s, +ve if receding) EraASTROM*   star-independent astrometry parameters: pmt : PM time interval (SSB, Julian years) eb : SSB to observer (vector, au) eh : Sun to observer (unit vector) em : Distance from Sun to observer (au) v : Barycentric observer velocity (vector, c) bm1 :  $\\sqrt{1-|v|^2}$  Reciprocal of Lorenz factor bpn : Bias-precession-nutation matrix along : Longitude + s' (radians) xp1 : Polar motion xp wrt local meridian (radians) yp1 : Polar motion yp wrt local meridian (radians) sphi : Sine of geodetic latitude cphi : Cosine of geodetic latitude diurab : Magnitude of diurnal aberration vector l : \"Local\" Earth rotation angle (radians) refa : Refraction constant A (radians) refb : Refraction constant B (radians) n : Number of bodies (Note 3) b::Vector{LDBODY} : Data for each of the n bodies (Notes 3,4): bm : Mass of the body (solar masses, Note 5) dl : Deflection limiter (Note 6) pv : Barycentric PV of the body (au, au/day) Returned ri ,  di : CIRS RA,Dec (radians) Notes Star data for an epoch other than J2000.0 (for example from the Hipparcos catalog, which has an epoch of J1991.25) will require a preliminary call to  pmsafe  before use. The proper motion in RA is dRA/dt rather than cos(Dec)*dRA/dt. The struct b contains n entries, one for each body to be considered.  If n = 0, no gravitational light deflection will be applied, not even for the Sun. The struct b should include an entry for the Sun as well as for any planet or other body to be taken into account.  The entries should be in the order in which the light passes the body. In the entry in the b struct for body i, the mass parameter b[i].bm can, as required, be adjusted in order to allow for such effects as quadrupole field. The deflection limiter parameter b[i].dl is phi^2/2, where phi is the angular separation (in radians) between star and body at which limiting is applied.  As phi shrinks below the chosen threshold, the deflection is artificially reduced, reaching zero for phi = 0.   Example values suitable for a terrestrial observer, together with masses, are as follows: body i b[i].bm b[i].dl Sun 1.0 6e-6 Jupiter 0.00095435 3e-9 Saturn 0.00028574 3e-10 For efficiency, validation of the contents of the b array is omitted.  The supplied masses must be greater than zero, the position and velocity vectors must be right, and the deflection limiter greater than zero. Called pmpx : proper motion and parallax ldn : light deflection by n bodies ab : stellar aberration rxp : product of r-matrix and pv-vector c2s : p-vector to spherical anp : normalize angle into range 0 to 2pi source"},{"id":855,"pagetitle":"Functions","title":"ERFA.atciqz","ref":"/ERFA/stable/api/functions/#ERFA.atciqz-Tuple{Any, Any, Any}","content":" ERFA.atciqz  —  Method atciqz(rc, dc, astrom) Quick ICRS to CIRS transformation, given precomputed star- independent astrometry parameters, and assuming zero parallax and proper motion. Use of this function is appropriate when efficiency is important and where many star positions are to be transformed for one date.  The star-independent parameters can be obtained by calling one of the functions  apci[13] ,  apcg[13] ,  apco[13]  or  apcs[13] . The corresponding function for the case of non-zero parallax and proper motion is  atciq . Given rc ,  dc : ICRS astrometric RA,Dec (radians) astrom : Star-independent astrometry parameters: pmt : PM time interval (SSB, Julian years) eb : SSB to observer (vector, au) eh : Sun to observer (unit vector) em : Distance from Sun to observer (au) v : Barycentric observer velocity (vector, c) bm1 :  $\\sqrt{1-|v|^2}$  Reciprocal of Lorenz factor bpn : Bias-precession-nutation matrix along : Longitude + s' (radians) xp1 : Polar motion xp wrt local meridian (radians) yp1 : Polar motion yp wrt local meridian (radians) sphi : Sine of geodetic latitude cphi : Cosine of geodetic latitude diurab : Magnitude of diurnal aberration vector l : \"Local\" Earth rotation angle (radians) refa : Refraction constant A (radians) refb : Refraction constant B (radians) Returned ri ,  di : CIRS RA,Dec (radians) Note All the vectors are with respect to BCRS axes. References Urban, S. & Seidelmann, P. K. (eds), Explanatory Supplement to   the Astronomical Almanac, 3rd ed., University Science Books   (2013). Klioner, Sergei A., \"A practical relativistic model for micro-   arcsecond astrometry in space\", Astr. J. 125, 1580-1597 (2003). Called s2c : spherical coordinates to unit vector ldsun : light deflection due to Sun ab : stellar aberration rxp : product of r-matrix and p-vector c2s : p-vector to spherical anp : normalize angle into range +/- pi source"},{"id":856,"pagetitle":"Functions","title":"ERFA.atco13","ref":"/ERFA/stable/api/functions/#ERFA.atco13-NTuple{18, Any}","content":" ERFA.atco13  —  Method atco13(rc, dc, pr, pd, px, rv, utc1, utc2, dut1, elong, phi, hm, xp, yp, phpa, tk, rh, wl) ICRS RA,Dec to observed place.  The caller supplies UTC, site coordinates, ambient air conditions and observing wavelength. ERFA models are used for the Earth ephemeris, bias-precession- nutation, Earth orientation and refraction. Given rc ,  dc : ICRS right ascension at J2000.0 (radians, Note 1) pr : RA proper motion (radians/year; Note 2) pd : Dec proper motion (radians/year) px : Parallax (arcsec) rv : Radial velocity (km/s, +ve if receding) utc1 : UTC as a 2-part... utc2 : ...quasi Julian Date (Notes 3-4) dut1 : UT1-UTC (seconds, Note 5) elong : Longitude (radians, east +ve, Note 6) phi : Latitude (geodetic, radians, Note 6) hm : Height above ellipsoid (m, geodetic, Notes 6,8) xp ,  yp : Polar motion coordinates (radians, Note 7) phpa : Pressure at the observer (hPa = mB, Note 8) tc : Ambient temperature at the observer (deg C) rh : Relative humidity at the observer (range 0-1) wl : Wavelength (micrometers, Note 9) Returned aob : Observed azimuth (radians: N=0,E=90) zob : Observed zenith distance (radians) hob : Observed hour angle (radians) dob : Observed declination (radians) rob : Observed right ascension (CIO-based, radians) eo : Equation of the origins (ERA-GST) Notes Star data for an epoch other than J2000.0 (for example from the  Hipparcos catalog, which has an epoch of J1991.25) will require  a preliminary call to  pmsafe  before use. The proper motion in RA is dRA/dt rather than cos(Dec)*dRA/dt. utc1+utc2 is quasi Julian Date (see Note 2), apportioned in any  convenient way between the two arguments, for example where utc1  is the Julian Day Number and utc2 is the fraction of a day. However, JD cannot unambiguously represent UTC during a leap  second unless special measures are taken.  The convention in the  present function is that the JD day represents UTC days whether  the length is 86399, 86400 or 86401 SI seconds. Applications should use the function  dtf2d  to convert from  calendar date and time of day into 2-part quasi Julian Date, as  it implements the leap-second-ambiguity convention just  described. The warning status \"dubious year\" flags UTCs that predate the  introduction of the time scale or that are too far in the  future to be trusted.  See  dat  for further details. UT1-UTC is tabulated in IERS bulletins.  It increases by exactly  one second at the end of each positive UTC leap second,  introduced in order to keep UT1-UTC within +/- 0.9s.  n.b. This  practice is under review, and in the future UT1-UTC may grow  essentially without limit. The geographical coordinates are with respect to the  WGS84   reference ellipsoid.  TAKE CARE WITH THE LONGITUDE SIGN:  the  longitude required by the present function is east-positive  (i.e. right-handed), in accordance with geographical convention. The polar motion xp,yp can be obtained from IERS bulletins.  The  values are the coordinates (in radians) of the Celestial  Intermediate Pole with respect to the International Terrestrial  Reference System (see IERS Conventions 2003), measured along the  meridians 0 and 90 deg west respectively.  For many  applications, xp and yp can be set to zero. If hm, the height above the ellipsoid of the observing station  in meters, is not known but phpa, the pressure in hPa (=mB),  is available, an adequate estimate of hm can be obtained from  the expression hm = -29.3 * tsl * log ( phpa / 1013.25 ); where tsl is the approximate sea-level air temperature in K  (See Astrophysical Quantities, C.W.Allen, 3rd edition, section  52).  Similarly, if the pressure phpa is not known, it can be  estimated from the height of the observing station, hm, as  follows: phpa = 1013.25 * exp ( -hm / ( 29.3 * tsl ) ); Note, however, that the refraction is nearly proportional to  the pressure and that an accurate phpa value is important for  precise work. The argument wl specifies the observing wavelength in  micrometers.  The transition from optical to radio is assumed to  occur at 100 micrometers (about 3000 GHz). The accuracy of the result is limited by the corrections for  refraction, which use a simple  $A*tan(z) + B*tan^3(z)$  model.  Providing the meteorological parameters are known accurately and  there are no gross local effects, the predicted observed  coordinates should be within 0.05 arcsec (optical) or 1 arcsec  (radio) for a zenith distance of less than 70 degrees, better  than 30 arcsec (optical or radio) at 85 degrees and better  than 20 arcmin (optical) or 30 arcmin (radio) at the horizon. Without refraction, the complementary functions  atco13  and   atoc13  are self-consistent to better than 1 microarcsecond  all over the celestial sphere.  With refraction included,  consistency falls off at high zenith distances, but is still  better than 0.05 arcsec at 85 degrees. \"Observed\" Az,ZD means the position that would be seen by a  perfect geodetically aligned theodolite.  (Zenith distance is  used rather than altitude in order to reflect the fact that no  allowance is made for depression of the horizon.)  This is  related to the observed HA,Dec via the standard rotation, using  the geodetic latitude (corrected for polar motion), while the  observed HA and RA are related simply through the Earth rotation  angle and the site longitude.  \"Observed\" RA,Dec or HA,Dec thus  means the position that would be seen by a perfect equatorial  with its polar axis aligned to the Earth's axis of rotation. It is advisable to take great care with units, as even unlikely  values of the input parameters are accepted and processed in  accordance with the models used. Called apco13 : astrometry parameters, ICRS-observed, 2013 atciq : quick ICRS to CIRS atioq : quick CIRS to observed source"},{"id":857,"pagetitle":"Functions","title":"ERFA.atic13","ref":"/ERFA/stable/api/functions/#ERFA.atic13-NTuple{4, Any}","content":" ERFA.atic13  —  Method atic13(ri, di, date1, date2) Transform star RA,Dec from geocentric CIRS to ICRS astrometric. Given ri ,  di : CIRS geocentric RA,Dec (radians) date1 : TDB as a 2-part... date2 : ...Julian Date (Note 1) Returned rc ,  dc : ICRS astrometric RA,Dec (radians) eo : Equation of the origins (ERA-GST, Note 4) Notes The TDB date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TDB)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience.  For most applications of this function the choice will not be at all critical. TT can be used instead of TDB without any significant impact on accuracy. Iterative techniques are used for the aberration and light deflection corrections so that the functions  atic13  (or  aticq ) and  atci13  (or  atciq ) are accurate inverses; even at the edge of the Sun's disk the discrepancy is only about 1 nanoarcsecond. The available accuracy is better than 1 milliarcsecond, limited mainly by the precession-nutation model that is used, namely IAU 2000A/2006.  Very close to solar system bodies, additional errors of up to several milliarcseconds can occur because of unmodeled light deflection;  however, the Sun's contribution is taken into account, to first order.  The accuracy limitations of the ERFA function  epv00  (used to compute Earth position and velocity) can contribute aberration errors of up to 5 microarcseconds.  Light deflection at the Sun's limb is uncertain at the 0.4 mas level. Should the transformation to (equinox based) J2000.0 mean place be required rather than (CIO based) ICRS coordinates, subtract the equation of the origins from the returned right ascension: RA = RI - EO.  (The  anp  function can then be applied, as required, to keep the result in the conventional 0-2pi range.) Called apci13 : astrometry parameters, ICRS-CIRS, 2013 aticq : quick CIRS to ICRS astrometric source"},{"id":858,"pagetitle":"Functions","title":"ERFA.aticq","ref":"/ERFA/stable/api/functions/#ERFA.aticq-Tuple{Any, Any, Any}","content":" ERFA.aticq  —  Method aticq(ri, di, astrom) Quick CIRS RA,Dec to ICRS astrometric place, given the star- independent astrometry parameters. Use of this function is appropriate when efficiency is important and where many star positions are all to be transformed for one date. The star-independent astrometry parameters can be obtained by calling one of the functions  apci[13] ,  apcg[13] ,  apco[13]  or  apcs[13] . Given ri ,  di : CIRS RA,Dec (radians) astrom : Star-independent astrometry parameters: pmt : PM time interval (SSB, Julian years) eb : SSB to observer (vector, au) eh : Sun to observer (unit vector) em : Distance from Sun to observer (au) v : Barycentric observer velocity (vector, c) bm1 :  $\\sqrt{1-|v|^2}$  Reciprocal of Lorenz factor bpn : Bias-precession-nutation matrix along : Longitude + s' (radians) xp1 : Polar motion xp wrt local meridian (radians) yp1 : Polar motion yp wrt local meridian (radians) sphi : Sine of geodetic latitude cphi : Cosine of geodetic latitude diurab : Magnitude of diurnal aberration vector l : \"Local\" Earth rotation angle (radians) refa : Refraction constant A (radians) refb : Refraction constant B (radians) Returned rc ,  dc : ICRS astrometric RA,Dec (radians) Notes Only the Sun is taken into account in the light deflection correction. Iterative techniques are used for the aberration and light deflection corrections so that the functions  atic13  (or  aticq ) and  atci13  (or  atciq ) are accurate inverses; even at the edge of the Sun's disk the discrepancy is only about 1 nanoarcsecond. Called s2c : spherical coordinates to unit vector trxp : product of transpose of r-matrix and p-vector zp : zero p-vector ab : stellar aberration ldsun : light deflection by the Sun c2s : p-vector to spherical anp : normalize angle into range +/- pi source"},{"id":859,"pagetitle":"Functions","title":"ERFA.aticqn","ref":"/ERFA/stable/api/functions/#ERFA.aticqn-Tuple{Any, Any, Any, Array{ERFA.LDBODY}}","content":" ERFA.aticqn  —  Method aticqn(ri, di, astrom, b::Array{LDBODY}) Quick CIRS to ICRS astrometric place transformation, given the star- independent astrometry parameters plus a list of light-deflecting bodies. Use of this function is appropriate when efficiency is important and where many star positions are all to be transformed for one date. The star-independent astrometry parameters can be obtained by calling one of the functions  apci[13] ,  apcg[13] ,  apco[13]  or  apcs[13] . Given ri ,  di : CIRS RA,Dec (radians) astrom : Star-independent astrometry parameters: pmt : PM time interval (SSB, Julian years) eb : SSB to observer (vector, au) eh : Sun to observer (unit vector) em : Distance from Sun to observer (au) v : Barycentric observer velocity (vector, c) bm1 :  $\\sqrt{1-|v|^2}$  Reciprocal of Lorenz factor bpn : Bias-precession-nutation matrix along : Longitude + s' (radians) xp1 : Polar motion xp wrt local meridian (radians) yp1 : Polar motion yp wrt local meridian (radians) sphi : Sine of geodetic latitude cphi : Cosine of geodetic latitude diurab : Magnitude of diurnal aberration vector l : \"Local\" Earth rotation angle (radians) refa : Refraction constant A (radians) refb : Refraction constant B (radians) n : Number of bodies (Note 3) b::Vector{LDBODY} : Data for each of the n bodies (Notes 3,4): bm : Mass of the body (solar masses, Note 5) dl : Deflection limiter (Note 6) pv : Barycentric PV of the body (au, au/day) Returned rc ,  dc : ICRS astrometric RA,Dec (radians) Notes Iterative techniques are used for the aberration and light deflection corrections so that the functions  aticqn  and  atciqn  are accurate inverses; even at the edge of the Sun's disk the discrepancy is only about 1 nanoarcsecond. If the only light-deflecting body to be taken into account is the Sun, the  aticq  function can be used instead. The struct b contains n entries, one for each body to be considered.  If n = 0, no gravitational light deflection will be applied, not even for the Sun. The struct b should include an entry for the Sun as well as for any planet or other body to be taken into account.  The entries should be in the order in which the light passes the body. In the entry in the b struct for body i, the mass parameter b[i].bm can, as required, be adjusted in order to allow for such effects as quadrupole field. The deflection limiter parameter b[i].dl is phi^2/2, where phi is the angular separation (in radians) between star and body at which limiting is applied.  As phi shrinks below the chosen threshold, the deflection is artificially reduced, reaching zero for phi = 0.   Example values suitable for a terrestrial observer, together with masses, are as follows: body i b[i].bm b[i].dl Sun 1.0 6e-6 Jupiter 0.00095435 3e-9 Saturn 0.00028574 3e-10 For efficiency, validation of the contents of the b array is omitted.  The supplied masses must be greater than zero, the position and velocity vectors must be right, and the deflection limiter greater than zero. Called s2c : spherical coordinates to unit vector trxp : product of transpose of r-matrix and p-vector zp : zero p-vector ab : stellar aberration ldn : light deflection by n bodies c2s : p-vector to spherical anp : normalize angle into range +/- pi source"},{"id":860,"pagetitle":"Functions","title":"ERFA.atio13","ref":"/ERFA/stable/api/functions/#ERFA.atio13-NTuple{14, Any}","content":" ERFA.atio13  —  Method atio13(ri, di, utc1, utc2, dut1, elong, phi, hm, xp, yp, phpa, tk, rh, wl) CIRS RA,Dec to observed place.  The caller supplies UTC, site coordinates, ambient air conditions and observing wavelength. Given ri : CIRS right ascension (CIO-based, radians) di : CIRS declination (radians) utc1 : UTC as a 2-part... utc2 : ...quasi Julian Date (Notes 1,2) dut1 : UT1-UTC (seconds, Note 3) elong : Longitude (radians, east +ve, Note 4) phi : Geodetic latitude (radians, Note 4) hm : Height above ellipsoid (m, geodetic Notes 4,6) xp ,  yp : Polar motion coordinates (radians, Note 5) phpa : Pressure at the observer (hPa = mB, Note 6) tc : Ambient temperature at the observer (deg C) rh : Relative humidity at the observer (range 0-1) wl : Wavelength (micrometers, Note 7) Returned aob : Observed azimuth (radians: N=0,E=90) zob : Observed zenith distance (radians) hob : Observed hour angle (radians) dob : Observed declination (radians) rob : Observed right ascension (CIO-based, radians) Notes utc1+utc2 is quasi Julian Date (see Note 2), apportioned in any  convenient way between the two arguments, for example where utc1  is the Julian Day Number and utc2 is the fraction of a day. However, JD cannot unambiguously represent UTC during a leap  second unless special measures are taken.  The convention in the  present function is that the JD day represents UTC days whether  the length is 86399, 86400 or 86401 SI seconds. Applications should use the function  dtf2d  to convert from  calendar date and time of day into 2-part quasi Julian Date, as  it implements the leap-second-ambiguity convention just  described. The warning status \"dubious year\" flags UTCs that predate the  introduction of the time scale or that are too far in the  future to be trusted.  See  dat  for further details. UT1-UTC is tabulated in IERS bulletins.  It increases by exactly  one second at the end of each positive UTC leap second,  introduced in order to keep UT1-UTC within +/- 0.9s.  n.b. This  practice is under review, and in the future UT1-UTC may grow  essentially without limit. The geographical coordinates are with respect to the  WGS84   reference ellipsoid.  TAKE CARE WITH THE LONGITUDE SIGN:  the  longitude required by the present function is east-positive  (i.e. right-handed), in accordance with geographical convention. The polar motion xp,yp can be obtained from IERS bulletins.  The  values are the coordinates (in radians) of the Celestial  Intermediate Pole with respect to the International Terrestrial  Reference System (see IERS Conventions 2003), measured along the  meridians 0 and 90 deg west respectively.  For many  applications, xp and yp can be set to zero. If hm, the height above the ellipsoid of the observing station  in meters, is not known but phpa, the pressure in hPa (=mB), is  available, an adequate estimate of hm can be obtained from the  expression hm = -29.3 * tsl * log ( phpa / 1013.25 ); where tsl is the approximate sea-level air temperature in K  (See Astrophysical Quantities, C.W.Allen, 3rd edition, section  52).  Similarly, if the pressure phpa is not known, it can be  estimated from the height of the observing station, hm, as  follows: phpa = 1013.25 * exp ( -hm / ( 29.3 * tsl ) ); Note, however, that the refraction is nearly proportional to  the pressure and that an accurate phpa value is important for  precise work. The argument wl specifies the observing wavelength in  micrometers.  The transition from optical to radio is assumed to  occur at 100 micrometers (about 3000 GHz). \"Observed\" Az,ZD means the position that would be seen by a  perfect geodetically aligned theodolite.  (Zenith distance is  used rather than altitude in order to reflect the fact that no  allowance is made for depression of the horizon.)  This is  related to the observed HA,Dec via the standard rotation, using  the geodetic latitude (corrected for polar motion), while the  observed HA and RA are related simply through the Earth rotation  angle and the site longitude.  \"Observed\" RA,Dec or HA,Dec thus  means the position that would be seen by a perfect equatorial  with its polar axis aligned to the Earth's axis of rotation. The accuracy of the result is limited by the corrections for  refraction, which use a simple  $A*tan(z) + B*tan^3(z)$  model.  Providing the meteorological parameters are known accurately and  there are no gross local effects, the predicted astrometric  coordinates should be within 0.05 arcsec (optical) or 1 arcsec  (radio) for a zenith distance of less than 70 degrees, better  than 30 arcsec (optical or radio) at 85 degrees and better  than 20 arcmin (optical) or 30 arcmin (radio) at the horizon. The complementary functions  atio13  and  atoi13  are self-  consistent to better than 1 microarcsecond all over the  celestial sphere. It is advisable to take great care with units, as even unlikely  values of the input parameters are accepted and processed in  accordance with the models used. Called apio13 : astrometry parameters, CIRS-observed, 2013 atioq : quick CIRS to observed source"},{"id":861,"pagetitle":"Functions","title":"ERFA.atioq","ref":"/ERFA/stable/api/functions/#ERFA.atioq-Tuple{Any, Any, Any}","content":" ERFA.atioq  —  Method atioq(ri, di, astrom) Quick CIRS to observed place transformation. Use of this function is appropriate when efficiency is important and where many star positions are all to be transformed for one date. The star-independent astrometry parameters can be obtained by calling  apio[13]  or  apco[13] . Given ri : CIRS right ascension di : CIRS declination astrom : Star-independent astrometry parameters: pmt : PM time interval (SSB, Julian years) eb : SSB to observer (vector, au) eh : Sun to observer (unit vector) em : Distance from Sun to observer (au) v : Barycentric observer velocity (vector, c) bm1 :  $\\sqrt{1-|v|^2}$  Reciprocal of Lorenz factor bpn : Bias-precession-nutation matrix along : Longitude + s' (radians) xp1 : Polar motion xp wrt local meridian (radians) yp1 : Polar motion yp wrt local meridian (radians) sphi : Sine of geodetic latitude cphi : Cosine of geodetic latitude diurab : Magnitude of diurnal aberration vector l : \"Local\" Earth rotation angle (radians) refa : Refraction constant A (radians) refb : Refraction constant B (radians) Returned aob : Observed azimuth (radians: N=0,E=90) zob : Observed zenith distance (radians) hob : Observed hour angle (radians) dob : Observed declination (radians) rob : Observed right ascension (CIO-based, radians) Notes This function returns zenith distance rather than altitude in order to reflect the fact that no allowance is made for depression of the horizon. The accuracy of the result is limited by the corrections for refraction, which use a simple  $A*tan(z) + B*tan^3(z)$  model. Providing the meteorological parameters are known accurately and there are no gross local effects, the predicted observed coordinates should be within 0.05 arcsec (optical) or 1 arcsec (radio) for a zenith distance of less than 70 degrees, better than 30 arcsec (optical or radio) at 85 degrees and better than 20 arcmin (optical) or 30 arcmin (radio) at the horizon. Without refraction, the complementary functions  atioq  and  atoiq  are self-consistent to better than 1 microarcsecond all over the celestial sphere.  With refraction included, consistency falls off at high zenith distances, but is still better than 0.05 arcsec at 85 degrees. It is advisable to take great care with units, as even unlikely values of the input parameters are accepted and processed in accordance with the models used. The CIRS RA,Dec is obtained from a star catalog mean place by allowing for space motion, parallax, the Sun's gravitational lens effect, annual aberration and precession-nutation.  For star positions in the ICRS, these effects can be applied by means of the  atci13  (etc.) functions.  Starting from classical \"mean place\" systems, additional transformations will be needed first. \"Observed\" Az,El means the position that would be seen by a perfect geodetically aligned theodolite.  This is obtained from the CIRS RA,Dec by allowing for Earth orientation and diurnal aberration, rotating from equator to horizon coordinates, and then adjusting for refraction.  The HA,Dec is obtained by rotating back into equatorial coordinates, and is the position that would be seen by a perfect equatorial with its polar axis aligned to the Earth's axis of rotation.  Finally, the RA is obtained by subtracting the HA from the local ERA. The star-independent CIRS-to-observed-place parameters in ASTROM may be computed with  apio[13]  or  apco[13] .  If nothing has changed significantly except the time,  aper[13]  may be used to perform the requisite adjustment to the astrom structure. Called s2c : spherical coordinates to unit vector c2s : p-vector to spherical anp : normalize angle into range 0 to 2pi source"},{"id":862,"pagetitle":"Functions","title":"ERFA.atoc13","ref":"/ERFA/stable/api/functions/#ERFA.atoc13-NTuple{15, Any}","content":" ERFA.atoc13  —  Method atoc13(typeofcoordinates, ob1, ob2, utc1, utc2, dut1, elong, phi, hm, xp, yp, phpa, tk, rh, wl) Observed place at a groundbased site to to ICRS astrometric RA,Dec. The caller supplies UTC, site coordinates, ambient air conditions and observing wavelength. Given type : Type of coordinates - \"R\", \"H\" or \"A\" (Notes 1,2) ob1 : Observed Az, HA or RA (radians; Az is N=0,E=90) ob2 : Observed ZD or Dec (radians) utc1 : UTC as a 2-part... utc2 : ...quasi Julian Date (Notes 3,4) dut1 : UT1-UTC (seconds, Note 5) elong : Longitude (radians, east +ve, Note 6) phi : Geodetic latitude (radians, Note 6) hm : Height above ellipsoid (m, geodetic Notes 6,8) xp ,  yp : Polar motion coordinates (radians, Note 7) phpa : Pressure at the observer (hPa = mB, Note 8) tc : Ambient temperature at the observer (deg C) rh : Relative humidity at the observer (range 0-1) wl : Wavelength (micrometers, Note 9) Returned rc ,  dc : ICRS astrometric RA,Dec (radians) Notes \"Observed\" Az,ZD means the position that would be seen by a  perfect geodetically aligned theodolite.  (Zenith distance is  used rather than altitude in order to reflect the fact that no  allowance is made for depression of the horizon.)  This is  related to the observed HA,Dec via the standard rotation, using  the geodetic latitude (corrected for polar motion), while the  observed HA and RA are related simply through the Earth rotation  angle and the site longitude.  \"Observed\" RA,Dec or HA,Dec thus  means the position that would be seen by a perfect equatorial  with its polar axis aligned to the Earth's axis of rotation. Only the first character of the type argument is significant.  \"R\" or \"r\" indicates that ob1 and ob2 are the observed right  ascension and declination;  \"H\" or \"h\" indicates that they are  hour angle (west +ve) and declination;  anything else (\"A\" or  \"a\" is recommended) indicates that ob1 and ob2 are azimuth  (north zero, east 90 deg) and zenith distance. utc1+utc2 is quasi Julian Date (see Note 2), apportioned in any  convenient way between the two arguments, for example where utc1  is the Julian Day Number and utc2 is the fraction of a day. However, JD cannot unambiguously represent UTC during a leap  second unless special measures are taken.  The convention in the  present function is that the JD day represents UTC days whether  the length is 86399, 86400 or 86401 SI seconds. Applications should use the function  dtf2d  to convert from  calendar date and time of day into 2-part quasi Julian Date, as  it implements the leap-second-ambiguity convention just  described. The warning status \"dubious year\" flags UTCs that predate the  introduction of the time scale or that are too far in the  future to be trusted.  See  dat  for further details. UT1-UTC is tabulated in IERS bulletins.  It increases by exactly  one second at the end of each positive UTC leap second,  introduced in order to keep UT1-UTC within +/- 0.9s.  n.b. This  practice is under review, and in the future UT1-UTC may grow  essentially without limit. The geographical coordinates are with respect to the  WGS84   reference ellipsoid.  TAKE CARE WITH THE LONGITUDE SIGN:  the  longitude required by the present function is east-positive  (i.e. right-handed), in accordance with geographical convention. The polar motion xp,yp can be obtained from IERS bulletins.  The  values are the coordinates (in radians) of the Celestial  Intermediate Pole with respect to the International Terrestrial  Reference System (see IERS Conventions 2003), measured along the  meridians 0 and 90 deg west respectively.  For many  applications, xp and yp can be set to zero. If hm, the height above the ellipsoid of the observing station  in meters, is not known but phpa, the pressure in hPa (=mB), is  available, an adequate estimate of hm can be obtained from the  expression hm = -29.3 * tsl * log ( phpa / 1013.25 ); where tsl is the approximate sea-level air temperature in K  (See Astrophysical Quantities, C.W.Allen, 3rd edition, section  52).  Similarly, if the pressure phpa is not known, it can be  estimated from the height of the observing station, hm, as  follows: phpa = 1013.25 * exp ( -hm / ( 29.3 * tsl ) ); Note, however, that the refraction is nearly proportional to  the pressure and that an accurate phpa value is important for  precise work. The argument wl specifies the observing wavelength in  micrometers.  The transition from optical to radio is assumed to  occur at 100 micrometers (about 3000 GHz). The accuracy of the result is limited by the corrections for  refraction, which use a simple  $A*tan(z) + B*tan^3(z)$  model.  Providing the meteorological parameters are known accurately and  there are no gross local effects, the predicted astrometric  coordinates should be within 0.05 arcsec (optical) or 1 arcsec  (radio) for a zenith distance of less than 70 degrees, better  than 30 arcsec (optical or radio) at 85 degrees and better  than 20 arcmin (optical) or 30 arcmin (radio) at the horizon. Without refraction, the complementary functions  atco13  and   atoc13  are self-consistent to better than 1 microarcsecond  all over the celestial sphere.  With refraction included,  consistency falls off at high zenith distances, but is still  better than 0.05 arcsec at 85 degrees. It is advisable to take great care with units, as even unlikely  values of the input parameters are accepted and processed in  accordance with the models used. Called apco13 : astrometry parameters, ICRS-observed atoiq : quick observed to CIRS aticq : quick CIRS to ICRS source"},{"id":863,"pagetitle":"Functions","title":"ERFA.atoi13","ref":"/ERFA/stable/api/functions/#ERFA.atoi13-NTuple{15, Any}","content":" ERFA.atoi13  —  Method atoi13(typeofcoordinates, ob1, ob2, utc1, utc2, dut1, elong, phi, hm, xp, yp, phpa, tk, rh, wl) Observed place to CIRS.  The caller supplies UTC, site coordinates, ambient air conditions and observing wavelength. Given type : Type of coordinates - \"R\", \"H\" or \"A\" (Notes 1,2) ob1 : Observed Az, HA or RA (radians; Az is N=0,E=90) ob2 : Observed ZD or Dec (radians) utc1 : UTC as a 2-part... utc2 : ...quasi Julian Date (Notes 3,4) dut1 : UT1-UTC (seconds, Note 5) elong : Longitude (radians, east +ve, Note 6) phi : Geodetic latitude (radians, Note 6) hm : Height above the ellipsoid (meters, Notes 6,8) xp ,  yp : Polar motion coordinates (radians, Note 7) phpa : Pressure at the observer (hPa = mB, Note 8) tc : Ambient temperature at the observer (deg C) rh : Relative humidity at the observer (range 0-1) wl : Wavelength (micrometers, Note 9) Returned ri : CIRS right ascension (CIO-based, radians) di : CIRS declination (radians) Notes \"Observed\" Az,ZD means the position that would be seen by a  perfect geodetically aligned theodolite.  (Zenith distance is  used rather than altitude in order to reflect the fact that no  allowance is made for depression of the horizon.)  This is  related to the observed HA,Dec via the standard rotation, using  the geodetic latitude (corrected for polar motion), while the  observed HA and RA are related simply through the Earth rotation  angle and the site longitude.  \"Observed\" RA,Dec or HA,Dec thus  means the position that would be seen by a perfect equatorial  with its polar axis aligned to the Earth's axis of rotation. Only the first character of the type argument is significant.  \"R\" or \"r\" indicates that ob1 and ob2 are the observed right  ascension and declination;  \"H\" or \"h\" indicates that they are  hour angle (west +ve) and declination;  anything else (\"A\" or  \"a\" is recommended) indicates that ob1 and ob2 are azimuth  (north zero, east 90 deg) and zenith distance. utc1+utc2 is quasi Julian Date (see Note 2), apportioned in any  convenient way between the two arguments, for example where utc1  is the Julian Day Number and utc2 is the fraction of a day. However, JD cannot unambiguously represent UTC during a leap  second unless special measures are taken.  The convention in the  present function is that the JD day represents UTC days whether  the length is 86399, 86400 or 86401 SI seconds. Applications should use the function  dtf2d  to convert from  calendar date and time of day into 2-part quasi Julian Date, as  it implements the leap-second-ambiguity convention just  described. The warning status \"dubious year\" flags UTCs that predate the  introduction of the time scale or that are too far in the  future to be trusted.  See  dat  for further details. UT1-UTC is tabulated in IERS bulletins.  It increases by exactly  one second at the end of each positive UTC leap second,  introduced in order to keep UT1-UTC within +/- 0.9s.  n.b. This  practice is under review, and in the future UT1-UTC may grow  essentially without limit. The geographical coordinates are with respect to the  WGS84   reference ellipsoid.  TAKE CARE WITH THE LONGITUDE SIGN:  the  longitude required by the present function is east-positive  (i.e. right-handed), in accordance with geographical convention. The polar motion xp,yp can be obtained from IERS bulletins.  The  values are the coordinates (in radians) of the Celestial  Intermediate Pole with respect to the International Terrestrial  Reference System (see IERS Conventions 2003), measured along the  meridians 0 and 90 deg west respectively.  For many  applications, xp and yp can be set to zero. If hm, the height above the ellipsoid of the observing station  in meters, is not known but phpa, the pressure in hPa (=mB), is  available, an adequate estimate of hm can be obtained from the  expression hm = -29.3 * tsl * log ( phpa / 1013.25 ); where tsl is the approximate sea-level air temperature in K  (See Astrophysical Quantities, C.W.Allen, 3rd edition, section  52).  Similarly, if the pressure phpa is not known, it can be  estimated from the height of the observing station, hm, as  follows: phpa = 1013.25 * exp ( -hm / ( 29.3 * tsl ) ); Note, however, that the refraction is nearly proportional to  the pressure and that an accurate phpa value is important for  precise work. The argument wl specifies the observing wavelength in  micrometers.  The transition from optical to radio is assumed to  occur at 100 micrometers (about 3000 GHz). The accuracy of the result is limited by the corrections for  refraction, which use a simple  $A*tan(z) + B*tan^3(z)$  model.  Providing the meteorological parameters are known accurately and  there are no gross local effects, the predicted astrometric  coordinates should be within 0.05 arcsec (optical) or 1 arcsec  (radio) for a zenith distance of less than 70 degrees, better  than 30 arcsec (optical or radio) at 85 degrees and better  than 20 arcmin (optical) or 30 arcmin (radio) at the horizon. Without refraction, the complementary functions  atio13  and   atoi13  are self-consistent to better than 1 microarcsecond  all over the celestial sphere.  With refraction included,  consistency falls off at high zenith distances, but is still  better than 0.05 arcsec at 85 degrees. It is advisable to take great care with units, as even unlikely  values of the input parameters are accepted and processed in  accordance with the models used. Called apio13 : astrometry parameters, CIRS-observed, 2013 atoiq : quick observed to CIRS source"},{"id":864,"pagetitle":"Functions","title":"ERFA.atoiq","ref":"/ERFA/stable/api/functions/#ERFA.atoiq-NTuple{4, Any}","content":" ERFA.atoiq  —  Method atoiq(typeofcoordinates, ob1, ob2, astrom) Quick observed place to CIRS, given the star-independent astrometry parameters. Use of this function is appropriate when efficiency is important and where many star positions are all to be transformed for one date. The star-independent astrometry parameters can be obtained by calling  apio[13]  or  apco[13] . Given type : Type of coordinates: \"R\", \"H\" or \"A\" (Note 1) ob1 : Observed Az, HA or RA (radians; Az is N=0,E=90) ob2 : Observed ZD or Dec (radians) astrom : Star-independent astrometry parameters: pmt : PM time interval (SSB, Julian years) eb : SSB to observer (vector, au) eh : Sun to observer (unit vector) em : Distance from Sun to observer (au) v : Barycentric observer velocity (vector, c) bm1 :  $\\sqrt{1-|v|^2}$  Reciprocal of Lorenz factor bpn : Bias-precession-nutation matrix along : Longitude + s' (radians) xp1 : Polar motion xp wrt local meridian (radians) yp1 : Polar motion yp wrt local meridian (radians) sphi : Sine of geodetic latitude cphi : Cosine of geodetic latitude diurab : Magnitude of diurnal aberration vector l : \"Local\" Earth rotation angle (radians) refa : Refraction constant A (radians) refb : Refraction constant B (radians) Returned ri : CIRS right ascension (CIO-based, radians) di : CIRS declination (radians) Notes \"Observed\" Az,El means the position that would be seen by a perfect geodetically aligned theodolite.  This is related to the observed HA,Dec via the standard rotation, using the geodetic latitude (corrected for polar motion), while the observed HA and RA are related simply through the Earth rotation angle and the site longitude.  \"Observed\" RA,Dec or HA,Dec thus means the position that would be seen by a perfect equatorial with its polar axis aligned to the Earth's axis of rotation.  By removing from the observed place the effects of atmospheric refraction and diurnal aberration, the CIRS RA,Dec is obtained. Only the first character of the type argument is significant. \"R\" or \"r\" indicates that ob1 and ob2 are the observed right ascension and declination;  \"H\" or \"h\" indicates that they are hour angle (west +ve) and declination;  anything else (\"A\" or \"a\" is recommended) indicates that ob1 and ob2 are azimuth (north zero, east 90 deg) and zenith distance.  (Zenith distance is used rather than altitude in order to reflect the fact that no allowance is made for depression of the horizon.) The accuracy of the result is limited by the corrections for refraction, which use a simple  $A*tan(z) + B*tan^3(z)$  model. Providing the meteorological parameters are known accurately and there are no gross local effects, the predicted observed coordinates should be within 0.05 arcsec (optical) or 1 arcsec (radio) for a zenith distance of less than 70 degrees, better than 30 arcsec (optical or radio) at 85 degrees and better than 20 arcmin (optical) or 30 arcmin (radio) at the horizon. Without refraction, the complementary functions  atioq  and  atoiq  are self-consistent to better than 1 microarcsecond all over the celestial sphere.  With refraction included, consistency falls off at high zenith distances, but is still better than 0.05 arcsec at 85 degrees. It is advisable to take great care with units, as even unlikely values of the input parameters are accepted and processed in accordance with the models used. Called s2c : spherical coordinates to unit vector c2s : p-vector to spherical anp : normalize angle into range 0 to 2pi source"},{"id":865,"pagetitle":"Functions","title":"ERFA.bi00","ref":"/ERFA/stable/api/functions/#ERFA.bi00-Tuple{}","content":" ERFA.bi00  —  Method bi00() Frame bias components of IAU 2000 precession-nutation models (part of MHB2000 with additions). Returned dpsibi ,  depsbi : Longitude and obliquity corrections dra : The ICRS RA of the J2000.0 mean equinox Notes The frame bias corrections in longitude and obliquity (radians) are required in order to correct for the offset between the GCRS pole and the mean J2000.0 pole.  They define, with respect to the GCRS frame, a J2000.0 mean pole that is consistent with the rest of the IAU 2000A precession-nutation model. In addition to the displacement of the pole, the complete description of the frame bias requires also an offset in right ascension.  This is not part of the IAU 2000A model, and is from Chapront et al. (2002).  It is returned in radians. This is a supplemented implementation of one aspect of the IAU 2000A nutation model, formally adopted by the IAU General Assembly in 2000, namely MHB2000 (Mathews et al. 2002). References Chapront, J., Chapront-Touze, M. & Francou, G., Astron.   Astrophys., 387, 700, 2002. Mathews, P.M., Herring, T.A., Buffet, B.A., \"Modeling of nutation   and precession: New nutation series for nonrigid Earth and   insights into the Earth's interior\", J.Geophys.Res., 107, B4, 2002.   The MHB2000 code itself was obtained on 9th September 2002   from ftp://maia.usno.navy.mil/conv2000/chapter5/IAU2000A. source"},{"id":866,"pagetitle":"Functions","title":"ERFA.bp00","ref":"/ERFA/stable/api/functions/#ERFA.bp00","content":" ERFA.bp00  —  Function bp00(date1, date2) Frame bias and precession, IAU 2000. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned rb : Frame bias matrix (Note 2) rp : Precession matrix (Note 3) rbp : Bias-precession matrix (Note 4) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix rb transforms vectors from GCRS to mean J2000.0 by applying frame bias. The matrix rp transforms vectors from J2000.0 mean equator and equinox to mean equator and equinox of date by applying precession. The matrix rbp transforms vectors from GCRS to mean equator and equinox of date by applying frame bias then precession.  It is the product rp x rb. It is permissible to re-use the same array in the returned arguments.  The arrays are filled in the order given. Called bi00 : frame bias components, IAU 2000 pr00 : IAU 2000 precession adjustments ir : initialize r-matrix to identity rx : rotate around X-axis ry : rotate around Y-axis rz : rotate around Z-axis cr : copy r-matrix rxr : product of two r-matrices Reference \"Expressions for the Celestial Intermediate Pole and Celestial   Ephemeris Origin consistent with the IAU 2000A precession-   nutation model\", Astron.Astrophys. 400, 1145-1154 (2003) n.b. The celestial ephemeris origin (CEO) was renamed \"celestial   intermediate origin\" (CIO) by IAU 2006 Resolution 2. source"},{"id":867,"pagetitle":"Functions","title":"ERFA.bp06","ref":"/ERFA/stable/api/functions/#ERFA.bp06","content":" ERFA.bp06  —  Function bp06(date1, date2) Frame bias and precession, IAU 2006. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned rb : Frame bias matrix (Note 2) rp : Precession matrix (Note 3) rbp : Bias-precession matrix (Note 4) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix rb transforms vectors from GCRS to mean J2000.0 by applying frame bias. The matrix rp transforms vectors from mean J2000.0 to mean of date by applying precession. The matrix rbp transforms vectors from GCRS to mean of date by applying frame bias then precession.  It is the product rp x rb. It is permissible to re-use the same array in the returned arguments.  The arrays are filled in the order given. Called pfw06 : bias-precession F-W angles, IAU 2006 fw2m : F-W angles to r-matrix pmat06 : PB matrix, IAU 2006 tr : transpose r-matrix rxr : product of two r-matrices cr : copy r-matrix References Capitaine, N. & Wallace, P.T., 2006, Astron.Astrophys. 450, 855 Wallace, P.T. & Capitaine, N., 2006, Astron.Astrophys. 459, 981 source"},{"id":868,"pagetitle":"Functions","title":"ERFA.bpn2xy","ref":"/ERFA/stable/api/functions/#ERFA.bpn2xy-Tuple{Any}","content":" ERFA.bpn2xy  —  Method bpn2xy(rbpn) Extract from the bias-precession-nutation matrix the X,Y coordinates of the Celestial Intermediate Pole. Given rbpn : Celestial-to-true matrix (Note 1) Returned x ,  y : Celestial Intermediate Pole (Note 2) Notes The matrix rbpn transforms vectors from GCRS to true equator (and CIO or equinox) of date, and therefore the Celestial Intermediate Pole unit vector is the bottom row of the matrix. The arguments x,y are components of the Celestial Intermediate Pole unit vector in the Geocentric Celestial Reference System. Reference \"Expressions for the Celestial Intermediate Pole and Celestial   Ephemeris Origin consistent with the IAU 2000A precession-   nutation model\", Astron.Astrophys. 400, 1145-1154   (2003) n.b. The celestial ephemeris origin (CEO) was renamed \"celestial   intermediate origin\" (CIO) by IAU 2006 Resolution 2. source"},{"id":869,"pagetitle":"Functions","title":"ERFA.c2i00a","ref":"/ERFA/stable/api/functions/#ERFA.c2i00a","content":" ERFA.c2i00a  —  Function c2i00a(a, b) Form the celestial-to-intermediate matrix for a given date using the IAU 2000A precession-nutation model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned rc2i : Celestial-to-intermediate matrix (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix rc2i is the first stage in the transformation from celestial to terrestrial coordinates: [TRS]  =  RPOM * R_3(ERA) * rc2i * [CRS] =  rc2t * [CRS] where [CRS] is a vector in the Geocentric Celestial Reference System and [TRS] is a vector in the International Terrestrial Reference System (see IERS Conventions 2003), ERA is the Earth Rotation Angle and RPOM is the polar motion matrix. A faster, but slightly less accurate result (about 1 mas), can be obtained by using instead the  c2i00b  function. Called pnm00a : classical NPB matrix, IAU 2000A c2ibpn : celestial-to-intermediate matrix, given NPB matrix References \"Expressions for the Celestial Intermediate Pole and Celestial   Ephemeris Origin consistent with the IAU 2000A precession-   nutation model\", Astron.Astrophys. 400, 1145-1154   (2003) n.b. The celestial ephemeris origin (CEO) was renamed \"celestial   intermediate origin\" (CIO) by IAU 2006 Resolution 2. McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":870,"pagetitle":"Functions","title":"ERFA.c2i00b","ref":"/ERFA/stable/api/functions/#ERFA.c2i00b","content":" ERFA.c2i00b  —  Function c2i00b(a, b) Form the celestial-to-intermediate matrix for a given date using the IAU 2000B precession-nutation model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned rc2i : Celestial-to-intermediate matrix (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix rc2i is the first stage in the transformation from celestial to terrestrial coordinates: [TRS]  =  RPOM * R_3(ERA) * rc2i * [CRS] =  rc2t * [CRS] where [CRS] is a vector in the Geocentric Celestial Reference System and [TRS] is a vector in the International Terrestrial Reference System (see IERS Conventions 2003), ERA is the Earth Rotation Angle and RPOM is the polar motion matrix. The present function is faster, but slightly less accurate (about 1 mas), than the  c2i00a  function. Called pnm00b : classical NPB matrix, IAU 2000B c2ibpn : celestial-to-intermediate matrix, given NPB matrix References \"Expressions for the Celestial Intermediate Pole and Celestial   Ephemeris Origin consistent with the IAU 2000A precession-   nutation model\", Astron.Astrophys. 400, 1145-1154   (2003) n.b. The celestial ephemeris origin (CEO) was renamed \"celestial   intermediate origin\" (CIO) by IAU 2006 Resolution 2. McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":871,"pagetitle":"Functions","title":"ERFA.c2i06a","ref":"/ERFA/stable/api/functions/#ERFA.c2i06a","content":" ERFA.c2i06a  —  Function c2i06a(a, b) Form the celestial-to-intermediate matrix for a given date using the IAU 2006 precession and IAU 2000A nutation models. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned rc2i : Celestial-to-intermediate matrix (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix rc2i is the first stage in the transformation from celestial to terrestrial coordinates: [TRS]  =  RPOM * R_3(ERA) * rc2i * [CRS] =  RC2T * [CRS] where [CRS] is a vector in the Geocentric Celestial Reference System and [TRS] is a vector in the International Terrestrial Reference System (see IERS Conventions 2003), ERA is the Earth Rotation Angle and RPOM is the polar motion matrix. Called pnm06a : classical NPB matrix, IAU 2006/2000A bpn2xy : extract CIP X,Y coordinates from NPB matrix s06 : the CIO locator s, given X,Y, IAU 2006 c2ixys : celestial-to-intermediate matrix, given X,Y and s References McCarthy, D. D., Petit, G. (eds.), 2004, IERS Conventions (2003),   IERS Technical Note No. 32, BKG source"},{"id":872,"pagetitle":"Functions","title":"ERFA.c2ibpn","ref":"/ERFA/stable/api/functions/#ERFA.c2ibpn-Tuple{Any, Any, Any}","content":" ERFA.c2ibpn  —  Method c2ibpn(date1, date2, rbpn) Form the celestial-to-intermediate matrix for a given date given the bias-precession-nutation matrix.  IAU 2000. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) rbpn : Celestial-to-true matrix (Note 2) Returned rc2i : Celestial-to-intermediate matrix (Note 3) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix rbpn transforms vectors from GCRS to true equator (and CIO or equinox) of date.  Only the CIP (bottom row) is used. The matrix rc2i is the first stage in the transformation from celestial to terrestrial coordinates: [TRS] = RPOM * R_3(ERA) * rc2i * [CRS] = RC2T * [CRS] where [CRS] is a vector in the Geocentric Celestial Reference System and [TRS] is a vector in the International Terrestrial Reference System (see IERS Conventions 2003), ERA is the Earth Rotation Angle and RPOM is the polar motion matrix. Although its name does not include \"00\", This function is in fact specific to the IAU 2000 models. Called bpn2xy : extract CIP X,Y coordinates from NPB matrix c2ixy : celestial-to-intermediate matrix, given X,Y References \"Expressions for the Celestial Intermediate Pole and Celestial   Ephemeris Origin consistent with the IAU 2000A precession-   nutation model\", Astron.Astrophys. 400, 1145-1154 (2003) n.b. The celestial ephemeris origin (CEO) was renamed \"celestial   intermediate origin\" (CIO) by IAU 2006 Resolution 2. McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":873,"pagetitle":"Functions","title":"ERFA.c2ixy","ref":"/ERFA/stable/api/functions/#ERFA.c2ixy-NTuple{4, Any}","content":" ERFA.c2ixy  —  Method c2ixy(x, y, s, t) Form the celestial to intermediate-frame-of-date matrix for a given date when the CIP X,Y coordinates are known.  IAU 2000. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) x ,  y : Celestial Intermediate Pole (Note 2) Returned rc2i : Celestial-to-intermediate matrix (Note 3) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The Celestial Intermediate Pole coordinates are the x,y components of the unit vector in the Geocentric Celestial Reference System. The matrix rc2i is the first stage in the transformation from celestial to terrestrial coordinates: [TRS] = RPOM * R_3(ERA) * rc2i * [CRS] = RC2T * [CRS] where [CRS] is a vector in the Geocentric Celestial Reference System and [TRS] is a vector in the International Terrestrial Reference System (see IERS Conventions 2003), ERA is the Earth Rotation Angle and RPOM is the polar motion matrix. Although its name does not include \"00\", This function is in fact specific to the IAU 2000 models. Called c2ixys : celestial-to-intermediate matrix, given X,Y and s s00 : the CIO locator s, given X,Y, IAU 2000A Reference McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":874,"pagetitle":"Functions","title":"ERFA.c2ixys","ref":"/ERFA/stable/api/functions/#ERFA.c2ixys-Tuple{Any, Any, Any}","content":" ERFA.c2ixys  —  Method c2ixys(x, y, s) Form the celestial to intermediate-frame-of-date matrix given the CIP X,Y and the CIO locator s. Given x ,  y : Celestial Intermediate Pole (Note 1) s : The CIO locator s (Note 2) Returned rc2i : Celestial-to-intermediate matrix (Note 3) Notes The Celestial Intermediate Pole coordinates are the x,y components of the unit vector in the Geocentric Celestial Reference System. The CIO locator s (in radians) positions the Celestial Intermediate Origin on the equator of the CIP. The matrix rc2i is the first stage in the transformation from celestial to terrestrial coordinates: [TRS] = RPOM * R_3(ERA) * rc2i * [CRS] = RC2T * [CRS] where [CRS] is a vector in the Geocentric Celestial Reference System and [TRS] is a vector in the International Terrestrial Reference System (see IERS Conventions 2003), ERA is the Earth Rotation Angle and RPOM is the polar motion matrix. Called ir : initialize r-matrix to identity rz : rotate around Z-axis ry : rotate around Y-axis Reference McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":875,"pagetitle":"Functions","title":"ERFA.c2s","ref":"/ERFA/stable/api/functions/#ERFA.c2s-Tuple{Any}","content":" ERFA.c2s  —  Method c2s(p) P-vector to spherical coordinates. Given p : P-vector Returned theta : Longitude angle (radians) phi : Latitude angle (radians) Notes The vector p can have any magnitude; only its direction is used. If p is null, zero theta and phi are returned. At either pole, zero theta is returned. source"},{"id":876,"pagetitle":"Functions","title":"ERFA.c2t00a","ref":"/ERFA/stable/api/functions/#ERFA.c2t00a","content":" ERFA.c2t00a  —  Function c2t00a(tta, ttb, uta, utb, xp, yp) Form the celestial to terrestrial matrix given the date, the UT1 and the polar motion, using the IAU 2000A nutation model. Given tta ,  ttb : TT as a 2-part Julian Date (Note 1) uta ,  utb : UT1 as a 2-part Julian Date (Note 1) xp ,  yp : Coordinates of the pole (radians, Note 2) Returned rc2t : Celestial-to-terrestrial matrix (Note 3) Notes The TT and UT1 dates tta+ttb and uta+utb are Julian Dates, apportioned in any convenient way between the arguments uta and utb.  For example, JD(UT1)=2450123.7 could be expressed in any of these ways, among others: uta utb Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 and MJD methods are good compromises between resolution and convenience.  In the case of uta,utb, the date & time method is best matched to the Earth rotation angle algorithm used:  maximum precision is delivered when the uta argument is for 0hrs UT1 on the day in question and the utb argument lies in the range 0 to 1, or vice versa. The arguments xp and yp are the coordinates (in radians) of the Celestial Intermediate Pole with respect to the International Terrestrial Reference System (see IERS Conventions 2003), measured along the meridians to 0 and 90 deg west respectively. The matrix rc2t transforms from celestial to terrestrial coordinates: [TRS] = RPOM * R_3(ERA) * RC2I * [CRS] = rc2t * [CRS] where [CRS] is a vector in the Geocentric Celestial Reference System and [TRS] is a vector in the International Terrestrial Reference System (see IERS Conventions 2003), RC2I is the celestial-to-intermediate matrix, ERA is the Earth rotation angle and RPOM is the polar motion matrix. A faster, but slightly less accurate result (about 1 mas), can be obtained by using instead the  c2t00b  function. Called c2i00a : celestial-to-intermediate matrix, IAU 2000A era00 : Earth rotation angle, IAU 2000 sp00 : the TIO locator s', IERS 2000 pom00 : polar motion matrix c2tcio : form CIO-based celestial-to-terrestrial matrix Reference McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":877,"pagetitle":"Functions","title":"ERFA.c2t00b","ref":"/ERFA/stable/api/functions/#ERFA.c2t00b","content":" ERFA.c2t00b  —  Function c2t00b(tta, ttb, uta, utb, xp, yp) Form the celestial to terrestrial matrix given the date, the UT1 and the polar motion, using the IAU 2000B nutation model. Given tta ,  ttb : TT as a 2-part Julian Date (Note 1) uta ,  utb : UT1 as a 2-part Julian Date (Note 1) xp ,  yp : Coordinates of the pole (radians, Note 2) Returned rc2t : Celestial-to-terrestrial matrix (Note 3) Notes The TT and UT1 dates tta+ttb and uta+utb are Julian Dates, apportioned in any convenient way between the arguments uta and utb.  For example, JD(UT1)=2450123.7 could be expressed in any of these ways, among others: uta utb Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 and MJD methods are good compromises between resolution and convenience.  In the case of uta,utb, the date & time method is best matched to the Earth rotation angle algorithm used:  maximum precision is delivered when the uta argument is for 0hrs UT1 on the day in question and the utb argument lies in the range 0 to 1, or vice versa. The arguments xp and yp are the coordinates (in radians) of the Celestial Intermediate Pole with respect to the International Terrestrial Reference System (see IERS Conventions 2003), measured along the meridians to 0 and 90 deg west respectively. The matrix rc2t transforms from celestial to terrestrial coordinates: [TRS] = RPOM * R_3(ERA) * RC2I * [CRS] = rc2t * [CRS] where [CRS] is a vector in the Geocentric Celestial Reference System and [TRS] is a vector in the International Terrestrial Reference System (see IERS Conventions 2003), RC2I is the celestial-to-intermediate matrix, ERA is the Earth rotation angle and RPOM is the polar motion matrix. The present function is faster, but slightly less accurate (about 1 mas), than the  c2t00a  function. Called c2i00b : celestial-to-intermediate matrix, IAU 2000B era00 : Earth rotation angle, IAU 2000 pom00 : polar motion matrix c2tcio : form CIO-based celestial-to-terrestrial matrix Reference McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":878,"pagetitle":"Functions","title":"ERFA.c2t06a","ref":"/ERFA/stable/api/functions/#ERFA.c2t06a","content":" ERFA.c2t06a  —  Function c2t06a(tta, ttb, uta, utb, xp, yp) Form the celestial to terrestrial matrix given the date, the UT1 and the polar motion, using the IAU 2006 precession and IAU 2000A nutation models. Given tta ,  ttb : TT as a 2-part Julian Date (Note 1) uta ,  utb : UT1 as a 2-part Julian Date (Note 1) xp ,  yp : Coordinates of the pole (radians, Note 2) Returned rc2t : Celestial-to-terrestrial matrix (Note 3) Notes The TT and UT1 dates tta+ttb and uta+utb are Julian Dates, apportioned in any convenient way between the arguments uta and utb.  For example, JD(UT1)=2450123.7 could be expressed in any of these ways, among others: uta utb Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 and MJD methods are good compromises between resolution and convenience.  In the case of uta,utb, the date & time method is best matched to the Earth rotation angle algorithm used:  maximum precision is delivered when the uta argument is for 0hrs UT1 on the day in question and the utb argument lies in the range 0 to 1, or vice versa. The arguments xp and yp are the coordinates (in radians) of the Celestial Intermediate Pole with respect to the International Terrestrial Reference System (see IERS Conventions 2003), measured along the meridians to 0 and 90 deg west respectively. The matrix rc2t transforms from celestial to terrestrial coordinates: [TRS] = RPOM * R_3(ERA) * RC2I * [CRS] = rc2t * [CRS] where [CRS] is a vector in the Geocentric Celestial Reference System and [TRS] is a vector in the International Terrestrial Reference System (see IERS Conventions 2003), RC2I is the celestial-to-intermediate matrix, ERA is the Earth rotation angle and RPOM is the polar motion matrix. Called c2i06a : celestial-to-intermediate matrix, IAU 2006/2000A era00 : Earth rotation angle, IAU 2000 sp00 : the TIO locator s', IERS 2000 pom00 : polar motion matrix c2tcio : form CIO-based celestial-to-terrestrial matrix Reference McCarthy, D. D., Petit, G. (eds.), 2004, IERS Conventions (2003),   IERS Technical Note No. 32, BKG source"},{"id":879,"pagetitle":"Functions","title":"ERFA.c2tcio","ref":"/ERFA/stable/api/functions/#ERFA.c2tcio","content":" ERFA.c2tcio  —  Function c2tcio(rc2i, era, rpom) Assemble the celestial to terrestrial matrix from CIO-based components (the celestial-to-intermediate matrix, the Earth Rotation Angle and the polar motion matrix). Given rc2i : Celestial-to-intermediate matrix era : Earth rotation angle (radians) rpom : Polar-motion matrix Returned rc2t : Celestial-to-terrestrial matrix Notes This function constructs the rotation matrix that transforms vectors in the celestial system into vectors in the terrestrial system.  It does so starting from precomputed components, namely the matrix which rotates from celestial coordinates to the intermediate frame, the Earth rotation angle and the polar motion matrix.  One use of the present function is when generating a series of celestial-to-terrestrial matrices where only the Earth Rotation Angle changes, avoiding the considerable overhead of recomputing the precession-nutation more often than necessary to achieve given accuracy objectives. The relationship between the arguments is as follows: [TRS] = RPOM * R_3(ERA) * rc2i * [CRS] = rc2t * [CRS] where [CRS] is a vector in the Geocentric Celestial Reference System and [TRS] is a vector in the International Terrestrial Reference System (see IERS Conventions 2003). Called cr : copy r-matrix rz : rotate around Z-axis rxr : product of two r-matrices Reference McCarthy, D. D., Petit, G. (eds.), 2004, IERS Conventions (2003),   IERS Technical Note No. 32, BKG source"},{"id":880,"pagetitle":"Functions","title":"ERFA.c2teqx","ref":"/ERFA/stable/api/functions/#ERFA.c2teqx","content":" ERFA.c2teqx  —  Function c2teqx(rc2i, era, rpom) Assemble the celestial to terrestrial matrix from equinox-based components (the celestial-to-true matrix, the Greenwich Apparent Sidereal Time and the polar motion matrix). Given rbpn : Celestial-to-true matrix gst : Greenwich (apparent) Sidereal Time (radians) rpom : Polar-motion matrix Returned rc2t : Celestial-to-terrestrial matrix (Note 2) Notes This function constructs the rotation matrix that transforms vectors in the celestial system into vectors in the terrestrial system.  It does so starting from precomputed components, namely the matrix which rotates from celestial coordinates to the true equator and equinox of date, the Greenwich Apparent Sidereal Time and the polar motion matrix.  One use of the present function is when generating a series of celestial-to-terrestrial matrices where only the Sidereal Time changes, avoiding the considerable overhead of recomputing the precession-nutation more often than necessary to achieve given accuracy objectives. The relationship between the arguments is as follows: [TRS] = rpom * R_3(gst) * rbpn * [CRS] = rc2t * [CRS] where [CRS] is a vector in the Geocentric Celestial Reference System and [TRS] is a vector in the International Terrestrial Reference System (see IERS Conventions 2003). Called cr : copy r-matrix rz : rotate around Z-axis rxr : product of two r-matrices Reference McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":881,"pagetitle":"Functions","title":"ERFA.c2tpe","ref":"/ERFA/stable/api/functions/#ERFA.c2tpe","content":" ERFA.c2tpe  —  Function c2tpe(tta, ttb, uta, utb, x, y, xp, yp) Form the celestial to terrestrial matrix given the date, the UT1, the nutation and the polar motion.  IAU 2000. Given tta ,  ttb : TT as a 2-part Julian Date (Note 1) uta ,  utb : UT1 as a 2-part Julian Date (Note 1) dpsi ,  deps : Nutation (Note 2) xp ,  yp : Coordinates of the pole (radians, Note 3) Returned rc2t : Celestial-to-terrestrial matrix (Note 4) Notes The TT and UT1 dates tta+ttb and uta+utb are Julian Dates, apportioned in any convenient way between the arguments uta and utb.  For example, JD(UT1)=2450123.7 could be expressed in any of these ways, among others: uta utb Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 and MJD methods are good compromises between resolution and convenience.  In the case of uta,utb, the date & time method is best matched to the Earth rotation angle algorithm used:  maximum precision is delivered when the uta argument is for 0hrs UT1 on the day in question and the utb argument lies in the range 0 to 1, or vice versa. The caller is responsible for providing the nutation components; they are in longitude and obliquity, in radians and are with respect to the equinox and ecliptic of date.  For high-accuracy applications, free core nutation should be included as well as any other relevant corrections to the position of the CIP. The arguments xp and yp are the coordinates (in radians) of the Celestial Intermediate Pole with respect to the International Terrestrial Reference System (see IERS Conventions 2003), measured along the meridians to 0 and 90 deg west respectively. The matrix rc2t transforms from celestial to terrestrial coordinates: [TRS] = RPOM * R_3(GST) * RBPN * [CRS] = rc2t * [CRS] where [CRS] is a vector in the Geocentric Celestial Reference System and [TRS] is a vector in the International Terrestrial Reference System (see IERS Conventions 2003), RBPN is the bias-precession-nutation matrix, GST is the Greenwich (apparent) Sidereal Time and RPOM is the polar motion matrix. Although its name does not include \"00\", This function is in fact specific to the IAU 2000 models. Called pn00 : bias/precession/nutation results, IAU 2000 gmst00 : Greenwich mean sidereal time, IAU 2000 sp00 : the TIO locator s', IERS 2000 ee00 : equation of the equinoxes, IAU 2000 pom00 : polar motion matrix c2teqx : form equinox-based celestial-to-terrestrial matrix Reference McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":882,"pagetitle":"Functions","title":"ERFA.c2txy","ref":"/ERFA/stable/api/functions/#ERFA.c2txy","content":" ERFA.c2txy  —  Function c2txy(tta, ttb, uta, utb, x, y, xp, yp) Form the celestial to terrestrial matrix given the date, the UT1, the CIP coordinates and the polar motion.  IAU 2000. Given tta ,  ttb : TT as a 2-part Julian Date (Note 1) uta ,  utb : UT1 as a 2-part Julian Date (Note 1) x ,  y : Celestial Intermediate Pole (Note 2) xp ,  yp : Coordinates of the pole (radians, Note 3) Returned rc2t : Celestial-to-terrestrial matrix (Note 4) Notes The TT and UT1 dates tta+ttb and uta+utb are Julian Dates, apportioned in any convenient way between the arguments uta and utb.  For example, JD(UT1)=2450123.7 could be expressed in any o these ways, among others: uta utb Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 and MJD methods are good compromises between resolution and convenience.  In the case of uta,utb, the date & time method is best matched to the Earth rotation angle algorithm used:  maximum precision is delivered when the uta argument is for 0hrs UT1 on the day in question and the utb argument lies in the range 0 to 1, or vice versa. The Celestial Intermediate Pole coordinates are the x,y components of the unit vector in the Geocentric Celestial Reference System. The arguments xp and yp are the coordinates (in radians) of the Celestial Intermediate Pole with respect to the International Terrestrial Reference System (see IERS Conventions 2003), measured along the meridians to 0 and 90 deg west respectively. The matrix rc2t transforms from celestial to terrestrial coordinates: [TRS] = RPOM * R_3(ERA) * RC2I * [CRS] = rc2t * [CRS] where [CRS] is a vector in the Geocentric Celestial Reference System and [TRS] is a vector in the International Terrestrial Reference System (see IERS Conventions 2003), ERA is the Earth Rotation Angle and RPOM is the polar motion matrix. Although its name does not include \"00\", This function is in fact specific to the IAU 2000 models. Called c2ixy : celestial-to-intermediate matrix, given X,Y era00 : Earth rotation angle, IAU 2000 sp00 : the TIO locator s', IERS 2000 pom00 : polar motion matrix c2tcio : form CIO-based celestial-to-terrestrial matrix Reference McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":883,"pagetitle":"Functions","title":"ERFA.cal2jd","ref":"/ERFA/stable/api/functions/#ERFA.cal2jd-Tuple{Any, Any, Any}","content":" ERFA.cal2jd  —  Method cal2jd(iy, imo, id) Gregorian Calendar to Julian Date. Given iy ,  im ,  id : Year, month, day in Gregorian calendar (Note 1) Returned djm0 : MJD zero-point: always 2400000.5 djm : Modified Julian Date for 0 hrs Notes The algorithm used is valid from -4800 March 1, but this implementation rejects dates before -4799 January 1. The Julian Date is returned in two pieces, in the usual ERFA manner, which is designed to preserve time resolution.  The Julian Date is available as a single number by adding djm0 and djm. In early eras the conversion is from the \"Proleptic Gregorian Calendar\";  no account is taken of the date(s) of adoption of the Gregorian Calendar, nor is the AD/BC numbering convention observed. Reference Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992),   Section 12.92 (p604). source"},{"id":884,"pagetitle":"Functions","title":"ERFA.cpv","ref":"/ERFA/stable/api/functions/#ERFA.cpv","content":" ERFA.cpv  —  Function cpv(pv) Copy a position/velocity vector. Deprecated Use  Base.deepcopy  instead. Given pv : position/velocity vector to be copied Returned c : copy source"},{"id":885,"pagetitle":"Functions","title":"ERFA.cr","ref":"/ERFA/stable/api/functions/#ERFA.cr","content":" ERFA.cr  —  Function cr(p) Copy an r-vector. Deprecated Use  Base.copy  instead. Given r : r-matrix to be copied Returned c : copy source"},{"id":886,"pagetitle":"Functions","title":"ERFA.d2dtf","ref":"/ERFA/stable/api/functions/#ERFA.d2dtf-Tuple{AbstractString, Any, Any, Any}","content":" ERFA.d2dtf  —  Method d2dtf(scale, ndp, d1, d2) Format for output a 2-part Julian Date (or in the case of UTC a quasi-JD form that includes special provision for leap seconds). Given scale : Time scale ID (Note 1) ndp : Resolution (Note 2) d1 ,  d2 : Time as a 2-part Julian Date (Notes 3,4) Returned iy ,  im ,  id : Year, month, day in Gregorian calendar (Note 5) ihmsf : Hours, minutes, seconds, fraction (Note 1) Notes scale identifies the time scale.  Only the value \"UTC\" (in upper case) is significant, and enables handling of leap seconds (see Note 4). ndp is the number of decimal places in the seconds field, and can have negative as well as positive values, such as: ndp resolution -4 1 00 00 -3 0 10 00 -2 0 01 00 -1 0 00 10 0 0 00 01 1 0 00 00.1 2 0 00 00.01 3 0 00 00.001 The limits are platform dependent, but a safe range is -5 to +9. d1+d2 is Julian Date, apportioned in any convenient way between the two arguments, for example where d1 is the Julian Day Number and d2 is the fraction of a day.  In the case of UTC, where the use of JD is problematical, special conventions apply:  see the next note. JD cannot unambiguously represent UTC during a leap second unless special measures are taken.  The ERFA internal convention is that the quasi-JD day represents UTC days whether the length is 86399, 86400 or 86401 SI seconds.  In the 1960-1972 era there were smaller jumps (in either direction) each time the linear UTC(TAI) expression was changed, and these \"mini-leaps\" are also included in the ERFA convention. The warning status \"dubious year\" flags UTCs that predate the introduction of the time scale or that are too far in the future to be trusted.  See  dat  for further details. For calendar conventions and limitations, see  cal2jd . Called jd2cal : JD to Gregorian calendar d2tf : decompose days to hms dat : delta(AT) = TAI-UTC source"},{"id":887,"pagetitle":"Functions","title":"ERFA.d2tf","ref":"/ERFA/stable/api/functions/#ERFA.d2tf-Tuple{Any, Any}","content":" ERFA.d2tf  —  Method d2tf(ndp, a) Decompose days to hours, minutes, seconds, fraction. Given ndp : Resolution (Note 1) days : Interval in days Returned sign : '+' or '-' ihmsf : Hours, minutes, seconds, fraction Notes The argument ndp is interpreted as follows: ndp resolution : ...0000 00 00 -7 1000 00 00 -6 100 00 00 -5 10 00 00 -4 1 00 00 -3 0 10 00 -2 0 01 00 -1 0 00 10 0 0 00 01 1 0 00 00.1 2 0 00 00.01 3 0 00 00.001 : 0 00 00.000... The largest positive useful value for ndp is determined by the size of days, the format of double on the target platform, and the risk of overflowing ihmsf[3].  On a typical platform, for days up to 1.0, the available floating-point precision might correspond to ndp=12.  However, the practical limit is typically ndp=9, set by the capacity of a 32-bit int, or ndp=4 if int is only 16 bits. The absolute value of days may exceed 1.0.  In cases where it does not, it is up to the caller to test for and handle the case where days is very nearly 1.0 and rounds up to 24 hours, by testing for ihmsf[0]=24 and setting ihmsf[0-3] to zero. source"},{"id":888,"pagetitle":"Functions","title":"ERFA.dat","ref":"/ERFA/stable/api/functions/#ERFA.dat-NTuple{4, Any}","content":" ERFA.dat  —  Method dat(iy, im, id, fd) For a given UTC date, calculate delta(AT) = TAI-UTC. IMPORTANT A new version of this function must be produced whenever a new leap second is announced.  There are four items to change on each such occasion: A new line must be added to the set  of statements that initialize the  array \"changes\". The constant IYV must be set to the  current year. The \"Latest leap second\" comment  below must be set to the new leap  second date. The \"This revision\" comment, later,  must be set to the current date. Change (2) must also be carried out whenever the function is re-issued, even if no leap seconds have been added. Latest leap second:  2016 December 31 Given iy : UTC:  year (Notes 1 and 2) im : Month (Note 2) id : Day (Notes 2 and 3) fd : Fraction of day (Note 4) Returned deltat : TAI minus UTC, seconds Notes UTC began at 1960 January 1.0 (JD 2436934.5) and it is improper to call the function with an earlier date.  If this is attempted, zero is returned together with a warning status. Because leap seconds cannot, in principle, be predicted in advance, a reliable check for dates beyond the valid range is impossible.  To guard against gross errors, a year five or more after the release year of the present function (see the constant IYV) is considered dubious.  In this case a warning status is returned but the result is computed in the normal way. For both too-early and too-late years, the warning status is +1. This is distinct from the error status -1, which signifies a year so early that JD could not be computed. If the specified date is for a day which ends with a leap second, the TAI-UTC value returned is for the period leading up to the leap second.  If the date is for a day which begins as a leap second ends, the TAI-UTC returned is for the period following the leap second. The day number must be in the normal calendar range, for example 1 through 30 for April.  The \"almanac\" convention of allowing such dates as January 0 and December 32 is not supported in this function, in order to avoid confusion near leap seconds. The fraction of day is used only for dates before the introduction of leap seconds, the first of which occurred at the end of 1971.  It is tested for validity (0 to 1 is the valid range) even if not used;  if invalid, zero is used and status -4 is returned.  For many applications, setting fd to zero is acceptable;  the resulting error is always less than 3 ms (and occurs only pre-1972). The status value returned in the case where there are multiple errors refers to the first error detected.  For example, if the month and day are 13 and 32 respectively, status -2 (bad month) will be returned.  The \"internal error\" status refers to a case that is impossible but causes some compilers to issue a warning. In cases where a valid result is not available, zero is returned. References For dates from 1961 January 1 onwards, the expressions from the file ftp://maia.usno.navy.mil/ser7/tai-utc.dat are used. The 5ms timestep at 1961 January 1 is taken from 2.58.1 (p87) of the 1992 Explanatory Supplement. Called cal2jd : Gregorian calendar to JD source"},{"id":889,"pagetitle":"Functions","title":"ERFA.dtdb","ref":"/ERFA/stable/api/functions/#ERFA.dtdb-NTuple{6, Any}","content":" ERFA.dtdb  —  Method dtdb(date1, date2, ut, elong, u, v) An approximation to TDB-TT, the difference between barycentric dynamical time and terrestrial time, for an observer on the Earth. The different time scales - proper, coordinate and realized - are related to each other:           TAI             <-  physically realized\n           :\n        offset            <-  observed (nominally +32.184s)\n           :\n          TT              <-  terrestrial time\n           :\n  rate adjustment (L_G)   <-  definition of TT\n           :\n          TCG             <-  time scale for GCRS\n           :\n    \"periodic\" terms      <-  [`dtdb`](@ref)  is an implementation\n           :\n  rate adjustment (L_C)   <-  function of solar-system ephemeris\n           :\n          TCB             <-  time scale for BCRS\n           :\n  rate adjustment (-L_B)  <-  definition of TDB\n           :\n          TDB             <-  TCB scaled to track TT\n           :\n    \"periodic\" terms      <-  -eraDtdb is an approximation\n           :\n          TT              <-  terrestrial time Adopted values for the various constants can be found in the IERS Conventions (McCarthy & Petit 2003). Given date1 ,  date2 : Date, TDB (Notes 1-3) ut : Universal time (UT1, fraction of one day) elong : Longitude (east positive, radians) u : Distance from Earth spin axis (km) v : Distance north of equatorial plane (km) Returned TDB-TT (seconds) Notes The date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. Although the date is, formally, barycentric dynamical time (TDB), the terrestrial dynamical time (TT) can be used with no practical effect on the accuracy of the prediction. TT can be regarded as a coordinate time that is realized as an offset of 32.184s from International Atomic Time, TAI.  TT is a specific linear transformation of geocentric coordinate time TCG, which is the time scale for the Geocentric Celestial Reference System, GCRS. TDB is a coordinate time, and is a specific linear transformation of barycentric coordinate time TCB, which is the time scale for the Barycentric Celestial Reference System, BCRS. The difference TCG-TCB depends on the masses and positions of the bodies of the solar system and the velocity of the Earth.  It is dominated by a rate difference, the residual being of a periodic character.  The latter, which is modeled by the present function, comprises a main (annual) sinusoidal term of amplitude approximately 0.00166 seconds, plus planetary terms up to about 20 microseconds, and lunar and diurnal terms up to 2 microseconds. These effects come from the changing transverse Doppler effect and gravitational red-shift as the observer (on the Earth's surface) experiences variations in speed (with respect to the BCRS) and gravitational potential. TDB can be regarded as the same as TCB but with a rate adjustment to keep it close to TT, which is convenient for many applications. The history of successive attempts to define TDB is set out in Resolution 3 adopted by the IAU General Assembly in 2006, which defines a fixed TDB(TCB) transformation that is consistent with contemporary solar-system ephemerides.  Future ephemerides will imply slightly changed transformations between TCG and TCB, which could introduce a linear drift between TDB and TT;  however, any such drift is unlikely to exceed 1 nanosecond per century. The geocentric TDB-TT model used in the present function is that of Fairhead & Bretagnon (1990), in its full form.  It was originally supplied by Fairhead (private communications with P.T.Wallace, 1990) as a Fortran subroutine.  The present C function contains an adaptation of the Fairhead code.  The numerical results are essentially unaffected by the changes, the differences with respect to the Fairhead & Bretagnon original being at the 1e-20 s level. The topocentric part of the model is from Moyer (1981) and Murray (1983), with fundamental arguments adapted from Simon et al. 1994.  It is an approximation to the expression ( v / c ) . ( r / c ), where v is the barycentric velocity of the Earth, r is the geocentric position of the observer and c is the speed of light. By supplying zeroes for u and v, the topocentric part of the model can be nullified, and the function will return the Fairhead & Bretagnon result alone. During the interval 1950-2050, the absolute accuracy is better than +/- 3 nanoseconds relative to time ephemerides obtained by direct numerical integrations based on the JPL DE405 solar system ephemeris. It must be stressed that the present function is merely a model, and that numerical integration of solar-system ephemerides is the definitive method for predicting the relationship between TCG and TCB and hence between TT and TDB. References Fairhead, L., & Bretagnon, P., Astron.Astrophys., 229, 240-247   (1990). IAU 2006 Resolution 3. McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Moyer, T.D., Cel.Mech., 23, 33 (1981). Murray, C.A., Vectorial Astrometry, Adam Hilger (1983). Seidelmann, P.K. et al., Explanatory Supplement to the   Astronomical Almanac, Chapter 2, University Science Books (1992). Simon, J.L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G. & Laskar, J., Astron.Astrophys., 282, 663-683 (1994). source"},{"id":890,"pagetitle":"Functions","title":"ERFA.dtf2d","ref":"/ERFA/stable/api/functions/#ERFA.dtf2d-Tuple{AbstractString, Vararg{Any, 6}}","content":" ERFA.dtf2d  —  Method dtf2d(scale, iy, imo, id, ih, imi, sec) Encode date and time fields into 2-part Julian Date (or in the case of UTC a quasi-JD form that includes special provision for leap seconds). Given scale : Time scale ID (Note 1) iy ,  im ,  id : Year, month, day in Gregorian calendar (Note 2) ihr ,  imn : Hour, minute sec : Seconds Returned d1 ,  d2 : 2-part Julian Date (Notes 3,4) Notes scale identifies the time scale.  Only the value \"UTC\" (in upper case) is significant, and enables handling of leap seconds (see Note 4). For calendar conventions and limitations, see  cal2jd . The sum of the results, d1+d2, is Julian Date, where normally d1 is the Julian Day Number and d2 is the fraction of a day.  In the case of UTC, where the use of JD is problematical, special conventions apply:  see the next note. JD cannot unambiguously represent UTC during a leap second unless special measures are taken.  The ERFA internal convention is that the quasi-JD day represents UTC days whether the length is 86399, 86400 or 86401 SI seconds.  In the 1960-1972 era there were smaller jumps (in either direction) each time the linear UTC(TAI) expression was changed, and these \"mini-leaps\" are also included in the ERFA convention. The warning status \"time is after end of day\" usually means that the sec argument is greater than 60.0.  However, in a day ending in a leap second the limit changes to 61.0 (or 59.0 in the case of a negative leap second). The warning status \"dubious year\" flags UTCs that predate the introduction of the time scale or that are too far in the future to be trusted.  See  dat  for further details. Only in the case of continuous and regular time scales (TAI, TT, TCG, TCB and TDB) is the result d1+d2 a Julian Date, strictly speaking.  In the other cases (UT1 and UTC) the result must be used with circumspection;  in particular the difference between two such results cannot be interpreted as a precise time interval. Called cal2jd : Gregorian calendar to JD dat : delta(AT) = TAI-UTC jd2cal : JD to Gregorian calendar source"},{"id":891,"pagetitle":"Functions","title":"ERFA.eceq06","ref":"/ERFA/stable/api/functions/#ERFA.eceq06","content":" ERFA.eceq06  —  Function eceq06(date1, date2, dl, db) Transformation from ecliptic coordinates (mean equinox and ecliptic of date) to ICRS RA,Dec, using the IAU 2006 precession model. Given date1 ,  date2 : TT as a 2-part Julian date (Note 1) dl ,  db : Ecliptic longitude and latitude (radians) Returned dr ,  dd : ICRS right ascension and declination (radians) The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. No assumptions are made about whether the coordinates represent starlight and embody astrometric effects such as parallax or aberration. The transformation is approximately that from ecliptic longitude and latitude (mean equinox and ecliptic of date) to mean J2000.0 right ascension and declination, with only frame bias (always less than 25 mas) to disturb this classical picture. Called s2c : spherical coordinates to unit vector ecm06 : J2000.0 to ecliptic rotation matrix, IAU 2006 trxp : product of transpose of r-matrix and p-vector c2s : unit vector to spherical coordinates anp : normalize angle into range 0 to 2pi anpm : normalize angle into range +/- pi source"},{"id":892,"pagetitle":"Functions","title":"ERFA.ecm06","ref":"/ERFA/stable/api/functions/#ERFA.ecm06-Tuple{Any, Any}","content":" ERFA.ecm06  —  Method ecm06(date1, date2) ICRS equatorial to ecliptic rotation matrix, IAU 2006. Given date1 ,  date2 : TT as a 2-part Julian date (Note 1) Returned rm : ICRS to ecliptic rotation matrix Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix is in the sense E_ep = rm x P_ICRS, where  P_ICRS  is a vector with respect to ICRS right ascension and declination axes and  E_ep  is the same vector with respect to the (inertial) ecliptic and equinox of date. P_ICRS  is a free vector, merely a direction, typically of unit magnitude, and not bound to any particular spatial origin, such as the Earth, Sun or SSB.  No assumptions are made about whether it represents starlight and embodies astrometric effects such as parallax or aberration.  The transformation is approximately that between mean J2000.0 right ascension and declination and ecliptic longitude and latitude, with only frame bias (always less than 25 mas) to disturb this classical picture. Called obl06 : mean obliquity, IAU 2006 pmat06 : PB matrix, IAU 2006 ir : initialize r-matrix to identity rx : rotate around X-axis rxr : product of two r-matrices source"},{"id":893,"pagetitle":"Functions","title":"ERFA.ee00","ref":"/ERFA/stable/api/functions/#ERFA.ee00-NTuple{4, Any}","content":" ERFA.ee00  —  Method ee00(date1, date2, epsa, dpsi) The equation of the equinoxes, compatible with IAU 2000 resolutions, given the nutation in longitude and the mean obliquity. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) epsa : Mean obliquity (Note 2) dpsi : Nutation in longitude (Note 3) Returned Equation of the equinoxes (Note 4) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The obliquity, in radians, is mean of date. The result, which is in radians, operates in the following sense: Greenwich apparent ST = GMST + equation of the equinoxes The result is compatible with the IAU 2000 resolutions.  For further details, see IERS Conventions 2003 and Capitaine et al. (2002). Called eect00 : equation of the equinoxes complementary terms References Capitaine, N., Wallace, P.T. and McCarthy, D.D., \"Expressions to   implement the IAU 2000 definition of UT1\", Astronomy &   Astrophysics, 406, 1135-1149 (2003) McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":894,"pagetitle":"Functions","title":"ERFA.ee00a","ref":"/ERFA/stable/api/functions/#ERFA.ee00a","content":" ERFA.ee00a  —  Function ee00a(dj1, dj2) Equation of the equinoxes, compatible with IAU 2000 resolutions. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned Equation of the equinoxes (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The result, which is in radians, operates in the following sense: Greenwich apparent ST = GMST + equation of the equinoxes The result is compatible with the IAU 2000 resolutions.  For further details, see IERS Conventions 2003 and Capitaine et al. (2002). Called pr00 : IAU 2000 precession adjustments obl80 : mean obliquity, IAU 1980 nut00a : nutation, IAU 2000A ee00 : equation of the equinoxes, IAU 2000 References Capitaine, N., Wallace, P.T. and McCarthy, D.D., \"Expressions to   implement the IAU 2000 definition of UT1\", Astronomy &   Astrophysics, 406, 1135-1149 (2003). McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004). source"},{"id":895,"pagetitle":"Functions","title":"ERFA.ee00b","ref":"/ERFA/stable/api/functions/#ERFA.ee00b","content":" ERFA.ee00b  —  Function ee00b(dj1, dj2) Equation of the equinoxes, compatible with IAU 2000 resolutions but using the truncated nutation model IAU 2000B. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned Equation of the equinoxes (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The result, which is in radians, operates in the following sense: Greenwich apparent ST = GMST + equation of the equinoxes The result is compatible with the IAU 2000 resolutions except that accuracy has been compromised for the sake of speed.  For further details, see McCarthy & Luzum (2001), IERS Conventions 2003 and Capitaine et al. (2003). Called pr00 : IAU 2000 precession adjustments obl80 : mean obliquity, IAU 1980 nut00b : nutation, IAU 2000B ee00 : equation of the equinoxes, IAU 2000 References Capitaine, N., Wallace, P.T. and McCarthy, D.D., \"Expressions to   implement the IAU 2000 definition of UT1\", Astronomy &   Astrophysics, 406, 1135-1149 (2003) McCarthy, D.D. & Luzum, B.J., \"An abridged model of the   precession-nutation of the celestial pole\", Celestial Mechanics &   Dynamical Astronomy, 85, 37-49 (2003) McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":896,"pagetitle":"Functions","title":"ERFA.ee06a","ref":"/ERFA/stable/api/functions/#ERFA.ee06a","content":" ERFA.ee06a  —  Function ee06a(dj1, dj2) Equation of the equinoxes, compatible with IAU 2000 resolutions and IAU 2006/2000A precession-nutation. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned Equation of the equinoxes (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The result, which is in radians, operates in the following sense: Greenwich apparent ST = GMST + equation of the equinoxes Called anpm : normalize angle into range +/- pi gst06a : Greenwich apparent sidereal time, IAU 2006/2000A gmst06 : Greenwich mean sidereal time, IAU 2006 Reference McCarthy, D. D., Petit, G. (eds.), 2004, IERS Conventions (2003),   IERS Technical Note No. 32, BKG source"},{"id":897,"pagetitle":"Functions","title":"ERFA.eect00","ref":"/ERFA/stable/api/functions/#ERFA.eect00","content":" ERFA.eect00  —  Function eect00(date1, date2) Equation of the equinoxes complementary terms, consistent with IAU 2000 resolutions. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned Complementary terms (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The \"complementary terms\" are part of the equation of the equinoxes (EE), classically the difference between apparent and mean Sidereal Time: GAST = GMST + EE with: EE = dpsi * cos(eps) where dpsi is the nutation in longitude and eps is the obliquity of date.  However, if the rotation of the Earth were constant in an inertial frame the classical formulation would lead to apparent irregularities in the UT1 timescale traceable to side- effects of precession-nutation.  In order to eliminate these effects from UT1, \"complementary terms\" were introduced in 1994 (IAU, 1994) and took effect from 1997 (Capitaine and Gontier, 1993): GAST = GMST + CT + EE By convention, the complementary terms are included as part of the equation of the equinoxes rather than as part of the mean Sidereal Time.  This slightly compromises the \"geometrical\" interpretation of mean sidereal time but is otherwise inconsequential. The present function computes CT in the above expression, compatible with IAU 2000 resolutions (Capitaine et al., 2002, and IERS Conventions 2003). Called fal03 : mean anomaly of the Moon falp03 : mean anomaly of the Sun faf03 : mean argument of the latitude of the Moon fad03 : mean elongation of the Moon from the Sun faom03 : mean longitude of the Moon's ascending node fave03 : mean longitude of Venus fae03 : mean longitude of Earth fapa03 : general accumulated precession in longitude References Capitaine, N. & Gontier, A.-M., Astron. Astrophys., 275,   645-650 (1993) Capitaine, N., Wallace, P.T. and McCarthy, D.D., \"Expressions to   implement the IAU 2000 definition of UT1\", Astronomy &   Astrophysics, 406, 1135-1149 (2003) IAU Resolution C7, Recommendation 3 (1994) McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":898,"pagetitle":"Functions","title":"ERFA.eform","ref":"/ERFA/stable/api/functions/#ERFA.eform-Tuple{ERFA.Ellipsoid}","content":" ERFA.eform  —  Method eform(n::Ellipsoid) Earth reference ellipsoids. Given n : Ellipsoid identifier (Note 1) Returned a : Equatorial radius (meters, Note 2) f : Flattening (Note 2) Notes The identifier n is a number that specifies the choice of reference ellipsoid.  The following are supported: WGS84 GRS80 WGS72 The ellipsoid parameters are returned in the form of equatorial radius in meters (a) and flattening (f).  The latter is a number around 0.00335, i.e. around 1/298. For the case where an unsupported n value is supplied, zero a and f are returned, as well as error status. References Department of Defense World Geodetic System 1984, National   Imagery and Mapping Agency Technical Report 8350.2, Third   Edition, p3-2. Moritz, H., Bull. Geodesique 66-2, 187 (1992). The Department of Defense World Geodetic System 1972, World   Geodetic System Committee, May 1974. Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992),   p220. source"},{"id":899,"pagetitle":"Functions","title":"ERFA.eo06a","ref":"/ERFA/stable/api/functions/#ERFA.eo06a","content":" ERFA.eo06a  —  Function eo06a(date1, date2) Equation of the origins, IAU 2006 precession and IAU 2000A nutation. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned Equation of the origins in radians Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The equation of the origins is the distance between the true equinox and the celestial intermediate origin and, equivalently, the difference between Earth rotation angle and Greenwich apparent sidereal time (ERA-GST).  It comprises the precession (since J2000.0) in right ascension plus the equation of the equinoxes (including the small correction terms). Called pnm06a : classical NPB matrix, IAU 2006/2000A bpn2xy : extract CIP X,Y coordinates from NPB matrix s06 : the CIO locator s, given X,Y, IAU 2006 eors : equation of the origins, given NPB matrix and s References Capitaine, N. & Wallace, P.T., 2006, Astron.Astrophys. 450, 855 Wallace, P.T. & Capitaine, N., 2006, Astron.Astrophys. 459, 981 source"},{"id":900,"pagetitle":"Functions","title":"ERFA.eors","ref":"/ERFA/stable/api/functions/#ERFA.eors-Tuple{Any, Any}","content":" ERFA.eors  —  Method eors(rnpb, s) Equation of the origins, given the classical NPB matrix and the quantity s. Given rnpb : Classical nutation x precession x bias matrix s : The quantity s (the CIO locator) Returned The equation of the origins in radians. Notes The equation of the origins is the distance between the true  equinox and the celestial intermediate origin and, equivalently,  the difference between Earth rotation angle and Greenwich  apparent sidereal time (ERA-GST).  It comprises the precession  (since J2000.0) in right ascension plus the equation of the  equinoxes (including the small correction terms). The algorithm is from Wallace & Capitaine (2006). References Capitaine, N. & Wallace, P.T., 2006, Astron.Astrophys. 450, 855 Wallace, P. & Capitaine, N., 2006, Astron.Astrophys. 459, 981 source"},{"id":901,"pagetitle":"Functions","title":"ERFA.epb","ref":"/ERFA/stable/api/functions/#ERFA.epb","content":" ERFA.epb  —  Function epb(dj1, dj2) Julian Date to Besselian Epoch. Given dj1 ,  dj2 : Julian Date (see note) Returned Besselian Epoch. Note The Julian Date is supplied in two pieces, in the usual ERFA    manner, which is designed to preserve time resolution.  The    Julian Date is available as a single number by adding dj1 and    dj2.  The maximum resolution is achieved if dj1 is 2451545.0    (J2000.0). Reference Lieske, J.H., 1979. Astron.Astrophys., 73, 282. source"},{"id":902,"pagetitle":"Functions","title":"ERFA.epb2jd","ref":"/ERFA/stable/api/functions/#ERFA.epb2jd","content":" ERFA.epb2jd  —  Function epb2jd(epj) Besselian Epoch to Julian Date. Given epb : Besselian Epoch (e.g. 1957.3) Returned djm0 : MJD zero-point: always 2400000.5 djm : Modified Julian Date Note The Julian Date is returned in two pieces, in the usual ERFA    manner, which is designed to preserve time resolution.  The    Julian Date is available as a single number by adding djm0 and    djm. Reference Lieske, J.H., 1979, Astron.Astrophys. 73, 282. source"},{"id":903,"pagetitle":"Functions","title":"ERFA.epj","ref":"/ERFA/stable/api/functions/#ERFA.epj","content":" ERFA.epj  —  Function epj(dj1, dj2) Julian Date to Julian Epoch. Given dj1 ,  dj2 : Julian Date (see note) Returned Julian Epoch Note The Julian Date is supplied in two pieces, in the usual ERFA    manner, which is designed to preserve time resolution.  The    Julian Date is available as a single number by adding dj1 and    dj2.  The maximum resolution is achieved if dj1 is 2451545.0    (J2000.0). Reference Lieske, J.H., 1979, Astron.Astrophys. 73, 282. source"},{"id":904,"pagetitle":"Functions","title":"ERFA.epj2jd","ref":"/ERFA/stable/api/functions/#ERFA.epj2jd","content":" ERFA.epj2jd  —  Function epj2jd(epj) Julian Epoch to Julian Date. Given epj : Julian Epoch (e.g. 1996.8) Returned djm0 : MJD zero-point: always 2400000.5 djm : Modified Julian Date Note The Julian Date is returned in two pieces, in the usual ERFA    manner, which is designed to preserve time resolution.  The    Julian Date is available as a single number by adding djm0 and    djm. Reference Lieske, J.H., 1979, Astron.Astrophys. 73, 282. source"},{"id":905,"pagetitle":"Functions","title":"ERFA.epv00","ref":"/ERFA/stable/api/functions/#ERFA.epv00-Tuple{Any, Any}","content":" ERFA.epv00  —  Method epv00(date1, date2) Earth position and velocity, heliocentric and barycentric, with respect to the Barycentric Celestial Reference System. Given date1 ,  date2 : TDB date (Note 1) Returned pvh : Heliocentric Earth position/velocity pvb : Barycentric Earth position/velocity Notes The TDB date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TDB)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience.  However, the accuracy of the result is more likely to be limited by the algorithm itself than the way the date has been expressed. n.b. TT can be used instead of TDB in most applications. On return, the arrays pvh and pvb contain the following: pvh[0][0]  x       }\npvh[0][1]  y       } heliocentric position, au\npvh[0][2]  z       }\n\npvh[1][0]  xdot    }\npvh[1][1]  ydot    } heliocentric velocity, au/d\npvh[1][2]  zdot    }\n\npvb[0][0]  x       }\npvb[0][1]  y       } barycentric position, au\npvb[0][2]  z       }\n\npvb[1][0]  xdot    }\npvb[1][1]  ydot    } barycentric velocity, au/d\npvb[1][2]  zdot    } The vectors are with respect to the Barycentric Celestial Reference System.  The time unit is one day in TDB. The function is a SIMPLIFIED SOLUTION from the planetary theory VSOP2000 (X. Moisson, P. Bretagnon, 2001, Celes. Mechanics & Dyn. Astron., 80, 3/4, 205-213) and is an adaptation of original Fortran code supplied by P. Bretagnon (private comm., 2000). Comparisons over the time span 1900-2100 with this simplified solution and the JPL DE405 ephemeris give the following results:                       RMS    max\nHeliocentric:\n    position error    3.7   11.2   km\n    velocity error    1.4    5.0   mm/s\n\nBarycentric:\n    position error    4.6   13.4   km\n    velocity error    1.4    4.9   mm/s Comparisons with the JPL DE406 ephemeris show that by 1800 and 2200 the position errors are approximately double their 1900-2100 size.  By 1500 and 2500 the deterioration is a factor of 10 and by 1000 and 3000 a factor of 60.  The velocity accuracy falls off at about half that rate. It is permissible to use the same array for pvh and pvb, which will receive the barycentric values. source"},{"id":906,"pagetitle":"Functions","title":"ERFA.eqec06","ref":"/ERFA/stable/api/functions/#ERFA.eqec06","content":" ERFA.eqec06  —  Function eqec06(date1, date2, dr, dd) Transformation from ICRS equatorial coordinates to ecliptic coordinates (mean equinox and ecliptic of date) using IAU 2006 precession model. Given date1 ,  date2 : TT as a 2-part Julian date (Note 1) dr ,  dd : ICRS right ascension and declination (radians) Returned dl ,  db : Ecliptic longitude and latitude (radians) The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. No assumptions are made about whether the coordinates represent starlight and embody astrometric effects such as parallax or aberration. The transformation is approximately that from mean J2000.0 right ascension and declination to ecliptic longitude and latitude (mean equinox and ecliptic of date), with only frame bias (always less than 25 mas) to disturb this classical picture. Called s2c : spherical coordinates to unit vector ecm06 : J2000.0 to ecliptic rotation matrix, IAU 2006 rxp : product of r-matrix and p-vector c2s : unit vector to spherical coordinates anp : normalize angle into range 0 to 2pi anpm : normalize angle into range +/- pi source"},{"id":907,"pagetitle":"Functions","title":"ERFA.eqeq94","ref":"/ERFA/stable/api/functions/#ERFA.eqeq94","content":" ERFA.eqeq94  —  Function eqeq94(date1, date2) Equation of the equinoxes, IAU 1994 model. Given date1 ,  date2 : TDB date (Note 1) Returned Equation of the equinoxes (Note 2) Notes The date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The result, which is in radians, operates in the following sense: Greenwich apparent ST = GMST + equation of the equinoxes Called anpm : normalize angle into range +/- pi nut80 : nutation, IAU 1980 obl80 : mean obliquity, IAU 1980 References IAU Resolution C7, Recommendation 3 (1994). Capitaine, N. & Gontier, A.-M., 1993, Astron. Astrophys., 275,   645-650. source"},{"id":908,"pagetitle":"Functions","title":"ERFA.era00","ref":"/ERFA/stable/api/functions/#ERFA.era00","content":" ERFA.era00  —  Function era00(dj1, dj2) Earth rotation angle (IAU 2000 model). Given dj1 ,  dj2 : UT1 as a 2-part Julian Date (see note) Returned Earth rotation angle (radians), range 0-2pi Notes The UT1 date dj1+dj2 is a Julian Date, apportioned in any convenient way between the arguments dj1 and dj2.  For example, JD(UT1)=2450123.7 could be expressed in any of these ways, among others: dj1 dj2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 and MJD methods are good compromises between resolution and convenience.  The date & time method is best matched to the algorithm used:  maximum precision is delivered when the dj1 argument is for 0hrs UT1 on the day in question and the dj2 argument lies in the range 0 to 1, or vice versa. The algorithm is adapted from Expression 22 of Capitaine et al. 2000. The time argument has been expressed in days directly, and, to retain precision, integer contributions have been eliminated.  The same formulation is given in IERS Conventions (2003), Chap. 5, Eq. 14. Called anp : normalize angle into range 0 to 2pi References Capitaine N., Guinot B. and McCarthy D.D, 2000, Astron.   Astrophys., 355, 398-405. McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":909,"pagetitle":"Functions","title":"ERFA.erfa_cp","ref":"/ERFA/stable/api/functions/#ERFA.erfa_cp","content":" ERFA.erfa_cp  —  Function erfa_cp(p) Copy a p-vector. Deprecated Use  Base.copy  instead. Given p : p-vector to be copied Returned c : copy source"},{"id":910,"pagetitle":"Functions","title":"ERFA.fad03","ref":"/ERFA/stable/api/functions/#ERFA.fad03","content":" ERFA.fad03  —  Function fad03(t) Fundamental argument, IERS Conventions (2003): mean elongation of the Moon from the Sun. Given t : TDB, Julian centuries since J2000.0 (Note 1) Returned D , radians (Note 2) Notes Though t is strictly TDB, it is usually more convenient to use TT, which makes no significant difference. The expression used is as adopted in IERS Conventions (2003) and is from Simon et al. (1994). References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683 source"},{"id":911,"pagetitle":"Functions","title":"ERFA.fae03","ref":"/ERFA/stable/api/functions/#ERFA.fae03","content":" ERFA.fae03  —  Function fae03(t) Fundamental argument, IERS Conventions (2003): Mean longitude of Earth. Given t : TDB, Julian centuries since J2000.0 (Note 1) Returned Mean longitude of Earth, radians (Note 2) Notes Though t is strictly TDB, it is usually more convenient to use TT, which makes no significant difference. The expression used is as adopted in IERS Conventions (2003) and comes from Souchay et al. (1999) after Simon et al. (1994). References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683 Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M. 1999,   Astron.Astrophys.Supp.Ser. 135, 111 source"},{"id":912,"pagetitle":"Functions","title":"ERFA.faf03","ref":"/ERFA/stable/api/functions/#ERFA.faf03","content":" ERFA.faf03  —  Function faf03(t) Fundamental argument, IERS Conventions (2003): Mean longitude of the Moon minus mean longitude of the ascending node. Given t : TDB, Julian centuries since J2000.0 (Note 1) Returned F , radians (Note 2) Notes Though t is strictly TDB, it is usually more convenient to use TT, which makes no significant difference. The expression used is as adopted in IERS Conventions (2003) and is from Simon et al. (1994). References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683 source"},{"id":913,"pagetitle":"Functions","title":"ERFA.faju03","ref":"/ERFA/stable/api/functions/#ERFA.faju03","content":" ERFA.faju03  —  Function faju03(t) Fundamental argument, IERS Conventions (2003): Mean longitude of Jupiter. Given t : TDB, Julian centuries since J2000.0 (Note 1) Returned Mean longitude of Jupiter, radians (Note 2) Notes Though t is strictly TDB, it is usually more convenient to use TT, which makes no significant difference. The expression used is as adopted in IERS Conventions (2003) and comes from Souchay et al. (1999) after Simon et al. (1994). References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683 Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M. 1999,   Astron.Astrophys.Supp.Ser. 135, 111 source"},{"id":914,"pagetitle":"Functions","title":"ERFA.fal03","ref":"/ERFA/stable/api/functions/#ERFA.fal03","content":" ERFA.fal03  —  Function fal03(t) Fundamental argument, IERS Conventions (2003): mean anomaly of the Moon. Given t : TDB, Julian centuries since J2000.0 (Note 1) Returned l , radians (Note 2) Notes Though t is strictly TDB, it is usually more convenient to use TT, which makes no significant difference. The expression used is as adopted in IERS Conventions (2003) and is from Simon et al. (1994). References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683 source"},{"id":915,"pagetitle":"Functions","title":"ERFA.falp03","ref":"/ERFA/stable/api/functions/#ERFA.falp03","content":" ERFA.falp03  —  Function falp03(t) Fundamental argument, IERS Conventions (2003): mean anomaly of the Sun. Given t : TDB, Julian centuries since J2000.0 (Note 1) Returned l' , radians (Note 2) Notes Though t is strictly TDB, it is usually more convenient to use TT, which makes no significant difference. The expression used is as adopted in IERS Conventions (2003) and is from Simon et al. (1994). References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683 source"},{"id":916,"pagetitle":"Functions","title":"ERFA.fama03","ref":"/ERFA/stable/api/functions/#ERFA.fama03","content":" ERFA.fama03  —  Function fama03(t) Fundamental argument, IERS Conventions (2003): Mean longitude of Mars. Given t : TDB, Julian centuries since J2000.0 (Note 1) Returned Mean longitude of Mars, radians (Note 2) Notes Though t is strictly TDB, it is usually more convenient to use TT, which makes no significant difference. The expression used is as adopted in IERS Conventions (2003) and comes from Souchay et al. (1999) after Simon et al. (1994). References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683 Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M. 1999,   Astron.Astrophys.Supp.Ser. 135, 111 source"},{"id":917,"pagetitle":"Functions","title":"ERFA.fame03","ref":"/ERFA/stable/api/functions/#ERFA.fame03","content":" ERFA.fame03  —  Function fame03(t) Fundamental argument, IERS Conventions (2003): Mean longitude of Mercury. Given t : TDB, Julian centuries since J2000.0 (Note 1) Returned Mean longitude of Mercury, radians (Note 2) Notes Though t is strictly TDB, it is usually more convenient to use TT, which makes no significant difference. The expression used is as adopted in IERS Conventions (2003) and comes from Souchay et al. (1999) after Simon et al. (1994). References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683 Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M. 1999,   Astron.Astrophys.Supp.Ser. 135, 111 source"},{"id":918,"pagetitle":"Functions","title":"ERFA.fane03","ref":"/ERFA/stable/api/functions/#ERFA.fane03","content":" ERFA.fane03  —  Function fane03(t) Fundamental argument, IERS Conventions (2003): Mean longitude of Neptune. Given t : TDB, Julian centuries since J2000.0 (Note 1) Returned Mean longitude of Neptune, radians (Note 2) Notes Though t is strictly TDB, it is usually more convenient to use TT, which makes no significant difference. The expression used is as adopted in IERS Conventions (2003) and is adapted from Simon et al. (1994). References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683 source"},{"id":919,"pagetitle":"Functions","title":"ERFA.faom03","ref":"/ERFA/stable/api/functions/#ERFA.faom03","content":" ERFA.faom03  —  Function faom03(t) Fundamental argument, IERS Conventions (2003): Mean longitude of the Moon's ascending node. Given t : TDB, Julian centuries since J2000.0 (Note 1) Returned Omega , radians (Note 2) Notes Though t is strictly TDB, it is usually more convenient to use TT, which makes no significant difference. The expression used is as adopted in IERS Conventions (2003) and is from Simon et al. (1994). References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683 source"},{"id":920,"pagetitle":"Functions","title":"ERFA.fapa03","ref":"/ERFA/stable/api/functions/#ERFA.fapa03","content":" ERFA.fapa03  —  Function fapa03(t) Fundamental argument, IERS Conventions (2003): general accumulated precession in longitude. Given t : TDB, Julian centuries since J2000.0 (Note 1) Returned General precession in longitude, radians (Note 2) Notes Though t is strictly TDB, it is usually more convenient to use TT, which makes no significant difference. The expression used is as adopted in IERS Conventions (2003).  It is taken from Kinoshita & Souchay (1990) and comes originally from Lieske et al. (1977). References Kinoshita, H. and Souchay J. 1990, Celest.Mech. and Dyn.Astron.   48, 187 Lieske, J.H., Lederle, T., Fricke, W. & Morando, B. 1977,   Astron.Astrophys. 58, 1-16 McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":921,"pagetitle":"Functions","title":"ERFA.fasa03","ref":"/ERFA/stable/api/functions/#ERFA.fasa03","content":" ERFA.fasa03  —  Function fasa03(t) Fundamental argument, IERS Conventions (2003): Mean longitude of Saturn. Given t : TDB, Julian centuries since J2000.0 (Note 1) Returned Mean longitude of Saturn, radians (Note 2) Notes Though t is strictly TDB, it is usually more convenient to use TT, which makes no significant difference. The expression used is as adopted in IERS Conventions (2003) and comes from Souchay et al. (1999) after Simon et al. (1994). References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683 Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M. 1999,   Astron.Astrophys.Supp.Ser. 135, 111 source"},{"id":922,"pagetitle":"Functions","title":"ERFA.faur03","ref":"/ERFA/stable/api/functions/#ERFA.faur03","content":" ERFA.faur03  —  Function faur03(t) Fundamental argument, IERS Conventions (2003): Mean longitude of Uranus. Given t : TDB, Julian centuries since J2000.0 (Note 1) Returned Mean longitude of Uranus, radians (Note 2) Notes Though t is strictly TDB, it is usually more convenient to use TT, which makes no significant difference. The expression used is as adopted in IERS Conventions (2003) and is adapted from Simon et al. (1994). References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683 source"},{"id":923,"pagetitle":"Functions","title":"ERFA.fave03","ref":"/ERFA/stable/api/functions/#ERFA.fave03","content":" ERFA.fave03  —  Function fave03(t) Fundamental argument, IERS Conventions (2003): Mean longitude of Venus. Given t : TDB, Julian centuries since J2000.0 (Note 1) Returned Mean longitude of Venus, radians (Note 2) Notes Though t is strictly TDB, it is usually more convenient to use TT, which makes no significant difference. The expression used is as adopted in IERS Conventions (2003) and comes from Souchay et al. (1999) after Simon et al. (1994). References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683 Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M. 1999,   Astron.Astrophys.Supp.Ser. 135, 111 source"},{"id":924,"pagetitle":"Functions","title":"ERFA.fk425","ref":"/ERFA/stable/api/functions/#ERFA.fk425-NTuple{6, Any}","content":" ERFA.fk425  —  Method fk425(r1950, d1950, dr1950, dd1950, p1950, v1950) Convert B1950.0 FK4 star catalog data to J2000.0 FK5. This function converts a star's catalog data from the old FK4 Bessel-Newcomb) system to the later IAU 1976 FK5 (Fricke) system. Given (all B1950.0, FK4) r1950,d1950 : B1950.0 RA,Dec (rad) dr1950,dd1950 : B1950.0 proper motions (rad/trop.yr) p1950 : Parallax (arcsec) v1950 : Radial velocity (km/s, +ve = moving away) Returned (all J2000.0, FK5) r2000,d2000 : J2000.0 RA,Dec (rad) dr2000,dd2000 : J2000.0 proper motions (rad/Jul.yr) p2000 : Parallax (arcsec) v2000 : Radial velocity (km/s, +ve = moving away) Notes The proper motions in RA are dRA/dt rather than cos(Dec)*dRA/dt, and are per year rather than per century. The conversion is somewhat complicated, for several reasons: Change of standard epoch from B1950.0 to J2000.0. An intermediate transition date of 1984 January 1.0 TT. A change of precession model. Change of time unit for proper motion (tropical to Julian). FK4 positions include the E-terms of aberration, to simplify the hand computation of annual aberration.  FK5 positions assume a rigorous aberration computation based on the Earth's barycentric velocity. The E-terms also affect proper motions, and in particular cause objects at large distances to exhibit fictitious proper motions. The algorithm is based on Smith et al. (1989) and Yallop et al. (1989), which presented a matrix method due to Standish (1982) as developed by Aoki et al. (1983), using Kinoshita's development of Andoyer's post-Newcomb precession.  The numerical constants from Seidelmann (1992) are used canonically. Conversion from B1950.0 FK4 to J2000.0 FK5 only is provided for. Conversions for different epochs and equinoxes would require additional treatment for precession, proper motion and E-terms. In the FK4 catalog the proper motions of stars within 10 degrees of the poles do not embody differential E-terms effects and should, strictly speaking, be handled in a different manner from stars outside these regions.  However, given the general lack of homogeneity of the star data available for routine astrometry, the difficulties of handling positions that may have been determined from astrometric fields spanning the polar and non- polar regions, the likelihood that the differential E-terms effect was not taken into account when allowing for proper motion in past astrometry, and the undesirability of a discontinuity in the algorithm, the decision has been made in this ERFA algorithm to include the effects of differential E-terms on the proper motions for all stars, whether polar or not.  At epoch J2000.0, and measuring \"on the sky\" rather than in terms of RA change, the errors resulting from this simplification are less than 1 milliarcsecond in position and 1 milliarcsecond per century in proper motion. Called anp : normalize angle into range 0 to 2pi pv2s : pv-vector to spherical coordinates pdp : scalar product of two p-vectors pvmpv : pv-vector minus pv_vector pvppv : pv-vector plus pv_vector s2pv : spherical coordinates to pv-vector sxp : multiply p-vector by scalar References Aoki, S. et al., 1983, \"Conversion matrix of epoch B1950.0 FK4-based positions of stars to epoch J2000.0 positions in accordance with the new IAU resolutions\".  Astron.Astrophys. 128, 263-267. Seidelmann, P.K. (ed), 1992, \"Explanatory Supplement to the Astronomical Almanac\", ISBN 0-935702-68-7. Smith, C.A. et al., 1989, \"The transformation of astrometric catalog systems to the equinox J2000.0\".  Astron.J. 97, 265. Standish, E.M., 1982, \"Conversion of positions and proper motions from B1950.0 to the IAU system at J2000.0\".  Astron.Astrophys., 115, 1, 20-22. Yallop, B.D. et al., 1989, \"Transformation of mean star places from FK4 B1950.0 to FK5 J2000.0 using matrices in 6-space\". Astron.J. 97, 274. source"},{"id":925,"pagetitle":"Functions","title":"ERFA.fk45z","ref":"/ERFA/stable/api/functions/#ERFA.fk45z-Tuple{Any, Any, Any}","content":" ERFA.fk45z  —  Method fk45z(r1950, d1950, bepoch) Convert a B1950.0 FK4 star position to J2000.0 FK5, assuming zero proper motion in the FK5 system. This function converts a star's catalog data from the old FK4 (Bessel-Newcomb) system to the later IAU 1976 FK5 (Fricke) system, in such a way that the FK5 proper motion is zero.  Because such a star has, in general, a non-zero proper motion in the FK4 system, the function requires the epoch at which the position in the FK4 system was determined. Given r1950 ,  d1950 : B1950.0 FK4 RA,Dec at epoch (rad) bepoch : Besselian epoch (e.g. 1979.3) Returned r2000 ,  d2000 : J2000.0 FK5 RA,Dec (rad) Notes The epoch bepoch is strictly speaking Beselian, but if a Julian epoch is supplied the result will be affected only to a negligible extent. The method is from Appendix 2 of Aoki et al. (1983), but using the constants of Seidelmann (1992).  See the function eraFk425 for a general introduction to the FK4 to FK5 conversion. Conversion from equinox B1950.0 FK4 to equinox J2000.0 FK5 only is provided for.  Conversions for different starting and/or ending epochs would require additional treatment for precession, proper motion and E-terms. In the FK4 catalog the proper motions of stars within 10 degrees of the poles do not embody differential E-terms effects and should, strictly speaking, be handled in a different manner from stars outside these regions.  However, given the general lack of homogeneity of the star data available for routine astrometry, the difficulties of handling positions that may have been determined from astrometric fields spanning the polar and non- polar regions, the likelihood that the differential E-terms effect was not taken into account when allowing for proper motion in past astrometry, and the undesirability of a discontinuity in the algorithm, the decision has been made in this ERFA algorithm to include the effects of differential E-terms on the proper motions for all stars, whether polar or not.  At epoch 2000.0, and measuring \"on the sky\" rather than in terms of RA change, the errors resulting from this simplification are less than 1 milliarcsecond in position and 1 milliarcsecond per century in proper motion. References Aoki, S. et al., 1983, \"Conversion matrix of epoch B1950.0 FK4-based positions of stars to epoch J2000.0 positions in accordance with the new IAU resolutions\".  Astron.Astrophys. 128, 263-267. Seidelmann, P.K. (ed), 1992, \"Explanatory Supplement to the Astronomical Almanac\", ISBN 0-935702-68-7. Called anp : normalize angle into range 0 to 2pi c2s : p-vector to spherical epb2jd : Besselian epoch to Julian date epj : Julian date to Julian epoch pdp : scalar product of two p-vectors pmp : p-vector minus p-vector ppsp : p-vector plus scaled p-vector pvu : update a pv-vector s2c : spherical to p-vectors source"},{"id":926,"pagetitle":"Functions","title":"ERFA.fk524","ref":"/ERFA/stable/api/functions/#ERFA.fk524-NTuple{6, Any}","content":" ERFA.fk524  —  Method function fk524(r2000, d2000, dr2000, dd2000, p2000, v2000) Convert J2000.0 FK5 star catalog data to B1950.0 FK4. Given (all J2000.0, FK5) r2000 ,  d2000 : J2000.0 RA,Dec (rad) dr2000 ,  dd2000 : J2000.0 proper motions (rad/Jul.yr) p2000 : parallax (arcsec) v2000 : radial velocity (km/s, +ve = moving away) Returned (all B1950.0, FK4) r1950 ,  d1950 : B1950.0 RA,Dec (rad) dr1950 ,  dd1950 : B1950.0 proper motions (rad/trop.yr) p1950 : parallax (arcsec) v1950 : radial velocity (km/s, +ve = moving away) Notes The proper motions in RA are dRA/dt rather than cos(Dec)*dRA/dt, and are per year rather than per century. The conversion is somewhat complicated, for several reasons: Change of standard epoch from J2000.0 to B1950.0. An intermediate transition date of 1984 January 1.0 TT. A change of precession model. Change of time unit for proper motion (Julian to tropical). FK4 positions include the E-terms of aberration, to simplify the hand computation of annual aberration.  FK5 positions assume a rigorous aberration computation based on the Earth's barycentric velocity. The E-terms also affect proper motions, and in particular cause objects at large distances to exhibit fictitious proper motions. The algorithm is based on Smith et al. (1989) and Yallop et al. (1989), which presented a matrix method due to Standish (1982) as developed by Aoki et al. (1983), using Kinoshita's development of Andoyer's post-Newcomb precession.  The numerical constants from Seidelmann (1992) are used canonically. In the FK4 catalog the proper motions of stars within 10 degrees of the poles do not embody differential E-terms effects and should, strictly speaking, be handled in a different manner from stars outside these regions.  However, given the general lack of homogeneity of the star data available for routine astrometry, the difficulties of handling positions that may have been determined from astrometric fields spanning the polar and non- polar regions, the likelihood that the differential E-terms effect was not taken into account when allowing for proper motion in past astrometry, and the undesirability of a discontinuity in the algorithm, the decision has been made in this ERFA algorithm to include the effects of differential E-terms on the proper motions for all stars, whether polar or not.  At epoch J2000.0, and measuring \"on the sky\" rather than in terms of RA change, the errors resulting from this simplification are less than 1 milliarcsecond in position and 1 milliarcsecond per century in proper motion. Called anp : normalize angle into range 0 to 2pi pdp : scalar product of two p-vectors pm : modulus of p-vector pmp : p-vector minus p-vector ppp : p-vector plus p-vector pv2s : pv-vector to spherical coordinates s2pv : spherical coordinates to pv-vector sxp : multiply p-vector by scalar References Aoki, S. et al., 1983, \"Conversion matrix of epoch B1950.0 FK4-based positions of stars to epoch J2000.0 positions in accordance with the new IAU resolutions\".  Astron.Astrophys. 128, 263-267. Seidelmann, P.K. (ed), 1992, \"Explanatory Supplement to the Astronomical Almanac\", ISBN 0-935702-68-7. Smith, C.A. et al., 1989, \"The transformation of astrometric catalog systems to the equinox J2000.0\".  Astron.J. 97, 265. Standish, E.M., 1982, \"Conversion of positions and proper motions from B1950.0 to the IAU system at J2000.0\".  Astron.Astrophys., 115, 1, 20-22. Yallop, B.D. et al., 1989, \"Transformation of mean star places from FK4 B1950.0 to FK5 J2000.0 using matrices in 6-space\". Astron.J. 97, 274. source"},{"id":927,"pagetitle":"Functions","title":"ERFA.fk52h","ref":"/ERFA/stable/api/functions/#ERFA.fk52h-NTuple{6, Any}","content":" ERFA.fk52h  —  Method fk52h(ra, dec, dra, ddec, px, rv) Transform FK5 (J2000.0) star data into the Hipparcos system. Given (all FK5, equinox J2000.0, epoch J2000.0) r5 : RA (radians) d5 : Dec (radians) dr5 : Proper motion in RA (dRA/dt, rad/Jyear) dd5 : Proper motion in Dec (dDec/dt, rad/Jyear) px5 : Parallax (arcsec) rv5 : Radial velocity (km/s, positive = receding) Returned (all Hipparcos, epoch J2000.0) rh : RA (radians) dh : Dec (radians) drh : proper motion in RA (dRA/dt, rad/Jyear) ddh : proper motion in Dec (dDec/dt, rad/Jyear) pxh : parallax (arcsec) rvh : radial velocity (km/s, positive = receding) Notes This function transforms FK5 star positions and proper motions into the system of the Hipparcos catalog. The proper motions in RA are dRA/dt rather than cos(Dec)*dRA/dt, and are per year rather than per century. The FK5 to Hipparcos transformation is modeled as a pure rotation and spin;  zonal errors in the FK5 catalog are not taken into account. See also  h2fk5 ,  fk5hz ,  hfk5z . Called starpv : star catalog data to space motion pv-vector fk5hip : FK5 to Hipparcos rotation and spin rxp : product of r-matrix and p-vector pxp : vector product of two p-vectors ppp : p-vector plus p-vector pvstar : space motion pv-vector to star catalog data Reference F.Mignard & M.Froeschle, Astron. Astrophys. 354, 732-739 (2000). source"},{"id":928,"pagetitle":"Functions","title":"ERFA.fk54z","ref":"/ERFA/stable/api/functions/#ERFA.fk54z-Tuple{Any, Any, Any}","content":" ERFA.fk54z  —  Method fk54z(r2000, d2000, bepoch) Convert a J2000.0 FK5 star position to B1950.0 FK4, assuming zero proper motion in FK5 and parallax. Given r2000 ,  d2000 : J2000.0 FK5 RA,Dec (rad) bepoch : Besselian epoch (e.g. 1950.0) Returned r1950 ,  d1950 : B1950.0 FK4 RA,Dec (rad) at epoch BEPOCH dr1950 ,  dd1950 : B1950.0 FK4 proper motions (rad/trop.yr) Notes In contrast to the eraFk524 function, here the FK5 proper motions, the parallax and the radial velocity are presumed zero. This function converts a star position from the IAU 1976 FK5 (Fricke) system to the former FK4 (Bessel-Newcomb) system, for cases such as distant radio sources where it is presumed there is zero parallax and no proper motion.  Because of the E-terms of aberration, such objects have (in general) non-zero proper motion in FK4, and the present function returns those fictitious proper motions. Conversion from B1950.0 FK4 to J2000.0 FK5 only is provided for. Conversions involving other equinoxes would require additional treatment for precession. The position returned by this function is in the B1950.0 FK4 reference system but at Besselian epoch BEPOCH.  For comparison with catalogs the BEPOCH argument will frequently be 1950.0. (In this context the distinction between Besselian and Julian epoch is insignificant.) The RA component of the returned (fictitious) proper motion is dRA/dt rather than cos(Dec)*dRA/dt. Called anp : normalize angle into range 0 to 2pi c2s : p-vector to spherical fk524 : FK4 to FK5 s2c : spherical to p-vector source"},{"id":929,"pagetitle":"Functions","title":"ERFA.fk5hip","ref":"/ERFA/stable/api/functions/#ERFA.fk5hip-Tuple{}","content":" ERFA.fk5hip  —  Method fk5hip() FK5 to Hipparcos rotation and spin. Returned r5h : R-matrix: FK5 rotation wrt Hipparcos (Note 2) s5h : R-vector: FK5 spin wrt Hipparcos (Note 3) Notes This function models the FK5 to Hipparcos transformation as a pure rotation and spin;  zonal errors in the FK5 catalogue are not taken into account. The r-matrix r5h operates in the sense:   P_Hipparcos = r5h x P_FK5 where P FK5 is a p-vector in the FK5 frame, and P Hipparcos is the equivalent Hipparcos p-vector. The r-vector s5h represents the time derivative of the FK5 to Hipparcos rotation.  The units are radians per year (Julian, TDB). Called rv2m : r-vector to r-matrix Reference F.Mignard & M.Froeschle, Astron. Astrophys. 354, 732-739 (2000). source"},{"id":930,"pagetitle":"Functions","title":"ERFA.fk5hz","ref":"/ERFA/stable/api/functions/#ERFA.fk5hz-NTuple{4, Any}","content":" ERFA.fk5hz  —  Method fk5hz(r5, d5, date1, date2) Transform an FK5 (J2000.0) star position into the system of the Hipparcos catalogue, assuming zero Hipparcos proper motion. Given r5 : FK5 RA (radians), equinox J2000.0, at date d5 : FK5 Dec (radians), equinox J2000.0, at date date1 ,  date2 : TDB date (Notes 1,2) Returned rh : Hipparcos RA (radians) dh : Hipparcos Dec (radians) Notes This function converts a star position from the FK5 system to the Hipparcos system, in such a way that the Hipparcos proper motion is zero.  Because such a star has, in general, a non-zero proper motion in the FK5 system, the function requires the date at which the position in the FK5 system was determined. The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The FK5 to Hipparcos transformation is modeled as a pure rotation and spin;  zonal errors in the FK5 catalogue are not taken into account. The position returned by this function is in the Hipparcos reference system but at date date1+date2. See also  fk52h ,  h2fk5 ,  hfk5z . Called s2c : spherical coordinates to unit vector fk5hip : FK5 to Hipparcos rotation and spin sxp : multiply p-vector by scalar rv2m : r-vector to r-matrix trxp : product of transpose of r-matrix and p-vector pxp : vector product of two p-vectors c2s : p-vector to spherical anp : normalize angle into range 0 to 2pi Reference F.Mignard & M.Froeschle, 2000, Astron.Astrophys. 354, 732-739. source"},{"id":931,"pagetitle":"Functions","title":"ERFA.fw2m","ref":"/ERFA/stable/api/functions/#ERFA.fw2m-NTuple{4, Any}","content":" ERFA.fw2m  —  Method fw2m(x, y, s, t) Form rotation matrix given the Fukushima-Williams angles. Given gamb : F-W angle gamma_bar (radians) phib : F-W angle phi_bar (radians) psi : F-W angle psi (radians) eps : F-W angle epsilon (radians) Returned r : Rotation matrix Notes Naming the following points: e = J2000.0 ecliptic pole, p = GCRS pole, E = ecliptic pole of date, and P = CIP, the four Fukushima-Williams angles are as follows: gamb = gamma = epE phib = phi = pE psi = psi = pEP eps = epsilon = EP The matrix representing the combined effects of frame bias, precession and nutation is: NxPxB = R_1(-eps).R_3(-psi).R_1(phib).R_3(gamb) Three different matrices can be constructed, depending on the supplied angles: To obtain the nutation x precession x frame bias matrix,  generate the four precession angles, generate the nutation  components and add them to the  psi_bar  and  epsilon_A  angles,  and call the present function. To obtain the precession x frame bias matrix, generate the  four precession angles and call the present function. To obtain the frame bias matrix, generate the four precession  angles for date J2000.0 and call the present function. The nutation-only and precession-only matrices can if necessary be obtained by combining these three appropriately. Called ir : initialize r-matrix to identity rz : rotate around Z-axis rx : rotate around X-axis Reference Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351 source"},{"id":932,"pagetitle":"Functions","title":"ERFA.fw2xy","ref":"/ERFA/stable/api/functions/#ERFA.fw2xy-NTuple{4, Any}","content":" ERFA.fw2xy  —  Method fw2xy(gamb, phib, psi, eps) CIP X,Y given Fukushima-Williams bias-precession-nutation angles. Given gamb : F-W angle gamma_bar (radians) phib : F-W angle phi_bar (radians) psi : F-W angle psi (radians) eps : F-W angle epsilon (radians) Returned x ,  y : CIP unit vector X,Y Notes Naming the following points: e = J2000.0 ecliptic pole, p = GCRS pole E = ecliptic pole of date, and P = CIP, the four Fukushima-Williams angles are as follows: gamb = gamma = epE phib = phi = pE psi = psi = pEP eps = epsilon = EP The matrix representing the combined effects of frame bias, precession and nutation is: NxPxB = R_1(-epsA).R_3(-psi).R_1(phib).R_3(gamb) The returned values x,y are elements  [3, 1]  and  [2, 1]  of the matrix.  Near J2000.0, they are essentially angles in radians. Called fw2m : F-W angles to r-matrix bpn2xy : extract CIP X,Y coordinates from NPB matrix Reference Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351 source"},{"id":933,"pagetitle":"Functions","title":"ERFA.g2icrs","ref":"/ERFA/stable/api/functions/#ERFA.g2icrs-Tuple{Any, Any}","content":" ERFA.g2icrs  —  Method g2icrs(dl, db) Transformation from Galactic Coordinates to ICRS. Given dl : Galactic longitude (radians) db : Galactic latitude (radians) Returned dr : ICRS right ascension (radians) dd : ICRS declination (radians) Notes The IAU 1958 system of Galactic coordinates was defined with respect to the now obsolete reference system FK4 B1950.0.  When interpreting the system in a modern context, several factors have to be taken into account: The inclusion in FK4 positions of the E-terms of aberration. The distortion of the FK4 proper motion system by differential Galactic rotation. The use of the B1950.0 equinox rather than the now-standard J2000.0. The frame bias between ICRS and the J2000.0 mean place system. The Hipparcos Catalogue (Perryman & ESA 1997) provides a rotation matrix that transforms directly between ICRS and Galactic coordinates with the above factors taken into account.  The matrix is derived from three angles, namely the ICRS coordinates of the Galactic pole and the longitude of the ascending node of the galactic equator on the ICRS equator.  They are given in degrees to five decimal places and for canonical purposes are regarded as exact.  In the Hipparcos Catalogue the matrix elements are given to 10 decimal places (about 20 microarcsec). In the present ERFA function the matrix elements have been recomputed from the canonical three angles and are given to 30 decimal places. The inverse transformation is performed by the function  icrs2g . Called anp : normalize angle into range 0 to 2pi anpm : normalize angle into range +/- pi s2c : spherical coordinates to unit vector trxp : product of transpose of r-matrix and p-vector c2s : p-vector to spherical Reference Perryman M.A.C. & ESA, 1997, ESA SP-1200, The Hipparcos and Tycho   catalogues.  Astrometric and photometric star catalogues   derived from the ESA Hipparcos Space Astrometry Mission.  ESA   Publications Division, Noordwijk, Netherlands. source"},{"id":934,"pagetitle":"Functions","title":"ERFA.gc2gd","ref":"/ERFA/stable/api/functions/#ERFA.gc2gd-Tuple{ERFA.Ellipsoid, Any}","content":" ERFA.gc2gd  —  Method gc2gd(n::Ellipsoid, xyz) Transform geocentric coordinates to geodetic using the specified reference ellipsoid. Given n : Ellipsoid identifier (Note 1) xyz : Geocentric vector (Note 2) Returned elong : Longitude (radians, east +ve, Note 3) phi : Latitude (geodetic, radians, Note 3) height : Height above ellipsoid (geodetic, Notes 2,3) Notes The identifier n is a number that specifies the choice of reference ellipsoid.  The following are supported: WGS84 GRS80 WGS72 The geocentric vector (xyz, given) and height (height, returned) are in meters. An error status -1 means that the identifier n is illegal.  An error status -2 is theoretically impossible.  In all error cases, all three results are set to -1e9. The inverse transformation is performed in the function  gd2gc . Called eform : Earth reference ellipsoids gc2gde : geocentric to geodetic transformation, general source"},{"id":935,"pagetitle":"Functions","title":"ERFA.gc2gde","ref":"/ERFA/stable/api/functions/#ERFA.gc2gde-Tuple{Any, Any, Any}","content":" ERFA.gc2gde  —  Method gc2gde(a, f, xyz) Transform geocentric coordinates to geodetic for a reference ellipsoid of specified form. Given a : Equatorial radius (Notes 2,4) f : Flattening (Note 3) xyz : Geocentric vector (Note 4) Returned elong : Longitude (radians, east +ve) phi : Latitude (geodetic, radians) height : Height above ellipsoid (geodetic, Note 4) Notes This function is based on the GCONV2H Fortran subroutine by Toshio Fukushima (see reference). The equatorial radius, a, can be in any units, but meters is the conventional choice. The flattening, f, is (for the Earth) a value around 0.00335, i.e. around 1/298. The equatorial radius, a, and the geocentric vector, xyz, must be given in the same units, and determine the units of the returned height, height. If an error occurs (status < 0), elong, phi and height are unchanged. The inverse transformation is performed in the function  gd2gce . The transformation for a standard ellipsoid (such as  WGS84 ) can more conveniently be performed by calling  gc2gd , which uses a numerical code to identify the required A and F values. Reference Fukushima, T., \"Transformation from Cartesian to geodetic   coordinates accelerated by Halley's method\", J.Geodesy (2006)   79: 689-693 source"},{"id":936,"pagetitle":"Functions","title":"ERFA.gd2gc","ref":"/ERFA/stable/api/functions/#ERFA.gd2gc-NTuple{4, Any}","content":" ERFA.gd2gc  —  Method gd2gc(n, elong, phi, height) Transform geodetic coordinates to geocentric using the specified reference ellipsoid. Given n : Ellipsoid identifier (Note 1) elong : Longitude (radians, east +ve) phi : Latitude (geodetic, radians, Note 3) height : Height above ellipsoid (geodetic, Notes 2,3) Returned xyz : Geocentric vector (Note 2) Notes The identifier n is a number that specifies the choice of reference ellipsoid.  The following are supported: n ellipsoid 1 WGS84 2 GRS80 3 WGS72 The n value has no significance outside the ERFA software.  For convenience, the  Ellipsoid  enum provides these values. The height (height, given) and the geocentric vector (xyz, returned) are in meters. No validation is performed on the arguments elong, phi and height.  An error status -1 means that the identifier n is illegal.  An error status -2 protects against cases that would lead to arithmetic exceptions.  In all error cases, xyz is set to zeros. The inverse transformation is performed in the function  gc2gd . Called eform : Earth reference ellipsoids gd2gce : geodetic to geocentric transformation, general zp : zero p-vector source"},{"id":937,"pagetitle":"Functions","title":"ERFA.gd2gce","ref":"/ERFA/stable/api/functions/#ERFA.gd2gce-NTuple{5, Any}","content":" ERFA.gd2gce  —  Method gd2gce(a, f, elong, phi, height) Transform geodetic coordinates to geocentric for a reference ellipsoid of specified form. Given a : Equatorial radius (Notes 1,4) f : Flattening (Notes 2,4) elong : Longitude (radians, east +ve) phi : Latitude (geodetic, radians, Note 4) height : Height above ellipsoid (geodetic, Notes 3,4) Returned xyz : Geocentric vector (Note 3) Notes The equatorial radius, a, can be in any units, but meters is the conventional choice. The flattening, f, is (for the Earth) a value around 0.00335, i.e. around 1/298. The equatorial radius, a, and the height, height, must be given in the same units, and determine the units of the returned geocentric vector, xyz. No validation is performed on individual arguments.  The error status -1 protects against (unrealistic) cases that would lead to arithmetic exceptions.  If an error occurs, xyz is unchanged. The inverse transformation is performed in the function  gc2gde . The transformation for a standard ellipsoid (such as  WGS84 ) can more conveniently be performed by calling  gd2gc ,  which uses a numerical code to identify the required a and f values. References Green, R.M., Spherical Astronomy, Cambridge University Press,   (1985) Section 4.5, p96. Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992),   Section 4.22, p202. source"},{"id":938,"pagetitle":"Functions","title":"ERFA.gmst00","ref":"/ERFA/stable/api/functions/#ERFA.gmst00","content":" ERFA.gmst00  —  Function gmst00(uta, utb, tta, ttb) Greenwich mean sidereal time (model consistent with IAU 2000 resolutions). Given uta ,  utb : UT1 as a 2-part Julian Date (Notes 1,2) tta ,  ttb : TT as a 2-part Julian Date (Notes 1,2) Returned Greenwich mean sidereal time (radians) Notes The UT1 and TT dates uta+utb and tta+ttb respectively, are both Julian Dates, apportioned in any convenient way between the argument pairs.  For example, JD=2450123.7 could be expressed in any of these ways, among others: Part A Part B Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable (in the case of UT;  the TT is not at all critical in this respect).  The J2000 and MJD methods are good compromises between resolution and convenience.  For UT, the date & time method is best matched to the algorithm that is used by the Earth Rotation Angle function, called internally:  maximum precision is delivered when the uta argument is for 0hrs UT1 on the day in question and the utb argument lies in the range 0 to 1, or vice versa. Both UT1 and TT are required, UT1 to predict the Earth rotation and TT to predict the effects of precession.  If UT1 is used for both purposes, errors of order 100 microarcseconds result. This GMST is compatible with the IAU 2000 resolutions and must be used only in conjunction with other IAU 2000 compatible components such as precession-nutation and equation of the equinoxes. The result is returned in the range 0 to 2pi. The algorithm is from Capitaine et al. (2003) and IERS Conventions 2003. Called era00 : Earth rotation angle, IAU 2000 anp : normalize angle into range 0 to 2pi References Capitaine, N., Wallace, P.T. and McCarthy, D.D., \"Expressions to   implement the IAU 2000 definition of UT1\", Astronomy &   Astrophysics, 406, 1135-1149 (2003) McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":939,"pagetitle":"Functions","title":"ERFA.gmst06","ref":"/ERFA/stable/api/functions/#ERFA.gmst06","content":" ERFA.gmst06  —  Function gmst06(uta, utb, tta, ttb) Greenwich mean sidereal time (consistent with IAU 2006 precession). Given uta ,  utb : UT1 as a 2-part Julian Date (Notes 1,2) tta ,  ttb : TT as a 2-part Julian Date (Notes 1,2) Returned Greenwich mean sidereal time (radians) Notes The UT1 and TT dates uta+utb and tta+ttb respectively, are both Julian Dates, apportioned in any convenient way between the argument pairs.  For example, JD=2450123.7 could be expressed in any of these ways, among others: Part A Part B Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable (in the case of UT;  the TT is not at all critical in this respect).  The J2000 and MJD methods are good compromises between resolution and convenience.  For UT, the date & time method is best matched to the algorithm that is used by the Earth rotation angle function, called internally:  maximum precision is delivered when the uta argument is for 0hrs UT1 on the day in question and the utb argument lies in the range 0 to 1, or vice versa. Both UT1 and TT are required, UT1 to predict the Earth rotation and TT to predict the effects of precession.  If UT1 is used for both purposes, errors of order 100 microarcseconds result. This GMST is compatible with the IAU 2006 precession and must not be used with other precession models. The result is returned in the range 0 to 2pi. Called era00 : Earth rotation angle, IAU 2000 anp : normalize angle into range 0 to 2pi Reference Capitaine, N., Wallace, P.T. & Chapront, J., 2005,   Astron.Astrophys. 432, 355 source"},{"id":940,"pagetitle":"Functions","title":"ERFA.gmst82","ref":"/ERFA/stable/api/functions/#ERFA.gmst82","content":" ERFA.gmst82  —  Function gmst82(dj1, dj2) Universal Time to Greenwich mean sidereal time (IAU 1982 model). Given dj1 ,  dj2 : UT1 Julian Date (see note) Returned Greenwich mean sidereal time (radians) Notes The UT1 date dj1+dj2 is a Julian Date, apportioned in any convenient way between the arguments dj1 and dj2.  For example, JD(UT1)=2450123.7 could be expressed in any of these ways, among others: dj1 dj2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 and MJD methods are good compromises between resolution and convenience.  The date & time method is best matched to the algorithm used:  maximum accuracy (or, at least, minimum noise) is delivered when the dj1 argument is for 0hrs UT1 on the day in question and the dj2 argument lies in the range 0 to 1, or vice versa. The algorithm is based on the IAU 1982 expression.  This is always described as giving the GMST at 0 hours UT1.  In fact, it gives the difference between the GMST and the UT, the steady 4-minutes-per-day drawing-ahead of ST with respect to UT.  When whole days are ignored, the expression happens to equal the GMST at 0 hours UT1 each day. In this function, the entire UT1 (the sum of the two arguments dj1 and dj2) is used directly as the argument for the standard formula, the constant term of which is adjusted by 12 hours to take account of the noon phasing of Julian Date.  The UT1 is then added, but omitting whole days to conserve accuracy. Called anp : normalize angle into range 0 to 2pi References Transactions of the International Astronomical Union,   XVIII B, 67 (1983). Aoki et al., Astron. Astrophys. 105, 359-361 (1982). source"},{"id":941,"pagetitle":"Functions","title":"ERFA.gst00a","ref":"/ERFA/stable/api/functions/#ERFA.gst00a","content":" ERFA.gst00a  —  Function gst00a(uta, utb, tta, ttb) Greenwich apparent sidereal time (consistent with IAU 2000 resolutions). Given uta ,  utb : UT1 as a 2-part Julian Date (Notes 1,2) tta ,  ttb : TT as a 2-part Julian Date (Notes 1,2) Returned Greenwich apparent sidereal time (radians) Notes The UT1 and TT dates uta+utb and tta+ttb respectively, are both Julian Dates, apportioned in any convenient way between the argument pairs.  For example, JD=2450123.7 could be expressed in any of these ways, among others: Part A Part B Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable (in the case of UT;  the TT is not at all critical in this respect).  The J2000 and MJD methods are good compromises between resolution and convenience.  For UT, the date & time method is best matched to the algorithm that is used by the Earth Rotation Angle function, called internally:  maximum precision is delivered when the uta argument is for 0hrs UT1 on the day in question and the utb argument lies in the range 0 to 1, or vice versa. Both UT1 and TT are required, UT1 to predict the Earth rotation and TT to predict the effects of precession-nutation.  If UT1 is used for both purposes, errors of order 100 microarcseconds result. This GAST is compatible with the IAU 2000 resolutions and must be used only in conjunction with other IAU 2000 compatible components such as precession-nutation. The result is returned in the range 0 to 2pi. The algorithm is from Capitaine et al. (2003) and IERS Conventions 2003. Called gmst00 : Greenwich mean sidereal time, IAU 2000 ee00a : equation of the equinoxes, IAU 2000A anp : normalize angle into range 0 to 2pi References Capitaine, N., Wallace, P.T. and McCarthy, D.D., \"Expressions to   implement the IAU 2000 definition of UT1\", Astronomy &   Astrophysics, 406, 1135-1149 (2003) McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":942,"pagetitle":"Functions","title":"ERFA.gst00b","ref":"/ERFA/stable/api/functions/#ERFA.gst00b","content":" ERFA.gst00b  —  Function gst00b(dr, dd) Greenwich apparent sidereal time (consistent with IAU 2000 resolutions but using the truncated nutation model IAU 2000B). Given uta ,  utb : UT1 as a 2-part Julian Date (Notes 1,2) Returned Greenwich apparent sidereal time (radians) Notes The UT1 date uta+utb is a Julian Date, apportioned in any convenient way between the argument pair.  For example, JD=2450123.7 could be expressed in any of these ways, among others: uta utb Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 and MJD methods are good compromises between resolution and convenience.  For UT, the date & time method is best matched to the algorithm that is used by the Earth Rotation Angle function, called internally:  maximum precision is delivered when the uta argument is for 0hrs UT1 on the day in question and the utb argument lies in the range 0 to 1, or vice versa. The result is compatible with the IAU 2000 resolutions, except that accuracy has been compromised for the sake of speed and convenience in two respects: UT is used instead of TDB (or TT) to compute the precession component of GMST and the equation of the equinoxes.  This results in errors of order 0.1 mas at present. The IAU 2000B abridged nutation model (McCarthy & Luzum, 2001) is used, introducing errors of up to 1 mas. This GAST is compatible with the IAU 2000 resolutions and must be used only in conjunction with other IAU 2000 compatible components such as precession-nutation. The result is returned in the range 0 to 2pi. The algorithm is from Capitaine et al. (2003) and IERS Conventions 2003. Called gmst00 : Greenwich mean sidereal time, IAU 2000 ee00b : equation of the equinoxes, IAU 2000B anp : normalize angle into range 0 to 2pi References Capitaine, N., Wallace, P.T. and McCarthy, D.D., \"Expressions to   implement the IAU 2000 definition of UT1\", Astronomy &   Astrophysics, 406, 1135-1149 (2003) McCarthy, D.D. & Luzum, B.J., \"An abridged model of the   precession-nutation of the celestial pole\", Celestial Mechanics &   Dynamical Astronomy, 85, 37-49 (2003) McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":943,"pagetitle":"Functions","title":"ERFA.gst06","ref":"/ERFA/stable/api/functions/#ERFA.gst06-NTuple{5, Any}","content":" ERFA.gst06  —  Method gst06(uta, utb, tta, ttb, rnpb) Greenwich apparent sidereal time, IAU 2006, given the NPB matrix. Given uta ,  utb : UT1 as a 2-part Julian Date (Notes 1,2) tta ,  ttb : TT as a 2-part Julian Date (Notes 1,2) rnpb : Nutation x precession x bias matrix Returned Greenwich apparent sidereal time (radians) Notes The UT1 and TT dates uta+utb and tta+ttb respectively, are both Julian Dates, apportioned in any convenient way between the argument pairs.  For example, JD=2450123.7 could be expressed in any of these ways, among others: Part A Part B Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable (in the case of UT;  the TT is not at all critical in this respect).  The J2000 and MJD methods are good compromises between resolution and convenience.  For UT, the date & time method is best matched to the algorithm that is used by the Earth rotation angle function, called internally:  maximum precision is delivered when the uta argument is for 0hrs UT1 on the day in question and the utb argument lies in the range 0 to 1, or vice versa. Both UT1 and TT are required, UT1 to predict the Earth rotation and TT to predict the effects of precession-nutation.  If UT1 is used for both purposes, errors of order 100 microarcseconds result. Although the function uses the IAU 2006 series for s+XY/2, it is otherwise independent of the precession-nutation model and can in practice be used with any equinox-based NPB matrix. The result is returned in the range 0 to 2pi. Called bpn2xy : extract CIP X,Y coordinates from NPB matrix s06 : the CIO locator s, given X,Y, IAU 2006 anp : normalize angle into range 0 to 2pi era00 : Earth rotation angle, IAU 2000 eors : equation of the origins, given NPB matrix and s Reference Wallace, P.T. & Capitaine, N., 2006, Astron.Astrophys. 459, 981 source"},{"id":944,"pagetitle":"Functions","title":"ERFA.gst06a","ref":"/ERFA/stable/api/functions/#ERFA.gst06a","content":" ERFA.gst06a  —  Function gst06a(uta, utb, tta, ttb) Greenwich apparent sidereal time (consistent with IAU 2000 and 2006 resolutions). Given uta ,  utb : UT1 as a 2-part Julian Date (Notes 1,2) tta ,  ttb : TT as a 2-part Julian Date (Notes 1,2) Returned Greenwich apparent sidereal time (radians) Notes The UT1 and TT dates uta+utb and tta+ttb respectively, are both Julian Dates, apportioned in any convenient way between the argument pairs.  For example, JD=2450123.7 could be expressed in any of these ways, among others: Part A Part B Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable (in the case of UT;  the TT is not at all critical in this respect).  The J2000 and MJD methods are good compromises between resolution and convenience.  For UT, the date & time method is best matched to the algorithm that is used by the Earth rotation angle function, called internally:  maximum precision is delivered when the uta argument is for 0hrs UT1 on the day in question and the utb argument lies in the range 0 to 1, or vice versa. Both UT1 and TT are required, UT1 to predict the Earth rotation and TT to predict the effects of precession-nutation.  If UT1 is used for both purposes, errors of order 100 microarcseconds result. This GAST is compatible with the IAU 2000/2006 resolutions and must be used only in conjunction with IAU 2006 precession and IAU 2000A nutation. The result is returned in the range 0 to 2pi. Called pnm06a : classical NPB matrix, IAU 2006/2000A gst06 : Greenwich apparent ST, IAU 2006, given NPB matrix Reference Wallace, P.T. & Capitaine, N., 2006, Astron.Astrophys. 459, 981 source"},{"id":945,"pagetitle":"Functions","title":"ERFA.gst94","ref":"/ERFA/stable/api/functions/#ERFA.gst94","content":" ERFA.gst94  —  Function gst94(dr, dd) Greenwich apparent sidereal time (consistent with IAU 1982/94 resolutions). Given uta ,  utb : UT1 as a 2-part Julian Date (Notes 1,2) Returned Greenwich apparent sidereal time (radians) Notes The UT1 date uta+utb is a Julian Date, apportioned in any convenient way between the argument pair.  For example, JD=2450123.7 could be expressed in any of these ways, among others: uta utb Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 and MJD methods are good compromises between resolution and convenience.  For UT, the date & time method is best matched to the algorithm that is used by the Earth Rotation Angle function, called internally:  maximum precision is delivered when the uta argument is for 0hrs UT1 on the day in question and the utb argument lies in the range 0 to 1, or vice versa. The result is compatible with the IAU 1982 and 1994 resolutions, except that accuracy has been compromised for the sake of convenience in that UT is used instead of TDB (or TT) to compute the equation of the equinoxes. This GAST must be used only in conjunction with contemporaneous IAU standards such as 1976 precession, 1980 obliquity and 1982 nutation.  It is not compatible with the IAU 2000 resolutions. The result is returned in the range 0 to 2pi. Called gmst82 : Greenwich mean sidereal time, IAU 1982 eqeq94 : equation of the equinoxes, IAU 1994 anp : normalize angle into range 0 to 2pi References Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992) IAU Resolution C7, Recommendation 3 (1994) source"},{"id":946,"pagetitle":"Functions","title":"ERFA.h2fk5","ref":"/ERFA/stable/api/functions/#ERFA.h2fk5-NTuple{6, Any}","content":" ERFA.h2fk5  —  Method h2fk5(ra, dec, dra, ddec, px, rv) Transform Hipparcos star data into the FK5 (J2000.0) system. Given (all Hipparcos, epoch J2000.0) rh : RA (radians) dh : Dec (radians) drh : Proper motion in RA (dRA/dt, rad/Jyear) ddh : Proper motion in Dec (dDec/dt, rad/Jyear) pxh : Parallax (arcsec) rvh : Radial velocity (km/s, positive = receding) Returned (all FK5, equinox J2000.0, epoch J2000.0) r5 : RA (radians) d5 : Dec (radians) dr5 : Proper motion in RA (dRA/dt, rad/Jyear) dd5 : Proper motion in Dec (dDec/dt, rad/Jyear) px5 : Parallax (arcsec) rv5 : Radial velocity (km/s, positive = receding) Notes This function transforms Hipparcos star positions and proper motions into FK5 J2000.0. The proper motions in RA are dRA/dt rather than cos(Dec)*dRA/dt, and are per year rather than per century. The FK5 to Hipparcos transformation is modeled as a pure rotation and spin;  zonal errors in the FK5 catalog are not taken into account. See also  fk52h ,  fk5hz ,  hfk5z . Called starpv : star catalog data to space motion pv-vector fk5hip : FK5 to Hipparcos rotation and spin rv2m : r-vector to r-matrix rxp : product of r-matrix and p-vector trxp : product of transpose of r-matrix and p-vector pxp : vector product of two p-vectors pmp : p-vector minus p-vector pvstar : space motion pv-vector to star catalog data Reference F.Mignard & M.Froeschle, Astron. Astrophys. 354, 732-739 (2000). source"},{"id":947,"pagetitle":"Functions","title":"ERFA.hd2ae","ref":"/ERFA/stable/api/functions/#ERFA.hd2ae-Tuple{Any, Any, Any}","content":" ERFA.hd2ae  —  Method hd2ae(h, d, p) Equatorial to horizon coordinates:  transform hour angle and declination to azimuth and altitude. Given ha : hour angle (local) dec : declination phi : site latitude Returned az : azimuth el : altitude (informally, elevation) Notes All the arguments are angles in radians. Azimuth is returned in the range 0-2pi;  north is zero, and east is +pi/2.  Altitude is returned in the range +/- pi/2. The latitude phi is pi/2 minus the angle between the Earth's rotation axis and the adopted zenith.  In many applications it will be sufficient to use the published geodetic latitude of the site.  In very precise (sub-arcsecond) applications, phi can be corrected for polar motion. The returned azimuth az is with respect to the rotational north pole, as opposed to the ITRS pole, and for sub-arcsecond accuracy will need to be adjusted for polar motion if it is to be with respect to north on a map of the Earth's surface. Should the user wish to work with respect to the astronomical zenith rather than the geodetic zenith, phi will need to be adjusted for deflection of the vertical (often tens of arcseconds), and the zero point of the hour angle ha will also be affected. The transformation is the same as Vh = Rz(pi) Ry(pi/2-phi) Ve, where Vh and Ve are lefthanded unit vectors in the (az,el) and (ha,dec) systems respectively and Ry and Rz are rotations about first the y-axis and then the z-axis.  (n.b. Rz(pi) simply reverses the signs of the x and y components.)  For efficiency, the algorithm is written out rather than calling other utility functions.  For applications that require even greater efficiency, additional savings are possible if constant terms such as functions of latitude are computed once and for all. Again for efficiency, no range checking of arguments is carried out. source"},{"id":948,"pagetitle":"Functions","title":"ERFA.hd2pa","ref":"/ERFA/stable/api/functions/#ERFA.hd2pa-Tuple{Any, Any, Any}","content":" ERFA.hd2pa  —  Method hd2pa(h, d, p) Parallactic angle for a given hour angle and declination. Given ha : hour angle dec : declination phi : site latitude Returned Returns the parallactic angle Notes All the arguments are angles in radians. The parallactic angle at a point in the sky is the position angle of the vertical, i.e. the angle between the directions to the north celestial pole and to the zenith respectively. The result is returned in the range -pi to +pi. At the pole itself a zero result is returned. The latitude phi is pi/2 minus the angle between the Earth's rotation axis and the adopted zenith.  In many applications it will be sufficient to use the published geodetic latitude of the site.  In very precise (sub-arcsecond) applications, phi can be corrected for polar motion. Should the user wish to work with respect to the astronomical zenith rather than the geodetic zenith, phi will need to be adjusted for deflection of the vertical (often tens of arcseconds), and the zero point of the hour angle ha will also be affected. Reference Smart, W.M., \"Spherical Astronomy\", Cambridge University Press, 6th edition (Green, 1977), p49. source"},{"id":949,"pagetitle":"Functions","title":"ERFA.hfk5z","ref":"/ERFA/stable/api/functions/#ERFA.hfk5z-NTuple{4, Any}","content":" ERFA.hfk5z  —  Method hfk5z(rh, dh, date1, date2) Transform a Hipparcos star position into FK5 J2000.0, assuming zero Hipparcos proper motion. Given rh : Hipparcos RA (radians) dh : Hipparcos Dec (radians) date1 ,  date2 : TDB date (Note 1) Returned (all FK5, equinox J2000.0, date date1+date2) r5 : RA (radians) d5 : Dec (radians) dr5 : FK5 RA proper motion (rad/year, Note 4) dd5 : Dec proper motion (rad/year, Note 4) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The proper motion in RA is dRA/dt rather than cos(Dec)*dRA/dt. The FK5 to Hipparcos transformation is modeled as a pure rotation and spin;  zonal errors in the FK5 catalogue are not taken into account. It was the intention that Hipparcos should be a close approximation to an inertial frame, so that distant objects have zero proper motion;  such objects have (in general) non-zero proper motion in FK5, and this function returns those fictitious proper motions. The position returned by this function is in the FK5 J2000.0 reference system but at date date1+date2. See also  fk52h ,  h2fk5 ,  fk5hz . Called s2c : spherical coordinates to unit vector fk5hip : FK5 to Hipparcos rotation and spin rxp : product of r-matrix and p-vector sxp : multiply p-vector by scalar rxr : product of two r-matrices trxp : product of transpose of r-matrix and p-vector pxp : vector product of two p-vectors pv2s : pv-vector to spherical anp : normalize angle into range 0 to 2pi Reference F.Mignard & M.Froeschle, 2000, Astron.Astrophys. 354, 732-739. source"},{"id":950,"pagetitle":"Functions","title":"ERFA.icrs2g","ref":"/ERFA/stable/api/functions/#ERFA.icrs2g-Tuple{Any, Any}","content":" ERFA.icrs2g  —  Method icrs2g(dr, dd) Transformation from ICRS to Galactic Coordinates. Given dr : ICRS right ascension (radians) dd : ICRS declination (radians) Returned dl : Galactic longitude (radians) db : Galactic latitude (radians) Notes The IAU 1958 system of Galactic coordinates was defined with respect to the now obsolete reference system FK4 B1950.0.  When interpreting the system in a modern context, several factors have to be taken into account: The inclusion in FK4 positions of the E-terms of aberration. The distortion of the FK4 proper motion system by differential Galactic rotation. The use of the B1950.0 equinox rather than the now-standard J2000.0. The frame bias between ICRS and the J2000.0 mean place system. The Hipparcos Catalogue (Perryman & ESA 1997) provides a rotation matrix that transforms directly between ICRS and Galactic coordinates with the above factors taken into account.  The matrix is derived from three angles, namely the ICRS coordinates of the Galactic pole and the longitude of the ascending node of the galactic equator on the ICRS equator.  They are given in degrees to five decimal places and for canonical purposes are regarded as exact.  In the Hipparcos Catalogue the matrix elements are given to 10 decimal places (about 20 microarcsec). In the present ERFA function the matrix elements have been recomputed from the canonical three angles and are given to 30 decimal places. The inverse transformation is performed by the function  g2icrs . Called anp : normalize angle into range 0 to 2pi anpm : normalize angle into range +/- pi s2c : spherical coordinates to unit vector rxp : product of r-matrix and p-vector c2s : p-vector to spherical Reference Perryman M.A.C. & ESA, 1997, ESA SP-1200, The Hipparcos and Tycho   catalogues.  Astrometric and photometric star catalogues   derived from the ESA Hipparcos Space Astrometry Mission.  ESA   Publications Division, Noordwijk, Netherlands. source"},{"id":951,"pagetitle":"Functions","title":"ERFA.ir","ref":"/ERFA/stable/api/functions/#ERFA.ir","content":" ERFA.ir  —  Function ir() Initialize an r-matrix to the identity matrix. Deprecated Use  Array{Float64}(LinearAlgebra.I, 3, 3)  instead. Returned r : r-matrix source"},{"id":952,"pagetitle":"Functions","title":"ERFA.jd2cal","ref":"/ERFA/stable/api/functions/#ERFA.jd2cal-Tuple{Any, Any}","content":" ERFA.jd2cal  —  Method jd2cal(dj1, dj2) Julian Date to Gregorian year, month, day, and fraction of a day. Given dj1 ,  dj2 : Julian Date (Notes 1, 2) Returned iy : Year im : Month id : Day fd : Fraction of day Notes The earliest valid date is -68569.5 (-4900 March 1).  The largest value accepted is 1e9. The Julian Date is apportioned in any convenient way between the arguments dj1 and dj2.  For example, JD=2450123.7 could be expressed in any of these ways, among others: dj1 dj2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time In early eras the conversion is from the \"proleptic Gregorian calendar\";  no account is taken of the date(s) of adoption of the Gregorian calendar, nor is the AD/BC numbering convention observed. Reference Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992),   Section 12.92 (p604). source"},{"id":953,"pagetitle":"Functions","title":"ERFA.jdcalf","ref":"/ERFA/stable/api/functions/#ERFA.jdcalf-Tuple{Any, Any, Any}","content":" ERFA.jdcalf  —  Method jdcalf(ndp, dj1, dj2) Julian Date to Gregorian Calendar, expressed in a form convenient for formatting messages:  rounded to a specified precision. Given ndp : Number of decimal places of days in fraction dj1 ,  dj2 : Dj1+dj2 = Julian Date (Note 1) Returned iymdf : Year, month, day, fraction in Gregorian calendar Notes The Julian Date is apportioned in any convenient way between the arguments dj1 and dj2.  For example, JD=2450123.7 could be expressed in any of these ways, among others: dj1 dj2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time In early eras the conversion is from the \"Proleptic Gregorian Calendar\";  no account is taken of the date(s) of adoption of the Gregorian Calendar, nor is the AD/BC numbering convention observed. Refer to the function  jd2cal . NDP should be 4 or less if internal overflows are to be avoided on machines which use 16-bit integers. Called jd2cal : JD to Gregorian calendar Reference Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992),   Section 12.92 (p604). source"},{"id":954,"pagetitle":"Functions","title":"ERFA.ld","ref":"/ERFA/stable/api/functions/#ERFA.ld-NTuple{6, Any}","content":" ERFA.ld  —  Method ld(bm, p, q, e, em, dlim) Apply light deflection by a solar-system body, as part of transforming coordinate direction into natural direction. Given bm : Mass of the gravitating body (solar masses) p : Direction from observer to source (unit vector) q : Direction from body to source (unit vector) e : Direction from body to observer (unit vector) em : Distance from body to observer (au) dlim : Deflection limiter (Note 4) Returned p1 : Observer to deflected source (unit vector) Notes The algorithm is based on Expr. (70) in Klioner (2003) and Expr. (7.63) in the Explanatory Supplement (Urban & Seidelmann 2013), with some rearrangement to minimize the effects of machine precision. The mass parameter bm can, as required, be adjusted in order to allow for such effects as quadrupole field. The barycentric position of the deflecting body should ideally correspond to the time of closest approach of the light ray to the body. The deflection limiter parameter dlim is phi^2/2, where phi is the angular separation (in radians) between source and body at which limiting is applied.  As phi shrinks below the chosen threshold, the deflection is artificially reduced, reaching zero for phi = 0. The returned vector p1 is not normalized, but the consequential departure from unit magnitude is always negligible. The arguments p and p1 can be the same array. To accumulate total light deflection taking into account the contributions from several bodies, call the present function for each body in succession, in decreasing order of distance from the observer. For efficiency, validation is omitted.  The supplied vectors must be of unit magnitude, and the deflection limiter non-zero and positive. References Urban, S. & Seidelmann, P. K. (eds), Explanatory Supplement to   the Astronomical Almanac, 3rd ed., University Science Books   (2013). Klioner, Sergei A., \"A practical relativistic model for micro-   arcsecond astrometry in space\", Astr. J. 125, 1580-1597 (2003). Called pdp : scalar product of two p-vectors pxp : vector product of two p-vectors source"},{"id":955,"pagetitle":"Functions","title":"ERFA.ldn","ref":"/ERFA/stable/api/functions/#ERFA.ldn-Tuple{Vector{ERFA.LDBODY}, Any, Any}","content":" ERFA.ldn  —  Method ldn(l::Vector{LDBODY}, ob, sc) For a star, apply light deflection by multiple solar-system bodies, as part of transforming coordinate direction into natural direction. Given n : Number of bodies (note 1) b : Data for each of the n bodies (Notes 1,2): bm : Mass of the body (solar masses, Note 3) dl : Deflection limiter (Note 4) pv : Barycentric PV of the body (au, au/day) ob : Barycentric position of the observer (au) sc : Observer to star coord direction (unit vector) Returned sn : Observer to deflected star (unit vector) The array b contains n entries, one for each body to be considered.  If n = 0, no gravitational light deflection will be applied, not even for the Sun. The array b should include an entry for the Sun as well as for any planet or other body to be taken into account.  The entries should be in the order in which the light passes the body. In the entry in the b array for body i, the mass parameter b[i].bm can, as required, be adjusted in order to allow for such effects as quadrupole field. The deflection limiter parameter b[i].dl is phi^2/2, where phi is the angular separation (in radians) between star and body at which limiting is applied.  As phi shrinks below the chosen threshold, the deflection is artificially reduced, reaching zero for phi = 0.   Example values suitable for a terrestrial observer, together with masses, are as follows: body i b[i].bm b[i].dl Sun 1.0 6e-6 Jupiter 0.00095435 3e-9 Saturn 0.00028574 3e-10 For cases where the starlight passes the body before reaching the observer, the body is placed back along its barycentric track by the light time from that point to the observer.  For cases where the body is \"behind\" the observer no such shift is applied.  If a different treatment is preferred, the user has the option of instead using the  ld  function.  Similarly,  ld  can be used for cases where the source is nearby, not a star. The returned vector sn is not normalized, but the consequential departure from unit magnitude is always negligible. The arguments sc and sn can be the same array. For efficiency, validation is omitted.  The supplied masses must be greater than zero, the position and velocity vectors must be right, and the deflection limiter greater than zero. Reference Urban, S. & Seidelmann, P. K. (eds), Explanatory Supplement to   the Astronomical Almanac, 3rd ed., University Science Books   (2013), Section 7.2.4. Called erfa_cp : copy p-vector pdp : scalar product of two p-vectors pmp : p-vector minus p-vector ppsp : p-vector plus scaled p-vector pn : decompose p-vector into modulus and direction ld : light deflection by a solar-system body source"},{"id":956,"pagetitle":"Functions","title":"ERFA.ldsun","ref":"/ERFA/stable/api/functions/#ERFA.ldsun-Tuple{Any, Any, Any}","content":" ERFA.ldsun  —  Method ldsun(p, e, em) Deflection of starlight by the Sun. Given p : Direction from observer to star (unit vector) e : Direction from Sun to observer (unit vector) em : Distance from Sun to observer (au) Returned p1 : Observer to deflected star (unit vector) Notes The source is presumed to be sufficiently distant that its directions seen from the Sun and the observer are essentially the same. The deflection is restrained when the angle between the star and the center of the Sun is less than a threshold value, falling to zero deflection for zero separation.  The chosen threshold value is within the solar limb for all solar-system applications, and is about 5 arcminutes for the case of a terrestrial observer. The arguments p and p1 can be the same array. Called ld : light deflection by a solar-system body source"},{"id":957,"pagetitle":"Functions","title":"ERFA.lteceq","ref":"/ERFA/stable/api/functions/#ERFA.lteceq","content":" ERFA.lteceq  —  Function lteceq(epj, dr, dd) Transformation from ecliptic coordinates (mean equinox and ecliptic of date) to ICRS RA,Dec, using a long-term precession model. Given epj : Julian epoch (TT) dl ,  db : Ecliptic longitude and latitude (radians) Returned dr ,  dd : ICRS right ascension and declination (radians) No assumptions are made about whether the coordinates represent starlight and embody astrometric effects such as parallax or aberration. The transformation is approximately that from ecliptic longitude and latitude (mean equinox and ecliptic of date) to mean J2000.0 right ascension and declination, with only frame bias (always less than 25 mas) to disturb this classical picture. The Vondrak et al. (2011, 2012) 400 millennia precession model agrees with the IAU 2006 precession at J2000.0 and stays within 100 microarcseconds during the 20th and 21st centuries.  It is accurate to a few arcseconds throughout the historical period, worsening to a few tenths of a degree at the end of the +/- 200,000 year time span. Called s2c : spherical coordinates to unit vector ltecm : J2000.0 to ecliptic rotation matrix, long term trxp : product of transpose of r-matrix and p-vector c2s : unit vector to spherical coordinates anp : normalize angle into range 0 to 2pi anpm : normalize angle into range +/- pi References Vondrak, J., Capitaine, N. and Wallace, P., 2011, New precession   expressions, valid for long time intervals, Astron.Astrophys. 534,   A22 Vondrak, J., Capitaine, N. and Wallace, P., 2012, New precession   expressions, valid for long time intervals (Corrigendum),   Astron.Astrophys. 541, C1 source"},{"id":958,"pagetitle":"Functions","title":"ERFA.ltecm","ref":"/ERFA/stable/api/functions/#ERFA.ltecm","content":" ERFA.ltecm  —  Function ltecm(dr, dd) ICRS equatorial to ecliptic rotation matrix, long-term. Given epj : Julian epoch (TT) Returned rm : ICRS to ecliptic rotation matrix Notes The matrix is in the sense E_ep = rm x P_ICRS, where  P_ICRS  is a vector with respect to ICRS right ascension and declination axes and  E_ep  is the same vector with respect to the (inertial) ecliptic and equinox of epoch epj. P_ICRS  is a free vector, merely a direction, typically of unit magnitude, and not bound to any particular spatial origin, such as the Earth, Sun or SSB.  No assumptions are made about whether it represents starlight and embodies astrometric effects such as parallax or aberration.  The transformation is approximately that between mean J2000.0 right ascension and declination and ecliptic longitude and latitude, with only frame bias (always less than 25 mas) to disturb this classical picture. The Vondrak et al. (2011, 2012) 400 millennia precession model agrees with the IAU 2006 precession at J2000.0 and stays within 100 microarcseconds during the 20th and 21st centuries.  It is accurate to a few arcseconds throughout the historical period, worsening to a few tenths of a degree at the end of the +/- 200,000 year time span. Called ltpequ : equator pole, long term ltpecl : ecliptic pole, long term pxp : vector product pn : normalize vector References Vondrak, J., Capitaine, N. and Wallace, P., 2011, New precession   expressions, valid for long time intervals, Astron.Astrophys. 534,   A22 Vondrak, J., Capitaine, N. and Wallace, P., 2012, New precession   expressions, valid for long time intervals (Corrigendum),   Astron.Astrophys. 541, C1 source"},{"id":959,"pagetitle":"Functions","title":"ERFA.lteqec","ref":"/ERFA/stable/api/functions/#ERFA.lteqec","content":" ERFA.lteqec  —  Function lteqec(epj, dr, dd) Transformation from ICRS equatorial coordinates to ecliptic coordinates (mean equinox and ecliptic of date) using a long-term precession model. Given epj : Julian epoch (TT) dr ,  dd : ICRS right ascension and declination (radians) Returned dl ,  db : Ecliptic longitude and latitude (radians) No assumptions are made about whether the coordinates represent starlight and embody astrometric effects such as parallax or aberration. The transformation is approximately that from mean J2000.0 right ascension and declination to ecliptic longitude and latitude (mean equinox and ecliptic of date), with only frame bias (always less than 25 mas) to disturb this classical picture. The Vondrak et al. (2011, 2012) 400 millennia precession model agrees with the IAU 2006 precession at J2000.0 and stays within 100 microarcseconds during the 20th and 21st centuries.  It is accurate to a few arcseconds throughout the historical period, worsening to a few tenths of a degree at the end of the +/- 200,000 year time span. Called s2c : spherical coordinates to unit vector ltecm : J2000.0 to ecliptic rotation matrix, long term rxp : product of r-matrix and p-vector c2s : unit vector to spherical coordinates anp : normalize angle into range 0 to 2pi anpm : normalize angle into range +/- pi References Vondrak, J., Capitaine, N. and Wallace, P., 2011, New precession   expressions, valid for long time intervals, Astron.Astrophys. 534,   A22 Vondrak, J., Capitaine, N. and Wallace, P., 2012, New precession   expressions, valid for long time intervals (Corrigendum),   Astron.Astrophys. 541, C1 source"},{"id":960,"pagetitle":"Functions","title":"ERFA.ltp","ref":"/ERFA/stable/api/functions/#ERFA.ltp","content":" ERFA.ltp  —  Function ltp(dr, dd) Long-term precession matrix. Given epj : Julian epoch (TT) Returned rp : Precession matrix, J2000.0 to date Notes The matrix is in the sense P_date = rp x P_J2000, where  P_J2000  is a vector with respect to the J2000.0 mean equator and equinox and  P_date  is the same vector with respect to the equator and equinox of epoch epj. The Vondrak et al. (2011, 2012) 400 millennia precession model agrees with the IAU 2006 precession at J2000.0 and stays within 100 microarcseconds during the 20th and 21st centuries.  It is accurate to a few arcseconds throughout the historical period, worsening to a few tenths of a degree at the end of the +/- 200,000 year time span. Called ltpequ : equator pole, long term ltpecl : ecliptic pole, long term pxp : vector product pn : normalize vector References Vondrak, J., Capitaine, N. and Wallace, P., 2011, New precession   expressions, valid for long time intervals, Astron.Astrophys. 534,   A22 Vondrak, J., Capitaine, N. and Wallace, P., 2012, New precession   expressions, valid for long time intervals (Corrigendum),   Astron.Astrophys. 541, C1 source"},{"id":961,"pagetitle":"Functions","title":"ERFA.ltpb","ref":"/ERFA/stable/api/functions/#ERFA.ltpb","content":" ERFA.ltpb  —  Function ltpb(dr, dd) Long-term precession matrix, including ICRS frame bias. Given epj : Julian epoch (TT) Returned rpb : Precession-bias matrix, J2000.0 to date Notes The matrix is in the sense P_date = rpb x P_ICRS, where  P_ICRS  is a vector in the Geocentric Celestial Reference System, and  P_date  is the vector with respect to the Celestial Intermediate Reference System at that date but with nutation neglected. A first order frame bias formulation is used, of sub- microarcsecond accuracy compared with a full 3D rotation. The Vondrak et al. (2011, 2012) 400 millennia precession model agrees with the IAU 2006 precession at J2000.0 and stays within 100 microarcseconds during the 20th and 21st centuries.  It is accurate to a few arcseconds throughout the historical period, worsening to a few tenths of a degree at the end of the +/- 200,000 year time span. References Vondrak, J., Capitaine, N. and Wallace, P., 2011, New precession   expressions, valid for long time intervals, Astron.Astrophys. 534,   A22 Vondrak, J., Capitaine, N. and Wallace, P., 2012, New precession   expressions, valid for long time intervals (Corrigendum),   Astron.Astrophys. 541, C1 source"},{"id":962,"pagetitle":"Functions","title":"ERFA.ltpecl","ref":"/ERFA/stable/api/functions/#ERFA.ltpecl","content":" ERFA.ltpecl  —  Function ltpecl(epj) Long-term precession of the ecliptic. Given epj : Julian epoch (TT) Returned vec : Ecliptic pole unit vector Notes The returned vector is with respect to the J2000.0 mean equator and equinox. The Vondrak et al. (2011, 2012) 400 millennia precession model agrees with the IAU 2006 precession at J2000.0 and stays within 100 microarcseconds during the 20th and 21st centuries.  It is accurate to a few arcseconds throughout the historical period, worsening to a few tenths of a degree at the end of the +/- 200,000 year time span. References Vondrak, J., Capitaine, N. and Wallace, P., 2011, New precession   expressions, valid for long time intervals, Astron.Astrophys. 534,   A22 Vondrak, J., Capitaine, N. and Wallace, P., 2012, New precession   expressions, valid for long time intervals (Corrigendum),   Astron.Astrophys. 541, C1 source"},{"id":963,"pagetitle":"Functions","title":"ERFA.ltpequ","ref":"/ERFA/stable/api/functions/#ERFA.ltpequ","content":" ERFA.ltpequ  —  Function ltpequ(epj) Long-term precession of the equator. Given epj : Julian epoch (TT) Returned veq : Equator pole unit vector Notes The returned vector is with respect to the J2000.0 mean equator and equinox. The Vondrak et al. (2011, 2012) 400 millennia precession model agrees with the IAU 2006 precession at J2000.0 and stays within 100 microarcseconds during the 20th and 21st centuries.  It is accurate to a few arcseconds throughout the historical period, worsening to a few tenths of a degree at the end of the +/- 200,000 year time span. References Vondrak, J., Capitaine, N. and Wallace, P., 2011, New precession   expressions, valid for long time intervals, Astron.Astrophys. 534,   A22 Vondrak, J., Capitaine, N. and Wallace, P., 2012, New precession   expressions, valid for long time intervals (Corrigendum),   Astron.Astrophys. 541, C1 source"},{"id":964,"pagetitle":"Functions","title":"ERFA.moon98","ref":"/ERFA/stable/api/functions/#ERFA.moon98-Tuple{Any, Any}","content":" ERFA.moon98  —  Method moon98(date1, date2) Approximate geocentric position and velocity of the Moon. n.b. Not IAU-endorsed and without canonical status. Given date1 : TT date part A (Notes 1,4) date2 : TT date part B (Notes 1,4) Returned pv : Moon p,v, GCRS (AU, AU/d, Note 5) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience.  The limited accuracy of the present algorithm is such that any of the methods is satisfactory. This function is a full implementation of the algorithm published by Meeus (see reference) except that the light-time correction to the Moon's mean longitude has been omitted. Comparisons with ELP/MPP02 over the interval 1950-2100 gave RMS errors of 2.9 arcsec in geocentric direction, 6.1 km in position and 36 mm/s in velocity.  The worst case errors were 18.3 arcsec in geocentric direction, 31.7 km in position and 172 mm/s in velocity. The original algorithm is expressed in terms of \"dynamical time\", which can either be TDB or TT without any significant change in accuracy.  UT cannot be used without incurring significant errors (30 arcsec in the present era) due to the Moon's 0.5 arcsec/sec movement. The result is with respect to the GCRS (the same as J2000.0 mean equator and equinox to within 23 mas). Velocity is obtained by a complete analytical differentiation of the Meeus model. The Meeus algorithm generates position and velocity in mean ecliptic coordinates of date, which the present function then rotates into GCRS.  Because the ecliptic system is precessing, there is a coupling between this spin (about 1.4 degrees per century) and the Moon position that produces a small velocity contribution.  In the present function this effect is neglected as it corresponds to a maximum difference of less than 3 mm/s and increases the RMS error by only 0.4%. References Meeus, J., Astronomical Algorithms, 2nd edition, Willmann-Bell, 1998, p337. Simon, J.L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou, G. & Laskar, J., Astron.Astrophys., 1994, 282, 663 Called s2pv : spherical coordinates to pv-vector pfw06 : bias-precession F-W angles, IAU 2006 ir : initialize r-matrix to identity rz : rotate around Z-axis rx : rotate around X-axis rxpv : product of r-matrix and pv-vector source"},{"id":965,"pagetitle":"Functions","title":"ERFA.num00a","ref":"/ERFA/stable/api/functions/#ERFA.num00a","content":" ERFA.num00a  —  Function num00a(date1, date2) Form the matrix of nutation for a given date, IAU 2000A model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned rmatn : Nutation matrix Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix operates in the sense V(true) = rmatn * V(mean), where the p-vector V(true) is with respect to the true equatorial triad of date and the p-vector V(mean) is with respect to the mean equatorial triad of date. A faster, but slightly less accurate result (about 1 mas), can be obtained by using instead the  num00b  function. Called pn00a : bias/precession/nutation, IAU 2000A Reference Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992),   Section 3.222-3 (p114). source"},{"id":966,"pagetitle":"Functions","title":"ERFA.num00b","ref":"/ERFA/stable/api/functions/#ERFA.num00b","content":" ERFA.num00b  —  Function num00b(date1, date2) Form the matrix of nutation for a given date, IAU 2000B model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned rmatn : Nutation matrix Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix operates in the sense V(true) = rmatn * V(mean), where the p-vector V(true) is with respect to the true equatorial triad of date and the p-vector V(mean) is with respect to the mean equatorial triad of date. The present function is faster, but slightly less accurate (about 1 mas), than the  num00a  function. Called pn00b : bias/precession/nutation, IAU 2000B Reference Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992),   Section 3.222-3 (p114). source"},{"id":967,"pagetitle":"Functions","title":"ERFA.num06a","ref":"/ERFA/stable/api/functions/#ERFA.num06a","content":" ERFA.num06a  —  Function num06a(date1, date2) Form the matrix of nutation for a given date, IAU 2006/2000A model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned rmatn : Nutation matrix Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix operates in the sense V(true) = rmatn * V(mean), where the p-vector V(true) is with respect to the true equatorial triad of date and the p-vector V(mean) is with respect to the mean equatorial triad of date. Called obl06 : mean obliquity, IAU 2006 nut06a : nutation, IAU 2006/2000A numat : form nutation matrix Reference Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992),   Section 3.222-3 (p114). source"},{"id":968,"pagetitle":"Functions","title":"ERFA.numat","ref":"/ERFA/stable/api/functions/#ERFA.numat-Tuple{Any, Any, Any}","content":" ERFA.numat  —  Method numat(epsa, dpsi, deps) Form the matrix of nutation. Given epsa : Mean obliquity of date (Note 1) dpsi ,  deps : Nutation (Note 2) Returned rmatn : Nutation matrix (Note 3) Notes The supplied mean obliquity epsa, must be consistent with the precession-nutation models from which dpsi and deps were obtained. The caller is responsible for providing the nutation components; they are in longitude and obliquity, in radians and are with respect to the equinox and ecliptic of date. The matrix operates in the sense V(true) = rmatn * V(mean), where the p-vector V(true) is with respect to the true equatorial triad of date and the p-vector V(mean) is with respect to the mean equatorial triad of date. Called ir : initialize r-matrix to identity rx : rotate around X-axis rz : rotate around Z-axis Reference Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992),   Section 3.222-3 (p114). source"},{"id":969,"pagetitle":"Functions","title":"ERFA.nut00a","ref":"/ERFA/stable/api/functions/#ERFA.nut00a","content":" ERFA.nut00a  —  Function nut00a(date1, date2) Nutation, IAU 2000A model (MHB2000 luni-solar and planetary nutation with free core nutation omitted). Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned dpsi ,  deps : Nutation, luni-solar + planetary (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The nutation components in longitude and obliquity are in radians and with respect to the equinox and ecliptic of date.  The obliquity at J2000.0 is assumed to be the Lieske et al. (1977) value of 84381.448 arcsec. Both the luni-solar and planetary nutations are included.  The latter are due to direct planetary nutations and the perturbations of the lunar and terrestrial orbits. The function computes the MHB2000 nutation series with the associated corrections for planetary nutations.  It is an implementation of the nutation part of the IAU 2000A precession- nutation model, formally adopted by the IAU General Assembly in 2000, namely MHB2000 (Mathews et al. 2002), but with the free core nutation (FCN - see Note 4) omitted. The full MHB2000 model also contains contributions to the nutations in longitude and obliquity due to the free-excitation of the free-core-nutation during the period 1979-2000.  These FCN terms, which are time-dependent and unpredictable, are NOT included in the present function and, if required, must be independently computed.  With the FCN corrections included, the present function delivers a pole which is at current epochs accurate to a few hundred microarcseconds.  The omission of FCN introduces further errors of about that size. The present function provides classical nutation.  The MHB2000 algorithm, from which it is adapted, deals also with (i) the offsets between the GCRS and mean poles and (ii) the adjustments in longitude and obliquity due to the changed precession rates. These additional functions, namely frame bias and precession adjustments, are supported by the ERFA functions  bi00   and  pr00 . The MHB2000 algorithm also provides \"total\" nutations, comprising the arithmetic sum of the frame bias, precession adjustments, luni-solar nutation and planetary nutation.  These total nutations can be used in combination with an existing IAU 1976 precession implementation, such as  pmat76 ,  to deliver GCRS- to-true predictions of sub-mas accuracy at current dates. However, there are three shortcomings in the MHB2000 model that must be taken into account if more accurate or definitive results are required (see Wallace 2002): The MHB2000 total nutations are simply arithmetic sums, yet in reality the various components are successive Euler rotations.  This slight lack of rigor leads to cross terms that exceed 1 mas after a century.  The rigorous procedure is to form the GCRS-to-true rotation matrix by applying the bias, precession and nutation in that order. Although the precession adjustments are stated to be with respect to Lieske et al. (1977), the MHB2000 model does not specify which set of Euler angles are to be used and how the adjustments are to be applied.  The most literal and straightforward procedure is to adopt the 4-rotation epsilon 0, psi A, omega A, xi A option, and to add DPSIPR to psi A and DEPSPR to both omega A and eps_A. The MHB2000 model predates the determination by Chapront et al. (2002) of a 14.6 mas displacement between the J2000.0 mean equinox and the origin of the ICRS frame.  It should, however, be noted that neglecting this displacement when calculating star coordinates does not lead to a 14.6 mas change in right ascension, only a small second- order distortion in the pattern of the precession-nutation effect. For these reasons, the ERFA functions do not generate the \"total nutations\" directly, though they can of course easily be generated by calling  bi00 ,  pr00  and the present function and adding the results. The MHB2000 model contains 41 instances where the same frequency appears multiple times, of which 38 are duplicates and three are triplicates.  To keep the present code close to the original MHB algorithm, this small inefficiency has not been corrected. Called fal03 : mean anomaly of the Moon faf03 : mean argument of the latitude of the Moon faom03 : mean longitude of the Moon's ascending node fame03 : mean longitude of Mercury fave03 : mean longitude of Venus fae03 : mean longitude of Earth fama03 : mean longitude of Mars faju03 : mean longitude of Jupiter fasa03 : mean longitude of Saturn faur03 : mean longitude of Uranus fapa03 : general accumulated precession in longitude References Chapront, J., Chapront-Touze, M. & Francou, G. 2002,   Astron.Astrophys. 387, 700 Lieske, J.H., Lederle, T., Fricke, W. & Morando, B. 1977,   Astron.Astrophys. 58, 1-16 Mathews, P.M., Herring, T.A., Buffet, B.A. 2002, J.Geophys.Res.   107, B4.  The MHB_2000 code itself was obtained on 9th September   2002 from ftp//maia.usno.navy.mil/conv2000/chapter5/IAU2000A. Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683 Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M. 1999,   Astron.Astrophys.Supp.Ser. 135, 111 Wallace, P.T., \"Software for Implementing the IAU 2000   Resolutions\", in IERS Workshop 5.1 (2002) source"},{"id":970,"pagetitle":"Functions","title":"ERFA.nut00b","ref":"/ERFA/stable/api/functions/#ERFA.nut00b","content":" ERFA.nut00b  —  Function nut00b(date1, date2) Nutation, IAU 2000B model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned dpsi ,  deps : Nutation, luni-solar + planetary (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The nutation components in longitude and obliquity are in radians and with respect to the equinox and ecliptic of date.  The obliquity at J2000.0 is assumed to be the Lieske et al. (1977) value of 84381.448 arcsec.  (The errors that result from using this function with the IAU 2006 value of 84381.406 arcsec can be neglected.) The nutation model consists only of luni-solar terms, but includes also a fixed offset which compensates for certain long- period planetary terms (Note 7). This function is an implementation of the IAU 2000B abridged nutation model formally adopted by the IAU General Assembly in 2000. The function computes the MHB 2000 SHORT luni-solar nutation series (Luzum 2001), but without the associated corrections for the precession rate adjustments and the offset between the GCRS and J2000.0 mean poles. The full IAU 2000A (MHB2000) nutation model contains nearly 1400 terms.  The IAU 2000B model (McCarthy & Luzum 2003) contains only 77 terms, plus additional simplifications, yet still delivers results of 1 mas accuracy at present epochs.  This combination of accuracy and size makes the IAU 2000B abridged nutation model suitable for most practical applications. The function delivers a pole accurate to 1 mas from 1900 to 2100 (usually better than 1 mas, very occasionally just outside 1 mas).  The full IAU 2000A model, which is implemented in the function  nut00a  (q.v.), delivers considerably greater accuracy at current dates;  however, to realize this improved accuracy, corrections for the essentially unpredictable free-core-nutation (FCN) must also be included. The present function provides classical nutation.  The MHB 2000 SHORT algorithm, from which it is adapted, deals also with (i) the offsets between the GCRS and mean poles and (ii) the adjustments in longitude and obliquity due to the changed precession rates.  These additional functions, namely frame bias and precession adjustments, are supported by the ERFA functions  bi00   and  pr00 . The MHB 2000 SHORT algorithm also provides \"total\" nutations, comprising the arithmetic sum of the frame bias, precession adjustments, and nutation (luni-solar + planetary).  These total nutations can be used in combination with an existing IAU 1976 precession implementation, such as  pmat76 ,  to deliver GCRS- to-true predictions of mas accuracy at current epochs.  However, for symmetry with the  nut00a   function (q.v. for the reasons), the ERFA functions do not generate the \"total nutations\" directly.  Should they be required, they could of course easily be generated by calling  bi00 ,  pr00  and the present function and adding the results. The IAU 2000B model includes \"planetary bias\" terms that are fixed in size but compensate for long-period nutations.  The amplitudes quoted in McCarthy & Luzum (2003), namely Dpsi = -1.5835 mas and Depsilon = +1.6339 mas, are optimized for the \"total nutations\" method described in Note 6.  The Luzum (2001) values used in this ERFA implementation, namely -0.135 mas and +0.388 mas, are optimized for the \"rigorous\" method, where frame bias, precession and nutation are applied separately and in that order.  During the interval 1995-2050, the ERFA implementation delivers a maximum error of 1.001 mas (not including FCN). References Lieske, J.H., Lederle, T., Fricke, W., Morando, B., \"Expressions   for the precession quantities based upon the IAU /1976/ system of   astronomical constants\", Astron.Astrophys. 58, 1-2, 1-16. (1977) Luzum, B., private communication, 2001 (Fortran code   MHB 2000 SHORT) McCarthy, D.D. & Luzum, B.J., \"An abridged model of the   precession-nutation of the celestial pole\", Cel.Mech.Dyn.Astron.   85, 37-49 (2003) Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., Laskar, J., Astron.Astrophys. 282, 663-683 (1994) source"},{"id":971,"pagetitle":"Functions","title":"ERFA.nut06a","ref":"/ERFA/stable/api/functions/#ERFA.nut06a","content":" ERFA.nut06a  —  Function nut06a(date1, date2) IAU 2000A nutation with adjustments to match the IAU 2006 precession. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned dpsi ,  deps : Nutation, luni-solar + planetary (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The nutation components in longitude and obliquity are in radians and with respect to the mean equinox and ecliptic of date, IAU 2006 precession model (Hilton et al. 2006, Capitaine et al. 2005). The function first computes the IAU 2000A nutation, then applies adjustments for (i) the consequences of the change in obliquity from the IAU 1980 ecliptic to the IAU 2006 ecliptic and (ii) the secular variation in the Earth's dynamical form factor J2. The present function provides classical nutation, complementing the IAU 2000 frame bias and IAU 2006 precession.  It delivers a pole which is at current epochs accurate to a few tens of microarcseconds, apart from the free core nutation. Called nut00a : nutation, IAU 2000A References Chapront, J., Chapront-Touze, M. & Francou, G. 2002,   Astron.Astrophys. 387, 700 Lieske, J.H., Lederle, T., Fricke, W. & Morando, B. 1977,   Astron.Astrophys. 58, 1-16 Mathews, P.M., Herring, T.A., Buffet, B.A. 2002, J.Geophys.Res.   107, B4.  The MHB_2000 code itself was obtained on 9th September   2002 from ftp//maia.usno.navy.mil/conv2000/chapter5/IAU2000A. Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683 Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M. 1999,   Astron.Astrophys.Supp.Ser. 135, 111 Wallace, P.T., \"Software for Implementing the IAU 2000   Resolutions\", in IERS Workshop 5.1 (2002) source"},{"id":972,"pagetitle":"Functions","title":"ERFA.nut80","ref":"/ERFA/stable/api/functions/#ERFA.nut80","content":" ERFA.nut80  —  Function nut80(date1, date2) Nutation, IAU 1980 model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned dpsi : Nutation in longitude (radians) deps : Nutation in obliquity (radians) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The nutation components are with respect to the ecliptic of date. Called anpm : normalize angle into range +/- pi Reference Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992),   Section 3.222 (p111). source"},{"id":973,"pagetitle":"Functions","title":"ERFA.nutm80","ref":"/ERFA/stable/api/functions/#ERFA.nutm80","content":" ERFA.nutm80  —  Function nutm80(date1, date2) Form the matrix of nutation for a given date, IAU 1980 model. Given date1 ,  date2 : TDB date (Note 1) Returned rmatn : Nutation matrix Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix operates in the sense V(true) = rmatn * V(mean), where the p-vector V(true) is with respect to the true equatorial triad of date and the p-vector V(mean) is with respect to the mean equatorial triad of date. Called nut80 : nutation, IAU 1980 obl80 : mean obliquity, IAU 1980 numat : form nutation matrix source"},{"id":974,"pagetitle":"Functions","title":"ERFA.obl06","ref":"/ERFA/stable/api/functions/#ERFA.obl06","content":" ERFA.obl06  —  Function obl06(date1, date2) Mean obliquity of the ecliptic, IAU 2006 precession model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned Obliquity of the ecliptic (radians, Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The result is the angle between the ecliptic and mean equator of date date1+date2. Reference Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351 source"},{"id":975,"pagetitle":"Functions","title":"ERFA.obl80","ref":"/ERFA/stable/api/functions/#ERFA.obl80","content":" ERFA.obl80  —  Function obl80(date1, date2) Mean obliquity of the ecliptic, IAU 1980 model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned Obliquity of the ecliptic (radians, Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The result is the angle between the ecliptic and mean equator of date date1+date2. Reference Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992),   Expression 3.222-1 (p114). source"},{"id":976,"pagetitle":"Functions","title":"ERFA.p06e","ref":"/ERFA/stable/api/functions/#ERFA.p06e-Tuple{Any, Any}","content":" ERFA.p06e  —  Method p06e(date1, date2) Precession angles, IAU 2006, equinox based. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned (see Note 2) eps0 : epsilon_0 psia : psi_A oma : omega_A bpa : P_A bqa : Q_A pia : pi_A bpia : Pi_A epsa : obliquity epsilon_A chia : chi_A za : z_A zetaa : zeta_A thetaa : theta_A pa : p_A gam : F-W angle gamma_J2000 phi : F-W angle phi_J2000 psi : F-W angle psi_J2000 Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. This function returns the set of equinox based angles for the Capitaine et al. \"P03\" precession theory, adopted by the IAU in 2006. The angles are set out in Table 1 of Hilton et al. (2006): Angle Name Description eps0 epsilon_0 obliquity at J2000.0 psia psi_A luni-solar precession oma omega_A inclination of equator wrt J2000.0 ecliptic bpa P_A ecliptic pole x, J2000.0 ecliptic triad bqa Q_A ecliptic pole -y, J2000.0 ecliptic triad pia pi_A angle between moving and J2000.0 ecliptics bpia Pi_A longitude of ascending node of the ecliptic epsa epsilon_A obliquity of the ecliptic chia chi_A planetary precession za z_A equatorial precession: -3rd 323 Euler angle zetaa zeta_A equatorial precession: -1st 323 Euler angle thetaa theta_A equatorial precession: 2nd 323 Euler angle pa p_A general precession gam gamma_J2000 J2000.0 RA difference of ecliptic poles phi phi_J2000 J2000.0 codeclination of ecliptic pole psi psi_J2000 longitude difference of equator poles, J2000.0 The returned values are all radians. Hilton et al. (2006) Table 1 also contains angles that depend on models distinct from the P03 precession theory itself, namely the IAU 2000A frame bias and nutation.  The quoted polynomials are used in other ERFA functions: xy06   contains the polynomial parts of the X and Y series. s06   contains the polynomial part of the s+XY/2 series. pfw06   implements the series for the Fukushima-Williams angles that are with respect to the GCRS pole (i.e. the variants that include frame bias). The IAU resolution stipulated that the choice of parameterization was left to the user, and so an IAU compliant precession implementation can be constructed using various combinations of the angles returned by the present function. The parameterization used by ERFA is the version of the Fukushima- Williams angles that refers directly to the GCRS pole.  These angles may be calculated by calling the function  pfw06 .  ERFA also supports the direct computation of the CIP GCRS X,Y by series, available by calling  xy06 . The agreement between the different parameterizations is at the 1 microarcsecond level in the present era. When constructing a precession formulation that refers to the GCRS pole rather than the dynamical pole, it may (depending on the choice of angles) be necessary to introduce the frame bias explicitly. It is permissible to re-use the same variable in the returned arguments.  The quantities are stored in the stated order. Reference Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351 Called obl06 : mean obliquity, IAU 2006 source"},{"id":977,"pagetitle":"Functions","title":"ERFA.p2pv","ref":"/ERFA/stable/api/functions/#ERFA.p2pv","content":" ERFA.p2pv  —  Function p2pv(p) Deprecated Use  [p, zeros(3)]  instead. Extend a p-vector to a pv-vector by appending a zero velocity. Given p : P-vector Returned pv : Pv-vector Called erfa_cp : copy p-vector zp : zero p-vector source"},{"id":978,"pagetitle":"Functions","title":"ERFA.p2s","ref":"/ERFA/stable/api/functions/#ERFA.p2s-Tuple{Any}","content":" ERFA.p2s  —  Method p2s(p) P-vector to spherical polar coordinates. Given p : P-vector Returned theta : Longitude angle (radians) phi : Latitude angle (radians) r : Radial distance Notes If P is null, zero theta, phi and r are returned. At either pole, zero theta is returned. Called c2s : p-vector to spherical pm : modulus of p-vector source"},{"id":979,"pagetitle":"Functions","title":"ERFA.pap","ref":"/ERFA/stable/api/functions/#ERFA.pap-Tuple{Any, Any}","content":" ERFA.pap  —  Method pap(a, b) Position-angle from two p-vectors. Given a : Direction of reference point b : Direction of point whose PA is required Returned Position angle of b with respect to a (radians) Notes The result is the position angle, in radians, of direction b with respect to direction a.  It is in the range -pi to +pi.  The sense is such that if b is a small distance \"north\" of a the position angle is approximately zero, and if b is a small distance \"east\" of a the position angle is approximately +pi/2. The vectors a and b need not be of unit length. Zero is returned if the two directions are the same or if either vector is null. If vector a is at a pole, the result is ill-defined. Called pn : decompose p-vector into modulus and direction pm : modulus of p-vector pxp : vector product of two p-vectors pmp : p-vector minus p-vector pdp : scalar product of two p-vectors source"},{"id":980,"pagetitle":"Functions","title":"ERFA.pas","ref":"/ERFA/stable/api/functions/#ERFA.pas-NTuple{4, Any}","content":" ERFA.pas  —  Method pas(al, ap, bl, bp) Position-angle from spherical coordinates. Given al : Longitude of point A (e.g. RA) in radians ap : Latitude of point A (e.g. Dec) in radians bl : Longitude of point B bp : Latitude of point B Returned Position angle of B with respect to A Notes The result is the bearing (position angle), in radians, of point B with respect to point A.  It is in the range -pi to +pi.  The sense is such that if B is a small distance \"east\" of point A, the bearing is approximately +pi/2. Zero is returned if the two points are coincident. source"},{"id":981,"pagetitle":"Functions","title":"ERFA.pb06","ref":"/ERFA/stable/api/functions/#ERFA.pb06-Tuple{Any, Any}","content":" ERFA.pb06  —  Method pb06(date1, date2) This function forms three Euler angles which implement general precession from epoch J2000.0, using the IAU 2006 model.  Frame bias (the offset between ICRS and mean J2000.0) is included. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned bzeta : 1st rotation: radians cw around z bz : 3rd rotation: radians cw around z btheta : 2nd rotation: radians ccw around y Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The traditional accumulated precession angles zeta A, z A, theta_A cannot be obtained in the usual way, namely through polynomial expressions, because of the frame bias.  The latter means that two of the angles undergo rapid changes near this date.  They are instead the results of decomposing the precession-bias matrix obtained by using the Fukushima-Williams method, which does not suffer from the problem.  The decomposition returns values which can be used in the conventional formulation and which include frame bias. The three angles are returned in the conventional order, which is not the same as the order of the corresponding Euler rotations.  The precession-bias matrix is  R_3(-z) x R_2(+theta) x R_3(-zeta) . Should  zeta_A ,  z_A ,  theta_A  angles be required that do not contain frame bias, they are available by calling the ERFA function  p06e . Called pmat06 : PB matrix, IAU 2006 rz : rotate around Z-axis source"},{"id":982,"pagetitle":"Functions","title":"ERFA.pdp","ref":"/ERFA/stable/api/functions/#ERFA.pdp","content":" ERFA.pdp  —  Function pdp(a, b) p-vector inner (=scalar=dot) product. Deprecated Use  LinearAlgebra.dot(a, b)  instead. Given a : First p-vector b : Second p-vector Returned $a \\cdot b$ source"},{"id":983,"pagetitle":"Functions","title":"ERFA.pfw06","ref":"/ERFA/stable/api/functions/#ERFA.pfw06-Tuple{Any, Any}","content":" ERFA.pfw06  —  Method pfw06(date1, date2) Precession angles, IAU 2006 (Fukushima-Williams 4-angle formulation). Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned gamb : F-W angle gamma_bar (radians) phib : F-W angle phi_bar (radians) psib : F-W angle psi_bar (radians) epsa : F-W angle epsilon_A (radians) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. Naming the following points: e = J2000.0 ecliptic pole, p = GCRS pole, E = mean ecliptic pole of date, and P = mean pole of date, the four Fukushima-Williams angles are as follows: gamb = gamma_bar = epE phib = phi_bar = pE psib = psi_bar = pEP epsa = epsilon_A = EP The matrix representing the combined effects of frame bias and precession is: PxB = R_1(-epsa).R_3(-psib).R_1(phib).R_3(gamb) The matrix representing the combined effects of frame bias, precession and nutation is simply: NxPxB = R_1(-epsa-dE).R_3(-psib-dP).R_1(phib).R_3(gamb) where dP and dE are the nutation components with respect to the ecliptic of date. Reference Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351 Called obl06 : mean obliquity, IAU 2006 source"},{"id":984,"pagetitle":"Functions","title":"ERFA.plan94","ref":"/ERFA/stable/api/functions/#ERFA.plan94-Tuple{Any, Any, Any}","content":" ERFA.plan94  —  Method plan94(date1, date2, np) Approximate heliocentric position and velocity of a nominated major planet:  Mercury, Venus, EMB, Mars, Jupiter, Saturn, Uranus or Neptune (but not the Earth itself). Given date1 : TDB date part A (Note 1) date2 : TDB date part B (Note 1) np : Planet (1=Mercury, 2=Venus, 3=EMB, 4=Mars,                          5=Jupiter, 6=Saturn, 7=Uranus, 8=Neptune) Returned (argument) Planet  p,v  (heliocentric, J2000.0, au,au/d) Notes The date date1+date2 is in the TDB time scale (in practice TT can be used) and is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TDB)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience.  The limited accuracy of the present algorithm is such that any of the methods is satisfactory. If an np value outside the range 1-8 is supplied, an error status (function value -1) is returned and the pv vector set to zeroes. For np=3 the result is for the Earth-Moon Barycenter.  To obtain the heliocentric position and velocity of the Earth, use instead the ERFA function  epv00 . On successful return, the arrays  p  and  v  contain the following: p : heliocentric position, au v : heliocentric velocity, au/d The reference frame is equatorial and is with respect to the mean equator and equinox of epoch J2000.0. The algorithm is due to J.L. Simon, P. Bretagnon, J. Chapront, M. Chapront-Touze, G. Francou and J. Laskar (Bureau des Longitudes, Paris, France).  From comparisons with JPL ephemeris DE102, they quote the following maximum errors over the interval 1800-2050: Body L (arcsec) B (arcsec) R (km) Mercury 4 1 300 Venus 5 1 800 EMB 6 1 1000 Mars 17 1 7700 Jupiter 71 5 76000 Saturn 81 13 267000 Uranus 86 7 712000 Neptune 11 1 253000 Over the interval 1000-3000, they report that the accuracy is no worse than 1.5 times that over 1800-2050.  Outside 1000-3000 the accuracy declines. Comparisons of the present function with the JPL DE200 ephemeris give the following RMS errors over the interval 1960-2025: Body position (km) velocity (m/s) Mercury 334 0.437 Venus 1060 0.855 EMB 2010 0.815 Mars 7690 1.98 Jupiter 71700 7.70 Saturn 199000 19.4 Uranus 564000 16.4 Neptune 158000 14.4 Comparisons against DE200 over the interval 1800-2100 gave the following maximum absolute differences.  (The results using DE406 were essentially the same.) Body L (arcsec) B (arcsec) R (km) Rdot (m/s) Mercury 7 1 500 0.7 Venus 7 1 1100 0.9 EMB 9 1 1300 1.0 Mars 26 1 9000 2.5 Jupiter 78 6 82000 8.2 Saturn 87 14 263000 24.6 Uranus 86 7 661000 27.4 Neptune 11 2 248000 21.4 The present ERFA re-implementation of the original Simon et al. Fortran code differs from the original in the following respects: C instead of Fortran. The date is supplied in two parts. The result is returned only in equatorial Cartesian form;  the ecliptic longitude, latitude and radius vector are not  returned. The result is in the J2000.0 equatorial frame, not ecliptic. More is done in-line: there are fewer calls to subroutines. Different error/warning status values are used. A different Kepler's-equation-solver is used (avoiding  use of double precision complex). Polynomials in t are nested to minimize rounding errors. Explicit double constants are used to avoid mixed-mode  expressions. None of the above changes affects the result significantly. The returned status indicates the most serious condition encountered during execution of the function.  Illegal np is considered the most serious, overriding failure to converge, which in turn takes precedence over the remote date warning. Called anp : normalize angle into range 0 to 2pi Reference Simon, J.L, Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., and Laskar, J., Astron. Astrophys. 282, 663 (1994). source"},{"id":985,"pagetitle":"Functions","title":"ERFA.pm","ref":"/ERFA/stable/api/functions/#ERFA.pm","content":" ERFA.pm  —  Function pm(p) Modulus of p-vector. Deprecated Use  LinearAlgebra.norm  instead. Given p : P-vector Returned Modulus source"},{"id":986,"pagetitle":"Functions","title":"ERFA.pmat00","ref":"/ERFA/stable/api/functions/#ERFA.pmat00","content":" ERFA.pmat00  —  Function pmat00(date1, date2) Precession matrix (including frame bias) from GCRS to a specified date, IAU 2000 model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned rbp : Bias-precession matrix (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix operates in the sense V(date) = rbp * V(GCRS), where the p-vector V(GCRS) is with respect to the Geocentric Celestial Reference System (IAU, 2000) and the p-vector V(date) is with respect to the mean equatorial triad of the given date. Called bp00 : frame bias and precession matrices, IAU 2000 Reference IAU: Trans. International Astronomical Union, Vol. XXIVB;  Proc.   24th General Assembly, Manchester, UK.  Resolutions B1.3, B1.6.   (2000) source"},{"id":987,"pagetitle":"Functions","title":"ERFA.pmat06","ref":"/ERFA/stable/api/functions/#ERFA.pmat06","content":" ERFA.pmat06  —  Function pmat06(date1, date2) Precession matrix (including frame bias) from GCRS to a specified date, IAU 2006 model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned rbp : Bias-precession matrix (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix operates in the sense V(date) = rbp * V(GCRS), where the p-vector V(GCRS) is with respect to the Geocentric Celestial Reference System (IAU, 2000) and the p-vector V(date) is with respect to the mean equatorial triad of the given date. Called pfw06 : bias-precession F-W angles, IAU 2006 fw2m : F-W angles to r-matrix References Capitaine, N. & Wallace, P.T., 2006, Astron.Astrophys. 450, 855 Wallace, P.T. & Capitaine, N., 2006, Astron.Astrophys. 459, 981 source"},{"id":988,"pagetitle":"Functions","title":"ERFA.pmat76","ref":"/ERFA/stable/api/functions/#ERFA.pmat76","content":" ERFA.pmat76  —  Function pmat76(date1, date2) Precession matrix from J2000.0 to a specified date, IAU 1976 model. Given date1 ,  date2 : Ending date, TT (Note 1) Returned rmatp : Precession matrix, J2000.0 -> date1+date2 Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix operates in the sense V(date) = RMATP * V(J2000), where the p-vector V(J2000) is with respect to the mean equatorial triad of epoch J2000.0 and the p-vector V(date) is with respect to the mean equatorial triad of the given date. Though the matrix method itself is rigorous, the precession angles are expressed through canonical polynomials which are valid only for a limited time span.  In addition, the IAU 1976 precession rate is known to be imperfect.  The absolute accuracy of the present formulation is better than 0.1 arcsec from 1960AD to 2040AD, better than 1 arcsec from 1640AD to 2360AD, and remains below 3 arcsec for the whole of the period 500BC to 3000AD.  The errors exceed 10 arcsec outside the range 1200BC to 3900AD, exceed 100 arcsec outside 4200BC to 5600AD and exceed 1000 arcsec outside 6800BC to 8200AD. Called prec76 : accumulated precession angles, IAU 1976 ir : initialize r-matrix to identity rz : rotate around Z-axis ry : rotate around Y-axis cr : copy r-matrix References Lieske, J.H., 1979, Astron.Astrophys. 73, 282.   equations (6) & (7), p283. Kaplan,G.H., 1981. USNO circular no. 163, pA2. source"},{"id":989,"pagetitle":"Functions","title":"ERFA.pmp","ref":"/ERFA/stable/api/functions/#ERFA.pmp","content":" ERFA.pmp  —  Function pmp(a, b) P-vector subtraction. Deprecated Use  a .- b  instead. Given a : First p-vector b : Second p-vector Returned amb : a - b source"},{"id":990,"pagetitle":"Functions","title":"ERFA.pmpx","ref":"/ERFA/stable/api/functions/#ERFA.pmpx-NTuple{8, Any}","content":" ERFA.pmpx  —  Method pmpx(rc, dc, pr, pd, px, rv, pmt, vob) Proper motion and parallax. Given rc ,  dc : ICRS RA,Dec at catalog epoch (radians) pr : RA proper motion (radians/year; Note 1) pd : Dec proper motion (radians/year) px : Parallax (arcsec) rv : Radial velocity (km/s, +ve if receding) pmt : Proper motion time interval (SSB, Julian years) vob : SSB to observer vector (au) Returned pco : Coordinate direction (BCRS unit vector) Notes The proper motion in RA is dRA/dt rather than cos(Dec)*dRA/dt. The proper motion time interval is for when the starlight reaches the solar system barycenter. To avoid the need for iteration, the Roemer effect (i.e. the small annual modulation of the proper motion coming from the changing light time) is applied approximately, using the direction of the star at the catalog epoch. References 1984 Astronomical Almanac, pp B39-B41. Urban, S. & Seidelmann, P. K. (eds), Explanatory Supplement to   the Astronomical Almanac, 3rd ed., University Science Books   (2013), Section 7.2. Called pdp : scalar product of two p-vectors pn : decompose p-vector into modulus and direction source"},{"id":991,"pagetitle":"Functions","title":"ERFA.pmsafe","ref":"/ERFA/stable/api/functions/#ERFA.pmsafe-NTuple{10, Any}","content":" ERFA.pmsafe  —  Method pmsafe(ra1, dec1, pmr1, pmd1, px1, rv1, ep1a, ep1b, ep2a, ep2b) Star proper motion:  update star catalog data for space motion, with special handling to handle the zero parallax case. Given ra1 : Right ascension (radians), before dec1 : Declination (radians), before pmr1 : RA proper motion (radians/year), before pmd1 : Dec proper motion (radians/year), before px1 : Parallax (arcseconds), before rv1 : Radial velocity (km/s, +ve = receding), before ep1a : \"before\" epoch, part A (Note 1) ep1b : \"before\" epoch, part B (Note 1) ep2a : \"after\" epoch, part A (Note 1) ep2b : \"after\" epoch, part B (Note 1) Returned ra2 : Right ascension (radians), after dec2 : Declination (radians), after pmr2 : RA proper motion (radians/year), after pmd2 : Dec proper motion (radians/year), after px2 : Parallax (arcseconds), after rv2 : Radial velocity (km/s, +ve = receding), after Notes The starting and ending TDB epochs ep1a+ep1b and ep2a+ep2b are Julian Dates, apportioned in any convenient way between the two parts (A and B).  For example, JD(TDB)=2450123.7 could be expressed in any of these ways, among others: epNa epNb Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. In accordance with normal star-catalog conventions, the object's right ascension and declination are freed from the effects of secular aberration.  The frame, which is aligned to the catalog equator and equinox, is Lorentzian and centered on the SSB. The proper motions are the rate of change of the right ascension and declination at the catalog epoch and are in radians per TDB Julian year. The parallax and radial velocity are in the same frame. Care is needed with units.  The star coordinates are in radians and the proper motions in radians per Julian year, but the parallax is in arcseconds. The RA proper motion is in terms of coordinate angle, not true angle.  If the catalog uses arcseconds for both RA and Dec proper motions, the RA proper motion will need to be divided by cos(Dec) before use. Straight-line motion at constant speed, in the inertial frame, is assumed. An extremely small (or zero or negative) parallax is overridden to ensure that the object is at a finite but very large distance, but not so large that the proper motion is equivalent to a large but safe speed (about 0.1c using the chosen constant).  A warning status of 1 is added to the status if this action has been taken. If the space velocity is a significant fraction of c (see the constant VMAX in the function  starpv ), it is arbitrarily set to zero.  When this action occurs, 2 is added to the status. The relativistic adjustment carried out in the  starpv  function involves an iterative calculation.  If the process fails to converge within a set number of iterations, 4 is added to the status. Called seps : angle between two points starpm : update star catalog data for space motion source"},{"id":992,"pagetitle":"Functions","title":"ERFA.pn","ref":"/ERFA/stable/api/functions/#ERFA.pn","content":" ERFA.pn  —  Function pn(p) Convert a p-vector into modulus and unit vector. Deprecated Use  (LinearAlgebra.norm(p), LinearAlgebra.normalize(p))  instead. Given p : P-vector Returned r : Modulus u : Unit vector Notes If p is null, the result is null.  Otherwise the result is a unit vector. It is permissible to re-use the same array for any of the arguments. Called pm : modulus of p-vector zp : zero p-vector sxp : multiply p-vector by scalar source"},{"id":993,"pagetitle":"Functions","title":"ERFA.pn00","ref":"/ERFA/stable/api/functions/#ERFA.pn00","content":" ERFA.pn00  —  Function pn00(date1, date2, dpsi, deps) Precession-nutation, IAU 2000 model:  a multi-purpose function, supporting classical (equinox-based) use directly and CIO-based use indirectly. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) dpsi ,  deps : Nutation (Note 2) Returned epsa : Mean obliquity (Note 3) rb : Frame bias matrix (Note 4) rp : Precession matrix (Note 5) rbp : Bias-precession matrix (Note 6) rn : Nutation matrix (Note 7) rbpn : GCRS-to-true matrix (Note 8) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The caller is responsible for providing the nutation components; they are in longitude and obliquity, in radians and are with respect to the equinox and ecliptic of date.  For high-accuracy applications, free core nutation should be included as well as any other relevant corrections to the position of the CIP. The returned mean obliquity is consistent with the IAU 2000 precession-nutation models. The matrix rb transforms vectors from GCRS to J2000.0 mean equator and equinox by applying frame bias. The matrix rp transforms vectors from J2000.0 mean equator and equinox to mean equator and equinox of date by applying precession. The matrix rbp transforms vectors from GCRS to mean equator and equinox of date by applying frame bias then precession.  It is the product rp x rb. The matrix rn transforms vectors from mean equator and equinox of date to true equator and equinox of date by applying the nutation (luni-solar + planetary). The matrix rbpn transforms vectors from GCRS to true equator and equinox of date.  It is the product rn x rbp, applying frame bias, precession and nutation in that order. It is permissible to re-use the same array in the returned arguments.  The arrays are filled in the order given. Called pr00 : IAU 2000 precession adjustments obl80 : mean obliquity, IAU 1980 bp00 : frame bias and precession matrices, IAU 2000 cr : copy r-matrix numat : form nutation matrix rxr : product of two r-matrices Reference Capitaine, N., Chapront, J., Lambert, S. and Wallace, P.,   \"Expressions for the Celestial Intermediate Pole and Celestial   Ephemeris Origin consistent with the IAU 2000A precession-   nutation model\", Astron.Astrophys. 400, 1145-1154 (2003) n.b. The celestial ephemeris origin (CEO) was renamed \"celestial   intermediate origin\" (CIO) by IAU 2006 Resolution 2. source"},{"id":994,"pagetitle":"Functions","title":"ERFA.pn00a","ref":"/ERFA/stable/api/functions/#ERFA.pn00a","content":" ERFA.pn00a  —  Function pn00a(date1, date2) Precession-nutation, IAU 2000A model:  a multi-purpose function, supporting classical (equinox-based) use directly and CIO-based use indirectly. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned dpsi ,  deps : Nutation (Note 2) epsa : Mean obliquity (Note 3) rb : Frame bias matrix (Note 4) rp : Precession matrix (Note 5) rbp : Bias-precession matrix (Note 6) rn : Nutation matrix (Note 7) rbpn : GCRS-to-true matrix (Notes 8,9) Notes The TT date date1+date2 is a Julian Date, apportioned in any  convenient way between the two arguments.  For example,  JD(TT)=2450123.7 could be expressed in any of these ways,  among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in  cases where the loss of several decimal digits of resolution  is acceptable.  The J2000 method is best matched to the way  the argument is handled internally and will deliver the  optimum resolution.  The MJD method and the date & time methods  are both good compromises between resolution and convenience. The nutation components (luni-solar + planetary, IAU 2000A) in  longitude and obliquity are in radians and with respect to the  equinox and ecliptic of date.  Free core nutation is omitted;  for the utmost accuracy, use the  pn00   function, where the  nutation components are caller-specified.  For faster but  slightly less accurate results, use the  pn00b  function. The mean obliquity is consistent with the IAU 2000 precession. The matrix rb transforms vectors from GCRS to J2000.0 mean  equator and equinox by applying frame bias. The matrix rp transforms vectors from J2000.0 mean equator and  equinox to mean equator and equinox of date by applying  precession. The matrix rbp transforms vectors from GCRS to mean equator and  equinox of date by applying frame bias then precession.  It is  the product rp x rb. The matrix rn transforms vectors from mean equator and equinox  of date to true equator and equinox of date by applying the  nutation (luni-solar + planetary). The matrix rbpn transforms vectors from GCRS to true equator and  equinox of date.  It is the product rn x rbp, applying frame  bias, precession and nutation in that order. The X,Y,Z coordinates of the IAU 2000A Celestial Intermediate  Pole are elements (3,1-3) of the GCRS-to-true matrix,  i.e.  rbpn[3,1:3] . It is permissible to re-use the same array in the returned  arguments.  The arrays are filled in the order given. Called nut00a : nutation, IAU 2000A pn00 : bias/precession/nutation results, IAU 2000 Reference Capitaine, N., Chapront, J., Lambert, S. and Wallace, P.,   \"Expressions for the Celestial Intermediate Pole and Celestial   Ephemeris Origin consistent with the IAU 2000A precession-   nutation model\", Astron.Astrophys. 400, 1145-1154 (2003) n.b. The celestial ephemeris origin (CEO) was renamed \"celestial   intermediate origin\" (CIO) by IAU 2006 Resolution 2. source"},{"id":995,"pagetitle":"Functions","title":"ERFA.pn00b","ref":"/ERFA/stable/api/functions/#ERFA.pn00b","content":" ERFA.pn00b  —  Function pn00b(date1, date2) Precession-nutation, IAU 2000B model:  a multi-purpose function, supporting classical (equinox-based) use directly and CIO-based use indirectly. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned dpsi ,  deps : Nutation (Note 2) epsa : Mean obliquity (Note 3) rb : Frame bias matrix (Note 4) rp : Precession matrix (Note 5) rbp : Bias-precession matrix (Note 6) rn : Nutation matrix (Note 7) rbpn : GCRS-to-true matrix (Notes 8,9) Notes The TT date date1+date2 is a Julian Date, apportioned in any  convenient way between the two arguments.  For example,  JD(TT)=2450123.7 could be expressed in any of these ways,  among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in  cases where the loss of several decimal digits of resolution  is acceptable.  The J2000 method is best matched to the way  the argument is handled internally and will deliver the  optimum resolution.  The MJD method and the date & time methods  are both good compromises between resolution and convenience. The nutation components (luni-solar + planetary, IAU 2000B) in  longitude and obliquity are in radians and with respect to the  equinox and ecliptic of date.  For more accurate results, but  at the cost of increased computation, use the  pn00a  function.  For the utmost accuracy, use the  pn00   function, where the  nutation components are caller-specified. The mean obliquity is consistent with the IAU 2000 precession. The matrix rb transforms vectors from GCRS to J2000.0 mean  equator and equinox by applying frame bias. The matrix rp transforms vectors from J2000.0 mean equator and  equinox to mean equator and equinox of date by applying  precession. The matrix rbp transforms vectors from GCRS to mean equator and  equinox of date by applying frame bias then precession.  It is  the product rp x rb. The matrix rn transforms vectors from mean equator and equinox  of date to true equator and equinox of date by applying the  nutation (luni-solar + planetary). The matrix rbpn transforms vectors from GCRS to true equator and  equinox of date.  It is the product rn x rbp, applying frame  bias, precession and nutation in that order. The X,Y,Z coordinates of the IAU 2000B Celestial Intermediate  Pole are elements (3,1-3) of the GCRS-to-true matrix,  i.e.  rbpn[3,1:3] . It is permissible to re-use the same array in the returned  arguments.  The arrays are filled in the stated order. Called nut00b : nutation, IAU 2000B pn00 : bias/precession/nutation results, IAU 2000 Reference Capitaine, N., Chapront, J., Lambert, S. and Wallace, P.,   \"Expressions for the Celestial Intermediate Pole and Celestial   Ephemeris Origin consistent with the IAU 2000A precession-   nutation model\", Astron.Astrophys. 400, 1145-1154 (2003). n.b. The celestial ephemeris origin (CEO) was renamed \"celestial   intermediate origin\" (CIO) by IAU 2006 Resolution 2. source"},{"id":996,"pagetitle":"Functions","title":"ERFA.pn06","ref":"/ERFA/stable/api/functions/#ERFA.pn06","content":" ERFA.pn06  —  Function pn06(date1, date2, dpsi, deps) Precession-nutation, IAU 2006 model:  a multi-purpose function, supporting classical (equinox-based) use directly and CIO-based use indirectly. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) dpsi ,  deps : Nutation (Note 2) Returned epsa : Mean obliquity (Note 3) rb : Frame bias matrix (Note 4) rp : Precession matrix (Note 5) rbp : Bias-precession matrix (Note 6) rn : Nutation matrix (Note 7) rbpn : GCRS-to-true matrix (Note 8) Notes The TT date date1+date2 is a Julian Date, apportioned in any  convenient way between the two arguments.  For example,  JD(TT)=2450123.7 could be expressed in any of these ways,  among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in  cases where the loss of several decimal digits of resolution  is acceptable.  The J2000 method is best matched to the way  the argument is handled internally and will deliver the  optimum resolution.  The MJD method and the date & time methods  are both good compromises between resolution and convenience. The caller is responsible for providing the nutation components;  they are in longitude and obliquity, in radians and are with  respect to the equinox and ecliptic of date.  For high-accuracy  applications, free core nutation should be included as well as  any other relevant corrections to the position of the CIP. The returned mean obliquity is consistent with the IAU 2006  precession. The matrix rb transforms vectors from GCRS to J2000.0 mean  equator and equinox by applying frame bias. The matrix rp transforms vectors from J2000.0 mean equator and  equinox to mean equator and equinox of date by applying  precession. The matrix rbp transforms vectors from GCRS to mean equator and  equinox of date by applying frame bias then precession.  It is  the product rp x rb. The matrix rn transforms vectors from mean equator and equinox  of date to true equator and equinox of date by applying the  nutation (luni-solar + planetary). The matrix rbpn transforms vectors from GCRS to true equator and  equinox of date.  It is the product rn x rbp, applying frame  bias, precession and nutation in that order. The X,Y,Z coordinates of the Celestial Intermediate Pole are  elements (3,1-3) of the GCRS-to-true matrix, i.e.  rbpn[3,1:3] . It is permissible to re-use the same array in the returned  arguments.  The arrays are filled in the stated order. Called pfw06 : bias-precession F-W angles, IAU 2006 fw2m : F-W angles to r-matrix cr : copy r-matrix tr : transpose r-matrix rxr : product of two r-matrices References Capitaine, N. & Wallace, P.T., 2006, Astron.Astrophys. 450, 855 Wallace, P.T. & Capitaine, N., 2006, Astron.Astrophys. 459, 981 source"},{"id":997,"pagetitle":"Functions","title":"ERFA.pn06a","ref":"/ERFA/stable/api/functions/#ERFA.pn06a","content":" ERFA.pn06a  —  Function pn06a(date1, date2) Precession-nutation, IAU 2006/2000A models:  a multi-purpose function, supporting classical (equinox-based) use directly and CIO-based use indirectly. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned dpsi ,  deps : Nutation (Note 2) epsa : Mean obliquity (Note 3) rb : Frame bias matrix (Note 4) rp : Precession matrix (Note 5) rbp : Bias-precession matrix (Note 6) rn : Nutation matrix (Note 7) rbpn : GCRS-to-true matrix (Notes 8,9) Notes The TT date date1+date2 is a Julian Date, apportioned in any  convenient way between the two arguments.  For example,  JD(TT)=2450123.7 could be expressed in any of these ways,  among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in  cases where the loss of several decimal digits of resolution  is acceptable.  The J2000 method is best matched to the way  the argument is handled internally and will deliver the  optimum resolution.  The MJD method and the date & time methods  are both good compromises between resolution and convenience. The nutation components (luni-solar + planetary, IAU 2000A) in  longitude and obliquity are in radians and with respect to the  equinox and ecliptic of date.  Free core nutation is omitted;  for the utmost accuracy, use the  pn06  function, where the  nutation components are caller-specified. The mean obliquity is consistent with the IAU 2006 precession. The matrix rb transforms vectors from GCRS to mean J2000.0 by  applying frame bias. The matrix rp transforms vectors from mean J2000.0 to mean of  date by applying precession. The matrix rbp transforms vectors from GCRS to mean of date by  applying frame bias then precession.  It is the product rp x rb. The matrix rn transforms vectors from mean of date to true of  date by applying the nutation (luni-solar + planetary). The matrix rbpn transforms vectors from GCRS to true of date  (CIP/equinox).  It is the product rn x rbp, applying frame bias,  precession and nutation in that order. The X,Y,Z coordinates of the IAU 2006/2000A Celestial  Intermediate Pole are elements (3,1-3) of the GCRS-to-true  matrix, i.e.  rbpn[3,1:3] . It is permissible to re-use the same array in the returned  arguments.  The arrays are filled in the stated order. Called nut06a : nutation, IAU 2006/2000A pn06 : bias/precession/nutation results, IAU 2006 Reference Capitaine, N. & Wallace, P.T., 2006, Astron.Astrophys. 450, 855 source"},{"id":998,"pagetitle":"Functions","title":"ERFA.pnm00a","ref":"/ERFA/stable/api/functions/#ERFA.pnm00a","content":" ERFA.pnm00a  —  Function pnm00a(date1, date2) Form the matrix of precession-nutation for a given date (including frame bias), equinox-based, IAU 2000A model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned rbpn : Classical NPB matrix (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix operates in the sense V(date) = rbpn * V(GCRS), where the p-vector V(date) is with respect to the true equatorial triad of date date1+date2 and the p-vector V(GCRS) is with respect to the Geocentric Celestial Reference System (IAU, 2000). A faster, but slightly less accurate result (about 1 mas), can be obtained by using instead the  pnm00b  function. Called pn00a : bias/precession/nutation, IAU 2000A Reference IAU: Trans. International Astronomical Union, Vol. XXIVB;  Proc.   24th General Assembly, Manchester, UK.  Resolutions B1.3, B1.6.   (2000) source"},{"id":999,"pagetitle":"Functions","title":"ERFA.pnm00b","ref":"/ERFA/stable/api/functions/#ERFA.pnm00b","content":" ERFA.pnm00b  —  Function pnm00b(date1, date2) Form the matrix of precession-nutation for a given date (including frame bias), equinox-based, IAU 2000B model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned rbpn : Bias-precession-nutation matrix (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix operates in the sense V(date) = rbpn * V(GCRS), where the p-vector V(date) is with respect to the true equatorial triad of date date1+date2 and the p-vector V(GCRS) is with respect to the Geocentric Celestial Reference System (IAU, 2000). The present function is faster, but slightly less accurate (about 1 mas), than the  pnm00a  function. Called pn00b : bias/precession/nutation, IAU 2000B Reference IAU: Trans. International Astronomical Union, Vol. XXIVB;  Proc.   24th General Assembly, Manchester, UK.  Resolutions B1.3, B1.6.   (2000) source"},{"id":1000,"pagetitle":"Functions","title":"ERFA.pnm06a","ref":"/ERFA/stable/api/functions/#ERFA.pnm06a","content":" ERFA.pnm06a  —  Function pnm06a(date1, date2) Form the matrix of precession-nutation for a given date (including frame bias), IAU 2006 precession and IAU 2000A nutation models. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned rnpb : Bias-precession-nutation matrix (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix operates in the sense V(date) = rnpb * V(GCRS), where the p-vector V(date) is with respect to the true equatorial triad of date date1+date2 and the p-vector V(GCRS) is with respect to the Geocentric Celestial Reference System (IAU, 2000). Called pfw06 : bias-precession F-W angles, IAU 2006 nut06a : nutation, IAU 2006/2000A fw2m : F-W angles to r-matrix Reference Capitaine, N. & Wallace, P.T., 2006, Astron.Astrophys. 450, 855. source"},{"id":1001,"pagetitle":"Functions","title":"ERFA.pnm80","ref":"/ERFA/stable/api/functions/#ERFA.pnm80","content":" ERFA.pnm80  —  Function pnm80(date1, date2) Form the matrix of precession/nutation for a given date, IAU 1976 precession model, IAU 1980 nutation model. Given date1 ,  date2 : TDB date (Note 1) Returned rmatpn : Combined precession/nutation matrix Notes The TDB date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TDB)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix operates in the sense V(date) = rmatpn * V(J2000), where the p-vector V(date) is with respect to the true equatorial triad of date date1+date2 and the p-vector V(J2000) is with respect to the mean equatorial triad of epoch J2000.0. Called pmat76 : precession matrix, IAU 1976 nutm80 : nutation matrix, IAU 1980 rxr : product of two r-matrices Reference Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992),   Section 3.3 (p145). source"},{"id":1002,"pagetitle":"Functions","title":"ERFA.pom00","ref":"/ERFA/stable/api/functions/#ERFA.pom00-Tuple{Any, Any, Any}","content":" ERFA.pom00  —  Method pom00(xp, yp, sp) Form the matrix of polar motion for a given date, IAU 2000. Given xp ,  yp : Coordinates of the pole (radians, Note 1) sp : The TIO locator s' (radians, Note 2) Returned rpom : Polar-motion matrix (Note 3) Notes The arguments xp and yp are the coordinates (in radians) of the Celestial Intermediate Pole with respect to the International Terrestrial Reference System (see IERS Conventions 2003), measured along the meridians to 0 and 90 deg west respectively. The argument sp is the TIO locator s', in radians, which positions the Terrestrial Intermediate Origin on the equator.  It is obtained from polar motion observations by numerical integration, and so is in essence unpredictable.  However, it is dominated by a secular drift of about 47 microarcseconds per century, and so can be taken into account by using s' = -47*t, where t is centuries since J2000.0.  The function  sp00  implements this approximation. The matrix operates in the sense V(TRS) = rpom * V(CIP), meaning that it is the final rotation when computing the pointing direction to a celestial source. Called ir : initialize r-matrix to identity rz : rotate around Z-axis ry : rotate around Y-axis rx : rotate around X-axis Reference McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":1003,"pagetitle":"Functions","title":"ERFA.ppp","ref":"/ERFA/stable/api/functions/#ERFA.ppp","content":" ERFA.ppp  —  Function ppp(a, b) P-vector addition. Deprecated Use  a .+ b  instead. Given a : First p-vector b : Second p-vector Returned apb : A + b source"},{"id":1004,"pagetitle":"Functions","title":"ERFA.ppsp","ref":"/ERFA/stable/api/functions/#ERFA.ppsp","content":" ERFA.ppsp  —  Function ppsp(a, s, b) P-vector plus scaled p-vector. Deprecated Use  a .+ s .* b  instead. Given a : First p-vector s : Scalar (multiplier for b) b : Second p-vector Returned apsb : a + s*b Note It is permissible for any of a, b and apsb to be the same array. Called sxp : multiply p-vector by scalar ppp : p-vector plus p-vector source"},{"id":1005,"pagetitle":"Functions","title":"ERFA.pr00","ref":"/ERFA/stable/api/functions/#ERFA.pr00-Tuple{Any, Any}","content":" ERFA.pr00  —  Method pr00(date1, date2) Precession-rate part of the IAU 2000 precession-nutation models (part of MHB2000). Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned dpsipr ,  depspr : Precession corrections (Notes 2,3) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The precession adjustments are expressed as \"nutation components\", corrections in longitude and obliquity with respect to the J2000.0 equinox and ecliptic. Although the precession adjustments are stated to be with respect to Lieske et al. (1977), the MHB2000 model does not specify which set of Euler angles are to be used and how the adjustments are to be applied.  The most literal and straightforward procedure is to adopt the 4-rotation  epsilon_0 ,  psi_A ,  omega_A ,  xi_A  option, and to add  dpsipr  to  psi_A  and  depspr  to both  omega_A  and  eps_A . This is an implementation of one aspect of the IAU 2000A nutation model, formally adopted by the IAU General Assembly in 2000, namely MHB2000 (Mathews et al. 2002). References Lieske, J.H., Lederle, T., Fricke, W. & Morando, B., \"Expressions   for the precession quantities based upon the IAU (1976) System of   Astronomical Constants\", Astron.Astrophys., 58, 1-16 (1977) Mathews, P.M., Herring, T.A., Buffet, B.A., \"Modeling of nutation   and precession   New nutation series for nonrigid Earth and   insights into the Earth's interior\", J.Geophys.Res., 107, B4, 2002.   The MHB2000 code itself was obtained on 9th September 2002   from ftp://maia.usno.navy.mil/conv2000/chapter5/IAU2000A. Wallace, P.T., \"Software for Implementing the IAU 2000   Resolutions\", in IERS Workshop 5.1 (2002). source"},{"id":1006,"pagetitle":"Functions","title":"ERFA.prec76","ref":"/ERFA/stable/api/functions/#ERFA.prec76-NTuple{4, Any}","content":" ERFA.prec76  —  Method prec76(date01, date02, date11, date12) IAU 1976 precession model. This function forms the three Euler angles which implement general precession between two dates, using the IAU 1976 model (as for the FK5 catalog). Given date01 ,  date02 : TDB starting date (Note 1) date11 ,  date12 : TDB ending date (Note 1) Returned zeta : 1st rotation: radians cw around z z : 3rd rotation: radians cw around z theta : 2nd rotation: radians ccw around y Notes The dates date01+date02 and date11+date12 are Julian Dates, apportioned in any convenient way between the arguments daten1 and daten2.  For example, JD(TDB)=2450123.7 could be expressed in any of these ways, among others: daten1 daten2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The two dates may be expressed using different methods, but at the risk of losing some resolution. The accumulated precession angles zeta, z, theta are expressed through canonical polynomials which are valid only for a limited time span.  In addition, the IAU 1976 precession rate is known to be imperfect.  The absolute accuracy of the present formulation is better than 0.1 arcsec from 1960AD to 2040AD, better than 1 arcsec from 1640AD to 2360AD, and remains below 3 arcsec for the whole of the period 500BC to 3000AD.  The errors exceed 10 arcsec outside the range 1200BC to 3900AD, exceed 100 arcsec outside 4200BC to 5600AD and exceed 1000 arcsec outside 6800BC to 8200AD. The three angles are returned in the conventional order, which is not the same as the order of the corresponding Euler rotations.  The precession matrix is  R_3(-z) x R_2(+theta) x R_3(-zeta) . Reference Lieske, J.H., 1979, Astron.Astrophys. 73, 282, equations   (6) & (7), p283. source"},{"id":1007,"pagetitle":"Functions","title":"ERFA.pv2p","ref":"/ERFA/stable/api/functions/#ERFA.pv2p","content":" ERFA.pv2p  —  Function pv2p(pv) Discard velocity component of a pv-vector. Deprecated Use  first(pv)  instead. Given pv : Pv-vector Returned p : P-vector Called erfa_cp : copy p-vector source"},{"id":1008,"pagetitle":"Functions","title":"ERFA.pv2s","ref":"/ERFA/stable/api/functions/#ERFA.pv2s-Tuple{Any}","content":" ERFA.pv2s  —  Method pv2s(pv) Convert position/velocity from Cartesian to spherical coordinates. Given pv : Pv-vector Returned theta : Longitude angle (radians) phi : Latitude angle (radians) r : Radial distance td : Rate of change of theta pd : Rate of change of phi rd : Rate of change of r Notes If the position part of pv is null, theta, phi, td and pd are indeterminate.  This is handled by extrapolating the position through unit time by using the velocity part of pv.  This moves the origin without changing the direction of the velocity component.  If the position and velocity components of pv are both null, zeroes are returned for all six results. If the position is a pole, theta, td and pd are indeterminate. In such cases zeroes are returned for all three. source"},{"id":1009,"pagetitle":"Functions","title":"ERFA.pvdpv","ref":"/ERFA/stable/api/functions/#ERFA.pvdpv-Tuple{Any, Any}","content":" ERFA.pvdpv  —  Method pvdpv(a, b) Inner (=scalar=dot) product of two pv-vectors. Given a : First pv-vector b : Second pv-vector Returned adb :  $a \\cdot b$  (see note) Note If the position and velocity components of the two pv-vectors are    ( ap, av ) and ( bp, bv ), the result, a . b, is the pair of    numbers ( ap . bp , ap . bv + av . bp ).  The two numbers are the    dot-product of the two p-vectors and its derivative. Called pdp : scalar product of two p-vectors source"},{"id":1010,"pagetitle":"Functions","title":"ERFA.pvm","ref":"/ERFA/stable/api/functions/#ERFA.pvm","content":" ERFA.pvm  —  Function pvm(pv) Modulus of pv-vector. Deprecated Use  LinearAlgebra.norm.(pv)  instead. Given pv : Pv-vector Returned r : Modulus of position component s : Modulus of velocity component Called pm : modulus of p-vector source"},{"id":1011,"pagetitle":"Functions","title":"ERFA.pvmpv","ref":"/ERFA/stable/api/functions/#ERFA.pvmpv","content":" ERFA.pvmpv  —  Function pvmpv(a, b) Subtract one pv-vector from another. Deprecated Use  a .- b  instead. Given a : First pv-vector b : Second pv-vector Returned amb : A - b Note It is permissible to re-use the same array for any of the    arguments. Called pmp : p-vector minus p-vector source"},{"id":1012,"pagetitle":"Functions","title":"ERFA.pvppv","ref":"/ERFA/stable/api/functions/#ERFA.pvppv","content":" ERFA.pvppv  —  Function pvppv(a, b) Add one pv-vector to another. Deprecated Use  a .+ b  instead. Given a : First pv-vector b : Second pv-vector Returned apb : A + b Note It is permissible to re-use the same array for any of the    arguments. Called ppp : p-vector plus p-vector source"},{"id":1013,"pagetitle":"Functions","title":"ERFA.pvstar","ref":"/ERFA/stable/api/functions/#ERFA.pvstar-Tuple{Any}","content":" ERFA.pvstar  —  Method pvstar(pv) Convert star position+velocity vector to catalog coordinates. Given (Note 1) pv : pv-vector (au, au/day) Returned (Note 2) ra : Right ascension (radians) dec : Declination (radians) pmr : RA proper motion (radians/year) pmd : Dec proper motion (radians/year) px : Parallax (arcsec) rv : Radial velocity (km/s, positive = receding) Notes The specified pv-vector is the coordinate direction (and its rate of change) for the date at which the light leaving the star reached the solar-system barycenter. The star data returned by this function are \"observables\" for an imaginary observer at the solar-system barycenter.  Proper motion and radial velocity are, strictly, in terms of barycentric coordinate time, TCB.  For most practical applications, it is permissible to neglect the distinction between TCB and ordinary \"proper\" time on Earth (TT/TAI).  The result will, as a rule, be limited by the intrinsic accuracy of the proper-motion and radial-velocity data;  moreover, the supplied pv-vector is likely to be merely an intermediate result (for example generated by the function  starpv ), so that a change of time unit will cancel out overall. In accordance with normal star-catalog conventions, the object's right ascension and declination are freed from the effects of secular aberration.  The frame, which is aligned to the catalog equator and equinox, is Lorentzian and centered on the SSB. Summarizing, the specified pv-vector is for most stars almost identical to the result of applying the standard geometrical \"space motion\" transformation to the catalog data.  The differences, which are the subject of the Stumpff paper cited below, are: In stars with significant radial velocity and proper motion, the constantly changing light-time distorts the apparent proper motion.  Note that this is a classical, not a relativistic, effect. The transformation complies with special relativity. Care is needed with units.  The star coordinates are in radians and the proper motions in radians per Julian year, but the parallax is in arcseconds; the radial velocity is in km/s, but the pv-vector result is in au and au/day. The proper motions are the rate of change of the right ascension and declination at the catalog epoch and are in radians per Julian year.  The RA proper motion is in terms of coordinate angle, not true angle, and will thus be numerically larger at high declinations. Straight-line motion at constant speed in the inertial frame is assumed.  If the speed is greater than or equal to the speed of light, the function aborts with an error status. The inverse transformation is performed by the function  starpv . Called pn : decompose p-vector into modulus and direction pdp : scalar product of two p-vectors sxp : multiply p-vector by scalar pmp : p-vector minus p-vector pm : modulus of p-vector ppp : p-vector plus p-vector pv2s : pv-vector to spherical anp : normalize angle into range 0 to 2pi Reference Stumpff, P., 1985, Astron.Astrophys. 144, 232-240. source"},{"id":1014,"pagetitle":"Functions","title":"ERFA.pvtob","ref":"/ERFA/stable/api/functions/#ERFA.pvtob-NTuple{7, Any}","content":" ERFA.pvtob  —  Method pvtob(elong, phi, height, xp, yp, sp, theta) Position and velocity of a terrestrial observing station. Given elong : Longitude (radians, east +ve, Note 1) phi : Latitude (geodetic, radians, Note 1) hm : Height above ref. ellipsoid (geodetic, m) xp ,  yp : Coordinates of the pole (radians, Note 2) sp : The TIO locator s' (radians, Note 2) theta : Earth rotation angle (radians, Note 3) Returned pv : Position/velocity vector (m, m/s, CIRS) Notes The terrestrial coordinates are with respect to the  WGS84  reference ellipsoid. xp and yp are the coordinates (in radians) of the Celestial Intermediate Pole with respect to the International Terrestrial Reference System (see IERS Conventions), measured along the meridians 0 and 90 deg west respectively.  sp is the TIO locator s', in radians, which positions the Terrestrial Intermediate Origin on the equator.  For many applications, xp, yp and (especially) sp can be set to zero. If theta is Greenwich apparent sidereal time instead of Earth rotation angle, the result is with respect to the true equator and equinox of date, i.e. with the x-axis at the equinox rather than the celestial intermediate origin. The velocity units are meters per UT1 second, not per SI second. This is unlikely to have any practical consequences in the modern era. No validation is performed on the arguments.  Error cases that could lead to arithmetic exceptions are trapped by the  gd2gc  function, and the result set to zeros. References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Urban, S. & Seidelmann, P. K. (eds), Explanatory Supplement to   the Astronomical Almanac, 3rd ed., University Science Books   (2013), Section 7.4.3.3. Called gd2gc : geodetic to geocentric transformation pom00 : polar motion matrix trxp : product of transpose of r-matrix and p-vector source"},{"id":1015,"pagetitle":"Functions","title":"ERFA.pvu","ref":"/ERFA/stable/api/functions/#ERFA.pvu-Tuple{Any, Any}","content":" ERFA.pvu  —  Method pvu(dt, pv) Update a pv-vector. Given dt : Time interval pv : Pv-vector Returned upv : P updated, v unchanged Notes \"Update\" means \"refer the position component of the vector to a new date dt time units from the existing date\". The time units of dt must match those of the velocity. It is permissible for pv and upv to be the same array. Called ppsp : p-vector plus scaled p-vector erfa_cp : copy p-vector source"},{"id":1016,"pagetitle":"Functions","title":"ERFA.pvup","ref":"/ERFA/stable/api/functions/#ERFA.pvup-Tuple{Any, Any}","content":" ERFA.pvup  —  Method pvup(dt, pv) Update a pv-vector, discarding the velocity component. Given dt : Time interval pv : Pv-vector Returned p : P-vector Notes \"Update\" means \"refer the position component of the vector to a new date dt time units from the existing date\". The time units of dt must match those of the velocity. source"},{"id":1017,"pagetitle":"Functions","title":"ERFA.pvxpv","ref":"/ERFA/stable/api/functions/#ERFA.pvxpv-Tuple{Any, Any}","content":" ERFA.pvxpv  —  Method pvxpv(a, b) Outer (=vector=cross) product of two pv-vectors. Given a : First pv-vector b : Second pv-vector Returned axb : A x b Notes If the position and velocity components of the two pv-vectors are ( ap, av ) and ( bp, bv ), the result, a x b, is the pair of vectors ( ap x bp, ap x bv + av x bp ).  The two vectors are the cross-product of the two p-vectors and its derivative. It is permissible to re-use the same array for any of the arguments. Called cpv : copy pv-vector pxp : vector product of two p-vectors ppp : p-vector plus p-vector source"},{"id":1018,"pagetitle":"Functions","title":"ERFA.pxp","ref":"/ERFA/stable/api/functions/#ERFA.pxp","content":" ERFA.pxp  —  Function pxp(a, b) p-vector outer (=vector=cross) product. Deprecated Use  LinearAlgebra.cross  instead. Given a : First p-vector b : Second p-vector Returned axb : A x b source"},{"id":1019,"pagetitle":"Functions","title":"ERFA.refco","ref":"/ERFA/stable/api/functions/#ERFA.refco-NTuple{4, Any}","content":" ERFA.refco  —  Method refco(phpa, tc, rh, wl) Determine the constants A and B in the atmospheric refraction model dZ = A tan Z + B tan^3 Z. Z is the \"observed\" zenith distance (i.e. affected by refraction) and dZ is what to add to Z to give the \"topocentric\" (i.e. in vacuo) zenith distance. Given phpa : Pressure at the observer (hPa = millibar) tc : Ambient temperature at the observer (deg C) rh : Relative humidity at the observer (range 0-1) wl : Wavelength (micrometers) Returned refa : tan Z coefficient (radians) refb : tan^3 Z coefficient (radians) Notes The model balances speed and accuracy to give good results in applications where performance at low altitudes is not paramount. Performance is maintained across a range of conditions, and applies to both optical/IR and radio. The model omits the effects of (i) height above sea level (apart from the reduced pressure itself), (ii) latitude (i.e. the flattening of the Earth), (iii) variations in tropospheric lapse rate and (iv) dispersive effects in the radio. The model was tested using the following range of conditions: lapse rates 0.0055, 0.0065, 0.0075 deg/meter latitudes 0, 25, 50, 75 degrees heights 0, 2500, 5000 meters ASL pressures mean for height -10% to +5% in steps of 5% temperatures -10 deg to +20 deg with respect to 280 deg at SL relative humidity 0, 0.5, 1 wavelengths 0.4, 0.6, ... 2 micron, + radio zenith distances 15, 45, 75 degrees The accuracy with respect to raytracing through a model atmosphere was as follows: worst RMS optical/IR 62 mas 8 mas radio 319 mas 49 mas For this particular set of conditions: lapse rate 0.0065 K/meter latitude 50 degrees sea level pressure 1005 mb temperature 280.15 K humidity 80% wavelength 5740 Angstroms the results were as follows: ZD raytrace refco Saastamoinen 10 10.27 10.27 10.27 20 21.19 21.20 21.19 30 33.61 33.61 33.60 40 48.82 48.83 48.81 45 58.16 58.18 58.16 50 69.28 69.30 69.27 55 82.97 82.99 82.95 60 100.51 100.54 100.50 65 124.23 124.26 124.20 70 158.63 158.68 158.61 72 177.32 177.37 177.31 74 200.35 200.38 200.32 76 229.45 229.43 229.42 78 267.44 267.29 267.41 80 319.13 318.55 319.10 deg arcsec arcsec arcsec The values for Saastamoinen's formula (which includes terms up to tan^5) are taken from Hohenkerk and Sinclair (1985). A wl value in the range 0-100 selects the optical/IR case and is wavelength in micrometers.  Any value outside this range selects the radio case. Outlandish input parameters are silently limited to mathematically safe values.  Zero pressure is permissible, and causes zeroes to be returned. The algorithm draws on several sources, as follows: The formula for the saturation vapour pressure of water as a function of temperature and temperature is taken from Equations (A4.5-A4.7) of Gill (1982). The formula for the water vapour pressure, given the saturation pressure and the relative humidity, is from Crane (1976), Equation (2.5.5). The refractivity of air is a function of temperature, total pressure, water-vapour pressure and, in the case of optical/IR, wavelength.  The formulae for the two cases are developed from Hohenkerk & Sinclair (1985) and Rueger (2002). The formula for beta, the ratio of the scale height of the atmosphere to the geocentric distance of the observer, is an adaption of Equation (9) from Stone (1996).  The adaptations, arrived at empirically, consist of (i) a small adjustment to the coefficient and (ii) a humidity term for the radio case only. The formulae for the refraction constants as a function of n-1 and beta are from Green (1987), Equation (4.31). References Crane, R.K., Meeks, M.L. (ed), \"Refraction Effects in the Neutral   Atmosphere\", Methods of Experimental Physics: Astrophysics 12B,   Academic Press, 1976. Gill, Adrian E., \"Atmosphere-Ocean Dynamics\", Academic Press, 1982. Green, R.M., \"Spherical Astronomy\", Cambridge University Press, 1987. Hohenkerk, C.Y., & Sinclair, A.T., NAO Technical Note No. 63, 1985. Rueger, J.M., \"Refractive Index Formulae for Electronic Distance   Measurement with Radio and Millimetre Waves\", in Unisurv Report   S-68, School of Surveying and Spatial Information Systems,   University of New South Wales, Sydney, Australia, 2002. Stone, Ronald C., P.A.S.P. 108, 1051-1058, 1996. source"},{"id":1020,"pagetitle":"Functions","title":"ERFA.rm2v","ref":"/ERFA/stable/api/functions/#ERFA.rm2v-Tuple{Any}","content":" ERFA.rm2v  —  Method rm2v(r) Express an r-matrix as an r-vector. Given r : Rotation matrix Returned w : Rotation vector (Note 1) Notes A rotation matrix describes a rotation through some angle about some arbitrary axis called the Euler axis.  The \"rotation vector\" returned by this function has the same direction as the Euler axis, and its magnitude is the angle in radians.  (The magnitude and direction can be separated by means of the function  pn .) If r is null, so is the result.  If r is not a rotation matrix the result is undefined;  r must be proper (i.e. have a positive determinant) and real orthogonal (inverse = transpose). The reference frame rotates clockwise as seen looking along the rotation vector from the origin. source"},{"id":1021,"pagetitle":"Functions","title":"ERFA.rv2m","ref":"/ERFA/stable/api/functions/#ERFA.rv2m-Tuple{Any}","content":" ERFA.rv2m  —  Method rv2m(w) Form the r-matrix corresponding to a given r-vector. Given w : Rotation vector (Note 1) Returned r : Rotation matrix Notes A rotation matrix describes a rotation through some angle about some arbitrary axis called the Euler axis.  The \"rotation vector\" supplied to This function has the same direction as the Euler axis, and its magnitude is the angle in radians. If w is null, the unit matrix is returned. The reference frame rotates clockwise as seen looking along the rotation vector from the origin. source"},{"id":1022,"pagetitle":"Functions","title":"ERFA.rx","ref":"/ERFA/stable/api/functions/#ERFA.rx","content":" ERFA.rx  —  Function rx(phi, r) Rotate an r-matrix about the x-axis. Given phi : Angle (radians) Given and returned r : r-matrix, rotated Notes Calling this function with positive phi incorporates in the supplied r-matrix r an additional rotation, about the x-axis, anticlockwise as seen looking towards the origin from positive x. The additional rotation can be represented by this matrix: (  1        0            0      )\n(                               )\n(  0   + cos(phi)   + sin(phi)  )\n(                               )\n(  0   - sin(phi)   + cos(phi)  ) source"},{"id":1023,"pagetitle":"Functions","title":"ERFA.rxp","ref":"/ERFA/stable/api/functions/#ERFA.rxp","content":" ERFA.rxp  —  Function rxp(r, p) Multiply a p-vector by an r-matrix. Deprecated Use  r * p  instead. Given r : R-matrix p : P-vector Returned rp : r * p Note It is permissible for p and rp to be the same array. Called erfa_cp : copy p-vector source"},{"id":1024,"pagetitle":"Functions","title":"ERFA.rxpv","ref":"/ERFA/stable/api/functions/#ERFA.rxpv","content":" ERFA.rxpv  —  Function rxpv(r, pv) Multiply a pv-vector by an r-matrix. Deprecated Use  [r * pv[1], r * pv[2]]  instead. Given r : R-matrix pv : Pv-vector Returned rpv : R * pv Note It is permissible for pv and rpv to be the same array. Called rxp : product of r-matrix and p-vector source"},{"id":1025,"pagetitle":"Functions","title":"ERFA.rxr","ref":"/ERFA/stable/api/functions/#ERFA.rxr","content":" ERFA.rxr  —  Function rxr(a, b) Multiply two r-matrices. Deprecated Use  a * b  instead. Given a : First r-matrix b : Second r-matrix Returned atb : a * b Note It is permissible to re-use the same array for any of the    arguments. Called cr : copy r-matrix source"},{"id":1026,"pagetitle":"Functions","title":"ERFA.ry","ref":"/ERFA/stable/api/functions/#ERFA.ry","content":" ERFA.ry  —  Function ry(phi, r) Rotate an r-matrix about the y-axis. Given theta : Angle (radians) Given and returned r : r-matrix, rotated Notes Calling this function with positive theta incorporates in the supplied r-matrix r an additional rotation, about the y-axis, anticlockwise as seen looking towards the origin from positive y. The additional rotation can be represented by this matrix: (  + cos(theta)     0      - sin(theta)  )\n(                                        )\n(       0           1           0        )\n(                                        )\n(  + sin(theta)     0      + cos(theta)  ) source"},{"id":1027,"pagetitle":"Functions","title":"ERFA.rz","ref":"/ERFA/stable/api/functions/#ERFA.rz","content":" ERFA.rz  —  Function rz(phi, r) Rotate an r-matrix about the z-axis. Given psi : Angle (radians) Given and returned r : r-matrix, rotated Notes Calling this function with positive psi incorporates in the supplied r-matrix r an additional rotation, about the z-axis, anticlockwise as seen looking towards the origin from positive z. The additional rotation can be represented by this matrix: (  + cos(psi)   + sin(psi)     0  )\n(                                 )\n(  - sin(psi)   + cos(psi)     0  )\n(                                 )\n(       0            0         1  ) source"},{"id":1028,"pagetitle":"Functions","title":"ERFA.s00","ref":"/ERFA/stable/api/functions/#ERFA.s00","content":" ERFA.s00  —  Function s00(date1, date2, x, y) The CIO locator s, positioning the Celestial Intermediate Origin on the equator of the Celestial Intermediate Pole, given the CIP's X,Y coordinates.  Compatible with IAU 2000A precession-nutation. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) x ,  y : CIP coordinates (Note 3) Returned The CIO locator s in radians (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The CIO locator s is the difference between the right ascensions of the same point in two systems:  the two systems are the GCRS and the CIP,CIO, and the point is the ascending node of the CIP equator.  The quantity s remains below 0.1 arcsecond throughout 1900-2100. The series used to compute s is in fact for s+XY/2, where X and Y are the x and y components of the CIP unit vector;  this series is more compact than a direct series for s would be.  This function requires X,Y to be supplied by the caller, who is responsible for providing values that are consistent with the supplied date. The model is consistent with the IAU 2000A precession-nutation. Called fal03 : mean anomaly of the Moon falp03 : mean anomaly of the Sun faf03 : mean argument of the latitude of the Moon fad03 : mean elongation of the Moon from the Sun faom03 : mean longitude of the Moon's ascending node fave03 : mean longitude of Venus fae03 : mean longitude of Earth fapa03 : general accumulated precession in longitude References Capitaine, N., Chapront, J., Lambert, S. and Wallace, P.,   \"Expressions for the Celestial Intermediate Pole and Celestial   Ephemeris Origin consistent with the IAU 2000A precession-   nutation model\", Astron.Astrophys. 400, 1145-1154 (2003) n.b. The celestial ephemeris origin (CEO) was renamed \"celestial   intermediate origin\" (CIO) by IAU 2006 Resolution 2. McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":1029,"pagetitle":"Functions","title":"ERFA.s00a","ref":"/ERFA/stable/api/functions/#ERFA.s00a","content":" ERFA.s00a  —  Function s00a(date1, date2) The CIO locator s, positioning the Celestial Intermediate Origin on the equator of the Celestial Intermediate Pole, using the IAU 2000A precession-nutation model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned The CIO locator s in radians (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The CIO locator s is the difference between the right ascensions of the same point in two systems.  The two systems are the GCRS and the CIP,CIO, and the point is the ascending node of the CIP equator.  The CIO locator s remains a small fraction of 1 arcsecond throughout 1900-2100. The series used to compute s is in fact for s+XY/2, where X and Y are the x and y components of the CIP unit vector;  this series is more compact than a direct series for s would be.  The present function uses the full IAU 2000A nutation model when predicting the CIP position.  Faster results, with no significant loss of accuracy, can be obtained via the function  s00b , which uses instead the IAU 2000B truncated model. Called pnm00a : classical NPB matrix, IAU 2000A bpn2xy : extract CIP X,Y from the BPN matrix s00 : the CIO locator s, given X,Y, IAU 2000A References Capitaine, N., Chapront, J., Lambert, S. and Wallace, P.,   \"Expressions for the Celestial Intermediate Pole and Celestial   Ephemeris Origin consistent with the IAU 2000A precession-   nutation model\", Astron.Astrophys. 400, 1145-1154 (2003) n.b. The celestial ephemeris origin (CEO) was renamed \"celestial   intermediate origin\" (CIO) by IAU 2006 Resolution 2. McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":1030,"pagetitle":"Functions","title":"ERFA.s00b","ref":"/ERFA/stable/api/functions/#ERFA.s00b","content":" ERFA.s00b  —  Function s00b(date1, date2) The CIO locator s, positioning the Celestial Intermediate Origin on the equator of the Celestial Intermediate Pole, using the IAU 2000B precession-nutation model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned The CIO locator s in radians (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The CIO locator s is the difference between the right ascensions of the same point in two systems.  The two systems are the GCRS and the CIP,CIO, and the point is the ascending node of the CIP equator.  The CIO locator s remains a small fraction of 1 arcsecond throughout 1900-2100. The series used to compute s is in fact for s+XY/2, where X and Y are the x and y components of the CIP unit vector;  this series is more compact than a direct series for s would be.  The present function uses the IAU 2000B truncated nutation model when predicting the CIP position.  The function  s00a  uses instead the full IAU 2000A model, but with no significant increase in accuracy and at some cost in speed. Called pnm00b : classical NPB matrix, IAU 2000B bpn2xy : extract CIP X,Y from the BPN matrix s00 : the CIO locator s, given X,Y, IAU 2000A References Capitaine, N., Chapront, J., Lambert, S. and Wallace, P.,   \"Expressions for the Celestial Intermediate Pole and Celestial   Ephemeris Origin consistent with the IAU 2000A precession-   nutation model\", Astron.Astrophys. 400, 1145-1154 (2003) n.b. The celestial ephemeris origin (CEO) was renamed \"celestial   intermediate origin\" (CIO) by IAU 2006 Resolution 2. McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":1031,"pagetitle":"Functions","title":"ERFA.s06","ref":"/ERFA/stable/api/functions/#ERFA.s06","content":" ERFA.s06  —  Function s06(date1, date2, x, y) The CIO locator s, positioning the Celestial Intermediate Origin on the equator of the Celestial Intermediate Pole, given the CIP's X,Y coordinates.  Compatible with IAU 2006/2000A precession-nutation. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) x ,  y : CIP coordinates (Note 3) Returned The CIO locator s in radians (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The CIO locator s is the difference between the right ascensions of the same point in two systems:  the two systems are the GCRS and the CIP,CIO, and the point is the ascending node of the CIP equator.  The quantity s remains below 0.1 arcsecond throughout 1900-2100. The series used to compute s is in fact for s+XY/2, where X and Y are the x and y components of the CIP unit vector;  this series is more compact than a direct series for s would be.  This function requires X,Y to be supplied by the caller, who is responsible for providing values that are consistent with the supplied date. The model is consistent with the \"P03\" precession (Capitaine et al. 2003), adopted by IAU 2006 Resolution 1, 2006, and the IAU 2000A nutation (with P03 adjustments). Called fal03 : mean anomaly of the Moon falp03 : mean anomaly of the Sun faf03 : mean argument of the latitude of the Moon fad03 : mean elongation of the Moon from the Sun faom03 : mean longitude of the Moon's ascending node fave03 : mean longitude of Venus fae03 : mean longitude of Earth fapa03 : general accumulated precession in longitude References Capitaine, N., Wallace, P.T. & Chapront, J., 2003, Astron.   Astrophys. 432, 355 McCarthy, D.D., Petit, G. (eds.) 2004, IERS Conventions (2003),   IERS Technical Note No. 32, BKG source"},{"id":1032,"pagetitle":"Functions","title":"ERFA.s06a","ref":"/ERFA/stable/api/functions/#ERFA.s06a","content":" ERFA.s06a  —  Function s06a(date1, date2) The CIO locator s, positioning the Celestial Intermediate Origin on the equator of the Celestial Intermediate Pole, using the IAU 2006 precession and IAU 2000A nutation models. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned The CIO locator s in radians (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The CIO locator s is the difference between the right ascensions of the same point in two systems.  The two systems are the GCRS and the CIP,CIO, and the point is the ascending node of the CIP equator.  The CIO locator s remains a small fraction of 1 arcsecond throughout 1900-2100. The series used to compute s is in fact for s+XY/2, where X and Y are the x and y components of the CIP unit vector;  this series is more compact than a direct series for s would be.  The present function uses the full IAU 2000A nutation model when predicting the CIP position. Called pnm06a : classical NPB matrix, IAU 2006/2000A bpn2xy : extract CIP X,Y coordinates from NPB matrix s06 : the CIO locator s, given X,Y, IAU 2006 References Capitaine, N., Chapront, J., Lambert, S. and Wallace, P.,   \"Expressions for the Celestial Intermediate Pole and Celestial   Ephemeris Origin consistent with the IAU 2000A precession-   nutation model\", Astron.Astrophys. 400, 1145-1154 (2003) n.b. The celestial ephemeris origin (CEO) was renamed \"celestial   intermediate origin\" (CIO) by IAU 2006 Resolution 2. Capitaine, N. & Wallace, P.T., 2006, Astron.Astrophys. 450, 855 McCarthy, D. D., Petit, G. (eds.), 2004, IERS Conventions (2003),   IERS Technical Note No. 32, BKG Wallace, P.T. & Capitaine, N., 2006, Astron.Astrophys. 459, 981 source"},{"id":1033,"pagetitle":"Functions","title":"ERFA.s2c","ref":"/ERFA/stable/api/functions/#ERFA.s2c-Tuple{Any, Any}","content":" ERFA.s2c  —  Method s2c(theta, phi) Convert spherical coordinates to Cartesian. Given theta : Longitude angle (radians) phi : Latitude angle (radians) Returned c : Direction cosines source"},{"id":1034,"pagetitle":"Functions","title":"ERFA.s2p","ref":"/ERFA/stable/api/functions/#ERFA.s2p-Tuple{Any, Any, Any}","content":" ERFA.s2p  —  Method s2p(theta, phi, r) Convert spherical polar coordinates to p-vector. Given theta : Longitude angle (radians) phi : Latitude angle (radians) r : Radial distance Returned p : Cartesian coordinates Called s2c : spherical coordinates to unit vector sxp : multiply p-vector by scalar source"},{"id":1035,"pagetitle":"Functions","title":"ERFA.s2pv","ref":"/ERFA/stable/api/functions/#ERFA.s2pv-NTuple{6, Any}","content":" ERFA.s2pv  —  Method s2pv(theta, phi, r, td, pd, rd) Convert position/velocity from spherical to Cartesian coordinates. Given theta : Longitude angle (radians) phi : Latitude angle (radians) r : Radial distance td : Rate of change of theta pd : Rate of change of phi rd : Rate of change of r Returned pv : Pv-vector source"},{"id":1036,"pagetitle":"Functions","title":"ERFA.s2xpv","ref":"/ERFA/stable/api/functions/#ERFA.s2xpv","content":" ERFA.s2xpv  —  Function s2xpv(s1, s2, pv) Multiply a pv-vector by two scalars. Deprecated Use  [s1 .* pv[1], s2 .* pv[2]]  instead. Given s1 : Scalar to multiply position component by s2 : Scalar to multiply velocity component by pv : Pv-vector Returned spv : Pv-vector: p scaled by s1, v scaled by s2 Note It is permissible for pv and spv to be the same array. Called sxp : multiply p-vector by scalar source"},{"id":1037,"pagetitle":"Functions","title":"ERFA.sepp","ref":"/ERFA/stable/api/functions/#ERFA.sepp-Tuple{Any, Any}","content":" ERFA.sepp  —  Method sepp(a, b) Angular separation between two p-vectors. Given a : First p-vector (not necessarily unit length) b : Second p-vector (not necessarily unit length) Returned Angular separation (radians, always positive) Notes If either vector is null, a zero result is returned. The angular separation is most simply formulated in terms of scalar product.  However, this gives poor accuracy for angles near zero and pi.  The present algorithm uses both cross product and dot product, to deliver full accuracy whatever the size of the angle. Called pxp : vector product of two p-vectors pm : modulus of p-vector pdp : scalar product of two p-vectors source"},{"id":1038,"pagetitle":"Functions","title":"ERFA.seps","ref":"/ERFA/stable/api/functions/#ERFA.seps-NTuple{4, Any}","content":" ERFA.seps  —  Method seps(al, ap, bl, bp) Angular separation between two sets of spherical coordinates. Given al : First longitude (radians) ap : First latitude (radians) bl : Second longitude (radians) bp : Second latitude (radians) Returned Angular separation (radians) Called s2c : spherical coordinates to unit vector sepp : angular separation between two p-vectors source"},{"id":1039,"pagetitle":"Functions","title":"ERFA.sp00","ref":"/ERFA/stable/api/functions/#ERFA.sp00","content":" ERFA.sp00  —  Function sp00(date1, date2) The TIO locator s', positioning the Terrestrial Intermediate Origin on the equator of the Celestial Intermediate Pole. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned The TIO locator s' in radians (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The TIO locator s' is obtained from polar motion observations by numerical integration, and so is in essence unpredictable. However, it is dominated by a secular drift of about 47 microarcseconds per century, which is the approximation evaluated by the present function. Reference McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":1040,"pagetitle":"Functions","title":"ERFA.starpm","ref":"/ERFA/stable/api/functions/#ERFA.starpm-NTuple{10, Any}","content":" ERFA.starpm  —  Method starpm(ra1, dec1, pmr1, pmd1, px1, rv1, ep1a, ep1b, ep2a, ep2b) Star proper motion:  update star catalog data for space motion. Given ra1 : Right ascension (radians), before dec1 : Declination (radians), before pmr1 : RA proper motion (radians/year), before pmd1 : Dec proper motion (radians/year), before px1 : Parallax (arcseconds), before rv1 : Radial velocity (km/s, +ve = receding), before ep1a : \"before\" epoch, part A (Note 1) ep1b : \"before\" epoch, part B (Note 1) ep2a : \"after\" epoch, part A (Note 1) ep2b : \"after\" epoch, part B (Note 1) Returned ra2 : Right ascension (radians), after dec2 : Declination (radians), after pmr2 : RA proper motion (radians/year), after pmd2 : Dec proper motion (radians/year), after px2 : Parallax (arcseconds), after rv2 : Radial velocity (km/s, +ve = receding), after Notes The starting and ending TDB dates ep1a+ep1b and ep2a+ep2b are Julian Dates, apportioned in any convenient way between the two parts (A and B).  For example, JD(TDB)=2450123.7 could be expressed in any of these ways, among others: epna epnb Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. In accordance with normal star-catalog conventions, the object's right ascension and declination are freed from the effects of secular aberration.  The frame, which is aligned to the catalog equator and equinox, is Lorentzian and centered on the SSB. The proper motions are the rate of change of the right ascension and declination at the catalog epoch and are in radians per TDB Julian year. The parallax and radial velocity are in the same frame. Care is needed with units.  The star coordinates are in radians and the proper motions in radians per Julian year, but the parallax is in arcseconds. The RA proper motion is in terms of coordinate angle, not true angle.  If the catalog uses arcseconds for both RA and Dec proper motions, the RA proper motion will need to be divided by cos(Dec) before use. Straight-line motion at constant speed, in the inertial frame, is assumed. An extremely small (or zero or negative) parallax is interpreted to mean that the object is on the \"celestial sphere\", the radius of which is an arbitrary (large) value (see the  starpv  function for the value used).  When the distance is overridden in this way, the status, initially zero, has 1 added to it. If the space velocity is a significant fraction of c (see the constant VMAX in the function  starpv ), it is arbitrarily set to zero.  When this action occurs, 2 is added to the status. The relativistic adjustment carried out in the  starpv  function involves an iterative calculation.  If the process fails to converge within a set number of iterations, 4 is added to the status. Called starpv : star catalog data to space motion pv-vector pvu : update a pv-vector pdp : scalar product of two p-vectors pvstar : space motion pv-vector to star catalog data source"},{"id":1041,"pagetitle":"Functions","title":"ERFA.starpv","ref":"/ERFA/stable/api/functions/#ERFA.starpv-NTuple{6, Any}","content":" ERFA.starpv  —  Method starpv(ra, dec, pmr, pmd, px, rv) Convert star catalog coordinates to position+velocity vector. Given (Note 1) ra : Right ascension (radians) dec : Declination (radians) pmr : RA proper motion (radians/year) pmd : Dec proper motion (radians/year) px : Parallax (arcseconds) rv : Radial velocity (km/s, positive = receding) Returned (Note 2) pv : pv-vector (au, au/day) Notes The star data accepted by this function are \"observables\" for an imaginary observer at the solar-system barycenter.  Proper motion and radial velocity are, strictly, in terms of barycentric coordinate time, TCB.  For most practical applications, it is permissible to neglect the distinction between TCB and ordinary \"proper\" time on Earth (TT/TAI).  The result will, as a rule, be limited by the intrinsic accuracy of the proper-motion and radial-velocity data;  moreover, the pv-vector is likely to be merely an intermediate result, so that a change of time unit would cancel out overall. In accordance with normal star-catalog conventions, the object's right ascension and declination are freed from the effects of secular aberration.  The frame, which is aligned to the catalog equator and equinox, is Lorentzian and centered on the SSB. The resulting position and velocity pv-vector is with respect to the same frame and, like the catalog coordinates, is freed from the effects of secular aberration.  Should the \"coordinate direction\", where the object was located at the catalog epoch, be required, it may be obtained by calculating the magnitude of the position vector pv[0][0-2] dividing by the speed of light in au/day to give the light-time, and then multiplying the space velocity pv[1][0-2] by this light-time and adding the result to pv[0][0-2]. Summarizing, the pv-vector returned is for most stars almost identical to the result of applying the standard geometrical \"space motion\" transformation.  The differences, which are the subject of the Stumpff paper referenced below, are: In stars with significant radial velocity and proper motion, the constantly changing light-time distorts the apparent proper motion.  Note that this is a classical, not a relativistic, effect. The transformation complies with special relativity. Care is needed with units.  The star coordinates are in radians and the proper motions in radians per Julian year, but the parallax is in arcseconds; the radial velocity is in km/s, but the pv-vector result is in au and au/day. The RA proper motion is in terms of coordinate angle, not true angle.  If the catalog uses arcseconds for both RA and Dec proper motions, the RA proper motion will need to be divided by cos(Dec) before use. Straight-line motion at constant speed, in the inertial frame, is assumed. An extremely small (or zero or negative) parallax is interpreted to mean that the object is on the \"celestial sphere\", the radius of which is an arbitrary (large) value (see the constant PXMIN). When the distance is overridden in this way, the status, initially zero, has 1 added to it. If the space velocity is a significant fraction of c (see the constant VMAX), it is arbitrarily set to zero.  When this action occurs, 2 is added to the status. The relativistic adjustment involves an iterative calculation. If the process fails to converge within a set number (IMAX) of iterations, 4 is added to the status. The inverse transformation is performed by the function  pvstar . Called s2pv : spherical coordinates to pv-vector pm : modulus of p-vector zp : zero p-vector pn : decompose p-vector into modulus and direction pdp : scalar product of two p-vectors sxp : multiply p-vector by scalar pmp : p-vector minus p-vector ppp : p-vector plus p-vector Reference Stumpff, P., 1985, Astron.Astrophys. 144, 232-240. source"},{"id":1042,"pagetitle":"Functions","title":"ERFA.sxp","ref":"/ERFA/stable/api/functions/#ERFA.sxp","content":" ERFA.sxp  —  Function sxp(s, p) Multiply a p-vector by a scalar. Deprecated Use  s .* p  instead. Given s : Scalar p : P-vector Returned sp : S * p Note It is permissible for p and sp to be the same array. source"},{"id":1043,"pagetitle":"Functions","title":"ERFA.sxpv","ref":"/ERFA/stable/api/functions/#ERFA.sxpv","content":" ERFA.sxpv  —  Function sxpv(s, pv) Multiply a pv-vector by a scalar. Deprecated Use  s .* pv  instead. Given s : Scalar pv : Pv-vector Returned spv : s * pv Note It is permissible for pv and spv to be the same array Called s2xpv : multiply pv-vector by two scalars source"},{"id":1044,"pagetitle":"Functions","title":"ERFA.taitt","ref":"/ERFA/stable/api/functions/#ERFA.taitt","content":" ERFA.taitt  —  Function taitt(tai1, tai2) Time scale transformation:  International Atomic Time, TAI, to Terrestrial Time, TT. Given tai1 ,  tai2 : TAI as a 2-part Julian Date Returned tt1 ,  tt2 : TT as a 2-part Julian Date Note tai1+tai2 is Julian Date, apportioned in any convenient way    between the two arguments, for example where tai1 is the Julian    Day Number and tai2 is the fraction of a day.  The returned    tt1,tt2 follow suit. References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992) source"},{"id":1045,"pagetitle":"Functions","title":"ERFA.taiut1","ref":"/ERFA/stable/api/functions/#ERFA.taiut1","content":" ERFA.taiut1  —  Function taiut1(tai1, tai2, dta) Time scale transformation:  International Atomic Time, TAI, to Universal Time, UT1. Given tai1 ,  tai2 : TAI as a 2-part Julian Date dta : UT1-TAI in seconds Returned ut11 ,  ut12 : UT1 as a 2-part Julian Date Notes tai1+tai2 is Julian Date, apportioned in any convenient way between the two arguments, for example where tai1 is the Julian Day Number and tai2 is the fraction of a day.  The returned UT11,UT12 follow suit. The argument dta, i.e. UT1-TAI, is an observed quantity, and is available from IERS tabulations. Reference Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992) source"},{"id":1046,"pagetitle":"Functions","title":"ERFA.taiutc","ref":"/ERFA/stable/api/functions/#ERFA.taiutc","content":" ERFA.taiutc  —  Function taiutc(tai1, tai2) Time scale transformation:  International Atomic Time, TAI, to Coordinated Universal Time, UTC. Given tai1 ,  tai2 : TAI as a 2-part Julian Date (Note 1) Returned utc1 ,  utc2 : UTC as a 2-part quasi Julian Date (Notes 1-3) Notes tai1+tai2 is Julian Date, apportioned in any convenient way between the two arguments, for example where tai1 is the Julian Day Number and tai2 is the fraction of a day.  The returned utc1 and utc2 form an analogous pair, except that a special convention is used, to deal with the problem of leap seconds - see the next note. JD cannot unambiguously represent UTC during a leap second unless special measures are taken.  The convention in the present function is that the JD day represents UTC days whether the length is 86399, 86400 or 86401 SI seconds.  In the 1960-1972 era there were smaller jumps (in either direction) each time the linear UTC(TAI) expression was changed, and these \"mini-leaps\" are also included in the ERFA convention. The function  d2dtf  can be used to transform the UTC quasi-JD into calendar date and clock time, including UTC leap second handling. The warning status \"dubious year\" flags UTCs that predate the introduction of the time scale or that are too far in the future to be trusted.  See  dat  for further details. Called utctai : UTC to TAI References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992) source"},{"id":1047,"pagetitle":"Functions","title":"ERFA.tcbtdb","ref":"/ERFA/stable/api/functions/#ERFA.tcbtdb","content":" ERFA.tcbtdb  —  Function tcbtdb(tcb1, tcb2) Time scale transformation:  Barycentric Coordinate Time, TCB, to Barycentric Dynamical Time, TDB. Given tcb1 ,  tcb2 : TCB as a 2-part Julian Date Returned tdb1 ,  tdb2 : TDB as a 2-part Julian Date Notes tcb1+tcb2 is Julian Date, apportioned in any convenient way between the two arguments, for example where tcb1 is the Julian Day Number and tcb2 is the fraction of a day.  The returned tdb1,tdb2 follow suit. The 2006 IAU General Assembly introduced a conventional linear transformation between TDB and TCB.  This transformation compensates for the drift between TCB and terrestrial time TT, and keeps TDB approximately centered on TT.  Because the relationship between TT and TCB depends on the adopted solar system ephemeris, the degree of alignment between TDB and TT over long intervals will vary according to which ephemeris is used. Former definitions of TDB attempted to avoid this problem by stipulating that TDB and TT should differ only by periodic effects.  This is a good description of the nature of the relationship but eluded precise mathematical formulation.  The conventional linear relationship adopted in 2006 sidestepped these difficulties whilst delivering a TDB that in practice was consistent with values before that date. TDB is essentially the same as Teph, the time argument for the JPL solar system ephemerides. Reference IAU 2006 Resolution B3 source"},{"id":1048,"pagetitle":"Functions","title":"ERFA.tcgtt","ref":"/ERFA/stable/api/functions/#ERFA.tcgtt","content":" ERFA.tcgtt  —  Function tcgtt(tcg1, tcg2) Time scale transformation:  Geocentric Coordinate Time, TCG, to Terrestrial Time, TT. Given tcg1 ,  tcg2 : TCG as a 2-part Julian Date Returned tt1 ,  tt2 : TT as a 2-part Julian Date Note tcg1+tcg2 is Julian Date, apportioned in any convenient way    between the two arguments, for example where tcg1 is the Julian    Day Number and tcg22 is the fraction of a day.  The returned    tt1,tt2 follow suit. References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),.   IERS Technical Note No. 32, BKG (2004) IAU 2000 Resolution B1.9 source"},{"id":1049,"pagetitle":"Functions","title":"ERFA.tdbtcb","ref":"/ERFA/stable/api/functions/#ERFA.tdbtcb","content":" ERFA.tdbtcb  —  Function tdbtcb(tdb1, tdb2) Time scale transformation:  Barycentric Dynamical Time, TDB, to Barycentric Coordinate Time, TCB. Given tdb1 ,  tdb2 : TDB as a 2-part Julian Date Returned tcb1 ,  tcb2 : TCB as a 2-part Julian Date Notes tdb1+tdb2 is Julian Date, apportioned in any convenient way between the two arguments, for example where tdb1 is the Julian Day Number and tdb2 is the fraction of a day.  The returned tcb1,tcb2 follow suit. The 2006 IAU General Assembly introduced a conventional linear transformation between TDB and TCB.  This transformation compensates for the drift between TCB and terrestrial time TT, and keeps TDB approximately centered on TT.  Because the relationship between TT and TCB depends on the adopted solar system ephemeris, the degree of alignment between TDB and TT over long intervals will vary according to which ephemeris is used. Former definitions of TDB attempted to avoid this problem by stipulating that TDB and TT should differ only by periodic effects.  This is a good description of the nature of the relationship but eluded precise mathematical formulation.  The conventional linear relationship adopted in 2006 sidestepped these difficulties whilst delivering a TDB that in practice was consistent with values before that date. TDB is essentially the same as Teph, the time argument for the JPL solar system ephemerides. Reference IAU 2006 Resolution B3 source"},{"id":1050,"pagetitle":"Functions","title":"ERFA.tdbtt","ref":"/ERFA/stable/api/functions/#ERFA.tdbtt","content":" ERFA.tdbtt  —  Function tdbtt(tdb1, tdb2, dtr) Time scale transformation:  Barycentric Dynamical Time, TDB, to Terrestrial Time, TT. Given tdb1 ,  tdb2 : TDB as a 2-part Julian Date dtr : TDB-TT in seconds Returned tt1 ,  tt2 : TT as a 2-part Julian Date Notes tdb1+tdb2 is Julian Date, apportioned in any convenient way between the two arguments, for example where tdb1 is the Julian Day Number and tdb2 is the fraction of a day.  The returned tt1,tt2 follow suit. The argument dtr represents the quasi-periodic component of the GR transformation between TT and TCB.  It is dependent upon the adopted solar-system ephemeris, and can be obtained by numerical integration, by interrogating a precomputed time ephemeris or by evaluating a model such as that implemented in the ERFA function  dtdb .   The quantity is dominated by an annual term of 1.7 ms amplitude. TDB is essentially the same as Teph, the time argument for the JPL solar system ephemerides. References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) IAU 2006 Resolution 3 source"},{"id":1051,"pagetitle":"Functions","title":"ERFA.tf2a","ref":"/ERFA/stable/api/functions/#ERFA.tf2a","content":" ERFA.tf2a  —  Function tf2a(s, ihour, imin, sec) Convert hours, minutes, seconds to radians. Given s : Sign:  '-' = negative, otherwise positive ihour : Hours imin : Minutes sec : Seconds Returned rad : Angle in radians Notes The result is computed even if any of the range checks fail. Negative ihour, imin and/or sec produce a warning status, but  the absolute value is used in the conversion. If there are multiple errors, the status value reflects only the  first, the smallest taking precedence. source"},{"id":1052,"pagetitle":"Functions","title":"ERFA.tf2d","ref":"/ERFA/stable/api/functions/#ERFA.tf2d","content":" ERFA.tf2d  —  Function tf2d(s, ihour, imin, sec) Convert hours, minutes, seconds to days. Given s : Sign:  '-' = negative, otherwise positive ihour : Hours imin : Minutes sec : Seconds Returned days : Interval in days Notes The result is computed even if any of the range checks fail. Negative ihour, imin and/or sec produce a warning status, but  the absolute value is used in the conversion. If there are multiple errors, the status value reflects only the  first, the smallest taking precedence. source"},{"id":1053,"pagetitle":"Functions","title":"ERFA.tpors","ref":"/ERFA/stable/api/functions/#ERFA.tpors-NTuple{4, Any}","content":" ERFA.tpors  —  Method tpors(xi, eta, ra, dec) In the tangent plane projection, given the rectangular coordinates of a star and its spherical coordinates, determine the spherical coordinates of the tangent point. Given xi ,  eta : rectangular coordinates of star image (Note 2) a ,  b : star's spherical coordinates (Note 3) Returned status : number of solutions: 0 = no solutions returned (Note 5) 1 = only the first solution is useful (Note 6) 2 = both solutions are useful (Note 6) a01 ,  b01 : tangent point's spherical coordinates, Soln. 1 a02 ,  b02 : tangent point's spherical coordinates, Soln. 2 Notes The tangent plane projection is also called the \"gnomonic projection\" and the \"central projection\". The eta axis points due north in the adopted coordinate system. If the spherical coordinates are observed (RA,Dec), the tangent plane coordinates (xi,eta) are conventionally called the \"standard coordinates\".  If the spherical coordinates are with respect to a right-handed triad, (xi,eta) are also right-handed. The units of (xi,eta) are, effectively, radians at the tangent point. All angular arguments are in radians. The angles a01 and a02 are returned in the range 0-2pi.  The angles b01 and b02 are returned in the range +/-pi, but in the usual, non-pole-crossing, case, the range is +/-pi/2. Cases where there is no solution can arise only near the poles. For example, it is clearly impossible for a star at the pole itself to have a non-zero xi value, and hence it is meaningless to ask where the tangent point would have to be to bring about this combination of xi and dec. Also near the poles, cases can arise where there are two useful solutions.  The return value indicates whether the second of the two solutions returned is useful;  1 indicates only one useful solution, the usual case. The basis of the algorithm is to solve the spherical triangle PSC, where P is the north celestial pole, S is the star and C is the tangent point.  The spherical coordinates of the tangent point are [a0,b0];  writing rho^2 = (xi^2+eta^2) and r^2 = (1+rho^2), side c is then (pi/2-b), side p is sqrt(xi^2+eta^2) and side s (to be found) is (pi/2-b0).  Angle C is given by sin(C) = xi/rho and cos(C) = eta/rho.  Angle P (to be found) is the longitude difference between star and tangent point (a-a0). This function is a member of the following set: spherical vector solve for tpxes tpxev xi,eta tpsts tpstv star tpors tporv origin Called anp : normalize angle into range 0 to 2pi References Calabretta M.R. & Greisen, E.W., 2002, \"Representations of celestial coordinates in FITS\", Astron.Astrophys. 395, 1077 Green, R.M., \"Spherical Astronomy\", Cambridge University Press, 1987, Chapter 13. source"},{"id":1054,"pagetitle":"Functions","title":"ERFA.tporv","ref":"/ERFA/stable/api/functions/#ERFA.tporv-Tuple{Any, Any, Any}","content":" ERFA.tporv  —  Method tporv(xi, eta, v) In the tangent plane projection, given the rectangular coordinates of a star and its direction cosines, determine the direction cosines of the tangent point. Given xi ,  eta : rectangular coordinates of star image (Note 2) v : star's direction cosines (Note 3) Returned status : number of solutions: 0 = no solutions returned (Note 4) 1 = only the first solution is useful (Note 5) 2 = both solutions are useful (Note 5) v01 : tangent point's direction cosines, Solution 1 v02 : tangent point's direction cosines, Solution 2 Notes The tangent plane projection is also called the \"gnomonic projection\" and the \"central projection\". The eta axis points due north in the adopted coordinate system. If the direction cosines represent observed (RA,Dec., the tangent plane coordinates (xi,eta. are conventionally called the \"standard coordinates\".  If the direction cosines are with respect to a right-handed triad, (xi,eta. are also right-handed. The units of (xi,eta. are, effectively, radians at the tangent point. The vector v must be of unit length or the result will be wrong. Cases where there is no solution can arise only near the poles. For example, it is clearly impossible for a star at the pole itself to have a non-zero xi value, and hence it is meaningless to ask where the tangent point would have to be. Also near the poles, cases can arise where there are two useful solutions.  The return value indicates whether the second of the two solutions returned is useful;  1 indicates only one useful solution, the usual case. The basis of the algorithm is to solve the spherical triangle PSC, where P is the north celestial pole, S is the star and C is the tangent point.  Calling the celestial spherical coordinates of the star and tangent point (a,b. and (a0,b0) respectively, and writing rho^2 = (xi^2+eta^2. and r^2 = (1+rho^2), and transforming the vector v into (a,b. in the normal way, side c is then (pi/2-b., side p is sqrt(xi^2+eta^2) and side s (to be found. is (pi/2-b0), while angle C is given by sin(C) = xi/rho and cos(C. = eta/rho;  angle P (to be found) is (a-a0).  After solving the spherical triangle, the result (a0,b0. can be expressed in vector form as v0. This function is a member of the following set: spherical vector solve for tpxes tpxev xi,eta tpsts tpstv star tpors tporv origin References Calabretta M.R. & Greisen, E.W., 2002, \"Representations of celestial coordinates in FITS\", Astron.Astrophys. 395, 1077 Green, R.M., \"Spherical Astronomy\", Cambridge University Press, 1987, Chapter 13. source"},{"id":1055,"pagetitle":"Functions","title":"ERFA.tpsts","ref":"/ERFA/stable/api/functions/#ERFA.tpsts-NTuple{4, Any}","content":" ERFA.tpsts  —  Method tpsts(xi, eta, raz, decz) In the tangent plane projection, given the star's rectangular coordinates and the spherical coordinates of the tangent point, solve for the spherical coordinates of the star. Given xi ,  eta : rectangular coordinates of star image (Note 2) a0 ,  b0 : tangent point's spherical coordinates Returned a ,  b : star's spherical coordinates Notes The tangent plane projection is also called the \"gnomonic projection\" and the \"central projection\". The eta axis points due north in the adopted coordinate system. If the spherical coordinates are observed (RA,Dec), the tangent plane coordinates (xi,eta) are conventionally called the \"standard coordinates\".  If the spherical coordinates are with respect to a right-handed triad, (xi,eta) are also right-handed. The units of (xi,eta) are, effectively, radians at the tangent point. All angular arguments are in radians. This function is a member of the following set: spherical vector solve for tpxes tpxev xi,eta tpsts tpstv star tpors tporv origin Called anp  normalize angle into range 0 to 2pi References Calabretta M.R. & Greisen, E.W., 2002, \"Representations of celestial coordinates in FITS\", Astron.Astrophys. 395, 1077 Green, R.M., \"Spherical Astronomy\", Cambridge University Press, 1987, Chapter 13. source"},{"id":1056,"pagetitle":"Functions","title":"ERFA.tpstv","ref":"/ERFA/stable/api/functions/#ERFA.tpstv-Tuple{Any, Any, Any}","content":" ERFA.tpstv  —  Method tpstv(xi, eta, vz) In the tangent plane projection, given the star's rectangular coordinates and the direction cosines of the tangent point, solve for the direction cosines of the star. Given xi ,  eta : rectangular coordinates of star image (Note 2) v0 : tangent point's direction cosines Returned v : star's direction cosines Notes The tangent plane projection is also called the \"gnomonic projection\" and the \"central projection\". The eta axis points due north in the adopted coordinate system. If the direction cosines represent observed (RA,Dec), the tangent plane coordinates (xi,eta) are conventionally called the \"standard coordinates\".  If the direction cosines are with respect to a right-handed triad, (xi,eta) are also right-handed. The units of (xi,eta) are, effectively, radians at the tangent point. The method used is to complete the star vector in the (xi,eta) based triad and normalize it, then rotate the triad to put the tangent point at the pole with the x-axis aligned to zero longitude.  Writing (a0,b0) for the celestial spherical coordinates of the tangent point, the sequence of rotations is (b-pi/2) around the x-axis followed by (-a-pi/2) around the z-axis. If vector v0 is not of unit length, the returned vector v will be wrong. If vector v0 points at a pole, the returned vector v will be based on the arbitrary assumption that the longitude coordinate of the tangent point is zero. This function is a member of the following set: spherical vector solve for tpxes tpxev xi,eta tpsts tpstv star tpors tporv origin References Calabretta M.R. & Greisen, E.W., 2002, \"Representations of celestial coordinates in FITS\", Astron.Astrophys. 395, 1077 Green, R.M., \"Spherical Astronomy\", Cambridge University Press, 1987, Chapter 13. source"},{"id":1057,"pagetitle":"Functions","title":"ERFA.tpxes","ref":"/ERFA/stable/api/functions/#ERFA.tpxes-NTuple{4, Any}","content":" ERFA.tpxes  —  Method tpxes(ra, dec, raz, decz) In the tangent plane projection, given celestial spherical coordinates for a star and the tangent point, solve for the star's rectangular coordinates in the tangent plane. Given a ,  b : star's spherical coordinates a0 ,  b0 : tangent point's spherical coordinates Returned status : 0 = OK 1 = star too far from axis 2 = antistar on tangent plane 3 = antistar too far from axis xi ,  eta : rectangular coordinates of star image (Note 2) Notes The tangent plane projection is also called the \"gnomonic projection\" and the \"central projection\". The eta axis points due north in the adopted coordinate system. If the spherical coordinates are observed (RA,Dec), the tangent plane coordinates (xi,eta) are conventionally called the \"standard coordinates\".  For right-handed spherical coordinates, (xi,eta) are also right-handed.  The units of (xi,eta) are, effectively, radians at the tangent point. All angular arguments are in radians. This function is a member of the following set: spherical vector solve for tpxes tpxev xi,eta tpsts tpstv star tpors tporv origin References Calabretta M.R. & Greisen, E.W., 2002, \"Representations of celestial coordinates in FITS\", Astron.Astrophys. 395, 1077 Green, R.M., \"Spherical Astronomy\", Cambridge University Press, 1987, Chapter 13. source"},{"id":1058,"pagetitle":"Functions","title":"ERFA.tpxev","ref":"/ERFA/stable/api/functions/#ERFA.tpxev-Tuple{Any, Any}","content":" ERFA.tpxev  —  Method tpxev(v, vz) In the tangent plane projection, given celestial direction cosines for a star and the tangent point, solve for the star's rectangular coordinates in the tangent plane. Given v : direction cosines of star (Note 4) v0 : direction cosines of tangent point (Note 4) Returned status : 0 = OK 1 = star too far from axis 2 = antistar on tangent plane 3 = antistar too far from axis xi ,  eta : tangent plane coordinates of star Notes The tangent plane projection is also called the \"gnomonic projection\" and the \"central projection\". The eta axis points due north in the adopted coordinate system. If the direction cosines represent observed (RA,Dec), the tangent plane coordinates (xi,eta) are conventionally called the \"standard coordinates\".  If the direction cosines are with respect to a right-handed triad, (xi,eta) are also right-handed. The units of (xi,eta) are, effectively, radians at the tangent point. The method used is to extend the star vector to the tangent plane and then rotate the triad so that (x,y) becomes (xi,eta). Writing (a,b) for the celestial spherical coordinates of the star, the sequence of rotations is (a+pi/2) around the z-axis followed by (pi/2-b) around the x-axis. If vector v0 is not of unit length, or if vector v is of zero length, the results will be wrong. If v0 points at a pole, the returned (xi,eta) will be based on the arbitrary assumption that the longitude coordinate of the tangent point is zero. This function is a member of the following set: spherical vector solve for tpxes tpxev xi,eta tpsts tpstv star tpors tporv origin References Calabretta M.R. & Greisen, E.W., 2002, \"Representations of celestial coordinates in FITS\", Astron.Astrophys. 395, 1077 Green, R.M., \"Spherical Astronomy\", Cambridge University Press, 1987, Chapter 13. source"},{"id":1059,"pagetitle":"Functions","title":"ERFA.tr","ref":"/ERFA/stable/api/functions/#ERFA.tr","content":" ERFA.tr  —  Function tr(r) Transpose an r-matrix. Deprecated Use  r'  instead. Given r : R-matrix Returned rt : Transpose Note It is permissible for r and rt to be the same array. Called cr : copy r-matrix source"},{"id":1060,"pagetitle":"Functions","title":"ERFA.trxp","ref":"/ERFA/stable/api/functions/#ERFA.trxp","content":" ERFA.trxp  —  Function trxp(r, p) Multiply a p-vector by the transpose of an r-matrix. Deprecated Use  r' * p  instead. Given r : R-matrix p : P-vector Returned trp : R * p Note It is permissible for p and trp to be the same array. Called tr : transpose r-matrix rxp : product of r-matrix and p-vector source"},{"id":1061,"pagetitle":"Functions","title":"ERFA.trxpv","ref":"/ERFA/stable/api/functions/#ERFA.trxpv","content":" ERFA.trxpv  —  Function trxpv(r, pv) Multiply a pv-vector by the transpose of an r-matrix. Deprecated Use  [r' * pv[1], r' * pv[2]]  instead. Given r : R-matrix pv : Pv-vector Returned trpv : R * pv Note It is permissible for pv and trpv to be the same array. Called tr : transpose r-matrix rxpv : product of r-matrix and pv-vector source"},{"id":1062,"pagetitle":"Functions","title":"ERFA.tttai","ref":"/ERFA/stable/api/functions/#ERFA.tttai","content":" ERFA.tttai  —  Function tttai(tt1, tt2) Time scale transformation:  Terrestrial Time, TT, to International Atomic Time, TAI. Given tt1 ,  tt2 : TT as a 2-part Julian Date Returned tai1 ,  tai2 : TAI as a 2-part Julian Date Note tt1+tt2 is Julian Date, apportioned in any convenient way between    the two arguments, for example where tt1 is the Julian Day Number    and tt2 is the fraction of a day.  The returned tai1,tai2 follow    suit. References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992) source"},{"id":1063,"pagetitle":"Functions","title":"ERFA.tttcg","ref":"/ERFA/stable/api/functions/#ERFA.tttcg","content":" ERFA.tttcg  —  Function tttcg(tt1, tt2) Time scale transformation:  Terrestrial Time, TT, to Geocentric Coordinate Time, TCG. Given tt1 ,  tt2 : TT as a 2-part Julian Date Returned tcg1 ,  tcg2 : TCG as a 2-part Julian Date Note tt1+tt2 is Julian Date, apportioned in any convenient way between    the two arguments, for example where tt1 is the Julian Day Number    and tt2 is the fraction of a day.  The returned tcg1,tcg2 follow    suit. References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) IAU 2000 Resolution B1.9 source"},{"id":1064,"pagetitle":"Functions","title":"ERFA.tttdb","ref":"/ERFA/stable/api/functions/#ERFA.tttdb","content":" ERFA.tttdb  —  Function tttdb(tt1, tt2, dtr) Time scale transformation:  Terrestrial Time, TT, to Barycentric Dynamical Time, TDB. Given tt1 ,  tt2 : TT as a 2-part Julian Date dtr : TDB-TT in seconds Returned tdb1 ,  tdb2 : TDB as a 2-part Julian Date Notes tt1+tt2 is Julian Date, apportioned in any convenient way between the two arguments, for example where tt1 is the Julian Day Number and tt2 is the fraction of a day.  The returned tdb1,tdb2 follow suit. The argument dtr represents the quasi-periodic component of the GR transformation between TT and TCB.  It is dependent upon the adopted solar-system ephemeris, and can be obtained by numerical integration, by interrogating a precomputed time ephemeris or by evaluating a model such as that implemented in the ERFA function  dtdb .   The quantity is dominated by an annual term of 1.7 ms amplitude. TDB is essentially the same as Teph, the time argument for the JPL solar system ephemerides. References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) IAU 2006 Resolution 3 source"},{"id":1065,"pagetitle":"Functions","title":"ERFA.ttut1","ref":"/ERFA/stable/api/functions/#ERFA.ttut1","content":" ERFA.ttut1  —  Function ttut1(tt1, tt2, dt) Time scale transformation:  Terrestrial Time, TT, to Universal Time, UT1. Given tt1 ,  tt2 : TT as a 2-part Julian Date dt : TT-UT1 in seconds Returned ut11 ,  ut12 : UT1 as a 2-part Julian Date Notes tt1+tt2 is Julian Date, apportioned in any convenient way between the two arguments, for example where tt1 is the Julian Day Number and tt2 is the fraction of a day.  The returned ut11,ut12 follow suit. The argument dt is classical Delta T. Reference Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992) source"},{"id":1066,"pagetitle":"Functions","title":"ERFA.ut1tai","ref":"/ERFA/stable/api/functions/#ERFA.ut1tai","content":" ERFA.ut1tai  —  Function ut1tai(ut11, ut12, dta) Time scale transformation:  Universal Time, UT1, to International Atomic Time, TAI. Given ut11 ,  ut12 : UT1 as a 2-part Julian Date dta : UT1-TAI in seconds Returned tai1 ,  tai2 : TAI as a 2-part Julian Date Notes ut11+ut12 is Julian Date, apportioned in any convenient way between the two arguments, for example where ut11 is the Julian Day Number and ut12 is the fraction of a day.  The returned tai1,tai2 follow suit. The argument dta, i.e. UT1-TAI, is an observed quantity, and is available from IERS tabulations. Reference Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992) source"},{"id":1067,"pagetitle":"Functions","title":"ERFA.ut1tt","ref":"/ERFA/stable/api/functions/#ERFA.ut1tt","content":" ERFA.ut1tt  —  Function ut1tt(ut11, ut12, dt) Time scale transformation:  Universal Time, UT1, to Terrestrial Time, TT. Given ut11 ,  ut12 : UT1 as a 2-part Julian Date dt : TT-UT1 in seconds Returned tt1 ,  tt2 : TT as a 2-part Julian Date Notes ut11+ut12 is Julian Date, apportioned in any convenient way between the two arguments, for example where ut11 is the Julian Day Number and ut12 is the fraction of a day.  The returned tt1,tt2 follow suit. The argument dt is classical Delta T. Reference Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992) source"},{"id":1068,"pagetitle":"Functions","title":"ERFA.ut1utc","ref":"/ERFA/stable/api/functions/#ERFA.ut1utc","content":" ERFA.ut1utc  —  Function ut1utc(ut11, ut12, dut1) Time scale transformation:  Universal Time, UT1, to Coordinated Universal Time, UTC. Given ut11 ,  ut12 : UT1 as a 2-part Julian Date (Note 1) dut1 : Delta UT1: UT1-UTC in seconds (Note 2) Returned utc1 ,  utc2 : UTC as a 2-part quasi Julian Date (Notes 3,4) Notes ut11+ut12 is Julian Date, apportioned in any convenient way between the two arguments, for example where ut11 is the Julian Day Number and ut12 is the fraction of a day.  The returned utc1 and utc2 form an analogous pair, except that a special convention is used, to deal with the problem of leap seconds - see Note 3. Delta UT1 can be obtained from tabulations provided by the International Earth Rotation and Reference Systems Service.  The value changes abruptly by 1s at a leap second;  however, close to a leap second the algorithm used here is tolerant of the \"wrong\" choice of value being made. JD cannot unambiguously represent UTC during a leap second unless special measures are taken.  The convention in the present function is that the returned quasi JD day UTC1+UTC2 represents UTC days whether the length is 86399, 86400 or 86401 SI seconds. The function  d2dtf  can be used to transform the UTC quasi-JD into calendar date and clock time, including UTC leap second handling. The warning status \"dubious year\" flags UTCs that predate the introduction of the time scale or that are too far in the future to be trusted.  See  dat  for further details. Called jd2cal : JD to Gregorian calendar dat : delta(AT) = TAI-UTC cal2jd : Gregorian calendar to JD References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992) source"},{"id":1069,"pagetitle":"Functions","title":"ERFA.utctai","ref":"/ERFA/stable/api/functions/#ERFA.utctai-Tuple{Any, Any}","content":" ERFA.utctai  —  Method utctai(utc1, utc2) Time scale transformation:  Coordinated Universal Time, UTC, to International Atomic Time, TAI. Given utc1 ,  utc2 : UTC as a 2-part quasi Julian Date (Notes 1-4) Returned tai1 ,  tai2 : TAI as a 2-part Julian Date (Note 5) Notes utc1+utc2 is quasi Julian Date (see Note 2), apportioned in any convenient way between the two arguments, for example where utc1 is the Julian Day Number and utc2 is the fraction of a day. JD cannot unambiguously represent UTC during a leap second unless special measures are taken.  The convention in the present function is that the JD day represents UTC days whether the length is 86399, 86400 or 86401 SI seconds.  In the 1960-1972 era there were smaller jumps (in either direction) each time the linear UTC(TAI) expression was changed, and these \"mini-leaps\" are also included in the ERFA convention. The warning status \"dubious year\" flags UTCs that predate the introduction of the time scale or that are too far in the future to be trusted.  See  dat  for further details. The function  dtf2d  converts from calendar date and time of day into 2-part Julian Date, and in the case of UTC implements the leap-second-ambiguity convention described above. The returned TAI1,TAI2 are such that their sum is the TAI Julian Date. Called jd2cal : JD to Gregorian calendar dat : delta(AT) = TAI-UTC cal2jd : Gregorian calendar to JD References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992) source"},{"id":1070,"pagetitle":"Functions","title":"ERFA.utcut1","ref":"/ERFA/stable/api/functions/#ERFA.utcut1","content":" ERFA.utcut1  —  Function utcut1(utc1, utc2, dut1) Time scale transformation:  Coordinated Universal Time, UTC, to Universal Time, UT1. Given utc1 ,  utc2 : UTC as a 2-part quasi Julian Date (Notes 1-4) dut1 : Delta UT1 = UT1-UTC in seconds (Note 5) Returned ut11 ,  ut12 : UT1 as a 2-part Julian Date (Note 6) Notes utc1+utc2 is quasi Julian Date (see Note 2), apportioned in any convenient way between the two arguments, for example where utc1 is the Julian Day Number and utc2 is the fraction of a day. JD cannot unambiguously represent UTC during a leap second unless special measures are taken.  The convention in the present function is that the JD day represents UTC days whether the length is 86399, 86400 or 86401 SI seconds. The warning status \"dubious year\" flags UTCs that predate the introduction of the time scale or that are too far in the future to be trusted.  See  dat  for further details. The function  dtf2d  converts from calendar date and time of day into 2-part Julian Date, and in the case of UTC implements the leap-second-ambiguity convention described above. Delta UT1 can be obtained from tabulations provided by the International Earth Rotation and Reference Systems Service. It is the caller's responsibility to supply a dut1 argument containing the UT1-UTC value that matches the given UTC. The returned ut11,ut12 are such that their sum is the UT1 Julian Date. References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992) Called jd2cal : JD to Gregorian calendar dat : delta(AT) = TAI-UTC utctai : UTC to TAI taiut1 : TAI to UT1 source"},{"id":1071,"pagetitle":"Functions","title":"ERFA.xy06","ref":"/ERFA/stable/api/functions/#ERFA.xy06-Tuple{Any, Any}","content":" ERFA.xy06  —  Method xy06(date1, date2) X,Y coordinates of celestial intermediate pole from series based on IAU 2006 precession and IAU 2000A nutation. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned x ,  y : CIP X,Y coordinates (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The X,Y coordinates are those of the unit vector towards the celestial intermediate pole.  They represent the combined effects of frame bias, precession and nutation. The fundamental arguments used are as adopted in IERS Conventions (2003) and are from Simon et al. (1994) and Souchay et al. (1999). This is an alternative to the angles-based method, via the ERFA function  fw2xy  and as used in  xys06a  for example.  The two methods agree at the 1 microarcsecond level (at present), a negligible amount compared with the intrinsic accuracy of the models.  However, it would be unwise to mix the two methods (angles-based and series-based) in a single application. Called fal03 : mean anomaly of the Moon falp03 : mean anomaly of the Sun faf03 : mean argument of the latitude of the Moon fad03 : mean elongation of the Moon from the Sun faom03 : mean longitude of the Moon's ascending node fame03 : mean longitude of Mercury fave03 : mean longitude of Venus fae03 : mean longitude of Earth fama03 : mean longitude of Mars faju03 : mean longitude of Jupiter fasa03 : mean longitude of Saturn faur03 : mean longitude of Uranus fane03 : mean longitude of Neptune fapa03 : general accumulated precession in longitude References Capitaine, N., Wallace, P.T. & Chapront, J., 2003,   Astron.Astrophys., 412, 567 Capitaine, N. & Wallace, P.T., 2006, Astron.Astrophys. 450, 855 McCarthy, D. D., Petit, G. (eds.), 2004, IERS Conventions (2003),   IERS Technical Note No. 32, BKG Simon, J.L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G. & Laskar, J., Astron.Astrophys., 1994, 282, 663 Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M., 1999,   Astron.Astrophys.Supp.Ser. 135, 111 Wallace, P.T. & Capitaine, N., 2006, Astron.Astrophys. 459, 981 source"},{"id":1072,"pagetitle":"Functions","title":"ERFA.xys00a","ref":"/ERFA/stable/api/functions/#ERFA.xys00a","content":" ERFA.xys00a  —  Function xys00a(date1, date2) For a given TT date, compute the X,Y coordinates of the Celestial Intermediate Pole and the CIO locator s, using the IAU 2000A precession-nutation model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned x ,  y : Celestial Intermediate Pole (Note 2) s : The CIO locator s (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The Celestial Intermediate Pole coordinates are the x,y components of the unit vector in the Geocentric Celestial Reference System. The CIO locator s (in radians) positions the Celestial Intermediate Origin on the equator of the CIP. A faster, but slightly less accurate result (about 1 mas for X,Y), can be obtained by using instead the  xys00b  function. Called pnm00a : classical NPB matrix, IAU 2000A bpn2xy : extract CIP X,Y coordinates from NPB matrix s00 : the CIO locator s, given X,Y, IAU 2000A Reference McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":1073,"pagetitle":"Functions","title":"ERFA.xys00b","ref":"/ERFA/stable/api/functions/#ERFA.xys00b","content":" ERFA.xys00b  —  Function xys00b(date1, date2) For a given TT date, compute the X,Y coordinates of the Celestial Intermediate Pole and the CIO locator s, using the IAU 2000B precession-nutation model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned x ,  y : Celestial Intermediate Pole (Note 2) s : The CIO locator s (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The Celestial Intermediate Pole coordinates are the x,y components of the unit vector in the Geocentric Celestial Reference System. The CIO locator s (in radians) positions the Celestial Intermediate Origin on the equator of the CIP. The present function is faster, but slightly less accurate (about 1 mas in X,Y), than the  xys00a  function. Called pnm00b : classical NPB matrix, IAU 2000B bpn2xy : extract CIP X,Y coordinates from NPB matrix s00 : the CIO locator s, given X,Y, IAU 2000A Reference McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":1074,"pagetitle":"Functions","title":"ERFA.xys06a","ref":"/ERFA/stable/api/functions/#ERFA.xys06a","content":" ERFA.xys06a  —  Function xys06a(date1, date2) For a given TT date, compute the X,Y coordinates of the Celestial Intermediate Pole and the CIO locator s, using the IAU 2006 precession and IAU 2000A nutation models. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned x ,  y : Celestial Intermediate Pole (Note 2) s : The CIO locator s (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The Celestial Intermediate Pole coordinates are the x,y components of the unit vector in the Geocentric Celestial Reference System. The CIO locator s (in radians) positions the Celestial Intermediate Origin on the equator of the CIP. Series-based solutions for generating X and Y are also available: see Capitaine & Wallace (2006) and  xy06 . Called pnm06a : classical NPB matrix, IAU 2006/2000A bpn2xy : extract CIP X,Y coordinates from NPB matrix s06 : the CIO locator s, given X,Y, IAU 2006 References Capitaine, N. & Wallace, P.T., 2006, Astron.Astrophys. 450, 855 Wallace, P.T. & Capitaine, N., 2006, Astron.Astrophys. 459, 981 source"},{"id":1075,"pagetitle":"Functions","title":"ERFA.zp","ref":"/ERFA/stable/api/functions/#ERFA.zp","content":" ERFA.zp  —  Function zp(p) Zero a p-vector. Deprecated Use  fill!(p, 0.0)  instead. Returned p : zero p-vector source"},{"id":1076,"pagetitle":"Functions","title":"ERFA.zpv","ref":"/ERFA/stable/api/functions/#ERFA.zpv","content":" ERFA.zpv  —  Function zpv(pv) Zero a pv-vector. Deprecated Use  fill!.(pv, 0.0)  instead. Returned p : zero pv-vector source"},{"id":1077,"pagetitle":"Functions","title":"ERFA.zr","ref":"/ERFA/stable/api/functions/#ERFA.zr","content":" ERFA.zr  —  Function zr(r) Initialize an r-matrix to the null matrix. Deprecated Use  fill!(r, 0.0)  instead. Returned r : r-matrix source"},{"id":1080,"pagetitle":"Index","title":"API Index","ref":"/ERFA/stable/api/name_index/#API-Index","content":" API Index"},{"id":1081,"pagetitle":"Index","title":"Types","ref":"/ERFA/stable/api/name_index/#Types","content":" Types ERFA.Ellipsoid"},{"id":1082,"pagetitle":"Index","title":"Constants","ref":"/ERFA/stable/api/name_index/#Constants","content":" Constants ERFA.AULT ERFA.CMPS ERFA.D2PI ERFA.DAS2R ERFA.DAU ERFA.DAYSEC ERFA.DC ERFA.DD2R ERFA.DJ00 ERFA.DJC ERFA.DJM ERFA.DJM0 ERFA.DJM00 ERFA.DJM77 ERFA.DJY ERFA.DMAS2R ERFA.DPI ERFA.DR2AS ERFA.DR2D ERFA.DS2R ERFA.DTY ERFA.ELB ERFA.ELG ERFA.GRS80 ERFA.SRS ERFA.TDB0 ERFA.TTMTAI ERFA.TURNAS ERFA.WGS72 ERFA.WGS84"},{"id":1083,"pagetitle":"Index","title":"Functions","ref":"/ERFA/stable/api/name_index/#Functions","content":" Functions ERFA.a2af ERFA.a2tf ERFA.ab ERFA.ae2hd ERFA.af2a ERFA.anp ERFA.anpm ERFA.apcg ERFA.apcg13 ERFA.apci ERFA.apci13 ERFA.apco ERFA.apco13 ERFA.apcs ERFA.apcs13 ERFA.aper ERFA.aper13 ERFA.apio ERFA.apio13 ERFA.atcc13 ERFA.atccq ERFA.atci13 ERFA.atciq ERFA.atciqn ERFA.atciqz ERFA.atco13 ERFA.atic13 ERFA.aticq ERFA.aticqn ERFA.atio13 ERFA.atioq ERFA.atoc13 ERFA.atoi13 ERFA.atoiq ERFA.bi00 ERFA.bp00 ERFA.bp06 ERFA.bpn2xy ERFA.c2i00a ERFA.c2i00b ERFA.c2i06a ERFA.c2ibpn ERFA.c2ixy ERFA.c2ixys ERFA.c2s ERFA.c2t00a ERFA.c2t00b ERFA.c2t06a ERFA.c2tcio ERFA.c2teqx ERFA.c2tpe ERFA.c2txy ERFA.cal2jd ERFA.cpv ERFA.cr ERFA.d2dtf ERFA.d2tf ERFA.dat ERFA.dtdb ERFA.dtf2d ERFA.eceq06 ERFA.ecm06 ERFA.ee00 ERFA.ee00a ERFA.ee00b ERFA.ee06a ERFA.eect00 ERFA.eform ERFA.eo06a ERFA.eors ERFA.epb ERFA.epb2jd ERFA.epj ERFA.epj2jd ERFA.epv00 ERFA.eqec06 ERFA.eqeq94 ERFA.era00 ERFA.erfa_cp ERFA.fad03 ERFA.fae03 ERFA.faf03 ERFA.faju03 ERFA.fal03 ERFA.falp03 ERFA.fama03 ERFA.fame03 ERFA.fane03 ERFA.faom03 ERFA.fapa03 ERFA.fasa03 ERFA.faur03 ERFA.fave03 ERFA.fk425 ERFA.fk45z ERFA.fk524 ERFA.fk52h ERFA.fk54z ERFA.fk5hip ERFA.fk5hz ERFA.fw2m ERFA.fw2xy ERFA.g2icrs ERFA.gc2gd ERFA.gc2gde ERFA.gd2gc ERFA.gd2gce ERFA.gmst00 ERFA.gmst06 ERFA.gmst82 ERFA.gst00a ERFA.gst00b ERFA.gst06 ERFA.gst06a ERFA.gst94 ERFA.h2fk5 ERFA.hd2ae ERFA.hd2pa ERFA.hfk5z ERFA.icrs2g ERFA.ir ERFA.jd2cal ERFA.jdcalf ERFA.ld ERFA.ldn ERFA.ldsun ERFA.lteceq ERFA.ltecm ERFA.lteqec ERFA.ltp ERFA.ltpb ERFA.ltpecl ERFA.ltpequ ERFA.moon98 ERFA.num00a ERFA.num00b ERFA.num06a ERFA.numat ERFA.nut00a ERFA.nut00b ERFA.nut06a ERFA.nut80 ERFA.nutm80 ERFA.obl06 ERFA.obl80 ERFA.p06e ERFA.p2pv ERFA.p2s ERFA.pap ERFA.pas ERFA.pb06 ERFA.pdp ERFA.pfw06 ERFA.plan94 ERFA.pm ERFA.pmat00 ERFA.pmat06 ERFA.pmat76 ERFA.pmp ERFA.pmpx ERFA.pmsafe ERFA.pn ERFA.pn00 ERFA.pn00a ERFA.pn00b ERFA.pn06 ERFA.pn06a ERFA.pnm00a ERFA.pnm00b ERFA.pnm06a ERFA.pnm80 ERFA.pom00 ERFA.ppp ERFA.ppsp ERFA.pr00 ERFA.prec76 ERFA.pv2p ERFA.pv2s ERFA.pvdpv ERFA.pvm ERFA.pvmpv ERFA.pvppv ERFA.pvstar ERFA.pvtob ERFA.pvu ERFA.pvup ERFA.pvxpv ERFA.pxp ERFA.refco ERFA.rm2v ERFA.rv2m ERFA.rx ERFA.rxp ERFA.rxpv ERFA.rxr ERFA.ry ERFA.rz ERFA.s00 ERFA.s00a ERFA.s00b ERFA.s06 ERFA.s06a ERFA.s2c ERFA.s2p ERFA.s2pv ERFA.s2xpv ERFA.sepp ERFA.seps ERFA.sp00 ERFA.starpm ERFA.starpv ERFA.sxp ERFA.sxpv ERFA.taitt ERFA.taiut1 ERFA.taiutc ERFA.tcbtdb ERFA.tcgtt ERFA.tdbtcb ERFA.tdbtt ERFA.tf2a ERFA.tf2d ERFA.tpors ERFA.tporv ERFA.tpsts ERFA.tpstv ERFA.tpxes ERFA.tpxev ERFA.tr ERFA.trxp ERFA.trxpv ERFA.tttai ERFA.tttcg ERFA.tttdb ERFA.ttut1 ERFA.ut1tai ERFA.ut1tt ERFA.ut1utc ERFA.utctai ERFA.utcut1 ERFA.xy06 ERFA.xys00a ERFA.xys00b ERFA.xys06a ERFA.zp ERFA.zpv ERFA.zr"},{"id":1086,"pagetitle":"Types & Constants","title":"Types and constants","ref":"/ERFA/stable/api/types_and_constants/#Types-and-constants","content":" Types and constants"},{"id":1087,"pagetitle":"Types & Constants","title":"Types","ref":"/ERFA/stable/api/types_and_constants/#Types","content":" Types"},{"id":1088,"pagetitle":"Types & Constants","title":"ERFA.Ellipsoid","ref":"/ERFA/stable/api/types_and_constants/#ERFA.Ellipsoid","content":" ERFA.Ellipsoid  —  Type Ellipsoid Reference ellipsoids WGS84 GRS80 WGS72 source"},{"id":1089,"pagetitle":"Types & Constants","title":"Constants","ref":"/ERFA/stable/api/types_and_constants/#Constants","content":" Constants"},{"id":1090,"pagetitle":"Types & Constants","title":"ERFA.AULT","ref":"/ERFA/stable/api/types_and_constants/#ERFA.AULT","content":" ERFA.AULT  —  Constant AULT Light time for 1 au (s) source"},{"id":1091,"pagetitle":"Types & Constants","title":"ERFA.CMPS","ref":"/ERFA/stable/api/types_and_constants/#ERFA.CMPS","content":" ERFA.CMPS  —  Constant CMPS Speed of light (m/s) source"},{"id":1092,"pagetitle":"Types & Constants","title":"ERFA.D2PI","ref":"/ERFA/stable/api/types_and_constants/#ERFA.D2PI","content":" ERFA.D2PI  —  Constant D2PI 2Pi source"},{"id":1093,"pagetitle":"Types & Constants","title":"ERFA.DAS2R","ref":"/ERFA/stable/api/types_and_constants/#ERFA.DAS2R","content":" ERFA.DAS2R  —  Constant DAS2R Arcseconds to radians source"},{"id":1094,"pagetitle":"Types & Constants","title":"ERFA.DAU","ref":"/ERFA/stable/api/types_and_constants/#ERFA.DAU","content":" ERFA.DAU  —  Constant DAU Astronomical unit (m, IAU 2012) source"},{"id":1095,"pagetitle":"Types & Constants","title":"ERFA.DAYSEC","ref":"/ERFA/stable/api/types_and_constants/#ERFA.DAYSEC","content":" ERFA.DAYSEC  —  Constant DAYSEC Seconds per day source"},{"id":1096,"pagetitle":"Types & Constants","title":"ERFA.DC","ref":"/ERFA/stable/api/types_and_constants/#ERFA.DC","content":" ERFA.DC  —  Constant DC Speed of light (au per day) source"},{"id":1097,"pagetitle":"Types & Constants","title":"ERFA.DD2R","ref":"/ERFA/stable/api/types_and_constants/#ERFA.DD2R","content":" ERFA.DD2R  —  Constant DD2R Degrees to radians source"},{"id":1098,"pagetitle":"Types & Constants","title":"ERFA.DJ00","ref":"/ERFA/stable/api/types_and_constants/#ERFA.DJ00","content":" ERFA.DJ00  —  Constant DJ00 Reference epoch (J2000.0), Julian Date source"},{"id":1099,"pagetitle":"Types & Constants","title":"ERFA.DJC","ref":"/ERFA/stable/api/types_and_constants/#ERFA.DJC","content":" ERFA.DJC  —  Constant DJC Days per Julian century source"},{"id":1100,"pagetitle":"Types & Constants","title":"ERFA.DJM","ref":"/ERFA/stable/api/types_and_constants/#ERFA.DJM","content":" ERFA.DJM  —  Constant DJM Days per Julian millennium source"},{"id":1101,"pagetitle":"Types & Constants","title":"ERFA.DJM0","ref":"/ERFA/stable/api/types_and_constants/#ERFA.DJM0","content":" ERFA.DJM0  —  Constant DJM0 Julian Date of Modified Julian Date zero source"},{"id":1102,"pagetitle":"Types & Constants","title":"ERFA.DJM00","ref":"/ERFA/stable/api/types_and_constants/#ERFA.DJM00","content":" ERFA.DJM00  —  Constant DJM00 Reference epoch (J2000.0), Modified Julian Date source"},{"id":1103,"pagetitle":"Types & Constants","title":"ERFA.DJM77","ref":"/ERFA/stable/api/types_and_constants/#ERFA.DJM77","content":" ERFA.DJM77  —  Constant DJM77 1977 Jan 1.0 as MJD source"},{"id":1104,"pagetitle":"Types & Constants","title":"ERFA.DJY","ref":"/ERFA/stable/api/types_and_constants/#ERFA.DJY","content":" ERFA.DJY  —  Constant DJY Days per Julian year source"},{"id":1105,"pagetitle":"Types & Constants","title":"ERFA.DMAS2R","ref":"/ERFA/stable/api/types_and_constants/#ERFA.DMAS2R","content":" ERFA.DMAS2R  —  Constant DMAS2R Milliarcseconds to radians source"},{"id":1106,"pagetitle":"Types & Constants","title":"ERFA.DPI","ref":"/ERFA/stable/api/types_and_constants/#ERFA.DPI","content":" ERFA.DPI  —  Constant DPI Pi source"},{"id":1107,"pagetitle":"Types & Constants","title":"ERFA.DR2AS","ref":"/ERFA/stable/api/types_and_constants/#ERFA.DR2AS","content":" ERFA.DR2AS  —  Constant DR2AS Radians to arcseconds source"},{"id":1108,"pagetitle":"Types & Constants","title":"ERFA.DR2D","ref":"/ERFA/stable/api/types_and_constants/#ERFA.DR2D","content":" ERFA.DR2D  —  Constant DR2D Radians to degrees source"},{"id":1109,"pagetitle":"Types & Constants","title":"ERFA.DS2R","ref":"/ERFA/stable/api/types_and_constants/#ERFA.DS2R","content":" ERFA.DS2R  —  Constant DS2R Seconds of time to radians source"},{"id":1110,"pagetitle":"Types & Constants","title":"ERFA.DTY","ref":"/ERFA/stable/api/types_and_constants/#ERFA.DTY","content":" ERFA.DTY  —  Constant DTY Length of tropical year B1900 (days) source"},{"id":1111,"pagetitle":"Types & Constants","title":"ERFA.ELB","ref":"/ERFA/stable/api/types_and_constants/#ERFA.ELB","content":" ERFA.ELB  —  Constant L_B L_B = 1 - d(TDB)/d(TCB) source"},{"id":1112,"pagetitle":"Types & Constants","title":"ERFA.ELG","ref":"/ERFA/stable/api/types_and_constants/#ERFA.ELG","content":" ERFA.ELG  —  Constant ELG L_G = 1 - d(TT)/d(TCG) source"},{"id":1113,"pagetitle":"Types & Constants","title":"ERFA.GRS80","ref":"/ERFA/stable/api/types_and_constants/#ERFA.GRS80","content":" ERFA.GRS80  —  Constant GRS80 Enum constant for the GRS80 reference ellipsoid source"},{"id":1114,"pagetitle":"Types & Constants","title":"ERFA.SRS","ref":"/ERFA/stable/api/types_and_constants/#ERFA.SRS","content":" ERFA.SRS  —  Constant SRS Schwarzschild radius of the Sun (au) = 2 * 1.32712440041e20 / (2.99792458e8)^2 / 1.49597870700e11 source"},{"id":1115,"pagetitle":"Types & Constants","title":"ERFA.TDB0","ref":"/ERFA/stable/api/types_and_constants/#ERFA.TDB0","content":" ERFA.TDB0  —  Constant TDB0 TDB (s) at TAI 1977/1/1.0 source"},{"id":1116,"pagetitle":"Types & Constants","title":"ERFA.TTMTAI","ref":"/ERFA/stable/api/types_and_constants/#ERFA.TTMTAI","content":" ERFA.TTMTAI  —  Constant TTMTAI TT minus TAI (s) source"},{"id":1117,"pagetitle":"Types & Constants","title":"ERFA.TURNAS","ref":"/ERFA/stable/api/types_and_constants/#ERFA.TURNAS","content":" ERFA.TURNAS  —  Constant TURNAS Arcseconds in a full circle source"},{"id":1118,"pagetitle":"Types & Constants","title":"ERFA.WGS72","ref":"/ERFA/stable/api/types_and_constants/#ERFA.WGS72","content":" ERFA.WGS72  —  Constant WGS72 Enum constant for the WGS72 reference ellipsoid source"},{"id":1119,"pagetitle":"Types & Constants","title":"ERFA.WGS84","ref":"/ERFA/stable/api/types_and_constants/#ERFA.WGS84","content":" ERFA.WGS84  —  Constant WGS84 Enum constant for the WGS84 reference ellipsoid source"},{"id":1122,"pagetitle":"Introduction","title":"Healpix.jl: an implementation of the Healpix tessellation scheme in Julia","ref":"/Healpix/stable/#Healpix.jl:-an-implementation-of-the-Healpix-tessellation-scheme-in-Julia","content":" Healpix.jl: an implementation of the Healpix tessellation scheme in Julia This is the documentation of the  Healpix.jl  package, an implementation of the Healpix spherical tessellation scheme written entirely in Julia. This package has the main purpose of providing a Julia-only solution, so that it can easily be used on platforms not supported by the Healpix C++ library (e.g., Windows). This library implements algorithms for converting directions into pixel indices and vice versa. It supports both  RING  and  NESTED  schemes, and it employs Julia's powerful type system to avoid mistaking one scheme in place of the other."},{"id":1123,"pagetitle":"Introduction","title":"Index","ref":"/Healpix/stable/#Index","content":" Index Healpix.NSIDE_MAX Healpix.ORDER_MAX Healpix.UNSEEN Healpix.AbstractHealpixMap Healpix.AbstractPolarizedHealpixMap Healpix.Alm Healpix.HealpixMap Healpix.NestedOrder Healpix.Order Healpix.PolarizedHealpixMap Healpix.Resolution Healpix.Resolution Healpix.RingInfo Healpix.RingOrder Base.:* Base.:+ Base.:- Base.:/ Base.eachindex Healpix.adjoint_alm2map! Healpix.adjoint_map2alm! Healpix.alm2cl Healpix.alm2map Healpix.alm2map! Healpix.almExplicitIndex Healpix.almxfl Healpix.almxfl! Healpix.anafast Healpix.ang2pix Healpix.ang2pixNest Healpix.ang2pixRing Healpix.ang2vec Healpix.applyFullWeights! Healpix.boundariesRing Healpix.boundariesRing! Healpix.cl2dl Healpix.colat2lat Healpix.combinemaps! Healpix.conformables Healpix.dl2cl Healpix.each_ell Healpix.each_ell_idx Healpix.each_ell_m Healpix.each_m Healpix.each_m_idx Healpix.equiproj Healpix.equiprojinv Healpix.equirectangular Healpix.gaussbeam Healpix.getEquatorIdx Healpix.getRingPixels Healpix.getinterpolRing Healpix.getringinfo Healpix.getringinfo! Healpix.gnominv Healpix.gnomonic Healpix.interpolate Healpix.iterate_map2alm! Healpix.lat2colat Healpix.map2alm Healpix.map2alm! Healpix.max_pixrad Healpix.mollweide Healpix.mollweideproj Healpix.mollweideprojinv Healpix.nest2ring Healpix.nest2ring Healpix.nest2ring! Healpix.npix2nside Healpix.nside2npix Healpix.nside2order Healpix.nside2pixarea Healpix.nside2resol Healpix.nsideok Healpix.numOfRings Healpix.numberOfAlms Healpix.order2nside Healpix.ortho2inv Healpix.orthographic Healpix.orthographic2 Healpix.orthoinv Healpix.pix2ang Healpix.pix2angNest Healpix.pix2angRing Healpix.pix2ringpos Healpix.pix2xyfNest Healpix.pix2xyfRing Healpix.pix2zphiNest Healpix.pix2zphiRing Healpix.pixwin Healpix.project Healpix.queryDiscRing Healpix.queryStripRing Healpix.readAlmFromFITS Healpix.readClFromFITS Healpix.readFullWeights Healpix.readMapFromFITS Healpix.readPolarizedMapFromFITS Healpix.ring2nest Healpix.ring2nest Healpix.ring2nest! Healpix.ring2theta Healpix.ring2z Healpix.ringAbove Healpix.savePixelsToFITS Healpix.saveToFITS Healpix.synalm Healpix.synalm! Healpix.synfast Healpix.synfast! Healpix.tod2map Healpix.udgrade Healpix.vec2ang Healpix.writeAlmToFITS Healpix.writeClToFITS Healpix.xyf2loc Healpix.xyf2pixNest Healpix.xyf2pixRing Healpix.zphi2pixRing LinearAlgebra.dot RecipesBase.plot"},{"id":1126,"pagetitle":"Power Spectrum","title":"Power Spectrum","ref":"/Healpix/stable/Cl/#Power-Spectrum","content":" Power Spectrum Power spectrum components  $C_{\\ell}$  are encoded as Vector{T}. Healpix.jl implements functions to perform sht operations on power spectra, e.g. to obtain a map or a set of  Alm , as well as writing/reading a power spectrum from a FITS file. The functions ending with  !  are  mutating  functions, which means that they assume that the result must be saved in a preallocated variable; they are space- and time-efficient and should be used when you want your code to be performant, or when you plan to apply the same operation several times (e.g., in a Monte Carlo simulation)."},{"id":1127,"pagetitle":"Power Spectrum","title":"Loading and saving power spectrum components","ref":"/Healpix/stable/Cl/#Loading-and-saving-power-spectrum-components","content":" Loading and saving power spectrum components Healpix.jl implements functions to read/write the components  $C_{\\ell}$  from/to a FITS files."},{"id":1128,"pagetitle":"Power Spectrum","title":"Healpix.readClFromFITS","ref":"/Healpix/stable/Cl/#Healpix.readClFromFITS","content":" Healpix.readClFromFITS  —  Function readClFromFITS{T <: Real}(f::CFITSIO.FITSFile, t::Type{T}; col_num = 2) -> Vector{T}\nreadClFromFITS{T <: Real}(fileName::String, t::Type{T}; col_num = 2) -> Vector{T} Read a set of C_ℓ coefficients from a FITS file. source"},{"id":1129,"pagetitle":"Power Spectrum","title":"Healpix.writeClToFITS","ref":"/Healpix/stable/Cl/#Healpix.writeClToFITS","content":" Healpix.writeClToFITS  —  Function writeClToFITS(f::CFITSIO.FITSFile, Cl::Vector{T}) where {T <: Real}\nwriteClToFITS(fileName, Cl::Vector{T}; overwrite = true) where {T <: Real} Write a set of C_ℓ coefficients to a FITS file. source"},{"id":1130,"pagetitle":"Power Spectrum","title":"Converting different power spectrum representation","ref":"/Healpix/stable/Cl/#Converting-different-power-spectrum-representation","content":" Converting different power spectrum representation It's often useful to represent, especially for plotting it, the power spectrum in the form of  $D_{\\ell}$ . Healpix.jl implements a couple of functions to convert a power spectrum from/to such a representation."},{"id":1131,"pagetitle":"Power Spectrum","title":"Healpix.cl2dl","ref":"/Healpix/stable/Cl/#Healpix.cl2dl","content":" Healpix.cl2dl  —  Function cl2dl(cl::AbstractVector{T}, lmin::Integer) where {T <: Real} Convert a set of  $C_ℓ$  to  $D_ℓ$  power spectrum, where  $D_ℓ = ℓ (ℓ + 1) C_ℓ / 2π$ . The first components are set to zero if not present. Arguments: cl::AbstractVector{T}  : Array of C_ℓ components lmin::Integer  : minimum l in the representation of the C_ℓ power spectrum Returns: Vector{T}  : Array of D_ℓ power spectrum components source"},{"id":1132,"pagetitle":"Power Spectrum","title":"Healpix.dl2cl","ref":"/Healpix/stable/Cl/#Healpix.dl2cl","content":" Healpix.dl2cl  —  Function dl2cl(dl::AbstractVector{T}, lmin::Integer) where {T <: Real} Convert a set of  $D_ℓ$  to  $C_ℓ$  power spectrum, where  $C_ℓ = 2π D_ℓ / ℓ (ℓ + 1)$ . The first components are set to zero if not present. The monopole component is set to zero in any case to avoid Inf values. Arguments: dl::AbstractVector{T}  : Array of D_ℓ components lmin::Integer  : minimum l in the representation of the Dℓ power spectrum Returns: Vector{T}  : Array of C_ℓ power spectrum components source"},{"id":1133,"pagetitle":"Power Spectrum","title":"Synthesizing harmonic coefficients from power spectrum","ref":"/Healpix/stable/Cl/#Synthesizing-harmonic-coefficients-from-power-spectrum","content":" Synthesizing harmonic coefficients from power spectrum Generate a  Alm  instance with a random set of  $a_{\\ell m}$  coefficients. Each harmonic coefficient  $a_{\\ell m}$  is a realization of a gaussian distribution with zero mean and  $C_{\\ell}$  variance."},{"id":1134,"pagetitle":"Power Spectrum","title":"Healpix.synalm!","ref":"/Healpix/stable/Cl/#Healpix.synalm!","content":" Healpix.synalm!  —  Function synalm!(cl::Vector{T}, alm::Alm{ComplexF64, Vector{ComplexF64}}, rng::AbstractRNG) where {T <: Real}\nsynalm!(cl::Vector{T}, alm::Alm{ComplexF64, Vector{ComplexF64}}) where {T <: Real} Generate a set of  $a_{ℓm}$  from a given power spectra  $C_ℓ$ . The output is written into the  Alm  object passed in input. Arguments: cl::AbstractVector{T} : The array representing the power spectrum components  $C_ℓ$ , starting from  $ℓ = 0$ . alm::Alm{Complex{T}} : The array representing the spherical harmonics coefficients  $a_{ℓm}$  we want to write the result into. rng::AbstractRNG  : (optional) the RNG to be used for generating the  $a_{ℓm}$ . It allows to set the seed beforehand guaranteeing the reproducibility of the process. source"},{"id":1135,"pagetitle":"Power Spectrum","title":"Healpix.synalm","ref":"/Healpix/stable/Cl/#Healpix.synalm","content":" Healpix.synalm  —  Function synalm(cl::Vector{T}, lmax::Integer, mmax::Integer, rng::AbstractRNG) where {T <: Real}\nsynalm(cl::Vector{T}, lmax::Integer, mmax::Integer) where {T <: Real}\nsynalm(cl::Vector{T}, lmax::Integer, rng::AbstractRNG) where {T <: Real}\nsynalm(cl::Vector{T}, lmax::Integer) where {T <: Real}\nsynalm(cl::Vector{T}, rng::AbstractRNG) where {T <: Real}\nsynalm(cl::Vector{T}) where {T <: Real} Generate a set of  $a_{ℓm}$  from a given power spectra  $C_ℓ$ . The output is written into a new  Alm  object of given lmax. Arguments: cl::AbstractVector{T} : The array representing the power spectrum components  $C_ℓ$ , starting from  $ℓ = 0$ . lmax::Integer : the maximum  $ℓ$  coefficient, will default to  length(cl)-1  if not specified. mmax::Integer : the maximum  $m$  coefficient, will default to  lmax  if not specified. rng::AbstractRNG  : (optional) the RNG to be used for generating the  $a_{ℓm}$ . It allows to set the seed beforehand guaranteeing the reproducibility of the process. source"},{"id":1136,"pagetitle":"Power Spectrum","title":"Generating a map from power spectrum","ref":"/Healpix/stable/Cl/#Generating-a-map-from-power-spectrum","content":" Generating a map from power spectrum Synthesize a set of  Alm  through  synalm  and generates a map from it through  alm2map ."},{"id":1137,"pagetitle":"Power Spectrum","title":"Healpix.synfast!","ref":"/Healpix/stable/Cl/#Healpix.synfast!","content":" Healpix.synfast!  —  Function synfast!(cl::Vector{T}, map::HealpixMap{T, RingOrder}, lmax::Integer, rng::AbstractRNG) where {T <: Real}\nsynfast!(cl::Vector{T}, map::HealpixMap{T, RingOrder}, lmax::Integer) where {T <: Real}\nsynfast!(cl::Vector{T}, map::HealpixMap{T, RingOrder}, rng::AbstractRNG) where {T <: Real}\nsynfast!(cl::Vector{T}, map::HealpixMap{T, RingOrder}) where {T <: Real} Generate a map from a given power spectra  $C_ℓ$ . The result is saved into the  HealpixMap  passed in input. Arguments: cl::AbstractVector{T} : The array representing the power spectrum components  $C_ℓ$ . map::HealpixMap{T, RingOrder} : the map that will contain the result. lmax::Integer : the maximum  $ℓ$  coefficient, will default to  length(cl)-1  if not specified. rng::AbstractRNG  : (optional) the RNG to be used for generating the  $a_{ℓm}$ . It allows to set the seed beforehand guaranteeing the reproducibility of the process. source"},{"id":1138,"pagetitle":"Power Spectrum","title":"Healpix.synfast","ref":"/Healpix/stable/Cl/#Healpix.synfast","content":" Healpix.synfast  —  Function synfast(cl::Vector{T}, nside::Integer, lmax::Integer, rng::AbstractRNG) where {T <: Real}\nsynfast(cl::Vector{T}, nside::Integer, lmax::Integer) where {T <: Real}\nsynfast(cl::Vector{T}, nside::Integer, rng::AbstractRNG) where {T <: Real}\nsynfast(cl::Vector{T}, nside::Integer) where {T <: Real} Generate a  HealpixMap  with given Nside, from a given power spectra  $C_ℓ$ . Arguments: cl::AbstractVector{T} : The array representing the power spectrum components  $C_ℓ$ . nside::Integer : nside of the map that will contain the result. lmax::Integer : the maximum  $ℓ$  coefficient, will default to  length(cl) -1 if not specified. rng::AbstractRNG  : (optional) the RNG to be used for generating the  $a_{ℓm}$ . It allows to set the seed beforehand guaranteeing the reproducibility of the process. source"},{"id":1139,"pagetitle":"Power Spectrum","title":"Computing the power spectrum from a map","ref":"/Healpix/stable/Cl/#Computing-the-power-spectrum-from-a-map","content":" Computing the power spectrum from a map Compute the (cross-) power spectrum of one (or two)  HealpixMap ."},{"id":1140,"pagetitle":"Power Spectrum","title":"Healpix.anafast","ref":"/Healpix/stable/Cl/#Healpix.anafast","content":" Healpix.anafast  —  Function anafast(map::HealpixMap{Float64, RingOrder, AA};\n        lmax=nothing, mmax=nothing, niter::Integer = 3) where {T <: Real,AA <: AbstractVector{T}} -> Vector{Float64}\nanafast(map₁::HealpixMap{Float64, RingOrder, AA}, map₂::HealpixMap{Float64, RingOrder, AA};\n        lmax=nothing, mmax=nothing, niter::Integer = 3) where {T <: Real,AA <: AbstractVector{T}} -> Vector{Float64} Computes the power spectrum of a Healpix map, or the cross-spectrum between two maps if  map2  is given. No removal of monopole or dipole is performed. The input maps must be in ring-ordering. Arguments: map₁::HealpixMap{Float64, RingOrder, AA} : the spherical harmonic coefficients of the first field map₂::HealpixMap{Float64, RingOrder, AA} : the spherical harmonic coefficients of the second field Returns: Array{T}  containing  $C_ℓ$ , with the first element referring to ℓ=0. source"},{"id":1143,"pagetitle":"Spherical harmonics","title":"Spherical harmonics","ref":"/Healpix/stable/alm/#Spherical-harmonics","content":" Spherical harmonics Starting from version 2.4, Healpix.jl implements generalized Fourier transformations through the  libsharp  library, to convert a map from its pixel-space representation to its decomposition in spherical harmonics. This has multiple applications, the most relevant being the analysis of Cosmic Microwave Background maps and the efficient computation of convolution operators. Everything revolves around the  Alm  type, which encodes a set of spherical harmonics and is thus conceptually equivalent to the concept of a  HealpixMap , only living in the harmonic space:"},{"id":1144,"pagetitle":"Spherical harmonics","title":"Healpix.Alm","ref":"/Healpix/stable/alm/#Healpix.Alm","content":" Healpix.Alm  —  Type Alm{T <: Number, AA <: AbstractVector{T}} An array of harmonic coefficients (a_ℓm). The type  T  is used for the value of each harmonic coefficient, and it must be a  Number  (one should however only use complex types for this). The type  AA  is used to store the array of coefficients; a typical choice is  Vector . A  Alm  type contains the following fields: alm : the array of harmonic coefficients lmax : the maximum value for  $ℓ$ mmax : the maximum value for  $m$ tval : maximum number of  $m$  coefficients for the maximum  $ℓ$ The  $a_{ℓm}$  are stored by  $m$ : if  $ℓ_{max}$  is 16, the first 16 elements are  $m=0$ ,  $ℓ=0-16$ , then the following 15 elements are  $m=1$ ,  $ℓ=1-16$ , then  $m=2$ ,  $ℓ=2-16$  and so on until the last element, the 153th, is  $m=16$ ,  $ℓ=16$ . source In the general case, the number of coefficients in a spherical harmonic expansion is infinite. For obvious reasons, Healpix.jl only allows to store band-limited expansions. The function  numberOfAlms  returns the number of floating-point numbers used to store the expansion, as a function of the maximum value for  $\\ell$  and  $m$ ."},{"id":1145,"pagetitle":"Spherical harmonics","title":"Healpix.numberOfAlms","ref":"/Healpix/stable/alm/#Healpix.numberOfAlms","content":" Healpix.numberOfAlms  —  Function numberOfAlms(lmax::Integer, mmax::Integer) -> Integer\nnumberOfAlms(lmax::Integer) -> Integer Return the size of the array of complex numbers needed to store the a_ℓm coefficients in the range of ℓ and m specified by  lmax  and  mmax . If  mmax  is not specified, it is assumed to be equal to  lmax . If  lmax  and  mmax  are inconsistent or negative, a  DomainError  exception is thrown. source"},{"id":1146,"pagetitle":"Spherical harmonics","title":"Converting between pixel space and harmonic space","ref":"/Healpix/stable/alm/#Converting-between-pixel-space-and-harmonic-space","content":" Converting between pixel space and harmonic space Healpix.jl implements the four functions  alm2map ,  map2alm ,  alm2map! , and  map2alm!  to convert a map from a pixel-space representation to the harmonic space and vice-versa. The functions ending with  !  are  mutating  functions, which means that they assume that the result must be saved in a preallocated variable; they are space- and time-efficient and should be used when you want your code to be performant, or when you plan to apply the same operation several times (e.g., in a Monte Carlo simulation). The synthesis operation ( alm2map ) is generally referred to with the matrix operator  $\\mathrm{Y}$ , while his inverse ( map2alm ) with  $\\mathrm{Y}^{-1}$ . Healpix.jl also implements the two adjoint functions  adjoint_alm2map!  and  adjoint_map2alm! , represented by  $\\mathrm{Y}^{\\mathrm{T}}$  and  $(\\mathrm{Y}^{-1})^\\mathrm{T}$  respectively. While the synthesis operator on a general scalar field  $f(θ, φ)$  can be defined through an exact summation as  $f(θ, φ) = \\mathrm{Y} \\, a_{ℓm}$  where  $f(θ, φ) = \\sum_{ℓ=0}^∞ \\sum_{m=-ℓ}^ℓ a_{ℓm} Y_{ℓm}(θ, φ)$ . The analysis operator is defined through an integral operator as  $a_{ℓm} = \\mathrm{Y}^{-1} f(θ, φ)$  where  $a_{ℓm} = \\int_0^{2π} \\int_0^π Y_{ℓm}^*(θ, φ)\\, f(θ, φ) \\sin θ \\, dθ \\, dφ$ . Though, in the real case wherein maps are pixelized, the latter ends up being approximated through a summation over the pixels. Here is where the adjoint of the synthesis operator,  $\\mathrm{Y}^{\\mathrm{T}}$ , comes into play. It is defined through:  $\\mathrm{Y}^{\\mathrm{T}} f(θ, φ) \\equiv \\sum_{i=1}^{N_{\\mathrm{pix}}} Y_{ℓm,\\,i}^* \\, f_i,$  which is an exact operation. Note that the latter does not give directly the  $a_{\\ell m}$  coefficients, since  $\\mathrm{Y}^{-1} \\simeq \\mathrm{W}\\, \\mathrm{Y}^{\\mathrm{T}}$ , where  $\\mathrm{W}$  is a diagonal matrix whose non-zero elements are approximately constant and equal to  $4π / N_{\\mathrm{pix}}$ , depending on the map pixelization. The latter realtion is also useful to obtain the adjoint of the analysis operator:  $(\\mathrm{Y}^{-1})^\\mathrm{T} = \\mathrm{W}^{\\mathrm{T}}\\,\\mathrm{Y} =  \\mathrm{W}\\,\\mathrm{Y}$ . Here is an example: using Random\n\n# Ensure reproducibility by using a fixed seed\nRandom.seed!(1234)\n\nnside = 8\nm = HealpixMap{Float32,RingOrder}(nside)\n\n# Initialize the pixels to random values in the 0…1 range\nfor i in 1:length(m)\n    m[i] = rand(Float32)\nend\n\nalm = map2alm(m)\n\n# Go back to pixel space\nnewm = alm2map(alm, nside) 768-element HealpixMap{Float64, RingOrder, Vector{Float64}}:\n 0.4334681110199904\n 0.46760588403582776\n 0.2356189978218053\n 0.7677461691857397\n 0.26188278236087537\n 0.438393398270254\n 0.9302889363247367\n 0.8597877691283009\n 0.6675362959627755\n 0.5961908196786236\n ⋮\n 0.40445452823379824\n 0.8160867498711573\n 0.6332998058370749\n 0.612791914793216\n 0.4012637841276252\n 0.19598229849597731\n 0.6998262769237045\n 0.8132148132630672\n 0.43815195983473854 The variable  newm  is a map that is close enough to  m , yet it is not exactly the same because of the approximations done by both  map2alm  and  alm2map ."},{"id":1147,"pagetitle":"Spherical harmonics","title":"Healpix.map2alm!","ref":"/Healpix/stable/alm/#Healpix.map2alm!","content":" Healpix.map2alm!  —  Function map2alm!(map::HealpixMap{Float64, RingOrder, Vector{Float64}},\n         alm::Alm{ComplexF64, Vector{ComplexF64}};\n         niter::Integer=3)\nmap2alm!(map::PolarizedHealpixMap{Float64, RingOrder, Vector{Float64}},\n         alm::Vector{Alm{ComplexF64, Vector{ComplexF64}}};\n         niter::Integer=3) This function performs a spherical harmonic transform on the map and places the results in the passed  alm  object. This function requires types derived from Float64, since it is done in-place. Arguments map : the map that must be decomposed in spherical harmonics. It can either be a  HealpixMap{Float64, RingOrder}  type (scalar map) or a  PolarizedHealpixMap{Float64, RingOrder}  type (polarized map). alm::Alm{ComplexF64, Vector{ComplexF64}} : the spherical harmonic coefficients to be written to. Keywords niter::Integer : number of iterations of SHTs to perform, to enhance accuracy source"},{"id":1148,"pagetitle":"Spherical harmonics","title":"Healpix.map2alm","ref":"/Healpix/stable/alm/#Healpix.map2alm","content":" Healpix.map2alm  —  Function map2alm(map::HealpixMap{Float64, RingOrder, AA};\n        lmax=nothing, mmax=nothing, niter::Integer=3)\nmap2alm(m::HealpixMap{T, RingOrder, AA};\n        lmax=nothing, mmax=nothing,\n        niter::Integer=3) where {T <: Real, AA <: AbstractVector{T}} Compute the spherical harmonic coefficients of a map. To enhance precision, more iterations of the transforms can be performed by passing a nonzero  niter . The underlying SHT library libsharp performs all calculations using  Cdouble  types, so all inputs are converted to types based on Float64. Arguments map : the map to decompose in spherical harmonics. It can either be a  HealpixMap{T, RingOrder, AA}  type (scalar map) or a  PolarizedHealpixMap{T, RingOrder, AA}  type (polarized map). Keywords lmax::Integer : the maximum ℓ coefficient, will default to 3*nside-1 if not specified. mmax::Integer : the maximum m coefficient niter::Integer : number of SHT iterations, to enhance precision. Defaults to 3 Returns Alm{ComplexF64, Vector{ComplexF64}} : the spherical harmonic coefficients corresponding to the map source"},{"id":1149,"pagetitle":"Spherical harmonics","title":"Healpix.alm2map!","ref":"/Healpix/stable/alm/#Healpix.alm2map!","content":" Healpix.alm2map!  —  Function alm2map!(alm::Alm{ComplexF64, Vector{ComplexF64}},\n         map::HealpixMap{Float64, RingOrder, Vector{Float64}})\nalm2map!(alm::Vector{Alm{ComplexF64, Vector{ComplexF64}}},\n         map::PolarizedHealpixMap{Float64, RingOrder, Vector{Float64}}) This function performs a spherical harmonic transform on the map and places the results in the passed  alm  object. This function requires types derived from Float64, since it is done in-place. Arguments alm::Alm{ComplexF64, Vector{ComplexF64}} : the spherical harmonic coefficients to perform the spherical harmonic transform on. map : the map that will contain the result. It can either be a  HealpixMap{Float64, RingOrder, Vector{Float64}}  type (scalar map) or a  PolarizedHealpixMap{Float64, RingOrder, Vector{Float64}}  (polarized map). source"},{"id":1150,"pagetitle":"Spherical harmonics","title":"Healpix.alm2map","ref":"/Healpix/stable/alm/#Healpix.alm2map","content":" Healpix.alm2map  —  Function alm2map(alm::Alm{ComplexF64, Vector{Float64}}, nside::Integer)\nalm2map(alm::Alm{T, Vector{T}}, nside::Integer) where T\nalm2map(alm::Vector{Alm{ComplexF64, Vector{ComplexF64}}}, nside::Integer)\nalm2map(alms::Vector{Alm{T, Vector{T}}}, nside::Integer) where T Compute a map from spherical harmonic coefficients. The underlying SHT library libsharp performs all calculations in Cdouble, so all inputs are converted to types based on Float64. Arguments alm : the spherical harmonic coefficients to transform. If of type  Alm{T, Vector{T}} , we assume a spin-0 spherical harmonic transform. If an array of  Alm  is passed, we assume that the components correspond to T, E, and B coefficients. Keywords nside::Integer : Healpix resolution parameter Returns HealpixMap{Float64, RingOrder, Vector{Float64}}  or  PolarizedHealpixMap{Float64, RingOrder, Vector{Float64}}  depending on if the input alm is of type  Alm{T, Vector{T}}  or  Array{Alm{T,Vector{T}}}  respectively. source"},{"id":1151,"pagetitle":"Spherical harmonics","title":"Healpix.adjoint_alm2map!","ref":"/Healpix/stable/alm/#Healpix.adjoint_alm2map!","content":" Healpix.adjoint_alm2map!  —  Function adjoint_alm2map!(map::HealpixMap{Float64, RingOrder, Vector{Float64}},\n                 alm::Alm{ComplexF64, Vector{ComplexF64}})\nadjoint_alm2map!(map::PolarizedHealpixMap{Float64, RingOrder, Vector{Float64}},\n                 alm::Vector{Alm{ComplexF64, Vector{ComplexF64}}}) This function performs a spherical harmonic transform Yᵀ on the map and places the results in the passed  alm  object. This function requires types derived from Float64, since it is done in-place. Arguments map : the map that must be decomposed in spherical harmonics. It can either be a  HealpixMap{Float64, RingOrder}  type (scalar map) or a  PolarizedHealpixMap{Float64, RingOrder}  type (polarized map). alm::Alm{ComplexF64, Vector{ComplexF64}} : the spherical harmonic coefficients to be written to. source"},{"id":1152,"pagetitle":"Spherical harmonics","title":"Healpix.adjoint_map2alm!","ref":"/Healpix/stable/alm/#Healpix.adjoint_map2alm!","content":" Healpix.adjoint_map2alm!  —  Function adjoint_map2alm!(alm::Alm{ComplexF64, Vector{ComplexF64}},\n                 map::HealpixMap{Float64, RingOrder, Vector{Float64}})\nadjoint_map2alm!(alm::Vector{Alm{ComplexF64, Vector{ComplexF64}}},\n                 map::PolarizedHealpixMap{Float64, RingOrder, Vector{Float64}}) This function performs the spherical harmonic transform (Y^-1)^t = W^t Y = W Y on the map and places the results in the passed  alm  object. This function requires types derived from Float64, since it is done in-place. Arguments alm::Alm{ComplexF64, Vector{ComplexF64}} : the spherical harmonic coefficients to perform the spherical harmonic transform on. map : the map that will contain the result. It can either be a  HealpixMap{Float64, RingOrder, Vector{Float64}}  type (scalar map) or a  PolarizedHealpixMap{Float64, RingOrder, Vector{Float64}}  (polarized map). source"},{"id":1153,"pagetitle":"Spherical harmonics","title":"Healpix.iterate_map2alm!","ref":"/Healpix/stable/alm/#Healpix.iterate_map2alm!","content":" Healpix.iterate_map2alm!  —  Function iterate_map2alm!(\n    maps::Vector{Vector{Float64}}, alms::Vector{Vector{Complex{Float64}}},\n    geom_info::Libsharp.GeomInfo, alm_info::Libsharp.AlmInfo,\n    niter::Integer, spin::Integer) This is an internal function for implementing iterative map2alm, used when the parameter  niter  is greater than 0. It synthesizes a map from the alms, subtracts it from the map to form a residual map, and then adds the harmonic coefficients of the residual map to the alms. It repeats this  niter  times. It performs this in-place on arrays of Float64 and Complex{Float64}. Arguments maps::Vector{Vector{Float64}} : an array where each element is a 1D Healpix map array. alms::Vector{Vector{Complex{Float64}}} : an array where each element is a array of alms geom_info::Libsharp.GeomInfo : contains information about the pixelization alm_info::Libsharp.AlmInfo : contains information about the SHT coefficient ordering niter::Integer : number of iterations to perform spin::Integer : spin of the field, 0 or 2 source"},{"id":1154,"pagetitle":"Spherical harmonics","title":"From harmonic coefficients to the power spectrum","ref":"/Healpix/stable/alm/#From-harmonic-coefficients-to-the-power-spectrum","content":" From harmonic coefficients to the power spectrum You can use the function  alm2cl  to convert a set of  $a_{\\ell m}$  coefficients into the components  $C_\\ell$  of the power spectrum. The pixelization also induces a transfer function, which can be obtained from  pixwin . A simple Gaussian beam window function in the asymptotic small-beam limit can be computed with  gaussbeam ."},{"id":1155,"pagetitle":"Spherical harmonics","title":"Healpix.alm2cl","ref":"/Healpix/stable/alm/#Healpix.alm2cl","content":" Healpix.alm2cl  —  Function alm2cl(alm::Alm{Complex{T}}) where {T <: Number} -> Vector{T}\nalm2cl(alm₁::Alm{Complex{T}}, alm₂::Alm{Complex{T}}) where {T <: Number} -> Vector{T} Compute  $C_ℓ$  from the spherical harmonic coefficients of one or two fields. Arguments alm₁::Alm{Complex{T}} : the spherical harmonic coefficients of the first field alm₂::Alm{Complex{T}} : the spherical harmonic coefficients of the second field Returns Array{T}  containing  $C_ℓ$ , with the first element referring to ℓ=0. source"},{"id":1156,"pagetitle":"Spherical harmonics","title":"Healpix.pixwin","ref":"/Healpix/stable/alm/#Healpix.pixwin","content":" Healpix.pixwin  —  Function pixwin(nside; pol=false) Arguments: nside : HEALPix resolution parameter Keywords pol::Bool=false : if true, also return polarization pixel window Returns: Vector{Float64}  pixel window function. If  pol=true , returns a Tuple   of the temperature and polarization pixel windows. Examples julia> pixwin(4)\n17-element Vector{Float64}:\n 1.0000000000020606\n 0.9942340766588788\n ⋮\n 0.4222841034207188 source"},{"id":1157,"pagetitle":"Spherical harmonics","title":"Healpix.gaussbeam","ref":"/Healpix/stable/alm/#Healpix.gaussbeam","content":" Healpix.gaussbeam  —  Function gaussbeam(fwhm::T, lmax::Int; pol=false) where T Compute the Gaussian beam window function  $B_ℓ$  given the FWHM of the beam in radians, where  $C_{ℓ, \\mathrm{measured}} = B_ℓ^2 C_ℓ$ . This beam is valid in the limit of  $σ^2 \\ll 0$ , which is the case for all high-resolution CMB experiments. Arguments fwhm::T : FWHM of the Gaussian beam in radians lmax::Int : maximum multipole ℓ pol=false : if false, returns the spin-0 beam for i.e. intensity. if true, returns the spin-2 beam Returns Vector{T}  containing  $B_ℓ$ , with the first element referring to ℓ=0. source"},{"id":1158,"pagetitle":"Spherical harmonics","title":"Algebraic operations in harmonic space","ref":"/Healpix/stable/alm/#Algebraic-operations-in-harmonic-space","content":" Algebraic operations in harmonic space Healpix.jl provides overloads of the  Base  functions  + ,  - ,  * ,  / , as well as  LinearAlgebra.dot , allowing to carry out these fundamental operations element-wise in harmonic space directly. For example, an element-wise sum between two  Alm  objects can be performed as follows: using Healpix\n\n#just two constant Alm objects\nmyalm1 = Healpix.Alm(5,5, ones(ComplexF64, Healpix.numberOfAlms(5)))\nmyalm1 = Healpix.Alm(5,5, ones(ComplexF64, Healpix.numberOfAlms(5)))\n\nalm_sum = myalm1 + myalm2 #each element will be = 2 + 0im"},{"id":1159,"pagetitle":"Spherical harmonics","title":"Multiplying or dividing a set of Alm by a generic function of ℓ or a constant","ref":"/Healpix/stable/alm/#Multiplying-or-dividing-a-set-of-Alm-by-a-generic-function-of-ℓ-or-a-constant","content":" Multiplying or dividing a set of Alm by a generic function of ℓ or a constant The operators  *  and  /  can be used to multiply or divide an  Alm  by an  $ℓ$ -dependent generic function  $f_\\ell$  (or just a constant, of type  Number ). In this case a new instance of  Alm  type will be returned. To perform a more efficient in-place operation refer to  almxfl! , as shown in this brief example: using Healpix\n\n#just two constant Alm objects\nmyalm = Healpix.Alm(5,5, ones(ComplexF64, Healpix.numberOfAlms(5)))\nmyf_l = ones(Healpix.numberOfAlms(5)) .* 2\n\n#will return a new object:\nmyalm*myf_l\nmyalm/myf_l\n\n#will overwrite myalm:\nalmxfl!(myalm, myf_l)\nalmxfl!(myalm, 1.0 ./ myf_l) #division In either case the call to such operator consists in a shortcut to the function  almxfl ."},{"id":1160,"pagetitle":"Spherical harmonics","title":"Healpix.almxfl","ref":"/Healpix/stable/alm/#Healpix.almxfl","content":" Healpix.almxfl  —  Function almxfl(alm::Alm{Complex{T}}, fl::AbstractVector{T}) where {T <: Number} -> Alm{T} Multiply an a ℓm by a vector b ℓ representing an ℓ-dependent function, without changing the a_ℓm passed in input. Arguments alms::Alm{Complex{T}} : The  Alm  object containing the spherical harmonics coefficients fl::AbstractVector{T} : The array containing the factors f ℓ to be multiplied by a ℓm Returns Alm{Complex{T}} : The result of a ℓm * f ℓ. source"},{"id":1161,"pagetitle":"Spherical harmonics","title":"Healpix.almxfl!","ref":"/Healpix/stable/alm/#Healpix.almxfl!","content":" Healpix.almxfl!  —  Function almxfl!(alm::Alm{Complex{T}}, fl::AA) where {T <: Number,AA <: AbstractVector{T}} Multiply IN-PLACE an a ℓm by a vector b ℓ representing an ℓ-dependent function. Arguments alms::Alm{Complex{T}} : The  Alm  object containing the spherical harmonics coefficients fl::AbstractVector{T} : The array containing the factors f ℓ to be multiplied by a ℓm source"},{"id":1162,"pagetitle":"Spherical harmonics","title":"Base.:+","ref":"/Healpix/stable/alm/#Base.:+","content":" Base.:+  —  Function +(alm₁::Alm{Complex{T}}, alm₂::Alm{Complex{T}}) where {T <: Number} Perform the element-wise sum in a_ℓm space. A new  Alm  object is returned. source"},{"id":1163,"pagetitle":"Spherical harmonics","title":"Base.:-","ref":"/Healpix/stable/alm/#Base.:-","content":" Base.:-  —  Function -(alm₁::Alm{Complex{T}}, alm₂::Alm{Complex{T}}) where {T <: Number} Perform the element-wise subtraction in a_ℓm space. A new  Alm  object is returned. source"},{"id":1164,"pagetitle":"Spherical harmonics","title":"Base.:*","ref":"/Healpix/stable/alm/#Base.:*","content":" Base.:*  —  Function *(alm₁::Alm{Complex{T}}, alm₂::Alm{Complex{T}}) where {T <: Number} Perform the element-wise product in a_ℓm space. A new  Alm  object is returned. source *(alm₁::Alm{Complex{T}}, fl::AA) where {T <: Number, AA <: AbstractVector{T}} Perform the product of an  Alm  object by a function of ℓ in a_ℓm space. Note: this consists in a shortcut of  almxfl , therefore a new  Alm  object is returned. source *(alm₁::Alm{Complex{T}}, fl::AbstractVector{T}) where {T <: Number} Perform the element-wise product of an  Alm  object by a constant in a_ℓm space. source"},{"id":1165,"pagetitle":"Spherical harmonics","title":"Base.:/","ref":"/Healpix/stable/alm/#Base.:/","content":" Base.:/  —  Function /(alm₁::Alm{Complex{T}}, alm₂::Alm{Complex{T}}) where {T <: Number} Perform an element-wise division in a_ℓm space between two  Alm s. A new  Alm  object is returned. source /(alm₁::Alm{Complex{T}}, fl::AA) where {T <: Number,AA <: AbstractVector{T}} Perform an element-wise division by a function of ℓ in a_ℓm space. A new  Alm  object is returned. source /(alm₁::Alm{Complex{T}}, c::Number) where {T <: Number} Perform an element-wise division by a constant in a_ℓm space. A new  Alm  object is returned. source"},{"id":1166,"pagetitle":"Spherical harmonics","title":"Dot product","ref":"/Healpix/stable/alm/#Dot-product","content":" Dot product Healpix.jl implements an overload of the operator  LinearAlgebra.dot  (along with its shortcut  ⋅ ) to perform a dot product directly in harmonic space. using Healpix\nmyalm = Healpix.Alm(5,5, ones(ComplexF64, Healpix.numberOfAlms(5)))\n\ndot_res = myalm ⋅ myalm #equivalent to dot(myalm, myalm)"},{"id":1167,"pagetitle":"Spherical harmonics","title":"LinearAlgebra.dot","ref":"/Healpix/stable/alm/#LinearAlgebra.dot","content":" LinearAlgebra.dot  —  Function LinearAlgebra.dot(alm₁::Alm{Complex{T}}, alm₂::Alm{Complex{T}}) where {T <: Number} Implements the dot product in a_ℓm space. The two imput alms must have matching size, lmax and mmax. A new  Alm  object is returned. source"},{"id":1168,"pagetitle":"Spherical harmonics","title":"Loading and saving harmonic coefficients","ref":"/Healpix/stable/alm/#Loading-and-saving-harmonic-coefficients","content":" Loading and saving harmonic coefficients"},{"id":1169,"pagetitle":"Spherical harmonics","title":"Healpix.readAlmFromFITS","ref":"/Healpix/stable/alm/#Healpix.readAlmFromFITS","content":" Healpix.readAlmFromFITS  —  Function readAlmFromFITS{T <: Complex}(f::CFITSIO.FITSFile, t::Type{T}) -> Alm{T}\nreadAlmFromFITS{T <: Complex}(fileName::String, t::Type{T}) -> Alm{T} Read a set of a_ℓm coefficients from a FITS file. If the code fails, CFITSIO will raise an exception. (Refer to the CFITSIO library for more information.) source"},{"id":1170,"pagetitle":"Spherical harmonics","title":"Healpix.writeAlmToFITS","ref":"/Healpix/stable/alm/#Healpix.writeAlmToFITS","content":" Healpix.writeAlmToFITS  —  Function writeAlmToFITS(f::CFITSIO.FITSFile, alm::Alm{Complex{T}}) where {T <: Number}\nwriteAlmToFITS(fileName, alm::Alm{Complex{T}}; overwrite = true) where {T <: Number} Write a set of a_ℓm coefficients into a FITS file. If the code fails, CFITSIO will raise an exception. (Refer to the CFITSIO library for more information.) In the fits file the alms are written with explicit index scheme,  $\\mathrm{index} = ℓ^2 + ℓ + m + 1$ , possibly out of order (check  almExplicitIndex ). source"},{"id":1171,"pagetitle":"Spherical harmonics","title":"Alm Indexing","ref":"/Healpix/stable/alm/#Alm-Indexing","content":" Alm Indexing You can use  almExplicitIndex  to compute the so-called explicit indexing. It is exploited for instance in  readAlmFromFITS  and  writeAlmToFITS ."},{"id":1172,"pagetitle":"Spherical harmonics","title":"Healpix.almExplicitIndex","ref":"/Healpix/stable/alm/#Healpix.almExplicitIndex","content":" Healpix.almExplicitIndex  —  Function almExplicitIndex(lmax) -> Vector{Int}\nalmExplicitIndex(lmax, mmax) -> Vector{Int}\nalmExplicitIndex(alm::Alm{T}) where {T} -> Vector{Int} Compute the explicit index scheme, i.e.  $\\mathrm{index} = ℓ^2 + ℓ + m + 1$  up to a certain  $ℓ$  and  $m$  if specified, or taken from the  Alm  passed. If not passed,  mmax  is defaulted to  lmax . If  lmax  and  mmax  are inconsistent or negative, a  DomainError  exception is thrown. source"},{"id":1173,"pagetitle":"Spherical harmonics","title":"Base.eachindex","ref":"/Healpix/stable/alm/#Base.eachindex","content":" Base.eachindex  —  Function eachindex(alm::Alm{Complex{T}}) where {T <: Number} Works as  eachindex(alm.alm) . source The following functions can be used, in an analogous way as  eachindex , in the case of arrays, to obtain sets of indexes or values of  $\\ell$  and  $m$ . On the same line as  eachindex , these can be very useful when implementing for-cycles over  Alm  objects. Here is an example of how to exploit  each_ell_m  to print explicitly the major-m ordering of a set of complex-stored  Alm : using Random\n\n# Initialize a random set of alm\nalm = Alm(4,4, randn(ComplexF64, numberOfAlms(4,4)))\n\n#print a_lm values knowing each corresponding l and m values\nfunction print_alm(alm)\n    i=1\n    for (l,m) in each_ell_m(alm)\n        a_lm = alm.alm[i]\n        print(\"ℓ = $l, |m| = $m: a_ℓm = $a_lm \\n\")\n        i+=1\n    end\nend\n\nprint_alm(alm) ℓ = 0, |m| = 0: a_ℓm = 0.674166420426957 + 0.12015940852663665im\nℓ = 1, |m| = 0: a_ℓm = 0.26995659480246836 - 0.8844655146931267im\nℓ = 2, |m| = 0: a_ℓm = -0.04981357923916372 + 1.4300721142872432im\nℓ = 3, |m| = 0: a_ℓm = -0.18587542663747117 - 0.8335273998823308im\nℓ = 4, |m| = 0: a_ℓm = -0.09984967044067523 + 0.07514927027045089im\nℓ = 1, |m| = 1: a_ℓm = 1.152496792202116 - 0.17820745395383283im\nℓ = 2, |m| = 1: a_ℓm = -0.6196955065952905 + 0.110454124464739im\nℓ = 3, |m| = 1: a_ℓm = -0.41081488076034667 - 0.17405438966620063im\nℓ = 4, |m| = 1: a_ℓm = 0.1274235417609124 + 0.0007035695547599746im\nℓ = 2, |m| = 2: a_ℓm = 0.4574996495040741 + 0.7724404207390505im\nℓ = 3, |m| = 2: a_ℓm = -0.6792132205217944 + 1.0835084382488063im\nℓ = 4, |m| = 2: a_ℓm = -0.7480159232895027 + 0.38608227767646486im\nℓ = 3, |m| = 3: a_ℓm = -0.8786830655943982 - 1.3432904461294208im\nℓ = 4, |m| = 3: a_ℓm = -0.13105413821878326 - 0.0836995560865279im\nℓ = 4, |m| = 4: a_ℓm = -0.15012829847205797 - 0.6991209480376886im"},{"id":1174,"pagetitle":"Spherical harmonics","title":"Healpix.each_ell","ref":"/Healpix/stable/alm/#Healpix.each_ell","content":" Healpix.each_ell  —  Function each_ell(alm::Alm{Complex{T}}, m::Integer) where {T <: Number} -> Vector{Int}\neach_ell(alm::Alm{Complex{T}}, ms::AbstractVector{I}) where {T <: Number, I <: Integer} -> Vector{Int} Returns an array of all the allowed ℓ values in  alm  for the given  m . source"},{"id":1175,"pagetitle":"Spherical harmonics","title":"Healpix.each_ell_idx","ref":"/Healpix/stable/alm/#Healpix.each_ell_idx","content":" Healpix.each_ell_idx  —  Function each_ell_idx(alm::Alm{Complex{T}}, m::Integer) where {T <: Number} -> Vector{Int}\neach_ell_idx(alm::Alm{Complex{T}}, ms::AbstractVector{I}) where {T <: Number, I <: Integer} -> Vector{Int} Returns an array of the indexes of the harmonic coefficients in  alm  corresponding to all the ℓ values for the given m value(s). source"},{"id":1176,"pagetitle":"Spherical harmonics","title":"Healpix.each_m","ref":"/Healpix/stable/alm/#Healpix.each_m","content":" Healpix.each_m  —  Function each_m(alm::Alm{Complex{T}}, l::Integer) where {T <: Number} -> Vector{Int}\neach_m(alm::Alm{Complex{T}}, ls::AbstractVector{I}) where {T <: Number, I <: Integer} -> Vector{Int} Returns an array containing all the allowed m values in  alm  for the given ℓ value(s). source"},{"id":1177,"pagetitle":"Spherical harmonics","title":"Healpix.each_m_idx","ref":"/Healpix/stable/alm/#Healpix.each_m_idx","content":" Healpix.each_m_idx  —  Function each_m_idx(alm::Alm{Complex{T}}, l::Integer) where {T <: Number} -> Vector{Int}\neach_m_idx(alm::Alm{Complex{T}}, ls::AbstractVector{I}) where {T <: Number, I <: Integer} -> Vector{Int} Returns an array of the indexes of the harmonic coefficients in  alm  corresponding to all the allowed m values for the given ℓ value(s). source"},{"id":1178,"pagetitle":"Spherical harmonics","title":"Healpix.each_ell_m","ref":"/Healpix/stable/alm/#Healpix.each_ell_m","content":" Healpix.each_ell_m  —  Function each_ell_m(alm::Alm{Complex{T}}) where {T <: Number} -> Vector{Int} Returns an array of tuples  (l, m)  of all the ℓ and m values of  alm  in m-major order (the same order as how the harmonic coefficients are stored in  Alm  objects). source"},{"id":1179,"pagetitle":"Spherical harmonics","title":"Full Pixel Weights","ref":"/Healpix/stable/alm/#Full-Pixel-Weights","content":" Full Pixel Weights The default  map2alm  uses iteration to obtain an accurate transform. One can instead apply a pixel weight to compute an accurate transform in a single pass, like quadrature. The easiest way to the pixel weight files is to run git clone --depth 1 https://github.com/healpy/healpy-data These weights are in a compressed format that is read with  readFullWeights  and multiplied into a map with  applyFullWeights! . nside = 32\ncompressed_weights = Healpix.readFullWeights(\n    \"healpix_full_weights_nside_$(lpad(nside,4,'0')).fits\")\nm = Healpix.HealpixMap{Float64,Healpix.RingOrder}(ones(Healpix.nside2npix(nside)))\nHealpix.applyFullWeights!(m, compressed_weights)\nalm = Healpix.map2alm(m; niter=0) The subsequent  map2alm  only needs  niter=0 ."},{"id":1180,"pagetitle":"Spherical harmonics","title":"Healpix.readFullWeights","ref":"/Healpix/stable/alm/#Healpix.readFullWeights","content":" Healpix.readFullWeights  —  Function readFullWeights(filename::String) Read the set of pixel weights used to compute the generalized Fourier transform of a map. These weights are usually precomputed; you can download the ones available in the  Healpy repository  using the following command: git clone --depth 1 https://github.com/healpy/healpy-data Arguments: filename::String : filename of the full pixel weights Returns: Vector{Float64} : contains the compressed pixel weights source"},{"id":1181,"pagetitle":"Spherical harmonics","title":"Healpix.applyFullWeights!","ref":"/Healpix/stable/alm/#Healpix.applyFullWeights!","content":" Healpix.applyFullWeights!  —  Function applyFullWeights!(m::HealpixMap{T, RingOrder}, [wgt::Vector{T}]) where T Apply a pixel weighting to a map for more accurate SHTs. Note that this only helps for  lmax<=1.5*Nside . If this is not the case, the pixel weights may do more harm than good. Pixel weights are automatically downloaded if not specified. Arguments: m::HealpixMap{T, RingOrder} : map to modify wgt::Vector{T}  (optional): compressed pixel weights. If not specified, this routine will   look for weights in artifacts. source applyFullWeights!(m::PolarizedHealpixMap{T, RingOrder}, [wgt::Vector{T}]) where T Apply a pixel weighting to a polarized map for more accurate SHTs. Arguments: m::PolarizedHealpixMap{T, RingOrder} : map to modify wgt::Vector{T}  (optional): compressed pixel weights. If not specified, an artifact        will be sought. source"},{"id":1184,"pagetitle":"Map functions","title":"Map functions","ref":"/Healpix/stable/mapfunc/#Map-functions","content":" Map functions Functions like  pix2angNest  and  ang2pixNest  fully define the Healpix tessellation scheme. They are however extremely impractical in a number of situations. It happens often that a large fraction of pixels in a map need to be processed together. Healpix.jl introduces the  HealpixMap{T, O <: Order}  type, which acts as a collection of all the pixels on the sphere. A  HealpixMap  type holds the value of all the pixels in its  pixels  field, and it keeps track of the ordering (either  RING  or  NESTED ). Here is an example that shows how to create a map and initialize it: nside = 32\nm = HealpixMap{Float64, RingOrder}(nside)\nm.pixels[:] = 1.0  # Set all pixels to 1 Healpix.jl defines the basic operations on maps (sum, subtraction, multiplication, division). These operations can either combine two maps or a map and a scalar value: mollweide(m * 2.0)\nmollweide(m * m) The  HealpixMap{T, O <: Order}  is derived from the abstract type  AbstractHealpixMap{T} , which does not encode the ordering. It is useful for functions that can either work on ring/nested-ordered maps but cannot be executed on plain generic arrays: # Return the number of pixels in the map, regardless of its ordering\nmaplength(m::AbstractHealpixMap{T}) where T = length(m)\n\n# This returns 12\nmaplength(HealpixMap{Float64, RingOrder}(1))\n\n# This too returns 12\nmaplength(HealpixMap{Float64, NestedOrder}(1))\n\n# This fails\nmaplength(zeros(Float64, 12)) Healpix.jl implements the  PolarizedHealpixMap{T, O <: Order}  type as well, which derives from  AbstractPolarizedHealpixMap{T} . This encodes three maps containing the I/Q/U signal: the intensity (I), and the Q and U Stokes parameters. The three maps must have the same resolution."},{"id":1185,"pagetitle":"Map functions","title":"Healpix.AbstractHealpixMap","ref":"/Healpix/stable/mapfunc/#Healpix.AbstractHealpixMap","content":" Healpix.AbstractHealpixMap  —  Type abstract type AbstractHealpixMap{T} <: AbstractVector{T} An abstract type representing an Healpix map without a specified ordering. This can be used to implement multiple dispatch when you don't care about the ordering of a map. source"},{"id":1186,"pagetitle":"Map functions","title":"Healpix.HealpixMap","ref":"/Healpix/stable/mapfunc/#Healpix.HealpixMap","content":" Healpix.HealpixMap  —  Type HealpixMap{T, O <: Order, AA <: AbstractVector{T}} <: AbstractHealpixMap{T} A Healpix map. The type  T  is used for the value of the pixels in a map, and it can be anything (even a string!). The type  O  is used to specify the ordering of the pixels, and it can either be  RingOrder  or  NestedOrder . The type  AA  is used to store the array of pixels; typical types are  Vector ,  CUArray ,  SharedArray , etc. A  HealpixMap  type contains the following fields: pixels : array of pixels resolution : instance of a  Resolution  object You can construct a map using one of the following forms: HealpixMap{T, O, AA}(arr)  and  HealpixMap{T, O, AA}(nside::Number)  will use  AA  as basetype HealpixMap{T, O}(arr)  and  HealpixMap{T, O}(nside::Number)  will use  Vector{T}  as basetype Examples The following example creates a map with  NSIDE=32  in  RING  order, containing integer values starting from 1: mymap = Healpix.HealpixMap{Int64, Healpix.RingOrder}(1:Healpix.nside2npix(32)) The call to  collect  is required to convert the range in an array. This example creates a map in  NESTED  order, with  NSIDE=64 , filled with zeroes: mymap = Healpix.HealpixMap{Float64, Healpix.NestedOrder}(64) Finally, the following examples show how to use  SharedArray : using SharedArrays\n\n# Create a map with all pixels set to zero\nmymap = Healpix.HealpixMap{Float64, Healpix.NestedOrder, SharedVector{Float64}}(64)\n\n# Create a map and initialize pixel values with a SharedArray\npixels = SharedVector{Int64}(1:12 |> collect)\nmymap = Healpix.HealpixMap{Int64, Healpix.RingOrder, SharedVector{Int64}}(m) source"},{"id":1187,"pagetitle":"Map functions","title":"Healpix.AbstractPolarizedHealpixMap","ref":"/Healpix/stable/mapfunc/#Healpix.AbstractPolarizedHealpixMap","content":" Healpix.AbstractPolarizedHealpixMap  —  Type AbstractPolarizedHealpixMap{T} An abstract type representing an Healpix polarized map without a specified ordering. This can be used to implement multiple dispatch when you don't care about the ordering of a map. source"},{"id":1188,"pagetitle":"Map functions","title":"Healpix.PolarizedHealpixMap","ref":"/Healpix/stable/mapfunc/#Healpix.PolarizedHealpixMap","content":" Healpix.PolarizedHealpixMap  —  Type mutable struct PolarizedHealpixMap{T, O <: Healpix.Order, AA <: AbstractVector{T}} A polarized I/Q/U map. It contains three Healpix maps with the same NSIDE: i q u You can create an instance of this type using the function  PolarizedHealpixMap{T,O} , which comes in three flavours: PolarizedHealpixMap(i::HealpixMap{T,O,AA}, q::HealpixMap{T,O,AA}, u::HealpixMap{T,O,AA}) PolarizedHealpixMap{T,O}(i::AbstractVector{T}, q::AbstractVector{T}, u::AbstractVector{T}) PolarizedHealpixMap{T,O}(nside::Number) source"},{"id":1189,"pagetitle":"Map functions","title":"Unseen pixels and nothingness","ref":"/Healpix/stable/mapfunc/#Unseen-pixels-and-nothingness","content":" Unseen pixels and nothingness You can use the constant  UNSEEN  to mark unseen pixels, i.e., pixels that lack data associated with them, in a way that is compatible with other Healpix libraries. m = HealpixMap{Float32, RingOrder}(32)\n\n# Mark all the pixels in the map as «unseen» (missing)\nm[:] .= UNSEEN 12288-element view(::HealpixMap{Float32, RingOrder, Vector{Float32}}, :) with eltype Float32:\n -1.6375f30\n -1.6375f30\n -1.6375f30\n -1.6375f30\n -1.6375f30\n -1.6375f30\n -1.6375f30\n -1.6375f30\n -1.6375f30\n -1.6375f30\n  ⋮\n -1.6375f30\n -1.6375f30\n -1.6375f30\n -1.6375f30\n -1.6375f30\n -1.6375f30\n -1.6375f30\n -1.6375f30\n -1.6375f30 However, Julia provides a nicer way to denote missing pixels through the use of  Nothing  (type) and  nothing  (value). Whenever you pass a  Union{Nothing, T}  type to a Healpix map, the map will be initialized to  nothing , and you can test if a pixel has been observer or not using Julia's function  isnothing : m = HealpixMap{Union{Int32, Nothing}, RingOrder}(1)\n\nm[:] = 1:12\nm[5] = nothing\n@assert isnothing(m[5]) Note that, unlike  UNSEEN , this mechanism permits to signal «missing» pixels even for maps that do not use floating-point numbers. Type stability and Nothing Using  Union{Nothing, T}  as the base type of a Healpix map can lead to elegant code, but it is not likely to be efficient! For instance, consider two implementations of the same code, which sums all the pixels in a map that are not marked as  nothing  or  UNSEEN : function sumpixels(m::HealpixMap{Union{Nothing, T}, O}) where {T <: Real, O <: Order}\n   cumsum = zero(Float64)\n   @inbounds for i in eachindex(m)\n       (!isnothing(m[i])) && (cumsum += m[i])\n   end\n   cumsum\nend\n\nfunction sumpixels(m::HealpixMap{T, O}) where {T <: Real, O <: Order}\n   cumsum = zero(Float64)\n   @inbounds for i in eachindex(m)\n       (m[i] != UNSEEN) && (cumsum += m[i])\n   end\n   cumsum\nend Let's now create two maps with random values and 50% of their pixels marked either as  nothing  or  UNSEEN : import Random\nmnothing = HealpixMap{Union{Float64, Nothing}, RingOrder}(1024)\nmnothing[:] = rand(length(mnothing))\n@. mnothing[mnothing < 0.5] = nothing\n\n# Create a new map identical to `mnothing`, but use UNSEEN instead of nothing\nm = HealpixMap{Float64, RingOrder}(mnothing.resolution.nside)\nm[:] = [isnothing(x) ? UNSEEN : x for x in mnothing] Running  sumpixels  over the two maps shows that the version with  UNSEEN  is three times faster. julia> @benchmark sumpixels(mnothing)\n@benchmark sumpixels(m)\nBenchmarkTools.Trial: 56 samples with 1 evaluation.\n Range (min … max):  88.233 ms …  91.043 ms  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     89.187 ms               ┊ GC (median):    0.00%\n Time  (mean ± σ):   89.315 ms ± 502.629 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n                  █ █  ▂ █▅▅                                    \n  ▅▁▁▁▁▁▁▁▁█▁▁▁▁▁▁█▁█▅██▁███▅█▅██▅█▅▁▅▁▅▁▁▁▁▁▅█▁█▅▁▁▁▁▅▅▁▁▁▁▁▅ ▁\n  88.2 ms         Histogram: frequency by time         90.5 ms <\n\n Memory estimate: 16 bytes, allocs estimate: 1.\n\njulia> @benchmark sumpixels(m)\nBenchmarkTools.Trial: 201 samples with 1 evaluation.\n Range (min … max):  22.579 ms … 29.701 ms  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     24.213 ms              ┊ GC (median):    0.00%\n Time  (mean ± σ):   24.906 ms ±  1.939 ms  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n   ▁ ▃█▁▁▅▁▃▁       ▂                                  ▁       \n  ▅█▆█████████▄▆█▁█▅█▆█▃▄█▄▄▃▁▃▆▁▃▃▁▄▃▃▄▁▄▇█▅▁▁▁▁▆▃▃▄▅▄█▅▃▃▁▃ ▄\n  22.6 ms         Histogram: frequency by time        29.2 ms <\n\n Memory estimate: 16 bytes, allocs estimate: 1. This happens because the implementation of  sumpixels  that uses  nothing  values is not  type-stable . You should decide if the elegance of using  nothing  in your code is worth this degradation in performance or not. You can use  saveToFITS  or  readMapFromFITS  on maps whose base type is  Union{Nothing, T}  only if  T  is a floating-point number, because for the sake of compatibility with other Healpix libraries the FITS file will use  UNSEEN  to mark missing values."},{"id":1190,"pagetitle":"Map functions","title":"Healpix.UNSEEN","ref":"/Healpix/stable/mapfunc/#Healpix.UNSEEN","content":" Healpix.UNSEEN  —  Constant A constant commonly used by Healpix libraries to mark «missing» pixels. This constant is useful if you need compatibility with other Healpix libraries. source"},{"id":1191,"pagetitle":"Map functions","title":"Encoding the order","ref":"/Healpix/stable/mapfunc/#Encoding-the-order","content":" Encoding the order Healpix.jl distinguishes between  RING  and  NEST  orderings using Julia's typesystem. The abstract type  Order  has two descendeants,  RingOrder  and  NestedOrder , which are used to instantiate objects of type  HealpixMap . Applying the functions  nest2ring  and   ring2nest  to maps converts those maps to the appropriate orders. In-place  nest2ring!  and  ring2nest!  versions are also  available."},{"id":1192,"pagetitle":"Map functions","title":"Healpix.Order","ref":"/Healpix/stable/mapfunc/#Healpix.Order","content":" Healpix.Order  —  Type abstract type Order Abstract type representing the ordering of pixels in a Healpix map. See also  RingOrder  and  NestedOrder . source"},{"id":1193,"pagetitle":"Map functions","title":"Healpix.RingOrder","ref":"/Healpix/stable/mapfunc/#Healpix.RingOrder","content":" Healpix.RingOrder  —  Type abstract type RingOrder <: Order The  RingOrder  type should be used when creating  HealpixMap  types in order to specify that the pixels in the map are sorted in ring ordering. (See also  NestedOrder .) source"},{"id":1194,"pagetitle":"Map functions","title":"Healpix.NestedOrder","ref":"/Healpix/stable/mapfunc/#Healpix.NestedOrder","content":" Healpix.NestedOrder  —  Type abstract type NestedOrder <: Order The  NestedOrder  type should be used when creating  HealpixMap  types in order to specify that the pixels in the map are sorted in ring ordering. (See also  RingOrder .) source"},{"id":1195,"pagetitle":"Map functions","title":"Healpix.nest2ring","ref":"/Healpix/stable/mapfunc/#Healpix.nest2ring-Union{Tuple{HealpixMap{T, NestedOrder, AA}}, Tuple{AA}, Tuple{T}} where {T, AA}","content":" Healpix.nest2ring  —  Method nest2ring(m_nest::HealpixMap{T, NestedOrder, AA}) where {T, AA} Convert a map from nested to ring order. This version allocates a new array of the same array type as the input. Arguments: m_nest::HealpixMap{T, NestedOrder, AA} : map of type  NestedOrder Returns: HealpixMap{T, RingOrder, AA} : the input map converted to  RingOrder Examples julia> m_nest = HealpixMap{Float64,NestedOrder}(rand(nside2npix(64)));\n\njulia> nest2ring(m_nest)\n49152-element HealpixMap{Float64, RingOrder, Vector{Float64}}:\n 0.4703834205807309\n ⋮\n 0.3945848051663148 source"},{"id":1196,"pagetitle":"Map functions","title":"Healpix.ring2nest","ref":"/Healpix/stable/mapfunc/#Healpix.ring2nest-Union{Tuple{HealpixMap{T, RingOrder, AA}}, Tuple{AA}, Tuple{T}} where {T, AA}","content":" Healpix.ring2nest  —  Method ring2nest(m_ring::HealpixMap{T, RingOrder, AA}) where {T, AA} Convert a map from ring to nested order. This version allocates a new array of the same array type as the input. Arguments: m_ring::HealpixMap{T, RingOrder, AA} : map of type  RingOrder Returns: HealpixMap{T, NestedOrder, AA} : the input map converted to  NestedOrder Examples julia> m_ring = HealpixMap{Float64,RingOrder}(rand(nside2npix(64)));\n\njulia> ring2nest(m_ring)\n49152-element HealpixMap{Float64, NestedOrder, Vector{Float64}}:\n 0.0673134062168923\n ⋮\n 0.703460503535335 source"},{"id":1197,"pagetitle":"Map functions","title":"Healpix.nest2ring!","ref":"/Healpix/stable/mapfunc/#Healpix.nest2ring!-Union{Tuple{AAR}, Tuple{AAN}, Tuple{T}, Tuple{HealpixMap{T, RingOrder, AAR}, HealpixMap{T, NestedOrder, AAN}}} where {T, AAN, AAR}","content":" Healpix.nest2ring!  —  Method nest2ring!(m_ring_dst::HealpixMap{T, RingOrder, AAR},\n           m_nest_src::HealpixMap{T, NestedOrder, AAN}) where {T, AAN, AAR} Convert a map from nested to ring order. This version takes a nested map in the second argument and writes it to the nested map provided in the first argument, following the standard Julia  func!(dst, src)  convention. Arguments: m_ring_dst::HealpixMap{T, NestedOrder, AA} : map of type  NestedOrder m_nest_src::HealpixMap{T, NestedOrder, AAN} : map of type  RingOrder Returns: HealpixMap{T, RingOrder, AA} : the input map converted to  RingOrder Examples julia> m_nest = HealpixMap{Float64,NestedOrder}(rand(nside2npix(64)));\n\njulia> m_ring = HealpixMap{Float64,RingOrder}(64);\n\njulia> nest2ring!(m_ring, m_nest)\n49152-element HealpixMap{Float64, RingOrder, Vector{Float64}}:\n 0.33681791815569895\n ⋮\n 0.9092457003948482 source"},{"id":1198,"pagetitle":"Map functions","title":"Healpix.ring2nest!","ref":"/Healpix/stable/mapfunc/#Healpix.ring2nest!-Union{Tuple{AAN}, Tuple{AAR}, Tuple{T}, Tuple{HealpixMap{T, NestedOrder, AAN}, HealpixMap{T, RingOrder, AAR}}} where {T, AAR, AAN}","content":" Healpix.ring2nest!  —  Method ring2nest!(m_nest_dst::HealpixMap{T, NestedOrder, AAN},\n           m_ring_src::HealpixMap{T, RingOrder, AAR}) where {T, AAR, AAN} Convert a map from ring to nested order. This version takes a nested map in the second argument and writes it to the nested map provided in the first argument, following the standard Julia  func!(dst, src)  convention. Arguments: m_nest_dst::HealpixMap{T, NestedOrder, AAN} : map of type  RingOrder m_ring_src::HealpixMap{T, RingOrder, AA} : map of type  RingOrder Returns: HealpixMap{T, NestedOrder, AA} : the input map converted to  NestedOrder Examples julia> m_ring = HealpixMap{Float64,RingOrder}(rand(nside2npix(64)));\n\njulia> m_nest = HealpixMap{Float64,RingOrder}(64);\n\njulia> ring2nest!(m_nest, m_ring)\n49152-element HealpixMap{Float64, NestedOrder, Vector{Float64}}:\n 0.0673134062168923\n ⋮\n 0.703460503535335 source"},{"id":1199,"pagetitle":"Map functions","title":"Pixel functions","ref":"/Healpix/stable/mapfunc/#Pixel-functions","content":" Pixel functions When working with maps, it is not needed to pick between  ang2pixNest  and  ang2pixRing  because a  HealpixMap  type already encodes the ordering. Functions  pix2ang  and  ang2pix  always choose the correct ordering, but they require a  HealpixMap  instead of a  Resolution  as their first argument."},{"id":1200,"pagetitle":"Map functions","title":"Healpix.pix2ang","ref":"/Healpix/stable/mapfunc/#Healpix.pix2ang","content":" Healpix.pix2ang  —  Function pix2ang{T, O <: Order}(map::HealpixMap{T, O}, ipix) -> (Float64, Float64)\npix2ang{T, O <: Order}(map::PolarizedHealpixMap{T, O}, ipix) -> (Float64, Float64) Return the pair ( theta ,  phi ), where  theta  is the colatitude and  phi  the longitude of the direction of the pixel center with index  ipix . source"},{"id":1201,"pagetitle":"Map functions","title":"Healpix.ang2pix","ref":"/Healpix/stable/mapfunc/#Healpix.ang2pix","content":" Healpix.ang2pix  —  Function ang2pix{T, O, AA}(map::HealpixMap{T, O}, theta, phi)\nang2pix{T, O, AA}(map::PolarizedHealpixMap{T, O}, theta, phi) Convert the direction specified by the colatitude  theta  (∈ [0, π]) and the longitude  phi  (∈ [0, 2π]) into the index of the pixel in the Healpix map  map . source"},{"id":1202,"pagetitle":"Map functions","title":"Loading and saving maps","ref":"/Healpix/stable/mapfunc/#Loading-and-saving-maps","content":" Loading and saving maps Healpix.jl implements a number of functions to save maps in FITS files."},{"id":1203,"pagetitle":"Map functions","title":"Healpix.saveToFITS","ref":"/Healpix/stable/mapfunc/#Healpix.saveToFITS","content":" Healpix.saveToFITS  —  Function saveToFITS(map::HealpixMap{T, O}, filename::AbstractString, typechar=\"D\", unit=\"\", extname=\"MAP\") where {T <: Number, O <: Order}\nsaveToFITS(map::PolarizedHealpixMap{T, O}, filename::AbstractString, typechar=\"D\", unit=\"\", extname=\"MAP\") where {T <: Number, O <: Order} Save a map into a FITS file. The name of the file is specified in  filename ; if it begins with  ! , existing files will be overwritten without warning. The parameter  typechar  specifies the data type to be used in the FITS file: the default ( D ) will save 64-bit floating-point values. See the CCFITSIO documentation for other values. The keyword  unit  specifies the measure unit used for the pixels in the map. The keyword  extname  specifies the name of the HDU where the map pixels will be written. source Function  savePixelsToFITS  is a low-level function. It knows nothing about the ordering schema used for the pixels, so the caller should manually write the  ORDERING  keyword in the HDU header by itself."},{"id":1204,"pagetitle":"Map functions","title":"Healpix.savePixelsToFITS","ref":"/Healpix/stable/mapfunc/#Healpix.savePixelsToFITS","content":" Healpix.savePixelsToFITS  —  Function savePixelsToFITS(map::HealpixMap{T}, f::CFITSIO.FITSFile, column) where {T <: Number} Save the pixels of  map  into the column with index/name  column  in the FITS file, which must have been already opened. source To load a map from a FITS file, you can either use  readMapFromFITS  or  readPolarizedMapFromFITS ."},{"id":1205,"pagetitle":"Map functions","title":"Healpix.readMapFromFITS","ref":"/Healpix/stable/mapfunc/#Healpix.readMapFromFITS","content":" Healpix.readMapFromFITS  —  Function readMapFromFITS{T}(f::CFITSIO.FITSFILE, column, t::Type{T})\nreadMapFromFITS{T}(fileName::String, column, t::Type{T}) Read a Healpix map from the specified (1-base indexed) column in a FITS file. The values will be read as numbers of type T. If the code fails, CFITSIO will raise an exception. (Refer to the CFITSIO library for more information.) source"},{"id":1206,"pagetitle":"Map functions","title":"Healpix.readPolarizedMapFromFITS","ref":"/Healpix/stable/mapfunc/#Healpix.readPolarizedMapFromFITS","content":" Healpix.readPolarizedMapFromFITS  —  Function readPolarizedMapFromFITS{T}(fileName::AbstractString, column, t::Type{T}) Read a polarized map (I/Q/U) from a FITS file and return a  PolarizedHealpixMap  object. The parameter  column  can be either a number or a 3-element tuple. In the first case, three consecutive columns will be read starting from  column  (1-based index), otherwise the three column indices will be used. source"},{"id":1207,"pagetitle":"Map functions","title":"Testing for conformability","ref":"/Healpix/stable/mapfunc/#Testing-for-conformability","content":" Testing for conformability It often happens that two Healpix maps need to be combined together: for instance, pixels on a sky map might need to be masked using a sky mask, or one map might need to be subtracted from another one. «Conformability» means that the operation between the two maps can be done directly on the pixels, without oordering or resolution conversions. The function  conformables  checks this. julia> m1 = HealpixMap{Float64, RingOrder}(1) 12-element HealpixMap{Float64, RingOrder, Vector{Float64}}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0 julia> m2 = HealpixMap{Float64, RingOrder}(1) 12-element HealpixMap{Float64, RingOrder, Vector{Float64}}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0 julia> m3 = HealpixMap{Float64, NestedOrder}(1) 12-element HealpixMap{Float64, NestedOrder, Vector{Float64}}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0 julia> m4 = HealpixMap{Float64, NestedOrder}(2) 48-element HealpixMap{Float64, NestedOrder, Vector{Float64}}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n ⋮\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0 julia> conformables(m1, m2) true julia> conformables(m1, m3) false julia> conformables(m1, m4) false"},{"id":1208,"pagetitle":"Map functions","title":"Healpix.conformables","ref":"/Healpix/stable/mapfunc/#Healpix.conformables","content":" Healpix.conformables  —  Function conformables{T, S, O1, O2}(map1::HealpixMap{T, O1, AA1},\n                           map2::HealpixMap{S, O2, AA2}) -> Bool\nconformables{T, S, O1, O2}(map1::PolarizedHealpixMap{T, O1, AA1},\n                           map2::PolarizedHealpixMap{S, O2, AA2}) -> Bool Determine if two Healpix maps are \"conformables\", i.e., if their shape and ordering are the same. The array types  AA1  and  AA2  are not considered in testing conformability. source"},{"id":1209,"pagetitle":"Map functions","title":"Interpolation","ref":"/Healpix/stable/mapfunc/#Interpolation","content":" Interpolation The fact that a Healpix map is, well, pixelized means that there is a sharp boundary between adjacent pixels. This can lead to undesidable effects, and therefore Healpix.jl provides a function,  interpolate , that returns the interpolated value of the map along some direction in the sky: If the direction (θ, ɸ) passes through the center of a pixel,  interpolate  returns the value of the pixel itself; Otherwise, the value of the pixel and its neighbours will be interpolated using a linear function to return a weighted value."},{"id":1210,"pagetitle":"Map functions","title":"Healpix.interpolate","ref":"/Healpix/stable/mapfunc/#Healpix.interpolate","content":" Healpix.interpolate  —  Function interpolate(m::HealpixMap{T, RingOrder, AA}, θ, ϕ) -> Value\ninterpolate(m::HealpixMap{T, RingOrder, AA}, θ, ϕ, pixbuf, weightbuf) -> Value Return an interpolated value of the map along the specified direction. When provided, the parameters  pixbuf  and  weightbuf  must be 4-element arrays of integer and floating-point values, respectively. They can be reused across multiple calls of  interpolate , to save heap allocations, and they do not need to be initialized, as they are used internally: pixbuf = Vector{Int}(undef, 4)\nweightbuf = Vector{Float64}(undef, 4)\n\nm = HealpixMap{Float64, RingOrder}(1)\nfor (θ, ϕ) in [(0., 0.), (π/2, π/2)]\n    println(interpolate(m, θ, ϕ, pixbuf, weightbuf))\nend Passing  pixbuf  and  weightbuf  saves some time, as this simple benchmark shows: julia> @benchmark interpolate(m, rand(), rand(), pixbuf, weightbuf)\nBenchmarkTools.Trial:\n  memory estimate:  618 bytes\n  allocs estimate:  9\n  --------------\n  minimum time:     283.184 ns (0.00% GC)\n  median time:      296.140 ns (0.00% GC)\n  mean time:        348.132 ns (9.55% GC)\n  maximum time:     10.627 μs (95.88% GC)\n  --------------\n  samples:          10000\n  evals/sample:     282\n\njulia> @benchmark interpolate(m, rand(), rand())\nBenchmarkTools.Trial:\n  memory estimate:  837 bytes\n  allocs estimate:  11\n  --------------\n  minimum time:     329.825 ns (0.00% GC)\n  median time:      345.504 ns (0.00% GC)\n  mean time:        417.004 ns (11.04% GC)\n  maximum time:     13.733 μs (96.21% GC)\n  --------------\n  samples:          10000\n  evals/sample:     223 source"},{"id":1211,"pagetitle":"Map functions","title":"Upgrading and Downgrading","ref":"/Healpix/stable/mapfunc/#Upgrading-and-Downgrading","content":" Upgrading and Downgrading Changing resolution is done with  udgrade . This is very fast for nested orderings, but slow for ring ordering."},{"id":1212,"pagetitle":"Map functions","title":"Healpix.udgrade","ref":"/Healpix/stable/mapfunc/#Healpix.udgrade","content":" Healpix.udgrade  —  Function udgrade(input_map::HealpixMap{T,O,AA}, output_nside; kw...) where {T,O,AA} -> HealpixMap{T,O,AA} Upgrades or downgrades a map to a target nside. Always makes a copy. This is very fast for nested orderings, but slow for ring because one needs to transform to nested ordering first. Arguments: input_map::HealpixMap{T,O,AA} : the map to upgrade/downgrade output_nside : desired nside Keywords: threshold=abs(1e-6UNSEEN) : absolute tolerance for identifying a bad pixel vs UNSEEN pess=false : if false, estimate pixels from remaining good pixels when downgrading.   if true, the entire downgraded pixel is set to UNSEEN. Returns: HealpixMap{T,O,AA} : upgraded/downgraded map in the same ordering as the input Examples julia> A = HealpixMap{Float64, NestedOrder}(ones(nside2npix(4)))\n192-element HealpixMap{Float64, RingOrder, Vector{Float64}}:\n 1.0\n ⋮\n 1.0\n\njulia> Healpix.udgrade(A, 2)\n48-element HealpixMap{Float64, NestedOrder, Vector{Float64}}:\n 1.0\n ⋮\n 1.0 source"},{"id":1213,"pagetitle":"Map functions","title":"Map-making","ref":"/Healpix/stable/mapfunc/#Map-making","content":" Map-making Map-making is the process of converting a time series of measurements into a sky map. The most basic form of map-making is the so-called \"binning\", where samples in the time stream falling within the same sky pixel are averaged. This map-making algorithm is strictly accurate only if the noise in the time stream is white. Healpix.jl implements two functions to perform binning,  tod2map  and  combinemaps! ."},{"id":1214,"pagetitle":"Map functions","title":"Healpix.tod2map","ref":"/Healpix/stable/mapfunc/#Healpix.tod2map","content":" Healpix.tod2map  —  Function tod2map{T,O}(pixidx, tod::Array{T}; nside=128) :: (map, hits) Create a binned map for a TOD and return a tuple containing the map itself and the hit map. source"},{"id":1215,"pagetitle":"Map functions","title":"Healpix.combinemaps!","ref":"/Healpix/stable/mapfunc/#Healpix.combinemaps!","content":" Healpix.combinemaps!  —  Function combinemaps{T, O, H}(destmap::HealpixMap{T, O}, desthitmap::HealpixMap{H, O},\n                     othermap::HealpixMap{T, O}, otherhitmap::HealpixMap{H, O}) Sum \"othermap\" to \"destmap\", assuming that both maps have been produced by binning TODs. The parameters  desthitmap  and  otherhitmap  are the two hit maps. At the end of the call,  destmap  and  desthitmap  are updated. source"},{"id":1218,"pagetitle":"Miscellanea","title":"General-purpose functions","ref":"/Healpix/stable/misc/#General-purpose-functions","content":" General-purpose functions Healpix.jl implements a few generic functions that can be helpful when doing calculations on the sphere."},{"id":1219,"pagetitle":"Miscellanea","title":"Healpix.lat2colat","ref":"/Healpix/stable/misc/#Healpix.lat2colat","content":" Healpix.lat2colat  —  Function lat2colat(x)\ncolat2lat(x) Convert colatitude into latitude and vice versa. Both  x  and the result are expressed in radians. source"},{"id":1220,"pagetitle":"Miscellanea","title":"Healpix.colat2lat","ref":"/Healpix/stable/misc/#Healpix.colat2lat","content":" Healpix.colat2lat  —  Function lat2colat(x)\ncolat2lat(x) Convert colatitude into latitude and vice versa. Both  x  and the result are expressed in radians. source"},{"id":1221,"pagetitle":"Miscellanea","title":"RecipesBase.plot","ref":"/Healpix/stable/misc/#RecipesBase.plot","content":" RecipesBase.plot  —  Function plot(m::HealpixMap{T, O, AA}, projection = mollweide, projparams = Dict()) Draw a representation of the map, using some specific projection. The parameter  projection  must be a function returning the bitmap. Possible values for  projection  are the following: equirectangular mollweide orthographic orthographic2 gnomonic You can define your own projections. The dictionary  projparams  allows to hack a number of parameters used in the projection. References See also  equirectangular ,  mollweide ,  orthographic ,  orthographic2 , and  gnomonic . source"},{"id":1224,"pagetitle":"Pixel functions","title":"Pixel functions","ref":"/Healpix/stable/pixelfunc/#Pixel-functions","content":" Pixel functions In this section we document the functions that convert from a direction in the sky into a pixel index, and vice versa. First of all, Healpix.jl implements the most basic functions to convert between spherical and Cartesian coordinates. Note that Healpix uses  co-latitude  instead of  latitude : julia> ang2vec(0.0, 0.0) (0.0, 0.0, 1.0) julia> vec2ang(0.0, 0.0, 1.0) (0.0, 0.0) More interesting functions return the index of the pixel on a Healpix-tessellated sphere. For these functions to work, you have to provide a  Resolution  object: julia> res = Resolution(16) Healpix resolution(NSIDE = 16) julia> ang2pixRing(res, π/2, 0) 1441 julia> ang2pixNest(res, π/2, 0) 1217"},{"id":1225,"pagetitle":"Pixel functions","title":"Ring functions","ref":"/Healpix/stable/pixelfunc/#Ring-functions","content":" Ring functions The Healpix projection has the advantage of storing pixels along iso-latitude rings; this allows to implement efficient spherical-transform functions. Healpix.jl provides a number of functions that manage rings. Many of them use the  RingInfo  structure, which encodes details about a ring."},{"id":1226,"pagetitle":"Pixel functions","title":"Healpix.RingInfo","ref":"/Healpix/stable/pixelfunc/#Healpix.RingInfo","content":" Healpix.RingInfo  —  Type RingInfo Information about a ring of pixels, i.e., the set of pixels on a Healpix map which have the same colatitude. The type is \"mutable\", so that one object can begin reused many times without further memory allocations. The list of fields defined in this structure is the following: ring : an integer index, running from firstPixIdx : index of the first pixel (using the  RING  scheme) belonging to this ring numOfPixels : number of consecutive pixels within the ring colatitude_rad : value of the colatitude for this ring (in radians) shifted : Boolean flag; it is  true  if the longitude of the first pixel in the ring is not zero. References See also  getringinfo!  and  getringinfo . Example import Healpix\nres = Healpix.Resolution(256)\n\n# Show information about ring #10\nprint(getringinfo(res, 10)) source"},{"id":1227,"pagetitle":"Pixel functions","title":"Healpix.getringinfo","ref":"/Healpix/stable/pixelfunc/#Healpix.getringinfo","content":" Healpix.getringinfo  —  Function getringinfo(resol::Resolution, ring; kwargs...) :: RingInfo Return a RingInfo structure containing information about the specified ring. For the list of accepted keyword arguments, see getringinfo!. source"},{"id":1228,"pagetitle":"Pixel functions","title":"Healpix.getringinfo!","ref":"/Healpix/stable/pixelfunc/#Healpix.getringinfo!","content":" Healpix.getringinfo!  —  Function getringinfo!(resol::Resolution, ring, ringinfo::RingInfo; full=true) :: RingInfo Fill the RingInfo structure with information about the specified ring. If  full  is  false , the field  colatitude_rad  (the most expensive in terms of computation) is set to  NaN . source"},{"id":1229,"pagetitle":"Pixel functions","title":"Healpix.getinterpolRing","ref":"/Healpix/stable/pixelfunc/#Healpix.getinterpolRing","content":" Healpix.getinterpolRing  —  Function getinterpolRing(resol::Resolution, θ, ϕ) -> (Vector{Int}, Vector{Float64})\ngetinterpolRing!(resol::Resolution, θ, ϕ, pix, weights) -> (Vector{Int}, Vector{Float64}) Return the indices and the weights of the four neighbour pixels for the given direction (θ, ϕ) in a map with the specified resolution. If provided, the parameters  pix  and  weights  should point to two 4-element arrays of integers and floating-points, respectively. They can be reused in multiple calls to avoid heap allocations and speed up the code. source"},{"id":1230,"pagetitle":"Pixel functions","title":"Pixel boundaries","ref":"/Healpix/stable/pixelfunc/#Pixel-boundaries","content":" Pixel boundaries It is sometimes useful to be able to trace the border of a pixel: this can be useful for plotting purposes. Healpix.jl implements the  boundariesRing!  and  boundariesRing  functions for this purpose. They calculate a set of  $N$  vectors pointing to a number of points along the border of a given pixel and return them as a  $N\\times 3$  matrix. Here is a visual example: using Plots\n\npointsperside = 10\nmatr = boundariesRing(Resolution(2), 3, pointsperside, Float32)\nscatter(matr[:, 1], matr[:, 2], matr[:, 3], label=\"\") GKS: cannot open display - headless operation mode active We can cycle this over  all  the pixels in a map; however, using  boundariesRing  will require the result matrix to be allocated again and again for each pixel. Here  boundariesRing!  comes to the rescue, as we can pre-allocate the matrix and then pass it to each call within the  for  loop: using Plots\n\npointsperside = 10\nmatr = Matrix{Float32}(undef, 4pointsperside, 3)\nresol = Resolution(2)\n\nscatter()\nfor pixidx in 1:resol.numOfPixels\n    boundariesRing!(resol, pixidx, pointsperside, matr)\n    scatter!(matr[:, 1], matr[:, 2], matr[:, 3], label=\"\")\nend"},{"id":1231,"pagetitle":"Pixel functions","title":"Reference","ref":"/Healpix/stable/pixelfunc/#Reference","content":" Reference"},{"id":1232,"pagetitle":"Pixel functions","title":"Healpix.ang2vec","ref":"/Healpix/stable/pixelfunc/#Healpix.ang2vec-Tuple{Any, Any}","content":" Healpix.ang2vec  —  Method ang2vec(theta, phi) -> Array{Float64} Given a direction in the sky with colatitude  theta  and longitude  phi  (in radians), return an array of 3 elements containing the  x ,  y , and  z  components of the one-length vector pointing to that direction. source"},{"id":1233,"pagetitle":"Pixel functions","title":"Healpix.vec2ang","ref":"/Healpix/stable/pixelfunc/#Healpix.vec2ang-Tuple{Any, Any, Any}","content":" Healpix.vec2ang  —  Method vec2ang(x, y, z) -> (Number, Number) Given a vector (not necessarily normalized) whose Cartesian components are  x ,  y , and  z , return a pair ( theta ,  phi ) containing the colatitude  theta  and the longitude  phi  (in radians) of the direction in the sky the vector is pointing at. source"},{"id":1234,"pagetitle":"Pixel functions","title":"Healpix.ang2pixNest","ref":"/Healpix/stable/pixelfunc/#Healpix.ang2pixNest-Tuple{Resolution, Any, Any}","content":" Healpix.ang2pixNest  —  Method ang2pixNest(resol::Resolution, theta, phi) -> Integer Return the index of the pixel which contains the point with coordinates ( theta , the colatitude, and  phi , the longitude), in radians, for a Healpix map with pixels in nested order. Note that pixel indexes are 1-based (this is Julia)! source"},{"id":1235,"pagetitle":"Pixel functions","title":"Healpix.zphi2pixRing","ref":"/Healpix/stable/pixelfunc/#Healpix.zphi2pixRing-Tuple{Resolution, Any, Any}","content":" Healpix.zphi2pixRing  —  Method zphi2pixRing(resol::Resolution, theta, phi) -> Integer Return the index of the pixel which contains the point with coordinates ( theta , the colatitude, and  phi , the longitude), in radians, for a Healpix map with pixels in ring order. Note that pixel indexes are 1-based (this is Julia)! source"},{"id":1236,"pagetitle":"Pixel functions","title":"Healpix.ang2pixRing","ref":"/Healpix/stable/pixelfunc/#Healpix.ang2pixRing-Tuple{Resolution, Any, Any}","content":" Healpix.ang2pixRing  —  Method ang2pixRing(resol::Resolution, theta, phi) -> Integer Return the index of the pixel which contains the point with coordinates ( theta , the colatitude, and  phi , the longitude), in radians, for a Healpix map with pixels in ring order. Note that pixel indexes are 1-based (this is Julia)! source"},{"id":1237,"pagetitle":"Pixel functions","title":"Healpix.pix2angNest","ref":"/Healpix/stable/pixelfunc/#Healpix.pix2angNest-Tuple{Resolution, Any}","content":" Healpix.pix2angNest  —  Method pix2angNest(resol::Resolution, pixel) -> (Float64, Float64) Given the (1-based) index of a pixel in a Healpix map in nested order, return a pair containing the ( colatitude ,  longitude ) angles corresponding to its center, both expressed in radians. source"},{"id":1238,"pagetitle":"Pixel functions","title":"Healpix.pix2angRing","ref":"/Healpix/stable/pixelfunc/#Healpix.pix2angRing-Tuple{Resolution, Any}","content":" Healpix.pix2angRing  —  Method pix2angRing(resol::Resolution, pixel) -> (Float64, Float64) Given the (1-based) index of a pixel in a Healpix map in ring order, return a pair containing the ( colatitude ,  longitude ) angles corresponding to its center, both expressed in radians. source"},{"id":1239,"pagetitle":"Pixel functions","title":"Healpix.ring2nest","ref":"/Healpix/stable/pixelfunc/#Healpix.ring2nest-Tuple{Resolution, Any}","content":" Healpix.ring2nest  —  Method ring2nest(resol::Resolution, ipix) :: Int Convert the number of a pixel from RING to NESTED scheme. source"},{"id":1240,"pagetitle":"Pixel functions","title":"Healpix.nest2ring","ref":"/Healpix/stable/pixelfunc/#Healpix.nest2ring-Tuple{Resolution, Any}","content":" Healpix.nest2ring  —  Method nest2ring(resol::Resolution, ipix) :: Int Convert the number of a pixel from NESTED to RING scheme. source"},{"id":1241,"pagetitle":"Pixel functions","title":"Healpix.pix2ringpos","ref":"/Healpix/stable/pixelfunc/#Healpix.pix2ringpos-Tuple{Resolution, Any}","content":" Healpix.pix2ringpos  —  Method pix2ringpos(resol::Resolution, pixel) Given the (1-based) index of a pixel in a Healpix map in ring order, return a pair of numbers (n, i, j) whose meaning is the following: n  can be one of the symbols  :northcap ,  :equator , or  :southcap , representing the region of the sky i  is the ring index, from 1 to 4NSIDE - 1 j  is the pixel-in-ring index source"},{"id":1242,"pagetitle":"Pixel functions","title":"Healpix.pix2xyfNest","ref":"/Healpix/stable/pixelfunc/#Healpix.pix2xyfNest-Tuple{Resolution, Any}","content":" Healpix.pix2xyfNest  —  Method pix2xyfNest(resol::Resolution, ipix) :: (Int, Int, Int) Convert a pixel number into (x, y, face), using NESTED ordering. source"},{"id":1243,"pagetitle":"Pixel functions","title":"Healpix.pix2xyfRing","ref":"/Healpix/stable/pixelfunc/#Healpix.pix2xyfRing-Tuple{Resolution, Any}","content":" Healpix.pix2xyfRing  —  Method pix2xyfRing(resol::Resolution, ipix) :: (Int, Int, Int) Convert a pixel number into (x, y, face), using RING ordering. source"},{"id":1244,"pagetitle":"Pixel functions","title":"Healpix.xyf2pixNest","ref":"/Healpix/stable/pixelfunc/#Healpix.xyf2pixNest-Tuple{Resolution, Any, Any, Any}","content":" Healpix.xyf2pixNest  —  Method xyf2pixNest(resol::Resolution, ix, iy, facenum) :: Int Convert (x, y, face) into a pixel number, using NESTED ordering. source"},{"id":1245,"pagetitle":"Pixel functions","title":"Healpix.xyf2pixRing","ref":"/Healpix/stable/pixelfunc/#Healpix.xyf2pixRing-Tuple{Resolution, Any, Any, Any}","content":" Healpix.xyf2pixRing  —  Method xyf2pixRing(resol::Resolution, ix, iy, facenum) :: Int Convert (x, y, face) into a pixel number, using RING ordering. source"},{"id":1246,"pagetitle":"Pixel functions","title":"Healpix.xyf2loc","ref":"/Healpix/stable/pixelfunc/#Healpix.xyf2loc","content":" Healpix.xyf2loc  —  Function xyf2loc(x, y, face) -> (z, phi, sintheta, have_sintheta) Given a position encoded as XYF, return the tuple containing  $z = cos(\\theta)$ ,  \\phi , and optionally an accurate estimate for  $sin(\\theta)$  (if  have_sintheta  is  true ), where  $\\theta$  is the colatitude and  $\\phi$  is the longitude, both expressed in radians. source"},{"id":1247,"pagetitle":"Pixel functions","title":"Healpix.pix2zphiRing","ref":"/Healpix/stable/pixelfunc/#Healpix.pix2zphiRing-Tuple{Resolution, Any}","content":" Healpix.pix2zphiRing  —  Method pix2zphiRing(res::Resolution, pix) -> (z, phi) Compute the angular coordinates  z = cos(θ), ϕ  of the center of the pixel with number  pix , assuming the  RING  numbering scheme for pixels.  Caution:  this method is inaccurate near the poles at high resolutions. source"},{"id":1248,"pagetitle":"Pixel functions","title":"Healpix.pix2zphiNest","ref":"/Healpix/stable/pixelfunc/#Healpix.pix2zphiNest-Tuple{Resolution, Any}","content":" Healpix.pix2zphiNest  —  Method pix2zphiNest(res::Resolution, pix) -> (z, phi) Compute the angular coordinates  z = cos(θ), ϕ  of the center of the pixel with number  pix , assuming the  NEST  numbering scheme for pixels.  Caution:  this method is inaccurate near the poles at high resolutions. source"},{"id":1249,"pagetitle":"Pixel functions","title":"Healpix.ringAbove","ref":"/Healpix/stable/pixelfunc/#Healpix.ringAbove","content":" Healpix.ringAbove  —  Function ringAbove(res::Resolution, z) -> (ring_number) Return the number of the next ring to the north of  z = cos(θ) . If  z  lies north of all rings, the function returns 0. source"},{"id":1250,"pagetitle":"Pixel functions","title":"Healpix.ring2theta","ref":"/Healpix/stable/pixelfunc/#Healpix.ring2theta","content":" Healpix.ring2theta  —  Function Create an array of the colatitude in radians (theta) of each ring index in `rings` for a map with resolution `res`.\n\nIf no `rings` array is passed, the computation is performed on all the rings deducted from `res`.\n\nIf an integer `ring` is passed, a single Float value of the colatitude is returned. source"},{"id":1251,"pagetitle":"Pixel functions","title":"Healpix.ring2z","ref":"/Healpix/stable/pixelfunc/#Healpix.ring2z","content":" Healpix.ring2z  —  Function ring2z(res::Resolution, ring) -> z Return the value of  z = \\cos(\\theta)  for the given ring. source"},{"id":1252,"pagetitle":"Pixel functions","title":"Healpix.getRingPixels","ref":"/Healpix/stable/pixelfunc/#Healpix.getRingPixels","content":" Healpix.getRingPixels  —  Function getRingPixels(map::HealpixMap{T,RingOrder,AA}, ring_info::RingInfo) where {T <: Real, AA <: AbstractVector{T}}\ngetRingPixels(map::HealpixMap{T,RingOrder,AA}, ring_idx::Integer) where {T <: Real, AA <: AbstractVector{T}} Returns by reference a slice ( view ) of the pixels in  map  corresponding to the given  ring_info  or  ring_idx . source"},{"id":1253,"pagetitle":"Pixel functions","title":"Healpix.numOfRings","ref":"/Healpix/stable/pixelfunc/#Healpix.numOfRings","content":" Healpix.numOfRings  —  Function numOfRings(resol::Resolution)\nnumOfRings(nside::Integer) Return the number of horizontal rings in a Healpix map. source"},{"id":1254,"pagetitle":"Pixel functions","title":"Healpix.getEquatorIdx","ref":"/Healpix/stable/pixelfunc/#Healpix.getEquatorIdx","content":" Healpix.getEquatorIdx  —  Function getEquatorIdx(nside::Integer)\ngetEquatorIdx(res::Resolution)\n\nComputes the ring index of the equator in a map of `Resolution` `res` or\nNSIDE parameter given by `nside`. source"},{"id":1255,"pagetitle":"Pixel functions","title":"Healpix.max_pixrad","ref":"/Healpix/stable/pixelfunc/#Healpix.max_pixrad","content":" Healpix.max_pixrad  —  Function max_pixrad(res::Resolution, ring)\nmax_pixrad(res::Resolution) Return the maximum angular distance (in radians) between a pixel center and any of its corners. If  ring  is specified, the result applies to all the pixels of the given ring; otherwise, all the pixels on the sphere are considered. source"},{"id":1256,"pagetitle":"Pixel functions","title":"Healpix.boundariesRing","ref":"/Healpix/stable/pixelfunc/#Healpix.boundariesRing","content":" Healpix.boundariesRing  —  Function boundariesRing(resol::Resolution, pix, step, T::Type{<:Real})\nboundariesRing!(resol::Resolution, pix, step, buf::Matrix{T}) where {T <: Real} Compute a set of directions (3D vectors) along the boundaries of a given pixel in the RING scheme at some resolution. The function  boundariesRing  returns a  $N \\times 3$  matrix of type  T  containing  $N$  vectors pointing towards the border of the pixel with index  pix  in RING scheme. Each edge of the pixel contains  step  points, and, as every pixel has a diamond-like shape with four edges, the number  $N$  is equal to  4 * step . If you plan to call this function again and again, you should allocate your own matrix with the results and call  boundariesRing! , which accepts the parameter  buf  where the result will be stored. The shape of this matrix must be  (4step, 3) , for instance, and its element can be left undefined: step = 10\nbuf = Matrix{Float64}(undef, 4step, 3)\nboundariesRing!(res, pixidx, step, buf)  # This sets `buf` Examples Here we show how to use  boundariesRing  and  boundariesRing!  together to avoid allocating a matrix twice. julia> matr = boundariesRing(Resolution(16), 534, 2, Float16)\n8×3 Matrix{Float16}:\n 0.3535  -0.6123  0.707\n 0.3525  -0.6353  0.687\n 0.3513  -0.657   0.6665\n 0.3762  -0.664   0.646\n 0.4014  -0.6694  0.625\n 0.4084  -0.645   0.646\n 0.414   -0.6196  0.6665\n 0.3843  -0.6167  0.687\n\njulia> boundariesRing!(Resolution(16), 535, 2, matr)  # Reuse `matr`\n\njulia> matr\n8×3 Matrix{Float16}:\n 0.4158  -0.5723  0.707\n 0.415   -0.596   0.687\n 0.414   -0.6196  0.6665\n 0.4397  -0.624   0.646\n 0.465   -0.627   0.625\n 0.4697  -0.602   0.646\n 0.473   -0.576   0.6665\n 0.4446  -0.5747  0.687 source"},{"id":1257,"pagetitle":"Pixel functions","title":"Healpix.boundariesRing!","ref":"/Healpix/stable/pixelfunc/#Healpix.boundariesRing!","content":" Healpix.boundariesRing!  —  Function boundariesRing!(resol::Resolution, pix, step, buf::Matrix{T}) where {T <: Real} See the documentation for  boundariesRing . source"},{"id":1260,"pagetitle":"Query functions","title":"Query functions","ref":"/Healpix/stable/query/#Query-functions","content":" Query functions It is often useful to perform calculations on a set of adjacent pixels in a map. Asking for the indices of pixels within a given region of the sphere is called a  query , and this kind of function can be implemented efficiently using the Healpix scheme. The functions that query a set of pixels satisfying some proximity criteria are the following: queryDiscRing queryStripRing Let's show an example about how to use  queryDiscRing , which returns a list of the indexes of the pixels that fall within some angle from a direction on the sky sphere: resol = Resolution(32)\n(theta, phi) = (1.3, 0.7)\nradius = deg2rad(10.0)\npixidx = queryDiscRing(resol, theta, phi, radius) 92-element Vector{Int64}:\n 3534\n 3535\n 3536\n 3661\n 3662\n 3663\n 3664\n 3665\n 3788\n 3789\n    ⋮\n 5199\n 5200\n 5201\n 5325\n 5326\n 5327\n 5328\n 5455\n 5456 We can visualize where these pixels are using a Mollweide projection: m = HealpixMap{Float32, RingOrder}(resol.nside);\nm[pixidx] .= 1;\n\nm[ang2pix(m, theta, phi)] = 2  # Highlight the pixel at the center\n\nusing Plots\nplot(m) The function  queryDiscRing  accepts an optional keyword  fact  that specifies the resolution to be used in computing the result; it can be any positive integer, and the actual resolution is  fact * NSIDE ."},{"id":1261,"pagetitle":"Query functions","title":"Reference","ref":"/Healpix/stable/query/#Reference","content":" Reference"},{"id":1262,"pagetitle":"Query functions","title":"Healpix.queryDiscRing","ref":"/Healpix/stable/query/#Healpix.queryDiscRing","content":" Healpix.queryDiscRing  —  Function queryDiscRing(resol::Resolution, theta, phi, radius; fact=0) Return a list of the indices of those pixels whose centers are closer than  radius  to direction  (theta, phi) . The three angles  radius ,  theta , and  phi  must be expressed in radians. If  fact  is nonzero, it must be a positive integer; it requires to carry the computation at a resolution  fact * nside . source"},{"id":1263,"pagetitle":"Query functions","title":"Healpix.queryStripRing","ref":"/Healpix/stable/query/#Healpix.queryStripRing","content":" Healpix.queryStripRing  —  Function queryStripRing(resol::Resolution, theta1, theta2; inclusive=true) Return a range of the indices of pixels that overlap with the colatitude range  [theta1, theta2] . If  inclusive  is set to  false , only those pixels whose  centers  lie within the colatitude range are returned. This function assumes the RING scheme, because in this case, the indexes of the pixels cover a range without gaps. Therefore, the function returns a  range  instead of a  list , as it is quicker and occupies far less memory. source"},{"id":1266,"pagetitle":"Working with resolutions","title":"Working with resolutions","ref":"/Healpix/stable/resolutions/#Working-with-resolutions","content":" Working with resolutions A Healpix tessellation is parametrized by a number, called  NSIDE , which must be a positive power of 2. It is related to the number of pixels  $N$  in the maps by the simple equation  $N = 12 \\mathrm{NSIDE}^2$ , and it is therefore related to the resolution of the pixelization. Any function working on a Healpix tessellation needs to receive the value of  NSIDE . Healpix.jl provides a wrapper around this parameter, the  Resolution  type, which internally keeps a number of precomputed coefficients to accelerate calculations. The following example prints a table containing details about a few Healpix resolutions: using Printf\n\n@printf(\"%-6s\\t%-12s\\t%-12s\\t%-12s\\n\",\n        \"NSIDE\",\n        \"#pix\",\n        \"#pix per face\",\n        \"solid angle\")\nfor poweroftwo in [0, 1, 2, 3, 4, 5]\n    res = Resolution(2 ^ poweroftwo)\n    @printf(\"%6d\\t%12d\\t%12d\\t%12.4f\\n\",\n            res.nside,\n            res.numOfPixels,\n            res.pixelsPerFace,\n            4π / res.numOfPixels)\nend NSIDE \t#pix        \t#pix per face\tsolid angle\n     1\t          12\t           1\t      1.0472\n     2\t          48\t           4\t      0.2618\n     4\t         192\t          16\t      0.0654\n     8\t         768\t          64\t      0.0164\n    16\t        3072\t         256\t      0.0041\n    32\t       12288\t        1024\t      0.0010 There is an upper limit to the value of the  NSIDE  parameter, which is encoded in the constant  NSIDE_MAX . The value is determined at runtime according to the size of the  Int  type; on 32-bit machines it is 8192 ( $2^{13}$ ), while on 64-bit machines it is 536870912 ( $2^{29}$ )."},{"id":1267,"pagetitle":"Working with resolutions","title":"Healpix.Resolution","ref":"/Healpix/stable/resolutions/#Healpix.Resolution","content":" Healpix.Resolution  —  Type struct Resolution Resolution  objects are needed to perform a number of pixel-related functions, e.g., convert a direction into a pixel number and vice versa. The fields of a  Resolution  object are the following: nside : the NSIDE parameter nsideTimesTwo : 2 * NSIDE nsideTimesFour : 4 * NSIDE numOfPixels : number of pixels in the map order : order of the map pixelsPerFace : number of pixels in each Healpix face ncap fact2 fact1 source"},{"id":1268,"pagetitle":"Working with resolutions","title":"Healpix.Resolution","ref":"/Healpix/stable/resolutions/#Healpix.Resolution-Tuple{Integer}","content":" Healpix.Resolution  —  Method Resolution(nside) -> Resolution Create a  Resolution  object, given a value for  NSIDE . source"},{"id":1269,"pagetitle":"Working with resolutions","title":"Healpix.nsideok","ref":"/Healpix/stable/resolutions/#Healpix.nsideok-Tuple{Integer}","content":" Healpix.nsideok  —  Method nsideok(nside::Integer) -> Bool Check whether  nside  is a valid  NSIDE  parameter. source"},{"id":1270,"pagetitle":"Working with resolutions","title":"Healpix.nside2npix","ref":"/Healpix/stable/resolutions/#Healpix.nside2npix-Tuple{Integer}","content":" Healpix.nside2npix  —  Method nside2npix(nside::Integer) -> Integer Return the number of pixels for a Healpix map with the specified  NSIDE  value. If  NSIDE  is not an integer power of two, the function throws a  DomainError  exception. source"},{"id":1271,"pagetitle":"Working with resolutions","title":"Healpix.npix2nside","ref":"/Healpix/stable/resolutions/#Healpix.npix2nside-Tuple{Integer}","content":" Healpix.npix2nside  —  Method npix2nside(npix::Integer) -> Integer Given the number of pixels in a Healpix map, return the  NSIDE  resolution parameter. If the number is invalid, throw a  DomainError  exception. source"},{"id":1272,"pagetitle":"Working with resolutions","title":"Healpix.nside2pixarea","ref":"/Healpix/stable/resolutions/#Healpix.nside2pixarea-Tuple{Integer}","content":" Healpix.nside2pixarea  —  Method nside2pixarea(nside::Integer) -> Real Return the solid angle of a pixel in a map with the specified  NSIDE  parameter. The result is expressed in steradians. source"},{"id":1273,"pagetitle":"Working with resolutions","title":"Healpix.nside2resol","ref":"/Healpix/stable/resolutions/#Healpix.nside2resol-Tuple{Integer}","content":" Healpix.nside2resol  —  Method nside2resol(nside::Integer) -> Real Return the approximate resolution of a map with the specified  NSIDE . The resolution is expressed in radians, and it is the square root of the pixel size. source"},{"id":1274,"pagetitle":"Working with resolutions","title":"Healpix.nside2order","ref":"/Healpix/stable/resolutions/#Healpix.nside2order-Tuple{Integer}","content":" Healpix.nside2order  —  Method nside2order(nside::Integer) Return the order (positive integer) associated with a given NSIDE. If the given nside is not valid, throw a  DomainError  exception. If you have created a  Healpix.Resolution  object, you can access the order through the field  order . See also  order2nside . source"},{"id":1275,"pagetitle":"Working with resolutions","title":"Healpix.order2nside","ref":"/Healpix/stable/resolutions/#Healpix.order2nside-Tuple{Integer}","content":" Healpix.order2nside  —  Method order2nside(order::Integer) Return the value of NSIDE for a given order. If the given order is not valid, throw a  DomainError  exception. If you have created a  Healpix.Resolution  object, you can access the value of NSIDE through the field  nside . See also  nside2order . source"},{"id":1276,"pagetitle":"Working with resolutions","title":"Healpix.ORDER_MAX","ref":"/Healpix/stable/resolutions/#Healpix.ORDER_MAX","content":" Healpix.ORDER_MAX  —  Constant ORDER_MAX Maximum order for the resolution of a map supported on this machine. The value of  NSIDE_MAX  is equal to  2^ORDER_MAX . source"},{"id":1277,"pagetitle":"Working with resolutions","title":"Healpix.NSIDE_MAX","ref":"/Healpix/stable/resolutions/#Healpix.NSIDE_MAX","content":" Healpix.NSIDE_MAX  —  Constant NSIDE_MAX Maximum allowed value for the NSIDE resolution parameter. source"},{"id":1280,"pagetitle":"Visualization","title":"Visualization functions","ref":"/Healpix/stable/visualization/#Visualization-functions","content":" Visualization functions Healpix.jl uses RecipesBase to display maps. You need to import  Plots  in order to display maps, using the  plot  functions.  Maps are internally treated as heatmaps, so your backend should support this kind of visualization: at the moment, this is true for GR, PlotLy and PyPlot. using Healpix\nusing Plots\n\nnside = 8\nm = HealpixMap{Float64, RingOrder}(nside)\nm.pixels[:] = 1:length(m.pixels)\nplot(m) A call to  plot  can provide two additional arguments: A carthographic projection (see below). A dictionary containing parameters to be used by the carthographic projection. The following example displays the same map in orthographic coordinates: plot(m, orthographic)"},{"id":1281,"pagetitle":"Visualization","title":"Cartographic projections","ref":"/Healpix/stable/visualization/#Cartographic-projections","content":" Cartographic projections Plotting is based on  project , which takes a map as input and produces a 2-D bitmap containing a representation of the map suitable to be shown using  Plots . Although the easiest way to plot a map is to use  plot ,  project  might be suitable in those cases where you are just interested in a 2D bitmap. It requires a  inverse  projection function (mapping the 2D plane to a point on the sphere) and the size of the bitmap, and it returns three values: A 2-D bitmap containing the color level of each pixel. Unseen pixels (e.g., those falling outside the ellipse in a Mollweide projection) are marked as  NaN , as well as unseen pixels; A 2-D bitmap of  Bool  values, telling which pixels in the map are masked, i.e., they are marked as  UNSEEN ,  NaN  or  missing  in the Healpix map; A  Bool  flag telling if there is any masked value in the mask (2nd return value, see above). This parameter is returned to optimize calls to  plot , but it is obviously redundant. Consider this example: using Healpix\n\nm = HealpixMap{Float64, RingOrder}(1)\n# Plot the map on a 20×20 bitmap using an\n# equirectangular projection\nimage, mask, maskflag = project(equiprojinv, m, 20, 20) (Float32[0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], Bool[0 0 … 0 0; 0 0 … 0 0; … ; 0 0 … 0 0; 0 0 … 0 0], false) A number of parameters can be passed to  project , in order to taylor the representation. They must  not  be passed as keyword arguments, because this would clash with the way plot recipes work; instead, you must use a dictionary: # Return a 2-D bitmap of 16-bit floating-point values\nimage, _, _ = project(equiprojinv, m, 20, 20,\n                      Dict(:desttype => Float16)) (Float16[0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], Bool[0 0 … 0 0; 0 0 … 0 0; … ; 0 0 … 0 0; 0 0 … 0 0], false) The following dictionary keys are available: :desttype : type used for the pixels in the 2-D bitmap returned by  project . Default is  Float32 ; :unseen : the value marking pixels as unseen, i.e., masked. The default is  -1.6375e+30 , to preserve compatibility with other Healpix libraries. :center : currently this is used only with orthographic projections. It specifies the coordinates of the center of the image (colatitude and longitude, both in radians)."},{"id":1282,"pagetitle":"Visualization","title":"Healpix.project","ref":"/Healpix/stable/visualization/#Healpix.project","content":" Healpix.project  —  Function project(invprojfn, m::HealpixMap{T, O, AA}, bmpwidth, bmpheight; kwargs...) Return a 2D bitmap (array) containing a cartographic projection of the map and a 2D bitmap containing a boolean mask. The size of the bitmap is  bmpwidth × bmpheight  pixels. The function  projfn  must be a function which accepts as input two parameters  x  and  y  (numbers between -1 and 1). The following keywords can be used in the call: center : 2-tuple specifying the location (colatitude, longitude) of the sky point that is to be placed in the middle of the image (in radians) unseen : by default, Healpix maps use the value -1.6375e+30 to mark unseen pixels. You can specify a different value using this keyword. This should not be used in common applications. Return a  Array{Union{Missing, Float32}}  containing the intensity of each pixel. Pixels falling outside the projection are marked as NaN, and unseen pixels are marked as  missing . source"},{"id":1283,"pagetitle":"Visualization","title":"Projection functions","ref":"/Healpix/stable/visualization/#Projection-functions","content":" Projection functions Functions  mollweide ,  equirectangular , and  orthographic  can be passed as parameters to  plot ."},{"id":1284,"pagetitle":"Visualization","title":"Healpix.mollweide","ref":"/Healpix/stable/visualization/#Healpix.mollweide","content":" Healpix.mollweide  —  Function mollweide(m::HealpixMap{T, O, AA}, projparams = Dict()) where {T <: Number, O, AA} High-level wrapper around  project  for Mollweide projections. The following parameters can be set in the  projparams  dictionary: width : width of the image, in pixels (default: 720 pixels) height : height of the image, in pixels; if not specified, it will be assumed to be equal to  width source"},{"id":1285,"pagetitle":"Visualization","title":"Healpix.equirectangular","ref":"/Healpix/stable/visualization/#Healpix.equirectangular","content":" Healpix.equirectangular  —  Function equirectangular(m::HealpixMap{T,O,AA}; kwargs...) where {T <: Number, O, AA} High-level wrapper around  project  for equirectangular projections. source"},{"id":1286,"pagetitle":"Visualization","title":"Healpix.orthographic","ref":"/Healpix/stable/visualization/#Healpix.orthographic","content":" Healpix.orthographic  —  Function orthographic(m::HealpixMap{T,O}, projparams = Dict()) where {T <: Number,O <: Order} High-level wrapper around  project  for orthographic projections. The following parameters can be set in the  projparams  dictionary: width : width of the image, in pixels (default: 720 pixels) height : height of the image, in pixels; if not specified, it will be assumed to be equal to  width center : position of the pixel in the middle of the left globe ( latitude  and longitude). source"},{"id":1287,"pagetitle":"Visualization","title":"Healpix.orthographic2","ref":"/Healpix/stable/visualization/#Healpix.orthographic2","content":" Healpix.orthographic2  —  Function orthographic2(m::HealpixMap{T, O, AA}, projparams = Dict()) where {T <: Number, O, AA} High-level wrapper around  project  for stereo orthographic projections. The following parameters can be set in the  projparams  dictionary: width : width of the image, in pixels (default: 720 pixels) height : height of the image, in pixels; if not specified, it will be assumed to be equal to  width center : position of the pixel in the middle of the left globe ( latitude  and longitude). Default is (0, 0). source"},{"id":1288,"pagetitle":"Visualization","title":"Healpix.gnomonic","ref":"/Healpix/stable/visualization/#Healpix.gnomonic","content":" Healpix.gnomonic  —  Function gnomonic(m::HealpixMap{T, O, AA}, projparams = Dict()) where {T <: Number, O, AA} High-level wrapper around  project  for gnomonic projections. The following parameters can be set in the  projparams  dictionary: width : width of the image, in pixels (default: 720 pixels) height : height of the image, in pixels; if not specified, it will be assumed to be equal to  width center : position and orientation of the pixel in the middle. It is a 3-element tuple containing: The  latitude  of the pixel, in radians The longitude of the pixel, in radians The rotation to be applied to the image, in radians fov_rad : size of the image along the x and y axes, in radians (default: 15°) Example plot(m, gnomonic, Dict(:fov_rad = deg2rad(1.5), :center = (0, 0, deg2rad(45)))) source They are based on  inverse  projection functions, i.e., functions that take a point in the plane  $[-1, 1] \\times [-1, 1]$  and return a tuple  (Bool, Number, Number) , where the first Boolean is  true  if the point falls within the projection, and the other two numbers are the latitude and longitude in radians."},{"id":1289,"pagetitle":"Visualization","title":"Healpix.mollweideprojinv","ref":"/Healpix/stable/visualization/#Healpix.mollweideprojinv","content":" Healpix.mollweideprojinv  —  Function mollweideprojinv(x, y) Inverse Mollweide projection. Given a point  (x, y)  on the plane, with  x ∈ [-1, 1] ,  y ∈ [-1, 1] , return a 3-tuple of type  (Bool, Number, Number) . The boolean specifies if  (x, y)  falls within the map ( true ) or not ( false ), the second and third arguments are the latitude and longitude in radians. source"},{"id":1290,"pagetitle":"Visualization","title":"Healpix.equiprojinv","ref":"/Healpix/stable/visualization/#Healpix.equiprojinv","content":" Healpix.equiprojinv  —  Function equiprojinv(x, y) Inverse equirectangular projection. Given a point  (x, y)  on the plane  [-1, 1] × [-1, 1] , return a tuple  (Bool, Number, Number)  where the first Boolean is a flag telling if the point falls within the projection ( true ) or not ( false ), and the two numbers are the latitude and longitude in radians. source"},{"id":1291,"pagetitle":"Visualization","title":"Healpix.orthoinv","ref":"/Healpix/stable/visualization/#Healpix.orthoinv","content":" Healpix.orthoinv  —  Function orthoinv(x, y, ϕ1, λ0) Inverse orthographic projection centered on  (ϕ1, λ0).  Given a point  (x, y)  on the plane, with  x ∈ [-1, 1] ,  y ∈ [-1, 1] , return a 3-tuple of type  (Bool, Number, Number) . The boolean specifies if  (x, y)  falls within the map ( true ) or not ( false ), the second and third arguments are the latitude and longitude in radians. source"},{"id":1292,"pagetitle":"Visualization","title":"Healpix.ortho2inv","ref":"/Healpix/stable/visualization/#Healpix.ortho2inv","content":" Healpix.ortho2inv  —  Function ortho2inv(x, y, ϕ1, λ0) Inverse stereo orthographic projection centered on  (ϕ1, λ0) . Given a point  (x, y)  on the plane, with  x ∈ [-1, 1] ,  y ∈ [-1, 1] , return a 3-tuple of type  (Bool, Number, Number) . The boolean specifies if  (x, y)  falls within the map ( true ) or not ( false ), the second and third arguments are the latitude and longitude in radians. source"},{"id":1293,"pagetitle":"Visualization","title":"Healpix.gnominv","ref":"/Healpix/stable/visualization/#Healpix.gnominv","content":" Healpix.gnominv  —  Function gnominv(x, y, ϕ1, λ0, fov_rad) Gnomonic projection centered on  (ϕ1, λ0) , with a field of view equal to  fov_rad  (in radians).  Given a point  (x, y)  on the plane, with  x ∈ [-1, 1] ,  y ∈ [-1, 1] , return a 3-tuple of type  (Bool, Number, Number) . The boolean specifies if  (x, y)  falls within the map ( true ) or not ( false ), the second and third arguments are the latitude and longitude in radians. source The direct project functions are available too."},{"id":1294,"pagetitle":"Visualization","title":"Healpix.equiproj","ref":"/Healpix/stable/visualization/#Healpix.equiproj","content":" Healpix.equiproj  —  Function equiproj(lat, lon) Equirectangular projection. Given the latitude  lat  (in radians) and the longitude (in radians), return a tuple (Bool, Number, Number) where the first Boolean is a flag telling if the point falls within the projection (true) or not (false), and the two numbers are the x and y coordinates of the point on the projection plane (both are in the range [−1, 1]). source"},{"id":1295,"pagetitle":"Visualization","title":"Healpix.mollweideproj","ref":"/Healpix/stable/visualization/#Healpix.mollweideproj","content":" Healpix.mollweideproj  —  Function mollweideproj(lat, lon) Mollweide projection. Given the latitude  lat  (in radians) and the longitude (in radians), return a tuple  (Bool, Number, Number)  where the first Boolean is a flag telling if the point falls within the projection ( true ) or not ( false ), and the two numbers are the x and y coordinates of the point on the projection plane (both are in the range [ −1, 1] ). source"},{"id":1298,"pagetitle":"Reproject","title":"Reproject","ref":"/Reproject/stable/#Reproject","content":" Reproject Implementation in  Julia  of the  reproject  package by Thomas Robitaille, part of the Astropy project. This package can be used to reproject Astronomical Images from one world coordinate to another. By reproject we mean re-gridding of images using interpolation (i.e changing the pixel resolution, orientation, coordinate system)."},{"id":1299,"pagetitle":"Reproject","title":"Installation","ref":"/Reproject/stable/#Installation","content":" Installation Reproject.jl is avilable for Julia 1.0 and later versions and can be installed with  Julia built-in package manager . julia> import Pkg; Pkg.add(\"Reproject\")"},{"id":1300,"pagetitle":"Reproject","title":"Usage","ref":"/Reproject/stable/#Usage","content":" Usage After installing the package, you can start using it with julia> using Reproject\n\njulia> result = reproject(input_data, output_projection) This returns a tuple of reprojected Image and footprint."},{"id":1301,"pagetitle":"Reproject","title":"Reprojecting Images","ref":"/Reproject/stable/#Reprojecting-Images","content":" Reprojecting Images To reproject Astronomical Images, primary requirements are Image data (2D Matrix), world cordinate frame of input Image and required output frame in which it needs to be reprojected. The Image data and input frame is given together as an  ImageHDU  or  FITS  file or name of the FITS file in  input_data . A keyword argument  hdu_in  can be given while using FITS or FITS file name to specify specific HDU in FITS file. The  output_projection  is the output world coordinate frame and needs to be a a  WCSTransform  or an  ImageHDU  or  FITS  file or name of the FITS file. A keyword argument  hdu_out  can be given while using FITS or FITS file name to specify specific HDU in FITS file. WCS information is extracted from header when ImageHDU or FITS file is given as  output_projection . Order of Interpolation can be specified by keyword  order  (i.e 0, 1(default), 2). The dimensions of output Image can be given by keyword  shape_out . This can be used to change resolution."},{"id":1302,"pagetitle":"Reproject","title":"Example","ref":"/Reproject/stable/#Example","content":" Example julia> using Reproject, FITSIO\n\njulia> input_data = FITS(\"gc_msx_e.fits\")\n\njulia> output_projection = FITS(\"gc_2mass_k.fits\")\n\njulia> result = reproject(input_data, output_projection, shape_out = (1000,1000), order = 2, hdu_in = 1, hdu_out = 1) Input Image: Output: Test files can be obtained from  here ."},{"id":1303,"pagetitle":"Reproject","title":"Related Packages","ref":"/Reproject/stable/#Related-Packages","content":" Related Packages Check out  AstroImages.jl , which use this package to form coloured RGB image from 2D CCD Astromonical Images."},{"id":1304,"pagetitle":"Reproject","title":"License","ref":"/Reproject/stable/#License","content":" License The  reproject  package is released under the terms of the BSD 3-Clause \"New\" or \"Revised\" License.  The  Reproject.jl  package received written permission to be released under the MIT \"Expat\" License. The authors of this package are  aquatiko  and  giordano ."},{"id":1307,"pagetitle":"API Reference","title":"API Reference","ref":"/Reproject/stable/api-reference/#API-Reference","content":" API Reference"},{"id":1308,"pagetitle":"API Reference","title":"Reproject.interpolator","ref":"/Reproject/stable/api-reference/#Reproject.interpolator-Tuple{AbstractArray, Int64}","content":" Reproject.interpolator  —  Method interpolator(array_in, order::Int) Returns an interpolator with the given array and order of interpolation. source"},{"id":1309,"pagetitle":"API Reference","title":"Reproject.pad_edges","ref":"/Reproject/stable/api-reference/#Reproject.pad_edges-Union{Tuple{Matrix{T}}, Tuple{T}} where T","content":" Reproject.pad_edges  —  Method pad_edges(array_in::Matrix{T}) where {T} Pads a given array and creates a border with edge elements. source"},{"id":1310,"pagetitle":"API Reference","title":"Reproject.parse_input_data","ref":"/Reproject/stable/api-reference/#Reproject.parse_input_data-Tuple{FITSIO.ImageHDU}","content":" Reproject.parse_input_data  —  Method parse_input_data(input_data::ImageHDU)\nparse_input_data(input_data::Tuple{AbstractArray, WCSTransform})\nparse_input_data(input_data::String, hdu_in)\nparse_input_data(input_data::FITS, hdu_in) Parse input data and returns an Array and WCS object. Arguments input_data : image to reproject which can be name of a FITS file,               an ImageHDU or a FITS file. hdu_in : used to set HDU to use when more than one HDU is present. source"},{"id":1311,"pagetitle":"API Reference","title":"Reproject.parse_output_projection","ref":"/Reproject/stable/api-reference/#Reproject.parse_output_projection-Tuple{WCS.WCSTransform, Any}","content":" Reproject.parse_output_projection  —  Method parse_output_projection(output_projection::WCSTransform, shape_out)\nparse_output_projection(output_projection::ImageHDU; shape_out)\nparse_output_projection(output_projection::String, hdu_number)\nparse_output_projection(output_projection::FITS, hdu_number) Parse output projection and returns a WCS object and shape of output. Arguments output_projection : WCS information about the image to be reprojected which can be                      name of a FITS file, an ImageHDU or WCSTransform. shape_out : shape of the output image. hdu_number : specifies HDU number when file name is given as input. source"},{"id":1312,"pagetitle":"API Reference","title":"Reproject.reproject","ref":"/Reproject/stable/api-reference/#Reproject.reproject-Tuple{Any, Any}","content":" Reproject.reproject  —  Method reproject(input_data, output_projection; shape_out = nothing, order = 1, hdu_in = 1, hdu_out = 1) Reprojects image data to a new projection using interpolation. Arguments input_data : Image data which is being reprojected.               It can be an ImageHDU, FITS object, name of a FITS file or a tuple of image matrix and WCSTransform. output_projection : Frame in which data is reprojected.                      Frame can be taken from WCSTransform object, ImageHDU, FITS or name of FITS file. shape_out : Shape of image after reprojection. order : Order of interpolation.          0: Nearest-neighbor          1: Linear          2: Quadratic hdu_in : Used to specify HDU number when giving input as FITS or name of FITS file. hdu_out:  Used to specify HDU number when giving output projection as FITS or name of FITS file. source"},{"id":1313,"pagetitle":"API Reference","title":"Reproject.wcs_to_celestial_frame","ref":"/Reproject/stable/api-reference/#Reproject.wcs_to_celestial_frame-Tuple{WCS.WCSTransform}","content":" Reproject.wcs_to_celestial_frame  —  Method wcs_to_celestial_frame(wcs::WCSTransform) Returns the reference frame of a WCSTransform. The reference frame supported in Julia are FK5, ICRS and Galactic. source"},{"id":1316,"pagetitle":"Home","title":"SkyCoords.jl","ref":"/SkyCoords/stable/#SkyCoords.jl","content":" SkyCoords.jl SkyCoords.jl provides a type system for astronomical coordinate systems with appropriate conversions between them."},{"id":1317,"pagetitle":"Home","title":"Installation","ref":"/SkyCoords/stable/#Installation","content":" Installation From the Julia REPL (v1.6) pkg> add SkyCoords\n\njulia> using SkyCoords"},{"id":1318,"pagetitle":"Home","title":"Usage","ref":"/SkyCoords/stable/#Usage","content":" Usage There are currently five supported coordinate systems. The following immutable types are used to represent coordinates in each system: ICRSCoords : ICRS coordinates system GalCoords : Galactic coordinates system SuperGalCoords : Supergalactic coordinates system FK5Coords : FK5 coordinates system (with arbitrary equinox) EclipticCoords : Ecliptic coordinates system Each type holds a longitude and latitude, and each is a subtype of  AbstractSkyCoords . julia> c1 = ICRSCoords(0.0, 0.0)  # inputs are ra, dec in radians\nICRSCoords{Float64}(0.0, 0.0)\n\njulia> c1.ra # access ra, dec individually\n0.0\n\njulia> c2 = convert(GalCoords, c1) # convert to a different system\nGalCoords{Float64}(1.6814027872278692, -1.0504884034813007)\n\njulia> c2.l # Note that galactic coordinate fields are l, b\n1.6814027872278692\n\njulia> c1 |> FK5Coords{2000} # Can use piping syntax for conversion\nFK5Coords{2000, Float64}(1.1102233723050067e-7, 4.411803426976326e-8)"},{"id":1319,"pagetitle":"Home","title":"Units","ref":"/SkyCoords/stable/#Units","content":" Units There is built-in support for units via  Unitful.jl julia> using Unitful\n\njulia> c = ICRSCoords(0.11255u\"°\", 0.00091u\"rad\")\nICRSCoords{Float64}(0.0019643680731196178, 0.00091)\n\njulia> c2 = FK5Coords{2000}(0.1u\"rad\", 0.5)\nFK5Coords{2000, Float64}(0.1, 0.5)\n\njulia> SkyCoords.lat(u\"μrad\", c)\n910.0 μrad"},{"id":1320,"pagetitle":"Home","title":"Parsing from strings","ref":"/SkyCoords/stable/#Parsing-from-strings","content":" Parsing from strings The  AstroAngles.jl  package provides convenient string parsing utilities julia> using AstroAngles\n\njulia> c3 = ICRSCoords(hms\"05:34:31.94\", dms\"+22:00:52.2\")\nICRSCoords{Float64}(1.4596726677614607, 0.3842255081802917) for example, to load coordinates from a target list julia> using CSV, DataFrames\n\njulia> table = CSV.File(\"target_list.csv\") |> DataFrame;\n\njulia> [table.ra table.dec]\n203×2 Matrix{String}:\n \"00 05 01.42\"  \"40 03 35.82\"\n \"00 05 07.52\"  \"73 13 11.34\"\n \"00 36 01.40\"  \"-11 12 13.00\"\n[...]\n\njulia> coords = @. ICRSCoords(hms2rad(table.ra), dms2rad(table.dec))\n203-element Vector{ICRSCoords{Float64}}:\n ICRSCoords{Float64}(0.021919880964005448, 0.6991780256843024)\n ICRSCoords{Float64}(0.022363485482220672, 1.277926878539953)\n ICRSCoords{Float64}(0.15718144355252264, -0.19553990200190915)\n[...]"},{"id":1321,"pagetitle":"Home","title":"Angular Separation between Coordinates","ref":"/SkyCoords/stable/#Angular-Separation-between-Coordinates","content":" Angular Separation between Coordinates The  separation  function allows you to compute the angular (great-circle) distance between two coordinates, in radians, using the  Vincenty formula .  The coordinates can be also given in different systems.  For example, according to SIMBAD the  FK5Coords{2000}  coordinates of  Mizar  are julia> mizar = FK5Coords{2000}(3.507787, 0.958628)\nFK5Coords{2000, Float64}(3.507787, 0.958628) while the  GalCoords  coordinates of Alcor are julia> alcor = GalCoords(1.968189, 1.072829)\nGalCoords{Float64}(1.968189, 1.072829) Their angular separation is given by julia> separation(mizar, alcor) # Radians\n0.003435309169452965\n\njulia> rad2deg(separation(mizar, alcor)) * 60 # Arcminutes\n11.809723003934822 with an angle julia> position_angle(mizar, alcor) # radians\n1.2446024012417884\n\njulia> position_angle(mizar, alcor) |> rad2deg # degrees\n71.31046476300233\n"},{"id":1322,"pagetitle":"Home","title":"Catalog Matching","ref":"/SkyCoords/stable/#Catalog-Matching","content":" Catalog Matching SkyCoords.jl offers coordinate catalog matching functionality through an extension that depends on  NearestNeighbors.jl . This functionality requires Julia ≥ v1.9 and  NearestNeighbors.jl  to be loaded (e.g.,  using NearestNeighbors.jl ). The  SkyCoords.match  function can match two catalogs of coordinates with an interface similar to Astropy's  match_coordinates_sky . This function operates on two arrays of coordinates, the first being the \"reference\" catalog that will be searched to find the closest coordinates to those in the second catalog. This function returns the indices into the reference catalog of the matches and the angular separation (in radians) between each coordinate and its match in the reference catalog. using NearestNeighbors # Required to use `match` method\nusing SkyCoords\n# Generate random coordinates\nN = 1000\nlons = 2pi .* rand(N) # (0, 2π)\nlats = pi .* (rand(N) .- 0.5) # (-π, π)\n# The catalog to match against\nrefcat = ICRSCoords.(lons, lats)\n# The catalog of coordinates for which you want to find neighbors in \"refcat\"\nmatchcat = refcat[[1,5,10]]\n\nids, sep = SkyCoords.match(refcat, matchcat)\nids == [1,5,10] # Indices for which `refcat[ids]` match to `matchcat`\n# output\ntrue Note that  SkyCoords.match  is not exported (to avoid clashing with  Base.match ) and should be used via the qualified signature  SkyCoords.match  (as above) or explicitly imported (e.g.,  using SkyCoords: match ). This extension additionally supports construction of  NearestNeighbors.KDTree s from  AbstractArray{<:AbstractSkyCoords}  and extends methods for general nearest neighbors queries ( nn ,  knn ) and queries for all neighbors within a given separation ( inrange , similar to Astropy's  search_around_sky ). More complicated catalog joins are supported by the  FlexiJoins.jl  package. For example, if  L  and  R  are two catalogs with coordinate keys  :coordsL  and  :coordsR  respectively, the two catalogs can be joined based on angular separation with  FlexiJoins.innerjoin((L, R), FlexiJoins.by_distance(:coordsL, :coordsR, SkyCoords.separation, <=(0.1)))  where the final condition indicates you only want to keep matches that have separations less than or equal to 0.1 rad. See their documentation on astronomy-specific applications  here ."},{"id":1323,"pagetitle":"Home","title":"Accuracy","ref":"/SkyCoords/stable/#Accuracy","content":" Accuracy All the supported conversions have been compared to the results of  astropy.coordinates  (to better than 0.0001 arcsec agreement for  Float64 ). In turn,  astropy.coordinates  has been tested against many other tools."},{"id":1324,"pagetitle":"Home","title":"Performance","ref":"/SkyCoords/stable/#Performance","content":" Performance For small and moderate numbers of coordinates, conversions are much faster than  astropy.coordinates  in Python. The following plot shows the performance for converting ICRS coordinates to various other systems (Galactic, FK5J2000 and FK5J1975), using  astropy.coordinates  ( py_*  labels) and SkyCoords.jl ( jl_*  labels). The x axis denotes the number of coordinates being simultaneously converted, with 1 corresponding to scalar coordinates. Specs CPU Intel core i5-8259U @ 2.3GHz (4 cores) RAM 16GB Julia Version 1.2 Python Version 3.7 Astropy Version 3.1.2 For scalar coordinates, SkyCoords.jl is up to 100,000 times faster. For very large vectors of one million coordinates or more, SkyCoords.jl is 2-4 times faster.  The source code for these benchmarks can be found in  bench/ ."},{"id":1325,"pagetitle":"Home","title":"Contributing","ref":"/SkyCoords/stable/#Contributing","content":" Contributing If you would like to contribute to SkyCoords please head over to the  GitHub page  and file an issue or open a pull request!"},{"id":1328,"pagetitle":"API/Reference","title":"API/Reference","ref":"/SkyCoords/stable/api/#API/Reference","content":" API/Reference"},{"id":1329,"pagetitle":"API/Reference","title":"Index","ref":"/SkyCoords/stable/api/#Index","content":" Index NearestNeighbors.KDTree SkyCoords.AbstractSkyCoords SkyCoords.EclipticCoords SkyCoords.FK5Coords SkyCoords.GalCoords SkyCoords.ICRSCoords SkyCoords.SuperGalCoords NearestNeighbors.inrange NearestNeighbors.knn NearestNeighbors.nn SkyCoords.match SkyCoords.offset SkyCoords.position_angle SkyCoords.separation"},{"id":1330,"pagetitle":"API/Reference","title":"Types","ref":"/SkyCoords/stable/api/#Types","content":" Types SkyCoords.AbstractSkyCoords  —  Type The supertype for all sky coordinate systems. source SkyCoords.ICRSCoords  —  Type ICRSCoords(ra, dec) International Celestial Reference System This is the current standard adopted by the International Astronomical Union notably due to its high level of accuracy compared to standard equatorial coordinate systems. What sets this apart from  FK5Coords  is that it is completely defined using extragalactic radio sources rather than a geocentric frame, which means the reference frame will not change due to Earth's motion. Coordinates ra  - Right ascension in radians (0, 2π) dec  - Declination in radians (-π/2, π/2) source SkyCoords.GalCoords  —  Type GalCoords(l, b) Galactic Coordinate System This coordinate system is defined based on the projection of the Milky Way galaxy onto our celestial sphere, with (0, 0) being approximately the center of our galaxy. Coordinates l  - Galactic longitude in radians (-π, π) b  - Galactic latitude in radians (-π/2, π/2) source SkyCoords.SuperGalCoords  —  Type SuperGalCoords(l, b) Supergalactic Coordinate System The supergalactic plane is part of a reference frame for the supercluster of galaxies that contains the Milky Way galaxy. The supergalactic plane as so-far observed is more or less perpendicular to the plane of the Milky Way, the angle is 84.5 degrees. Viewed from the Earth, the plane traces a great circle across the sky through the constellations  Coordinates l  - SuperGalCoords longitude in radians (-π, π) b  - SuperGalCoords latitude in radians (-π/2, π/2) source SkyCoords.FK5Coords  —  Type FK5Coords{equinox}(ra, dec) Equatorial Coordinate System This coordinate system maps the celestial sphere based on a geocentric observer. Historically the oldest, this coordinate system has been shown to be inaccurate due to its definitions based on the Earth, which has long-scale precession causing the reference frame to change. Because of this, an equinox must be provided (typically 2000, commonly known as J2000) which defines the reference frame. Coordinates ra  - Right ascension in radians (0, 2π) dec  - Declination in radians (-π/2, π/2) source SkyCoords.EclipticCoords  —  Type EclipticCoords{equinox}(lon, lat) Ecliptic Coordinate System This coordinate system is geocentric with the ecliptic plane as the xy-plane with x oriented according to the equinox specified by  equinox . Coordinates lon  - Longitude in radians (0, 2π) lat  - Latitude in radians (-π/2, π/2) source"},{"id":1331,"pagetitle":"API/Reference","title":"Conversion","ref":"/SkyCoords/stable/api/#Conversion","content":" Conversion To convert between types, there are three (equivalent) methods of doing so. julia> c1 = ICRSCoords(0., 0.)\nICRSCoords{Float64}(0.0, 0.0) using  convert julia> convert(GalCoords, c1)\nGalCoords{Float64}(1.6814027872278692, -1.0504884034813007) using constructors julia> GalCoords(c1)\nGalCoords{Float64}(1.6814027872278692, -1.0504884034813007) using  |> julia> c1 |> GalCoords\nGalCoords{Float64}(1.6814027872278692, -1.0504884034813007)"},{"id":1332,"pagetitle":"API/Reference","title":"Catalog Matching","ref":"/SkyCoords/stable/api/#Catalog-Matching","content":" Catalog Matching SkyCoords.match  —  Method match(refcoords::AbstractArray{<:AbstractSkyCoords}, \n      matchcoords::AbstractArray{<:AbstractSkyCoords};\n      nthneighbor::Int = 1) Requires Julia ≥ 1.9 and NearestNeighbors.jl to be loaded (e.g.,  using NearestNeighbors ). Finds the nearest entries in  refcoords  to the coordinates contained in  matchcoords . The keyword argument  nthneighbor  determines  which  nearest neighbor to search for; typically this should be  1  when matching one set of coordinates to another. Another common use case is setting  nthneighbor = 2  when matching a catalog against itself to find the nearest neighbor of each coordinate in the same catalog.  Returns  (id, sep) , where id  is an array containing indices of the coordinates in  refcoords  that matched with the elements of  matchcoords , and  sep  is an array giving the angular separation between the elements of  matchcoords  and the above matches. Note that this method creates a  KDTree  from  refcoords  and then calls the method below. If you plan to use the same  refcoords  to match to many different  matchcoords , then you should directly construct  KDTree(refcoords)  and call the method below. match(tree::KDTree, matchcoords::AbstractArray{<:AbstractSkyCoords};\n      nthneighbor::Int = 1) As above, but uses a pre-constructed  tree::KDTree  rather than creating one from a reference catalog of coordinates. source NearestNeighbors.KDTree  —  Method KDTree(data::AbstractArray{<:AbstractSkyCoords}; kws...) Requires Julia ≥ 1.9 and NearestNeighbors.jl to be loaded (e.g.,  using NearestNeighbors ). Construct a  KDTree  from NearestNeighbors.jl. The provided  data  are used to construct the tree, and the  kws...  are passed to  NearestNeighbors.KDTree . An internal Cartesian coordinate representation is used, with a standard coordinate representation of  CartesianCoords{ICRSCoords} . Coordinate conversions are applied automatically in the following methods, which extend those from  NearestNeighbors.jl . nn(tree::KDTree, coord::AbstractSkyCoords)  queries the  tree  for the entry nearest the provided  coord . nn(tree::KDTree, coords::AbstractArray{<:AbstractSkyCoords})  queries the  tree  for the entry nearest each coordinate in  coords . knn(tree::KDTree, coord::AbstractSkyCoords, k::Int)  queries the  tree  for the  k  coordinates nearest the provided  coord . knn(tree::KDTree, coords::AbstractArray{<:AbstractSkyCoords}, k::Int)  queries the  tree  for the  k  coordinates nearest each coordinate in  coords . source NearestNeighbors.nn  —  Method nn(tree::KDTree, coord::AbstractSkyCoords) Requires Julia ≥ 1.9 and NearestNeighbors.jl to be loaded (e.g.,  using NearestNeighbors ). Queries the  tree  for the nearest entry to the provided  coord . Returns the index into the tree of the nearest entry and the angular separation between the two coordinates, in radians. nn(tree::KDTree, coords::AbstractArray{<:AbstractSkyCoords}) Returns arrays  (id, sep)  containing the indices and angular separations (in radians) of the closest entries in  tree  for each coordinate in  coords . source NearestNeighbors.knn  —  Method knn(tree::KDTree, coord::AbstractSkyCoords, \n    k::Int, sortres::Bool = false) Requires Julia ≥ 1.9 and NearestNeighbors.jl to be loaded (e.g.,  using NearestNeighbors ). Queries the  tree  for the  k  nearest entries to the provided  coord . Returns vectors  (id, sep) , which, respectively, contain the indices into the tree of the  k  nearest entries, and the angular separations between  coord  and the  k  nearest entries, in radians. If  sortres  is  true , the returned neighbors are sorted by separation. knn(tree::KDTree, coords::AbstractArray{<:AbstractSkyCoords}, k::Int, sortres::Bool = false) Returns arrays  (id, sep)  containing vectors of indices and angular separations (in radians) of the  k  closest entries in  tree  for each coordinate in  coords . If  sortres  is  true , the returned neighbors are sorted by separation. source NearestNeighbors.inrange  —  Method inrange(tree::KDTree, coord::AbstractSkyCoords, seplim::Number) Requires Julia ≥ 1.9 and NearestNeighbors.jl to be loaded (e.g.,  using NearestNeighbors ). Searches for coordinates in the  tree  with angular separations from  coord  less than  seplim , which must be given in radians. If  tree = KDTree(data) , returns indices into  data . inrange(tree::KDTree, coords::AbstractArray{<:AbstractSkyCoords}, seplim::Number) For each coordinate in  coords , finds coordinates in  tree  that lie within  seplim  radians. source"},{"id":1333,"pagetitle":"API/Reference","title":"Functions","ref":"/SkyCoords/stable/api/#Functions","content":" Functions SkyCoords.separation  —  Function separation(c1::AbstractSkyCoords, c2::AbstractSkyCoords) -> distance Return angular separation between two sky coordinates, in radians. The angular separation is calculated using the  Vincenty formula , which is slightly more complex and computationally expensive than some alternatives, but is stable at at all distances, including the poles and antipodes. source SkyCoords.position_angle  —  Function position_angle(c1::AbstractSkyCoords, c2::AbstractSkyCoords) -> angle Return position angle between two sky coordinates, in positive radians. Examples julia> c1 = ICRSCoords(0, 0); c2 = ICRSCoords(deg2rad(1), 0);\n\njulia> position_angle(c1, c2) |> rad2deg\n90.0 source SkyCoords.offset  —  Function offset(::AbstractSkyCoords, separation, pa) -> coordinate Offset a coordinate by a given angular separation,  separation , in radians and position angle,  pa , in radians. Uses the sine and cosine rules in spherical coordinates with corrections for the antipodes. Returns a sky coordinate of the same type as input. Examples julia> c1 = ICRSCoords(0, 0);\n\njulia> c2 = offset(c1, deg2rad(1), deg2rad(90))\nICRSCoords{Float64}(0.017453292519943295, 1.0686516840418957e-18)\n\njulia> offset(c1, c2) .|> rad2deg\n(1.0, 90.0) See Also separation ,  position_angle source offset(::AbstractSkyCoords, AbstractSkyCoords) -> angle, angle Return the separation and position angle in radians between two sky coordinates. Examples julia> c1 = ICRSCoords(0, 0); c2 = ICRSCoords(deg2rad(1), 0);\n\njulia> offset(c1, c2) .|> rad2deg\n(1.0, 90.0) See Also separation ,  position_angle source"},{"id":1336,"pagetitle":"Home","title":"WCS.jl","ref":"/WCS/stable/#WCS.jl","content":" WCS.jl Astronomical  World Coordinate System  library for Julia. This package wraps the WCSLIB C library. This is a tool made for users who are already familiar with WCS transformations. If you are not, please reference the following manuscripts Representation of world coordinates in FITS Representations of celestial coordinates in FITS Representations of spectral coordinates in FITS Representations of distortions in FITS world coordinate systems"},{"id":1337,"pagetitle":"Home","title":"Installation","ref":"/WCS/stable/#Installation","content":" Installation From the REPL, press  ]  to enter Pkg mode pkg> add WCS"},{"id":1338,"pagetitle":"Home","title":"Usage","ref":"/WCS/stable/#Usage","content":" Usage Import the library: There are many ways to utilize WCS transformations. Let's make one for a 2-dimensional array (like an image) from scratch: julia> wcs = WCSTransform(2;\n           cdelt = [-0.066667, 0.066667],\n           ctype = [\"RA---AIR\", \"DEC--AIR\"],\n           crpix = [-234.75, 8.3393],\n           crval = [0., -90],\n           pv    = [(2, 1, 45.0)],\n       )\nWCSTransform(naxis=2, cdelt=[-0.066667, 0.066667], crval=[0.0, -90.0], crpix=[-234.75, 8.3393]) We can also create one from a FITS  header  loaded into our environment if it contains the appropriate keywords: julia> wcs_array = WCS.from_header(header)\n\njulia> wcs_array[1]; Now we can do conversions between pixel and world coordinates. Note WCS transforms use pixel  (0, 0)  as the top-left corner (not 1-indexed!!) julia> pixcoords = [0.0  24.0  45.0;  # x coordinates\n                    0.0  38.0  98.0]  # y coordinates\n2×3 Matrix{Float64}:\n 0.0  24.0  45.0\n 0.0  38.0  98.0\n\njulia> worldcoords = pix_to_world(wcs, pixcoords)\n2×3 Matrix{Float64}:\n 267.965   276.539   287.771\n -73.7366  -71.9741  -69.6781\n\njulia> pixcoords = world_to_pix(wcs, worldcoords)\n2×3 Matrix{Float64}:\n  1.16529e-12  24.0  45.0\n -7.10543e-14  38.0  98.0"},{"id":1339,"pagetitle":"Home","title":"API/Reference","ref":"/WCS/stable/#API/Reference","content":" API/Reference WCS.WCSTransform  —  Type WCSTransform(naxis; kwds...) Construct a WCS transformation with the given number of axes  naxis . Keyword arguments can be passed to set various attributes of the transform. Specifying keyword arguments is equivalent to setting them after construction: julia> wcs = WCSTransform(2; crpix=[1000., 1000.])\nWCSTransform(naxis=2, cdelt=[1.0, 1.0], crval=[0.0, 0.0], crpix=[1000.0, 1000.0]) is equivalent to: julia> wcs = WCSTransform(2)\nWCSTransform(naxis=2, cdelt=[1.0, 1.0], crval=[0.0, 0.0], crpix=[0.0, 0.0])\n\njulia> wcs.crpix = [1000., 1000.];\n\njulia> wcs\nWCSTransform(naxis=2, cdelt=[1.0, 1.0], crval=[0.0, 0.0], crpix=[1000.0, 1000.0]) Properties Below is the entire list of public properties for a  WCSTransform Keyword Type Description naxis Int32 Number of dimensions crval Vector{Float64}  (length  naxis ) coordinate value at reference point crpix Vector{Float64}  (length  naxis ) array location of the reference point in pixels cdelt Vector{Float64}  (length  naxis ) coordinate increment at reference point crder Vector{Float64}  (length  naxis ) random error in coordinate csyer Vector{Float64}  (length  naxis ) systematic error in coordinate ctype Vector{String}  (length  naxis ) axis type (8 characters) crota Vector{Float64}  (length  naxis ) rotation from stated coordinate type cunit Vector{String}  (length  naxis ) units of axes cunit Vector{String}  (length  naxis ) names of axes pc Matrix{Float64}  (size  naxis  ×  naxis ) linear transformation matrix cd Matrix{Float64}  (size  naxis  ×  naxis ) linear transformation matrix (with scale) equinox Float64 the equinox associated with dynamical equatorial or ecliptic coordinate systems latpole Float64 the native latitude of the celestial pole lonpole Float64 the native longitude of the celestial pole mjdavg Float64 Modified Julian Date corresponding to  DATE-AVG mjdobs Float64 Modified Julian Date corresponding to  DATE-OBS restfrq Float64 rest frequency (Hz) restwav Float64 rest wavelength (m) velangl Float64 velocity angle velosys Float64 relative radial velocity zsource Float64 the redshift of the source colnum Int32 column of FITS binary table associated with this WCS dateavg String representative mid-point of the date of observation dateobs String start of the date of observation radesys String the equatorial or ecliptic coordinate system type specsys String spectral reference frame (standard of rest) ssysobs String spectral reference frame ssyssrc String spectral reference frame for redshift wcsname String name of this coordinate representation obsgeo Vector{Float64}  (length 3 or 6) location of the observer in a standard terrestrial reference frame alt String character code for alternate coordinate descriptions source WCS.from_header  —  Method from_header(header[; relax=WCS.HDR_ALL, ctrl=0, ignore_rejected=false, table=false]) Parse the FITS image header in the String  header , returning a  Vector{WCSTransform}  giving all the transforms defined in the header. The  relax  determines the treatment of non-standard keywords. The default is to accept all known non-standard keywords. Use  relax=WCS.HDR_NONE  to ignore all non-standard keywords. Use, e.g.,  relax=(WCS.HDR_RADECSYS & WCS.HDR_CROTAia)  to only accept selected non-standard keywords. source WCS.obsfix  —  Method obsfix(ctrl::Integer, wcs::WCSTransform) Complete the  obsgeo  field  wcs  of observatory coordinates.  That is, if only the  (x,y,z)  Cartesian coordinate triplet or the  (l,b,h)  geodetic coordinate triplet are set, then it derives the other triplet from it. If both triplets are set, then it checks for consistency at the level of 1 metre. Parameters ctrl : flag that controls behaviour if one triplet is defined and the other is only partially defined: 0: Reset only the undefined elements of an incomplete coordinate triplet. 1: Reset all elements of an incomplete triplet. 2: Don't make any changes, check for consistency only. Returns an error if either of the two triplets is incomplete. wcs : Coordinate transformation parameters. Its  obsgeo  field may be changed. Returns -1: No change required (not an error). 0: Success. 1: Null wcsprm pointer passed. 5: Invalid parameter value. source WCS.pix_to_world!  —  Method pix_to_world!(wcs, pixcoords, worldcoords[; stat, imcoords, phi, theta]) Convert the array of pixel coordinates  pixcoords  to world coordinates according to the WCSTransform  wcs , storing the result in the  worldcoords  and  stat  arrays.  pixcoords  should be a 2-d array where  pixcoords[:, i]  is the i-th set of coordinates, or a 1-d array representing a single set of coordinates.  worldcoords  must be the same size and type as  pixcoords . If given, the arrays  stat ,  imcoords ,  phi ,  theta  will be used to store intermediate results. Their sizes and types must all match  pixcoords , except for  stat  which should be the same size but of type  Cint  (typically  Int32 ). source WCS.pix_to_world  —  Method pix_to_world(wcs, pixcoords) Convert the array of pixel coordinates  pixcoords  to world coordinates according to the WCSTransform  wcs .  pixcoords  should be a 2-d array where  pixcoords[:, i]  is the  i -th set of coordinates, or a 1-d array representing a single set of coordinates. The return value is the same shape as  pixcoords . source WCS.to_header  —  Method to_header(wcs[; relax=WCS.HDR_NONE]) Encode the WCSTransform  wcs  as a FITS header string. The  relax  keyword controls how non-standard extensions to the WCS standard are handled. source WCS.world_to_pix!  —  Method world_to_pix!(wcs, worldcoords, pixcoords[; stat, phi, theta, imcoords]) Convert the array of pixel coordinates  worldcoords  to pixel coordinates according to the WCSTransform  wcs , storing the result in the  pixcoords  array.  worldcoords  should be a 2-d array where  worldcoords[:, i]  is the  i -th set of coordinates, or a 1-d array representing a single set of coordinates.  pixcoords  must be the same size and type as  worldcoords . If given, the arrays  stat ,  imcoords ,  phi ,  theta  will be used to store intermediate results. Their sizes and types must all match  worldcoords , except for  stat  which should be the same size but of type  Cint  (typically  Int32 ). source WCS.world_to_pix  —  Method world_to_pix(wcs, worldcoords) Convert the array of world coordinates  worldcoords  to pixel coordinates according to the WCSTransform  wcs .  worldcoords  is a 2-d array where  worldcoords[:, i]  is the i-th set of coordinates, or a 1-d array representing a single set of coordinates. The return value is the same size as  worldcoords . source"},{"id":1340,"pagetitle":"Home","title":"Index","ref":"/WCS/stable/#Index","content":" Index WCS.WCSTransform WCS.from_header WCS.obsfix WCS.pix_to_world WCS.pix_to_world! WCS.to_header WCS.world_to_pix WCS.world_to_pix!"},{"id":1343,"pagetitle":"Home","title":"Spectra.jl","ref":"/Spectra/stable/#Spectra.jl","content":" Spectra.jl Utilities for interfacing with astronomical spectra and synthetic spectra libraries. Spectra.jl Installation Quick Start Citation Contributing Spectrum Types Constructors Basic operations Unitful helpers Plotting Index Transformations Extinction"},{"id":1344,"pagetitle":"Home","title":"Installation","ref":"/Spectra/stable/#Installation","content":" Installation From the REPL, press  ]  to enter Pkg mode pkg> add https://github.com/JuliaAstro/Spectra.jl\n\njulia> using Spectra"},{"id":1345,"pagetitle":"Home","title":"Quick Start","ref":"/Spectra/stable/#Quick-Start","content":" Quick Start Here is a quick demo of some of our features julia> using Spectra, FITSIO, Unitful, UnitfulAstro, Plots\n\njulia> fitsurl = \"https://dr14.sdss.org/optical/spectrum/view/data/format=fits/spec=lite?plateid=1323&mjd=52797&fiberid=12\";\n\njulia> # download(fitsurl, \"sdss.fits\");\n\njulia> f = FITS(\"sdss.fits\")\nFile: sdss.fits\nMode: \"r\" (read-only)\nHDUs: Num  Name     Type\n      1             Image\n      2    COADD    Table\n      3    SPECOBJ  Table\n      4    SPZLINE  Table\n\njulia> wave = (10 .^ read(f[2], \"loglam\"))u\"angstrom\";\n\njulia> flux = (read(f[2], \"flux\") .* 1e-17)u\"erg/s/cm^2/angstrom\";\n\njulia> spec = spectrum(wave, flux)\nSpectrum(Quantity{Float32, 𝐋, Unitful.FreeUnits{(Å,), 𝐋, nothing}}, Quantity{Float64, 𝐌 𝐋^-1 𝐓^-3, Unitful.FreeUnits{(Å^-1, erg, cm^-2, s^-1), 𝐌 𝐋^-1 𝐓^-3, nothing}})\n\njulia> plot(spec); julia> cont_fit = continuum(spec)\nSpectrum(Quantity{Float32, 𝐋, Unitful.FreeUnits{(Å,), 𝐋, nothing}}, Quantity{Float64, 𝐌 𝐋^-1 𝐓^-3, Unitful.FreeUnits{(Å^-1, erg, cm^-2, s^-1), 𝐌 𝐋^-1 𝐓^-3, nothing}})\n  coeffs: Quantity{Float64, 𝐌 𝐋^-1 𝐓^-3, Unitful.FreeUnits{(Å^-1, erg, cm^-2, s^-1), 𝐌 𝐋^-1 𝐓^-3, nothing}}[1.983152216046405e-15 erg Å^-1 cm^-2 s^-1, -1.8822245369267038e-16 erg Å^-1 cm^-2 s^-1, -1.0422750370065006e-16 erg Å^-1 cm^-2 s^-1, 4.8112282273206135e-17 erg Å^-1 cm^-2 s^-1]\n  normalized: true\n\njulia> plot(cont_fit, xlims=(6545, 6600));"},{"id":1346,"pagetitle":"Home","title":"Citation","ref":"/Spectra/stable/#Citation","content":" Citation If you found this software or any derivative work useful in your academic work, I ask that you please cite the code. TODO"},{"id":1347,"pagetitle":"Home","title":"Contributing","ref":"/Spectra/stable/#Contributing","content":" Contributing Please see  Contributing  for information on contributing and extending Spectra.jl."},{"id":1350,"pagetitle":"Analysis","title":"Analysis","ref":"/Spectra/stable/analysis/#Analysis","content":" Analysis"},{"id":1351,"pagetitle":"Analysis","title":"Spectra.equivalent_width","ref":"/Spectra/stable/analysis/#Spectra.equivalent_width","content":" Spectra.equivalent_width  —  Function equivalent_width(::AbstractSpectrum) Calculate the equivalent width of the given continuum-normalized spectrum. Return value has units equal to wavelengths. source"},{"id":1352,"pagetitle":"Analysis","title":"Spectra.line_flux","ref":"/Spectra/stable/analysis/#Spectra.line_flux","content":" Spectra.line_flux  —  Function line_flux(::AbstractSpectrum) Calculate the line flux of the given continuum-normalized spectrum. Return value has units equal to flux. source"},{"id":1356,"pagetitle":"Contributing","title":"Contributing","ref":"/Spectra/stable/contrib/#contrib","content":" Contributing"},{"id":1357,"pagetitle":"Contributing","title":"Extending AbstractSpectrum","ref":"/Spectra/stable/contrib/#Extending-AbstractSpectrum","content":" Extending  AbstractSpectrum Most of the code written within this library should work as long as your subtype contains the following fields wave::AbstractArray flux::AbstractArray meta::Dict{Symbol, Any} Variations of  wave  and  flux  ought to work given the appropriate methods being written."},{"id":1358,"pagetitle":"Contributing","title":"Contributing Guidelines","ref":"/Spectra/stable/contrib/#Contributing-Guidelines","content":" Contributing Guidelines In general, for contributing, use the following guidelines Write clean, pragmatic julia code New features must come with adequete unit testing and documentation Each new feature should bump the package one minor version Make sure to cite relevant papers and code where appropriate If you are interested in contributing, head over to  GitHub  and take a look at some of the issues for ideas!"},{"id":1361,"pagetitle":"Fitting","title":"Fitting","ref":"/Spectra/stable/fitting/#Fitting","content":" Fitting"},{"id":1362,"pagetitle":"Fitting","title":"Spectra.continuum","ref":"/Spectra/stable/fitting/#Spectra.continuum","content":" Spectra.continuum  —  Function continuum(::AbstractSpectrum, deg::Int=3) Return a continuum-normalized spectrum by fitting the continuum with a Chebyshev polynomial of degree  deg . source"},{"id":1363,"pagetitle":"Fitting","title":"Spectra.continuum!","ref":"/Spectra/stable/fitting/#Spectra.continuum!","content":" Spectra.continuum!  —  Function continuum!(::AbstractSpectrum, deg::Int=3) In-place version of  continuum source"},{"id":1366,"pagetitle":"Spectrum","title":"Spectrum","ref":"/Spectra/stable/spectrum/#Spectrum","content":" Spectrum Here we will go over the different spectral types and how we use them."},{"id":1367,"pagetitle":"Spectrum","title":"Types","ref":"/Spectra/stable/spectrum/#Types","content":" Types Spectra are defined as possible subtypes of  AbstractSpectrum . You can use these directly for construction, or use the catch-all  spectrum  function, which is preferred."},{"id":1368,"pagetitle":"Spectrum","title":"Spectra.Spectrum","ref":"/Spectra/stable/spectrum/#Spectra.Spectrum","content":" Spectra.Spectrum  —  Type Spectrum <: AbstractSpectrum A 1-dimensional spectrum stored as vectors of real numbers. The wavelengths are assumed to be in angstrom. source"},{"id":1369,"pagetitle":"Spectrum","title":"Constructors","ref":"/Spectra/stable/spectrum/#Constructors","content":" Constructors"},{"id":1370,"pagetitle":"Spectrum","title":"Spectra.spectrum","ref":"/Spectra/stable/spectrum/#Spectra.spectrum","content":" Spectra.spectrum  —  Function spectrum(wave, flux; kwds...) Construct a spectrum given the spectral wavelengths and fluxes. This will automatically dispatch the correct spectrum type given the shape and element type of the given flux. Any keyword arguments will be accessible from the spectrum as properties. Examples julia> wave = range(1e4, 4e4, length=1000);\n\njulia> flux = 100 .* ones(size(wave));\n\njulia> spec = spectrum(wave, flux)\nSpectrum(Float64, Float64)\n\njulia> spec = spectrum(wave, flux, name=\"Just Noise\")\nSpectrum(Float64, Float64)\n  name: Just Noise\n\njulia> spec.name\n\"Just Noise\" There is easy integration with  Unitful.jl  and its sub-projects and  Measurements.jl julia> using Unitful, UnitfulAstro, Measurements\n\njulia> wave = range(1, 4, length=1000)u\"μm\";\n\njulia> sigma = randn(size(wave));\n\njulia> flux = (100 .± sigma)u\"erg/cm^2/s/angstrom\";\n\njulia> spec = spectrum(wave, flux)\nSpectrum(Quantity{Float64, 𝐋, Unitful.FreeUnits{(μm,), 𝐋, nothing}}, Quantity{Measurement{Float64}, 𝐌 𝐋^-1 𝐓^-3, Unitful.FreeUnits{(Å^-1, erg, cm^-2, s^-1), 𝐌 𝐋^-1 𝐓^-3, nothing}}) For a multi-order spectrum, all orders must have the same length, so be sure to pad any ragged orders with NaN. julia> wave = reshape(range(100, 1e4, length=1000), 100, 10)';\n\njulia> flux = ones(10, 100) .* collect(1:10);\n\njulia> spec = spectrum(wave, flux)\nEchelleSpectrum(Float64, Float64)\n  # orders: 10 source"},{"id":1371,"pagetitle":"Spectrum","title":"Basic operations","ref":"/Spectra/stable/spectrum/#Basic-operations","content":" Basic operations For more advanced transformations, see  Transformations Function Base.length(::AbstractSpectrum) Base.size(::AbstractSpectrum) Base.maximum(::AbstractSpectrum) Base.minimum(::AbstractSpectrum) Base.argmax(::AbstractSpectrum) Base.argmin(::AbstractSpectrum) Base.findmax(::AbstractSpectrum) Base.findmin(::AbstractSpectrum)"},{"id":1372,"pagetitle":"Spectrum","title":"Arithmetic","ref":"/Spectra/stable/spectrum/#Arithmetic","content":" Arithmetic Function +(::AbstractSpectrum, A) -(::AbstractSpectrum, A) *(::AbstractSpectrum, A) /(::AbstractSpectrum, A)"},{"id":1373,"pagetitle":"Spectrum","title":"Unitful helpers","ref":"/Spectra/stable/spectrum/#Unitful-helpers","content":" Unitful helpers"},{"id":1374,"pagetitle":"Spectrum","title":"Unitful.unit","ref":"/Spectra/stable/spectrum/#Unitful.unit","content":" Unitful.unit  —  Function Unitful.unit(::AbstractSpectrum) Get the units of a spectrum. Returns a tuple of the wavelength units and flux/sigma units Examples julia> using Unitful, UnitfulAstro\n\njulia> wave = range(1e4, 3e4, length=1000);\n\njulia> flux = wave .* 10 .+ randn(1000);\n\njulia> spec = spectrum(wave * u\"angstrom\", flux * u\"W/m^2/angstrom\");\n\njulia> w_unit, f_unit = unit(spec)\n(Å, W Å^-1 m^-2) source"},{"id":1375,"pagetitle":"Spectrum","title":"Unitful.ustrip","ref":"/Spectra/stable/spectrum/#Unitful.ustrip","content":" Unitful.ustrip  —  Function Unitful.ustrip(::AbstractSpectrum) Remove the units from a spectrum. Useful for processing spectra in tools that don't play nicely with  Unitful.jl Examples julia> using Unitful, UnitfulAstro\n\njulia> wave = range(1e4, 3e4, length=1000);\n\njulia> flux = wave .* 10 .+ randn(1000);\n\njulia> spec = spectrum(wave*u\"angstrom\", flux*u\"W/m^2/angstrom\")\nSpectrum(Quantity{Float64, 𝐋, Unitful.FreeUnits{(Å,), 𝐋, nothing}}, Quantity{Float64, 𝐌 𝐋^-1 𝐓^-3, Unitful.FreeUnits{(Å^-1, m^-2, W), 𝐌 𝐋^-1 𝐓^-3, nothing}})\n\njulia> ustrip(spec)\nSpectrum(Float64, Float64) source"},{"id":1376,"pagetitle":"Spectrum","title":"Plotting","ref":"/Spectra/stable/spectrum/#Plotting","content":" Plotting We provide simple plotting recipes for spectra using  Plots.jl using Plots, Spectra\n\nwave = range(1e3, 5e4, length=100)\nspec = blackbody(wave, 2000)\n\nplot(spec) GKS: cannot open display - headless operation mode active"},{"id":1377,"pagetitle":"Spectrum","title":"Index","ref":"/Spectra/stable/spectrum/#Index","content":" Index Spectra.Spectrum Spectra.spectrum Unitful.unit Unitful.ustrip"},{"id":1380,"pagetitle":"Transformations","title":"Transformations","ref":"/Spectra/stable/transforms/#Transformations","content":" Transformations"},{"id":1381,"pagetitle":"Transformations","title":"Extinction","ref":"/Spectra/stable/transforms/#Extinction","content":" Extinction By levaraging  DustExtinction.jl  we can apply common reddening laws to our spectra. julia> using Unitful, Measurements, Random\n\njulia> rng = Random.seed!(0);\n\njulia> wave = (1:0.5:3)u\"μm\"\n(1.0:0.5:3.0) μm\n\njulia> sigma = randn(rng, size(wave))\n5-element Vector{Float64}:\n  0.942970533446119\n  0.13392275765318448\n  1.5250689085124804\n  0.12390123120559722\n -1.205772284259936\n\njulia> flux = (100 .± sigma)u\"W/m^2/μm\"\n5-element Vector{Quantity{Measurement{Float64}, 𝐌 𝐋^-1 𝐓^-3, Unitful.FreeUnits{(μm^-1, m^-2, W), 𝐌 𝐋^-1 𝐓^-3, nothing}}}:\n 100.0 ± 0.94 W μm^-1 m^-2\n 100.0 ± 0.13 W μm^-1 m^-2\n 100.0 ± 1.5 W μm^-1 m^-2\n 100.0 ± 0.12 W μm^-1 m^-2\n 100.0 ± -1.2 W μm^-1 m^-2\n\njulia> spec = spectrum(wave, flux)\nSpectrum(Quantity{Float64, 𝐋, Unitful.FreeUnits{(μm,), 𝐋, nothing}}, Quantity{Measurement{Float64}, 𝐌 𝐋^-1 𝐓^-3, Unitful.FreeUnits{(μm^-1, m^-2, W), 𝐌 𝐋^-1 𝐓^-3, nothing}})\n\njulia> red = redden(spec, 0.3)\nSpectrum(Quantity{Float64, 𝐋, Unitful.FreeUnits{(μm,), 𝐋, nothing}}, Quantity{Measurement{Float64}, 𝐌 𝐋^-1 𝐓^-3, Unitful.FreeUnits{(μm^-1, m^-2, W), 𝐌 𝐋^-1 𝐓^-3, nothing}})\n\njulia> red.flux\n5-element Vector{Quantity{Measurement{Float64}, 𝐌 𝐋^-1 𝐓^-3, Unitful.FreeUnits{(μm^-1, m^-2, W), 𝐌 𝐋^-1 𝐓^-3, nothing}}}:\n 89.44 ± 0.84 W μm^-1 m^-2\n 94.35 ± 0.13 W μm^-1 m^-2\n  96.4 ± 1.5 W μm^-1 m^-2\n 97.48 ± 0.12 W μm^-1 m^-2\n  98.1 ± 1.2 W μm^-1 m^-2\n\njulia> deredden!(red, 0.3)\nSpectrum(Quantity{Float64, 𝐋, Unitful.FreeUnits{(μm,), 𝐋, nothing}}, Quantity{Measurement{Float64}, 𝐌 𝐋^-1 𝐓^-3, Unitful.FreeUnits{(μm^-1, m^-2, W), 𝐌 𝐋^-1 𝐓^-3, nothing}})\n\njulia> red.flux ≈ spec.flux\ntrue"},{"id":1382,"pagetitle":"Transformations","title":"API/Reference","ref":"/Spectra/stable/transforms/#API/Reference","content":" API/Reference"},{"id":1383,"pagetitle":"Transformations","title":"DustExtinction.redden","ref":"/Spectra/stable/transforms/#DustExtinction.redden","content":" DustExtinction.redden  —  Function redden(::AbstractSpectrum, Av; Rv = 3.1, law = CCM89) Redden a spectrum using common color laws provided by  DustExtinction.jl .  Av  is the total extinction,  Rv  is the selective extinction (3.1 is a common value for the Milky Way) and  law  is the color law to use for determining the extinction. source"},{"id":1384,"pagetitle":"Transformations","title":"Spectra.redden!","ref":"/Spectra/stable/transforms/#Spectra.redden!","content":" Spectra.redden!  —  Function redden!(::AbstractSpectrum, Av; Rv = 3.1, law = CCM89) In-place version of  redden source"},{"id":1385,"pagetitle":"Transformations","title":"DustExtinction.deredden","ref":"/Spectra/stable/transforms/#DustExtinction.deredden","content":" DustExtinction.deredden  —  Function deredden(::AbstractSpectrum, Av; Rv = 3.1, law = CCM89) Deredden a spectrum using common color laws provided by  DustExtinction.jl .  Av  is the total extinction,  Rv  is the selective extinction (3.1 is a common value for the Milky Way) and  law  is the color law to use for determining the extinction. source"},{"id":1386,"pagetitle":"Transformations","title":"Spectra.deredden!","ref":"/Spectra/stable/transforms/#Spectra.deredden!","content":" Spectra.deredden!  —  Function deredden!(::AbstractSpectrum, Av; Rv = 3.1, law = CCM89) In-place version of  deredden source"},{"id":1389,"pagetitle":"Home","title":"SpectralFitting.jl Documentation","ref":"/SpectralFitting/stable/#SpectralFitting.jl-Documentation","content":" SpectralFitting.jl Documentation Fast and flexible spectral fitting in Julia. SpectralFitting.jl is a package for defining and fitting spectral models, with a number of utilities to make model composition easy and invocation fast. SpectralFitting can be extended with  LibXSPEC_jll.jl  via XSPECModels.jl to expose the library of models from  HEASoft XSPEC , and provides helper functions for operating with spectral data from a number of different missions. The package natively uses  LsqFit.jl  to fit parameters using the Levenberg-Marquardt algorithm, but makes it easy to use  Optim.jl  for more specialized fitting algorithms, or  Turing.jl  for Bayesian inference and MCMC. SpectralFitting is designed to be extended, such that new models are simple to create, and new dataset processing pipelines for different missions are brief to define. Where performance is key, SpectralFitting helps you define fast and AD-compatible surrogates of spectral models using  Surrogates.jl , and embed them in the model composition algebra. To get started, add the AstroRegistry from the University of Bristol and then install: julia>]\npkg> registry add https://github.com/astro-group-bristol/AstroRegistry\npkg> add SpectralFitting Then use using SpectralFitting\n# .... See  Walkthrough  for an example walkthrough the package. For more University of Bristol Astrophysics Group codes, see  our GitHub organisation ."},{"id":1392,"pagetitle":"Using datasets","title":"Datasets","ref":"/SpectralFitting/stable/datasets/datasets/#Datasets","content":" Datasets SpectralFitting.jl supports a wide variety of datasets, and makes it easy to wrap your own. For spectral fitting specifics, the main dataset type is SpectralFitting.SpectralData  —  Type SpectralData{T} <: AbstractDataset A general spectral data structure, minimally with a  Spectrum  and  ResponseMatrix . Optionally also includes the  AncillaryResponse  and a background  Spectrum . Methods The following methods are made available through the  SpectralData : regroup! restrict_domain! mask_energies! drop_channels! drop_bad_channels! drop_negative_channels! normalize! objective_units spectrum_energy bin_widths subtract_background! set_domain! error_statistic Constructors The available constructors are: SpectralData(paths::SpectralDataPaths; kwargs...) Using  SpectralDataPaths . If the spectrum and repsonse matrix have already been loaded seperately, use SpectralData(\n    spectrum::Spectrum,\n    response::ResponseMatrix;\n    # try to match the domains of the response matrix to the data\n    match_domains = true,\n    background = nothing,\n    ancillary = nothing,\n) source"},{"id":1393,"pagetitle":"Using datasets","title":"Dataset abstraction","ref":"/SpectralFitting/stable/datasets/datasets/#Dataset-abstraction","content":" Dataset abstraction Datasets must define a small API to make fitting possible. The picture to have in mind when considering the different domains is as follows: the model is trying to predict the objective. It does so by taking in input domain and maps it to some output domain. That means  make_output_domain  and  make_objective_domain  correspond to the  $(X,Y)$  values of the data that the model is trying to fit, whilst the model is evaluated on the  make_model_domain , which need not be the same as the output domain. In other cases, the  objective_transformer  acts to transform the output of the model onto the output domain.  Mathematically, expressing the output domain  $X$ , the model domain  $D$ , the model output  $M(D)$  and objective  $S$ , along with the transformer as  $T$ , then the relationship between the different domains is \\[\\hat{S} = T \\times M(D),\\] Both  $\\hat{S}$  and  $S$  are defined over  $X$ . The various fitting operations try to find model paramters that make  $\\hat{S}$  and  $S$  as close as possible. SpectralFitting.AbstractDataset  —  Type abstract type AbstractDataset Abstract type for use in fitting routines. High level representation of some underlying data structures. Fitting data is considered to have an  objective  and a  domain . As the domain may be, for example, energy bins (high and low), or fourier frequencies (single value), the purpose of this abstraction is to provide some facility for translating between these representations for the models to fit with. This is done by checking that the  AbstractDataLayout  of the model and data are compatible, or at least have compatible translations. Must implement a minimal set of accessor methods. These are paired with  objective  and  domain  parlance. Note that these functions are prefixed with  make_*  and not  get_*  to represent that there may be allocations or work going into the translation. Usage of these functions should be sparse in the interest of performance. The arrays returned by the  make_*  functions must correspond to the  AbstractDataLayout  specified by the caller. make_objective_variance make_objective make_domain_variance make_model_domain make_ouput_domain Additionally there is an objective transformer that transforms the output of the model onto the  output  domain: objective_transformer Finally, to make all of the fitting for different statistical regimes work efficiently, datasets should inform which units are preferred to fit. They may also give the error statistics they prefer, and a label name primarily used to disambiguate: preferred_units error_statistic make_label source SpectralFitting.make_objective_variance  —  Function make_objective_variance(layout::AbstractDataLayout, dataset::AbstractDataset) Make the variance vector associated with each objective point. source SpectralFitting.make_objective  —  Function make_objective(layout::AbstractDataLayout, dataset::AbstractDataset) Returns the array used as the target for model fitting. The array must correspond to the data  AbstractDataLayout  specified by the  layout  parameter. In as far as it can be guarunteed, the memory in the returned array will not be mutated by any fitting procedures. Domain for this objective should be returned by  make_model_domain . source SpectralFitting.make_domain_variance  —  Function make_domain_variance(layout::AbstractDataLayout, dataset::AbstractDataset) Make the variance vector associated with the domain. source SpectralFitting.make_model_domain  —  Function make_model_domain(layout::AbstractDataLayout, dataset::AbstractDataset) Returns the array used as the domain for the modelling. This is paired with  make_domain_variance source SpectralFitting.make_output_domain  —  Function make_output_domain(layout::AbstractDataLayout, dataset::AbstractDataset) Returns the array used as the output domain. That is, in cases where the model input and output map to different domains, the input domain is said to be the model domain, the input domain is said to be the model domain. The distinction is mainly used for the purposes of simulating data and for visualising data. source"},{"id":1394,"pagetitle":"Using datasets","title":"Underlying data layouts","ref":"/SpectralFitting/stable/datasets/datasets/#Underlying-data-layouts","content":" Underlying data layouts SpectralFitting.AbstractDataLayout  —  Type abstract type AbstractDataLayout end The data layout primarily concerns the relationship between the objective and the domain. It is used to work out whether a model and a dataset are fittable, and if not, whether a translation in the output of the model to the domain of the model is possible. The following methods may be used to interrogate support: preferred_support  for inferring the preferred support of a model when multiple supports are possible. common_support  to obtain the common support of two structures The following method is also used to define the support of a model or dataset: supports For cases where unit information needs to be propagated, an  AbstractDataLayout  can also be used to ensure the units are compatible. To query the units of a layout, use support_units source SpectralFitting.OneToOne  —  Type struct OneToOne <: AbstractDataLayout end Indicates there is a one-to-one (injective) correspondence between each input value and each output value. That is to say length(objective) == length(domain) source SpectralFitting.ContiguouslyBinned  —  Type struct ContiguouslyBinned <: AbstractDataLayout end Contiguously binned data layout means that the domain describes high and low bins, with the objective being the value in that bin. This means length(objective) + 1== length(domain) Note that the  contiguous  qualifer is to mean there is no gaps in the bins, and that \\[\\Delta E_i = E_{i+1} - E_{i}\\] source SpectralFitting.common_support  —  Function common_support(x, y) Find the common  AbstractDataLayout  of  x  and  y , following the ordering of  preferred_support . source SpectralFitting.preferred_support  —  Function preferred_support(x) Get the preferred  AbstractDataLayout  of  x . If multiple supports are available, the  DEFAULT_SUPPORT_ORDERING  is followed: DEFAULT_SUPPORT_ORDERING = (ContiguouslyBinned{Nothing}(nothing), OneToOne{Nothing}(nothing)) source SpectralFitting.supports  —  Function supports(x::Type) Used to define whether a given type has support for a specific  AbstractDataLayout . Should return a tuple of the supported layouts. This method should be implemented to express new support, not the query method. To query, there is supports(layout::AbstractDataLayout, x)::Bool Example supports(::Type{typeof(x)}) = (OneToOne(),)\n@assert supports(ContiguouslyBinned(), x) == false source"},{"id":1399,"pagetitle":"Diverse examples","title":"Spectral fitting examples","ref":"/SpectralFitting/stable/examples/examples/#Spectral-fitting-examples","content":" Spectral fitting examples Below are a number of examples illustrating how this package may be used."},{"id":1400,"pagetitle":"Diverse examples","title":"Using the model library","ref":"/SpectralFitting/stable/examples/examples/#Using-the-model-library","content":" Using the model library The model library details a model algebra (see  AbstractSpectralModelKind ) for composing models together. An example use of this may be to construct a complex model from a series of simpler models, and invoke the models on a given energy grid: using SpectralFitting\nusing Plots\n\nmodel = PhotoelectricAbsorption() * (PowerLaw() + BlackBody())\n\n# define energy grid\nenergy = collect(range(0.1, 12.0, 100))\n\nflux = invokemodel(energy, model)\n\nplot(energy[1:end-1], flux) Note this energy grid may be arbitrarily spaced, but, like XSPEC, assumes the bins are contiguous, i.e. that the high energy limit of one bin is the low energy limit of the next. The full model library of available models is listed in  Model index ."},{"id":1403,"pagetitle":"Optimizer galore","title":"Optimizer galore","ref":"/SpectralFitting/stable/examples/optimizers/#Optimizer-galore","content":" Optimizer galore Let's fit a spectrum: using SpectralFitting, Plots\n\nDATADIR = \"...\"\nDATADIR = length(get(ENV, \"CI\", \"\")) > 0 ? @__DIR__() * \"/../../ex-datadir\" : \"/home/lilith/Developer/jl/datasets/xspec/walkthrough\" # hide\nspec1_path = joinpath(DATADIR, \"s54405.pha\")\ndata = OGIPDataset(spec1_path) \nnormalize!(data)\n\nmask_energies!(data, 1, 15)\n\n# a plotting utility\nmy_plot(data) = plot(\n    data, \n    xscale = :log10, \n    yscale = :log10,\n    ylims = (1e-3, 1.3)\n)\n\nmy_plot(data)"},{"id":1406,"pagetitle":"A quick guide","title":"A quick guide to modelling and fitting in SpectralFitting.jl","ref":"/SpectralFitting/stable/examples/sherpa-example/#A-quick-guide-to-modelling-and-fitting-in-SpectralFitting.jl","content":" A quick guide to modelling and fitting in SpectralFitting.jl This is SpectralFitting.jl version of  A quick guide to modeling and fitting in Sherpa . using SpectralFitting, Plots\nusing Random\nRandom.seed!(0)\n\nx = collect(range(-5, 5, 200))\n\nA_true = 3.0\npos_true = 1.3\nsigma_true = 0.8\nerr_true = 0.2\n\ny = @. A_true * exp(-(x - pos_true)^2 / (2 * sigma_true^2))\n\ny_noisy = y .+ (0.2 * randn(length(y)))\n\nscatter(x, y_noisy) To make this into a fittable dataset, we observe that our layout is injective (i.e.  length(x) == length(y) ). This is subtly different from how the majority of spectral models are implemented, which usually assume some kind of binning ( length(x) == length(y) + 1 ). Fortunately, SpectralFitting.jl can track this for us, and do various conversion to make the models work correctly for the data. We need only tell the package what our  AbstractDataLayout  is: data = InjectiveData(x, y_noisy; name = \"example\") ┌  InjectiveData  with  200  data points:\n│   Name                  : example\n│   . Domain (min/max)    : (-5.0000, 5.0)\n│   . Codomain (min/max)  : (-0.42323, 3.3787)\n└  The data prints the  data card , which provides us some high level information about our data at a glance. We can plot the data trivially using one of the Plots.jl recipes plot(data, markersize = 3) Next we want to specify a model to fit to this data. Models that are prefixed with  XS_  are models that are linked from the XSPEC model library, provided via  LibXSPEC_jll . For a full list of the models, see  Models index . Warning It is advised to  use the Julia implemented models . This allows various calculations to benefit from automatic differentiation, efficient multi-threading, GPU offloading, and various other useful things, see  Why & how . model = GaussianLine(μ = FitParam(0.0)) ┌ GaussianLine\n│ K -> 1 ± 0.1 ∈ [ 0, Inf ]  FREE \n│ μ -> 0 ±   0 ∈ [ 0, Inf ]  FREE \n│ σ -> 1 ± 0.1 ∈ [ 0, Inf ]  FREE \n└  We can plot our model over the same domain range quite easily too: plot(data.domain[1:end-1], invokemodel(data.domain, model)) Note that we've had to adjust the domain here. As stated before, most models are implemented for binned data, and therefore return one fewer bin than given. SpectralFitting.jl adopts the SciML problem-solver abstraction, so to fit a model to data we specify a  FittingProblem : prob = FittingProblem(model => data) ┌ FittingProblem:\n│   . Models     : 1\n│   . Datasets   : 1\n│   Parameter Summary:\n│   . Total      : 3\n│   .  Frozen      : 0\n│   .  Bound       : 0\n│   .  Free        : 3\n└  We fit problem then by calling  fit : result = fit(prob, LevenbergMarquadt()) ┌ FitResult:\n│  Model:  GaussianLine \n│   . Name : m.K        m.μ        m.σ        \n│   . u    : 121.70     1.3210     0.81300    \n│   . Δu   : 9.2751     0.071547   0.071547   \n│   . χ²   : 7.7600\n└ Σχ² = 7.7600 The result card tells us a little bit about how successful the fit was. We further inspect the fit by overplotting result on the data: plot(data, markersize = 3)\nplot!(result) We can create a contour plot of the fit statistic by evaluating the result everywhere on the grid and measuring the statistic: amps = range(50, 200, 50)\ndevs = range(0.5, 1.2, 50)\n\nstats = [\n    measure(ChiSquared(), result, [a, result.u[2], d])\n    for d in devs, a in amps\n]\n\n# 1, 2, and 3 sigma contours\nlevels = [2.3, 4.61, 9.21]\ncontour(\n    amps,\n    devs,\n    stats .- sum(result.stats),\n    levels = levels,\n    xlabel = \"K\",\n    ylabel = \"σ\"\n)\nscatter!([result.u[1]], [result.u[3]])"},{"id":1409,"pagetitle":"Fitting spectral models","title":"Fitting spectral models","ref":"/SpectralFitting/stable/fitting/#Fitting-spectral-models","content":" Fitting spectral models"},{"id":1412,"pagetitle":"Composite models","title":"Composite models","ref":"/SpectralFitting/stable/models/composite-models/#Composite-models","content":" Composite models The model algebra defined by the  AbstractSpectralModelKind  yields instances of  CompositeModel , nested to various degrees. These composite models are designed to make as much information about the spectral model available at compile-time, such that rich and optimized generated functions may be assembled purely from the Julia types (see  Why & how ). SpectralFitting.CompositeModel  —  Type CompositeModel{T,K,Op,M1,M2} <: AbstractSpectralModel{T,K}\nCompositeModel(left_model, right_model, op::AbstractCompositeOperator) Type resulting from operations combining any number of  AbstractSpectralModel  via the model algebra defined from  AbstractSpectralModelKind . model = PhotoelectricAbsorption() * (PowerLaw() + BlackBody())\ntypeof(model) <: CompositeModel # true Each operation binary operation in the model algebra is encoded in the parametric types of the  CompositeModel , where the operation is given by an  AbstractCompositeOperator .  Composite models adopt the model kind of the  right  model, i.e.  M2 , and obey the model algebra accordingly. Composite models very rarely need to be constructed directly, and are instead obtained by regular model operations. The  propertynames  and  getproperty  methods for  CompositeModel  are overwritten to access all models in the model tree. For example: julia> propertynames(PowerLaw() + DeltaLine())\n(:a1, :a2) CompositeModel  has  destructure  for working abstractly with model trees. source SpectralFitting.AbstractCompositeOperator  —  Type abstract type AbstractCompositeOperator Superype of all composition operators. Used to implement the model algebra of  AbstractSpectralModelKind  through a trait system. The Julia symbol corresponding to a given  AbstractCompositeOperator  may be obtained through  operation_symbol . source SpectralFitting.AdditionOperator  —  Type AdditionOperator <: AbstractCompositeOperator\nAdditionOperator() Corresponds to the  :(+)  symbol. source SpectralFitting.MultiplicationOperator  —  Type MultiplicationOperator <: AbstractCompositeOperator\nMultiplicationOperator() Corresponds to the  :(*)  symbol. source SpectralFitting.ConvolutionOperator  —  Type ConvolutionOperator <: AbstractCompositeOperator\nConvolutionOperator() Has no corresponding symbol, since it invokes a function call  C(A) . source SpectralFitting.operation_symbol  —  Function operation_symbol(::AbstractCompositeOperator)\noperation_symbol(::Type{<:AbstractCompositeOperator}) Obtain the model symbol from a given  AbstractCompositeOperator . source"},{"id":1415,"pagetitle":"Model index","title":"Model index","ref":"/SpectralFitting/stable/models/models/#Model-index","content":" Model index Models wrapped from XSPEC implementations are prefixed with  XS_* , whereas pure-Julia models are simply named, e.g.  XS_PowerLaw  in XSPEC vs  PowerLaw  in Julia. The available models are SpectralFitting.BlackBody SpectralFitting.BremsStrahlung SpectralFitting.DeltaLine SpectralFitting.GaussianLine SpectralFitting.Log10Flux SpectralFitting.PhotoelectricAbsorption SpectralFitting.PowerLaw"},{"id":1416,"pagetitle":"Model index","title":"Julia models","ref":"/SpectralFitting/stable/models/models/#Julia-models","content":" Julia models"},{"id":1417,"pagetitle":"Model index","title":"Additive","ref":"/SpectralFitting/stable/models/models/#Additive","content":" Additive SpectralFitting.BlackBody  —  Type BlackBody K : Normalisation. kT : Temperature (keV). Example energy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, BlackBody())                         BlackBody\n       ┌────────────────────────────────────────┐\n   0.2 │                                        │\n       │                                        │\n       │                                        │\n       │                                        │\n       │                                        │\n       │                                        │\n       │      .:''':..                          │\n       │     :'      '':.                       │\n       │   .'           ':.                     │\n       │  .:               '..                  │\n       │  :                  ':.                │\n       │ .'                     ':..            │\n       │ :                         ''...        │\n       │:                              '''....  │\n     0 │:                                    '''│\n       └────────────────────────────────────────┘\n        0                                     20\n                         E (keV) source SpectralFitting.BremsStrahlung  —  Type BremsStrahlung K : Normalisation. kT : Temperature (keV). ab : Helium to hydrogen ratio Example energy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, BremsStrahlung())                    BremsStrahlung\n     ┌────────────────────────────────────────┐\n   3 │.                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │ :                                      │\n   0 │ ':.....................................│\n     └────────────────────────────────────────┘\n      0                                     20\n                       E (keV) source SpectralFitting.DeltaLine  —  Type DeltaLine _width K : Normalisation. E : Energy at which the delta function spikes. Example energy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, DeltaLine())                         DeltaLine\n       ┌────────────────────────────────────────┐\n   0.4 │         .                              │\n       │         :                              │\n       │         :                              │\n       │         :                              │\n       │         :                              │\n       │         :                              │\n       │         ::                             │\n       │         ::                             │\n       │         ::                             │\n       │         ::                             │\n       │         ::                             │\n       │         ::                             │\n       │         ::                             │\n       │         ::                             │\n     0 │.........::.............................│\n       └────────────────────────────────────────┘\n        0                                     20\n                         E (keV) Note The  DeltaLine  model is not a true delta function, as this would be extremely difficult to define in a numerical model that needs to be able to propagate gradients. Instead, it is a very narrow  GaussianLine  model. source SpectralFitting.GaussianLine  —  Type GaussianLine K : Normalisation. μ : Mean σ : Standard deviation Example energy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, GuassianLine())                        GaussianLine\n        ┌────────────────────────────────────────┐\n   0.09 │                                        │\n        │            ..                          │\n        │           .':                          │\n        │           : :                          │\n        │           : '.                         │\n        │          .'  :                         │\n        │          :   :                         │\n        │          :   :                         │\n        │          :   '.                        │\n        │         :     :                        │\n        │         :     :                        │\n        │         :     :                        │\n        │        .'      :                       │\n        │        :       '.                      │\n      0 │.......:         :......................│\n        └────────────────────────────────────────┘\n         0                                     20\n                          E (keV) source SpectralFitting.PowerLaw  —  Type PowerLaw K : Normalisation. a : Photon index. Example energy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, PowerLaw())                         PowerLaw\n       ┌────────────────────────────────────────┐\n   0.5 │                                        │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │ :                                      │\n       │ :                                      │\n       │  :                                     │\n       │   :.                                   │\n       │    ':..                                │\n       │        ''':......                      │\n       │                  ''''''''''''''........│\n     0 │                                        │\n       └────────────────────────────────────────┘\n        0                                     20\n                         E (keV) source"},{"id":1418,"pagetitle":"Model index","title":"Multiplicative","ref":"/SpectralFitting/stable/models/models/#Multiplicative","content":" Multiplicative SpectralFitting.PhotoelectricAbsorption  —  Type PhotoelectricAbsorption table ηH : Equivalent hydrogen column (units of 10²² atoms per cm⁻²). source"},{"id":1419,"pagetitle":"Model index","title":"Convolutional","ref":"/SpectralFitting/stable/models/models/#Convolutional","content":" Convolutional SpectralFitting.Log10Flux  —  Type Log10Flux Used to measure the (log) flux of the models it is applied to. Note that the additive components must have their normalisations frozen for this model to work properly. E_min E_max log10Flux Example model = PowerLaw()\nmodel.K.frozen = true\n\nflux_model = Log10Flux()(model) source"},{"id":1420,"pagetitle":"Model index","title":"Utility","ref":"/SpectralFitting/stable/models/models/#Utility","content":" Utility SpectralFitting.register_model_data  —  Function SpectralFitting.register_model_data(M::Type{<:AbstractSpectralModel}, model_data::ModelDataInfo...)\nSpectralFitting.register_model_data(M::Type{<:AbstractSpectralModel}, remote_and_local::Tuple{String,String}...)\nSpectralFitting.register_model_data(M::Type{<:AbstractSpectralModel}, filenames::String...)\nSpectralFitting.register_model_data(s::Symbol, filenames::String...) Register  filenames  as model data associated with the model given by type  M  or symbol  s .  This function does not download any files, but rather adds the relevant filenames to a lookup which  SpectralFitting.download_model_data  consults when invoked, and consequently model data is only downloaded when needed. Note It is good practice to use this method immediately after defining a new model with  @xspecmodel  to register any required datafiles from the HEASoft source code, and therefore keep relevant information together. Example # by type\nregister_model_data(XS_Laor, \"ari.mod\")\n# by symbol\nregister_model_data(:XS_KyrLine, \"KBHline01.fits\") source SpectralFitting.finite_diff_kernel!  —  Function finite_diff_kernel!(f::Function, flux, energy) Calculates the finite difference of the function  f  over the energy bin between the high and low bin edges, via \\[c_i = f(E_{i,\\text{high}}) - f(E_{i,\\text{low}}),\\] similar to evaluating the limits of the integral between  $E_{i,\\text{high}}$  and  $E_{i,\\text{low}}$ . This utility function is primarily used for  Additive  models to ensure the flux per bin is normalised for the energy over the bin. source SpectralFitting.wrap_model_as_objective  —  Function wrap_model_as_objective(model::AbstractSpectralModel; ΔE = 1e-1)\nwrap_model_as_objective(M::Type{<:AbstractSpectralModel}; ΔE = 1e-1) Wrap a spectral model into an objective function for building/optimizing a surrogate model. Returns an anonymous function taking the tuple  (E, params...)  as the argument, and returning a single flux value. source"},{"id":1421,"pagetitle":"Model index","title":"Generating model fingerprints","ref":"/SpectralFitting/stable/models/models/#Generating-model-fingerprints","content":" Generating model fingerprints To generate the unicode plot to add as a fingerprint, we use a simple function: using SpectralFitting, UnicodePlots\n\nfunction plotmodel(energy, model)\n    flux = invokemodel(energy, model)\n    lineplot(\n        energy[1:end-1],\n        flux,\n        title=String(Base.typename(typeof(model)).name),\n        xlabel=\"E (keV)\",\n        canvas=DotCanvas\n    )\nend\n\n# e.g. for XS_PowerLaw()\nenergy = collect(range(0.1, 20.0, 100))\nplotmodel(energy, PowerLaw())                        PowerLaw                   \n      ┌────────────────────────────────────────┐  \n    7   │ .                                         │  \n      │ :                                         │  \n      │ :                                         │  \n      │ :                                         │  \n      │ :                                         │  \n      │ :                                         │  \n      │ :                                         │  \n      │ :                                         │  \n      │ :                                         │  \n      │ :                                         │  \n      │ :                                         │  \n      │ :                                         │  \n      │ :                                         │  \n      │ :.                                        │  \n    0   │   :...................................... │  \n      └────────────────────────────────────────┘  \n       0                                       20   \n                       E (keV)                  "},{"id":1424,"pagetitle":"Surrogate models","title":"Surrogate models","ref":"/SpectralFitting/stable/models/surrogate-models/#Surrogate-models","content":" Surrogate models Surrogate models allow you to create fast or memory efficient approximations of model components, or assist in optimizing some objective function directly. SpectralFitting uses the  Surrogates.jl  library of models, that yields pure-Julia surrogate models. Consequently, surrogate models also permit use of automatic differentiation in fitting, and are therefore powerful tools for improving fitting performance."},{"id":1425,"pagetitle":"Surrogate models","title":"Surrogates overview","ref":"/SpectralFitting/stable/models/surrogate-models/#Surrogates-overview","content":" Surrogates overview Warning The surrogate model optimization does not work well for most XSPEC models currently. This is being actively developed. Any function may be wrapped as a surrogate model using the  SurrogateSpectralModel  type. SpectralFitting.SurrogateSpectralModel  —  Type SurrogateSpectralModel <: AbstractSpectralModel\nSurrogateSpectralModel(modelkind, surrogate, params, params_symbols) Used to wrap a surrogate function into an  AbstractSpectralModel . Example Creating a surrogate function using  make_surrogate_harness : # build and optimize a surrogate model\nsurrogate = make_surrogate_harness(model, lower_bounds, upper_bounds)\n\n# create surrogate spectral model\nsm = SurrogateSpectralModel(\n    Multiplicative(),\n    surrogate,\n    (FitParam(1.0),),\n    (:ηH,)\n) The  lower_bounds  and  upper_bounds  must be tuples in the form  (E, params...) , where  E  denotes the bounds on the energy range to train over. source To facilitate easy surrogate builds, SpectralFitting exports a number of utility functions. SpectralFitting.make_surrogate_harness  —  Function make_surrogate_harness(\n    model::M,\n    lowerbounds::T,\n    upperbounds::T;\n    optimization_samples = 200,\n    seed_samples = 50,\n    S::Type = RadialBasis,\n    sample_type = SobolSample(),\n    verbose = false,\n) Creates and optimizes a surrogate model of type  S  for  model , using  wrap_model_as_objective  and   optimize_accuracy!  for  optimization_samples  iterations. Model is initially seeded with  seed_samples  points prior to optimization. Warning Additive models integrate energies to calculate flux, which surrogate models are currently not capable of. Results for Additive models likely to be inaccurate. This will be patched in a future version. source SpectralFitting.optimize_accuracy!  —  Function optimize_accuracy!(\n    surr::AbstractSurrogate,\n    obj::Function,\n    lb,\n    ub;\n    sample_type::SamplingAlgorithm = SobolSample(),\n    maxiters = 200,\n    N_truth = 5000,\n    verbose = false,\n) Improve accuracy (faithfullness) of the surrogate model in recreating the objective function. Samples a new space of  N_truth  points between  lb  and  ub , and calculates the objective function  obj  at each. Finds the point with largest MSE between surrogate and objective, and adds the point to the surrogate pool. Repeats  maxiters  times, adding  maxiters  points to surrogate model. Optionally print to stdout the MSE and iteration count with  verbose = true . Note that upper- and lower-bounds should be in the form  (E, params...) , where  E  is a single energy and  params  are the model parameters. source"},{"id":1426,"pagetitle":"Surrogate models","title":"Creating a surrogate for XS_PhotoelectricAbsorption","ref":"/SpectralFitting/stable/models/surrogate-models/#Creating-a-surrogate-for-XS_PhotoelectricAbsorption","content":" Creating a surrogate for  XS_PhotoelectricAbsorption Before we start, let us discuss a number of benefits the use of surrogate models may bring us: SurrogateSpectralModel  permit use of automatic differentiation. Surrogate models may be allocation-free depending on setup, whereas XSPEC wrappers will always have to allocate for type-conversions. Surrogate models may be considerably faster, especially for table models. Surrogate models are shareable (see  Sharing surrogate models ), and are tunable in size. XS_PhotoelectricAbsorption  is an XSPEC model that is wrapped by a thin C-wrapper into Julia. The implementation of this model is a number of Fortran routines from the late 90s, including a tabulation of ~3000 lines of data that has been copied directly into the Fortran source code. The performance of this model represents its complexity. using SpectralFitting, XSPECModels\n\nenergy = collect(range(0.1, 20.0, 200))\nmodel = XS_PhotoelectricAbsorption()\n\nflux = similar(energy)[1:end-1] 199-element Vector{Float64}:\n 0.0\n 7.1e-322\n 2.5e-322\n 6.94818216194357e-310\n 6.94817869137984e-310\n 0.0\n 6.94818216194357e-310\n 6.94817869137984e-310\n 0.0\n 6.94818216194357e-310\n ⋮\n 6.94817869137984e-310\n 0.0\n 6.94818216194357e-310\n 6.94817869137984e-310\n 0.0\n 6.94818216194357e-310\n 6.94817869137984e-310\n 0.0\n 6.94818216194357e-310 Benchmarking with  BenchmarkTools.jl : using BenchmarkTools\n@benchmark invokemodel!($flux, $energy, $model) BenchmarkTools.Trial: 4933 samples with 1 evaluation per sample.\n Range  ( min  …  max ):   1.003 ms  …   1.391 ms    ┊  GC  ( min … max ):  0.00% … 0.00%\n Time   ( median ):      1.008 ms               ┊  GC  ( median ):     0.00%\n Time   ( mean  ±  σ ):    1.010 ms  ±  12.640 μs    ┊  GC  ( mean ± σ ):   0.00% ± 0.00%\n\n       ▃▆█ ▆ ▃ ▁                                                  \n  ▂▂▃▅▇███ █ █ █ ▇▅▄▃▃▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▁▂▂▁▁▂▂▂▂▂▂▂▂ ▃\n  1 ms            Histogram: frequency by time         1.04 ms  < \n\n Memory estimate :  224 bytes , allocs estimate :  7 . The surrogate we'll construct will have to be tailored a little to the data we wish to fit, as we need to specify the parameter ranges our surrogate should learn. For example, we might be interested in energies between  $0.1$  and  $20$  keV (expressed in our domain), with equivalent hydrogen column  $\\eta$ H anywhere between  $10^{-3}$  and  $30$ . We specify the parameter bounds using tuples: lower_bounds = (1e-3,)\nupper_bounds = (30.0,) Note The first index is always the energy bounds, and the subsequent indices are the parameters in the same order they are defined in the model structure. Next, we use  make_surrogate_harness  to build and optimize a surrogate function for our model. By default, the surrogate uses linear radial basis functions, and seeds the coefficients with a number of seed points. This function then improves the accuracy of the model using  optimize_accuracy! , until a maximal number of iterations has been reached. For illustration purposes, we'll omit the accuracy improving step, and perform this ourselves. We can do this by setting  optimization_samples = 0  in the keyword arguments: using Surrogates\n\nharness = make_surrogate_harness(\n    (x, y) -> RadialBasis(x, y, lower_bounds, upper_bounds),\n    energy,\n    model,\n    lower_bounds,\n    upper_bounds;\n    # default is 50, but to illustrate the training behaviour we'll set this low\n    seed_samples = 2,\n)\n\n# number of points the surrogate has been trained on\nlength(harness.surrogate.x) 2 We can examine how well our surrogate reconstructs the model for a given test parameter: using Plots\n# random test value\nηh_test = 22.9\n\nmodel.ηH.value = ηh_test\nf = invokemodel(energy, model)\n\nf̂ = harness.surrogate([ηh_test]) Now we'll use  optimize_accuracy!  to improve the faithfulness of our surrogate. This requires making use of  wrap_model_as_objective  as a little wrapper around our model: optimize_accuracy!(harness; maxiters=50)\n\nlength(harness.surrogate.x) 52 We can plot the surrogate model again and see the improvement. new_f̂ = harness.surrogate([ηh_test]) Tight. We can also inspect the memory footprint of our model: # in bytes\nBase.summarysize(harness) 173760 This may be reduced by lowering  maxiters  in  optimize_accuracy!  at the cost of decreasing faithfulness. However, compare this to the Fortran tabulated source file in the XSPEC source code, which is approximately 224 Kb. The surrogate model with all it's training data is of the same order."},{"id":1427,"pagetitle":"Surrogate models","title":"Using a surrogate spectral model","ref":"/SpectralFitting/stable/models/surrogate-models/#Using-a-surrogate-spectral-model","content":" Using a surrogate spectral model Now that we have the surrogate model, we use  SurrogateSpectralModel  to wrap it into an  AbstractSpectralModel . The constructor also needs to know the model kind, have a copy of the model parameters, and know which symbols to represent the parameters with. sm = make_model(harness) ┌ SurrogateSpectralModel\n│ ηH -> 22.9 ± 0.1 ∈ [ 0, Inf ]  FREE \n└  We can now use the familiar API and attempt to benchmark the performance: @benchmark invokemodel!($flux, $energy, $sm) BenchmarkTools.Trial: 10000 samples with 5 evaluations per sample.\n Range  ( min  …  max ):   6.447 μs  …  84.065 μs    ┊  GC  ( min … max ):  0.00% … 0.00%\n Time   ( median ):      6.544 μs               ┊  GC  ( median ):     0.00%\n Time   ( mean  ±  σ ):    6.728 μs  ±   2.463 μs    ┊  GC  ( mean ± σ ):   0.00% ± 0.00%\n\n  ▄▄█▆ ▃ ▁                                                        \n  ████ █ █▇▅▄▃▃ ▂ ▂▂▂▂▂▂▂▄▆▄▃▃▃▂▂▂▂▂▂▁▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ ▃\n  6.45 μs         Histogram: frequency by time         7.88 μs  < \n\n Memory estimate :  1.72 KiB , allocs estimate :  5 . Comparing this to the initial benchmark of  XS_PhotoelectricAbsorption , we see about a significant speedup, with no allocations,  and  this surrogate model is now automatic differentiation ready."},{"id":1428,"pagetitle":"Surrogate models","title":"Evaluating the model","ref":"/SpectralFitting/stable/models/surrogate-models/#Evaluating-the-model","content":" Evaluating the model p_range = collect(range(1.0, 30.0))\n\nfluxes_vecs = map(p_range) do p\n    model.ηH.value = p\n    f = invokemodel(energy, model)\nend\nfluxes_mat = reduce(hcat, fluxes_vecs)\n\nsurface(p_range, energy[1:end-1], fluxes_mat, xlabel = \"ηH\", ylabel = \"E\", zlabel = \"f\", title = \"Model\") s_fluxes_vecs = map(p_range) do p\n    sm.params[1].value = p\n    display(sm)\n    f = invokemodel(energy, sm)\nend\ns_fluxes_mat = reduce(hcat, s_fluxes_vecs)\n\nsurface(p_range, energy[1:end-1], s_fluxes_mat, xlabel = \"ηH\", ylabel = \"E\", zlabel = \"f\", title = \"Surrogate\")"},{"id":1429,"pagetitle":"Surrogate models","title":"Sharing surrogate models","ref":"/SpectralFitting/stable/models/surrogate-models/#Sharing-surrogate-models","content":" Sharing surrogate models To export and import surrogate models,  JLD2.jl  is recommended."},{"id":1432,"pagetitle":"Using models","title":"Using spectral models","ref":"/SpectralFitting/stable/models/using-models/#Using-spectral-models","content":" Using spectral models In this page you'll find how to use the spectral model library and how to define your own models. Using the model library is as easy as invoking or composing models from the  Model Index . For example: model = PowerLaw() ┌ PowerLaw\n│ K -> 1 ± 0.1 ∈ [ 0, Inf ]  FREE \n│ a -> 2 ± 0.2 ∈ [ 0, Inf ]  FREE \n└  In the output of the REPL we see the model name, and it's two parameters, with information about those parameters, such as the current value, the associated error (10% by defaul), the minimum and maximum values, and whether the parameter is frozen or not. Note See  FitParam  for full details about fitable parameters. The parameters can be tweaked by accessing the fields model.K.value = 2.0\nmodel.K.frozen = true\nmodel ┌ PowerLaw\n│ K -> 2                     FROZEN \n│ a -> 2 ± 0.2 ∈ [ 0, Inf ]  FREE \n└  We can invoke the model on a domain in the following way domain = collect(range(0.1, 10.0, 100))\ninvokemodel(domain, model) 99-element view(::Matrix{Float64}, :, 1) with eltype Float64:\n 10.0\n  3.333333333333333\n  1.666666666666667\n  1.0\n  0.6666666666666665\n  0.4761904761904763\n  0.3571428571428572\n  0.2777777777777777\n  0.22222222222222232\n  0.18181818181818188\n  ⋮\n  0.002388915432393668\n  0.002337540906965918\n  0.002287805994051678\n  0.00223964165733484\n  0.00219298245614033\n  0.0021477663230240474\n  0.002103934357248094\n  0.0020614306328591847\n  0.0020202020202020055 Note By default, models are implemented to accept a single input vector with all of the low and high bin edges, and return a flux array with the flux in each energy bin. As such, it is here the case that: length(flux) == length(energy) - 1 Models need not be defined as such, however. See  AbstractDataLayout  for more. Models can be composed together following the  Model algebra . That means to expressive a photoelectric absorption component acting on the power law we can write model2 = PhotoelectricAbsorption() * model ┌ CompositeModel with 2 model components:\n│     m1 * a1 \n│ Model key and parameters:\n│      m1  => PhotoelectricAbsorption\n│        ηH -> 1 ± 0.1 ∈ [ 0, Inf ]  FREE \n│      a1  => PowerLaw\n│        K -> 2                     FROZEN \n│        a -> 2 ± 0.2 ∈ [ 0, Inf ]  FREE \n└  The parameters of this  CompositeModel  are are copied from the expression. This means we can modify the  K_1  parameter in  model2  without having to worry that we are changing  model.K : model2.a1.K.frozen = false\nmodel2 ┌ CompositeModel with 2 model components:\n│     m1 * a1 \n│ Model key and parameters:\n│      m1  => PhotoelectricAbsorption\n│        ηH -> 1 ± 0.1 ∈ [ 0, Inf ]  FREE \n│      a1  => PowerLaw\n│        K -> 2 ± 0.1 ∈ [ 0, Inf ]  FREE \n│        a -> 2 ± 0.2 ∈ [ 0, Inf ]  FREE \n└  model ┌ PowerLaw\n│ K -> 2                     FROZEN \n│ a -> 2 ± 0.2 ∈ [ 0, Inf ]  FREE \n└  Composite models have the same methods as single models. This means we can invoke a model in the same way invokemodel(domain, model2) 99-element view(::Matrix{Float64}, :, 1) with eltype Float64:\n 2.0751585013952092e-263\n 4.495947705380242e-37\n 6.169182651763269e-13\n 4.3452153392915345e-6\n 0.00071255337382327\n 0.0002950219828216392\n 0.0025894772776999717\n 0.005476504002915039\n 0.008240937581191064\n 0.014887524257980244\n ⋮\n 0.002352926658712353\n 0.0023033682709992184\n 0.002255340978829189\n 0.002208782849254055\n 0.002163635423211736\n 0.0021198431935328848\n 0.0020773528501903667\n 0.0020361145193630906\n 0.001996079508045848"},{"id":1433,"pagetitle":"Using models","title":"Defining new models","ref":"/SpectralFitting/stable/models/using-models/#Defining-new-models","content":" Defining new models To define your own model, you need to tell the package what the model parameters are and how to invoke the model. This is all done by creating a  struct  which subtypes  AbstractSpectralModel . Let's create a new  Additive  spectral model: Base.@kwdef struct MyModel{T} <: AbstractSpectralModel{T,Additive}\n    K::T = FitParam(2.0)\n    p::T = FitParam(3.0)\nend\n\n# implementing a dummy add operation this function can do anything it likes, but\n# must write the output into `output` and ideally should be thread safe\nfunction SpectralFitting.invoke!(output, input, model::MyModel)\n    SpectralFitting.finite_diff_kernel!(output, input) do E\n        E + model.p\n    end\nend Here we used the utility method  SpectralFitting.finite_diff_kernel!  to ensure the additive model is appropriately scaled across the bin width. Note that  Additive  models do not need to use the normalization parameter  K  themselves. This is because when we use  invokemodel  these sorts of translations are automatically applied, for compatability with external models. Our model is now ready to use model = MyModel() ┌ MyModel\n│ K -> 2 ± 0.2 ∈ [ 0, Inf ]  FREE \n│ p -> 3 ± 0.3 ∈ [ 0, Inf ]  FREE \n└  domain = collect(range(0.1, 10.0, 100))\ninvokemodel(domain, model) 99-element view(::Matrix{Float64}, :, 1) with eltype Float64:\n 0.20000000000000018\n 0.1999999999999993\n 0.20000000000000018\n 0.20000000000000018\n 0.20000000000000018\n 0.20000000000000018\n 0.1999999999999993\n 0.20000000000000018\n 0.20000000000000018\n 0.1999999999999993\n ⋮\n 0.1999999999999993\n 0.20000000000000284\n 0.1999999999999993\n 0.1999999999999993\n 0.1999999999999993\n 0.1999999999999993\n 0.20000000000000284\n 0.1999999999999993\n 0.1999999999999993 Note To add new XSPEC or foreign function models, see  Wrapping new XSPEC models ."},{"id":1434,"pagetitle":"Using models","title":"Model abstraction","ref":"/SpectralFitting/stable/models/using-models/#Model-abstraction","content":" Model abstraction All spectral models are a sub-type of  AbstractSpectralModel . SpectralFitting.AbstractSpectralModel  —  Type abstract type AbstractSpectralModel{T,K<:AbstractSpectralModelKind} end Supertype of all spectral models, tracking the number type  T  and  AbstractSpectralModelKind  denoted  K . Implementation Sub-types must implement the following interface (see the function's documentation for examples): SpectralFitting.invoke! The parameters of the model must be of types  FitParam  when default initialised, as this is used to perform introspection. The boiler plate for a new model is as follows: struct MyNewModel{T} <: AbstractSpectralModel{T,Additive}\n    \"Normalisation (required by Additive kinds)\n    K::T\n    \"First parameter\"\n    p1::T\n    \"Second parameter\"\n    p2::T\nend\n\n# add a default keyword constructor\nfunction MyNewModel(;K = FitParam(1.0), p1 = FitParam(2.0), p2 = FitParam(0.1))\n    MyNewModel(K, p1, p2)\nend\n\nfunction SpectralFitting.invoke!(output, domain, model::MyNewModel)\n    # implementation must overwrite `output`\n    output .= 0\nend Usage The available API for a spectral model is detailed below: invokemodel  /  invokemodel! : the primary way to invoke a model. allocate_model_output : allocate the output matrix for the model. The following query functions exist: modelkind  for obtaining  K implementation  used to ascertain whether we can do things like automatic differentiation through this model. parameter_count  to return a compile-time integer representing the total number of parameters in the model. parameter_vector  to obtain a vector where every element is a  FitParam  in the same order as the struct fields. parameter_names  to obtain a vector of symbols for each parameter. objective_cache_count  how many output arrays this model needs to be invoked (only used for  CompositeModel ). supports  what  AbstractDataLayout  are supported by this model. Conversion functions include: remake_with_parameters  for converting a model from  FitParam  type parameters to a primitive type (e.g.  Float64 ), or for rebuilding models with new values. The parametric type parameter  T  is the number type of the model and  K  defines the  AbstractSpectralModelKind . source SpectralFitting.invoke!  —  Function SpectralFitting.invoke!(output, domain, M::Type{<:AbstractSpectralModel}, params...) Used to define the behaviour of models. Should calculate the output of the model and write in-place into  output . The model parameters are passed in the model structure. Warning This function should not be called directly. Use  invokemodel  instead.  invoke!  is only to define the model, not to use it. Users should always call models using  invokemodel  or  invokemodel!  to ensure normalisations and closures are accounted for. Example Base.@kwdef struct MyModel{T} <: AbstractSpectralModel{T,Multiplicative}\n    p1::T = FitParam(1.0)\n    p2::T = FitParam(2.0)\n    p3::T = FitParam(3.0)\nend would have the arguments passed to  invoke!  as function SpectralFitting.invoke!(output, domain, model::MyModel)\n    # ...\nend source SpectralFitting.implementation  —  Function implementation(model::AbstractSpectralModel)\nimplementation(::Type{<:AbstractSpectralModel}) Get the  AbstractSpectralModelImplementation  for a given  AbstractSpectralModel  or model type. This is used primarily to learn what optimizations we can do with a model, for example propagating auto-diff gradients through a model or arbitrary precision numbers. source"},{"id":1435,"pagetitle":"Using models","title":"Model methods","ref":"/SpectralFitting/stable/models/using-models/#Model-methods","content":" Model methods SpectralFitting.invokemodel  —  Function invokemodel(domain, model::AbstractSpectralModel) Invoke the  AbstractSpectralModel  given by  model  over the domain  domain . This function will perform any normalisation or post-processing tasks that a specific model kind may require, e.g. multiplying by a normalisation constant for  Additive  models. Note invokemodel  allocates the needed output arrays based on the element type of  free_params  to allow automatic differentation libraries to calculate parameter gradients. In-place non-allocating variants are the  invokemodel!  functions. Example model = PowerLaw()\ndomain = collect(range(0.1, 20.0, 100))\n\ninvokemodel(domain, model) source SpectralFitting.invokemodel!  —  Function invokemodel!(output, domain, model)\ninvokemodel!(output, domain, model, params::AbstractVector)\ninvokemodel!(output, domain, model, params::ParameterCache) In-place variant of  invokemodel , calculating the output of an  AbstractSpectralModel  given by  model , optionally overriding the parameters using a  ParameterCache  or an  AbstractVector . The  output  may not necessarily be a single vector, and one should use  allocate_model_output  to allocate the output structure. Example model = PowerLaw()\ndomain = collect(range(0.1, 20.0, 100))\noutput = allocate_model_output(model, domain)\ninvokemodel!(output, domain, model) source"},{"id":1436,"pagetitle":"Using models","title":"Model algebra","ref":"/SpectralFitting/stable/models/using-models/#Model-algebra","content":" Model algebra Models exist as three different kinds, defined by an  AbstractSpectralModelKind  trait. SpectralFitting.AbstractSpectralModelKind  —  Type abstract type AbstractSpectralModelKind Abstract type of all model kinds. The algebra of models is as follows A + A = A\nM * M = M\nM * A = A\nC(A)  = A where  A  is  Additive ,  M  is  Multiplicative , and  C  is  Convolutional . All other operations are prohibited, e.g.  C(M)  or  M * C . To obtain  M * C  there must be an additive component, e.g.  M * C(A) . source SpectralFitting.Additive  —  Type Additive <: AbstractSpectralModelKind\nAdditive() Additive models are effectively the sources of photons, and are the principle building blocks of composite models. Every additive model has a normalisation parameter which re-scales the output by a constant factor  K . Note Defining custom additive models requires special care. See  Defining new models . source SpectralFitting.Multiplicative  —  Type Multiplicative <: AbstractSpectralModelKind\nMultiplicative() Multiplicative models act on  Additive  models, by element-wise multiplying the output in each domain bin of the additive model by a different factor. source SpectralFitting.Convolutional  —  Type Convolutional <: AbstractSpectralModelKind\nConvolutional() Convolutional models act on the output generated by  Additive  models, similar to  Multiplicative  models, however may convolve kernels through the output also. source"},{"id":1437,"pagetitle":"Using models","title":"Model data availability","ref":"/SpectralFitting/stable/models/using-models/#Model-data-availability","content":" Model data availability Many of the XSPEC implemented models use tabular data, such as FITS, and return results interpolated from these pre-calculated tables. In some cases, these table models have data files that are multiple gigabytes in size, and would be very unwieldy to ship indiscriminantly. SpectralFitting attempts to circumnavigate this bloat by downloading the model data on an  ut opus  basis. SpectralFitting.download_model_data  —  Function SpectralFitting.download_model_data(model::AbstractSpectralModel; kwargs...)\nSpectralFitting.download_model_data(M::Type{<:AbstractSpectralModel}; kwargs...)\nSpectralFitting.download_model_data(s::Symbol; kwargs...) Downloads the model data for a model specified either by  model , type  M , or symbol  s . Datafiles associated with a specific model may be registered using  SpectralFitting.register_model_data . The download is currently unconfigurable, but permits slight control via a number of keyword arguments: progress::Bool = true Display a progress bar for the download. model_source_url::String = \"http://www.star.bris.ac.uk/fbaker/XSPEC-model-data\" The source URL used to download the model data. All standard XSPEC spectral model data is currently being hosted on the University of Bristol astrophysics servers, and should be persistently available to anyone. source SpectralFitting.download_all_model_data  —  Function SpectralFitting.download_all_model_data() Downloads all model data for the models currently registered with  SpectralFitting.register_model_data . Calls  SpectralFitting.download_model_data  to perform the download. source Special care must be taken if new XSPEC models are wrapped to ensure the data is available. For more on this, see  Wrapping new XSPEC models . Model data may also alternatively be copied in  by-hand  from a HEASoft XSPEC source directory. In this case, the location to copy the data to may be determined via  joinpath(SpectralFitting.LibXSPEC_jll.artifact_dir, \"spectral\", \"modelData\") ."},{"id":1440,"pagetitle":"Wrapper models","title":"Wrapper models","ref":"/SpectralFitting/stable/models/wrapper-models/#Wrapper-models","content":" Wrapper models Wrapper models are a type of \"meta-model\" that can be used to change the behaviour of other models. Their constructors commonly take a model as an argument, and change the way this model is called. The following wrapper models are available SpectralFitting.AbstractModelWrapper SpectralFitting.AsConvolution SpectralFitting.AutoCache SpectralFitting.ParameterPatch SpectralFitting.ParameterPatch  —  Type ParameterPatch(model; patch::Function) An  AbstractModelWrapper  that can be used to manipulate the parameters of the model it wraps. For example model = PowerLaw() + PowerLaw()\n\nfunction patcher!(p)\n    # any arbitrary function may be defined here\n    p.a1.K = 3 * p.a2.K + sqrt(p.a2.a)\nend\n\npatched_model = ParameterPatch(model; patch = patcher!)\n\n# set the patched parameter as frozen so it is not fitted\n# failing to do so may ruin a fit\npatched_model.a1.K.frozen = true When the model is invoked, it will call the  patch  function to manipulate the parameters as desired. Warning This wrapper is relatively new and not extensively tested. It should be noted nothing is done to validate if a parameter that you are modifying is actually a  frozen  parameter. This will change in the future, and parameters patched this way will be labelled as  bound . source SpectralFitting.apply_patch!  —  Function apply_patch!(model::ParameterPatch) Apply a patch to the model (i.e. use the  patch!  function to update the model parameters). source SpectralFitting.AsConvolution  —  Type AsConvolution(model; domain = collect(range(0, 2, 100))) Turn an additive model into a convolutional model. Example convolution_model = AsConvolution(GaussianLine()) The above model will now convolve the  GaussianLine  model onto whatever it is applied to. The  domain  keyword can be used to pass the domain on which to evaluate the wrapped model before convolution. The domain is such that  x = 1  corresponds to no domain shift in the convolution (e.g., if the domain is energy, this would be the rest energy of a line). source SpectralFitting.AutoCache  —  Type AutoCache Used to automatically create a cache of another model, to avoid re-evaluating the model if the next parameters are close to the previous parameters. The intended use is for fitting expensive models which. Example model = PhotoelectricAbsorption() * AutoCache(PowerLaw()) In the above model, the  PowerLaw  component will be augmented with the caching behaviour. source SpectralFitting.AbstractModelWrapper  —  Type abstract type AbstractModelWrapper{M,T,K} <: AbstractSpectralModel{T,K} end Used to implement wrapper models that take existing models as their argument and modify their behaviour. source"},{"id":1443,"pagetitle":"XSPEC models","title":"XSPEC models","ref":"/SpectralFitting/stable/models/xspec-models/#XSPEC-models","content":" XSPEC models SpectralFitting can vendor the XSPEC model library through the utility package XSPECModels.jl. You can install this package directly from the University of Bristol's  AstroRegistry : pkg> registry add https://github.com/astro-group-bristol/AstroRegistry\npkg> add XSPECModels Using the package is straight forward once installed: using SpectralFitting, XSPECModels Note The convention is that models that have are imported from XSPEC or have XSPEC ABI are prefixed with  XS_  in their name. For example, the XSPEC equivalent of  PowerLaw  is  XS_PowerLaw . The XSPEC models are wrapped into SpectralFitting models using the [ @xspecmodel ] macro. If a model you require is not already wrapped, this macro will make that easy to do. Please consider upstreaming your wrapper via a PR to the SpectralFitting GitHub repository. XSPECModels.@xspecmodel  —  Macro @xspecmodel [type=Float64] [ff_call_site] model Used to wrap additional XSPEC models, generating the needed  AbstractSpectralModel  implementation. The  type  keyword specifies the underlying type to coerce input and output arrays to, as different implementations may have incompatible number of bits. The  ff_call_site  is the foreign fuction call site, which is the first argument to  ccall , and follows the same conventions. The  model  is a struct, which must subtype  AbstractSpectralModel . If the callsite is not specified, the user must implement  _unsafe_ffi_invoke! . Examples @xspecmodel :C_powerlaw struct XS_PowerLaw{T} <: AbstractSpectralModel{T, Additive}\n    \"Normalisation.\"\n    K::T\n    \"Photon index.\"\n    a::T\nend\n\n# constructor has default values\nfunction XS_PowerLaw(; K = FitParam(1.0), a = FitParam(1.0))\n    XS_PowerLaw{typeof(K)}(K, a)\nend We define a new structure  XS_PowerLaw  with two parameters, but since the model is  Additive , only a single parameter ( a ) is passed to the XSPEC function. The function we bind to this model is  :C_powerlaw  from the XSPEC C wrappers. The macro will then generate the following functions implementation invoke! _safe_ffi_invoke! If a callsite was specified, it will also generate: _unsafe_ffi_invoke! source XSPEC models frequently have tabular data dependencies, without which the models fail to invoke (see  Model data availability ). If the data files are known but not present, the XSPEC models will throw an error with instructions for downloading the missing data. If the data files are unknown, Julia may crash catastrophically. If this is the case, often a single line will be printed with the LibXSPEC error, specifying the name of the missing source file. This can be registered as a data dependency of a model using  SpectralFitting.register_model_data . The first time any XSPEC model is invoked, SpectralFitting checks to see whether requisite data is needed, and whether the data is downloaded. Subsequent calls will hit a lookup cache instead to avoid run-time costs of performing this check."},{"id":1444,"pagetitle":"XSPEC models","title":"Additive","ref":"/SpectralFitting/stable/models/xspec-models/#Additive","content":" Additive XSPECModels.XS_PowerLaw  —  Type XS_PowerLaw(K, a) K : Normalisation. a : Photon index. Example energy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_PowerLaw())                       XS_PowerLaw\n       ┌────────────────────────────────────────┐\n   0.5 │                                        │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │ :                                      │\n       │ :                                      │\n       │  :                                     │\n       │   :.                                   │\n       │    ':..                                │\n       │        ''':......                      │\n       │                  ''''''''''''''........│\n     0 │                                        │\n       └────────────────────────────────────────┘\n        0                                     20\n                         E (keV) source XSPECModels.XS_BlackBody  —  Type XS_BlackBody(K, T) K : Normalisation. T : Temperature (keV). Example energy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_BlackBody())                       XS_BlackBody\n       ┌────────────────────────────────────────┐\n   0.2 │                                        │\n       │                                        │\n       │                                        │\n       │                                        │\n       │                                        │\n       │                                        │\n       │      .:''':..                          │\n       │    .:       ''.                        │\n       │   .'           ':.                     │\n       │   :              ''..                  │\n       │  :                  ':.                │\n       │ :                     '':.             │\n       │.:                         ''..         │\n       │:                              '':....  │\n     0 │'                                    '''│\n       └────────────────────────────────────────┘\n        0                                     20\n                         E (keV) source XSPECModels.XS_BremsStrahlung  —  Type XS_BremsStrahlung(K, T) K : Normalisation. T : Plasma temperature (keV). Example energy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_BremsStrahlung())                   XS_BremsStrahlung\n     ┌────────────────────────────────────────┐\n   2 │                                        │\n     │.                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │'.                                      │\n     │ :                                      │\n   0 │  ':....................................│\n     └────────────────────────────────────────┘\n      0                                     20\n                       E (keV) source XSPECModels.XS_Gaussian  —  Type XS_Gaussian(K, E, σ) K : Normalisation E : Line energy in keV. σ : Line width in keV. Example energy = collect(range(4.0, 8.0, 100))\ninvokemodel(energy, XS_Gaussian())                         XS_Gaussian\n        ┌────────────────────────────────────────┐\n   0.09 │                                        │\n        │            .                           │\n        │           : :                          │\n        │           : :                          │\n        │           : '.                         │\n        │          .'  :                         │\n        │          :   :                         │\n        │          :   :                         │\n        │          :   '.                        │\n        │         :     :                        │\n        │         :     :                        │\n        │         :     :                        │\n        │        .'      :                       │\n        │        :       :                       │\n      0 │.......:         :......................│\n        └────────────────────────────────────────┘\n         0                                     20\n                          E (keV) source XSPECModels.XS_Laor  —  Type XS_Laor(K, lineE, a, inner_r, outer_r, incl) K : Normalisation. lineE : Rest frame line energy (keV). a : Power law dependence of emissivity. Scales R⁻ᵅ. inner_r : Inner radius of the accretion disk (GM/c). outer_r : Outer radius of the accretion disk (GM/c). θ : Disk inclination angle to line of sight (degrees, 0 is pole on). Example energy = collect(range(0.1, 10.0, 100))\ninvokemodel(energy, XS_Laor())                           XS_Laor\n        ┌────────────────────────────────────────┐\n   0.06 │                                        │\n        │                                        │\n        │                         ::             │\n        │                         ::             │\n        │                        : :             │\n        │                       :  :             │\n        │                      :   :             │\n        │                     :'   :             │\n        │                   .:     :             │\n        │                  :'      :             │\n        │                .'        :             │\n        │              .:'         :             │\n        │            ..'           :             │\n        │          .:'              :            │\n      0 │.......:''                 :............│\n        └────────────────────────────────────────┘\n         0                                     10\n                          E (keV) source XSPECModels.XS_DiskLine  —  Type XS_DiskLine(K, lineE, β, inner_r, outer_r, incl) K : Normalisation. lineE : Rest frame line energy (keV). β : Power law dependence of emissivity. If < 10, scales Rᵅ. inner_r : Inner radius of the accretion disk (GM/c). outer_r : Outer radius of the accretion disk (GM/c). θ : Disk inclination angle to line of sight (degrees, 0 is pole on). Example energy = collect(range(4.0, 8.0, 100))\ninvokemodel(energy, XS_DiskLine())                         XS_DiskLine\n        ┌────────────────────────────────────────┐\n   0.09 │                                        │\n        │                           .            │\n        │                           :            │\n        │                           ::           │\n        │                         . ::           │\n        │                         : ::           │\n        │                         :'':           │\n        │                        .'  :           │\n        │                        :    :          │\n        │                        :    :          │\n        │                       .'    :          │\n        │                       :     :          │\n        │                     .:      '.         │\n        │                   .:'        :         │\n      0 │...............:'''           :.........│\n        └────────────────────────────────────────┘\n         4                                      8\n                          E (keV) source XSPECModels.XS_PhotoelectricAbsorption  —  Type XS_PhotoelectricAbsorption(ηH) ηH : Equivalent hydrogen column (units of 10²² atoms per cm⁻²). Example energy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_PhotoelectricAbsorption())              XS_PhotoelectricAbsorption\n     ┌────────────────────────────────────────┐\n   1 │       ...''''''''''''''''''''''''''''''│\n     │      .'                                │\n     │     :                                  │\n     │    :'                                  │\n     │    :                                   │\n     │   :                                    │\n     │   :                                    │\n     │   :                                    │\n     │  :                                     │\n     │  :                                     │\n     │  :                                     │\n     │  :                                     │\n     │  :                                     │\n     │ :                                      │\n   0 │.:                                      │\n     └────────────────────────────────────────┘\n      0                                     20\n                       E (keV) source XSPECModels.XS_WarmAbsorption  —  Type XS_WarmAbsorption(ηH, Ew) ηH : Equivalent hydrogen column (units of 10²² atoms per cm⁻²). Ew : Window energy (keV). Example energy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_WarmAbsorption())                     XS_WarmAbsorption\n       ┌────────────────────────────────────────┐\n     1 │':      ...''':'''''''''''''''''''''''''│\n       │ :    .:'                               │\n       │ :   .'                                 │\n       │ :  .:                                  │\n       │ :  :                                   │\n       │ :  :                                   │\n       │ : :                                    │\n       │ : :                                    │\n       │ : :                                    │\n       │ : :                                    │\n       │ ::                                     │\n       │ ::                                     │\n       │  :                                     │\n       │  :                                     │\n   0.2 │  :                                     │\n       └────────────────────────────────────────┘\n        0                                     20\n                         E (keV) source XSPECModels.XS_CalculateFlux  —  Type XS_CalculateFlux(E_min, E_max, lg10Flux) E_min : Minimum energy. E_max : Maximum energy. log10Flux : log (base 10) flux in erg / cm^2 / s source XSPECModels.XS_KerrDisk  —  Type XS_KerrDisk(K, lineE, index1, index2, break_r, a, θ, inner_r, outer_r) K : Normalisation. lineE : Rest frame line energy (keV). index1 : Emissivity index for inner disk. index2 : Emissivity index for outer disk. break_r : Break radius separating inner and outer disk (gᵣ). a : Dimensionless black hole spin. θ : Disk inclination angle to line of sight (degrees). inner_r : Inner radius of the disk in units of rₘₛ. outer_r : Outer radius of the disk in units of rₘₛ. z : Redshift. Example energy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_KerrDisk())                         XS_KerrDisk\n        ┌────────────────────────────────────────┐\n   0.05 │                                        │\n        │                                        │\n        │                                .       │\n        │                               .:       │\n        │                              :::       │\n        │                            .:' '.      │\n        │                           .:    :      │\n        │                         ..'     :      │\n        │                         :'      :      │\n        │                       .'        :      │\n        │                     .:'         :      │\n        │                  .:''           :      │\n        │               .::'              :      │\n        │            ..:'                 :      │\n      0 │.........:'''                    :......│\n        └────────────────────────────────────────┘\n         0                                      8\n                          E (keV) source XSPECModels.XS_KyrLine  —  Type XS_KyrLine(K, a, θ_obs, inner_r, ms_flag, outer_r, lineE, α, β, break_r, z, limb) K : Normalisation. a : Dimensionless black hole spin. θ : Observer inclination (0 is on pole, degrees). inner_r : Inner radius of the disk in units of GM/c² ms_flag : 0: integrate from rᵢₙ. 1: integrate from rₘₛ. outer_r : Outer radius of the disk in units of GM/c² lineE : Rest frame line energy (keV). α β break_r : Break radius seperating inner and outer disk (GM/c²). z : Overall Doppler shift. limb : 0: isotropic emission, 1: Laor's limb darkening, 2: Haard's limb brightening. Example energy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_KyrLine())                         XS_KyrLine\n        ┌────────────────────────────────────────┐\n   0.05 │                                        │\n        │                                        │\n        │                                :       │\n        │                                :.      │\n        │                              :.':      │\n        │                             :'  :      │\n        │                            :    :      │\n        │                          .'     :      │\n        │                        .:'      :      │\n        │                       .'        :      │\n        │                     .:          :      │\n        │                   .'            :      │\n        │                .:'              :      │\n        │            ..:'                 :      │\n      0 │.........:'''                    :......│\n        └────────────────────────────────────────┘\n         0                                      8\n                          E (keV) source"},{"id":1447,"pagetitle":"Parameters","title":"Parameters","ref":"/SpectralFitting/stable/parameters/#Parameters","content":" Parameters One of the core interface that SpectralFitting.jl provides are the model abstractions, and a method for controlling their  parameters . Models are defined with a generic field type, so that they can be converted to primative types (e.g. Float64 or Float32) during evaluation. But whilst defining a model or a problem, the field type of all parameters is  FitParam . SpectralFitting.FitParam  —  Type FitParam(\n    value;\n    # default error is 10%\n    error = 0.1 * value,\n    frozen = false,\n    lower_limit = 0,\n    upper_limit = Inf\n) A parameter of an  AbstractSpectralModel . The fittable parameter can be used to control how a model will be invoked during fit, e.g. what rangers a parameter can take, whether they should be fronze, and so forth. Note Be aware, not all fitting algorithms support \"boxed\" parameters, where the lower and upper limits are taken into account. To link parameters together, see  bind!  or  ParameterPatch . Parameters can be modified in a model in the conventional way: model = PowerLaw()\n\n# set the value\nmodel.K = 2.0\n# set the error\nmodel.K.error = 0.3\n# set the lower bound\nmodel.K.lower_limit = 1.0 Accessing the values in a generic function should use  get_value . To iterate over all parameters of a model, use  parameter_vector . Fields value : The value (i.e. mean) of the parameter. error : The absolute (±, or standard deviation) error on the parameter. lower_limit : The lower limit the parameter can take. upper_limit : The upper limit the parameter can take. frozen : Is this a frozen parameter during fits? patched : Is this parameter patched in some way? A  FitParam  is a fittable (or frozen) parameter of an  AbstractSpectralModel . Every model will instantiate with  FitParam  as their parameter types so that they may be modified, bounded, frozen, or otherwise, as desired before a fit is attempted. The following methods should be preferred over direct field access for a  FitParam : set_value! get_value get_error get_lowerlimit get_upperlimit isfrozen isfree source"},{"id":1448,"pagetitle":"Parameters","title":"Parameter binding","ref":"/SpectralFitting/stable/parameters/#Parameter-binding","content":" Parameter binding When performing a fit, it is desireable to  bind  certain parameters together. This ensures that they will have the same value; for example, if you were fitting two simultaneous datasets with two  PowerLaw  models, you may want to have different normalisations of the model components, but enforce the power law index to be the same. To achieve this, SpectralFitting has the  bind!  function that applies to your  FittingProblem . SpectralFitting.bind!  —  Function bind!(prob::FittingProblem, pairs[, pairs...]) Bind parameters together within a  FittingProblem . Parameters bound together will be mandated to have same value during the fit. The binding must be specified in double or triple selector, which follow the format: pair := (model_index, :component_name, :parameter_symbol)\n     := (model_index, :parameter_symbol) The  model_index  is the index of the model in a multi-fit problem, i.e.  1 ,  2 , and so on. The component name is a  CompositeModel  model name, e.g.  :a1 , or  :c3 . This can be omitted if the model is not a  CompositeModel . The paramter symbol is a symbol representing the field of the parameter in the model. That is,  :K  or  :log10Flux . Bindings are specified using a chain of pairs  (root) => (target) [=> (target)] . The root parameter is kept as is, and all subsequent paramters are bound to the root. Multiple chains of pairs may be specified in a single call to  bind! , or, alternatively, multiple bindings may be specified with successive calls to  bind! . Bindings can be inspected with  details . See also  bindall! . Examples Bind model 1's  K  parameter to model 2's second additive model's  K : bind!(prob, (1, :K) => (2, :a2, :K)) Bind model 3's  :a2.K  parameter to model4's  :m3.L  and model 6's  :a1.a : bind!(prob, (3, :a2, :K) => (4, :m3, :K) => (6, :a1, :a)) Consider the following two models model1 = PhotoelectricAbsorption() * (BlackBody() + PowerLaw())\nmodel2 = PhotoelectricAbsorption() * (PowerLaw() + PowerLaw())\n\nprob = FittingProblem(model1 => data1, model2 => data2)\n\n# Bind the power law indices in the two models\nbindall!(prob, :a)\n\n# Bind the normalisation of powerlaws in the 2nd model:\nbind!(prob, (2, :a1, :K) => (2, :a2, :K))\n\n# To inspect the overall bindings.\ndetails(prob) Note Only free parameters can be bound together. source SpectralFitting.bindall!  —  Function bindall!(prob::FittingProblem, item[, item...]) Bind a common parameter across all models. The item is used to select the parameter to bind, and may either be a single symbol, or a model-symbol double. Examples # bind parameter `a` in all models\nbindall!(prob, :a)\n\n# bind parameter `K` in component `a3` in all models\nbindall!(prob, (:a3, :K))\n\n# multiple simultaneously\nbindall!(prob, :E, (:a2, :K)) source Note Bindings are treated not as specific to the model but specific to the  FittingProblem . This is because you may want to use the same model for multiple different datasets, and have slightly different binding requirements for each one (e.g. depending on the instruments you are using). If you do need the same binding applied to two different problems, you can do that with append!(prob1.bindings, prob2.bindings) Caution however, this will only make sense if you are using precisely the same model in both problems. Let's try it out. We'll generate some arbitrary powerlaw spectra with different normalisations and fit them simultaneously. using SpectralFitting, Plots\n\nenergy = collect(range(0.1, 10.0, 100))\n\n# two different models with different normalisations\nmodel1 = PowerLaw(K = FitParam(100.0), a = FitParam(1.2))\nmodel2 = PowerLaw(K = FitParam(300.0), a = FitParam(2.0))\n\ndata1 = simulate(energy, model1, var = 1e-3, seed = 42)\ndata2 = simulate(energy, model2, var = 1e-3, seed = 42)\n\nplot(data1, xscale = :log10, yscale = :log10)\nplot!(data2, xscale = :log10, yscale = :log10) Now we want to fit a single powerlaw model to both of these spectra simultaneously, but with the powerlaw index fixed to be the same in both models. model = PowerLaw()\nprob = FittingProblem(model => data1, model => data2)\n\nbindall!(prob, :a)\nprob ┌ FittingProblem:\n│   . Models     : 2\n│   . Datasets   : 2\n│   Parameter Summary:\n│   . Total      : 4\n│   .  Frozen      : 0\n│   .  Bound       : 1\n│   .  Free        : 3\n└  We can get a better look at our model configuration by using the  details  method: details(prob) ┌ Models:\n│    Model 1 : PowerLaw\n│   K -> 1 ± 0.1 ∈ [ 0, Inf ]  FREE \n│   a -> 2 ± 0.2 ∈ [ 0, Inf ]  FREE \n│\n│    Model 2 : PowerLaw\n│   K -> 1 ± 0.1 ∈ [ 0, Inf ]  FREE \n│   a ->  Bound to Model 1 -> a \n└ In this printout we see that the  a  parameter of  Model 2  is bound to the  a  parameter of  Model 1 . result = fit(prob, LevenbergMarquadt())\n\nplot(data1, xscale = :log10, yscale = :log10)\nplot!(data2, xscale = :log10, yscale = :log10)\nplot!(result[1])\nplot!(result[2]) Note that this fit is bad, because the underlying data have different power law indices, but our fit is required to enforce the models to have the same value. If we release this requirement, the fit will be much better, but the models will be entirely independent. prob = FittingProblem(model => data1, model => data2)\n\nresult = SpectralFitting.fit(prob, LevenbergMarquadt())\n\nplot(data1, xscale = :log10, yscale = :log10)\nplot!(data2, xscale = :log10, yscale = :log10)\nplot!(result[1])\nplot!(result[2])"},{"id":1449,"pagetitle":"Parameters","title":"Parameter patching","ref":"/SpectralFitting/stable/parameters/#Parameter-patching","content":" Parameter patching Warning The parameter patching interface is still experimental and will likely change in subsesquent versions of SpectralFitting.jl Sometimes simply linking values is not sufficient, and you need to express a complex relationship between parameters. This is where  ParameterPatch , a type of  AbstractModelWrapper  is useful. Consider the following using SpectralFitting, Plots\n\nreal_model = GaussianLine(K = FitParam(2.0)) + GaussianLine(μ = FitParam(2.0), K = FitParam(4.0))\nenergy = collect(range(0.1, 10.0, 100))\n\ndata = simulate(energy, real_model; var = 4e-4, seed = 42)\nplot(data) We can fit this simple dataset quite easily, but suppose we wanted to constrain the solution to have the normalisation of one model component be exactly twice that of the other. To achieve this, we can use a patch: function my_patch!(p)\n    p.a2.K = p.a1.K * 2\nend\n\n# reset the parameters so the fit starts \"fresh\"\nmodel = GaussianLine() + GaussianLine(μ = FitParam(3.0))\n\n# Wrap the model with a parameter patch\npatched_model = ParameterPatch(model; patch = my_patch!)\n# be sure to freeze any parameter you are planning to overwrite in a patch\npatched_model.a2.K.frozen = true\n\npatched_model ┌ ParameterPatch with 2 model components:\n│     a1 + a2 \n│ Model key and parameters:\n│      a1  => GaussianLine\n│        K -> 1   ± 0.1 ∈ [ 0, Inf ]  FREE \n│        μ -> 6.4 ± 0.6 ∈ [ 0, Inf ]  FREE \n│        σ -> 1   ± 0.1 ∈ [ 0, Inf ]  FREE \n│      a2  => GaussianLine\n│        K -> 1                     FROZEN /PATCHED \n│        μ -> 3 ± 0.3 ∈ [ 0, Inf ]  FREE \n│        σ -> 1 ± 0.1 ∈ [ 0, Inf ]  FREE \n└  This can then be fit as usual: prob = FittingProblem(patched_model => data)\nresult = fit(prob, LevenbergMarquadt())\n\nplot!(result) To apply the result with a parameter patch back on a model, use  update_model!  or  apply_patch! update_model!(patched_model, result)\npatched_model ┌ ParameterPatch with 2 model components:\n│     a1 + a2 \n│ Model key and parameters:\n│      a1  => GaussianLine\n│        K -> 1.97 ± 0.1 ∈ [ 0, Inf ]  FREE \n│        μ -> 6.34 ± 0.6 ∈ [ 0, Inf ]  FREE \n│        σ -> 1.05 ± 0.1 ∈ [ 0, Inf ]  FREE \n│      a2  => GaussianLine\n│        K -> 3.93                      FROZEN /PATCHED \n│        μ -> 2.01  ± 0.3 ∈ [ 0, Inf ]  FREE \n│        σ -> 0.961 ± 0.1 ∈ [ 0, Inf ]  FREE \n└ "},{"id":1452,"pagetitle":"Reference","title":"API reference","ref":"/SpectralFitting/stable/reference/#API-reference","content":" API reference"},{"id":1453,"pagetitle":"Reference","title":"General reference","ref":"/SpectralFitting/stable/reference/#General-reference","content":" General reference Modules = [SpectralFitting.Reflection]\nOrder   = [:function, :type]"},{"id":1456,"pagetitle":"Transitioning from XSPEC","title":"Transitioning from XSPEC","ref":"/SpectralFitting/stable/transitioning-from-xspec/#Transitioning-from-XSPEC","content":" Transitioning from XSPEC"},{"id":1459,"pagetitle":"Walkthrough","title":"Walkthrough","ref":"/SpectralFitting/stable/walkthrough/#Walkthrough","content":" Walkthrough Warning This walk through has not been fleshed out with the relevant astrophysical content yet (for example, whether a fit is good, what the different parameters mean, etc.), and so assumes some familarity with spectral fitting in general. It is also not yet complete, nor a faithful illustration of everything SpectralFitting.jl can do. It serves to illustrate similarities and differences in syntax between SpectralFitting.jl and XSPEC. This example walkthrough is the SpectralFitting.jl equivalent of the  Walk through XSPEC  from the XSPEC manual. We will use the same dataset, available for download from this  link to the data files ."},{"id":1460,"pagetitle":"Walkthrough","title":"Overview","ref":"/SpectralFitting/stable/walkthrough/#Overview","content":" Overview The first thing we want to do is load our datasets. Unlike in XSPEC, we have no requirement of being in the same directory as the data, or even that all of the response, ancillary, and spectral files be in the same place. For simplicity, we'll assume they are: Note Be sure to set  DATADIR  pointing to the directory where you keep the walkthrough data. using SpectralFitting, XSPECModels, Plots\n\nDATADIR = \"...\"\nspec1_path = joinpath(DATADIR, \"s54405.pha\")\ndata = OGIPDataset(spec1_path) ┌ SpectralDataset{SpectralFitting.OGIPData}:\n│   . Object              : 1E 1048-5937\n│   . Observation ID      : [no observation id]\n│   . Exposure ID         : [no exposure id]\n│  SpectralData  with  125  active channels: \n│   . Chn. E (min/max)    : (0.69357, 70.563)\n│   . Masked channels     : 0 / 125\n│   . Model domain size   : 129\n│   . Domain (min/max)    : (0.44347, 36.632)\n│  Primary Spectrum: \n│ Spectrum: EXOSAT[ME]\n│   Units                 : counts s^-1\n│   . Exposure time       : 23580.0\n│   . Channels            : 125\n│   . Data (min/max)      : (-0.028499, 0.30515)\n│   . Grouped             : yes\n│   . Bad channels        : yes (40)\n│  Response: \n│ Response Matrix (125 x 128) channels:\n│   . Chn. E (min/max)    : (0.69357, 70.563)\n│   . Domain E (min/max)  : (0.44347, 36.632)\n│ Background: nothing\n│ Ancillary: nothing\n└  This will print a little card about our data, which shows us what else SpectralFitting.jl loaded. We can see the  Primary Spectrum , the  Response , but that the  Background  and  Ancillary  response files are missing. That's to be expected, since we don't have those files in the dataset.  We can check what paths it used by looking at data.user_data.paths SpectralFilePaths:\n  . Spectrum       : /home/runner/work/SpectralFitting.jl/SpectralFitting.jl/docs/build/../../ex-datadir/s54405.pha\n  . Response       : /home/runner/work/SpectralFitting.jl/SpectralFitting.jl/docs/build/../../ex-datadir/s54405.rsp\n  . Background     : nothing\n  . Ancillary      : nothing\n We can load and alter any part of a dataset as we do our fitting. For example, if you have multiple different ancillary files at hand, switching them between fits is a one-liner. To visualize our data, we can use some of the  Plots.jl  recipes included in SpectralFitting.jl: plot(data, xlims = (0.5, 70), xscale = :log10) Note that the units are currently not divided by the energy bin widths. We can either do that manually, or use the  normalize!  to convert whatever units the data is currently in to the defacto standard  counts s⁻¹ keV⁻¹  for fitting. Whilst we're at it, we see in the model card that there are 40  bad quality bins  still present in our data. We can drop those as well, and plot the data on log-log axes: normalize!(data)\ndrop_bad_channels!(data)\nplot(data, ylims = (0.001, 2.0), yscale = :log10, xscale = :log10) Note that when there are no negative axes, the scale defaults to log on the plot unless otherwise specified. Next we want to specify a model to fit to this data. Models that are prefixed with  XS_  are models that are linked from the XSPEC model library, provided via  LibXSPEC_jll . For a full list of the models, see  Models library . Warning It is advised to  use the Julia implemented models . This allows various calculations to benefit from automatic differentiation, efficient multi-threading, GPU offloading, and various other useful things, see  Why & how . We will start by fitting a photoelectric absorption model that acts on a power law model: Note To see information about a model, use the  ?  in the Julia REPL: julia> ?PowerLaw\nXS_PowerLaw(K, a)\n\n    •  K: Normalisation.\n\n    •  a: Photon index.\n\nExample\n≡≡≡≡≡≡≡\n... model = PhotoelectricAbsorption() * PowerLaw() ┌ CompositeModel with 2 model components:\n│     m1 * a1 \n│ Model key and parameters:\n│      m1  => PhotoelectricAbsorption\n│        ηH -> 1 ± 0.1 ∈ [ 0, Inf ]  FREE \n│      a1  => PowerLaw\n│        K -> 1 ± 0.1 ∈ [ 0, Inf ]  FREE \n│        a -> 2 ± 0.2 ∈ [ 0, Inf ]  FREE \n└  If we want to specify paramters of our model at instantiation, we can do that with model = PhotoelectricAbsorption() * PowerLaw(a = FitParam(3.0)) ┌ CompositeModel with 2 model components:\n│     m1 * a1 \n│ Model key and parameters:\n│      m1  => PhotoelectricAbsorption\n│        ηH -> 1 ± 0.1 ∈ [ 0, Inf ]  FREE \n│      a1  => PowerLaw\n│        K -> 1 ± 0.1 ∈ [ 0, Inf ]  FREE \n│        a -> 3 ± 0.3 ∈ [ 0, Inf ]  FREE \n└  Alternatively, we can modify the parameters by reaching into the corresponding model component: set_value!(model.a1.a, 4.0) 4.0 SpectralFitting.jl adopts the SciML problem-solver abstraction, so to fit a model to data we specify a  FittingProblem : prob = FittingProblem(model => data) ┌ FittingProblem:\n│   . Models     : 1\n│   . Datasets   : 1\n│   Parameter Summary:\n│   . Total      : 3\n│   .  Frozen      : 0\n│   .  Bound       : 0\n│   .  Free        : 3\n└  SpectralFitting.jl makes a huge wealth of optimizers available from  Optimizations.jl , and others from further afield. For consistency with XSPEC, we'll use here a delayed-gratification least-squares algorithm from  LsqFit.jl : result = fit(prob, LevenbergMarquadt()) ┌ FitResult:\n│  Model:  CompositeModel \n│   . Name : m1.ηH      a1.K       a1.a       \n│   . u    : 0.56637    22.181     2.2488     \n│   . Δu   : 0.27433    4.3720     0.12638    \n│   . χ²   : 108.94\n└ Σχ² = 108.94 Here we can see the parameter vector, the estimated error on each parameter, and the measure of the fit statistic (here chi squared). We can overplot our result on our data easily: plot(data,\n    ylims = (0.001, 2.0),\n    xscale = :log10,\n    yscale = :log10\n)\nplot!(result) Our model does not account for the high energy range well. We can ignore that range for now, and select everything from 0 to 15 keV and refit: mask_energies!(data, 0, 15)\nresult = fit(prob, LevenbergMarquadt()) ┌ FitResult:\n│  Model:  CompositeModel \n│   . Name : m1.ηH      a1.K       a1.a       \n│   . u    : 0.53199    21.584     2.2307     \n│   . Δu   : 0.27277    4.2347     0.12576    \n│   . χ²   : 43.970\n└ Σχ² = 43.970 plot(data,\n    ylims = (0.001, 2.0),\n    xscale = :log10,\n    yscale = :log10\n)\nplot!(result, label = \"PowerLaw\") The result is not yet baked into our model, and represents just the outcome of the fit. To update the parameters and errors in the model, we can use  update_model! update_model!(model, result) ┌ CompositeModel with 2 model components:\n│     m1 * a1 \n│ Model key and parameters:\n│      m1  => PhotoelectricAbsorption\n│        ηH -> 0.532 ± 0.1 ∈ [ 0, Inf ]  FREE \n│      a1  => PowerLaw\n│        K -> 21.6 ± 0.1 ∈ [ 0, Inf ]  FREE \n│        a -> 2.23 ± 0.3 ∈ [ 0, Inf ]  FREE \n└  Note Since fitting and updating a model is often done in tandem, SpectralFitting.jl has both a  fit  and  fit!  method, the latter automatically updates the model parameters after fit. To estimate the goodness of our fit, we can mimic the  goodness  command from XSPEC. This will use the  simulate  function to simulate spectra for a dataset (here determined by the result), and fit the model to the simulated dataset. The fit statistic for each fit is then appended to an array, which we can use to plot a histogram: pcent, spread = goodness(result; N = 1000, seed = 42, exposure_time = data.spectrum.exposure_time)\n@info \"%goodness = $pcent\"\nhistogram(spread, ylims = (0, 300), label = \"Simulated\")\nvline!([result[1].stats], label = \"Best fit\") Note we have set the random number generator seed with  seed = 42  to allow our results to be strictly reproduced. The  goodness  command will return the percent of simulations with a fit statistic better than the result, in addition to the statistics of each individual trial. Next we want to calculate the flux in an energy range observed by the detector. We can do this with  LogFlux  or  XS_CalculateFlux , as they are both equivalent implementations. We can modify our model by accessing properties from the model card and writing a new expression: calc_flux = XS_CalculateFlux(\n    E_min = FitParam(0.2, frozen = true),\n    E_max = FitParam(2.0, frozen = true),\n    log10Flux = FitParam(-10.3, lower_limit = -100, upper_limit = 100),\n)\n\nflux_model = model.m1 * calc_flux(model.a1) ┌ CompositeModel with 3 model components:\n│     m1 * c1(a1) \n│ Model key and parameters:\n│      m1  => PhotoelectricAbsorption\n│        ηH -> 0.532 ± 0.1 ∈ [ 0, Inf ]  FREE \n│      c1  => XS_CalculateFlux\n│            E_min -> 0.2                        FROZEN \n│            E_max -> 2                          FROZEN \n│        log10Flux -> -10.3 ± 1 ∈ [ -100, 100 ]  FREE \n│      a1  => PowerLaw\n│        K -> 21.6 ± 0.1 ∈ [ 0, Inf ]  FREE \n│        a -> 2.23 ± 0.3 ∈ [ 0, Inf ]  FREE \n└  Since we used the old model to define the new one, our best fit values are automatically copied into the new model. We can now freeze the normalization, as we are using the flux integrating model to scale the powerlaw component: flux_model.a1.K.frozen = true\nflux_model ┌ CompositeModel with 3 model components:\n│     m1 * c1(a1) \n│ Model key and parameters:\n│      m1  => PhotoelectricAbsorption\n│        ηH -> 0.532 ± 0.1 ∈ [ 0, Inf ]  FREE \n│      c1  => XS_CalculateFlux\n│            E_min -> 0.2                        FROZEN \n│            E_max -> 2                          FROZEN \n│        log10Flux -> -10.3 ± 1 ∈ [ -100, 100 ]  FREE \n│      a1  => PowerLaw\n│        K -> 21.6                     FROZEN \n│        a -> 2.23 ± 0.3 ∈ [ 0, Inf ]  FREE \n└  Looking at the data card, we see the fit domain does not include the full region that we want to integrate the flux over. We therefore need to extend the fitting domain: flux_problem = FittingProblem(flux_model => data)\n# TODO: domain extensions not fully implemented yet ┌ FittingProblem:\n│   . Models     : 1\n│   . Datasets   : 1\n│   Parameter Summary:\n│   . Total      : 6\n│   .  Frozen      : 3\n│   .  Bound       : 0\n│   .  Free        : 3\n└  Now to fit we can repeat the above procedure, and even overplot the region of flux we integrated: flux_result = fit(flux_problem, LevenbergMarquadt())\n\nplot(data,\n    ylims = (0.001, 2.0),\n    xscale = :log10,\n    yscale = :log10\n)\nplot!(flux_result)\nvspan!([flux_model.c1.E_min.value, flux_model.c1.E_max.value], alpha = 0.5) Let's try alternative models to see how they fit the data. First, an absorbed black body: model2 = PhotoelectricAbsorption() * XS_BlackBody() ┌ CompositeModel with 2 model components:\n│     m1 * a1 \n│ Model key and parameters:\n│      m1  => PhotoelectricAbsorption\n│        ηH -> 1 ± 0.1 ∈ [ 0, Inf ]  FREE \n│      a1  => XS_BlackBody\n│        K -> 1 ± 0.1 ∈ [ 0, Inf ]  FREE \n│        T -> 3 ± 0.3 ∈ [ 0, Inf ]  FREE \n└  We fit in the same way as before: prob2 = FittingProblem(model2 => data)\nresult2 = fit!(prob2, LevenbergMarquadt()) ┌ FitResult:\n│  Model:  CompositeModel \n│   . Name : m1.ηH      a1.K       a1.T       \n│   . u    : 0.0        0.46462    0.89091    \n│   . Δu   : 0.27922    0.022068   0.032552   \n│   . χ²   : 123.78\n└ Σχ² = 123.78 Let's overplot this result against our power law result: dp = plot(data,\n    ylims = (0.001, 2.0),\n    xscale = :log10,\n    yscale = :log10,\n    legend = :bottomleft,\n)\nplot!(dp, result, label = \"PowerLaw $(round(sum(result.stats)))\")\nplot!(dp, result2, label = \"BlackBody $(round(sum(result2.stats)))\") Or a bremsstrahlung model: model3 = PhotoelectricAbsorption() * XS_BremsStrahlung()\nprob3 = FittingProblem(model3 => data)\nresult3 = fit(prob3, LevenbergMarquadt()) ┌ FitResult:\n│  Model:  CompositeModel \n│   . Name : m1.ηH      a1.K       a1.T       \n│   . u    : 0.0        13.869     5.3031     \n│   . Δu   : 0.19521    1.3055     0.70084    \n│   . χ²   : 40.027\n└ Σχ² = 40.027 plot!(dp, result3, label = \"Brems $(round(sum(result3.stats)))\") Let's take a look at the residuals of these three models. There are utility methods for this in SpectralFitting.jl, but we can easily just interact with the result directly: function calc_residuals(result)\n    # select which result we want (only have one, but for generalisation to multi-model fits)\n    r = result[1]\n    y = calculate_objective!(r, r.u)\n    obj, var = get_objective(r), get_objective_variance(r)\n    @. (obj - y) / sqrt(var)\nend\n\ndomain = SpectralFitting.plotting_domain(data)\n\nrp = hline([0], linestyle = :dash, legend = false)\nplot!(rp,domain, calc_residuals(result), seriestype = :stepmid)\nplot!(rp, domain, calc_residuals(result2), seriestype = :stepmid)\nplot!(rp, domain, calc_residuals(result3), seriestype = :stepmid)\nrp We can compose this figure with our previous one, and change to a linear x scale: plot(dp, rp, layout = grid(2, 1, heights = [0.7, 0.3]), link = :x, xscale = :linear) We can do all that plotting work with some of the builtin recipes: function plot_result(data, results...)\n    p1 = plot(data,\n        ylims = (0.001, 2.0),\n        xscale = :log10,\n        yscale = :log10,\n        legend = :bottomleft,\n    )\n    p2 = plot(xscale = :log10)\n    for r in results\n        plot!(p1, r)\n        residualplot!(p2, r)\n    end\n    plot(p1, p2, link = :x, layout = @layout [top{0.75h} ; bottom{0.25h}])\nend\n\nplot_result(data, result, result2, result3) Let's modify the black body model with a continuum component bbpl_model = model2.m1 * (PowerLaw() + model2.a1) |> deepcopy ┌ CompositeModel with 3 model components:\n│     m1 * (a1 + a2) \n│ Model key and parameters:\n│      m1  => PhotoelectricAbsorption\n│        ηH -> 0 ± 0.1 ∈ [ 0, Inf ]  FREE \n│      a1  => PowerLaw\n│        K -> 1 ± 0.1 ∈ [ 0, Inf ]  FREE \n│        a -> 2 ± 0.2 ∈ [ 0, Inf ]  FREE \n│      a2  => XS_BlackBody\n│        K -> 0.465 ± 0.1 ∈ [ 0, Inf ]  FREE \n│        T -> 0.891 ± 0.3 ∈ [ 0, Inf ]  FREE \n└  Note We pipe the model to  deepcopy  to create a copy of all the model parameters. Not doing this means the parameters in  bbpl_model  will be aliased to the parameters in  model2 , and changing one with change the other. We'll freeze the hydrogen column density parameter to the galactic value and refit: bbpl_model.m1.ηH.value = 4\nbbpl_model.m1.ηH.frozen = true\nbbpl_model ┌ CompositeModel with 3 model components:\n│     m1 * (a1 + a2) \n│ Model key and parameters:\n│      m1  => PhotoelectricAbsorption\n│        ηH -> 4  FROZEN \n│      a1  => PowerLaw\n│        K -> 1 ± 0.1 ∈ [ 0, Inf ]  FREE \n│        a -> 2 ± 0.2 ∈ [ 0, Inf ]  FREE \n│      a2  => XS_BlackBody\n│        K -> 0.465 ± 0.1 ∈ [ 0, Inf ]  FREE \n│        T -> 0.891 ± 0.3 ∈ [ 0, Inf ]  FREE \n└  And fitting: bbpl_result = fit(\n    FittingProblem(bbpl_model => data),\n    LevenbergMarquadt()\n) ┌ FitResult:\n│  Model:  CompositeModel \n│   . Name : a1.K       a1.a       a2.K       a2.T       \n│   . u    : 77.052     2.9226     83.697     0.15572    \n│   . Δu   : 12.743     0.11682    66.153     0.015973   \n│   . χ²   : 40.864\n└ Σχ² = 40.864 Let's plot the result: plot_result(data, bbpl_result) Update the model and fix the black body temperature to 2 keV: update_model!(bbpl_model, bbpl_result)\n\nbbpl_model.a2.T.value = 2.0\nbbpl_model.a2.T.frozen = true\nbbpl_model ┌ CompositeModel with 3 model components:\n│     m1 * (a1 + a2) \n│ Model key and parameters:\n│      m1  => PhotoelectricAbsorption\n│        ηH -> 4  FROZEN \n│      a1  => PowerLaw\n│        K -> 77.1 ± 0.1 ∈ [ 0, Inf ]  FREE \n│        a -> 2.92 ± 0.2 ∈ [ 0, Inf ]  FREE \n│      a2  => XS_BlackBody\n│        K -> 83.7 ± 0.1 ∈ [ 0, Inf ]  FREE \n│        T -> 2                        FROZEN \n└  Fitting: bbpl_result2 = fit(\n    FittingProblem(bbpl_model => data),\n    LevenbergMarquadt()\n) ┌ FitResult:\n│  Model:  CompositeModel \n│   . Name : a1.K       a1.a       a2.K       \n│   . u    : 573.17     4.8351     0.38234    \n│   . Δu   : 83.183     0.16012    0.034796   \n│   . χ²   : 71.708\n└ Σχ² = 71.708 Overplotting this new result: plot!(bbpl_result2)"},{"id":1461,"pagetitle":"Walkthrough","title":"MCMC","ref":"/SpectralFitting/stable/walkthrough/#MCMC","content":" MCMC We can use libraries like  Pidgeons.jl  or  Turing.jl  to perform Bayesian inference on our paramters. SpectralFitting.jl is designed with  BYOO  (Bring Your Own Optimizer) in mind, and so makes it relatively easy to get at the core fitting functions to be used with other packages. Let's use Turing.jl here, which means we'll also want to use  StatsPlots.jl  to plot our walker chains. using StatsPlots\nusing Turing Turing.jl provides enormous control over the definition of the model, and this is not control SpectralFitting.jl wants to take away from you. Although we will provide utility scripts to do the basics, here we'll show you everything step by step to give you an overview of what you can do. Let's go back to our first model: model ┌ CompositeModel with 2 model components:\n│     m1 * a1 \n│ Model key and parameters:\n│      m1  => PhotoelectricAbsorption\n│        ηH -> 0.532 ± 0.1 ∈ [ 0, Inf ]  FREE \n│      a1  => PowerLaw\n│        K -> 21.6 ± 0.1 ∈ [ 0, Inf ]  FREE \n│        a -> 2.23 ± 0.3 ∈ [ 0, Inf ]  FREE \n└  This gave a pretty good fit but the errors on our paramters are not well defined, being estimated only from a convariance matrix in the least-squares solver. MCMC can give us better confidence regions, and even help us uncover dependencies between paramters. Here we'll take all of our parameters and convert them into a Turing.jl model with use of their macro: @model function mcmc_model(objective, stddev, f)\n    K ~ Normal(20.0, 1.0)\n    a ~ Normal(2.2, 0.3)\n    ηH ~ truncated(Normal(0.5, 0.1); lower = 0)\n    pred = f(K, a, ηH)\n    return objective ~ MvNormal(pred, stddev)\nend mcmc_model (generic function with 2 methods) A few things to note here: we use the Turing.jl sampling syntax  ~  to say that a variable is sampled from a certain type of prior distribution. There are no fixed criteria for what a distribution can be, and we encourage you to consult the Turing.jl documentation to learn how to define your own custom probability distributions. In this case, we will use Gaussians for all our parameters, and for the means and standard deviations use the best fit and estimated errors. At the moment we haven't explicitly used our model, but  f  in this case takes the roll of invoking our model, and folding through instrument responses. We call it in much the same way as  invokemodel , despite it going the extra step to fold our model. To instantiate this, we can use the SpectralFitting.jl helper functions: config = FittingConfig(FittingProblem(model => data))\n\nmm = mcmc_model(\n    get_objective_single(config),\n    sqrt.(get_objective_variance_single(config)),\n    get_invoke_wrapper_single(config),\n) That's it! We're now ready to sample our model. Since all our models are implemented in Julia, we can use gradient-boosted samplers with automatic differentiation, such as NUTS. We'll walk 5000 itterations, just as a small example: chain = sample(mm, NUTS(), 5_000) Chains MCMC chain (5000×17×1 Array{Float64, 3}):\n\nIterations        = 1001:1:6000\nNumber of chains  = 1\nSamples per chain = 5000\nWall duration     = 18.15 seconds\nCompute duration  = 18.15 seconds\nparameters        = K, a, ηH\ninternals         = n_steps, is_accept, acceptance_rate, log_density, hamiltonian_energy, hamiltonian_energy_error, max_hamiltonian_energy_error, tree_depth, numerical_error, step_size, nom_step_size, lp, logprior, loglikelihood\n\nUse `describe(chains)` for summary statistics and quantiles.\n In the printout we see summary statistics about or model, in this case that it has converged well ( rhat  close to 1 for all parameters), better estimates of the standard deviation, and various quantiles. We can plot our chains to make sure the caterpillers are healthy and fuzzy, making use of StatsPlots.jl recipes: plot(chain) Using PairPlots.jl to create corner plots: import PairPlots, Makie, CairoMakie\n\ntable = (; # named tuple syntax\n    K = vec(chain[\"K\"]),\n    a = vec(chain[\"a\"]),\n    ηH = vec(chain[\"ηH\"])\n)\n\nPairPlots.pairplot(table)"},{"id":1464,"pagetitle":"Why & How","title":"Why & how","ref":"/SpectralFitting/stable/why-and-how/#Why-and-how","content":" Why & how SpectralFitting.jl is a package for fitting models to spectral data, similar to  XSPEC ,  Sherpa  or  ISIS . The rationale for this package is to provide a unanimous interface for different model libraries, and to leverage advancements in the computional methods that are available in Julia, including the rich statistics ecosystem, with  automatic-differentiation  and  speed . Longer term ambitions include Multi-wavelength fits Radiative transfer embedded into the package Spectral and timing fits SpectralFitting aims to provide highly optimised and flexible fitting algorithms, along with a library of spectral models, for use in any field of Astronomy that concerns itself with spectral data."},{"id":1467,"pagetitle":"LombScargle.jl","title":"LombScargle.jl","ref":"/LombScargle/stable/#LombScargle.jl","content":" LombScargle.jl"},{"id":1468,"pagetitle":"LombScargle.jl","title":"Introduction","ref":"/LombScargle/stable/#Introduction","content":" Introduction LombScargle.jl  is a package for a fast multi-threaded estimation of the  frequency spectrum  of a periodic signal with  the Lomb–Scargle periodogram .  This is written in  Julia , a modern high-level, high-performance dynamic programming language designed for technical computing. Another Julia package that provides tools to perform spectral analysis of signals is  DSP.jl , but its methods require that the signal has been sampled at equally spaced times. Instead, the Lomb–Scargle periodogram enables you to analyze unevenly sampled data as well, which is a fairly common case in astronomy, a field where this periodogram is widely used. The algorithms used in this package are reported in the following papers: [PR89] Press, W. H., Rybicki, G. B. 1989, ApJ, 338, 277 (URL:  http://dx.doi.org/10.1086/167197 , Bibcode:  http://adsabs.harvard.edu/abs/1989ApJ...338..277P ) [TOW10] Townsend, R. H. D. 2010, ApJS, 191, 247 (URL:  http://dx.doi.org/10.1088/0067-0049/191/2/247 , Bibcode:  http://adsabs.harvard.edu/abs/2010ApJS..191..247T ) [ZK09] Zechmeister, M., Kürster, M. 2009, A&A, 496, 577 (URL:  http://dx.doi.org/10.1051/0004-6361:200811296 , Bibcode:  http://adsabs.harvard.edu/abs/2009A%26A...496..577Z ) Other relevant papers are: [CMB99] Cumming, A., Marcy, G. W., & Butler, R. P. 1999, ApJ, 526, 890 (URL:  http://dx.doi.org/10.1086/308020 , Bibcode:  http://adsabs.harvard.edu/abs/1999ApJ...526..890C ) [CUM04] Cumming, A. 2004, MNRAS, 354, 1165 (URL:  http://dx.doi.org/10.1111/j.1365-2966.2004.08275.x , Bibcode:  http://adsabs.harvard.edu/abs/2004MNRAS.354.1165C ) [HB86] Horne, J. H., & Baliunas, S. L. 1986, ApJ, 302, 757 (URL:  http://dx.doi.org/10.1086/164037 , Bibcode:  http://adsabs.harvard.edu/abs/1986ApJ...302..757H ) [LOM76] Lomb, N. R. 1976, Ap&SS, 39, 447 (URL:  http://dx.doi.org/10.1007/BF00648343 , Bibcode:  http://adsabs.harvard.edu/abs/1976Ap%26SS..39..447L ) [MHC93] Murdoch, K. A., Hearnshaw, J. B., & Clark, M. 1993, ApJ, 413, 349 (URL:  http://dx.doi.org/10.1086/173003 , Bibcode:  http://adsabs.harvard.edu/abs/1993ApJ...413..349M ) [SCA82] Scargle, J. D. 1982, ApJ, 263, 835 (URL:  http://dx.doi.org/10.1086/160554 , Bibcode:  http://adsabs.harvard.edu/abs/1982ApJ...263..835S ) [SS10] Sturrock, P. A., & Scargle, J. D. 2010, ApJ, 718, 527 (URL:  http://dx.doi.org/10.1088/0004-637X/718/1/527 , Bibcode:  http://adsabs.harvard.edu/abs/2010ApJ...718..527S ) The package provides facilities to: compute the periodogram using different methods (with different speeds) and different normalizations. This is one of the fastest implementations of these methods available as free software. If Julia is run with more than one  thread , computation is automatically multi-threaded, further speeding up calculations; access the frequency and period grid of the resulting periodogram, together with the power spectrum; find the maximum power in the periodogram and the frequency and period corresponding to the peak. All these queries can be restricted to a specified region, in order to search a local maximum, instead of the global one; calculate the probability that a peak arises from noise only (false-alarm probability) using analytic formulas, in order to assess the significance of the peak; perform bootstrap resamplings in order to compute the false-alarm probability with a statistical method; determine the best-fitting Lomb–Scargle model for the given data set at the given frequency."},{"id":1469,"pagetitle":"LombScargle.jl","title":"Installation","ref":"/LombScargle/stable/#Installation","content":" Installation LombScargle.jl  is available for Julia 0.7 and later versions, and can be installed with  Julia's built-in package manager . In a Julia session run the commands julia> using Pkg\njulia> Pkg.update()\njulia> Pkg.add(\"LombScargle\") Older versions are also available for Julia 0.4-0.6."},{"id":1470,"pagetitle":"LombScargle.jl","title":"Usage","ref":"/LombScargle/stable/#Usage","content":" Usage After installing the package, you can start using it with using LombScargle The module defines a new  LombScargle.Periodogram  data type, which, however, is not exported because you will most probably not need to directly manipulate such objects. This data type holds both the frequency and the power vectors of the periodogram. The main function provided by the package is  lombscargle :"},{"id":1471,"pagetitle":"LombScargle.jl","title":"LombScargle.lombscargle","ref":"/LombScargle/stable/#LombScargle.lombscargle-Tuple{AbstractVector{var\"#s1\"} where var\"#s1\"<:Real, Vararg{Any, N} where N}","content":" LombScargle.lombscargle  —  Method lombscargle(times::AbstractVector{<:Real}, signal::AbstractVector{<:Real},\n            [errors::AbstractVector{<:Real}]; keywords...) Compute the Lomb–Scargle periodogram of the  signal  vector, observed at  times .  You can also specify the uncertainties for each signal point with  errors  argument.  All these vectors must have the same length. All optional keywords are described in the docstring of  LombScargle.plan . If the signal has uncertainties, the  signal  vector can also be a vector of  Measurement  objects (from  Measurements.jl  package), in which case you don’t need to pass a separate  errors  vector for the uncertainties of the signal. source lombscargle  returns a  LombScargle.Periodogram . The only two mandatory arguments are: times : the vector of observation times signal : the vector of observations associated with  times The optional argument is: errors : the uncertainties associated to each  signal  point. All these vectors must have the same length. Tip You can pre-plan a periodogram with  LombScargle.plan  function, which has the same syntax as  lombscargle  described in this section. In this way the actual computation of the periodogram is faster and you will save memory. See the  Planning the Periodogram  section below. Tip LombScargle.jl  exploits Julia's native  multi-threading  for the non-fast methods (the methods used when you set the keyword  fast=false ). Run Julia with  $n$  threads (e.g.,  JULIA_NUM_THREADS=4 julia  for 4 threads, if your machine has 4 physical cores) in order to automatically gain an  $n$  -fold scaling. Please note that multi-threading is still an experimental feature in Julia, so you may encounter issues when running it with more than one thread. For example, bug  #17395  (if still open) may prevent the function, on some systems, from effectively scaling. If the signal has uncertainties, the  signal  vector can also be a vector of  Measurement  objects (from  Measurements.jl  package), in which case you need not to pass a separate  errors  vector for the uncertainties of the signal. You can create arrays of  Measurement  objects with the  measurement  function, see  Measurements.jl  manual at  https://juliaphysics.github.io/Measurements.jl/stable  for more details. The generalised Lomb–Scargle periodogram by [ZK09] is always used when the signal has uncertainties, because the original Lomb–Scargle algorithm cannot handle them. Tip The uncertainties are only used in the generalised Lomb–Scargle algorithm to build an  inverse-variance  weights vector (see [ZK09]), that gives more importance to datapoints with lower uncertainties. The case where all measurements have the same uncertainty (a condition known as  homoskedasticity ) results in a constant weights vector, like if there are no uncertainties at all. If you have homoskedastic errors, you do not need to provide them to  lombscargle ."},{"id":1472,"pagetitle":"LombScargle.jl","title":"Planning the Periodogram","ref":"/LombScargle/stable/#Planning-the-Periodogram","content":" Planning the Periodogram In a manner similar to planning Fourier transforms with FFTW, it is possible to speed-up computation of the Lomb–Scargle periodogram by pre-planning it with  LombScargle.plan  function. It has the same syntax as  lombscargle , which in the base case is:"},{"id":1473,"pagetitle":"LombScargle.jl","title":"LombScargle.plan","ref":"/LombScargle/stable/#LombScargle.plan","content":" LombScargle.plan  —  Function LombScargle.plan(times::AbstractVector{<:Real}, signal::AbstractVector{<:Real},\n                 [errors::AbstractVector{<:Real}];\n                 normalization::Symbol=:standard,\n                 noise_level::Real=1,\n                 center_data::Bool=true,\n                 fit_mean::Bool=true,\n                 fast::Bool=true,\n                 flags::Integer=FFTW.ESTIMATE,\n                 timelimit::Real=Inf,\n                 oversampling::Integer=5,\n                 padding_factors::Vector{Int}=[2],\n                 Mfft::Integer=4,\n                 samples_per_peak::Integer=5,\n                 nyquist_factor::Integer=5,\n                 minimum_frequency::Real=NaN,\n                 maximum_frequency::Real=NaN,\n                 frequencies::AbstractVector{Real}=\n                 autofrequency(times,\n                               samples_per_peak=samples_per_peak,\n                               nyquist_factor=nyquist_factor,\n                               minimum_frequency=minimum_frequency,\n                               maximum_frequency=maximum_frequency)) Pre-plan the Lomb–Scargle periodogram of the  signal  vector, observed at  times .  The periodogram can then be computed by passing the result of this function to  lombscargle . You can also specify the uncertainties for each signal point with  errors  argument.  All these vectors must have the same length. Optional keywords arguments are: normalization : how to normalize the periodogram.  Valid choices are:  :standard ,  :model ,  :log ,  :psd ,  :Scargle ,  :HorneBaliunas ,  :Cumming noise_level : the noise level used to normalize the periodogram when  normalization  is set to  :Scargle fit_mean : if  true , fit for the mean of the signal using the Generalised Lomb–Scargle algorithm (see Zechmeister & Kürster paper below).  If this is  false  and no uncertainty on the signal is provided, the original algorithm by Lomb and Scargle will be employed (see Townsend paper below) center_data : if  true , subtract the weighted mean of  signal  from  signal  itself before performing the periodogram.  This is especially important if  fit_mean  is  false frequencies : the frequecy grid (not angular frequencies) at which the periodogram will be computed, as a vector.  If not provided, it is an evenly spaced grid of type  Range , automatically determined with  LombScargle.autofrequency  function, which see.  See below for other available keywords that can be used to affect the frequency grid without directly setting  frequencies You can explicitely require to use or not the fast method by Press & Rybicki, overriding the default choice, by setting the  fast  keyword.  In any case,  frequencies  must be a  Range  object (this is the default) in order to actually use this method.  A few other keywords are available to adjust the settings of the periodogram when the fast method is used (otherwise they are ignored): fast : whether to use the fast method. flags : this integer keyword is a bitwise-or of FFTW planner flags, defaulting to  FFTW.ESTIMATE .  Passing  FFTW.MEASURE  or  FFTW.PATIENT  will instead spend several seconds (or more) benchmarking different possible FFT algorithms and picking the fastest one; see the FFTW manual for more information on planner flags. timelimit : specifies a rough upper bound on the allowed planning time, in seconds. oversampling : oversampling the frequency factor for the approximation; roughly the number of time samples across the highest-frequency sinusoid. This parameter contains the tradeoff between accuracy and speed. padding_factors : the FFT is performed on a vector with length equal to the smallest number larger than or equal to  N * oversampling  which is a product of all numbers in this vector.  E.g., use  padding_factors=[2]  to perform the FFT on a vector padded to a power of 2, or  padding_factors=[2, 3, 5, 7]  for the optimal size for the FFTW library. Mfft : the number of adjacent points to use in the FFT approximation. In addition, you can use all optional keyword arguments of  LombScargle.autofrequency  function in order to tune the  frequencies . If the signal has uncertainties, the  signal  vector can also be a vector of  Measurement  objects (from  Measurements.jl  package), in which case you don’t need to pass a separate  errors  vector for the uncertainties of the signal. source"},{"id":1474,"pagetitle":"LombScargle.jl","title":"LombScargle.autofrequency","ref":"/LombScargle/stable/#LombScargle.autofrequency","content":" LombScargle.autofrequency  —  Function autofrequency(times::AbstractVector{Real};\n              samples_per_peak::Integer=5,\n              nyquist_factor::Integer=5,\n              minimum_frequency::Real=NaN,\n              maximum_frequency::Real=NaN) Determine a suitable frequency grid for the given vector of  times . Optional keyword arguments are: samples_per_peak : the approximate number of desired samples across the typical peak nyquist_factor : the multiple of the average Nyquist frequency used to choose the maximum frequency if  maximum_frequency  is not provided minimum_frequency : if specified, then use this minimum frequency rather than one chosen based on the size of the baseline maximum_frequency : if specified, then use this maximum frequency rather than one chosen based on the average Nyquist frequency This is based on prescription given at  https://jakevdp.github.io/blog/2015/06/13/lomb-scargle-in-python/  and uses the same keywords names adopted in Astropy. source LombScargle.plan  takes all the same argument as  lombscargle  shown above and returns a  LombScargle.PeriodogramPlan  object after having pre-computed certain quantities needed afterwards, and pre-allocated the memory for the periodogram. It is highly suggested to plan a periodogram before actually computing it, especially for the fast method. Once you plan a periodogram, you can pass the  LombScargle.PeriodogramPlan  to  lombscargle  as the only argument."},{"id":1475,"pagetitle":"LombScargle.jl","title":"LombScargle.lombscargle","ref":"/LombScargle/stable/#LombScargle.lombscargle-Tuple{LombScargle.PeriodogramPlan}","content":" LombScargle.lombscargle  —  Method lombscargle(plan::PeriodogramPlan) Compute the Lomb–Scargle periodogram for the given  plan .  This method has no other arguments.  See documentation of  LombScargle.plan  for how to plan a Lomb–Scargle periodogram. source Planning the periodogram has a twofold advantage. First of all, the planning stage is  type-unstable , because the type of the plan depends on the value of input parameters, and not on their types. Thus, separating the planning (inherently inefficient) from the actual computation of the periodogram (completely type-stable) makes overall computation faster than directly calling  lombscargle . Secondly, the  LombScargle.PeriodogramPlan  bears the time vector, but the quantities that are pre-computed in planning stage do not actually depend on it. This is particularly useful if you want to calculate the  False-Alarm Probability  via bootstrapping with  LombScargle.bootstrap : the vector time is randomly shuffled, but pre-computed quantities will remain the same, saving both time and memory in each iteration. In addition, you ensure that you will use the same options you used to compute the periodogram."},{"id":1476,"pagetitle":"LombScargle.jl","title":"Fast Algorithm","ref":"/LombScargle/stable/#Fast-Algorithm","content":" Fast Algorithm When the frequency grid is evenly spaced, you can compute an approximate generalised Lomb–Scargle periodogram using a fast algorithm proposed by [PR89] that greatly speeds up calculations, as it scales as  $O[N \\log(M)]$  for  $N$  data points and  $M$  frequencies. For comparison, the true Lomb–Scargle periodogram has complexity  $O[NM]$ .  The larger the number of datapoints, the more accurate the approximation. Note This method internally performs a  Fast Fourier Transform  (FFT) to compute some quantities, but it is in no way equivalent to conventional Fourier periodogram analysis. LombScargle.jl  uses  FFTW  functions to compute the FFT. You can speed-up this task by using multi-threading: call  FFTW.set_num_threads(n)  to use  $n$  threads. However, please note that the running time will not scale as  $n$  because computation of the FFT is only a part of the algorithm. The only prerequisite in order to be able to employ this fast method is to provide a  frequencies  vector as an  AbstractRange  object, which ensures that the frequency grid is perfectly evenly spaced. This is the default, since  LombScargle.autofrequency  returns an  AbstractRange  object. Tip In Julia, an  AbstractRange  object can be constructed for example with the  range  function (you specify the start of the range, and optionally the stop, the length and the step of the vector) or with the syntax  start:[step:]stop  (you specify the start and the end of the range, and optionally the linear step). Since this fast method is accurate only for large datasets, it is enabled by default only if the number of output frequencies is larger than 200. You can override the default choice of using this method by setting the  fast  keyword to  true  or  false . We recall that in any case, the  frequencies  vector must be a  Range  in order to use this method. To summarize, provided that  frequencies  vector is an  AbstractRange  object, you can use the fast method: by default if the length of the output frequency grid is larger than 200 points in any case with the  fast=true  keyword Setting  fast=false  always ensures you that this method will not be used, instead  fast=true  actually enables it only if  frequencies  is an  AbstractRange ."},{"id":1477,"pagetitle":"LombScargle.jl","title":"Normalization","ref":"/LombScargle/stable/#Normalization","content":" Normalization By default, the periodogram  $p(f)$  is normalized so that it has values in the range  $0 \\leq p(f) \\leq 1$ , with  $p = 0$  indicating no improvement of the fit and  $p = 1$  a \"perfect\" fit (100% reduction of  $\\chi^2$  or  $\\chi^2 = 0$ ). This is the normalization suggested by [LOM76] and [ZK09], and corresponds to the  :standard  normalization in  lombscargle  function. [ZK09] wrote the formula for the power of the periodogram at frequency  $f$  as \\[p(f) = \\frac{1}{YY}\\left[\\frac{YC^2_{\\tau}}{CC_{\\tau}} +\n\\frac{YS^2_{\\tau}}{SS_{\\tau}}\\right]\\] See the paper for details. The other normalizations for periodograms  $P(f)$  are calculated from this one. In what follows,  $N$  is the number of observations. :model : \\[P(f) = \\frac{p(f)}{1 - p(f)}\\] :log : \\[P(f) = -\\log(1 - p(f))\\] :psd : \\[P(f) = \\frac{W}{2}\\left[\\frac{YC^2_{\\tau}}{CC_{\\tau}} +\n\\frac{YS^2_{\\tau}}{SS_{\\tau}}\\right] = p(f) \\frac{W*YY}{2}\\] where W is the sum of the inverse of the individual errors,  $W = \\sum \\frac{1}{\\sigma_{i}}$ , as given in [ZK09]. :Scargle : \\[P(f) = \\frac{p(f)}{\\text{noise level}}\\] This normalization can be used when you know the noise level (expected from the a priori known noise variance or population variance), but this isn't usually the case. See [SCA82] :HorneBaliunas : \\[P(f) = \\frac{N - 1}{2} p(f)\\] This is like the  :Scargle  normalization, where the noise has been estimated for Gaussian noise to be  $(N - 1)/2$ . See [HB86] If the data contains a signal or if errors are under- or overestimated or if intrinsic variability is present, then  $(N-1)/2$  may not be a good uncorrelated estimator for the noise level.  [CMB99] suggested to estimate the noise level a posteriori with the residuals of the best fit and normalised the periodogram as: \\[P(f) = \\frac{N - 3}{2} \\frac{p(f)}{1 - p(f_{\\text{best}})}\\] This is the  :Cumming  normalization option"},{"id":1478,"pagetitle":"LombScargle.jl","title":"Access Frequency Grid and Power Spectrum of the Periodogram","ref":"/LombScargle/stable/#Access-Frequency-Grid-and-Power-Spectrum-of-the-Periodogram","content":" Access Frequency Grid and Power Spectrum of the Periodogram lombscargle  returns a  LombScargle.Periodogram  object, but you most probably want to use the frequency grid and the power spectrum. You can access these vectors with  freq  and  power  functions, just like in  DSP.jl  package. If you want to get the 2-tuple  (freq(p), power(p))  use the  freqpower  function."},{"id":1479,"pagetitle":"LombScargle.jl","title":"LombScargle.power","ref":"/LombScargle/stable/#LombScargle.power","content":" LombScargle.power  —  Function power(p::Periodogram) Return the power vector of Lomb–Scargle periodogram  p . source"},{"id":1480,"pagetitle":"LombScargle.jl","title":"LombScargle.freq","ref":"/LombScargle/stable/#LombScargle.freq","content":" LombScargle.freq  —  Function freq(p::Periodogram) Return the frequency vector of Lomb–Scargle periodogram  p . source"},{"id":1481,"pagetitle":"LombScargle.jl","title":"LombScargle.freqpower","ref":"/LombScargle/stable/#LombScargle.freqpower","content":" LombScargle.freqpower  —  Function freqpower(p::Periodogram) Return the 2-tuple  (freq(p), power(p)) , where  freq(p)  and  power(p)  are the frequency vector and the power vector of Lomb–Scargle periodogram  p  respectively. source"},{"id":1482,"pagetitle":"LombScargle.jl","title":"Access Period Grid","ref":"/LombScargle/stable/#Access-Period-Grid","content":" Access Period Grid The following utilities are the analogs of  freq  and  freqpower , but relative to the periods instead of the frequencies. Thus  period(p)  returns the vector of periods in the periodogram, that is  1./freq(p) , and  periodpower(p)  gives you the 2-tuple  (period(p), power(p)) ."},{"id":1483,"pagetitle":"LombScargle.jl","title":"LombScargle.period","ref":"/LombScargle/stable/#LombScargle.period","content":" LombScargle.period  —  Function period(p::Periodogram) Return the period vector of Lomb–Scargle periodogram  p .  It is equal to  1 ./ freq(p) . source"},{"id":1484,"pagetitle":"LombScargle.jl","title":"LombScargle.periodpower","ref":"/LombScargle/stable/#LombScargle.periodpower","content":" LombScargle.periodpower  —  Function periodpower(p::Periodogram) Return the 2-tuple  (period(p), power(p)) , where  period(p)  and  power(p)  are the period vector and the power vector of Lomb–Scargle periodogram  p  respectively. source"},{"id":1485,"pagetitle":"LombScargle.jl","title":"findmaxpower, findmaxfreq, and findmaxperiod Functions","ref":"/LombScargle/stable/#findmaxpower,-findmaxfreq,-and-findmaxperiod-Functions","content":" findmaxpower ,  findmaxfreq , and  findmaxperiod  Functions Once you compute the periodogram, you usually want to know which are the frequencies or periods with highest power. To do this, you can use the  findmaxfreq  and  findmaxperiod  functions."},{"id":1486,"pagetitle":"LombScargle.jl","title":"LombScargle.findmaxpower","ref":"/LombScargle/stable/#LombScargle.findmaxpower","content":" LombScargle.findmaxpower  —  Function findmaxpower(p::Periodogram) Return the highest power of the periodogram  p . source"},{"id":1487,"pagetitle":"LombScargle.jl","title":"LombScargle.findmaxfreq","ref":"/LombScargle/stable/#LombScargle.findmaxfreq","content":" LombScargle.findmaxfreq  —  Function findmaxfreq(p::Periodogram, [interval::AbstractVector{Real}], threshold::Real=findmaxpower(p)) Return the array of frequencies with the highest power in the periodogram  p . If a scalar real argument  threshold  is provided, return the frequencies with power larger than or equal to  threshold .  If you want to limit the search to a narrower frequency range, pass as second argument a vector with the extrema of the interval. source"},{"id":1488,"pagetitle":"LombScargle.jl","title":"LombScargle.findmaxperiod","ref":"/LombScargle/stable/#LombScargle.findmaxperiod","content":" LombScargle.findmaxperiod  —  Function findmaxperiod(p::Periodogram, [interval::AbstractVector{Real}], threshold::Real=findmaxpower(p)) Return the array of periods with the highest power in the periodogram  p .  If a scalar real argument  threshold  is provided, return the period with power larger than or equal to  threshold .  If you want to limit the search to a narrower period range, pass as second argument a vector with the extrema of the interval. source"},{"id":1489,"pagetitle":"LombScargle.jl","title":"False-Alarm Probability","ref":"/LombScargle/stable/#False-Alarm-Probability","content":" False-Alarm Probability Noise in the data produce fluctuations in the periodogram that will present several local peaks, but not all of them related to real periodicities. The significance of the peaks can be tested by calculating the probability that its power can arise purely from noise.  The higher the value of the power, the lower will be this probability. Note [CMB99] showed that the different normalizations result in different probability functions.  LombScargle.jl  can calculate the probability (and the false-alarm probability) only for the normalizations reported by [ZK09], that are  :standard ,  :Scargle ,  :HorneBaliunas , and  :Cumming . The probability  $\\text{Prob}(p > p_{0})$  that the periodogram power  $p$  can exceed the value  $p_{0}$  can be calculated with the  prob  function, whose first argument is the periodogram and the second one is the  $p_{0}$  value. The function  probinv  is its inverse: it takes the probability as second argument and returns the corresponding  $p_{0}$  value."},{"id":1490,"pagetitle":"LombScargle.jl","title":"LombScargle.prob","ref":"/LombScargle/stable/#LombScargle.prob-Tuple{LombScargle.Periodogram, Real}","content":" LombScargle.prob  —  Method prob(P::Periodogram, pow::Real) Return the probability that the periodogram power can exceed the value  pow . Its inverse is the  probinv  function. source"},{"id":1491,"pagetitle":"LombScargle.jl","title":"LombScargle.probinv","ref":"/LombScargle/stable/#LombScargle.probinv-Tuple{LombScargle.Periodogram, Real}","content":" LombScargle.probinv  —  Method probinv(P::Periodogram, prob::Real) Return the power value of the periodogram power whose probability is  prob . This is the inverse of  prob  function. source"},{"id":1492,"pagetitle":"LombScargle.jl","title":"LombScargle.M","ref":"/LombScargle/stable/#LombScargle.M","content":" LombScargle.M  —  Function LombScargle.M(P::Periodogram) Estimates the number of independent frequencies in the periodogram  P . source"},{"id":1493,"pagetitle":"LombScargle.jl","title":"LombScargle.fap","ref":"/LombScargle/stable/#LombScargle.fap-Tuple{LombScargle.Periodogram, Real}","content":" LombScargle.fap  —  Method fap(P::Periodogram, pow::Real) Return the false-alarm probability for periodogram  P  and power value  pow . Its inverse is the  fapinv  function. source"},{"id":1494,"pagetitle":"LombScargle.jl","title":"LombScargle.fapinv","ref":"/LombScargle/stable/#LombScargle.fapinv-Tuple{LombScargle.Periodogram, Real}","content":" LombScargle.fapinv  —  Method fapinv(P::Periodogram, prob::Real) Return the power value of the periodogram whose false-alarm probability is  prob . This is the inverse of  fap  function. source Here are the probability functions for each normalization supported by  LombScargle.jl : :standard  ( $p \\in [0, 1]$ ): \\[\\text{Prob}(p > p_{0}) = (1 - p_{0})^{(N - 3)/2}\\] :Scargle  ( $p \\in [0, \\infty)$ ): \\[\\text{Prob}(p > p_{0}) = \\exp(-p_{0})\\] :HorneBaliunas  ( $p \\in [0, (N - 1)/2]$ ): \\[\\text{Prob}(p > p_{0}) = \\left(1 - \\frac{2p_{0}}{N - 1}\\right)^{(N - 3)/2}\\] :Cumming  ( $p \\in [0, \\infty)$ ): \\[\\text{Prob}(p > p_{0}) = \\left(1 + \\frac{2p_{0}}{N - 3}\\right)^{-(N - 3)/2}\\] As explained by [SS10], «the term \"false-alarm probability denotes the probability that at least one out of  $M$  independent power values in a prescribed search band of a power spectrum computed from a white-noise time series is expected to be as large as or larger than a given value».  LombScargle.jl  provides the  fap  function to calculate the false-alarm probability (FAP) of a given power in a periodogram. Its first argument is the periodogram, the second one is the value  $p_{0}$  of the power of which you want to calculate the FAP. The function  fap  uses the formula \\[\\text{FAP} = 1 - (1 - \\text{Prob}(p > p_{0}))^M\\] where  $M$  is the number of independent frequencies estimated with  $M = T \\cdot \\Delta f$ , being  $T$  the duration of the observations and  $\\Delta f$  the width of the frequency range in which the periodogram has been calculated (see [CUM04]). The function  fapinv  is the inverse of  fap : it takes as second argument the value of the FAP and returns the corresponding value  $p_{0}$  of the power. The detection threshold  $p_{0}$  is the periodogram power corresponding to some (small) value of  $\\text{FAP}$ , i.e. the value of  $p$  exceeded due to noise alone in only a small fraction  $\\text{FAP}$  of trials. An observed power larger than  $p_{0}$  indicates that a signal is likely present (see [CUM04]). Warning Some authors stressed that this method to calculate the false-alarm probability is not completely reliable. A different approach to calculate the false-alarm probability is to perform Monte Carlo or bootstrap simulations in order to determine how often a certain power level  $p_{0}$  is exceeded just by chance (see [CMB99], [CUM04], and [ZK09]). See the  Bootstrapping  section."},{"id":1495,"pagetitle":"LombScargle.jl","title":"Bootstrapping","ref":"/LombScargle/stable/#Bootstrapping","content":" Bootstrapping One of the possible and simplest statistical methods that you can use to measure the false-alarm probability and its inverse is  bootstrapping  (see section 4.2.2 of [MHC93]). Note We emphasize that you can use this method only if you know your data points are  independent and identically distributed , and they have  white uncorrelated noise . The recipe of the bootstrap method is very simple to implement: repeat the Lomb–Scargle analysis a large number  $N$  of times on the original data, but with the signal (and errors, if present) vector randomly shuffled. As an alternative, shuffle only the time vector; out of all these simulations, store the powers of the highest peaks; in order to estimate the false-alarm probability of a given power, count how many times the highest peak of the simulations exceeds that power, as a fraction of  $N$ . If you instead want to find the inverse of the false-alarm probability  $\\text{prob}$ , looks for the  $N\\cdot\\text{prob}$ -th element of the highest peaks vector sorted in descending order. Remember to pass to  lombscargle  function the same options, if any, you used to compute the Lomb–Scargle periodogram before. LombScargle.jl  provides simple methods to perform such analysis. The  LombScargle.bootstrap  function allows you to create a bootstrap sample with  N  permutations of the original data."},{"id":1496,"pagetitle":"LombScargle.jl","title":"LombScargle.bootstrap","ref":"/LombScargle/stable/#LombScargle.bootstrap","content":" LombScargle.bootstrap  —  Function LombScargle.bootstrap(N::Integer,\n                      times::AbstractVector{Real},\n                      signal::AbstractVector{Real},\n                      errors::AbstractVector{Real}=ones(signal); ...) Create  N  bootstrap samples, perform the Lomb–Scargle analysis on them, and store all the highest peaks for each one in a  LombScargle.Bootstrap  object. All the arguments after  N  are passed around to  lombscargle . source LombScargle.bootstrap(N::Integer, plan::PeriodogramPlan) Create  N  bootstrap samples, perform the Lomb–Scargle analysis on them for the given  plan , and store all the highest peaks for each one in a  LombScargle.Bootstrap  object. See documentation of  LombScargle.plan  for how to plan a Lomb–Scargle periodogram. source The false-alarm probability and its inverse can be calculated with  fap  and  fapinv  functions respectively.  Their syntax is the same as the methods introduced above, but with a  LombScargle.Bootstrap  object as first argument, instead of the  LombScargle.Periodogram  one."},{"id":1497,"pagetitle":"LombScargle.jl","title":"LombScargle.fap","ref":"/LombScargle/stable/#LombScargle.fap-Tuple{LombScargle.Bootstrap{var\"#s1\"} where var\"#s1\"<:AbstractFloat, Real}","content":" LombScargle.fap  —  Method fap(b::Bootstrap, power::Real) Return the false-alarm probability for  power  in the bootstrap sample  b . Its inverse is the  fapinv  function. source"},{"id":1498,"pagetitle":"LombScargle.jl","title":"LombScargle.fapinv","ref":"/LombScargle/stable/#LombScargle.fapinv-Tuple{LombScargle.Bootstrap{var\"#s1\"} where var\"#s1\"<:AbstractFloat, Real}","content":" LombScargle.fapinv  —  Method fapinv(b::Bootstrap, prob::Real) Return the power value whose false-alarm probability is  prob  in the bootstrap sample  b . It returns  NaN  if the requested probability is too low and the power cannot be determined with the bootstrap sample  b .  In this case, you should enlarge your bootstrap sample so that  N*fap  can be rounded to an integer larger than or equal to 1. This is the inverse of  fap  function. source"},{"id":1499,"pagetitle":"LombScargle.jl","title":"LombScargle.model Function","ref":"/LombScargle/stable/#LombScargle.model-Function","content":" LombScargle.model  Function For each frequency  $f$  (and hence for the corresponding angular frequency  $\\omega = 2\\pi f$ ) the Lomb–Scargle algorithm looks for the sinusoidal function of the type \\[a_f\\cos(\\omega t) + b_f\\sin(\\omega t) + c_f\\] that best fits the data. In the original Lomb–Scargle algorithm the offset  $c$  is null (see [LOM76]). In order to find the best-fitting coefficients  $a_f$ ,  $b_f$ , and  $c_f$  for the given frequency  $f$ , without actually performing the periodogram, you can solve the linear system  $\\mathbf{A}x = \\mathbf{y}$ , where  $\\mathbf{A}$  is the matrix \\[\\begin{aligned}\n\\begin{bmatrix}\n  \\cos(\\omega t) & \\sin(\\omega t) & 1\n\\end{bmatrix} =\n\\begin{bmatrix}\n  \\cos(\\omega t_{1}) & \\sin(\\omega t_{1}) & 1      \\\\\n  \\vdots             & \\vdots             & \\vdots \\\\\n  \\cos(\\omega t_{n}) & \\sin(\\omega t_{n}) & 1\n\\end{bmatrix}\n\\end{aligned}\\] $t = [t_1, \\dots, t_n]^\\text{T}$  is the column vector of observation times,  $x$  is the column vector with the unknown coefficients \\[\\begin{aligned}\n\\begin{bmatrix}\n  a_f \\\\\n  b_f \\\\\n  c_f\n\\end{bmatrix}\n\\end{aligned}\\] and  $\\textbf{y}$  is the column vector of the signal. The solution of the matrix gives the wanted coefficients. This is what the  LombScargle.model  function does in order to return the best fitting Lomb–Scargle model for the given signal at the given frequency."},{"id":1500,"pagetitle":"LombScargle.jl","title":"LombScargle.model","ref":"/LombScargle/stable/#LombScargle.model","content":" LombScargle.model  —  Function LombScargle.model(times::AbstractVector{Real},\n                  signal::AbstractVector{R2},\n                  [errors::AbstractVector{R3},]\n                  frequency::Real,\n                  [times_fit::AbstractVector{R4}];\n                  center_data::Bool=true,\n                  fit_mean::Bool=true) Return the best fitting Lomb–Scargle model for the given signal at the given frequency. Mandatory arguments are: times : the observation times signal : the signal, sampled at  times  (must have the same length as  times ) frequency : the frequency at which to calculate the model Optional arguments are: errors : the vector of uncertainties of the signal.  If provided, it must have the same length as  signal  and  times , and be the third argument.  Like for  lombscargle , if the signal has uncertainties, the  signal  vector can also be a vector of  Measurement  objects, and this argument should be omitted times_fit : the vector of times at which the model will be calculated.  It defaults to  times .  If provided, it must come after  frequency Optional keyword arguments  center_data  and  fit_mean  have the same meaning as in  lombscargle : fit_mean : whether to fit for the mean. If this is  false , like in the original Lomb–Scargle periodogram,  $\\mathbf{A}$  does not have the third column of ones,  $c_f$  is set to  $0$  and the unknown vector to be determined becomes  $x = [a_f, b_f]^\\text{T}$ center_data : whether the data should be pre-centered before solving the linear system. This is particularly important if  fit_mean=false source"},{"id":1501,"pagetitle":"LombScargle.jl","title":"Examples","ref":"/LombScargle/stable/#Examples","content":" Examples Here is an example of a noisy periodic signal ( $\\sin(\\pi t) + 1.5\\cos(2\\pi t)$ ) sampled at unevenly spaced times. julia> using LombScargle\n\njulia> ntimes = 1001\n1001\n\njulia> t = range(0.01, stop = 10pi, length = ntimes) # Observation times\n0.01:0.03140592653589793:31.41592653589793\n\njulia> t += step(t)*rand(ntimes) # Randomize times\n\njulia> s = sinpi.(t) .+ 1.5cospi.(2t) .+ rand(ntimes) # The signal\n\njulia> plan = LombScargle.plan(t, s); # Pre-plan the periodogram\n\njulia> pgram = lombscargle(plan) # Compute the periodogram\nLombScargle.Periodogram{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}},Array{Float64,1}}([0.000472346, 0.000461633, 0.000440906, 0.000412717, 0.000383552, 0.000355828, 0.000289723, 0.000154585, 3.44734e-5, 5.94437e-7  …  3.15125e-5, 0.000487391, 0.0018939, 0.00367003, 0.00484181, 0.00495189, 0.00453233, 0.00480968, 0.00619657, 0.0074052], 0.003185690706734265:0.00637138141346853:79.72190993602499, [0.0295785, 0.0540516, 0.0780093, 0.122759, 0.15685, 0.192366, 0.206601, 0.252829, 0.265771, 0.315443  …  31.1512, 31.1758, 31.2195, 31.2342, 31.2752, 31.293, 31.3517, 31.3761, 31.4148, 31.4199], :standard) You can plot the result, for example with  Plots  package. Use  freqpower  function to get the frequency grid and the power of the periodogram as a 2-tuple. using Plots\nplot(freqpower(pgram)...) You can also plot the power vs the period, instead of the frequency, with  periodpower : using Plots\nplot(periodpower(pgram)...) Warning If you do not fit for the mean of the signal ( fit_mean=false  keyword to  lombscargle  function) without centering the data ( center_data=false ) you can get inaccurate results. For example, spurious peaks at low frequencies can appear and the real peaks lose power: plot(freqpower(lombscargle(t, s, fit_mean=false, center_data=false))...) Tip You can tune the frequency grid with appropriate keywords to  lombscargle  function. For example, in order to increase the sampling increase  samples_per_peak , and set  maximum_frequency  to lower values in order to narrow the frequency range: plot(freqpower(lombscargle(t, s, samples_per_peak=20, maximum_frequency=1.5))...) If you simply want to use your own frequency grid, directly set the  frequencies  keyword: plot(freqpower(lombscargle(t, s, frequencies=0.001:1e-3:1.5))...)"},{"id":1502,"pagetitle":"LombScargle.jl","title":"Signal with Uncertainties","ref":"/LombScargle/stable/#Signal-with-Uncertainties","content":" Signal with Uncertainties The generalised Lomb–Scargle periodogram is able to handle a signal with uncertainties, and they will be used as weights in the algorithm.  The uncertainties can be passed either as the third optional argument  errors  to  lombscargle  or by providing this function with a  signal  vector of type  Measurement  (from  Measurements.jl  package). using Measurements, Plots\nntimes = 1001\nt = range(0.01, stop = 10pi, length = ntimes)\ns = sinpi.(2t)\nerrors = rand(0.1:1e-3:4.0, ntimes)\n# Run one of the two following equivalent commands\nplot(freqpower(lombscargle(t, s, errors, maximum_frequency=1.5))...)\nplot(freqpower(lombscargle(t, measurement(s, errors), maximum_frequency=1.5))...) This is the plot of the power versus the period: # Run one of the two following equivalent commands\nplot(periodpower(lombscargle(t, s, errors, maximum_frequency=1.5))...)\nplot(periodpower(lombscargle(t, measurement(s, errors), maximum_frequency=1.5))...) We recall that the generalised Lomb–Scargle algorithm is used when the  fit_mean  optional keyword to  lombscargle  is  true  if no error is provided, instead it is always used if the signal has uncertainties."},{"id":1503,"pagetitle":"LombScargle.jl","title":"Find Highest Power and Associated Frequencies and Periods","ref":"/LombScargle/stable/#Find-Highest-Power-and-Associated-Frequencies-and-Periods","content":" Find Highest Power and Associated Frequencies and Periods findmaxfreq  function tells you the frequencies with the highest power in the periodogram (and you can get the period by taking its inverse): julia> t = range(0, stop = 10, length = 1001);\n\njulia> s = sinpi.(t);\n\njulia> plan = LombScargle.plan(t, s); # Plan the periodogram\n\njulia> p = lombscargle(plan);\n\njulia> findmaxperiod(p) # Period with highest power\n1-element Array{Float64,1}:\n 0.004987779939149084\n\njulia> findmaxfreq(p) # Frequency with the highest power\n1-element Array{Float64,1}:\n 200.49 This peak is at high frequencies, very far from the expected value of the period of 2. In order to find the real peak, you can either narrow the ranges in order to exclude higher armonics julia> findmaxperiod(p, [1, 10]) # Limit the search to periods in [1, 10]\n1-element Array{Float64,1}:\n 2.04082\n\njulia> findmaxfreq(p, [0.1, 1]) # Limit the search to frequencies in [0.1, 1]\n1-element Array{Float64,1}:\n 0.49 or pass the  threshold  argument to  findmaxfreq  or  findmaxperiod . You can use  findmaxpower  to discover the highest power in the periodogram: julia> findmaxpower(p)\n0.9958310178312316\n\njulia> findmaxperiod(p, 0.95)\n10-element Array{Float64,1}:\n 2.04082\n 1.96078\n 0.0100513\n 0.0100492\n 0.00995124\n 0.00994926\n 0.00501278\n 0.00501228\n 0.00498778\n 0.00498728\n\njulia> findmaxfreq(p, 0.95)\n10-element Array{Float64,1}:\n   0.49\n   0.51\n  99.49\n  99.51\n 100.49\n 100.51\n 199.49\n 199.51\n 200.49\n 200.51 The first peak is the real one, the other double peaks appear at higher armonics. Tip Usually, plotting the periodogram can give you a clue of what's going on."},{"id":1504,"pagetitle":"LombScargle.jl","title":"Significance of the Peaks","ref":"/LombScargle/stable/#Significance-of-the-Peaks","content":" Significance of the Peaks The significance of the peaks in the Lomb–Scargle periodogram can be assessed by measuring the  False-Alarm Probability . Analytic expressions of this quantity and its inverse can be obtained with the  fap  and  fapinv  functions, respectively. julia> t = linspace(0.01, 20, samples_per_peak = 10)\n\njulia> s = sinpi.(e.*t).^2 .- cos.(5t).^4\n\njulia> plan = LombScargle.plan(t, s);\n\njulia> p = lombscargle(plan)\n\n# Find the false-alarm probability for the highest peak.\njulia> fap(p, 0.3)\n0.028198095962262748 Thus, a peak with power  $0.3$  has a probability of  $0.028$  that it is due to noise only. A quantity that is often used is the inverse of the false-alarm probability as well: what is the minimum power whose false-alarm probability is lower than the given probability? For example, if you want to know the minimum power for which the false-alarm probability is at most  $0.01$  you can use: julia> fapinv(p, 0.01)\n0.3304696923786712 As we already noted, analytic expressions of the false-alarm probability and its inverse may not be reliable if your data does not satisfy specific assumptions. A better way to calculate this quantity is to use statistical methods. One of this is bootstrapping. In  LombScargle.jl , you can use the function  LombScargle.bootstrap  to create a bootstrap sample and then you can calculate the false-alarm probability and its inverse using this sample. Tip When applying the bootstrap method you should use the same options you used to perform the periodogram on your data. Using the same periodogram plan you used to compute the periodogram will ensure that you use the same options. However, note that the fast method gives approximate results that for some frequencies may not be reliable (they can go outside the range  $[0, 1]$  for the standard normalization). More robust results can be obtained with the  fast = false  option. # Create a bootstrap sample with 10000\n# resamplings of the original data, re-using the\n# same periodogram plan.  The larger the better.\n# This may take some minutes.\njulia> b = LombScargle.bootstrap(10000, plan)\n\n# Calculate the false-alarm probability of a peak\n# with power 0.3 using this bootstrap sample.\njulia> fap(b, 0.3)\n0.0209\n\n# Calculate the lowest power that has probability\n# less than 0.01 in this bootstrap sample.\njulia> fapinv(b, 0.01)\n0.3268290388848437 If you query  fapinv  with a too low probability, the corresponding power cannot be determined and you will get  NaN  as result. julia> fapinv(b, 1e-5)\nNaN If you want to find the power corresponding to a false-alarm probability of  $\\text{prob} = 10^{-5}$ , you have to create a new bootstrap sample with  $N$  resamplings so that  $N\\cdot\\text{prob}$  can be rounded to an integer larger than or equal to one (for example  $N = 10^{5}$ )."},{"id":1505,"pagetitle":"LombScargle.jl","title":"Find the Best-Fitting Model","ref":"/LombScargle/stable/#Find-the-Best-Fitting-Model","content":" Find the Best-Fitting Model The  LombScargle.model  function can help you to test whether a certain frequency fits well your data. using Plots\nt = range(0.01, stop = 10pi, length = 1000) # Observation times\ns = sinpi.(t) .+ 1.2cospi.(t) .+ 0.3rand(length(t)) # The noisy signal\n# Pick-up the best frequency\nf = findmaxfreq(lombscargle(t, s, maximum_frequency=10, samples_per_peak=20))[1]\nt_fit = range(0, stop = 1, length = 50)\ns_fit = LombScargle.model(t, s, f, t_fit/f) # Determine the model\nscatter(mod.(t.*f, 1), s, lab=\"Phased data\", title=\"Best Lomb-Scargle frequency: $f\")\nplot!(t_fit, s_fit, lab=\"Best-fitting model\", linewidth=4) Tip If there are more than one dominant frequency you may need to consider more models. This task may require some work and patience. Plot the periodogram in order to find the best frequencies. using Plots\nt = range(0.01, stop = 5, length = 1000) # Observation times\ns = sinpi.(2t) .+ 1.2cospi.(4t) .+ 0.3rand(length(t)) # Noisy signal\nplan = LombScargle.plan(t, s, samples_per_peak=50)\np = lombscargle(plan)\n# After plotting the periodogram, you discover\n# that it has two prominent peaks around 1 and 2.\nf1 = findmaxfreq(p, [0.8, 1.2])[1] # Get peak frequency around 1\nf2 = findmaxfreq(p, [1.8, 2.2])[1] # Get peak frequency around 2\nfit1 = LombScargle.model(t, s, f1) # Determine the first model\nfit2 = LombScargle.model(t, s, f2) # Determine the second model\nscatter(t, s, lab=\"Data\", title=\"Best-fitting Lomb-Scargle model\")\nplot!(t, fit1 + fit2, lab=\"Best-fitting model\", linewidth=4)"},{"id":1506,"pagetitle":"LombScargle.jl","title":"Performance","ref":"/LombScargle/stable/#Performance","content":" Performance A pre-planned periodogram in  LombScargle.jl  computed in single thread mode with the fast method is more than 2 times faster than the implementation of the same algorithm provided by AstroPy, and more than 4 times faster if 4 FFTW threads are used (on machines with at least 4 physical CPUs). The following plot shows a comparison between the times needed to compute a periodogram for a signal with N datapoints using  LombScargle.jl , with 1 or 4 FFTW threads (with  flags = FFTW.MEASURE  for better performance), and the single-threaded Astropy implementation.  (Julia version: 1.6.0;  LombScargle.jl  version: 1.0.0; Python version: 3.8.6; Astropy version: 4.1.  CPU: Intel(R) Core(TM) i7-4870HQ CPU @ 2.50GHz.) Note that this comparison is unfair, as Astropy doesn’t support pre-planning a periodogram nor multi-threading, and it pads vectors for FFT to a length which is a power of 2, while by default  LombScargle.jl  uses length which are multiples of 2, 3, 5, 7.  A non-planned periodogram in single thread mode in  LombScargle.jl  is still twice as fast as Astropy."},{"id":1507,"pagetitle":"LombScargle.jl","title":"Development","ref":"/LombScargle/stable/#Development","content":" Development The package is developed at  https://github.com/JuliaAstro/LombScargle.jl . There you can submit bug reports, make suggestions, and propose pull requests."},{"id":1508,"pagetitle":"LombScargle.jl","title":"History","ref":"/LombScargle/stable/#History","content":" History The ChangeLog of the package is available in  NEWS.md  file in top directory."},{"id":1509,"pagetitle":"LombScargle.jl","title":"License","ref":"/LombScargle/stable/#License","content":" License The  LombScargle.jl  package is licensed under the BSD 3-clause \"New\" or \"Revised\" License. The original author is Mosè Giordano."},{"id":1510,"pagetitle":"LombScargle.jl","title":"Acknowledgements","ref":"/LombScargle/stable/#Acknowledgements","content":" Acknowledgements This package adapts the implementation in Astropy of the the fast Lomb–Scargle method by [PR89]. We claim no endorsement nor promotion by the Astropy Team."},{"id":1515,"pagetitle":"Home","title":"BoxLeastSquares.jl","ref":"/BoxLeastSquares/stable/#BoxLeastSquares.jl","content":" BoxLeastSquares.jl"},{"id":1516,"pagetitle":"Home","title":"Installation","ref":"/BoxLeastSquares/stable/#Installation","content":" Installation To install use  Pkg . From the REPL, press  ]  to enter Pkg-mode pkg> add BoxLeastSquares If you want to use the most up-to-date version of the code, check it out from  main pkg> add BoxLeastSquares#main"},{"id":1517,"pagetitle":"Home","title":"Usage","ref":"/BoxLeastSquares/stable/#Usage","content":" Usage First, import the package julia> using BoxLeastSquares you can optionally alias the package name, too julia> import BoxLeastSquares as BLS now, load some data. If you don't have an estimate of the y error it will default to 1. julia> t, y, yerr = load_data(); # load data somehow The primary interface is through the  BLS  method julia> result = BLS(t, y, yerr; duration=0.16)\nBLSPeriodogram\n==============\ninput dim: 1000\noutput dim: 1820\nperiod range: 0.32 - 5.014724142709022\nduration range: 0.16 - 0.16\nobjective: likelihood\n\nparameters\n----------\nindex: 1633\nperiod: 1.99930396919953\nduration: 0.16\nt0: 0.5001330656464655\ndepth: 0.19594118110109113 ± 0.0008688097746093883\nsnr: 225.52828804117118\nlog-likelihood: 27396.365214805144 to extract the parameters in a convenient named tuple use  BoxLeastSquares.params julia> BoxLeastSquares.params(result)\n(index = 1633, power = 27396.365214805144, period = 1.99930396919953, duration = 0.16, t0 = 0.5001330656464655, depth = 0.19594118110109113, depth_err = 0.0008688097746093883, snr = 225.52828804117118, loglike = 27396.365214805144) The period grid was automatically determined using  autoperiod , but you can supply your own, too: julia> periods = exp.(range(log(2) - 0.1, log(2) + 0.1, length=1000));\n\njulia> result_fine = BLS(t, y, yerr; duration=0.12:0.01:0.20, periods=periods)\nBLSPeriodogram\n==============\ninput dim: 1000\noutput dim: 1000\nperiod range: 1.809674836071919 - 2.210341836151295\nduration range: 0.12 - 0.2\nobjective: likelihood\n\nparameters\n----------\nindex: 503\nperiod: 2.001001251543549\nduration: 0.168\nt0: 0.4961330656464656\ndepth: 0.19466955969052016 ± 0.0008627202098527317\nsnr: 225.64622628204188\nlog-likelihood: 27457.6383039924"},{"id":1518,"pagetitle":"Home","title":"Unitful.jl","ref":"/BoxLeastSquares/stable/#Unitful.jl","content":" Unitful.jl BoxLeastSquares.jl is fully compatible with  Unitful.jl  (although it is not a dependency of the library). For example julia> using Unitful\n\njulia> tu = t * u\"d\";\n\njulia> results_units = BLS(tu, y, yerr; duration=(2:0.1:4)u\"hr\")\nBLSPeriodogram\n==============\ninput dim: 1000\noutput dim: 3343\nperiod range: 0.3333333333333333 d - 4.988348864592586 d\nduration range: 2.0 hr - 4.0 hr\nobjective: likelihood\n\nparameters\n----------\nindex: 2986\nperiod: 2.0019235780121827 d\nduration: 3.8000000000000003 hr\nt0: 0.4916330656464656 d\ndepth: 0.19445716575012517 ± 0.0008692454825826517\nsnr: 223.70799693127577\nlog-likelihood: 26953.643422397385"},{"id":1519,"pagetitle":"Home","title":"Plotting","ref":"/BoxLeastSquares/stable/#Plotting","content":" Plotting BoxLeastSquares.BLSPeriodogram  has plotting shorthands built right in- by default it will plot the period grid and the computed power using Plots, UnitfulRecipes\n\nplot(results_units, label=\"\") now let's look at how the transit model compares to the data pars = BoxLeastSquares.params(results_units)\nwrap = 0.5 * pars.period\nphases = @. (mod(t - pars.t0 + wrap, pars.period) - wrap) / pars.period\ninds = sortperm(phases)\nmodel = BoxLeastSquares.model(results_units)\n\nscatter(phases[inds], y[inds], yerr=yerr[inds],\n    label=\"data\", xlabel=\"phase\", xlim=(-0.2, 0.2), leg=:bottomright)\nplot!(phases[inds], model[inds], lw=3, label=\"BLS model\")"},{"id":1520,"pagetitle":"Home","title":"Performance","ref":"/BoxLeastSquares/stable/#Performance","content":" Performance This code has been benchmarked against the C implementation in  astropy.timeseries.bls . The C version uses OpenMP to multi-thread some parts of the core BLS algorithm, but BoxLeastSquares.jl has no threading support currently. For a fair comparison, we set  OMP_NUM_THREADS  to 1 for the following tests. This first benchmark is simply the time it takes to evaluate the BLS periodogram. Periods are pre-computed using  autoperiod . We simulate different sizes of data sets (x-axis) as well as different sizes of period grids (shape). This benchmark does not use units. The code can be found in  bench/benchmark.jl . Here is the information for my system- Julia Version 1.6.0\nCommit f9720dc2eb* (2021-03-24 12:55 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin20.3.0)\n  CPU: Intel(R) Core(TM) i5-8259U CPU @ 2.30GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, skylake)\nEnvironment:\n  OMP_NUM_THREADS = 1\n  JULIA_NUM_THREADS = 1"},{"id":1521,"pagetitle":"Home","title":"Contributing and Support","ref":"/BoxLeastSquares/stable/#Contributing-and-Support","content":" Contributing and Support If you would like to contribute, feel free to open a  pull request . If you want to discuss something before contributing, head over to  discussions  and join or open a new topic. If you're having problems with something, open an  issue ."},{"id":1524,"pagetitle":"API/Reference","title":"API/Reference","ref":"/BoxLeastSquares/stable/api/#API/Reference","content":" API/Reference BoxLeastSquares.BLSPeriodogram BoxLeastSquares.BLS BoxLeastSquares.autoperiod BoxLeastSquares.model BoxLeastSquares.model BoxLeastSquares.params BoxLeastSquares.periods BoxLeastSquares.power"},{"id":1525,"pagetitle":"API/Reference","title":"BoxLeastSquares.BLSPeriodogram","ref":"/BoxLeastSquares/stable/api/#BoxLeastSquares.BLSPeriodogram","content":" BoxLeastSquares.BLSPeriodogram  —  Type BLSPeriodogram A convenient wrapper for outputs from  BLS . Methods BoxLeastSquares.params BoxLeastSquares.power BoxLeastSquares.periods Attributes t  - input time grid y  - input data yerr  - input data uncertainty periods  - the input periods duration_in  - the input durations objective  - the objective that was maximized power  - the power calculated at each period duration  - the best duration at each period t0  - the best transit time at each period depth  - the best transit depth at each period snr  - the signal-to-noise ratio at each period loglike  - the log-likeilhood at each period Plotting Plotting recipes are provided for  BLSPeriodogram  which automatically plots the period and the power source"},{"id":1526,"pagetitle":"API/Reference","title":"BoxLeastSquares.BLS","ref":"/BoxLeastSquares/stable/api/#BoxLeastSquares.BLS","content":" BoxLeastSquares.BLS  —  Function BLS(t, y, [yerr];\n    duration, periods=autoperiod(t, duration, kwargs...), \n    objective=:likelihood, oversample=10, kwargs...) Compute the box-least-squares periodogram. Parameters t  - the time for each observation. Units are irrelevant, except that they must be consistent for all temporal parameters (e.g.,  duration ).  Unitful.jl  units work seamlessly without needing to convert. y  - the flux value for each observation yerr , optional - the uncertainty for each observation, if not provided, will default to ones duration  - The duration or durations to consider. Same units as  t periods , optional - The period grid to computer the BLS power over. If not provided,  autoperiod  will be called along with any extra keyword arguments (like  minimum_period ) objective , optional - Choose between maximizing the likeilhood ( :likeilhood , default) or the signal-to-noise ratio ( :snr ). oversample , optional - The number of bins per duration that should be used. Larger values of  oversample  will lead to a finer grid. The returned values are wrapped into a convenience type  BoxLeastSquares.BLSPeriodogram source"},{"id":1527,"pagetitle":"API/Reference","title":"BoxLeastSquares.autoperiod","ref":"/BoxLeastSquares/stable/api/#BoxLeastSquares.autoperiod-Union{Tuple{T}, Tuple{AbstractVector{T}, Any}} where T","content":" BoxLeastSquares.autoperiod  —  Method autoperiod(t, duration;\n    minimum_n_transit=3, frequency_factor=1.0,\n    [minimum_period, maximum_period]) Automatically determine a period grid from the given times and duration(s). Periods are selected such that at least  minimum_n_trasnit  transits occur. The default minimum period is twice the maximum duration. The default maximum period is  (maximum(t) - minimum(t)) / (minimum_n_transit - 1) . The frequency factor changes the granularity in frequency space- a smaller frequency factor will create a finer period grid. source"},{"id":1528,"pagetitle":"API/Reference","title":"BoxLeastSquares.model","ref":"/BoxLeastSquares/stable/api/#BoxLeastSquares.model","content":" BoxLeastSquares.model  —  Function BoxLeastSquares.model(t, y, [yerr]; period, duration, t0) Evaluate the transit model on the given time grid. If  yerr  is not provided, it will default to 1. The following transit parameters must be set: period  orbital period in the same units as  t duration  the transit duration in the same units as  t t0  the transit time (middle of transit) in the same units as  t If you are using  Unitful.jl , the unit conversions will be made automatically. source"},{"id":1529,"pagetitle":"API/Reference","title":"BoxLeastSquares.model","ref":"/BoxLeastSquares/stable/api/#BoxLeastSquares.model-Tuple{BoxLeastSquares.BLSPeriodogram}","content":" BoxLeastSquares.model  —  Method BoxLeastSquares.model(::BLSPeriodogram; kwargs...) Create a transit model using the data and best-fitting parameters from the given BLS periodogram. Any keyword parameters can be overriden. source"},{"id":1530,"pagetitle":"API/Reference","title":"BoxLeastSquares.params","ref":"/BoxLeastSquares/stable/api/#BoxLeastSquares.params-Tuple{BoxLeastSquares.BLSPeriodogram}","content":" BoxLeastSquares.params  —  Method BoxLeastSquares.params(::BLSPeriodogram) Return the transit parameters for the best fitting period. Returns period, duration, t0, and power as well as the index of the max-power period. source"},{"id":1531,"pagetitle":"API/Reference","title":"BoxLeastSquares.periods","ref":"/BoxLeastSquares/stable/api/#BoxLeastSquares.periods-Tuple{BoxLeastSquares.BLSPeriodogram}","content":" BoxLeastSquares.periods  —  Method BoxLeastSquares.periods(::BLSPeriodogram) Return the period grid for the periodogram source"},{"id":1532,"pagetitle":"API/Reference","title":"BoxLeastSquares.power","ref":"/BoxLeastSquares/stable/api/#BoxLeastSquares.power-Tuple{BoxLeastSquares.BLSPeriodogram}","content":" BoxLeastSquares.power  —  Method BoxLeastSquares.power(::BLSPeriodogram) Return the power calculated for each period for the periodogram source"},{"id":1537,"pagetitle":"Introduction","title":"AstroLib.jl","ref":"/AstroLib/stable/#AstroLib.jl","content":" AstroLib.jl AstroLib  is a package of small generic routines useful above all in astronomical and astrophysical context, written in  Julia . Included are also translations of some  IDL Astronomy User’s Library  procedures, which are released under terms of  BSD-2-Clause License . AstroLib’s functions are not drop-in replacement of those procedures, Julia standard data types are often used (e.g.,  DateTime  type instead of generic string for dates) and the syntax may slightly differ. An extensive error testing suite ensures old fixed bugs will not be brought back by future changes."},{"id":1538,"pagetitle":"Introduction","title":"Installation","ref":"/AstroLib/stable/#Installation","content":" Installation AstroLib is available for Julia 1.0 and later versions, and can be installed with  Julia 's built-in package manager. In a Julia session run the commands julia> import Pkg\njulia> Pkg.update()\njulia> Pkg.add(\"AstroLib\") Older versions are also available for Julia 0.4-0.6. Note that, in order to work, a few functions require external files, which are automatically downloaded when building the package. Should these files be missing for some reason, you will be able to load the package but some functions may not work properly. You can manually build the package with julia> Pkg.build(\"AstroLib\")"},{"id":1539,"pagetitle":"Introduction","title":"Usage","ref":"/AstroLib/stable/#Usage","content":" Usage After installing the package, you can start using AstroLib with using AstroLib Many functions in  AstroLib.jl  are compatible with  Measurements.jl  package, which allows you to define quantities with uncertainty and propagate the error when performing calculations according to  propagation of uncertainty rules . For example: julia> using AstroLib, Measurements\n\njulia> mag2flux(12.54 ± 0.03)\n3.499e-14 ± 9.7e-16"},{"id":1540,"pagetitle":"Introduction","title":"How Can I Help?","ref":"/AstroLib/stable/#How-Can-I-Help?","content":" How Can I Help? AstroLib.jl  is developed on  GitHub . You can contribute to the project in a number of ways: by translating more routines from IDL Astronomy User’s Library, or providing brand-new functions, or even improving existing ones (make them faster and more precise). Also bug reports are encouraged."},{"id":1541,"pagetitle":"Introduction","title":"License","ref":"/AstroLib/stable/#License","content":" License The  AstroLib.jl  package is licensed under the MIT “Expat” License. The original author is Mosè Giordano."},{"id":1542,"pagetitle":"Introduction","title":"Notes","ref":"/AstroLib/stable/#Notes","content":" Notes This project is a work-in-progress, only few procedures have been translated so far. In addition, function syntax may change from time to time. Check  TODO.md  out to see how you can help. Volunteers are welcome!"},{"id":1543,"pagetitle":"Introduction","title":"Documentation","ref":"/AstroLib/stable/#Documentation","content":" Documentation Every function provided has detailed documentation that can be  accessed  at Julia REPL with julia> ?FunctionName or with julia> @doc FunctionName"},{"id":1544,"pagetitle":"Introduction","title":"Related Projects","ref":"/AstroLib/stable/#Related-Projects","content":" Related Projects This is not the only effort to bundle astronomical functions written in Julia language. Other packages useful for more specific purposes are available at  JuliaAstro . Because of this, some of IDL AstroLib’s utilities are not provided in  AstroLib.jl  as they are already present in other Julia packages. Here is a list of such utilities: aper , see  Photometry.jl  package asinh , already present in Julia with the same name cirrange , it is equivalent to  mod(x, 360) .  To restrict a number to the   range  [0, 2pi)  use  mod2pi(x) cosmo_param , see  Cosmology.jl  package galage , see  Cosmology.jl  package glactc_pm , see  SkyCoords.jl  package glactc , see  SkyCoords.jl  package jplephinterp , see  JPLEphemeris.jl  package jplephread , see  JPLEphemeris.jl  package jplephtest , see  JPLEphemeris.jl  package lumdist , see  Cosmology.jl  package readcol , use  readdlm , part of Julia  Base.DataFmt  module. This is not a complete replacement for  readcol  but most of the time it does-the-right-thing even without using any option (it automatically identifies string and numerical columns) and you do not need to manually specify a variable for each column In addition, there are similar projects for Python ( Python AstroLib ) and R ( Astronomy Users Library )."},{"id":1547,"pagetitle":"Reference","title":"Reference","ref":"/AstroLib/stable/ref/#Reference","content":" Reference"},{"id":1548,"pagetitle":"Reference","title":"Data types","ref":"/AstroLib/stable/ref/#Data-types","content":" Data types"},{"id":1549,"pagetitle":"Reference","title":"Observatory","ref":"/AstroLib/stable/ref/#Observatory","content":" Observatory AstroLib.jl  defines a new  Observatory  type. This can be used to define a new object holding information about an observing site. It is a  composite type  whose fields are name  ( String  type): the name of the site latitude  ( Float64  type): North-ward latitude of the site in degrees longitude  ( Float64  type): East-ward longitude of the site in degrees altitude  ( Float64  type): altitude of the site in meters tz  ( Float64  type): the number of hours of offset from UTC The type constructor  Observatory  can be used to create a new  Observatory  object. Its syntax is Observatory(name, lat, long, alt, tz) name  should be a string;  lat ,  long , and  tz  should be anything that can be converted to a floating number with  ten  function;  alt  should be a real number. A predefined list of some observing sites is provided with  AstroLib.observatories  constant. It is a dictionary whose keys are the abbreviated names of the observatories. For example, you can access information of the European Southern Observatory with julia> obs = AstroLib.observatories[\"eso\"]\nObservatory: European Southern Observatory\nlatitude:    -29.256666666666668°N\nlongitude:   -70.73°E\naltitude:    2347.0 m\ntime zone:   UTC-4\n\njulia> obs.longitude\n-70.73 You can list all keys of the dictionary with keys(AstroLib.observatories) Feel free to contribute new sites or adjust information of already present ones."},{"id":1550,"pagetitle":"Reference","title":"Planet","ref":"/AstroLib/stable/ref/#Planet","content":" Planet The package provides  Planet  type to hold information about Solar System planets. Its fields are Designation: name : the name Physical characteristics: radius : mean radius in meters eqradius : equatorial radius in meters polradius : polar radius in meters mass : mass in kilogram Orbital characteristics (epoch J2000): ecc : eccentricity of the orbit axis : semi-major axis of the orbit in meters period : sidereal orbital period in seconds The constructor has this syntax: Planet(name, radius, eqradius, polradius, mass, ecc, axis, period) The list of Solar System planets, from Mercury to Pluto, is available with  AstroLib.planets  dictionary. The keys of this dictionary are the lowercase names of the planets. For example: julia> AstroLib.planets[\"mercury\"]\nPlanet:                      Mercury\nmean radius:                 2.4397e6 m\nequatorial radius:           2.4397e6 m\npolar radius:                2.4397e6 m\nmass:                        3.3011e23 kg\neccentricity:                0.20563593\nsemi-major axis:             5.790922654152439e10 m\nperiod:                      7.60053024e6 s\ninclination:                 7.00497902 °\nlongitude of ascending node: 48.33076593 °\nlongitude of perihelion:     77.45779628 °\nmean longitude:              252.2503235 °\n\njulia> AstroLib.planets[\"mars\"].eqradius\n3.3962e6\n\njulia> AstroLib.planets[\"saturn\"].mass\n5.6834e26"},{"id":1551,"pagetitle":"Reference","title":"Functions organized by category","ref":"/AstroLib/stable/ref/#Functions-organized-by-category","content":" Functions organized by category"},{"id":1552,"pagetitle":"Reference","title":"Coordinates and positions","ref":"/AstroLib/stable/ref/#Coordinates-and-positions","content":" Coordinates and positions adstring() aitoff() altaz2hadec() baryvel() bprecess() co_aberration() co_nutate() co_refract() eci2geo() eq2hor() eqpole() euler() gcirc() geo2eci() geo2geodetic() geo2mag() geodetic2geo() hadec2altaz() helio_rv() helio() hor2eq() jprecess() mag2geo() mean_obliquity() planet_coords() polrec() posang() precess() precess_cd() precess_xyz() premat() radec() recpol() true_obliquity() zenpos()"},{"id":1553,"pagetitle":"Reference","title":"Time and date","ref":"/AstroLib/stable/ref/#Time-and-date","content":" Time and date ct2lst() daycnv() get_date() get_juldate() helio_jd() jdcnv() juldate() month_cnv() nutate() ydn2md() ymd2dn()"},{"id":1554,"pagetitle":"Reference","title":"Moon and sun","ref":"/AstroLib/stable/ref/#Moon-and-sun","content":" Moon and sun moonpos() mphase() sunpos() xyz()"},{"id":1555,"pagetitle":"Reference","title":"Utilities","ref":"/AstroLib/stable/ref/#Utilities","content":" Utilities airtovac() calz_unred() deredd() flux2mag() gal_uvw() imf() ismeuv() kepler_solver() lsf_rotate() mag2flux() paczynski() planck_freq() planck_wave() rad2sec() rhotheta() sec2rad() sixty() sphdist() ten() tic_one() ticpos() tics() trueanom() uvbybeta() vactoair()"},{"id":1556,"pagetitle":"Reference","title":"Miscellaneous (non-astronomy) functions","ref":"/AstroLib/stable/ref/#Miscellaneous-(non-astronomy)-functions","content":" Miscellaneous (non-astronomy) functions ordinal()"},{"id":1557,"pagetitle":"Reference","title":"Types and functions organized alphabetically","ref":"/AstroLib/stable/ref/#Types-and-functions-organized-alphabetically","content":" Types and functions organized alphabetically"},{"id":1558,"pagetitle":"Reference","title":"AstroLib.POLELATLONG","ref":"/AstroLib/stable/ref/#AstroLib.POLELATLONG","content":" AstroLib.POLELATLONG  —  Constant List of locations of North Magnetic Pole since 1590. This is provided by World Magnetic Model (https://www.ngdc.noaa.gov/geomag/data/poles/NP.xy). source"},{"id":1559,"pagetitle":"Reference","title":"AstroLib.observatories","ref":"/AstroLib/stable/ref/#AstroLib.observatories","content":" AstroLib.observatories  —  Constant List of observing sites.  The observatories have  Observatory  type. source"},{"id":1560,"pagetitle":"Reference","title":"AstroLib.planets","ref":"/AstroLib/stable/ref/#AstroLib.planets","content":" AstroLib.planets  —  Constant List of planets of the Solar System, from Mercury to Pluto.  The elements of the list have  Planet  type. Reference for most quantities is the Planetary Fact Sheet: http://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html and the Keplerian Elements for Approximate Positions of the Major Planets: https://ssd.jpl.nasa.gov/txt/p elem t1.txt source"},{"id":1561,"pagetitle":"Reference","title":"AstroLib.Observatory","ref":"/AstroLib/stable/ref/#AstroLib.Observatory","content":" AstroLib.Observatory  —  Type Type holding information about an observing site.  Its fields are: name : the name of the site latitude : North-ward latitude of the site in degrees longitude : East-ward longitude of the site in degrees altitude : altitude of the site in meters tz : the number of hours of offset from UTC source"},{"id":1562,"pagetitle":"Reference","title":"AstroLib.Planet","ref":"/AstroLib/stable/ref/#AstroLib.Planet","content":" AstroLib.Planet  —  Type Type holding information about a planet.  Its fields are: Designation: name : the name Physical characteristics: radius : mean radius in meters eqradius : equatorial radius in meters polradius : polar radius in meters mass : mass in kilogram Orbital characteristics (epoch J2000): ecc : eccentricity of the orbit axis : semi-major axis of the orbit in meters period : sidereal orbital period in seconds Position characteristics (epoch J2000): inc : inclination in degrees asc_long : longitude of the ascending node in degrees per_long : longitude of perihelion in degrees mean_long : mean longitude in degrees source"},{"id":1563,"pagetitle":"Reference","title":"AstroLib.adstring","ref":"/AstroLib/stable/ref/#AstroLib.adstring-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractFloat","content":" AstroLib.adstring  —  Method adstring(ra::Real, dec::Real[, precision::Int=2, truncate::Bool=true]) -> string\nadstring([ra, dec]) -> string\nadstring(dec) -> string\nadstring([ra], [dec]) -> [\"string1\", \"string2\", ...] Purpose Returns right ascension and declination as string(s) in sexagesimal format. Explanation Takes right ascension and declination expressed in decimal format, converts them to sexagesimal and return a formatted string.  The precision of right ascension and declination can be specified. Arguments Arguments of this function are: ra : right ascension in decimal degrees.  It is converted to hours before printing. dec : declination in decimal degrees. The function can be called in different ways: Two numeric arguments: first is  ra , the second is  dec . An iterable (array, tuple) of two elements:  (ra, dec) . One numeric argument: it is assumed only  dec  is provided. Optional keywords affecting the output format are always available: precision  (optional integer keyword): specifies the number of digits of declination seconds.  The number of digits for right ascension seconds is always assumed to be one more  precision .  If the function is called with only  dec  as input,  precision  default to 1, in any other case defaults to 0. truncate  (optional boolean keyword): if true, then the last displayed digit in the output is truncated in precision rather than rounded.  This option is useful if  adstring  is used to form an official IAU name (see http://vizier.u-strasbg.fr/Dic/iau-spec.htx) with coordinate specification. Output The function returns one string.  The format of strings can be specified with  precision  and  truncate  keywords, see above. Example julia> using AstroLib\n\njulia> adstring(30.4, -1.23, truncate=true)\n\" 02 01 35.9  -01 13 48\"\n\njulia> adstring.([30.4, -15.63], [-1.23, 48.41], precision=1)\n2-element Vector{String}:\n \" 02 01 36.00  -01 13 48.0\"\n \" 22 57 28.80  +48 24 36.0\" source"},{"id":1564,"pagetitle":"Reference","title":"AstroLib.airtovac","ref":"/AstroLib/stable/ref/#AstroLib.airtovac-Tuple{Real}","content":" AstroLib.airtovac  —  Method airtovac(wave_air) -> wave_vacuum Purpose Converts air wavelengths to vacuum wavelengths. Explanation Wavelengths are corrected for the index of refraction of air under standard conditions. Wavelength values below  $2000 Å$  will  not  be altered, take care within  $[1 Å, 2000 Å]$ .  Uses relation of Ciddor (1996). Arguments wave_air : the wavelength in air. Output Vacuum wavelength in angstroms. Method Uses relation of Ciddor (1996), Applied Optics 62, 958. Example If the air wavelength is  w = 6056.125  (a Krypton line), then  airtovac(w)  yields a vacuum wavelength of  6057.8019 . julia> using AstroLib\n\njulia> airtovac(6056.125)\n6057.801930991426 Notes vactoair  converts vacuum wavelengths to air wavelengths. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1565,"pagetitle":"Reference","title":"AstroLib.aitoff","ref":"/AstroLib/stable/ref/#AstroLib.aitoff-Tuple{Real, Real}","content":" AstroLib.aitoff  —  Method aitoff(l, b) -> x, y Purpose Convert longitude  l  and latitude  b  to  (x, y)  using an Aitoff projection. Explanation This function can be used to create an all-sky map in Galactic coordinates with an equal-area Aitoff projection.  Output map coordinates are zero longitude centered. Arguments l : longitude, scalar or vector, in degrees. b : latitude, number of elements as  l , in degrees. Coordinates can be given also as a 2-tuple  (l, b) . Output 2-tuple  (x, y) . x : x coordinate, same number of elements as  l .   x  is normalized to be in  $[-180, 180]$ . y : y coordinate, same number of elements as  l .   y  is normalized to be in  $[-90, 90]$ . Example Get  $(x ,y)$  Aitoff coordinates of Sirius, whose Galactic coordinates are  $(227.23, -8.890)$ . julia> using AstroLib\n\njulia> x, y = aitoff(227.23, -8.890)\n(-137.92196683723276, -11.772527357473054) Notes See  AIPS memo No. 46 , page 4, for details of the algorithm.  This version of  aitoff  assumes the projection is centered at  b=0  degrees. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1566,"pagetitle":"Reference","title":"AstroLib.altaz2hadec","ref":"/AstroLib/stable/ref/#AstroLib.altaz2hadec-Tuple{Real, Real, Real}","content":" AstroLib.altaz2hadec  —  Method altaz2hadec(alt, az, lat) -> ha, dec Purpose Convert Horizon (Alt-Az) coordinates to Hour Angle and Declination. Explanation Can deal with the NCP singularity.  Intended mainly to be used by program  hor2eq . Arguments Input coordinates may be either a scalar or an array, of the same dimension. alt : local apparent altitude, in degrees, scalar or array. az : the local apparent azimuth, in degrees, scalar or vector, measured  east  of  north !!!  If you have measured azimuth west-of-south (like the book Meeus does), convert it to east of north via:  az = (az + 180) % 360 . lat : the local geodetic latitude, in degrees, scalar or array. alt  and  az  can be given as a 2-tuple  (alt, az) . Output 2-tuple  (ha, dec) ha : the local apparent hour angle, in degrees.  The hour angle is the time that right ascension of 0 hours crosses the local meridian.  It is unambiguously defined. dec : the local apparent declination, in degrees. The output coordinates are always floating points and have the same type (scalar or array) as the input coordinates. Example Arcturus is observed at an apparent altitude of 59d,05m,10s and an azimuth (measured east of north) of 133d,18m,29s while at the latitude of +43.07833 degrees.  What are the local hour angle and declination of this object? julia> using AstroLib\n\njulia> ha, dec = altaz2hadec(ten(59,05,10), ten(133,18,29), 43.07833)\n(336.6828582472844, 19.182450965120402) The widely available XEPHEM code gets: Hour Angle = 336.683\nDeclination = 19.1824 Notes hadec2altaz  converts Hour Angle and Declination to Horizon (Alt-Az) coordinates. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1567,"pagetitle":"Reference","title":"AstroLib.baryvel","ref":"/AstroLib/stable/ref/#AstroLib.baryvel-Tuple{Real}","content":" AstroLib.baryvel  —  Method baryvel(dje, deq) -> dvelh, dvelb Purpose Calculates heliocentric and barycentric velocity components of Earth. Explanation Baryvel takes into account the Earth-Moon motion, and is useful for radial velocity work to an accuracy of ~1 m/s. Arguments dje : julian ephemeris date deq  (optional): epoch of mean equinox of  dvelh  and  dvelb . If  deq  is not provided, then it is assumed to be equal to  dje . Output dvelh : heliocentric velocity component. in km/s dvelb : barycentric velocity component. in km/s Example Compute the radial velocity of the Earth toward Altair on 15-Feb-1994 using both the original Stumpf algorithm. julia> using AstroLib\n\njulia> jd = jdcnv(1994, 2, 15, 0)\n2.4493985e6\n\njulia> baryvel(jd, 2000)\n([-17.0724258266945, -22.81120895274765, -9.889315408506354], [-17.080834081384847, -22.80470807516409, -9.886258269159352]) Notes The 3-vectors outputs  dvelh  and  dvelb  are given in a right-handed coordinate system with the +X axis toward the Vernal Equinox, and +Z axis toward the celestial pole. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1568,"pagetitle":"Reference","title":"AstroLib.bprecess","ref":"/AstroLib/stable/ref/#AstroLib.bprecess","content":" AstroLib.bprecess  —  Function bprecess(ra, dec[, epoch]) -> ra1950, dec1950\nbprecess(ra, dec, muradec[, parallax=parallax, radvel=radvel]) -> ra1950, dec1950 Purpose Precess positions from J2000.0 (FK5) to B1950.0 (FK4). Explanation Calculates the mean place of a star at B1950.0 on the FK4 system from the mean place at J2000.0 on the FK5 system. bprecess  function has two methods, one for each of the following cases: the proper motion is known and non-zero the proper motion is unknown or known to be exactly zero (i.e. extragalactic radio sources).  Better precision can be achieved in this case by inputting the epoch of the original observations. Arguments The function has 2 methods.  The common mandatory arguments are: ra : input J2000 right ascension, in degrees. dec : input J2000 declination, in degrees. The two methods have a different third argument (see \"Explanation\" section for more details).  It can be one of the following: muradec : 2-element vector containing the proper motion in seconds of arc per tropical  century  in right ascension and declination. epoch : scalar giving epoch of original observations. If none of these two arguments is provided (so  bprecess  is fed only with right ascension and declination), it is assumed that proper motion is exactly zero and  epoch = 2000 . If it is used the method involving  muradec  argument, the following keywords are available: parallax  (optional numerical keyword): stellar parallax, in seconds of arc. radvel  (optional numerical keyword): radial velocity in km/s. Right ascension and declination can be passed as the 2-tuple  (ra, dec) .  You can also pass  ra ,  dec ,  parallax , and  radvel  as arrays, all of the same length N.  In that case,  muradec  should be a matrix 2×N. Output The 2-tuple of right ascension and declination in 1950, in degrees, of input coordinates is returned.  If  ra  and  dec  (and other possible optional arguments) are arrays, the 2-tuple of arrays  (ra1950, dec1950)  of the same length as the input coordinates is returned. Method The algorithm is taken from the Explanatory Supplement to the Astronomical Almanac 1992, page 186.  See also Aoki et al (1983), A&A, 128, 263.  URL: http://adsabs.harvard.edu/abs/1983A%26A...128..263A. Example The SAO2000 catalogue gives the J2000 position and proper motion for the star HD 119288.  Find the B1950 position. RA(2000) = 13h 42m 12.740s Dec(2000) = 8d 23' 17.69'' Mu(RA) = -.0257 s/yr Mu(Dec) = -.090 ''/yr julia> using AstroLib\n\njulia> muradec = 100*[-15*0.0257, -0.090]; # convert to century proper motion\n\njulia> ra = ten(13, 42, 12.74)*15;\n\njulia> decl = ten(8, 23, 17.69);\n\njulia> adstring(bprecess(ra, decl, muradec), precision=2)\n\" 13 39 44.526  +08 38 28.63\" Notes \"When transferring individual observations, as opposed to catalog mean place, the safest method is to transform the observations back to the epoch of the observation, on the FK4 system (or in the system that was used to to produce the observed mean place), convert to the FK5 system, and transform to the the epoch and equinox of J2000.0\" – from the Explanatory Supplement (1992), p. 180 jprecess  performs the precession to J2000 coordinates. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1569,"pagetitle":"Reference","title":"AstroLib.calz_unred","ref":"/AstroLib/stable/ref/#AstroLib.calz_unred","content":" AstroLib.calz_unred  —  Function calz_unred(wave, flux, ebv[, r_v]) -> deredden_wave Purpose Deredden a galaxy spectrum using the Calzetti et al. (2000) recipe. Explanation Calzetti et al.  (2000, ApJ 533, 682; http://adsabs.harvard.edu/abs/2000ApJ...533..682C) developed a recipe for dereddening the spectra of galaxies where massive stars dominate the radiation output, valid between  $0.12$  to  $2.2$  microns.  ( calz_unred  extrapolates between  $0.12$  and  $0.0912$  microns.) Arguments wave : wavelength (Angstroms) flux : calibrated flux. ebv : color excess E(B-V).  If a negative  ebv  is supplied, then fluxes will be reddened rather than deredenned.  Note that the supplied color excess should be that derived for the stellar continuum, EBV(stars), which is related to the reddening derived from the gas, EBV(gas), via the Balmer decrement by EBV(stars) = 0.44*EBV(gas). r_v  (optional): ratio of total to selective extinction, default is 4.05.  Calzetti et al. (2000) estimate  $r_v = 4.05 ± 0.80$  from optical-IR observations of 4 starbursts. Output Unreddened flux, same units as  flux .  Flux values will be left unchanged outside valid domain ( $0.0912$  -  $2.2$  microns). Example Estimate how a flat galaxy spectrum (in wavelength) between  $1200 Å$  and  $3200 Å$  is altered by a reddening of E(B-V) = 0.1. wave = collect(1200:50:3150);\nflux = ones(size(wave));\nflux_new = calz_unred.(wave, flux, -0.1); Using a plotting tool you can visualize the unreddend flux.  For example, with  Plots.jl using Plots\nplot(wave, flux_new) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1570,"pagetitle":"Reference","title":"AstroLib.co_aberration","ref":"/AstroLib/stable/ref/#AstroLib.co_aberration","content":" AstroLib.co_aberration  —  Function co_aberration(jd, ra, dec[, eps=NaN]) -> d_ra, d_dec Purpose Calculate changes to right ascension and declination due to the effect of annual aberration Explanation With reference to Meeus, Chapter 23 Arguments jd : julian date, scalar or vector ra : right ascension in degrees, scalar or vector dec : declination in degrees, scalar or vector eps  (optional): true obliquity of the ecliptic (in radians). It will be calculated if no argument is specified. Output The 2-tuple  (d_ra, d_dec) : d_ra : correction to right ascension due to aberration, in arc seconds d_dec : correction to declination due to aberration, in arc seconds Example Compute the change in RA and Dec of Theta Persei (RA = 2h46m,11.331s, Dec = 49d20',54.5'') due to aberration on 2028 Nov 13.19 TD julia> using AstroLib\n\njulia> jd = jdcnv(2028,11,13,4, 56)\n2.4620887055555554e6\n\njulia> co_aberration(jd,ten(2,46,11.331)*15,ten(49,20,54.54))\n(30.04404628365077, 6.699400463119431) d_ra = 30.04404628365103'' (≈ 2.003s) d_dec = 6.699400463118504'' Notes Code of this function is based on IDL Astronomy User's Library. The output d ra is  not  multiplied by cos(dec), so that apparent ra = ra + d_ra/3600. These formula are from Meeus, Chapters 23.  Accuracy is much better than 1 arcsecond. The maximum deviation due to annual aberration is 20.49'' and occurs when the Earth's velocity is perpendicular to the direction of the star. This function calls  true_obliquity  and  sunpos . source"},{"id":1571,"pagetitle":"Reference","title":"AstroLib.co_nutate","ref":"/AstroLib/stable/ref/#AstroLib.co_nutate-Tuple{Real, Real, Real}","content":" AstroLib.co_nutate  —  Method co_nutate(jd, ra, dec) -> d_ra, d_dec, eps, d_psi, d_eps Purpose Calculate changes in RA and Dec due to nutation of the Earth's rotation Explanation Calculates necessary changes to ra and dec due to the nutation of the Earth's rotation axis, as described in Meeus, Chap 23. Uses formulae from Astronomical Almanac, 1984, and does the calculations in equatorial rectangular coordinates to avoid singularities at the celestial poles. Arguments jd : julian date, scalar or vector ra : right ascension in degrees, scalar or vector dec : declination in degrees, scalar or vector Output The 5-tuple  (d_ra, d_dec, eps, d_psi, d_eps) : d_ra : correction to right ascension due to nutation, in degrees d_dec : correction to declination due to nutation, in degrees eps : the true obliquity of the ecliptic d_psi : nutation in the longitude of the ecliptic d_eps : nutation in the obliquity of the ecliptic Example Example 23a in Meeus: On 2028 Nov 13.19 TD the mean position of Theta Persei is 2h 46m 11.331s 49d 20' 54.54''. Determine the shift in position due to the Earth's nutation. julia> using AstroLib\n\njulia> jd = jdcnv(2028,11,13,4,56)\n2.4620887055555554e6\n\njulia> co_nutate(jd,ten(2,46,11.331) * 15,ten(49,20,54.54))\n(0.004400660977140092, 0.00172668646508356, 0.40904016038217555, 14.859389427896472, 2.703809037235057) Notes Code of this function is based on IDL Astronomy User's Library. The output of  d_ra  and  d_dec  in IDL AstroLib is in arcseconds, however it is in degrees here. This function calls  mean_obliquity  and  nutate . source"},{"id":1572,"pagetitle":"Reference","title":"AstroLib.co_refract","ref":"/AstroLib/stable/ref/#AstroLib.co_refract","content":" AstroLib.co_refract  —  Function co_refract(old_alt[, altitude=0, pressure=NaN, temperature=NaN,\n           epsilon=0.25, to_observe=false]) -> aout Purpose Calculate correction to altitude due to atmospheric refraction. Explanation Because the index of refraction of air is not precisely 1.0, the atmosphere bends all incoming light, making a star or other celestial object appear at a slightly different altitude (or elevation) than it really is.  It is important to understand the following definitions: Observed Altitude: The altitude that a star is seen to be, with a telescope. This is where it appears in the sky. This is should be always greater than the apparent altitude. Apparent Altitude: The altitude that a star would be at, if ~there were no atmosphere~ (sometimes called the \"true\" altitude). This is usually calculated from an object's celestial coordinates. Apparent altitude should always be smaller than the observed altitude. Thus, for example, the Sun's apparent altitude when you see it right on the horizon is actually -34 arcminutes. This program uses a couple of simple formulae to estimate the effect for most optical and radio wavelengths. Typically, you know your observed altitude (from an observation), and want the apparent altitude. To go the other way, this program uses an iterative approach. Arguments old_alt : observed altitude in degrees. If  to_observe  is set to true, this should be apparent altitude altitude  (optional): the height of the observing location, in meters. This is only used to determine an approximate temperature and pressure, if these are not specified separately. Default is 0 i.e. sea level pressure  (optional): the pressure at the observing location, in millibars. Default is NaN temperature  (optional): the temperature at the observing location, in Kelvins. Default is NaN epsilon  (optional): the accuracy to obtain, in arcseconds. If  to_observe  is true, then it will be calculated. Default is 0.25 arcseconds to_observe  (optional boolean keyword): if set to true, it is assumed that  old_alt  has apparent altitude as its input and the observed altitude will be found Output aout : apparent altitude, in degrees. Observed altitude is returned if  to_observe  is set to true Example The lower limb of the Sun is observed to have altitude of 0d 30'. Calculate the the true (i.e. apparent) altitude of the Sun's lower limb using mean  conditions of air pressure and temperature. julia> using AstroLib\n\njulia> co_refract(0.5)\n0.02584736873098442 Notes If altitude is set but the temperature or pressure is not, the program will make an intelligent guess for the temperature and pressure. Wavelength Dependence This correction is 0 at zenith, about 1 arcminute at 45 degrees, and 34 arcminutes at the horizon for optical wavelengths. The correction is non-negligible at all wavelengths, but is not very easily calculable. These formulae assume a wavelength of 550 nm, and will be accurate to about 4 arcseconds for all visible wavelengths, for elevations of 10 degrees and higher. Amazingly, they are also accurate for radio frequencies less than ~ 100 GHz. References Meeus, Astronomical Algorithms, Chapter 15. Explanatory Supplement to the Astronomical Almanac, 1992. Methods of Experimental Physics, Vol 12 Part B, Astrophysics, Radio Telescopes, Chapter 2.5, \"Refraction Effects in the Neutral Atmosphere\", by R.K. Crane. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1573,"pagetitle":"Reference","title":"AstroLib.co_refract_forward","ref":"/AstroLib/stable/ref/#AstroLib.co_refract_forward-Tuple{Real, Real, Real}","content":" AstroLib.co_refract_forward  —  Method co_refract_forward(alt, pre, temp) -> ref Purpose A function used by  co_refract  to find apparent (or observed) altitude Arguments alt : the observed (or apparent) altitude, in degrees pre : pressure, in millibars temp : temperature, in Kelvins Output ref : the atmospheric refraction, in minutes of arc Notes The atmospheric refraction is calculated by Saemundsson's formula Code of this function is based on IDL Astronomy User's Library. source"},{"id":1574,"pagetitle":"Reference","title":"AstroLib.ct2lst","ref":"/AstroLib/stable/ref/#AstroLib.ct2lst","content":" AstroLib.ct2lst  —  Function ct2lst(longitude, jd) -> local_sidereal_time\nct2lst(longitude, tz, date) -> local_sidereal_time Purpose Convert from Local Civil Time to Local Mean Sidereal Time. Arguments The function can be called in two different ways.  The only argument common to both methods is  longitude : longitude : the longitude in degrees (east of Greenwich) of the place for which the local sidereal time is desired.  The Greenwich mean sidereal time (GMST) can be found by setting longitude =  0 . The civil date to be converted to mean sidereal time can be specified either by providing the Julian days: jd : this is number of Julian days for the date to be converted. or the time zone and the date: tz : the time zone of the site in hours, positive East of the Greenwich meridian (ahead of GMT).  Use this parameter to easily account for Daylight Savings time (e.g. -4=EDT, -5 = EST/CDT). date : this is the local civil time with type  DateTime . Output The local sidereal time for the date/time specified in hours. Method The Julian days of the day and time is question is used to determine the number of days to have passed since 2000-01-01.  This is used in conjunction with the GST of that date to extrapolate to the current GST; this is then used to get the LST.  See Astronomical Algorithms by Jean Meeus, p. 84 (Eq. 11-4) for the constants used. Example Find the Greenwich mean sidereal time (GMST) on 2008-07-30 at 15:53 in Baltimore, Maryland (longitude=-76.72 degrees).  The timezone is EDT or tz=-4 julia> using AstroLib, Dates\n\njulia> lst = ct2lst(-76.72, -4, DateTime(2008, 7, 30, 15, 53))\n11.356505172312609\n\njulia> sixty(lst)\n3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):\n 11.0\n 21.0\n 23.418620325392112 Find the Greenwich mean sidereal time (GMST) on 2015-11-24 at 13:21 in Heidelberg, Germany (longitude=08° 43' E).  The timezone is CET or tz=1. Provide  ct2lst  only with the longitude of the place and the number of Julian days. julia> using AstroLib, Dates\n\njulia> longitude = ten(8, 43); # Convert longitude to decimals.\n\njulia> # Get number of Julian days. Remember to subtract the time zone in\n       # order to convert local time to UTC.\n\njulia> jd = jdcnv(DateTime(2015, 11, 24, 13, 21) - Dates.Hour(1));\n\njulia> lst = ct2lst(longitude, jd) # Calculate Greenwich Mean Sidereal Time.\n17.140685171005316\n\njulia> sixty(lst)\n3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):\n 17.0\n  8.0\n 26.466615619137883 Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1575,"pagetitle":"Reference","title":"AstroLib.daycnv","ref":"/AstroLib/stable/ref/#AstroLib.daycnv","content":" AstroLib.daycnv  —  Function daycnv(julian_days) -> DateTime Purpose Converts Julian days number to Gregorian calendar dates. Explanation Takes the number of Julian calendar days since epoch  -4713-11-24T12:00:00  and returns the corresponding proleptic Gregorian Calendar date. Argument julian_days : Julian days number. Output Proleptic Gregorian Calendar date, of type  DateTime , corresponding to the given Julian days number. Example julia> using AstroLib\n\njulia> daycnv(2440000)\n1968-05-23T12:00:00 Notes jdcnv  is the inverse of this function. source"},{"id":1576,"pagetitle":"Reference","title":"AstroLib.deredd","ref":"/AstroLib/stable/ref/#AstroLib.deredd-NTuple{5, Real}","content":" AstroLib.deredd  —  Method deredd(Eby, by, m1, c1, ub) -> by0, m0, c0, ub0 Purpose Deredden stellar Stromgren parameters given for a value of E(b-y) Arguments Eby : color index E(b-y), scalar (E(b-y) = 0.73*E(B-V)) by : b-y color (observed) m1 : Stromgren line blanketing parameter (observed) c1 : Stromgren Balmer discontinuity parameter (observed) ub : u-b color (observed) All arguments can be either scalars or arrays all of the same length. Output The 4-tuple  (by0, m0, c0, ub0) . by0 : b-y color (dereddened) m0 : line blanketing index (dereddened) c0 : Balmer discontinuity parameter (dereddened) ub0 : u-b color (dereddened) These are scalars or arrays of the same length as the input arguments. Example julia> using AstroLib\n\njulia> deredd(0.5, 0.2, 1.0, 1.0, 0.1)\n(-0.3, 1.165, 0.905, -0.665) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1577,"pagetitle":"Reference","title":"AstroLib.eci2geo","ref":"/AstroLib/stable/ref/#AstroLib.eci2geo-NTuple{4, Real}","content":" AstroLib.eci2geo  —  Method eci2geo(x, y, z, jd) -> latitude, longitude, altitude Purpose Convert Earth-centered inertial coordinates to geographic spherical coordinates. Explanation Converts from ECI (Earth-Centered Inertial) (x, y, z) rectangular coordinates to geographic spherical coordinates (latitude, longitude, altitude).  Julian day is also needed as input. ECI coordinates are in km from Earth center at the supplied time (True of Date). Geographic coordinates assume the Earth is a perfect sphere, with radius equal to its equatorial radius. Arguments x : ECI x coordinate at  jd , in kilometers. y : ECI y coordinate at  jd , in kilometers. z : ECI z coordinate at  jd , in kilometers. jd : Julian days. The three coordinates can be passed as a 3-tuple  (x, y, z) .  In addition,  x ,  y ,  z , and  jd  can be given as arrays of the same length. Output The 3-tuple of geographical coordinate (latitude, longitude, altitude). latitude : latitude, in degrees. longitude : longitude, in degrees. altitude : altitude, in kilometers. If ECI coordinates are given as arrays, a 3-tuple of arrays of the same length is returned. Example Obtain the geographic direction of the vernal point on 2015-06-30T14:03:12.857, in geographic coordinates, at altitude 600 km.  Note: equatorial radii of Solar System planets in meters are stored into  AstroLib.planets  dictionary. julia> using AstroLib\n\njulia> x = AstroLib.planets[\"earth\"].eqradius*1e-3 + 600;\n\njulia> lat, long, alt = eci2geo(x, 0, 0, jdcnv(\"2015-06-30T14:03:12.857\"))\n(0.0, 230.87301833205856, 600.0) These coordinates can be further transformed into geodetic coordinates using  geo2geodetic  or into geomagnetic coordinates using  geo2mag . Notes geo2eci  converts geographic spherical coordinates to Earth-centered inertial coordinates. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1578,"pagetitle":"Reference","title":"AstroLib.eq2hor","ref":"/AstroLib/stable/ref/#AstroLib.eq2hor","content":" AstroLib.eq2hor  —  Function eq2hor(ra, dec, jd[, obsname; ws=false, B1950=false, precession=true, nutate=true,\n       aberration=true, refract=true, pressure=NaN, temperature=NaN]) -> alt, az, ha\n\neq2hor(ra, dec, jd, lat, lon[, altitude=0; ws=false, B1950=false,\n       precession=true, nutate=true, aberration=true, refract=true,\n       pressure=NaN, temperature=NaN]) -> alt, az, ha Purpose Convert celestial  (ra-dec) coords to local horizon coords (alt-az). Explanation This code calculates horizon (alt,az) coordinates from equatorial (ra,dec) coords. It performs precession, nutation, aberration, and refraction corrections. Arguments This function has two base methods.  With one you can specify the name of the observatory, if present in  AstroLib.observatories , with the other one you can provide the coordinates of the observing site and, optionally, the altitude. Common mandatory arguments: ra : right ascension of object, in degrees dec : declination of object, in degrees jd : julian date Other positional arguments: obsname : set this to a valid observatory name in  AstroLib.observatories . or lat : north geodetic latitude of location, in degrees. lon : AST longitude of location, in degrees. You can specify west longitude with a negative sign. altitude : the altitude of the observing location, in meters.  It is  0  by default Optional keyword arguments: ws  (optional boolean keyword): set this to  true  to get the azimuth measured westward from south (not East of North) B1950  (optional boolean keyword): set this to  true  if the ra and dec are specified in B1950 (FK4 coordinates) instead of J2000 (FK5). This is  false  by default precession  (optional boolean keyword): set this to  false  for no precession correction,  true  by default nutate  (optional boolean keyword): set this to  false  for no nutation,  true  by default aberration  (optional boolean keyword): set this to  false  for no aberration correction,  true  by default refract  (optional boolean keyword): set this to  false  for no refraction correction,  true  by default pressure  (optional keyword): the pressure at the observing location, in millibars. Default value is  NaN temperature  (optional keyword): the temperature at the observing location, in Kelvins. Default value is  NaN Output alt : altitude of horizon coords, in degrees az : azimuth angle measured East from North (unless ws is  true ), in degrees ha : hour angle, in degrees Example julia> using AstroLib\n\njulia> alt_o, az_o = eq2hor(ten(6,40,58.2)*15, ten(9,53,44), 2460107.25, ten(50,31,36),\n                            ten(6,51,18), 369, pressure = 980, temperature=283)\n(16.423991509721567, 265.60656932130564, 76.11502253130612)\n\njulia> adstring(az_o, alt_o)\n\" 17 42 25.6  +16 25 26\" Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1579,"pagetitle":"Reference","title":"AstroLib.eqpole","ref":"/AstroLib/stable/ref/#AstroLib.eqpole-Tuple{Real, Real}","content":" AstroLib.eqpole  —  Method eqpole(l, b[; southpole = false]) -> x, y Purpose Convert right ascension  $l$  and declination  $b$  to coordinate  $(x, y)$  using an equal-area polar projection. Explanation The output  $x$  and  $y$  coordinates are scaled to be in the range  $[-90, 90]$  and to go from equator to pole to equator.  Output map points can be centered on the north pole or south pole. Arguments l : longitude, scalar or vector, in degrees b : latitude, same number of elements as right ascension, in degrees southpole  (optional boolean keyword): keyword to indicate that the plot is to be centered on the south pole instead of the north pole.  Default is  false . Output The 2-tuple  $(x, y)$ : $x$  coordinate, same number of elements as right ascension, normalized to be in the range  $[-90, 90]$ . $y$  coordinate, same number of elements as declination, normalized to be in the range  $[-90, 90]$ . Example julia> using AstroLib\n\njulia> eqpole(100, 35, southpole=true)\n(-111.18287262822456, -19.604540237028665)\n\njulia> eqpole(80, 19)\n(72.78853915267848, 12.83458333897169) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1580,"pagetitle":"Reference","title":"AstroLib.euler","ref":"/AstroLib/stable/ref/#AstroLib.euler-Tuple{Real, Real, Integer}","content":" AstroLib.euler  —  Method euler(ai, bi, select[, FK4=true, radians=true]) Purpose Transform between Galactic, celestial, and ecliptic coordinates. Explanation The function is used by the astro procedure. Arguments ai : input longitude, scalar or vector. bi : input latitude, scalar or vector. select  : integer input specifying type of coordinate transformation. SELECT   From          To     | SELECT   From       To    1   RA-Dec (2000) Galactic |   4    Ecliptic   RA-Dec    2   Galactic      RA-DEC   |   5    Ecliptic   Galactic    3   RA-Dec        Ecliptic |   6    Galactic   Ecliptic FK4  (optional boolean keyword) : if this keyword is set to  true , then input and output celestial and ecliptic coordinates should be given in equinox B1950. When  false , by default, they should be given in equinox J2000. radians  (optional boolean keyword) : if this keyword is set to  true , all input and output angles are in radians rather than degrees. Output a 2-tuple  (ao, bo) : ao : output longitude in degrees. bo : output latitude in degrees. Example Find the Galactic coordinates of Cyg X-1 (ra=299.590315, dec=35.201604) julia> using AstroLib\n\njulia> euler(299.590315, 35.201604, 1)\n(71.33498957116959, 3.0668335310640984) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1581,"pagetitle":"Reference","title":"AstroLib.flux2mag","ref":"/AstroLib/stable/ref/#AstroLib.flux2mag","content":" AstroLib.flux2mag  —  Function flux2mag(flux[, zero_point, ABwave=number]) -> magnitude Purpose Convert from flux expressed in erg/(s cm² Å) to magnitudes. Explanation This is the reverse of  mag2flux . Arguments flux : the flux to be converted in magnitude, expressed in erg/(s cm² Å). zero_point : the zero point level of the magnitude.  If not supplied then defaults to 21.1 (Code et al 1976).  Ignored if the  ABwave  keyword is supplied ABwave  (optional numeric keyword): wavelength in Angstroms. If supplied, then returns Oke AB magnitudes (Oke & Gunn 1983, ApJ, 266, 713; http://adsabs.harvard.edu/abs/1983ApJ...266..713O). Output The magnitude. If the  ABwave  keyword is set then magnitude is given by the expression \\[\\text{ABmag} = -2.5\\log_{10}(f) - 5\\log_{10}(\\text{ABwave}) - 2.406\\] Otherwise, magnitude is given by the expression \\[\\text{mag} = -2.5\\log_{10}(\\text{flux}) - \\text{zero point}\\] Example julia> using AstroLib\n\njulia> flux2mag(5.2e-15)\n14.609991640913002\n\njulia> flux2mag(5.2e-15, 15)\n20.709991640913003\n\njulia> flux2mag(5.2e-15, ABwave=15)\n27.423535345634598 Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1582,"pagetitle":"Reference","title":"AstroLib.frebin","ref":"/AstroLib/stable/ref/#AstroLib.frebin-Union{Tuple{R}, Tuple{AbstractArray{R}, Real}, Tuple{AbstractArray{R}, Real, Real}} where R<:Real","content":" AstroLib.frebin  —  Method frebin(image, nsout, nlout=1, total=false) -> rebinned_image Purpose Shrink or expand the size of an array an arbitrary amount using interpolation Arguments image : the array representing the 1D or 2D image to be rebinned. nsout : number of samples in the output image, numeric scalar. nlout  (optional): number of lines in the output image, numeric scalar (default = 1). total  (optional boolean keyword): if true, the output pixels will be the           sum of pixels within the appropriate box of the input image.            Otherwise they will be the average. Use of the  total  keyword           conserves total counts. Output The resized image is returned as the function result. Examples Suppose one has an 800 x 800 image array, im, that must be expanded to a size 850 x 900 while conserving the total counts. The pixel values are the sum of the x and y coordinates in the original image: julia> using AstroLib\n\njulia> image = [x+y for x in 1:800, y in 1:800];\n\njulia> size(image)\n(800, 800)\n\njulia> sum(image)\n512640000\n\njulia> image1 = frebin(image, 850, 900, total=true);\n\njulia> size(image1)\n(850, 900)\n\njulia> sum(image1) ≈ sum(image)\ntrue If the new dimensions are integer ratios of the original dimensions, some optimizations can be performed.  We can also choose to preserve the  average  pixel value rather than the  total  pixel value in the image: julia> using AstroLib\n\njulia> image = [x+y for x in 1:800, y in 1:800];\n\njulia> size(image)\n(800, 800)\n\njulia> sum(image)/length(image)\n801.0\n\njulia> image1 = frebin(image, 400, 400, total=false);\n\njulia> size(image1)\n(400, 400)\n\njulia> (sum(image1)/length(image1)) ≈ (sum(image)/length(image))\ntrue\n\njulia> image2 = frebin(image, 1600, 1600, total=false);\n\njulia> size(image2)\n(1600, 1600)\n\njulia> (sum(image2)/length(image2)) ≈ (sum(image)/length(image))\ntrue Of course, this works with 1D arrays as well: julia> using AstroLib\n\njulia> image = [x for x in 1:800];\n\njulia> size(image)\n(800,)\n\njulia> sum(image)\n320400\n\njulia> sum(image)/length(image)\n400.5\n\njulia> image1 = frebin(image, 1600);\n\njulia> size(image1)\n(1600,)\n\njulia> (sum(image1)/length(image1)) ≈ (sum(image)/length(image))\ntrue\n\njulia> image2 = frebin(image, 410, total=true);\n\njulia> size(image2)\n(410,)\n\njulia> sum(image2) ≈ sum(image)\ntrue Notes If the input image sizes are a multiple of the output image sizes then  frebin  is equivalent to summing over the grid multiples for  compression, and simple pixel duplication on expansion. If the number of output pixels are not integers, the output image size will be truncated to an integer.  The platescale, however, will reflect the non-integer number of pixels.  For example, if you want to bin a 100 x 100 integer image such that each output pixel is 3.1 input pixels in each direction use:     n = 100/3.1   # 32.2581     image_out = frebin(image,n,n) The output image will be 32 x 32 and a small portion at the trailing edges of the input image will be ignored. History Adapted from May 1998 STIS  version, written D. Lindler, ACC Added /NOZERO, use INTERPOLATE instead of CONGRID, June 98 W. Landsman   Fixed for nsout non-integral but a multiple of image size  Aug 98 D.Lindler DJL, Oct 20, 1998, Modified to work for floating point image sizes when     expanding the image.  Improve speed by addressing arrays in memory order W.Landsman Dec/Jan 2001 Code of this function is based on IDL Astronomy User's Library. source"},{"id":1583,"pagetitle":"Reference","title":"AstroLib.fshift","ref":"/AstroLib/stable/ref/#AstroLib.fshift-Union{Tuple{R}, Tuple{AbstractArray{R}, Real, Real}} where R<:Real","content":" AstroLib.fshift  —  Method fshift(image, Δx, Δy) -> shifted_image Purpose Routine to shift an image by non-integer values Arguments image : 2D image to be shifted. Δx : shift in x Δy : shift in y Output Shifted image is returned as the function results Example Suppose we want to shift a 10x10 image by 0.5 pixels in the x and y directions. The pixel values are the sum of the x and y coordinates: julia> using AstroLib\n\njulia> image = [x+y for x in 1:10, y in 1:10];\n\njulia> fshift(image, 0.5, 0.5)\n10×10 Matrix{Float64}:\n 11.0   7.0   8.0   9.0  10.0  11.0  12.0  13.0  14.0  15.0\n  7.0   3.0   4.0   5.0   6.0   7.0   8.0   9.0  10.0  11.0\n  8.0   4.0   5.0   6.0   7.0   8.0   9.0  10.0  11.0  12.0\n  9.0   5.0   6.0   7.0   8.0   9.0  10.0  11.0  12.0  13.0\n 10.0   6.0   7.0   8.0   9.0  10.0  11.0  12.0  13.0  14.0\n 11.0   7.0   8.0   9.0  10.0  11.0  12.0  13.0  14.0  15.0\n 12.0   8.0   9.0  10.0  11.0  12.0  13.0  14.0  15.0  16.0\n 13.0   9.0  10.0  11.0  12.0  13.0  14.0  15.0  16.0  17.0\n 14.0  10.0  11.0  12.0  13.0  14.0  15.0  16.0  17.0  18.0\n 15.0  11.0  12.0  13.0  14.0  15.0  16.0  17.0  18.0  19.0\n\njulia> fshift(image, -3, -1)\n10×10 Matrix{Float64}:\n  6.0   7.0   8.0   9.0  10.0  11.0  12.0  13.0  14.0   5.0\n  7.0   8.0   9.0  10.0  11.0  12.0  13.0  14.0  15.0   6.0\n  8.0   9.0  10.0  11.0  12.0  13.0  14.0  15.0  16.0   7.0\n  9.0  10.0  11.0  12.0  13.0  14.0  15.0  16.0  17.0   8.0\n 10.0  11.0  12.0  13.0  14.0  15.0  16.0  17.0  18.0   9.0\n 11.0  12.0  13.0  14.0  15.0  16.0  17.0  18.0  19.0  10.0\n 12.0  13.0  14.0  15.0  16.0  17.0  18.0  19.0  20.0  11.0\n  3.0   4.0   5.0   6.0   7.0   8.0   9.0  10.0  11.0   2.0\n  4.0   5.0   6.0   7.0   8.0   9.0  10.0  11.0  12.0   3.0\n  5.0   6.0   7.0   8.0   9.0  10.0  11.0  12.0  13.0   4.0 History version 2  D. Lindler  May, 1992 - rewritten for IDL version 2 19-may-1992\tJKF/ACC\t\t- move to GHRS DAF. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1584,"pagetitle":"Reference","title":"AstroLib.gal_uvw","ref":"/AstroLib/stable/ref/#AstroLib.gal_uvw-NTuple{6, Real}","content":" AstroLib.gal_uvw  —  Method gal_uvw(ra, dec, pmra, pmdec, vrad, plx[, lsr=true]) -> u, v, w Purpose Calculate the Galactic space velocity  $(u, v, w)$  of a star. Explanation Calculates the Galactic space velocity  $(u, v, w)$  of a star given its (1) coordinates, (2) proper motion, (3) parallax, and (4) radial velocity. Arguments User must supply a position, proper motion, radial velocity and parallax. Either scalars or arrays all of the same length can be supplied. Position: ra : right ascension, in degrees dec : declination, in degrees Proper Motion pmra : proper motion in right ascension in arc units (typically milli-arcseconds/yr).  If given  $μ_α$  – proper motion in seconds of time/year – then this is equal to  $15 μ_α \\cos(\\text{dec})$ . pmdec : proper motion in declination (typically mas/yr). Radial Velocity vrad : velocity in km/s Parallax plx : parallax with same distance units as proper motion measurements typically milliarcseconds (mas) If you know the distance in parsecs, then set  plx  to  $1000/\\text{distance}$ , if proper motion measurements are given in milli-arcseconds/yr. There is an additional optional keyword: lsr  (optional boolean keyword): if this keyword is set to  true , then the output velocities will be corrected for the solar motion  $(u, v, w)_⊙ = (-8.5, 13.38, 6.49)$  (Coşkunoǧlu et al. 2011 MNRAS, 412, 1237; DOI: 10.1111/j.1365-2966.2010.17983.x ) to the local standard of rest (LSR).  Note that the value of the solar motion through the LSR remains poorly determined. Output The 3-tuple  $(u, v, w)$ $u$ : velocity (km/s) positive toward the Galactic  anti center $v$ : velocity (km/s) positive in the direction of Galactic rotation $w$ : velocity (km/s) positive toward the North Galactic Pole Method Follows the general outline of Johnson & Soderblom (1987, AJ, 93, 864; DOI: 10.1086/114370 ) except that  $u$  is positive outward toward the Galactic  anti center, and the J2000 transformation matrix to Galactic coordinates is taken from the introduction to the Hipparcos catalog. Example Compute the U,V,W coordinates for the halo star HD 6755.  Use values from Hipparcos catalog, and correct to the LSR. julia> using AstroLib\n\njulia> ra = ten(1,9,42.3)*15.; dec = ten(61,32,49.5);\n\njulia> pmra = 627.89;  pmdec = 77.84; # mas/yr\n\njulia> vrad = -321.4; dis = 129; # distance in parsecs\n\njulia> u, v, w = gal_uvw(ra, dec, pmra, pmdec, vrad, 1e3/dis, lsr=true)\n(118.2110474553902, -466.4828898385057, 88.16573278565097) Notes This function does not take distance as input.  See \"Arguments\" section above for how to provide it using parallax argument. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1585,"pagetitle":"Reference","title":"AstroLib.gcirc","ref":"/AstroLib/stable/ref/#AstroLib.gcirc-Tuple{Integer, Vararg{Real, 4}}","content":" AstroLib.gcirc  —  Method gcirc(units, ra1, dec1, ra2, dec2) -> angular_distance Purpose Computes rigorous great circle arc distances. Explanation Input position can be either radians, sexagesimal right ascension and declination, or degrees. Arguments units : integer, can be either 0, or 1, or 2.  Describes units of inputs and output: 0: everything (input right ascensions and declinations, and output distance) is radians 1: right ascensions are in decimal hours, declinations in decimal degrees, output distance in arc seconds 2: right ascensions and declinations are in degrees, output distance in arc seconds ra1 :  right ascension or longitude of point 1 dec1 : declination or latitude of point 1 ra2 : right ascension or longitude of point 2 dec2 : declination or latitude of point 2 Both  ra1  and  dec1 , and  ra2  and  dec2  can be given as 2-tuples  (ra1, dec1)  and  (ra2, dec2) . Output Angular distance on the sky between points 1 and 2, as a  AbstractFloat .  See  units  argument above for the units. Method \"Haversine formula\" see http://en.wikipedia.org/wiki/Great-circle_distance. Example julia> using AstroLib\n\njulia> gcirc(0, 120, -43, 175, +22)\n1.590442261600714 Notes The function  sphdist  provides an alternate method of computing a spherical distance. The Haversine formula can give rounding errors for antipodal points. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1586,"pagetitle":"Reference","title":"AstroLib.geo2eci","ref":"/AstroLib/stable/ref/#AstroLib.geo2eci-NTuple{4, Real}","content":" AstroLib.geo2eci  —  Method geo2eci(latitude, longitude, altitude, jd) -> x, y, z Purpose Convert geographic spherical coordinates to Earth-centered inertial coordinates. Explanation Converts from geographic spherical coordinates (latitude, longitude, altitude) to ECI (Earth-Centered Inertial) (x, y, z) rectangular coordinates.  Julian days is also needed. Geographic coordinates assume the Earth is a perfect sphere, with radius equal to its equatorial radius.  ECI coordinates are in km from Earth center at epoch TOD (True of Date). Arguments latitude : geographic latitude, in degrees. longitude : geographic longitude, in degrees. altitude : geographic altitude, in kilometers. jd : Julian days. The three coordinates can be passed as a 3-tuple  (latitude, longitude, altitude) .  In addition,  latitude ,  longitude ,  altitude , and  jd  can be given as arrays of the same length. Output The 3-tuple of ECI (x, y, z) coordinates, in kilometers.  The TOD epoch is the supplied  jd  time. If geographical coordinates are given as arrays, a 3-tuple of arrays of the same length is returned. Example Obtain the ECI coordinates of the intersection of the equator and Greenwich's meridian on 2015-06-30T14:03:12.857 julia> using AstroLib\n\njulia> geo2eci(0, 0, 0, jdcnv(\"2015-06-30T14:03:12.857\"))\n(-4024.8671780315185, 4947.835465127513, 0.0) Notes eci2geo  converts Earth-centered inertial coordinates to geographic spherical coordinates. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1587,"pagetitle":"Reference","title":"AstroLib.geo2geodetic","ref":"/AstroLib/stable/ref/#AstroLib.geo2geodetic-NTuple{5, Real}","content":" AstroLib.geo2geodetic  —  Method geo2geodetic(latitude, longitude, altitude) -> latitude, longitude, altitude\ngeo2geodetic(latitude, longitude, altitude, planet) -> latitude, longitude, altitude\ngeo2geodetic(latitude, longitude, altitude, equatorial_radius, polar_radius) -> latitude, longitude, altitude Purpose Convert from geographic (or planetographic) to geodetic coordinates. Explanation Converts from geographic (latitude, longitude, altitude) to geodetic (latitude, longitude, altitude).  In geographic coordinates, the Earth is assumed a perfect sphere with a radius equal to its equatorial radius.  The geodetic (or ellipsoidal) coordinate system takes into account the Earth's oblateness. Geographic and geodetic longitudes are identical.  Geodetic latitude is the angle between local zenith and the equatorial plane.  Geographic and geodetic altitudes are both the closest distance between the satellite and the ground. Arguments The function has two base methods.  The arguments common to all methods and always mandatory are  latitude ,  longitude , and  altitude : latitude : geographic latitude, in degrees. longitude : geographic longitude, in degrees. altitude : geographic altitude, in kilometers. In order to convert to geodetic coordinates, you can either provide custom equatorial and polar radii of the planet or use the values of one of the planets of Solar System (Pluto included). If you want to use the method with explicit equatorial and polar radii the additional mandatory arguments are: equatorial_radius : value of the equatorial radius of the body, in kilometers. polar_radius : value of the polar radius of the body, in kilometers. Instead, if you want to use the method with the selection of a planet, the only additional argument is the planet name: planet  (optional string argument): string with the name of the Solar System planet, from \"Mercury\" to \"Pluto\".  If omitted (so, when only  latitude ,  longitude , and  altitude  are provided), the default is \"Earth\". In all cases, the three coordinates can be passed as a 3-tuple  (latitude, longitude, altitude) .  In addition, geographical  latitude ,  longitude , and  altitude  can be given as arrays of the same length. Output The 3-tuple  (latitude, longitude, altitude)  in geodetic coordinates, for the body with specified equatorial and polar radii (Earth by default). If geographical coordinates are given as arrays, a 3-tuple of arrays of the same length is returned. Method Stephen P.  Keeler and Yves Nievergelt, \"Computing geodetic coordinates\", SIAM Rev. Vol. 40, No. 2, pp. 300-309, June 1998 (DOI: 10.1137/S0036144597323921 ). Planetary constants are from Planetary Fact Sheet (http://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html). Example Locate the Earth geographic North pole (latitude: 90°, longitude: 0°, altitude 0 km), in geodetic coordinates: julia> using AstroLib\n\njulia> geo2geodetic(90, 0, 0)\n(90.0, 0.0, 21.38499999999931) The same for Jupiter: julia> using AstroLib\n\njulia> geo2geodetic(90, 0, 0, \"Jupiter\")\n(90.0, 0.0, 4638.0) Find geodetic coordinates for point of geographic coordinates (latitude, longitude, altitude) = (43.16°, -24.32°, 3.87 km) on a planet with equatorial radius 8724.32 km and polar radius 8619.19 km: julia> using AstroLib\n\njulia> geo2geodetic(43.16, -24.32, 3.87, 8724.32, 8619.19)\n(43.849399515234516, -24.32, 53.53354478670965) Notes Whereas the conversion from geodetic to geographic coordinates is given by an exact, analytical formula, the conversion from geographic to geodetic isn't. Approximative iterations (as used here) exist, but tend to become less good with increasing eccentricity and altitude.  The formula used in this routine should give correct results within six digits for all spatial locations, for an ellipsoid (planet) with an eccentricity similar to or less than Earth's.  More accurate results can be obtained via calculus, needing a non-determined amount of iterations. In any case, the function  geodetic2geo , which converts from geodetic (or planetodetic) to geographic coordinates, can be used to estimate the accuracy of  geo2geodetic . julia> using AstroLib\n\njulia> collect(geodetic2geo(geo2geodetic(67.2, 13.4, 1.2))) - [67.2, 13.4, 1.2]\n3-element Vector{Float64}:\n -3.5672513831741526e-9\n  0.0\n  9.484211194177306e-10 Code of this function is based on IDL Astronomy User's Library. source"},{"id":1588,"pagetitle":"Reference","title":"AstroLib.geo2mag","ref":"/AstroLib/stable/ref/#AstroLib.geo2mag","content":" AstroLib.geo2mag  —  Function geo2mag(latitude, longitude[, year]) -> geomagnetic_latitude, geomagnetic_longitude Purpose Convert from geographic to geomagnetic coordinates. Explanation Converts from geographic (latitude, longitude) to geomagnetic (latitude, longitude).  Altitude is not involved in this function. Arguments latitude : geographic latitude (North), in degrees. longitude : geographic longitude (East), in degrees. year  (optional numerical argument): the year in which to perform conversion. If omitted, defaults to current year. The coordinates can be passed as arrays of the same length. Output The 2-tuple of magnetic (latitude, longitude) coordinates, in degrees. If geographical coordinates are given as arrays, a 2-tuple of arrays of the same length is returned. Example Kyoto has geographic coordinates 35° 00' 42'' N, 135° 46' 06'' E, find its geomagnetic coordinates in 2016: julia> using AstroLib\n\njulia> geo2mag(ten(35,0,42), ten(135,46,6), 2016)\n(36.86579228937769, -60.1840605366516) Notes This function uses list of North Magnetic Pole positions provided by World Magnetic Model (https://www.ngdc.noaa.gov/geomag/data/poles/NP.xy). mag2geo  converts geomagnetical coordinates to geographic coordinates. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1589,"pagetitle":"Reference","title":"AstroLib.geodetic2geo","ref":"/AstroLib/stable/ref/#AstroLib.geodetic2geo-NTuple{5, Real}","content":" AstroLib.geodetic2geo  —  Method geodetic2geo(latitude, longitude, altitude) -> latitude, longitude, altitude\ngeodetic2geo(latitude, longitude, altitude, planet) -> latitude, longitude, altitude\ngeodetic2geo(latitude, longitude, altitude, equatorial_radius, polar_radius) -> latitude, longitude, altitude Purpose Convert from geodetic (or planetodetic) to geographic coordinates. Explanation Converts from geodetic (latitude, longitude, altitude) to geographic (latitude, longitude, altitude).  In geographic coordinates, the Earth is assumed a perfect sphere with a radius equal to its equatorial radius.  The geodetic (or ellipsoidal) coordinate system takes into account the Earth's oblateness. Geographic and geodetic longitudes are identical.  Geodetic latitude is the angle between local zenith and the equatorial plane.  Geographic and geodetic altitudes are both the closest distance between the satellite and the ground. Arguments The function has two base methods.  The arguments common to all methods and always mandatory are  latitude ,  longitude , and  altitude : latitude : geodetic latitude, in degrees. longitude : geodetic longitude, in degrees. altitude : geodetic altitude, in kilometers. In order to convert to geographic coordinates, you can either provide custom equatorial and polar radii of the planet or use the values of one of the planets of Solar System (Pluto included). If you want to use the method with explicit equatorial and polar radii the additional mandatory arguments are: equatorial_radius : value of the equatorial radius of the body, in kilometers. polar_radius : value of the polar radius of the body, in kilometers. Instead, if you want to use the method with the selection of a planet, the only additional argument is the planet name: planet  (optional string argument): string with the name of the Solar System planet, from \"Mercury\" to \"Pluto\".  If omitted (so, when only  latitude ,  longitude , and  altitude  are provided), the default is \"Earth\". In all cases, the three coordinates can be passed as a 3-tuple  (latitude, longitude, altitude) .  In addition, geodetic  latitude ,  longitude , and  altitude  can be given as arrays of the same length. Output The 3-tuple  (latitude, longitude, altitude)  in geographic coordinates, for the body with specified equatorial and polar radii (Earth by default). If geodetic coordinates are given as arrays, a 3-tuple of arrays of the same length is returned. Method Stephen P.  Keeler and Yves Nievergelt, \"Computing geodetic coordinates\", SIAM Rev. Vol. 40, No. 2, pp. 300-309, June 1998 (DOI: 10.1137/S0036144597323921 ). Planetary constants from \"Allen's Astrophysical Quantities\", Fourth Ed., (2000). Example Find geographic coordinates of geodetic North pole (latitude: 90°, longitude: 0°, altitude 0 km) of the Earth: julia> using AstroLib\n\njulia> geodetic2geo(90, 0, 0)\n(90.0, 0.0, -21.38499999999931) The same for Jupiter: julia> using AstroLib\n\njulia> geodetic2geo(90, 0, 0, \"Jupiter\")\n(90.0, 0.0, -4638.0) Find geographic coordinates for point of geodetic coordinates (latitude, longitude, altitude) = (43.16°, -24.32°, 3.87 km) on a planet with equatorial radius 8724.32 km and polar radius 8619.19 km: julia> using AstroLib\n\njulia> geodetic2geo(43.16, -24.32, 3.87, 8724.32, 8619.19)\n(42.46772711708433, -24.32, -44.52902080669082) Notes geo2geodetic  converts from geographic (or planetographic) to geodetic coordinates. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1590,"pagetitle":"Reference","title":"AstroLib.get_date","ref":"/AstroLib/stable/ref/#AstroLib.get_date-Tuple{Dates.DateTime, Bool, Bool}","content":" AstroLib.get_date  —  Method get_date([date, old=true, timetag=true]) -> string Purpose Returns the UTC date in  \"CCYY-MM-DD\"  format for FITS headers. Explanation This is the format required by the  DATE  and  DATE-OBS  keywords in a FITS header. Argument date  (optional): the date in UTC standard.  If omitted, defaults to the current UTC time.  Each element can be either a  DateTime  type or anything that can be converted to that type.  In the case of vectorial input, each element is considered as a date, so you cannot provide a date by parts. old  (optional boolean keyword): see below. timetag  (optional boolean keyword): see below. Output A string with the date formatted according to the given optional keywords. When no optional keywords ( timetag  and  old ) are supplied, the format of the output string is  \"CCYY-MM-DD\"  (year-month-day part of the date), where  CCYY  represents a 4-digit calendar year,  MM  the 2-digit ordinal number of a calendar month within the calendar year, and  DD  the 2-digit ordinal number of a day within the calendar month. If the boolean keyword  old  is true (default: false), the year-month-day part of date has  \"DD/MM/YY\"  format.  This is the formerly (pre-1997) recommended for FITS.  Note that this format is now deprecated because it uses only a 2-digit representation of the year. If the boolean keyword  timetag  is true (default: false),  \"Thh:mm:ss\"  is appended to the year-month-day part of the date, where <hh> represents the hour in the day, <mm> the minutes, <ss> the seconds, and the literal 'T' the ISO 8601 time designator. Note that  old  and  timetag  keywords can be used together, so that the output string will have  \"DD/MM/YYThh:mm:ss\"  format. Example julia> using AstroLib, Dates\n\njulia> get_date(DateTime(21937, 05, 30, 09, 59, 00), timetag=true)\n\"21937-05-30T09:59:00\" Notes A discussion of the DATExxx syntax in FITS headers can be found in http://www.cv.nrao.edu/fits/documents/standards/year2000.txt Those who wish to use need further flexibility in their date formats (e.g. to use TAI time) should look at Bill Thompson's time routines in http://sohowww.nascom.nasa.gov/solarsoft/gen/idl/time source"},{"id":1591,"pagetitle":"Reference","title":"AstroLib.get_juldate","ref":"/AstroLib/stable/ref/#AstroLib.get_juldate-Tuple{}","content":" AstroLib.get_juldate  —  Method get_juldate() -> julian_days Purpose Return the number of Julian days for current time. Explanation Return for current time the number of Julian calendar days since epoch  -4713-11-24T12:00:00  as a floating point. Example get_juldate()\ndaycnv(get_juldate()) Notes Use  jdcnv  to get the number of Julian days for a different date. source"},{"id":1592,"pagetitle":"Reference","title":"AstroLib.hadec2altaz","ref":"/AstroLib/stable/ref/#AstroLib.hadec2altaz-Tuple{Real, Real, Real}","content":" AstroLib.hadec2altaz  —  Method hadec2altaz(ha, dec, lat[, ws=true]) -> alt, az Purpose Convert Hour Angle and Declination to Horizon (Alt-Az) coordinates. Explanation Can deal with the NCP singularity.  Intended mainly to be used by program  eq2hor . Arguments Input coordinates may be either a scalar or an array, of the same dimension. ha : the local apparent hour angle, in degrees.  The hour angle is the time that right ascension of 0 hours crosses the local meridian.  It is unambiguously defined. dec : the local apparent declination, in degrees. lat : the local geodetic latitude, in degrees, scalar or array. ws  (optional boolean keyword): if true, the output azimuth is measured West from South.  The default is to measure azimuth East from North. ha  and  dec  can be given as a 2-tuple  (ha, dec) . Output 2-tuple  (alt, az) alt : local apparent altitude, in degrees. az : the local apparent azimuth, in degrees. The output coordinates are always floating points and have the same type (scalar or array) as the input coordinates. Example Arcturus is observed at an apparent hour angle of 336.6829 and a declination of 19.1825 while at the latitude of +43° 4' 42''.  What are the local altitude and azimuth of this object? julia> using AstroLib\n\njulia> alt, az = hadec2altaz(336.6829, 19.1825, ten(43, 4, 42))\n(59.08617155005685, 133.3080693440254) Notes altaz2hadec  converts Horizon (Alt-Az) coordinates to Hour Angle and Declination. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1593,"pagetitle":"Reference","title":"AstroLib.helio","ref":"/AstroLib/stable/ref/#AstroLib.helio","content":" AstroLib.helio  —  Function helio(jd, list[, radians=true]) -> hrad, hlong, hlat Purpose Compute heliocentric coordinates for the planets. Explanation The mean orbital elements for epoch J2000 are used. These are derived from a 250 yr least squares fit of the DE 200 planetary ephemeris to a Keplerian orbit where each element is allowed to vary linearly with time. Useful mainly for dates between 1800 and 2050, this solution fits the terrestrial planet orbits to ~25'' or better, but achieves only ~600'' for Saturn. Arguments jd : julian date, scalar or vector num : integer denoting planet number, scalar or vector 1 = Mercury, 2 = Venus, ... 9 = Pluto radians (optional): if this keyword is set to  true , then the longitude and latitude output are in radians rather than degrees. Output hrad : the heliocentric radii, in astronomical units. hlong : the heliocentric (ecliptic) longitudes, in degrees. hlat : the heliocentric latitudes in degrees. Example Find heliocentric position of Venus on August 23, 2000 julia> using AstroLib\n\njulia> helio(jdcnv(2000,08,23,0), 2)\n(0.7213758288364316, 198.39093251916148, 2.887355631705488) Find the current heliocentric positions of all the planets julia> using AstroLib\n\njulia> helio.([jdcnv(1900)], 1:9)\n9-element Vector{Tuple{Float64, Float64, Float64}}:\n (0.4207394142180803, 202.60972662618906, 3.0503005607270532)\n (0.7274605731764012, 344.5381482401048, -3.3924346961624785)\n (0.9832446886519147, 101.54969268801035, 0.012669354526696368)\n (1.4212659241051142, 287.8531100442217, -1.5754626002228043)\n (5.386813769590955, 235.91306092135062, 0.9131692817310215)\n (10.054339927304339, 268.04069870870387, 1.0851704598594278)\n (18.984683376211326, 250.0555468087738, 0.05297087029604253)\n (29.87722677219009, 87.07244903504716, -1.245060583142733)\n (46.9647515992327, 75.94692594417324, -9.576681044165511) Notes This program is based on the two-body model and thus neglects interactions between the planets. The coordinates are given for equinox 2000 and  not  the equinox of the supplied date. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1594,"pagetitle":"Reference","title":"AstroLib.helio_jd","ref":"/AstroLib/stable/ref/#AstroLib.helio_jd-Tuple{Real, Real, Real}","content":" AstroLib.helio_jd  —  Method helio_jd(date, ra, dec[, B1950=true, diff=false]) -> jd_helio\nhelio_jd(date, ra, dec[, B1950=true, diff=true]) -> time_diff Purpose Convert geocentric (reduced) Julian date to heliocentric Julian date. Explanation This procedure corrects for the extra light travel time between the Earth and the Sun. An online calculator for this quantity is available at http://www.physics.sfasu.edu/astro/javascript/hjd.html Users requiring more precise calculations and documentation should look at the IDL code available at http://astroutils.astronomy.ohio-state.edu/time/ Arguments date : reduced Julian date (= JD - 2400000).  You can use  juldate()  to calculate the reduced Julian date. ra  and  dec : right ascension and declination in degrees.  Default equinox is J2000. B1950  (optional boolean keyword): if set to  true , then input coordinates are assumed to be in equinox B1950 coordinates.  Default is  false . diff  (optional boolean keyword): if set to  true , the function returns the time difference (heliocentric JD - geocentric JD) in seconds.  Default is  false . Output The return value depends on the value of  diff  optional keywords: if  diff  is  false  (default), then the heliocentric reduced Julian date is returned. if  diff  is  true , then the time difference in seconds between the geocentric and heliocentric Julian date is returned. Example What is the heliocentric Julian date of an observation of V402 Cygni (J2000: RA = 20 9 7.8, Dec = 37 09 07) taken on June 15, 2016 at 11:40 UT? julia> using AstroLib\n\njulia> jd = juldate(2016, 6, 15, 11, 40);\n\njulia> helio_jd(jd, ten(20, 9, 7.8) * 15, ten(37, 9, 7))\n57554.98808289718 Notes Wayne Warren (Raytheon ITSS) has compared the results of this algorithm with the FORTRAN subroutines in the STARLINK SLALIB library (see http://star-www.rl.ac.uk/).                                                  Time Diff (sec)\n     Date               RA(2000)   Dec(2000)  STARLINK      IDL\n\n1999-10-29T00:00:00.0  21 08 25.  -67 22 00.  -59.0        -59.0\n1999-10-29T00:00:00.0  02 56 33.4 +00 26 55.  474.1        474.1\n1940-12-11T06:55:00.0  07 34 41.9 -00 30 42.  366.3        370.2\n1992-02-29T03:15:56.2  12 56 27.4 +42 10 17.  350.8        350.9\n2000-03-01T10:26:31.8  14 28 36.7 -20 42 11.  243.7        243.7\n2100-02-26T09:18:24.2  08 26 51.7 +85 47 28.  104.0        108.8 Code of this function is based on IDL Astronomy User's Library. source"},{"id":1595,"pagetitle":"Reference","title":"AstroLib.helio_rv","ref":"/AstroLib/stable/ref/#AstroLib.helio_rv","content":" AstroLib.helio_rv  —  Function helio_rv(jd, T, P, V_0, K[, e, ω]) -> rv Purpose Return the heliocentric radial velocity of a spectroscopic binary. Explanation This function will return the heliocentric radial velocity of a spectroscopic binary star at a given heliocentric date given its orbit. Arguments jd : time of observation, as number of Julian days. T : time of periastron passage (max. +ve velocity for circular orbits), same time system as  jd P : the orbital period in same units as  jd V_0 : systemic velocity K : velocity semi-amplitude in the same units as  V_0 e : eccentricity of the orbit.  It defaults to 0 if omitted ω : longitude of periastron in degrees.  It defaults to 0 if omitted Output The predicted heliocentric radial velocity in the same units as Gamma for the date(s) specified by  jd . Example What was the heliocentric radial velocity of the primary component of HU Tau at 1730 UT 25 Oct 1994? julia> using AstroLib\n\njulia> jd = juldate(94, 10, 25, 17, 30); # Obtain Geocentric Julian days\n\njulia> hjd = helio_jd(jd, ten(04, 38, 16) * 15, ten(20, 41, 05)); # Convert to HJD\n\njulia> helio_rv(hjd, 46487.5303, 2.0563056, -6, 59.3)\n-62.965570107789475 NB: the functions  juldate  and  helio_jd  return a reduced HJD (HJD - 2400000) and so T and P must be specified in the same fashion. Plot two cycles of an eccentric orbit,  $e = 0.6$ ,  $ω = 45°$  for both components of a binary star.  Use  Plots.jl  for plotting. using Plots\nφ = range(0, stop=2, length=1000); # Generate 1000 phase points\nplot(φ, helio_rv.(φ, 0, 1, 0, 100, 0.6, 45)) # Plot 1st component\nplot(φ, helio_rv.(φ, 0, 1, 0, 100, 0.6, 45+180)) # Plot 2nd component Notes The user should ensure consistency with all time systems being used (i.e.  jd  and  t  should be in the same units and time system).  Generally, users should reduce large time values by subtracting a large constant offset, which may improve numerical accuracy. If using the the function  juldate  and  helio_jd , the reduced HJD time system must be used throughtout. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1596,"pagetitle":"Reference","title":"AstroLib.hor2eq","ref":"/AstroLib/stable/ref/#AstroLib.hor2eq","content":" AstroLib.hor2eq  —  Function hor2eq(alt, az, jd[, obsname;\n       ws=false, B1950=false, precession=true, nutate=true,\n       aberration=true, refract=true,\n       lat=NaN, lon=NaN, altitude=0,\n       pressure=NaN, temperature=NaN]) -> ra, dec, ha\n\nhor2eq(alt, az, jd, lat, lon[, altitude=0;\n       ws=false, B1950=false, precession=true, nutate=true,\n       aberration=true, refract=true,\n       pressure=NaN, temperature=NaN]) -> ra, dec, ha Purpose Converts local horizon coordinates (alt-az) to equatorial (ra-dec) coordinates. Explanation This is a function to calculate equatorial (ra,dec) coordinates from horizon (alt,az) coords. It is accurate to about 1 arcsecond or better. It performs precession, nutation, aberration, and refraction corrections. Arguments This function has two base methods.  With one you can specify the name of the observatory, if present in  AstroLib.observatories , with the other one you can provide the coordinates of the observing site and, optionally, the altitude. Common mandatory arguments: alt : altitude of horizon coords, in degrees az : azimuth angle measured East from North (unless ws is  true ), in degrees jd : julian date Other positional arguments: obsname : set this to a valid observatory name in  AstroLib.observatories . or lat : north geodetic latitude of location, in degrees. lon : AST longitude of location, in degrees. You can specify west longitude with a negative sign. altitude : the altitude of the observing location, in meters.  It is  0  by default Optional keyword arguments: ws  (optional boolean keyword): set this to  true  to get the azimuth measured westward from south. This is  false  by default B1950  (optional boolean keyword): set this to  true  if the ra and dec are specified in B1950 (FK4 coordinates) instead of J2000 (FK5). This is  false  by default precession  (optional boolean keyword): set this to  false  for no precession,  true  by default nutate  (optional boolean keyword): set this to  false  for no nutation,  true  by default aberration  (optional boolean keyword): set this to  false  for no aberration correction,  true  by default refract  (optional boolean keyword): set this to  false  for no refraction correction,  true  by default pressure  (optional keyword): the pressure at the observing location, in millibars. Default value is  NaN temperature  (optional keyword): the temperature at the observing location, in Kelvins. Default value is  NaN Output ra : right ascension of object, in degrees (FK5) dec : declination of the object, in degrees (FK5) ha : hour angle, in degrees Example You are at Kitt Peak National Observatory, looking at a star at azimuth angle 264d 55m 06s and elevation 37d 54m 41s (in the visible). Today is Dec 25, 2041 and the local time is 10 PM precisely. What is the right ascension and declination (J2000) of the star you're looking at? The temperature here is about 0 Celsius, and the pressure is 781 millibars. The Julian date for this time is 2466879.7083333 julia> using AstroLib\n\njulia> ra_o, dec_o = hor2eq(ten(37,54,41), ten(264,55,06), 2466879.7083333,\n                            \"kpno\", pressure = 781, temperature = 273)\n(3.3224480269254713, 15.19061543702944, 54.61174536229464)\n\njulia> adstring(ra_o, dec_o)\n\" 00 13 17.4  +15 11 26\" Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1597,"pagetitle":"Reference","title":"AstroLib.imf","ref":"/AstroLib/stable/ref/#AstroLib.imf-Tuple{AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}}","content":" AstroLib.imf  —  Method imf(mass, expon, mass_range) -> psi Purpose Compute an N-component power-law logarithmic initial mass function (IMF). Explanation The function is normalized so that the total mass distribution equals one solar mass. Arguments mass : mass in units of solar mass, vector. expon : power law exponent, vector. The number of values in expon equals the number of different power-law components in the IMF. mass_range : vector containing the mass upper and lower limits of the IMF and masses where the IMF exponent changes. The number of values in mass range should be one more than in expon. The values in mass range should be monotonically increasing and positive. Output psi : mass function, number of stars per unit logarithmic mass interval evaluated for supplied masses. Example Show the number of stars per unit mass interval at 3 Msun for a Salpeter (expon = -1.35) IMF, with a mass range from 0.1 MSun to 110 Msun. julia> using AstroLib\n\njulia> imf([3], [-1.35], [0.1, 110]) / 3\n1-element Vector{Float64}:\n 0.01294143518151214 Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1598,"pagetitle":"Reference","title":"AstroLib.ismeuv","ref":"/AstroLib/stable/ref/#AstroLib.ismeuv","content":" AstroLib.ismeuv  —  Function ismeuv(wave, hcol[, he1col=hcol*0.1, he2col=0, fano=false]) -> tau Purpose Compute the continuum interstellar EUV optical depth Explanation The EUV optical depth is computed from the photoionization of hydrogen and helium. Arguments wave : wavelength value (in Angstroms). Useful range is 40 - 912 A; at shorter wavelength metal opacity should be considered, at longer wavelengths there is no photoionization. hcol : interstellar hydrogen column density in cm-2. he1col  (optional): neutral helium column density in cm-2. Default is 0.1*hcol (10% of hydrogen column) he2col  (optional): ionized helium column density in cm-2 Default is 0. fano  (optional boolean keyword): If this keyword is true, then the 4 strongest auto-ionizing resonances of He I are included. The shape of these resonances is given by a Fano profile - see Rumph, Bowyer, & Vennes 1994, AJ, 107, 2108. If these resonances are included then the input wavelength vector should have a fine (>~0.01 A) grid between 190 A and 210 A, since the resonances are very narrow. Output tau : Vector giving resulting optical depth, non-negative values. Example One has a model EUV spectrum with wavelength, w (in Angstroms). Find the EUV optical depth by 1e18 cm-2 of HI, with N(HeI)/N(HI) = N(HeII)/N(HI) = 0.05. julia> using AstroLib\n\njulia> ismeuv.([670, 910], 1e19, 5e17, 5e17)\n2-element Vector{Float64}:\n 27.35393320556168\n 62.683796028917286 Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1599,"pagetitle":"Reference","title":"AstroLib.jdcnv","ref":"/AstroLib/stable/ref/#AstroLib.jdcnv-Tuple{Dates.DateTime}","content":" AstroLib.jdcnv  —  Method jdcnv(date) -> julian_days Purpose Convert proleptic Gregorian Calendar date in UTC standard to number of Julian days. Explanation Takes the given proleptic Gregorian date in UTC standard and returns the number of Julian calendar days since epoch  -4713-11-24T12:00:00 . Argument date : date in proleptic Gregorian Calendar.  Each element can be either a  DateTime  or anything that can be converted directly to  DateTime . Output Number of Julian days, as a floating point. Example Find the Julian days number at 2016 August 23, 03:39:06. julia> using AstroLib, Dates\n\njulia> jdcnv(DateTime(2016, 08, 23, 03, 39, 06))\n2.4576236521527776e6\n\njulia> jdcnv(2016, 08, 23, 03, 39, 06)\n2.4576236521527776e6\n\njulia> jdcnv(\"2016-08-23T03:39:06\")\n2.4576236521527776e6 Notes This is the inverse of  daycnv . get_juldate  returns the number of Julian days for current time.  It is equivalent to  jdcnv(now(Dates.UTC)) . For the conversion of Julian date to number of Julian days, use  juldate . source"},{"id":1600,"pagetitle":"Reference","title":"AstroLib.jprecess","ref":"/AstroLib/stable/ref/#AstroLib.jprecess","content":" AstroLib.jprecess  —  Function jprecess(ra, dec[, epoch]) -> ra2000, dec2000\njprecess(ra, dec, muradec[, parallax=parallax, radvel=radvel]) -> ra2000, dec2000 Purpose Precess positions from B1950.0 (FK4) to J2000.0 (FK5). Explanation Calculate the mean place of a star at J2000.0 on the FK5 system from the mean place at B1950.0 on the FK4 system. jprecess  function has two methods, one for each of the following cases: the proper motion is known and non-zero the proper motion is unknown or known to be exactly zero (i.e. extragalactic radio sources).  Better precision can be achieved in this case by inputting the epoch of the original observations. Arguments The function has 2 methods.  The common mandatory arguments are: ra : input B1950 right ascension, in degrees. dec : input B1950 declination, in degrees. The two methods have a different third argument (see \"Explanation\" section for more details).  It can be one of the following: muradec : 2-element vector containing the proper motion in seconds of arc per tropical  century  in right ascension and declination. epoch : scalar giving epoch of original observations. If none of these two arguments is provided (so  jprecess  is fed only with right ascension and declination), it is assumed that proper motion is exactly zero and  epoch = 1950 . If it is used the method involving  muradec  argument, the following keywords are available: parallax  (optional numerical keyword): stellar parallax, in seconds of arc. radvel  (optional numerical keyword): radial velocity in km/s. Right ascension and declination can be passed as the 2-tuple  (ra, dec) .  You can also pass  ra ,  dec ,  parallax , and  radvel  as arrays, all of the same length N.  In that case,  muradec  should be a matrix 2×N. Output The 2-tuple of right ascension and declination in 2000, in degrees, of input coordinates is returned.  If  ra  and  dec  (and other possible optional arguments) are arrays, the 2-tuple of arrays  (ra2000, dec2000)  of the same length as the input coordinates is returned. Method The algorithm is taken from the Explanatory Supplement to the Astronomical Almanac 1992, page 184.  See also Aoki et al (1983), A&A, 128, 263.  URL: http://adsabs.harvard.edu/abs/1983A%26A...128..263A. Example The SAO catalogue gives the B1950 position and proper motion for the star HD 119288.   Find the J2000 position. RA(1950) = 13h 39m 44.526s Dec(1950) = 8d 38' 28.63'' Mu(RA) = -.0259 s/yr Mu(Dec) = -.093 ''/yr julia> using AstroLib\n\njulia> muradec = 100 * [-15*0.0259, -0.093]; # convert to century proper motion\n\njulia> ra = ten(13, 39, 44.526)*15;\n\njulia> decl = ten(8, 38, 28.63);\n\njulia> adstring(jprecess(ra, decl, muradec), precision=2)\n\" 13 42 12.740  +08 23 17.69\" Notes \"When transferring individual observations, as opposed to catalog mean place, the safest method is to tranform the observations back to the epoch of the observation, on the FK4 system (or in the system that was used to to produce the observed mean place), convert to the FK5 system, and transform to the the epoch and equinox of J2000.0\" – from the Explanatory Supplement (1992), p. 180 bprecess  performs the precession to B1950 coordinates. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1601,"pagetitle":"Reference","title":"AstroLib.juldate","ref":"/AstroLib/stable/ref/#AstroLib.juldate-Tuple{Dates.DateTime}","content":" AstroLib.juldate  —  Method juldate(date::DateTime) -> reduced_julia_days Purpose Convert from calendar to Reduced Julian Days. Explanation Julian Day Number is a count of days elapsed since Greenwich mean noon on 1 January 4713 B.C.  Julian Days are the number of Julian days followed by the fraction of the day elapsed since the preceding noon. This function takes the given  date  and returns the number of Julian calendar days since epoch  1858-11-16T12:00:00  (Reduced Julian Days = Julian Days - 2400000). Argument date : date in Julian Calendar, UTC standard.  Each element can be given in  DateTime  type or anything that can be converted to that type. Output The number of Reduced Julian Days is returned. Example Get number of Reduced Julian Days at 2016-03-20T15:24:00. julia> using AstroLib, Dates\n\njulia> juldate(DateTime(2016, 03, 20, 15, 24))\n57468.14166666667\n\njulia> juldate(2016, 03, 20, 15, 24)\n57468.14166666667\n\njulia> juldate(\"2016-03-20T15:24\")\n57468.14166666667 Notes Julian Calendar is assumed, thus before  1582-10-15T00:00:00  this function is  not  the inverse of  daycnv .  For the conversion proleptic Gregorian date to number of Julian days, use  jdcnv , which is the inverse of  daycnv . Code of this function is based on IDL Astronomy User's Library. source"},{"id":1602,"pagetitle":"Reference","title":"AstroLib.kepler_solver","ref":"/AstroLib/stable/ref/#AstroLib.kepler_solver","content":" AstroLib.kepler_solver  —  Function kepler_solver(M, e) -> E Purpose Solve Kepler's equation in the elliptic motion regime ( $0 ≤ e ≤ 1$ ) and return eccentric anomaly  $E$ . Explanation In order to find the position of a body in elliptic motion (e.g., in the two-body problem) at a given time  $t$ , one has to solve the  Kepler's equation \\[M(t) = E(t) - e \\sin E(t)\\] where  $M(t) = (t - t_0)/P$  is the mean anomaly,  $E(t)$  the eccentric anomaly,  $e$  the eccentricity of the orbit,  $t_0$  is the time of periapsis passage, and  $P$  is the period of the orbit.  Usually the eccentricity is given and one wants to find the eccentric anomaly  $E(t)$  at a specific time  $t$ , so that also the mean anomaly  $M(t)$  is known. Arguments M : mean anomaly. e : eccentricity, in the elliptic motion regime ( $0 ≤ e ≤ 1$ ) Output The eccentric anomaly  $E$ , restricted to the range  $[-π, π]$ . Method Many different numerical methods exist to solve Kepler's equation.  This function implements the algorithm proposed in Markley (1995) Celestial Mechanics and Dynamical Astronomy, 63, 101 (DOI: 10.1007/BF00691917 ).  This method is not iterative, requires only four transcendental function evaluations, and has been proved to be fast and efficient over the entire range of elliptic motion  $0 ≤ e ≤ 1$ . Example Find the eccentric anomaly for an orbit with eccentricity  $e = 0.7$  and for  $M(t) = 8π/3$ . julia> using AstroLib\n\njulia> ecc = 0.7;\n\njulia> E = kepler_solver(8pi/3, ecc)\n2.5085279492864223 Plot the eccentric anomaly as a function of mean anomaly for eccentricity  $e = 0, 0.5, 0.9$ .  Recall that  kepler_solver  gives  $E ∈ [-π, π]$ , use  mod2pi  to have it in  $[0, 2π]$ .  Use  Plots.jl  for plotting. using AstroLib\nusing Plots\nM = range(0, stop=2pi, length=1001)[1:end-1];\nfor ecc in (0, 0.5, 0.9)\n    plot(M, mod2pi.(kepler_solver.(M, ecc)))\nend Notes The true anomaly can be calculated with  trueanom  function. source"},{"id":1603,"pagetitle":"Reference","title":"AstroLib.lsf_rotate","ref":"/AstroLib/stable/ref/#AstroLib.lsf_rotate","content":" AstroLib.lsf_rotate  —  Function lsf_rotate(delta_v, v_sin_i[, epsilon = 0.3]) -> velocity_grid, lsf Purpose Create a 1-d convolution kernel to broaden a spectrum from a rotating star. Explanation Can be used to derive the broadening effect (LSF, line spread function) due to rotation on a synthetic stellar spectrum.  Assumes constant limb darkening across the disk. Arguments delta_v : the step increment (in km/s) in the output rotation kernel v_sin_i : the rotational velocity projected along the line of sight (km/s) epsilon  (optional numeric argument): the limb-darkening coefficient, default = 0.6 which is typical for photospheric lines.  The specific intensity  $I$  at any angle  $θ$  from the specific intensity  $I_{\\text{cen}}$  at the center of the disk is given by: \\[I = I_{\\text{cen}} ⋅ (1 - ε ⋅ (1 - \\cos(θ)))\\] Output The 2-tuple ( velocity_grid ,  lsf ): velocity_grid : vector of velocity grid with the same number of elements as  lsf  (see below) lsf : the convolution kernel vector for the specified rotational velocity. The number of points in  lsf  will be always be odd (the kernel is symmetric) and equal to either  ceil(2*v_sin_i/delta_v)  or  ceil(2*v_sin_i/delta_v) + 1 , whichever number is odd.  Elements of  lsf  will always be of type  AbstractFloat .  To actually compute the broadening, the spectrum should be convolved with the rotational  lsf Example Plot the line spread function for a star rotating at 90 km/s in velocity space every 3 km/s.  Use  Plots.jl  for plotting. using Plots\nplot(lsf_rotate(3, 90)...) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1604,"pagetitle":"Reference","title":"AstroLib.mag2flux","ref":"/AstroLib/stable/ref/#AstroLib.mag2flux","content":" AstroLib.mag2flux  —  Function mag2flux(mag[, zero_point, ABwave=number]) -> flux Purpose Convert from magnitudes to flux expressed in erg/(s cm² Å). Explanation This is the reverse of  flux2mag . Arguments mag : the magnitude to be converted in flux. zero_point : the zero point level of the magnitude.  If not supplied then defaults to 21.1 (Code et al 1976).  Ignored if the  ABwave  keyword is supplied ABwave  (optional numeric keyword): wavelength, in Angstroms.  If supplied, then the input  mag  is assumed to contain Oke AB magnitudes (Oke & Gunn 1983, ApJ, 266, 713; http://adsabs.harvard.edu/abs/1983ApJ...266..713O). Output The flux. If the  ABwave  keyword is set, then the flux is given by the expression \\[\\text{flux} = 10^{-0.4(\\text{mag} +2.406 + 4\\log_{10}(\\text{ABwave}))}\\] Otherwise the flux is given by \\[\\text{flux} =  10^{-0.4(\\text{mag} + \\text{zero point})}\\] Example julia> using AstroLib\n\njulia> mag2flux(8.3)\n1.7378008287493692e-12\n\njulia> mag2flux(8.3, 12)\n7.58577575029182e-9\n\njulia> mag2flux(8.3, ABwave=12)\n3.624411568301719e-7 Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1605,"pagetitle":"Reference","title":"AstroLib.mag2geo","ref":"/AstroLib/stable/ref/#AstroLib.mag2geo","content":" AstroLib.mag2geo  —  Function mag2geo(latitude, longitude[, year]) -> geographic_latitude, geographic_longitude Purpose Convert from geomagnetic to geographic coordinates. Explanation Converts from geomagnetic (latitude, longitude) to geographic (latitude, longitude).  Altitude is not involved in this function. Arguments latitude : geomagnetic latitude (North), in degrees. longitude : geomagnetic longitude (East), in degrees. year  (optional numerical argument): the year in which to perform conversion. If omitted, defaults to current year. The coordinates can be passed as arrays of the same length. Output The 2-tuple of geographic (latitude, longitude) coordinates, in degrees. If geomagnetic coordinates are given as arrays, a 2-tuple of arrays of the same length is returned. Example Find position of North Magnetic Pole in 2016 julia> using AstroLib\n\njulia> mag2geo(90, 0, 2016)\n(86.395, -166.29000000000002) Notes This function uses list of North Magnetic Pole positions provided by World Magnetic Model (https://www.ngdc.noaa.gov/geomag/data/poles/NP.xy). geo2mag  converts geographic coordinates to geomagnetic coordinates. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1606,"pagetitle":"Reference","title":"AstroLib.mean_obliquity","ref":"/AstroLib/stable/ref/#AstroLib.mean_obliquity-Tuple{Real}","content":" AstroLib.mean_obliquity  —  Method mean_obliquity(jd) -> m_eps Purpose Return the mean obliquity of the ecliptic for a given Julian date Explanation The function is used by the  co_nutate  procedure. Arguments jd : julian date Output m_eps : mean obliquity of the ecliptic, in radians Example julia> using AstroLib\n\njulia> mean_obliquity(jdcnv(1978,01,7,11, 01))\n0.4091425159336512 Notes The algorithm used to find the mean obliquity( eps0 ) is mentioned in USNO Circular 179, but the canonical reference for the IAU adoption is apparently Hilton et al., 2006, Celest.Mech.Dyn.Astron. 94, 351. 2000 source"},{"id":1607,"pagetitle":"Reference","title":"AstroLib.month_cnv","ref":"/AstroLib/stable/ref/#AstroLib.month_cnv-Tuple{Integer}","content":" AstroLib.month_cnv  —  Method month_cnv(number[, shor=true, up=true, low=true]) -> month_name\nmonth_cnv(name) -> number Purpose Convert between a month English name and  the equivalent number. Explanation For example, converts from \"January\" to 1  or vice-versa. Arguments The functions has two methods, one with numeric input (and three possible boolean keywords) and the other one with string input. Numeric input arguments: number : the number of the month to be converted to month name. short  (optional boolean keyword): if true, the abbreviated (3-character) name of the month will be returned, e.g. \"Apr\" or \"Oct\".  Default is false. up  (optional boolean keyword): if true, the name of the month will be all in upper case, e.g. \"APRIL\" or \"OCTOBER\".  Default is false. low  (optional boolean keyword): if true, the name of the month will be all in lower case, e.g. \"april\" or \"october\".  Default is false. String input argument: name : month name to be converted to month number. Output The month name or month number, depending on the input.  For numeric input, the format of the month name is influenced by the optional keywords. Example julia> using AstroLib\n\njulia> month_cnv.([\"janua\", \"SEP\", \"aUgUsT\"])\n3-element Vector{Int64}:\n 1\n 9\n 8\n\njulia> month_cnv.([2, 12, 6], short=true, low=true)\n3-element Vector{String}:\n \"feb\"\n \"dec\"\n \"jun\" source"},{"id":1608,"pagetitle":"Reference","title":"AstroLib.moonpos","ref":"/AstroLib/stable/ref/#AstroLib.moonpos","content":" AstroLib.moonpos  —  Function moonpos(jd[, radians=true]) -> ra, dec, dis, geolong, geolat Purpose Compute the right ascension and declination of the Moon at specified Julian date. Arguments jd : the Julian ephemeris date.  It can be either a scalar or an array radians  (optional boolean keyword): if set to  true , then all output angular quantities are given in radians rather than degrees.  The default is  false Output The 5-tuple  (ra, dec, dis, geolong, geolat) : ra : apparent right ascension of the Moon in degrees, referred to the true equator of the specified date(s) dec : the declination of the Moon in degrees dis : the distance between the centre of the Earth and the centre of the Moon in kilometers geolong : apparent longitude of the moon in degrees, referred to the ecliptic of the specified date(s) geolat : apparent longitude of the moon in degrees, referred to the ecliptic of the specified date(s) If  jd  is an array, then all output quantities are arrays of the same length as  jd . Method Derived from the Chapront ELP2000/82 Lunar Theory (Chapront-Touze' and Chapront, 1983, 124, 50), as described by Jean Meeus in Chapter 47 of ``Astronomical Algorithms'' (Willmann-Bell, Richmond), 2nd edition, 1998.  Meeus quotes an approximate accuracy of 10\" in longitude and 4\" in latitude, but he does not give the time range for this accuracy. Comparison of the IDL procedure with the example in ``Astronomical Algorithms'' reveals a very small discrepancy (~1 km) in the distance computation, but no difference in the position calculation. Example Find the position of the moon on April 12, 1992 julia> using AstroLib\n\njulia> jd = jdcnv(1992, 4, 12);\n\njulia> adstring(moonpos(jd)[1:2],precision=1)\n\" 08 58 45.23  +13 46 06.1\" This is within 1\" from the position given in the Astronomical Almanac. Plot the Earth-moon distance during 2016 with sampling of 6 hours.  Use  Plots.jl  for plotting using Dates\nusing Plots\npoints = DateTime(2016):Dates.Hour(6):DateTime(2017);\nplot(points, moonpos(jdcnv.(points))[3]) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1609,"pagetitle":"Reference","title":"AstroLib.mphase","ref":"/AstroLib/stable/ref/#AstroLib.mphase-Tuple{Real}","content":" AstroLib.mphase  —  Method mphase(jd) -> k Purpose Return the illuminated fraction of the Moon at given Julian date(s). Arguments jd : the Julian ephemeris date. Output The illuminated fraction  $k$  of Moon's disk, with  $0 ≤ k ≤ 1$ .  $k = 0$  indicates a new moon, while  $k = 1$  stands for a full moon. Method Algorithm from Chapter 46 of \"Astronomical Algorithms\" by Jean Meeus (Willmann-Bell, Richmond) 1991.   sunpos  and  moonpos  are used to get positions of the Sun and the Moon, and the Moon distance.  The selenocentric elongation of the Earth from the Sun (phase angle) is then computed, and used to determine the illuminated fraction. Example Plot the illuminated fraction of the Moon for every day in January 2018 with a hourly sampling.  Use  Plots.jl  for plotting using Dates\nusing Plots\npoints = DateTime(2018,01,01):Dates.Hour(1):DateTime(2018,01,31,23,59,59);\nplot(points, mphase.(jdcnv.(points))) Note that in this calendar month there are two full moons, this event is called  blue moon . Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1610,"pagetitle":"Reference","title":"AstroLib.nutate","ref":"/AstroLib/stable/ref/#AstroLib.nutate-Tuple{Real}","content":" AstroLib.nutate  —  Method nutate(jd) -> long, obliq Purpose Return the nutation in longitude and obliquity for a given Julian date. Arguments jd : Julian ephemeris date, it can be either a scalar or a vector Output The 2-tuple  (long, obliq) , where long : the nutation in longitude obl : the nutation in latitude If  jd  is an array,  long  and  obl  are arrays of the same length. Method Uses the formula in Chapter 22 of \"Astronomical Algorithms\" by Jean Meeus (1998, 2nd ed.) which is based on the 1980 IAU Theory of Nutation and includes all terms larger than 0.0003\". Example Find the nutation in longitude and obliquity 1987 on Apr 10 at 0h.  This is example 22.a from Meeus julia> using AstroLib\n\njulia> jd = jdcnv(1987, 4, 10);\n\njulia> nutate(jd)\n(-3.787931077110494, 9.44252069864449) Plot the daily nutation in longitude and obliquity during the 21st century. Use  Plots.jl  for plotting. using Dates\nusing Plots\nyears = DateTime(2000):DateTime(2100);\nlong, obl = nutate(jdcnv.(years));\nplot(years, long); plot(years, obl) You can see both the dominant large scale period of nutation, of 18.6 years, and smaller oscillations with shorter periods. Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1611,"pagetitle":"Reference","title":"AstroLib.ordinal","ref":"/AstroLib/stable/ref/#AstroLib.ordinal-Tuple{Integer}","content":" AstroLib.ordinal  —  Method ordinal(num) -> result Purpose Convert an integer to a correct English ordinal string. Explanation The first four ordinal strings are \"1st\", \"2nd\", \"3rd\", \"4th\", .... Arguments num : number to be made ordinal. It should be of type  Integer . Output result : ordinal string, such as \"1st\", \"3rd\", \"164th\", \"87th\", etc. Example julia> using AstroLib\n\njulia> ordinal.(1:5)\n5-element Vector{String}:\n \"1st\"\n \"2nd\"\n \"3rd\"\n \"4th\"\n \"5th\" Notes This function does not support float arguments, unlike the IDL implementation. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1612,"pagetitle":"Reference","title":"AstroLib.paczynski","ref":"/AstroLib/stable/ref/#AstroLib.paczynski-Tuple{Real}","content":" AstroLib.paczynski  —  Method paczynski(u) -> amplification Purpose Calculate gravitational microlensing amplification of a point-like source by a single point-like lens. Explanation Return the  gravitational microlensing  amplification of a point-like source by a single point-like lens, using Paczyński formula \\[A(u) = \\frac{u^2 + 2}{u\\sqrt{u^2 + 4}}\\] where  $u$  is the projected distance between the lens and the source in units of  Einstein radii . In order to speed up calculations for extreme values of  $u$ , the following asyntotic expressions for  $A(u)$  are used: \\[A(u) =\n\\begin{cases}\n 1/u & |u| ≪ 1 \\\\\n \\text{sgn}(u) & |u| ≫ 1\n\\end{cases}\\] Arguments u : projected distance between the lens and the source, in units of Einstein radii Output The microlensing amplification for the given distance. Example Calculate the microlensing amplification for  $u = 10^{-10}, 10^{-1}, 1, 10, 10^{10}$ : julia> paczynski.([1e-10, 1e-1, 1, 10, 1e10])\n5-element Vector{Float64}:\n  1.0e10\n 10.037461005722337\n  1.3416407864998738\n  1.0001922892047386\n  1.0 Notes The expression of  $A(u)$  of microlensing amplification has been given by Bohdan Paczyński in Paczynski, B. 1986, ApJ, 304, 1. DOI: 10.1086/164140 , Bibcode: 1986ApJ...304....1P The same expression was actually found by Albert Einstein half a century earlier: Einstein, A. 1936, Science, 84, 506. DOI: 10.1126/science.84.2188.506 , Bibcode: 1936Sci....84..506E source"},{"id":1613,"pagetitle":"Reference","title":"AstroLib.planck_freq","ref":"/AstroLib/stable/ref/#AstroLib.planck_freq-Tuple{Real, Real}","content":" AstroLib.planck_freq  —  Method planck_freq(frequency, temperature) -> black_body_flux Purpose Calculate the flux of a black body per unit frequency. Explanation Return the spectral radiance of a black body per unit frequency using  Planck's law \\[B_\\nu(\\nu, T) = \\frac{2h\\nu^3}{c^2} \\frac{1}{e^\\frac{h\\nu}{k_\\mathrm{B}T} - 1}\\] Arguments frequency : frequency at which the flux is to be calculated, in Hertz. temperature : the equilibrium temperature of the black body, in Kelvin. Output The spectral radiance of the black body, in units of W/(sr·m²·Hz). Example Plot the spectrum of a black body in  $[10^{12}, 10^{15.4}]$  Hz at 8000 K. Use  Plots.jl  for plotting. using Plots\nfrequency = exp10.(range(12, stop=15.4, length=1000));\ntemperature = ones(size(frequency)) * 8000;\nflux = planck_freq.(frequency, temperature);\nplot(frequency, flux) Notes planck_wave  calculates the flux of a black body per unit wavelength. source"},{"id":1614,"pagetitle":"Reference","title":"AstroLib.planck_wave","ref":"/AstroLib/stable/ref/#AstroLib.planck_wave-Tuple{Real, Real}","content":" AstroLib.planck_wave  —  Method planck_wave(wavelength, temperature) -> black_body_flux Purpose Calculate the flux of a black body per unit wavelength. Explanation Return the spectral radiance of a black body per unit wavelength using  Planck's law \\[B_λ(λ, T) = \\frac{2hc^2}{λ^5} \\frac{1}{e^{\\frac{hc}{λ k_\\mathrm{B}T}} - 1}\\] Arguments wavelength : wavelength at which the flux is to be calculated, in meters. temperature : the equilibrium temperature of the black body, in Kelvin. Output The spectral radiance of the black body, in units of W/(sr·m³). Example Plot the spectrum of a black body in  $[0, 3]$  µm at  $5000$  K.  Use  Plots.jl  for plotting. using Plots\nwavelength = range(0, stop=3e-6, length=1000);\ntemperature = ones(wavelength)*5000;\nflux = planck_wave.(wavelength, temperature);\nplot(wavelength, flux) Notes planck_freq  calculates the flux of a black body per unit frequency. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1615,"pagetitle":"Reference","title":"AstroLib.planet_coords","ref":"/AstroLib/stable/ref/#AstroLib.planet_coords-Tuple{Real, Integer}","content":" AstroLib.planet_coords  —  Method planet_coords(date, num) Purpose Find right ascension and declination for the planets when provided a date as input. Explanation This function uses the  helio  to get the heliocentric ecliptic coordinates of the planets at the given date which it then converts these to geocentric ecliptic coordinates ala \"Astronomical Algorithms\" by Jean Meeus (1991, p 209). These are then converted to right ascension and declination using  euler . The accuracy between the years 1800 and 2050 is better than 1 arcminute for the terrestial planets, but reaches 10 arcminutes for Saturn. Before 1850 or after 2050 the accuracy can get much worse. Arguments date : Can be either a single date or an array of dates. Each element can be either a  DateTime  type or Julian Date. It can be a scalar or vector. num : integer denoting planet number, scalar or vector 1 = Mercury, 2 = Venus, ... 9 = Pluto. If not in that change, then the program will throw an error. Output ra : right ascension of planet(J2000), in degrees dec : declination of the planet(J2000), in degrees Example Find the RA, Dec of Venus on 1992 Dec 20 julia> using AstroLib, Dates\n\njulia> adstring(planet_coords(DateTime(1992,12,20),2))\n\" 21 05 02.8  -18 51 41\" Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1616,"pagetitle":"Reference","title":"AstroLib.polrec","ref":"/AstroLib/stable/ref/#AstroLib.polrec-Tuple{Real, Real}","content":" AstroLib.polrec  —  Method polrec(radius, angle[, degrees=true]) -> x, y Purpose Convert 2D polar coordinates to rectangular coordinates. Explanation This is the partial inverse function of  recpol . Arguments radius : radial coordinate of the point.  It may be a scalar or an array. angle : the angular coordinate of the point.  It may be a scalar or an array of the same lenth as  radius . degrees  (optional boolean keyword): if  true , the  angle  is assumed to be in degrees, otherwise in radians.  It defaults to  false . Mandatory arguments can also be passed as the 2-tuple  (radius, angle) , so that it is possible to execute  recpol(polrec(radius, angle)) . Output A 2-tuple  (x, y)  with the rectangular coordinate of the input.  If  radius  and  angle  are arrays,  x  and  y  are arrays of the same length as  radius  and  angle . Example Get rectangular coordinates  $(x, y)$  of the point with polar coordinates  $(r, φ) = (1.7, 227)$ , with angle  $φ$  expressed in degrees. julia> using AstroLib\n\njulia> x, y = polrec(1.7, 227, degrees=true)\n(-1.1593972121062475, -1.2433012927525897) source"},{"id":1617,"pagetitle":"Reference","title":"AstroLib.posang","ref":"/AstroLib/stable/ref/#AstroLib.posang-Tuple{Integer, Vararg{Real, 4}}","content":" AstroLib.posang  —  Method posang(units, ra1, dec1, ra2, dec2) -> angular_distance Purpose Compute rigorous position angle of point 2 relative to point 1. Explanation Computes the rigorous position angle of point 2 (with given right ascension and declination) using point 1 (with given right ascension and declination) as the center. Arguments units : integer, can be either 0, or 1, or 2.  Describes units of inputs and output: 0: everything (input right ascensions and declinations, and output distance) is radians 1: right ascensions are in decimal hours, declinations in decimal degrees, output distance in degrees 2: right ascensions and declinations are in degrees, output distance in degrees ra1 :  right ascension or longitude of point 1 dec1 : declination or latitude of point 1 ra2 : right ascension or longitude of point 2 dec2 : declination or latitude of point 2 Both  ra1  and  dec1 , and  ra2  and  dec2  can be given as 2-tuples  (ra1, dec1)  and  (ra2, dec2) . Output Angle of the great circle containing  [ra2, dec2]  from the meridian containing  [ra1, dec1] , in the sense north through east rotating about  [ra1, dec1] . See  units  argument above for units. Method The \"four-parts formula\" from spherical trigonometry (p. 12 of Smart's Spherical Astronomy or p. 12 of Green' Spherical Astronomy). Example Mizar has coordinates (ra, dec) = (13h 23m 55.5s, +54° 55' 31'').  Its companion, Alcor, has coordinates (ra, dec) = (13h 25m 13.5s, +54° 59' 17''). Find the position angle of Alcor with respect to Mizar. julia> using AstroLib\n\njulia> posang(1, ten(13, 25, 13.5), ten(54, 59, 17), ten(13, 23, 55.5), ten(54, 55, 31))\n-108.46011246802047 Notes The function  sphdist  provides an alternate method of computing a spherical distance. Note that  posang  is not commutative: the position angle between A and B is  $θ$ , then the position angle between B and A is  $180 + θ$ . Code of this function is based on IDL Astronomy User's Library. source"},{"id":1618,"pagetitle":"Reference","title":"AstroLib.precess","ref":"/AstroLib/stable/ref/#AstroLib.precess-NTuple{4, Real}","content":" AstroLib.precess  —  Method precess(ra, dec, equinox1, equinox2[, FK4=true, radians=true]) -> prec_ra, prec_dec Purpose Precess coordinates from  equinox1  to  equinox2 . Explanation The default  (ra, dec)  system is FK5 based on epoch J2000.0 but FK4 based on B1950.0 is available via the  FK4  boolean keyword. Arguments ra : input right ascension, scalar or vector, in degrees, unless the  radians  keyword is set to  true dec : input declination, scalar or vector, in degrees, unless the  radians  keyword is set to  true equinox1 : original equinox of coordinates, numeric scalar. equinox2 : equinox of precessed coordinates. FK4  (optional boolean keyword): if this keyword is set to  true , the FK4 (B1950.0) system precession angles are used to compute the precession matrix. When it is  false , the default, use FK5 (J2000.0) precession angles. radians  (optional boolean keyword): if this keyword is set to  true , then the input and output right ascension and declination vectors are in radians rather than degrees. Output The 2-tuple  (ra, dec)  of coordinates modified by precession. Example The Pole Star has J2000.0 coordinates (2h, 31m, 46.3s, 89d 15' 50.6\"); compute its coordinates at J1985.0 julia> using AstroLib\n\njulia> ra, dec = ten(2,31,46.3)*15, ten(89,15,50.6)\n(37.94291666666666, 89.26405555555556)\n\njulia> adstring(precess(ra, dec, 2000, 1985), precision=1)\n\" 02 16 22.73  +89 11 47.3\" Precess the B1950 coordinates of Eps Ind (RA = 21h 59m,33.053s, DEC = -56d, 59', 33.053\") to equinox B1975. julia> using AstroLib\n\njulia> ra, dec = ten(21, 59, 33.053) * 15, ten(-56, 59, 33.053)\n(329.88772083333333, -56.992514722222225)\n\njulia> adstring(precess(ra, dec, 1950, 1975, FK4=true), precision=1)\n\" 22 01 15.46  -56 52 18.7\" Method Algorithm from \"Computational Spherical Astronomy\" by Taff (1983), p. 24. (FK4). FK5 constants from \"Explanatory Supplement To The Astronomical Almanac\" 1992, page 104 Table 3.211.1 (https://archive.org/details/131123ExplanatorySupplementAstronomicalAlmanac). Notes Accuracy of precession decreases for declination values near 90 degrees.  precess  should not be used more than 2.5 centuries from 2000 on the FK5 system (1950.0 on the FK4 system).  If you need better accuracy, use  bprecess  or  jprecess  as needed. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1619,"pagetitle":"Reference","title":"AstroLib.precess_cd","ref":"/AstroLib/stable/ref/#AstroLib.precess_cd","content":" AstroLib.precess_cd  —  Function precess_cd(cd, epoch1, epoch2, crval_old, crval_new[, FK4=true]) -> cd Purpose Precess the coordinate description matrix. Explanation The coordinate matrix is precessed from epoch1 to epoch2. Arguments cd : 2×2 coordinate description matrix in degrees epoch1 : original equinox of coordinates, scalar epoch2 : equinox of precessed coordinates, scalar crval_old : 2 element vector containing right ascension and declination in degrees of the reference pixel in the original equinox crval_new : 2 element vector giving crval in the new equinox FK4  (optional boolean keyword): if this keyword is set to  true , then the precession constants are taken in the FK4 reference frame. When it is  false , the default is the FK5 frame Output cd : coordinate description containing precessed values Example julia> using AstroLib\n\njulia> precess_cd([20 60; 45 45], 1950, 2000, [34, 58], [12, 83])\n2×2 Matrix{Float64}:\n  48.8944  147.075\n 110.188   110.365 Notes Code of this function is based on IDL Astronomy User's Library. This function should not be used for values more than 2.5 centuries from the year 1900. This function calls  sec2rad ,  precess  and  bprecess . source"},{"id":1620,"pagetitle":"Reference","title":"AstroLib.precess_xyz","ref":"/AstroLib/stable/ref/#AstroLib.precess_xyz-NTuple{5, Real}","content":" AstroLib.precess_xyz  —  Method precess_xyz(x, y, z, equinox1, equinox2) -> prec_x, prec_y, prec_z Purpose Precess equatorial geocentric rectangular coordinates. Arguments x ,  y ,  z : scalars or vectors giving heliocentric rectangular coordinates. equinox1 : original equinox of coordinates, numeric scalar. equinox2 : equinox of precessed coordinates, numeric scalar. Input coordinates can be given also a 3-tuple  (x, y, z) . Output The 3-tuple  (x, y, z)  of coordinates modified by precession. Example Precess 2000 equinox coordinates  (1, 1, 1)  to 2050. julia> using AstroLib\n\njulia> precess_xyz(1, 1, 1, 2000, 2050)\n(0.9838854500981734, 1.0110925876508692, 1.0048189888146941) Method The equatorial geocentric rectangular coordinates are converted to right ascension and declination, precessed in the normal way, then changed back to  x ,  y  and  z  using unit vectors. Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1621,"pagetitle":"Reference","title":"AstroLib.premat","ref":"/AstroLib/stable/ref/#AstroLib.premat-Tuple{Real, Real}","content":" AstroLib.premat  —  Method premat(equinox1, equinox2[, FK4=true]) -> precession_matrix Purpose Return the precession matrix needed to go from  equinox1  to  equinox2 . Explanation This matrix is used by  precess  and  baryvel  to precess astronomical coordinates. Arguments equinox1 : original equinox of coordinates. equinox2 : equinox of precessed coordinates. FK4  (optional boolean keyword): if this keyword is set to  true , the FK4 (B1950.0) system precession angles are used to compute the precession matrix. When it is  false , the default, use FK5 (J2000.0) precession angles. Output A 3×3 matrix, used to precess equatorial rectangular coordinates. Example Return the precession matrix from 1950.0 to 1975.0 in the FK4 system julia> using AstroLib\n\njulia> premat(1950, 1975, FK4=true)\n3×3 StaticArraysCore.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n 0.999981    -0.00558775  -0.00242909\n 0.00558775   0.999984    -6.78691e-6\n 0.00242909  -6.78633e-6   0.999997 Method FK4 constants from \"Computational Spherical Astronomy\" by Taff (1983), p. 24. (FK4). FK5 constants from \"Explanatory Supplement To The Astronomical Almanac\" 1992, page 104 Table 3.211.1 (https://archive.org/details/131123ExplanatorySupplementAstronomicalAlmanac). Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1622,"pagetitle":"Reference","title":"AstroLib.rad2sec","ref":"/AstroLib/stable/ref/#AstroLib.rad2sec-Tuple{Real}","content":" AstroLib.rad2sec  —  Method rad2sec(rad) -> seconds Purpose Convert from radians to seconds. Argument rad : number of radians. Output The number of seconds corresponding to  rad . Example julia> using AstroLib\n\njulia> rad2sec(1)\n206264.80624709636 Notes Use  sec2rad  to convert seconds to radians. source"},{"id":1623,"pagetitle":"Reference","title":"AstroLib.radec","ref":"/AstroLib/stable/ref/#AstroLib.radec-Tuple{Real, Real}","content":" AstroLib.radec  —  Method radec(ra::Real, dec::Real[, hours=false]) -> ra_hours, ra_minutes, ra_seconds, dec_degrees, dec_minutes, dec_seconds Purpose Convert right ascension and declination from decimal to sexagesimal units. Explanation The conversion is to sexagesimal hours for right ascension, and sexagesimal degrees for declination. Arguments ra : decimal right ascension, scalar or array.  It is expressed in degrees, unless the optional keyword  hours  is set to  true . dec : declination in decimal degrees, scalar or array, same number of elements as  ra . hours  (optional boolean keyword): if  false  (the default),  ra  is assumed to be given in degrees, otherwise  ra  is assumed to be expressed in hours. Output A 6-tuple of  AbstractFloat : (ra_hours, ra_minutes, ra_seconds, dec_degrees, dec_minutes, dec_seconds) If  ra  and  dec  are arrays, also each element of the output 6-tuple are arrays of the same dimension. Example Position of Sirius in the sky is (ra, dec) = (6.7525, -16.7161), with right ascension expressed in hours.  Its sexagesimal representation is given by julia> using AstroLib\n\njulia> radec(6.7525, -16.7161, hours=true)\n(6.0, 45.0, 9.0, -16.0, 42.0, 57.9600000000064) source"},{"id":1624,"pagetitle":"Reference","title":"AstroLib.recpol","ref":"/AstroLib/stable/ref/#AstroLib.recpol-Tuple{Real, Real}","content":" AstroLib.recpol  —  Method recpol(x, y[, degrees=false]) -> radius, angle Purpose Convert 2D rectangular coordinates to polar coordinates. Explanation This is the partial inverse function of  polrec . Arguments x : the abscissa coordinate of the point.  It may be a scalar or an array. y : the ordinate coordinate of the point.  It may be a scalar or an array of the same lenth as  x . degrees  (optional boolean keyword): if  true , the output  angle  is given in degrees, otherwise in radians.  It defaults to  false . Mandatory arguments may also be passed as the 2-tuple  (x, y) , so that it is possible to execute  polrec(recpol(x, y)) . Output A 2-tuple  (radius, angle)  with the polar coordinates of the input.  The coordinate  angle  coordinate lies in the range  $[-π, π]$  if  degrees=false , or  $[-180, 180]$  when  degrees=true . If  x  and  y  are arrays,  radius  and  angle  are arrays of the same length as  radius  and  angle . Example Calculate polar coordinates  $(r, φ)$  of point with rectangular coordinates  $(x, y) = (2.24, -1.87)$ . julia> using AstroLib\n\njulia> r, phi = recpol(2.24, -1.87)\n(2.9179616172938263, -0.6956158538564537) Angle  $φ$  is given in radians. source"},{"id":1625,"pagetitle":"Reference","title":"AstroLib.rhotheta","ref":"/AstroLib/stable/ref/#AstroLib.rhotheta-NTuple{8, Real}","content":" AstroLib.rhotheta  —  Method rhotheta(period, periastron, eccentricity, semimajor_axis, inclination, omega, omega2, epoch) -> rho, theta Purpose Calculate the separation and position angle of a binary star. Explanation This function will return the separation  $ρ$  and position angle  $θ$  of a visual binary star derived from its orbital elements.  The algorithms described in the following book will be used: Meeus J., 1992, Astronomische Algorithmen, Barth.  Compared to the examples given at page 400 and no discrepancy found. Arguments period : period [year] periastro : time of periastron passage [year] eccentricity : eccentricity of the orbit semimajor_axis : semi-major axis [arc second] inclination : inclination angle [degree] omega : node [degree] omega2 : longitude of periastron [degree] epoch : epoch of observation [year] All input parameters have to be scalars. Output The 2-tuple  $(ρ, θ)$ , where $ρ$  is separation [arc second], and $θ$  is position angle (degree). Example Find the position of Eta Coronae Borealis at the epoch 2016 julia> using AstroLib\n\njulia> ρ, θ = rhotheta(41.623, 1934.008, 0.2763, 0.907, 59.025, 23.717, 219.907, 2016)\n(0.6351167848659552, 214.42513387396497) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1626,"pagetitle":"Reference","title":"AstroLib.sec2rad","ref":"/AstroLib/stable/ref/#AstroLib.sec2rad-Tuple{Real}","content":" AstroLib.sec2rad  —  Method sec2rad(sec) -> radians Purpose Convert from seconds to radians. Argument sec : number of seconds. Output The number of radians corresponding to  sec . Example julia> using AstroLib\n\njulia> sec2rad(3600 * 30)\n0.5235987755982988 Notes Use  rad2sec  to convert radians to seconds. source"},{"id":1627,"pagetitle":"Reference","title":"AstroLib.sixty","ref":"/AstroLib/stable/ref/#AstroLib.sixty-Tuple{Real}","content":" AstroLib.sixty  —  Method sixty(number) -> [deg, min, sec] Purpose Converts a decimal number to sexagesimal. Explanation The reverse of  ten  function. Argument number : decimal number to be converted to sexagesimal. Output An array of three  AbstractFloat , that are the sexagesimal counterpart (degrees, minutes, seconds) of  number . Example julia> using AstroLib\n\njulia> sixty(-0.615)\n3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):\n -0.0\n 36.0\n 54.0 Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1628,"pagetitle":"Reference","title":"AstroLib.sphdist","ref":"/AstroLib/stable/ref/#AstroLib.sphdist-NTuple{4, Real}","content":" AstroLib.sphdist  —  Method sphdist(long1, lat1, long2, lat2[, degrees=true]) -> angular_distance Purpose Angular distance between points on a sphere. Arguments long1 :  longitude of point 1 lat1 : latitude of point 1 long2 : longitude of point 2 lat2 : latitude of point 2 degrees  (optional boolean keyword): if  true , all angles, including the output distance, are assumed to be in degrees, otherwise they are all in radians.  It defaults to  false . Output Angular distance on a sphere between points 1 and 2, as an  AbstractFloat .  It is expressed in radians unless  degrees  keyword is set to  true . Example julia> using AstroLib\n\njulia> sphdist(120, -43, 175, +22, degrees=true)\n82.33037963318735 Notes gcirc  function is similar to  sphdist , but may be more suitable for astronomical applications. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1629,"pagetitle":"Reference","title":"AstroLib.sunpos","ref":"/AstroLib/stable/ref/#AstroLib.sunpos","content":" AstroLib.sunpos  —  Function sunpos(jd[, radians=false]) -> ra, dec, elong, obliquity Purpose Compute the right ascension and declination of the Sun at a given date. Arguments jd : the Julian date of when you want to calculate Sun position.  It can be either a scalar or a vector.  Use  jdcnv  to get the Julian date for a given date and time. radians  (optional boolean keyword): if set to  true , all output quantities are given in radians.  The default is  false , so all quantities are given in degrees. Output The 4-tuple  (ra, dec, elong, obliquity) : ra : the right ascension of the Sun at that date dec : the declination of the Sun at that date elong : ecliptic longitude of the Sun at that date obliquity : the obliquity of the ecliptic All quantities are given in degrees, unless  radians  keyword is set to  true  (see \"Arguments\" section).  If  jd  is an array, arrays of the same given as  jd  are returned. Method Uses a truncated version of Newcomb's Sun.  Adapted from the IDL routine SUN_POS by CD Pike, which was adapted from a FORTRAN routine by B. Emerson (RGO). Example Find the apparent right ascension and declination of the Sun on May 1, 1982 julia> using AstroLib\n\njulia> adstring(sunpos(jdcnv(1982, 5, 1))[1:2], precision=2)\n\" 02 31 32.614  +14 54 34.92\" The Astronomical Almanac gives  02 31 32.58 +14 54 34.9  so the error for this case is < 0.5\". Plot the apparent right ascension, in hours, and declination of the Sun, in degrees, for every day in 2016.  Use  Plots.jl  for plotting. using Plots\nusing Dates\n\ndays = DateTime(2016):Day(1):DateTime(2016, 12, 31);\nra, declin = sunpos(jdcnv.(days));\nplot(days, ra/15); plot(days, declin) Notes Patrick Wallace (Rutherford Appleton Laboratory, UK) has tested the accuracy of a C adaptation of the present algorithm and found the following results.  From 1900-2100  sunpos  gave 7.3 arcsec maximum error, 2.6 arcsec RMS.  Over the shorter interval 1950-2050 the figures were 6.4 arcsec max, 2.2 arcsec RMS. The returned  ra  and  dec  are in the given date's equinox. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1630,"pagetitle":"Reference","title":"AstroLib.ten","ref":"/AstroLib/stable/ref/#AstroLib.ten","content":" AstroLib.ten  —  Function ten(deg[, min, sec]) -> decimal\nten(\"deg:min:sec\") -> decimal Purpose Converts a sexagesimal number or string to decimal. Explanation ten  is the inverse of the  sixty  function. Arguments ten  takes as argument either three scalars ( deg ,  min ,  sec ) or a string. The string should have the form  \"deg:min:sec\"  or  \"deg min sec\" .  Also any iterable like  (deg, min, sec)  or  [deg, min, sec]  is accepted as argument. If minutes and seconds are not specified they default to zero. Output The decimal conversion of the sexagesimal numbers provided is returned. Method The formula used for the conversion is \\[\\mathrm{sign}(\\mathrm{deg})·\\left(|\\mathrm{deg}| + \\frac{\\mathrm{min}}{60} + \\frac{\\mathrm{sec}}{3600}\\right)\\] Example julia> using AstroLib\n\njulia> ten(-0.0, 19, 47)\n-0.3297222222222222\n\njulia> ten(\"+5:14:58\")\n5.249444444444444\n\njulia> ten(\"-10 26\")\n-10.433333333333334\n\njulia> ten((-10, 26))\n-10.433333333333334 Notes These functions cannot deal with  -0  (negative integer zero) in numeric input. If it is important to give sense to negative zero, you can either make sure to pass a floating point negative zero  -0.0  (this is the best option), or use negative minutes and seconds, or non-integer negative degrees and minutes. source"},{"id":1631,"pagetitle":"Reference","title":"AstroLib.tic_one","ref":"/AstroLib/stable/ref/#AstroLib.tic_one","content":" AstroLib.tic_one  —  Function tic_one(zmin, pixx, incr[, ra=true]) -> min2, tic1 Purpose Determine the position of the first tic mark for astronomical images. Explanation For use in labelling images with right ascension and declination axes. This routine determines the position in pixels of the first tic. Arguments zmin : astronomical coordinate value at axis zero point (degrees  or hours). pixx : distance in pixels between tic marks (usually obtained from  tics ). incr  - increment in minutes for labels (usually an even number obtained  from the procedure  tics ). ra  (optional boolean keyword): if true, incremental value being entered  is in minutes of time, else it is assumed that value is in else it's in minutes of arc.  Default is false. Output The 2 tuple  (min2, tic1) : min2 : astronomical coordinate value at first tic mark tic1 : position in pixels of first tic mark Example Suppose a declination axis has a value of 30.2345 degrees at its zero point.  A tic mark is desired every 10 arc minutes, which corresponds to 12.74 pixels, with increment for labels being 10 minutes. Then julia> using AstroLib\n\njulia> tic_one(30.2345, 12.74, 10)\n(30.333333333333332, 7.554820000000081) yields values of min2 ≈ 30.333 and tic1 ≈ 7.55482, i.e. the first tic mark should be labeled 30 deg 20 minutes and be placed at pixel value 7.55482. Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1632,"pagetitle":"Reference","title":"AstroLib.ticpos","ref":"/AstroLib/stable/ref/#AstroLib.ticpos-Tuple{Real, Real, Real}","content":" AstroLib.ticpos  —  Method ticpos(deglen, pixlen, ticsize) -> ticsize, incr, units Purpose Specify distance between tic marks for astronomical coordinate overlays. Explanation User inputs number an approximate distance between tic marks, and the axis length in degrees.  ticpos  will return a distance between tic marks such that the separation is a round multiple in arc seconds, arc minutes, or degrees. Arguments deglen : length of axis in degrees, positive scalar pixlen : length of axis in plotting units (pixels), postive scalar ticsize : distance between tic marks (pixels).  This value will be  adjusted by  ticpos  such that the distance corresponds to a round  multiple in the astronomical coordinate. Output The 3-tuple  (ticsize, incr, units) : ticsize : distance between tic marks (pixels), positive scalar incr : incremental value for tic marks in round units given  by the  units  parameter units : string giving units of ticsize, either 'Arc Seconds', 'Arc Minutes', or 'Degrees' Example Suppose a 512 × 512 image array corresponds to 0.2 × 0.2 degrees on the sky. A tic mark is desired in round angular units, approximately every 75 pixels. Then julia> using AstroLib\n\njulia> ticpos(0.2, 512, 75)\n(85.33333333333333, 2.0, \"Arc Minutes\") i.e. a good tic mark spacing is every 2 arc minutes, corresponding to 85.333 pixels. Notes All the arguments taken as input are assumed to be positive in nature. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1633,"pagetitle":"Reference","title":"AstroLib.tics","ref":"/AstroLib/stable/ref/#AstroLib.tics","content":" AstroLib.tics  —  Function tics(radec_min, radec_max, numx, ticsize[, ra=true]) -> ticsize, incr Purpose Compute a nice increment between tic marks for astronomical images. Explanation For use in labelling a displayed image with right ascension or declination axes.  An approximate distance between tic marks is input, and a new value is computed such that the distance between tic marks is in simple increments of the tic label values. Arguements radec_min  : minimum axis value (degrees). radec_min  : maximum axis value (degrees). numx  : number of pixels in x direction. ticsize  : distance between tic marks (pixels). ra  (optional boolean keyword): if true, incremental value would be in minutes of time. Default is false. Output A 2-tuple  (ticsize, incr) : ticsize  : distance between tic marks (pixels). incr  : incremental value for tic labels.  The format is dependent on the optional keyword. If true (i.e for right ascension), it's in minutes of time, else it's in minutes of arc (for declination). Example julia> using AstroLib\n\njulia> tics(55, 60, 100.0, 1/2)\n(0.66, 2.0)\n\njulia> tics(30, 60, 12, 2, true)\n(2.75, 30.0) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1634,"pagetitle":"Reference","title":"AstroLib.true_obliquity","ref":"/AstroLib/stable/ref/#AstroLib.true_obliquity-Tuple{Real}","content":" AstroLib.true_obliquity  —  Method true_obliquity(jd) -> t_eps Purpose Return the true obliquity of the ecliptic for a given Julian date Explanation The function is used by the  co_aberration  procedure. Arguments jd : Julian date. Output t_eps : true obliquity of the ecliptic, in radians Example julia> using AstroLib\n\njulia> true_obliquity(jdcnv(1978,01,7,11, 01))\n0.4090953896211926 Notes The function calls  mean_obliquity . source"},{"id":1635,"pagetitle":"Reference","title":"AstroLib.trueanom","ref":"/AstroLib/stable/ref/#AstroLib.trueanom-Tuple{Real, Real}","content":" AstroLib.trueanom  —  Method trueanom(E, e) -> true anomaly Purpose Calculate true anomaly for a particle in elliptic orbit with eccentric anomaly  $E$  and eccentricity  $e$ . Explanation In the two-body problem, once that the  Kepler's equation  is solved and  $E(t)$  is determined, the polar coordinates  $(r(t), θ(t))$  of the body at time  $t$  in the elliptic orbit are given by \\[θ(t) = 2 \\arctan \\left( \\sqrt{\\frac{1 + e}{1 - e}} \\tan\\frac{E(t)}{2} \\right)\\] \\[r(t) = \\frac{a(1 - e^2)}{1 + e\\cos(θ(t) - θ_0)}\\] in which  $a$  is the semi-major axis of the orbit, and  $θ_0$  the value of angular coordinate at time  $t = t_0$ . Arguments E : eccentric anomaly. e : eccentricity, in the elliptic motion regime ( $0 ≤ e ≤ 1$ ) Output The true anomaly. Example Plot the true anomaly as a function of mean anomaly for eccentricity  $e = 0, 0.5, 0.9$ . Use  Plots.jl  for plotting. using Plots\nM = range(0, stop=2pi, length=1001)[1:end-1];\np = plot()\nfor ecc in (0, 0.5, 0.9)\n    plot!(p, M, mod2pi.(trueanom.(kepler_solver.(M, ecc), ecc)))\nend\np Notes The eccentric anomaly can be calculated with  kepler_solver  function. source"},{"id":1636,"pagetitle":"Reference","title":"AstroLib.uvbybeta","ref":"/AstroLib/stable/ref/#AstroLib.uvbybeta","content":" AstroLib.uvbybeta  —  Function uvbybeta(by, m1, c1, n[, hbeta=NaN, eby_in=NaN]) -> te, mv, eby, delm0, radius Purpose Derive dereddened colors, metallicity, and Teff from Stromgren colors. Arguments by : Stromgren b-y color m1 : Stromgren line-blanketing parameter c1 : Stromgren Balmer discontinuity parameter n : Integer which can be any value between 1 to 8, giving approximate stellar classification. B0 - A0, classes III - V, 2.59 < Hbeta < 2.88,-0.20 <   c0   < 1.00 B0 - A0, class   Ia     , 2.52 < Hbeta < 2.59,-0.15 <   c0   < 0.40 B0 - A0, class   Ib     , 2.56 < Hbeta < 2.61,-0.10 <   c0   < 0.50 B0 - A0, class   II     , 2.58 < Hbeta < 2.63,-0.10 <   c0   < 0.10 A0 - A3, classes III - V, 2.87 < Hbeta < 2.93,-0.01 < (b-y)o < 0.06 A3 - F0, classes III - V, 2.72 < Hbeta < 2.88, 0.05 < (b-y)o < 0.22 F1 - G2, classes III - V, 2.60 < Hbeta < 2.72, 0.22 < (b-y)o < 0.39 G2 - M2, classes  IV - V, 0.20 < m0    < 0.76, 0.39 < (b-y)o < 1.00 hbeta  (optional): H-beta line strength index. If it is not supplied, then by default its value will be  NaN  and the code will estimate a value based on by, m1,and c1. It is not used for stars in group 8. eby_in  (optional): specifies the E(b-y) color to use. If not supplied, then by default its value will be  NaN  and E(b-y) will be estimated from the Stromgren colors. Output te : approximate effective temperature mv : absolute visible magnitude eby : color excess E(b-y) delm0 : metallicity index, delta m0, may not be calculable for early B stars and so returns  NaN . radius : stellar radius (R/R(solar)) Example Determine the stellar parameters of 5 stars given their Stromgren parameters julia> using AstroLib\n\njulia> by = [-0.001, 0.403, 0.244, 0.216, 0.394];\n\njulia> m1 = [0.105, -0.074, -0.053, 0.167, 0.186];\n\njulia> c1 = [0.647, 0.215, 0.051, 0.785, 0.362];\n\njulia> hbeta = [2.75, 2.552, 2.568, 2.743, 0];\n\njulia> nn = [1, 2, 3, 7, 8];\n\njulia> uvbybeta.(by, m1, c1, nn, hbeta)\n5-element Vector{NTuple{5, Float64}}:\n (13057.535222326893, -0.27375469585031265, 0.04954396423248884, -0.008292894218734928, 2.7136529525371897)\n (14025.053834219656, -6.907050783073221, 0.4140562248995983, NaN, 73.50771722263974)\n (18423.76405400214, -5.935816553877892, 0.2828247876690783, NaN, 39.84106215808709)\n (7210.507090112837, 2.2180408083364167, 0.018404079180028038, 0.018750927360588615, 2.0459018065648165)\n (5755.671513413262, 3.9449408311022, -0.025062997393370458, 0.03241423718769865, 1.5339239690774464) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1637,"pagetitle":"Reference","title":"AstroLib.vactoair","ref":"/AstroLib/stable/ref/#AstroLib.vactoair-Tuple{Real}","content":" AstroLib.vactoair  —  Method vactoair(wave_vacuum) -> wave_air Purpose Converts vacuum wavelengths to air wavelengths. Explanation Corrects for the index of refraction of air under standard conditions. Wavelength values below  $2000 Å$  will not be altered.  Uses relation of Ciddor (1996). Arguments wave_vacuum : vacuum wavelength in angstroms.  Wavelengths are corrected for the index of refraction of air under standard conditions.  Wavelength values below  $2000 Å$  will  not  be altered, take care within  $[1 Å, 2000 Å]$ . Output Air wavelength in angstroms. Method Uses relation of Ciddor (1996), Applied Optics 35, 1566 ( http://adsabs.harvard.edu/abs/1996ApOpt..35.1566C ). Example If the vacuum wavelength is  w = 2000 , then  vactoair(w)  yields an air wavelength of  1999.353 . julia> using AstroLib\n\njulia> vactoair(2000)\n1999.3526230448367 Notes airtovac  converts air wavelengths to vacuum wavelengths. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1638,"pagetitle":"Reference","title":"AstroLib.xyz","ref":"/AstroLib/stable/ref/#AstroLib.xyz","content":" AstroLib.xyz  —  Function xyz(jd[, equinox]) -> x, y, z, v_x, v_y, v_z Purpose Calculate geocentric  $x$ ,  $y$ , and  $z$  and velocity coordinates of the Sun. Explanation Calculates geocentric  $x$ ,  $y$ , and  $z$  vectors and velocity coordinates ( $dx$ ,  $dy$  and  $dz$ ) of the Sun.  (The positive  $x$  axis is directed towards the equinox, the  $y$ -axis, towards the point on the equator at right ascension 6h, and the  $z$  axis toward the north pole of the equator).  Typical position accuracy is  $<10^{-4}$  AU (15000 km). Arguments jd : number of Reduced Julian Days for the wanted date.  It can be either a scalar or a vector. equinox  (optional numeric argument): equinox of output. Default is 1950. You can use  juldate  to get the number of Reduced Julian Days for the selected dates. Output The 6-tuple  $(x, y, z, v_x, v_y, v_z)$ , where $x, y, z$ : scalars or vectors giving heliocentric rectangular coordinates (in AU) for each date supplied.  Note that  $\\sqrt{x^2 + y^2 + z^2}$  gives the Earth-Sun distance for the given date. $v_x, v_y, v_z$ : velocity vectors corresponding to  $x, y$ , and  $z$ . Example What were the rectangular coordinates and velocities of the Sun on 1999-01-22T00:00:00 (= JD 2451200.5) in J2000 coords?  Note: Astronomical Almanac (AA) is in TDT, so add 64 seconds to UT to convert. julia> using AstroLib, Dates\n\njulia> jd = juldate(DateTime(1999, 1, 22))\n51200.5\n\njulia> xyz(jd + 64/86400, 2000)\n(0.514568709240398, -0.7696326261820209, -0.33376880143023935, 0.014947267514079971, 0.008314838205477328, 0.003606857607575486) Compare to Astronomical Almanac (1999 page C20)             x  (AU)        y  (AU)     z (AU)\nxyz:      0.51456871   -0.76963263  -0.33376880\nAA:       0.51453130   -0.7697110   -0.3337152\nabs(err): 0.00003739    0.00007839   0.00005360\nabs(err)\n    (km):   5609          11759         8040 NOTE: Velocities in AA are for Earth/Moon barycenter       (a very minor offset) see AA 1999 page E3            x vel (AU/day) y vel (AU/day)   z vel (AU/day)\nxyz:      -0.014947268   -0.0083148382    -0.0036068576\nAA:       -0.01494574    -0.00831185      -0.00360365\nabs(err):  0.000001583    0.0000029886     0.0000032076\nabs(err)\n (km/sec): 0.00265        0.00519          0.00557 Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1639,"pagetitle":"Reference","title":"AstroLib.ydn2md","ref":"/AstroLib/stable/ref/#AstroLib.ydn2md-Tuple{Integer, Integer}","content":" AstroLib.ydn2md  —  Method ydn2md(year, day) -> date Purpose Convert from year and day number of year to a date. Explanation Returns the date corresponding to the  day  of  year . Arguments year : the year, as an integer. day : the day of  year , as an integer. Output The date, of  Date  type, of  $\\text{day} - 1$  days after January 1st of  year . Example Find the date of the 60th and 234th days of the year 2016. julia> using AstroLib\n\njulia> ydn2md.(2016, [60, 234])\n2-element Vector{Dates.Date}:\n 2016-02-29\n 2016-08-21 Note ymd2dn  converts from a date to day of the year. source"},{"id":1640,"pagetitle":"Reference","title":"AstroLib.ymd2dn","ref":"/AstroLib/stable/ref/#AstroLib.ymd2dn","content":" AstroLib.ymd2dn  —  Function ymd2dn(date) -> number_of_days Purpose Convert from a date to day of the year. Explanation Returns the day of the year for  date  with January 1st being day 1. Arguments date : the date with  Date  type.  Can be a single date or an array of dates. Output The day of the year for the given  date .  If  date  is an array, returns an array of days. Example Find the days of the year for March 5 in the years 2015 and 2016 (this is a leap year). julia> using AstroLib, Dates\n\njulia> ymd2dn.([Date(2015, 3, 5), Date(2016, 3, 5)])\n2-element Vector{Int64}:\n 64\n 65 Note ydn2md  converts from year and day number of year to a date. source"},{"id":1641,"pagetitle":"Reference","title":"AstroLib.zenpos","ref":"/AstroLib/stable/ref/#AstroLib.zenpos","content":" AstroLib.zenpos  —  Function zenpos(jd, latitude, longitude) -> zenith_right_ascension, declination\nzenpos(date, latitude, longitude, tz) -> zenith_right_ascension, declination Purpose Return the zenith right ascension and declination in radians for a given Julian date or a local civil time and timezone. Explanation The local sidereal time is computed with the help of  ct2lst , which is the right ascension of the zenith. This and the observatories latitude (corresponding to the declination) are converted to radians and returned as the zenith direction. Arguments The function can be called in two different ways. The arguments common to both methods are  latitude  and  longitude : latitude  : latitude of the desired location. longitude  : longitude of the desired location. The zenith direction can be computed either by providing the Julian date: jd  : the Julian date of the date and time for which the zenith position is desired. or the time zone and the date: tz : the time zone (in hours) of the desired location (e.g. 4 = EDT, 5 = EST) date : the local civil time with type  DateTime . Output A 2-tuple  (ra, dec) : ra  : the right ascension (in radians) of the zenith. dec  : the declination (in radians) of the zenith. Example julia> using AstroLib, Dates\n\njulia> zenpos(DateTime(2017, 04, 25, 18, 59), 43.16, -24.32, 4)\n(0.946790432684706, 0.7532841051607526)\n\njulia> zenpos(jdcnv(2016, 05, 05, 13, 41), ten(35,0,42), ten(135,46,6))\n(3.5757821152779536, 0.6110688599440813) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1644,"pagetitle":"ASDF2.jl","title":"ASDF2.jl","ref":"/ASDF2/stable/#ASDF2.jl","content":" ASDF2.jl"},{"id":1645,"pagetitle":"ASDF2.jl","title":"ASDF2.Byteorder","ref":"/ASDF2/stable/#ASDF2.Byteorder","content":" ASDF2.Byteorder  —  Type @enum ASDF2.Byteorder Byteorder_little Byteorder_big source"},{"id":1646,"pagetitle":"ASDF2.jl","title":"ASDF2.Byteorder","ref":"/ASDF2/stable/#ASDF2.Byteorder-Tuple{AbstractString}","content":" ASDF2.Byteorder  —  Method ASDF2.Byteorder(str::AbstractString)::Byteorder source"},{"id":1647,"pagetitle":"ASDF2.jl","title":"ASDF2.Datatype","ref":"/ASDF2/stable/#ASDF2.Datatype","content":" ASDF2.Datatype  —  Type Careful, there is also  Base.DataType , which is a different type. source"},{"id":1648,"pagetitle":"ASDF2.jl","title":"Base.string","ref":"/ASDF2/stable/#Base.string-Tuple{ASDF2.Byteorder}","content":" Base.string  —  Method string(byteorder::Byteorder)::AbstractString source"},{"id":1651,"pagetitle":"Home","title":"Home","ref":"/AstroImages/stable/#Home","content":" Home AstroImage.jl is a Julia package for loading, manipulating, and visualizing astronomical images. It supports FITS files ( FITSIO.jl ), world coordinates ( WCS.jl ), rendering images ( Images.jl ), and plot recipes ( Plots.jl )."},{"id":1652,"pagetitle":"Home","title":"Videos","ref":"/AstroImages/stable/#Videos","content":" Videos AstroImages.jl was presented at JuliaCon in 2022. You can view the talk  here ."},{"id":1655,"pagetitle":"API","title":"API Documentation","ref":"/AstroImages/stable/api/#API-Documentation","content":" API Documentation"},{"id":1656,"pagetitle":"API","title":"FileIO.load","ref":"/AstroImages/stable/api/#FileIO.load","content":" FileIO.load  —  Function load(filename)  loads the contents of a formatted file, trying to infer the format from  filename  and/or magic bytes in the file (see  query ). load(strm)  loads from an  IOStream  or similar object. In this case, there is no filename extension, so we rely on the magic bytes for format identification. load(File{format\"PNG\"}(filename))  specifies the format directly, and bypasses the format  query . load(Stream{format\"PNG\"}(io))  specifies the format directly, and bypasses the format  query . load(f; options...)  passes keyword arguments on to the loader. source"},{"id":1657,"pagetitle":"API","title":"FileIO.save","ref":"/AstroImages/stable/api/#FileIO.save","content":" FileIO.save  —  Function save(filename, data...)  saves the contents of a formatted file, trying to infer the format from  filename . save(Stream{format\"PNG\"}(io), data...)  specifies the format directly, and bypasses the format  query . save(File{format\"PNG\"}(filename), data...)  specifies the format directly, and bypasses the format  query . save(f, data...; options...)  passes keyword arguments on to the saver. source"},{"id":1658,"pagetitle":"API","title":"FileIO.query","ref":"/AstroImages/stable/api/#FileIO.query","content":" FileIO.query  —  Function query(filename; checkfile=true) Return a  File  object with information about the format inferred from the file's extension and/or magic bytes. If  filename  already exists, the file's magic bytes will take priority unless  checkfile  is false. source query(io, [filename]) Returns a  Stream  object with information about the format inferred from the magic bytes. source"},{"id":1659,"pagetitle":"API","title":"AstroImages.AstroImage","ref":"/AstroImages/stable/api/#AstroImages.AstroImage","content":" AstroImages.AstroImage  —  Type AstroImage Provides access to a FITS image along with its accompanying header and WCS information, if applicable. source"},{"id":1660,"pagetitle":"API","title":"AstroImages.imview","ref":"/AstroImages/stable/api/#AstroImages.imview","content":" AstroImages.imview  —  Function imview(img; clims=Percent(99.5), stretch=identity, cmap=:magma, contrast=1.0, bias=0.5) Create a read only view of an array or AstroImageMat mapping its data values to Colors according to  clims ,  stretch , and  cmap . The data is first clamped to  clims , which can either be a tuple of (min, max) values or a function accepting an iterator of pixel values that returns (min, max). By default,  clims=Percent(99.5)  which sets the display min and max to the central 99.5 percentile range of pixel values. Convenient functions to use for  clims  are:  extrema ,  Zscale , and  Percent(p) Next, the data is rescaled to [0,1] and remapped according to the function  stretch . Stretch can be any monotonic fuction mapping values in the range [0,1] to some range [a,b]. Note that  log(0)  is not defined so is not directly supported. For a list of convenient stretch functions, see:  logstretch ,  powstretch ,  squarestretch ,  asinhstretch ,  sinhstretch ,  powerdiststretch Finally the data is mapped to RGB values according to  cmap . If cmap is  nothing , grayscale is used. ColorSchemes.jl defines hundreds of colormaps. A few nice ones for images include:  :viridis ,  :magma ,  :plasma ,  :thermal , and  :turbo . Crucially, this function returns a view over the underlying data. If  img  is updated then those changes will be reflected by this view with the exception of  clims  which is not recalculated. Note: if clims or stretch is a function, the pixel values passed in are first filtered to remove non-finite or missing values. Defaults The default values of  clims ,  stretch , and  cmap  are  extrema ,  identity , and  nothing  respectively. You may alter these defaults using  AstroImages.set_clims! ,   AstroImages.set_stretch! , and  AstroImages.set_cmap! . Automatic Display Arrays wrapped by  AstroImageMat()  get displayed as images automatically by calling  imview  on them with the default settings when using displays that support showing PNG images. Missing data Pixels that are  NaN  or  missing  will be displayed as transparent when  cmap  is set or black if. +/- Inf will be displayed as black or white respectively. Exporting Images The view returned by  imview  can be saved using general  FileIO.save  methods. Example: v = imview(data, cmap=:magma, stretch=asinhstretch, clims=Percent(95))\nsave(\"output.png\", v) source imview(img::AbstractArray{<:Complex}; ...) When applied to an image with complex values, display the magnitude of the pixels using  imview  and display the phase angle as a panel below using a cyclical color map. For more customatization, you can create a view like this yourself: vcat(\n    imview(abs.(img)),\n    imview(angle.(img)),\n) source"},{"id":1661,"pagetitle":"API","title":"AstroImages.implot","ref":"/AstroImages/stable/api/#AstroImages.implot","content":" AstroImages.implot  —  Function implot(\n    img::AbstractArray;\n    clims=Percent(99.5),\n    stretch=identity,\n    cmap=:magma,\n    bias=0.5,\n    contrast=1,\n    wcsticks=true,\n    grid=true,\n    platescale=1\n) Create a read only view of an array or AstroImageMat mapping its data values to an array of Colors. Equivalent to: implot(\n    imview(\n        img::AbstractArray;\n        clims=Percent(99.5),\n        stretch=identity,\n        cmap=:magma,\n        bias=0.5,\n        contrast=1,\n    ),\n    wcsn=1,\n    wcsticks=true,\n    wcstitle=true,\n    grid=true,\n    platescale=1\n) Image Rendering See  imview  for how data is mapped to RGBA pixel values. WCS & Image Coordinates If provided with an AstroImage that has WCS headers set, the tick marks and plot grid are calculated using WCS.jl. By default, use the first WCS coordinate system. The underlying pixel coordinates are those returned by  dims(img)  multiplied by  platescale . This allows you to overplot lines, regions, etc. using pixel coordinates. If you wish to compute the pixel coordinate of a point in world coordinates, see  world_to_pix . wcsn  (default  1 ) select which WCS transform in the headers to use for ticks & grid wcsticks  (default  true  if WCS headers present) display ticks and labels, and title using world coordinates wcstitle  (default  true  if WCS headers present and  length(refdims(img))>0 ). When slicing a cube, display the location along unseen axes in world coordinates instead of pixel coordinates. grid  (default  true ) show a grid over the plot. Uses WCS coordinates if  wcsticks  is true, otherwise pixel coordinates multiplied by  platescale . platescale  (default  1 ). Scales the underlying pixel coordinates to ease overplotting, etc. If  wcsticks  is false, the displayed pixel coordinates are also scaled. Defaults The default values of  clims ,  stretch , and  cmap  are  extrema ,  identity , and  nothing  respectively. You may alter these defaults using  AstroImages.set_clims! ,   AstroImages.set_stretch! , and  AstroImages.set_cmap! . source"},{"id":1662,"pagetitle":"API","title":"AstroImages.Comment","ref":"/AstroImages/stable/api/#AstroImages.Comment","content":" AstroImages.Comment  —  Type Index for accessing a comment associated with a header keyword or COMMENT entry. Example: img = AstroImage(randn(10,10))\nimg[\"ABC\"] = 1\nimg[\"ABC\", Comment] = \"A comment describing this key\"\n\npush!(img, Comment, \"The purpose of this file is to demonstrate comments\")\nimg[Comment] # [\"The purpose of this file is to demonstrate comments\"] source"},{"id":1663,"pagetitle":"API","title":"AstroImages.History","ref":"/AstroImages/stable/api/#AstroImages.History","content":" AstroImages.History  —  Type Allows accessing and setting HISTORY header entries img = AstroImage(randn(10,10))\npush!(img, History, \"2023-04-19: Added history entry.\")\nimg[History] # [\"2023-04-19: Added history entry.\"] source"},{"id":1664,"pagetitle":"API","title":"WCS.pix_to_world","ref":"/AstroImages/stable/api/#WCS.pix_to_world","content":" WCS.pix_to_world  —  Function pix_to_world(wcs, pixcoords) Convert the array of pixel coordinates  pixcoords  to world coordinates according to the WCSTransform  wcs .  pixcoords  should be a 2-d array where \"pixcoords[:, i]\" is the i-th set of coordinates, or a 1-d array representing a single set of coordinates. The return value is the same shape as  pixcoords . source pix_to_world(img::AstroImage, pixcoords; all=false) Given an astro image, look up the world coordinates of the pixels given by  pixcoords . World coordinates are resolved using WCS.jl and a WCSTransform calculated from any FITS header present in  img . If no WCS information is in the header, or the axes are all linear, this will just return pixel coordinates. pixcoords  should be the coordinates in your current selection of the image. For example, if you select a slice like this: julia> cube = load(\"some-3d-cube.fits\")\njulia> slice = cube[10:20, 30:40, 5] Then to look up the coordinates of the pixel in the bottom left corner of  slice , run: julia> world_coords = pix_to_world(img, [1, 1])\n[10, 30] If WCS information was present in the header of  cube , then those coordinates would be resolved using axis 1, 2, and 3 respectively. To include world coordinates in all axes, pass  all=true julia> world_coords = pix_to_world(img, [1, 1], all=true)\n[10, 30, 5] !! Coordinates must be provided in the order of  dims(img) . If you transpose an image, the order you pass the coordinates should not change. source"},{"id":1665,"pagetitle":"API","title":"WCS.world_to_pix","ref":"/AstroImages/stable/api/#WCS.world_to_pix","content":" WCS.world_to_pix  —  Function world_to_pix(wcs, worldcoords) Convert the array of world coordinates  worldcoords  to pixel coordinates according to the WCSTransform  wcs .  worldcoords  is a 2-d array where \"worldcoords[:, i]\" is the i-th set of coordinates, or a 1-d array representing a single set of coordinates. The return value is the same size as  worldcoords . source"},{"id":1666,"pagetitle":"API","title":"DimensionalData.Dimensions.X","ref":"/AstroImages/stable/api/#DimensionalData.Dimensions.X","content":" DimensionalData.Dimensions.X  —  Type X <: XDim\n\nX(val=:) X  Dimension .  X <: XDim <: IndependentDim Examples xdim = X(2:2:10) val = A[X(1)] mean(A; dims=X) source"},{"id":1667,"pagetitle":"API","title":"DimensionalData.Dimensions.Y","ref":"/AstroImages/stable/api/#DimensionalData.Dimensions.Y","content":" DimensionalData.Dimensions.Y  —  Type Y <: YDim\n\nY(val=:) Y  Dimension .  Y <: YDim <: DependentDim Examples ydim = Y(['a', 'b', 'c']) val = A[Y(1)] mean(A; dims=Y) source"},{"id":1668,"pagetitle":"API","title":"DimensionalData.Dimensions.Z","ref":"/AstroImages/stable/api/#DimensionalData.Dimensions.Z","content":" DimensionalData.Dimensions.Z  —  Type Z <: ZDim\n\nZ(val=:) Z  Dimension .  Z <: ZDim <: Dimension Example: zdim = Z(10:10:100) val = A[Z(1)] mean(A; dims=Z) source"},{"id":1669,"pagetitle":"API","title":"DimensionalData.Dimensions.Dim","ref":"/AstroImages/stable/api/#DimensionalData.Dimensions.Dim","content":" DimensionalData.Dimensions.Dim  —  Type Dim{S}(val=:) A generic dimension. For use when custom dims are required when loading data from a file. Can be used as keyword arguments for indexing. Dimension types take precedence over same named  Dim  types when indexing with symbols, or e.g. creating Tables.jl keys. julia> dim = Dim{:custom}(['a', 'b', 'c'])\ncustom ['a', 'b', 'c'] source"},{"id":1670,"pagetitle":"API","title":"DimensionalData.Dimensions.Lookups.At","ref":"/AstroImages/stable/api/#DimensionalData.Dimensions.Lookups.At","content":" DimensionalData.Dimensions.Lookups.At  —  Type At <: IntSelector\n\nAt(x; atol=nothing, rtol=nothing)\nAt(a, b; kw...) Selector that exactly matches the value on the passed-in dimensions, or throws an error. For ranges and arrays, every intermediate value must match an existing value - not just the end points. x  can be any value to select a single index, or a  Vector  of values to select vector of indices. If two values  a  and  b  are used, the range between them will be selected. Keyword  atol  is passed to  isapprox . Example using DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))\nA[X(At(20)), Y(At(6))]\n\n# output\n\n5 source"},{"id":1671,"pagetitle":"API","title":"DimensionalData.Dimensions.Lookups.Near","ref":"/AstroImages/stable/api/#DimensionalData.Dimensions.Lookups.Near","content":" DimensionalData.Dimensions.Lookups.Near  —  Type Near <: IntSelector\n\nNear(x)\nNear(a, b) Selector that selects the nearest index to  x . With  Points  this is simply the lookup values nearest to the  x , however with  Intervals  it is the interval  center  nearest to  x . This will be offset from the index value for  Start  and  End  locus. x  can be any value to select a single index, or a  Vector  of values to select vector of indices. If two values  a  and  b   are used, the range between the nearsest value to each of them will be selected. Example using DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))\nA[X(Near(23)), Y(Near(5.1))]\n\n# output\n4 source"},{"id":1672,"pagetitle":"API","title":"DimensionalData.Dimensions.dims","ref":"/AstroImages/stable/api/#DimensionalData.Dimensions.dims","content":" DimensionalData.Dimensions.dims  —  Function dims(x, query) => Tuple{Vararg{Dimension}}\ndims(x, query...) => Tuple{Vararg{Dimension}} Get the dimension(s) matching the type(s) of the query dimension. Lookup can be an Int or an Dimension, or a tuple containing any combination of either. Arguments x : any object with a  dims  method, or a  Tuple  of  Dimension . query : Tuple or a single  Dimension  or  Dimension Type . Example julia> using DimensionalData\n\njulia> A = DimArray(ones(2, 3, 2), (X, Y, Z))\n╭───────────────────────────╮\n│ 2×3×2 DimArray{Float64,3} │\n├───────────────────── dims ┤\n  ↓ X, → Y, ↗ Z\n└───────────────────────────┘\n[:, :, 1]\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n\njulia> dims(A, (X, Y))\n(↓ X, → Y)\n source dims(x, [dims::Tuple]) => Tuple{Vararg{Dimension}}\ndims(x, dim) => Dimension Return a tuple of  Dimension s for an object, in the order that matches the axes or columns of the underlying data. dims  can be  Dimension ,  Dimension  types, or  Symbols  for  Dim{Symbol} . The default is to return  nothing . source"},{"id":1673,"pagetitle":"API","title":"DimensionalData.Dimensions.refdims","ref":"/AstroImages/stable/api/#DimensionalData.Dimensions.refdims","content":" DimensionalData.Dimensions.refdims  —  Function refdims(x, [dims::Tuple]) => Tuple{Vararg{Dimension}}\nrefdims(x, dim) => Dimension Reference dimensions for an array that is a slice or view of another array with more dimensions. slicedims(a, dims)  returns a tuple containing the current new dimensions and the new reference dimensions. Refdims can be stored in a field or discarded, as it is mostly to give context to plots. Ignoring refdims will simply leave some captions empty. The default is to return an empty  Tuple () . source"},{"id":1674,"pagetitle":"API","title":"AstroImages.header","ref":"/AstroImages/stable/api/#AstroImages.header","content":" AstroImages.header  —  Function header(img::AstroImage) Return the underlying FITSIO.FITSHeader object wrapped by an AstroImage. Note that this object has less flexible getindex and setindex methods. Indexing by symbol, Comment, History, etc are not supported. source header(array::AbstractArray) Returns an empty FITSIO.FITSHeader object when called with a non-AstroImage abstract array. source"},{"id":1675,"pagetitle":"API","title":"AstroImages.wcs","ref":"/AstroImages/stable/api/#AstroImages.wcs","content":" AstroImages.wcs  —  Function wcs(img) Computes and returns a list of World Coordinate System WCSTransform objects from WCS.jl. The resultss are cached after the first call, so subsequent calls are fast. Modifying a WCS header invalidates this cache automatically, so users should call  wcs(...)  each time rather than keeping the WCSTransform object around. source wcs(img, index) Computes and returns a World Coordinate System WCSTransform objects from WCS.jl by index. This is to support files with multiple WCS transforms specified.  wcs(img,1)  is useful for selecting selecting the first WCSTranform object. The resultss are cached after the first call, so subsequent calls are fast. Modifying a WCS header invalidates this cache automatically, so users should call  wcs(...)  each time rather than keeping the WCSTransform object around. source wcs(array) Returns a list with a single basic WCSTransform object when called with a non-AstroImage abstract array. source"},{"id":1676,"pagetitle":"API","title":"AstroImages.WCSGrid","ref":"/AstroImages/stable/api/#AstroImages.WCSGrid","content":" AstroImages.WCSGrid  —  Type WCSGrid(img::AstroImageMat, ax=(1,2), coords=(first(axes(img,ax[1])),first(axes(img,ax[2])))) Given an AstroImageMat, return information necessary to plot WCS gridlines in physical coordinates against the image's pixel coordinates. This function has to work on both plotted axes at once to handle rotation and general curvature of the WCS grid projected on the image coordinates. source"},{"id":1677,"pagetitle":"API","title":"AstroImages.composecolors","ref":"/AstroImages/stable/api/#AstroImages.composecolors","content":" AstroImages.composecolors  —  Function composecolors(\n    images,\n    cmap=[\"#F00\", \"#0F0\", \"#00F\"];\n    clims,\n    stretch,\n    contrast,\n    bias,\n    multiplier\n) Create a color composite of multiple images by applying  imview  and blending the results. This function can be used to create RGB composites using any number of channels (e.g. red, green, blue, and hydrogen alpha) as well as more exotic images like blending radio and optical data using two different colormaps. cmap  should be a list of colorants, named colors (see Colors.jl), or colorschemes (see ColorSchemes.jl).  clims ,  stretch ,  contrast , and  bias  are passed on to  imview . They can be a single value or a list of different values for each image. The headers of the returned image are copied from the first image. Examples: # Basic RGB\ncomposecolors([redimage, greenimage, blueimage])\n# Non-linear stretch before blending\ncomposecolors([redimage, greenimage, blueimage], stretch=asinhstretch)\n# More than three channels are allowed (H alpha in pink)\ncomposecolors(\n    [antred, antgreen, antblue, anthalp],\n    [\"red\", \"green\", \"blue\", \"maroon1\"],\n    multiplier=[1,2,1,1]\n)\n# Can mix\ncomposecolors([radioimage, xrayimage], [:ice, :magma], clims=extrema)\ncomposecolors([radioimage, xrayimage], [:magma, :viridis], clims=[Percent(99), Zscale()]) source"},{"id":1678,"pagetitle":"API","title":"AstroImages.Zscale","ref":"/AstroImages/stable/api/#AstroImages.Zscale","content":" AstroImages.Zscale  —  Type Zscale(options)(data) Wraps PlotUtils.zscale in a callable with default parameters. This is a common algorithm for agressively stretching astronomical data to see faint structure that originated in IRAF:  https://iraf.net/forum/viewtopic.php?showtopic=134139  but is now seen in many other applications/libraries (DS9, Astropy, etc.) Usage: imview(img, clims=Zscale())\nimplot(img, clims=Zscale(contrast=0.1)) Default parameters: nsamples::Int=1000\ncontrast::Float64=0.25\nmax_reject::Float64=0.5\nmin_npixels::Float64=5\nk_rej::Float64=2.5\nmax_iterations::Int=5 source"},{"id":1679,"pagetitle":"API","title":"AstroImages.Percent","ref":"/AstroImages/stable/api/#AstroImages.Percent","content":" AstroImages.Percent  —  Type Percent(99.5) Returns a callable that calculates display limits that include the given percent of the image data. Reproduces the behaviour of the SAO DS9 scale menu. Example: julia> imview(img, clims=Percent(90)) This will set the limits to be the 5th percentile to the 95th percentile. source"},{"id":1680,"pagetitle":"API","title":"AstroImages.logstretch","ref":"/AstroImages/stable/api/#AstroImages.logstretch","content":" AstroImages.logstretch  —  Function logstretch(num,a=1000) A log-stretch as defined by the SAO DS9 application:  http://ds9.si.edu/doc/ref/how.html source"},{"id":1681,"pagetitle":"API","title":"AstroImages.powstretch","ref":"/AstroImages/stable/api/#AstroImages.powstretch","content":" AstroImages.powstretch  —  Function powstretch(num, a=1000) A power-stretch as defined by the SAO DS9 application:  http://ds9.si.edu/doc/ref/how.html source"},{"id":1682,"pagetitle":"API","title":"AstroImages.sqrtstretch","ref":"/AstroImages/stable/api/#AstroImages.sqrtstretch","content":" AstroImages.sqrtstretch  —  Function sqrtstretch(num) A square root stretch (simply defined as Base.sqrt) source"},{"id":1683,"pagetitle":"API","title":"AstroImages.squarestretch","ref":"/AstroImages/stable/api/#AstroImages.squarestretch","content":" AstroImages.squarestretch  —  Function squarestretch(num) A squarestretch-stretch as defined by the SAO DS9 application:  http://ds9.si.edu/doc/ref/how.html source"},{"id":1684,"pagetitle":"API","title":"AstroImages.asinhstretch","ref":"/AstroImages/stable/api/#AstroImages.asinhstretch","content":" AstroImages.asinhstretch  —  Function asinhstretch(num) A hyperbolic arcsin stretch as defined by the SAO DS9 application:  http://ds9.si.edu/doc/ref/how.html source"},{"id":1685,"pagetitle":"API","title":"AstroImages.sinhstretch","ref":"/AstroImages/stable/api/#AstroImages.sinhstretch","content":" AstroImages.sinhstretch  —  Function sinhstretch(num) A hyperbolic sin stretch as defined by the SAO DS9 application:  http://ds9.si.edu/doc/ref/how.html source"},{"id":1686,"pagetitle":"API","title":"AstroImages.powerdiststretch","ref":"/AstroImages/stable/api/#AstroImages.powerdiststretch","content":" AstroImages.powerdiststretch  —  Function powerdiststretch(num, a=1000) A power distance stretch as defined by astropy. source"},{"id":1687,"pagetitle":"API","title":"AstroImages.copyheader","ref":"/AstroImages/stable/api/#AstroImages.copyheader","content":" AstroImages.copyheader  —  Function copyheader(img::AstroImage, data) -> imgnew Create a new image copying the header of  img  but using the data of the AbstractArray  data . Note that changing the header of  imgnew  does not affect the header of  img . See also:  shareheader . source"},{"id":1688,"pagetitle":"API","title":"AstroImages.shareheader","ref":"/AstroImages/stable/api/#AstroImages.shareheader","content":" AstroImages.shareheader  —  Function shareheader(img::AstroImage, data) -> imgnew Create a new image reusing the header dictionary of  img  but using the data of the AbstractArray  data . The two images have synchronized header; modifying one also affects the other. See also:  copyheader . source"},{"id":1689,"pagetitle":"API","title":"AstroImages.recenter","ref":"/AstroImages/stable/api/#AstroImages.recenter","content":" AstroImages.recenter  —  Function recenter(img::AstroImage)\nrecenter(img::AstroImage, newcentx, newcenty, ...) Adjust the dimensions of an AstroImage so that they are centered on the pixel locations given by  newcentx , .. etc. This does not affect the underlying array, it just updates the dimensions associated with it by the AstroImage. If no  newcent  arguments are provided, center the image in all dimensions to the middle pixel (or fractional pixel). Example: a = AstroImage(randn(11,11))\na[1,1] # Bottom left\na[At(1),At(1)] # Bottom left\nr = recenter(a, 6, 6)\nr[1,1] # Still bottom left\nr[At(1),At(1)] # Center pixel source"},{"id":1692,"pagetitle":"Plotting Contours","title":"Contours","ref":"/AstroImages/stable/guide/contours/#Contours","content":" Contours This guide shows a few different ways to measure and visualize contours of images."},{"id":1693,"pagetitle":"Plotting Contours","title":"Using Plots","ref":"/AstroImages/stable/guide/contours/#Using-Plots","content":" Using Plots The most basic way to create a contour plot is simply to use Plots.jl  contour  and  contourf  functions on your image. Let's see how that works: using AstroImages, Plots\n\n\n# First load a FITS file of interest\nfname = download(\n    \"https://www.chandra.harvard.edu/photo/2014/archives/fits/herca/herca_radio.fits\",\n    \"herca-radio.fits\"\n)\n\nherca = load(\"herca-radio.fits\") Create a contour plot contour(herca) Create a filled contour plot contourf(herca) Specify the number of levels contour(herca, levels=5) Specify specific levels contour(herca, levels=[1, 1000, 5000]) Overplot contours on image: implot(herca)\ncontour!(herca, levels=4, color=:cyan)"},{"id":1694,"pagetitle":"Plotting Contours","title":"Using Contour.jl","ref":"/AstroImages/stable/guide/contours/#Using-Contour.jl","content":" Using Contour.jl For more control over how contours are calculated and plotted, you can use the  Contour.jl  package: using Contour\nherca = load(\"herca-radio.fits\")\n\np = implot(herca, cmap=nothing, colorbar=false)\n\n# Note: Contour.jl only supports float inputs.\n# See https://github.com/JuliaGeometry/Contour.jl/issues/73\nfor cl in levels(contours(dims(herca)..., float.(herca)))\n    lvl = level(cl) # the z-value of this contour level\n    for line in lines(cl)\n        xs, ys = coordinates(line) # coordinates of this line segment\n        plot!(p, xs, ys, line_z=lvl, label=\"\")\n    end\nend\n\np Here we plot just the contours, now in world coordinates: p = plot(xlabel=\"RA\", ylabel=\"DEC\")\nfor cl in levels(contours(dims(herca)..., float.(herca)))\n    lvl = level(cl) # the z-value of this contour level\n    for line in lines(cl)\n        xs, ys = coordinates(line) # coordinates of this line segment\n        worldcoords = map(zip(xs,ys)) do pixcoord\n            pix_to_world(herca, [pixcoord...])\n        end\n        plot!(p, getindex.(worldcoords,1), getindex.(worldcoords,2), line_z=lvl, label=\"\")\n    end\nend\np"},{"id":1697,"pagetitle":"Blurring & Filtering Images","title":"Image Filtering","ref":"/AstroImages/stable/guide/image-filtering/#Image-Filtering","content":" Image Filtering The package  ImageFiltering.jl  makes it easy to apply arbitrary filters to images."},{"id":1698,"pagetitle":"Blurring & Filtering Images","title":"Gaussian Blurs","ref":"/AstroImages/stable/guide/image-filtering/#Gaussian-Blurs","content":" Gaussian Blurs Let's start by downloading a radio image of Hercules A: using AstroImages\nusing ImageFiltering\n\nfname = download(\n    \"https://www.chandra.harvard.edu/photo/2014/archives/fits/herca/herca_radio.fits\",\n    \"herca-radio.fits\"\n)\n\nherca = load(\"herca-radio.fits\") Let's now apply a Gaussian blur (aka a low pass filter) using the  imfilter  function: herca_blur_20 = imfilter(herca, Kernel.gaussian(20.0)) The image has been smoothed out by convolving it with a wide Gaussian. Let's now do the opposite and perform a high-pass filter. This will bring out faint variations in structure. We can do this by subtracting a blurred image from the original: herca_blur_4 = imfilter(herca, Kernel.gaussian(4.0))\nherca_highpass = herca .- herca_blur_4 We now see lots of faint structure inside the jets! Finally, let's adjust how the image is displayed and apply a non-linear stretch: imview(\n    herca_highpass,\n    cmap=:seaborn_rocket_gradient,\n    clims=(-50,1500),\n    stretch=asinhstretch\n) If you have Plots loaded, we can add a colorbar and coordinate axes by switching to  implot : using Plots\nimplot(\n    herca_highpass,\n    cmap=:seaborn_rocket_gradient,\n    clims=(-50,1500),\n    stretch=asinhstretch\n)"},{"id":1699,"pagetitle":"Blurring & Filtering Images","title":"Median Filtering","ref":"/AstroImages/stable/guide/image-filtering/#Median-Filtering","content":" Median Filtering In addition to linear filters using  imfilter , ImageFiltering.jl also includes a great function called  mapwindow . This functions allows you to map an arbitrary function over a patch of an image. Let's use  mapwindow  to perform a median filter. This is a great way to suppress salt and pepper noise, or remove stars from some images. We'll use a Hubble picture of the Eagle nebula: using AstroImages\nusing ImageFiltering\n\nfname = download(\n    \"https://ds9.si.edu/download/data/673nmos.fits\",\n    \"eagle-673nmos.fits\"\n)\n\neagle673 = load(\"eagle-673nmos.fits\") The data is originally from  https://esahubble.org/projects/fits_liberator/eagledata/ . We can apply a median filter using  mapwindow . Make sure the patch size is an odd number in each direction! using Statistics\nmedfilt = copyheader(eagle673, mapwindow(median, eagle673, (11,11))) We use  copyheader  here since  mapwindow  returns a plain array and drops the image meta data. We can put this side by side with the original to see how some of the faint stars have been removed from the image: imview([eagle673[1:800,1:800]; medfilt[1:800,1:800]])"},{"id":1702,"pagetitle":"Transforming Images","title":"Image Transformations","ref":"/AstroImages/stable/guide/image-transformations/#Image-Transformations","content":" Image Transformations The  ImageTransformations.jl  package contains many useful functions for manipulating astronomical images. Note however that many of these functions drop the AstroImage wrapper and return plain arrays or OffsetArrays. They can be re-wrapped using  copyheader  or  shareheader  if you'd like to preserve the FITS header, dimension labels, WCS information, etc. You can install ImageTransformations by running  ] add ImageTransformations  at the REPL. For these examples, we'll download an image of the Antenae galaxies from Hubble: using AstroImages\nusing ImageTransformations\n\nfname = download(\n    \"https://esahubble.org/static/projects/fits_liberator/datasets/antennae/blue.fits\",\n    \"ant-blue.fits\"\n)\n\nantblue = load(\"ant-blue.fits\")\n\n# We'll change the defaults to avoid setting them each time\nAstroImages.set_clims!(Percent(99))\nAstroImages.set_cmap!(:ice)\nAstroImages.set_stretch!(asinhstretch)\n\nimview(antblue)"},{"id":1703,"pagetitle":"Transforming Images","title":"Rotations","ref":"/AstroImages/stable/guide/image-transformations/#Rotations","content":" Rotations We can rotate images using the  imrotate  function. imrotate(antblue, 3π/4) |> imview The rotation angle is in radians, but you can use the function  rad2deg  to convert from degrees."},{"id":1704,"pagetitle":"Transforming Images","title":"Resizing","ref":"/AstroImages/stable/guide/image-transformations/#Resizing","content":" Resizing We can resize images using the  imresize  function: imresize(antblue, ratio=0.2) |> imview"},{"id":1705,"pagetitle":"Transforming Images","title":"Arbitrary Transformations","ref":"/AstroImages/stable/guide/image-transformations/#Arbitrary-Transformations","content":" Arbitrary Transformations Arbitrary transformations can be performed using ImageTransformation's  warp  function. See the documentation linked above for more details."},{"id":1706,"pagetitle":"Transforming Images","title":"Mapping from One Coordinate System to Another","ref":"/AstroImages/stable/guide/image-transformations/#Mapping-from-One-Coordinate-System-to-Another","content":" Mapping from One Coordinate System to Another For transforming an image from one coordiante system (say, RA & DEC) to another (e.g., galactic lattitude & logitude), see  Reprojecting Images ."},{"id":1709,"pagetitle":"Extracting Photometry","title":"Photometry","ref":"/AstroImages/stable/guide/photometry/#Photometry","content":" Photometry The following examples are adapted from  Photometry.jl  to show the same examples combined with AstroImages.jl. To learn how to measure background levels, perform aperture photometry, etc see the  Photometry.jl documentation ."},{"id":1710,"pagetitle":"Extracting Photometry","title":"Background Estimation","ref":"/AstroImages/stable/guide/photometry/#Background-Estimation","content":" Background Estimation From Photometry.jl: Estimating backgrounds is an important step in performing photometry. Ideally, we could perfectly describe the background with a scalar value or with some distribution. Unfortunately, it's impossible for us to precisely separate the background and foreground signals. Here, we use mixture of robust statistical estimators and meshing to let us get the spatially varying background from an astronomical photo. Let's show an example [...] Now let's try and estimate the background using estimate_background. First, we'll si gma-clip to try and remove the signals from the stars. Then, the background is broken down into boxes, in this case of size (50, 50). Within each box, the given statistical estimators get the background value and RMS. By default, we use SourceExtractorBackground and StdRMS. This creates a low-resolution image, which we then need to resize. We can accomplish this using an interpolator, by default a cubic-spline interpolator via ZoomInterpolator. The end result is a smooth estimate of the spatially varying background and background RMS. using Photometry\nusing AstroImages\nusing Plots # optional, for implot functionality\n\n# Download our image, courtesy of astropy\nurl = \"https://rawcdn.githack.com/astropy/photutils-datasets/8c97b4fa3a6c9e6ea072faeed2d49a20585658ba/data/M6707HH.fits\"\nimage = AstroImage(download(url))\n\n# sigma-clip\nclipped = sigma_clip(image, 1, fill=NaN)\n\n# get background and background rms with box-size (50, 50)\nbkg, bkg_rms = estimate_background(clipped, 50)\n\nimview(image)\nimview(clipped)\nimview(bkg)\nimview(bkg_rms) Or, if you have Plots loaded: using Plots\n\nAstroImages.set_clims!(Percent(99.5))\nAstroImages.set_cmap!(:magma)\nAstroImages.set_stretch!(identity)\n\nplot(\n    implot(image, title=\"Original\"),\n    implot(clipped, title=\"Sigma-Clipped\"),\n    implot(bkg, title=\"Background\"),\n    implot(bkg_rms, title=\"Background RMS\"),\n    layout=(2, 2),\n    ticks=false,\n) We could apply a median filter, too, by specifying  filter_size # get background and background rms with box-size (50, 50) and filter_size (5, 5)\nbkg_f, bkg_rms_f = estimate_background(clipped, 50, filter_size=5)\n\n# plot\nplot(\n    implot(bkg, title=\"Unfiltered\", ylabel=\"Background\"),\n    implot(bkg_f, title=\"Filtered\"),\n    implot(bkg_rms, ylabel=\"RMS\"),\n    implot(bkg_rms_f);\n    layout=(2, 2),\n    ticks=false,\n) Now we can see our image after subtracting the filtered background and ready for Aperture Photometry! subt = image .- bkg_f[axes(image)...]\nclims = extrema(vcat(vec(image), vec(subt)))\nplot(\n    implot(image; title=\"Original\", clims),\n    implot(subt; title=\"Subtracted\", clims),\n    size=(1600,1000)\n)"},{"id":1711,"pagetitle":"Extracting Photometry","title":"Source Extraction","ref":"/AstroImages/stable/guide/photometry/#Source-Extraction","content":" Source Extraction From the background-subtracted image, we can detect all sources in the image: # We specify the uncertainty in the pixel data. We'll set it equal to zero.\nerrs = zeros(axes(subt))\nsources = extract_sources(PeakMesh(), subt, errs, true) # sort from brightest to darkest Table with 3 columns and 60924 rows:\n      x     y     value\n    ┌────────────────────\n 1  │ 255   226   9762.42\n 2  │ 940   681   9661.5\n 3  │ 219   924   9653.78\n 4  │ 38    678   9647.93\n 5  │ 245   85    9637.55\n 6  │ 44    1001  9633.13\n 7  │ 503   904   9627.34\n 8  │ 819   775   9625.92\n 9  │ 610   62    9617.79\n 10 │ 133   110   9616.88\n 11 │ 592   123   9614.86\n 12 │ 1055  248   9612.46\n 13 │ 424   86    9611.86\n 14 │ 558   125   9585.93\n 15 │ 125   1021  9582.11\n 16 │ 112   637   9579.71\n 17 │ 196   2     9579.49\n ⋮  │  ⋮     ⋮       ⋮ There's over 60,000 sources! We'll define a circular apperture for each source: aps = CircularAperture.(sources.x, sources.y, 6)[1:1000] # just brightest thousand point sources 1000-element Vector{CircularAperture{Int64}}:\n CircularAperture(255, 226, r=6)\n CircularAperture(940, 681, r=6)\n CircularAperture(219, 924, r=6)\n CircularAperture(38, 678, r=6)\n CircularAperture(245, 85, r=6)\n CircularAperture(44, 1001, r=6)\n CircularAperture(503, 904, r=6)\n CircularAperture(819, 775, r=6)\n CircularAperture(610, 62, r=6)\n CircularAperture(133, 110, r=6)\n ⋮\n CircularAperture(697, 975, r=6)\n CircularAperture(703, 599, r=6)\n CircularAperture(893, 878, r=6)\n CircularAperture(291, 457, r=6)\n CircularAperture(660, 855, r=6)\n CircularAperture(711, 920, r=6)\n CircularAperture(708, 271, r=6)\n CircularAperture(701, 273, r=6)\n CircularAperture(710, 273, r=6) We can overplot them on our original image. The coordinate sytem used by the Photometry.jl plot recipes (but not the actual return values) doesn't match AstroImages, so we must transpose our image: implot(subt', colorbar=false)\nplot!(aps)"},{"id":1712,"pagetitle":"Extracting Photometry","title":"Measuring Photometry","ref":"/AstroImages/stable/guide/photometry/#Measuring-Photometry","content":" Measuring Photometry Finally we can extract the source photometry table = photometry(aps, subt) Table with 3 columns and 1000 rows:\n      xcenter  ycenter  aperture_sum\n    ┌───────────────────────────────\n 1  │ 255      226      20542.4\n 2  │ 940      681      7125.3\n 3  │ 219      924      14741.0\n 4  │ 38       678      31056.4\n 5  │ 245      85       -910.308\n 6  │ 44       1001     2792.62\n 7  │ 503      904      6954.07\n 8  │ 819      775      -3136.61\n 9  │ 610      62       4338.13\n 10 │ 133      110      22219.0\n 11 │ 592      123      18562.2\n 12 │ 1055     248      3277.33\n 13 │ 424      86       255299.0\n 14 │ 558      125      6659.03\n 15 │ 125      1021     11524.1\n 16 │ 112      637      1349.78\n 17 │ 196      2        -797.491\n ⋮  │    ⋮        ⋮          ⋮ And plot them: scatter(\n    table.xcenter,\n    table.ycenter,\n    aspectratio=1,\n    marker_z=table.aperture_sum,\n    markerstrokewidth=0,\n    label=\"\",\n    framestyle=:box,\n    background_inside=:black,\n    color=:white\n)"},{"id":1715,"pagetitle":"Reprojecting Images","title":"Reprojecting Images","ref":"/AstroImages/stable/guide/reproject/#Reprojecting-Images","content":" Reprojecting Images Integration with the  Reproject.jl  package is not yet complete."},{"id":1718,"pagetitle":"Array Operations","title":"Array Operations","ref":"/AstroImages/stable/manual/array/#Array-Operations","content":" Array Operations You can operate on an  AstroImage  like any other Julia array. using AstroImages\n\nimg = AstroImage(randn(10,10))"},{"id":1719,"pagetitle":"Array Operations","title":"Indexing","ref":"/AstroImages/stable/manual/array/#Indexing","content":" Indexing You can look up individual pixels (see  Conventions ) img[1,1] # Bottom left 1.823493617711442 img[1:5,1:5]"},{"id":1720,"pagetitle":"Array Operations","title":"Broadcasting","ref":"/AstroImages/stable/manual/array/#Broadcasting","content":" Broadcasting AstroImages participate in broadcasting as expected: @. img + img^2 + 2img^3 You can update them in-place (if the underlying array you passed supports mutation) img[1:5,:] .= 0\nimg"},{"id":1723,"pagetitle":"Conventions","title":"Conventions","ref":"/AstroImages/stable/manual/conventions/#Conventions","content":" Conventions In the Julia Astro ecosystem, images follow the following conventions."},{"id":1724,"pagetitle":"Conventions","title":"Axes","ref":"/AstroImages/stable/manual/conventions/#Axes","content":" Axes For simple 2D images, the first axis is the horizontal axis and the second axis is the vertical axis. So images are indexed by  img[xi, yi] . The origin is at the bottom left of the image, so  img[1,1]  refers to the bottom left corner as does  img[begin,begin] .  img[end,end]  is the top right corner,  img[begin,end]  is the top left, etc. Note that this is transposed and flipped from how Julia prints arrays at the REPL."},{"id":1725,"pagetitle":"Conventions","title":"Pixels","ref":"/AstroImages/stable/manual/conventions/#Pixels","content":" Pixels This library considers the exact location of  img[1,1]  to be the center of the pixel in the bottom left corner. This means that plot limits should have the  1  tick slightly away from the left/bottom spines of the image. The default plot limits for  implot  are  -0.5  to  end+0.5  along both axes. There is a  known bug  with the Plots.jl GR backend that leads ticks to be slightly offset. PyPlot and Plotly backends show the correct tick locations."},{"id":1728,"pagetitle":"Converting from RGB","title":"Converting From RGB Images","ref":"/AstroImages/stable/manual/converting-from-rgb/#Converting-From-RGB-Images","content":" Converting From RGB Images If you encouter an image in a standard graphics format (e.g. PNG, JPG) that you want to analyze or store in an AstroImage, it will likely contain RGB (or similar) pixels. It is possible to store RGB data in an AstroImage. Let's see how that works: using AstroImages\ndownload(\"https://upload.wikimedia.org/wikipedia/commons/1/15/154-panel_Widefield_Milky_Way_Panorama.jpg\",\"mw-crop2-small.png\")\n\n# First we load it from the PNG file\nmw_png = load(\"mw-crop2-small.png\") You will need the Images.jl package installed to load formats like PNG. Once the RGB image is loaded, we can store it in an AstroImage if we'd like: mw_ai = AstroImage(mw_png) However, we may want to extract the RGB channels first. We can do this using  Images.channelview . Images.channelview  returns a view into the RGB data as a 3 × X × Y dimension cube. Unfortunately, we will have to permute the dimensions slightly. using Images\nmw_png = load(\"mw-crop2-small.png\")\nmw_chan_view = channelview(mw_png)\nmw_rgb_cube = AstroImage(\n    permutedims(mw_chan_view, (3, 2, 1))[:,end:-1:begin,:],\n    # Optional:\n    (X=:, Y=:, Spec=[:R,:G,:B])\n) ╭─────────────────────────────────╮ \n │  11096 × 2979 × 3  AstroImage{N0f8,3}  │ \n ├─────────────────────────────────┴────────────────────────────────────── dims ┐ \n   ↓ X    ,\n   → Y    ,\n   ↗ Spec  Categorical{Symbol}  [:R, :G, :B]   ReverseOrdered \n └──────────────────────────────────────────────────────────────────────────────┘ \n[ : ,  : ,  1 ]\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n ⋮                        ⋮              ⋱                 ⋮              \n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0 Here we chose to mark the third axis as a spectral axis with keys  :R ,  :G , and  :B . We can now visualize each channel: mw_rgb_cube[Spec=At(:R)] # Or just: mw_rgb_cube[:,:,1] imview(\n    mw_rgb_cube[Spec=At(:R)],\n    cmap=nothing # Grayscale mode\n) using Plots\nimplot(mw_rgb_cube[Spec=At(:B)])"},{"id":1731,"pagetitle":"Converting to RGB","title":"Converting to RGB","ref":"/AstroImages/stable/manual/converting-to-rgb/#Converting-to-RGB","content":" Converting to RGB If you have two or more images of the same scene taken at different wavelengths, you may wish to combine them to create a colour composite. For ultimate control, you can do this manually using  imview . Simply map your channels to  RGB  values using  imview  and then sum the results. For convenience, AstroImages.jl provides the function  composecolors ."},{"id":1732,"pagetitle":"Converting to RGB","title":"Using composecolors","ref":"/AstroImages/stable/manual/converting-to-rgb/#Using-composecolors","content":" Using  composecolors We'll demonstrate  composecolors  using Hubble images of the Antenae colliding galaxies. One can be very scientific about this process, but often the goal of producing color composites is aesthetic or about highlighting certain features for public consumption. I'll set the default color map to grayscale to avoid confusion. using AstroImages\n\nAstroImages.set_cmap!(nothing) Let's start by downloading the separate color channel FITS files: # We crop some of the images a bit to help align them with the other color channels\nantred = AstroImage(download(\"https://esahubble.org/static/projects/fits_liberator/datasets/antennae/red.fits\"))[:, begin+14:end] antgreen = AstroImage(download(\"https://esahubble.org/static/projects/fits_liberator/datasets/antennae/green.fits\")) antblue = AstroImage(download(\"https://esahubble.org/static/projects/fits_liberator/datasets/antennae/blue.fits\"))[:, begin+14:end] anthalph = AstroImage(download(\"https://esahubble.org/static/projects/fits_liberator/datasets/antennae/hydrogen.fits\"))[:, begin+14:end]; # Hydrogen-Alpha; we'll revisit later In order to compose these images, we'll have to match the relative intensity scales and clip outlying values. Thankfully,  composecolors  handles most of these details automatically. rgb1 = composecolors([antred, antgreen, antblue]) It's a start! Note For best results, the images should be properly aligned and cropped to the same size before making a color composite. The simple cropping we did here is just for demonstration purposes. By default, if you provide three images these are mapped to the color channels red, green, and blue. The intensities are limited to  Percent(99.5) . We can now tweak these defaults to our tastes. We could try clamping the intensities more agressively to bring out more of the galaxy structure: rgb2 = composecolors(\n    [antred, antgreen, antblue],\n    clims=Percent(97)\n) This looks okay but saturates the galaxy cores. Let's take care of that gash through the image by just blanking it out. mask = antgreen .== antgreen[end,begin]\n# remove holes in the mask\nusing ImageFiltering, Statistics\nmask = BitMatrix(mapwindow(median, mask, (3,3)))\nimview(mask) antred[mask] .= NaN\nantgreen[mask] .= NaN\nantblue[mask] .= NaN\nanthalph[mask] .= NaN Typically we need to perform a \"gamma correction\" aka non-lienar stretch to map the wide dynamic range of astronomical images into a narrower human visible range. We can do this using the  stretch  keyword. An  asinhstretch  is typically recommended when preparing RGB images: rgb3 = composecolors(\n    [antred, antgreen, antblue],\n    stretch=asinhstretch\n) Keywords like  strech ,  clims , etc can be either a single value for all channels or a list of separate values/functions per channel. The green channel appears to be quite faint compared to the red and blue channels. We can modify that by adjusting the relative intensities of the channels. We could also do this using a combination of the  contrast  and  bias  keywords. rgb4 = composecolors(\n    [antred, antgreen, antblue],\n    stretch=asinhstretch,\n    multiplier=[1,1.7,1]\n) That's better! Let's go one step further, and incorporate a fourth chanel: Hydrogen Alpha. Hydrogen Alpha is a narrow filter centered around one of the emission lines of Hydrogen atoms. It traces locations with hot gas; mostly star-formation regions in this case. imview(anthalph, cmap=:magma, clims=Zscale()) We'll now need to specify the color channels we want to use for each wavelength since we can't use just the default three RGB. We can use any named color or julia ColorScheme. rgb5 = composecolors(\n    [antred, antgreen, antblue, anthalph],\n    [\"red\", \"green\", \"blue\", \"maroon1\"],\n    stretch=asinhstretch,\n    multiplier=[1,1.7,1,0.8]\n) Additionally, I'd like to just show the brightest areas of Hydrogen alpha emission rather than adding a diffuse pink glow. We can turn off the stretch for this one channel: rgb6 = composecolors(\n    [antred, antgreen, antblue, anthalph],\n    [\"red\", \"green\", \"blue\", \"maroon1\"],\n    stretch=[\n        asinhstretch,\n        asinhstretch,\n        asinhstretch,\n        identity,\n    ],\n    multiplier=[1,1.7,1,0.8]\n) Finally, we can crop the image and save it as a PNG. crop = rgb6[200:end-100,50:end-50] save(\"antenae-composite.png\", crop) If you want to save it in a format like  JPG  that doesn't support transparent pixels, you could replace the masked area with zeros instead of  NaN ."},{"id":1735,"pagetitle":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","ref":"/AstroImages/stable/manual/dimensions-and-world-coordinates/#Dimensions-and-World-Coordinates","content":" Dimensions and World Coordinates AstroImages are based on  Dimensional Data . Each axis is assigned a dimension name and the indices are tracked."},{"id":1736,"pagetitle":"Dimensions and World Coordinates","title":"World Coordinates","ref":"/AstroImages/stable/manual/dimensions-and-world-coordinates/#World-Coordinates","content":" World Coordinates FITS files with world coordinate system (WCS) headers contain all the information necessary to map a pixel location into celestial coordinates & back. Let's see how this works with a 2D image with RA & DEC coordinates. using AstroImages\nusing Plots\n\n# Download a Hubble image of the Eagle nebula\ndownload(\n    \"https://ds9.si.edu/download/data/656nmos.fits\",\n    \"eagle-656nmos.fits\"\n);\neagle = load(\"eagle-656nmos.fits\") This image contains world coordinate system headers. AstroImages.jl uses WCS.jl (and wcslib under the hood) to parse these headers. We can generate a WCSTransform object to inspect: wcs(eagle, 1) # specify which coordinate system WCSTransform(naxis=2,cdelt=[1.0, 1.0],crval=[274.71149247724, -13.816384007184],crpix=[386.5, 396.0]) Note that we specify with an index which coordinate system we'd like to use. Most images just contain one, but some contain multiple systems. We can lookup a coordinate from the image: world = pix_to_world(eagle, [1, 1]) # Bottom left corner 2-element Vector{Float64}:\n 274.712299241082\n -13.801135972688115 Or convert back from world coordinates to pixel coordinates: We can lookup a coordinate from the image: world_to_pix(eagle, world) # Bottom left corner 2-element Vector{Float64}:\n 1.000000000336172\n 0.9999999992196535 These pixel coordinates do not necessarily have to lie within the bounds of the original image, and in general lie at a fractional pixel position. If an image contains WCS headers, we can visualize them using  implot : implot(eagle) We can adjust the color of the grid: implot(eagle, gridcolor=:cyan) If these aren't desired, we can turn off the grid or the WCS tick marks: plot(\n  implot(eagle, grid=false),\n  implot(eagle, wcsticks=false),\n  size=(900,300),\n  bottommargin=10Plots.mm\n) Since AstroImages are based on DimensionalData's AbstractDimArray, the mapping between pixel coordinates and world coordinates are preserved when slicing an AstroImage: slice1 = eagle[1:800,1:800]\nslice2 = eagle[800:1600,1:800]\nplot(\n  implot(slice1),\n  implot(slice2),\n  size=(900,300),\n  bottommargin=10Plots.mm\n) World coordinate queries from that slice are aware of their position in the parent image: @show pix_to_world(slice1, [1,1]) 2-element Vector{Float64}:\n 274.712299241082\n -13.801135972688115 @show pix_to_world(slice2, [1,1]) 2-element Vector{Float64}:\n 274.7277517847315\n -13.817350009028138 Note that you can query the dimensions of an image using the  dims  function from DimensionalData: dims(slice2) ( ↓ X  Sampled{Int64}  800:1600   ForwardOrdered   Regular   Points ,\n → Y  Sampled{Int64}  1:800   ForwardOrdered   Regular   Points )"},{"id":1737,"pagetitle":"Dimensions and World Coordinates","title":"Named Dimensions","ref":"/AstroImages/stable/manual/dimensions-and-world-coordinates/#Named-Dimensions","content":" Named Dimensions Each dimension of an AstroImage is named. The automatic dimension names are  X ,  Y ,  Z ,  Dim{4} ,  Dim{5} , and so on; however you can pass in other names or orders to the load function and/or AstroImage contructor: julia> img = load(\"eagle-656nmos.fits\", 1, (Y,Z))\n1600×1600 AstroImage{Float32,2} with dimensions:\n  Y Sampled 1:1600 ForwardOrdered Regular Points,\n  Z Sampled 1:1600 ForwardOrdered Regular Points Other useful dimension names are  Spec  for spectral axes,  Pol  for polarization data, and  Ti  for time axes. These are tracked the same way as the automatic dimension names and interact smoothly with any WCS headers. You can give a dimension an arbitrary name using  Dim{Symbol} , e.g.,  Dim{:Velocity} . You can access AstroImages using dimension names: eagle[X=100] ╭────────────────────────────────────╮ \n │  1600-element  AstroImage{Float32,1}  │ \n ├────────────────────────────────────┴─────────────────────────────────── dims ┐ \n   ↓ Y  Sampled{Int64}  1:1600   ForwardOrdered   Regular   Points \n └──────────────────────────────────────────────────────────────────────────────┘ \n     1   0.0\n     2   0.0\n     3   0.0\n     4   0.0\n     5   0.0\n     6   0.0\n    ⋮  \n  1596   0.0\n  1597   0.0\n  1598   0.0\n  1599   0.0\n  1600   0.0 When indexing into a slice out of a larger parent image or cube, this named access refers to the  parent  dimensions: slice1 = eagle[600:800,600:800]\nslice1[X=At(700),Y=At(700)] == eagle[X=At(700),Y=At(700)] == eagle[700,700] true"},{"id":1738,"pagetitle":"Dimensions and World Coordinates","title":"Cubes","ref":"/AstroImages/stable/manual/dimensions-and-world-coordinates/#Cubes","content":" Cubes Let's see how this works with a 3D cube. using AstroImages\n\nHIcube = load(download(\"https://www.astropy.org/astropy-data/tutorials/FITS-cubes/reduced_TAN_C14.fits\")) ╭───────────────────────────────────╮ \n │  150 × 150 × 450  AstroImage{Float32,3}  │ \n ├───────────────────────────────────┴──────────────────────────────────── dims ┐ \n   ↓ X  Sampled{Int64}  Base.OneTo(150)   ForwardOrdered   Regular   Points ,\n   → Y  Sampled{Int64}  Base.OneTo(150)   ForwardOrdered   Regular   Points ,\n   ↗ Z  Sampled{Int64}  Base.OneTo(450)   ForwardOrdered   Regular   Points \n └──────────────────────────────────────────────────────────────────────────────┘ \n[ : ,  : ,  1 ]\n    ↓   →      1      2      3      4      5      6   …   144    145    146    147    148    149    150 \n    1     NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n    2     NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n    3     NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n    4     NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n   ⋮                          ⋮       ⋱         ⋮                        ⋮\n  147     NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n  148     NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n  149     NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n  150     NaN  NaN  NaN  NaN  NaN  NaN  …  NaN  NaN  NaN  NaN  NaN  NaN  NaN Notice how the cube is not displayed automatically. We have to pick a specific slice: HIcube[Z=228] Using  implot , the world coordinates are displayed automatically: implot(HIcube[Z=228], cmap=:turbo) The plot automatically reflects the world coordinates embeded in the file. It displays the x axis in galactic longitude, the y-axis in galactic latitude, and even shows the curved projection from pixel coordinates to galactic coordinates. The title is automatically set to the world coordinate along the Z axis in units of velocity. It also picks up the unit of the data (Kelvins) to display on the colorbar. If we pick another slice, the title updates accordingly: implot(HIcube[Z=308], cmap=:turbo) This works for other slices through the cube as well: implot(HIcube[Y=45],  cmap=:turbo, aspectratio=0.3)"},{"id":1739,"pagetitle":"Dimensions and World Coordinates","title":"Custom Dimensions","ref":"/AstroImages/stable/manual/dimensions-and-world-coordinates/#Custom-Dimensions","content":" Custom Dimensions julia> img = load(\"img.fits\",1,(Y=1:1600,Z=1:1600))\n1600×1600 AstroImage{Float32,2} with dimensions:\n  Y Sampled 1:1600 ForwardOrdered Regular Points,\n  Z Sampled 1:1600 ForwardOrdered Regular Points Other useful dimension names are  Spec  for spectral axes,  Pol  for polarization data, and  Ti  for time axes. These are tracked the same was as the automatic dimension names and interact smoothly with any WCS headers. Often times we have images or cubes that we want to index with physical coordinates where setting up a full WCS transform is overkill. In these cases, it's easier to leverage custom dimensions. For example, one may wish to julia> img = load(\"img.fits\",1,(X=801:2400,Y=1:2:3200))\n1600×1600 AstroImage{Float32,2} with dimensions:\n  X Sampled 801:2400 ForwardOrdered Regular Points,\n  Y Sampled 1:2:3199 ForwardOrdered Regular Points\n... Unlike OffsetArrays, the usual indexing remains so  img[1,1]  is still the bottom left of the image; however, data can be looked up according to the offset dimensions using specifiers: julia> img[X=Near(2000),Y=1..100]\n50-element AstroImage{Float32,1} with dimensions:\n  Y Sampled 1:2:99 ForwardOrdered Regular Points\nand reference dimensions:\n  X Sampled 2000:2000 ForwardOrdered Regular Points\n  0.0 You can adjust the center of an image's dimensions using  recenter : eagle_cen = recenter(eagle, 801, 801); Unlike an OffsetArray,  eagle_cen[1,1]  still refers to the bottom left of the image. This also has no effect on broadcasting;  eagle_cen .+ ones(1600,1600)  is perfectly valid. However, we see the new centered dimensions when we go to plot the image: implot(eagle_cen, wcsticks=false) And we can query positions using the offset dimensions: implot(eagle_cen[X=-300..300, Y=-300..300], wcsticks=false)"},{"id":1742,"pagetitle":"Displaying Images","title":"Displaying Images","ref":"/AstroImages/stable/manual/displaying-images/#Displaying-Images","content":" Displaying Images The  imview  and  implot  functions are very similar. Both allow any abstract array of numbers to be rendered into an image or a Plots.jl image series.  implot  is largely a superset of  imview  because it also supports colorbars, tick marks, WCS grid lines, overplotting other data & shapes, and automatic axis and title naming (from the FITS header if available)."},{"id":1743,"pagetitle":"Displaying Images","title":"imview","ref":"/AstroImages/stable/manual/displaying-images/#imview","content":" imview Any AbstractArray (including an AstroImage) can be displayed using  imview . This function renders an arbitrary array into an array of  RGBA  values using a number of parameters. If the input is an AstroImage{<:Number}, an AstroImage{RGBA} will be returned that retains headers, WCS information, etc. The defaults for the  imview  function are: img = randn(50,50);\nimview(img; clims=Percent(99.5), cmap=:magma, stretch=identity, contrast=1.0, bias=0.5) We can adjust the color limits explicitly: imview(img; clims=(-1, 1)) Or pass a function/callable object to calculate them for us: imview(img; clims=Zscale()) We can turn off the colormap and use it in grayscale mode: imview(img; cmap=nothing) Pass any color scheme from ColorSchemes.jl: imview(img; cmap=:ice) imview(img; cmap=:seaborn_rocket_gradient) Or an RGB or named color value: imview(img; cmap=\"#F00\")\nimview(img; cmap=\"red\") Let's now switch to an astronomical image: fname = download(\n    \"https://ds9.si.edu/download/data/656nmos.fits\",\n    \"eagle-656nmos.fits\"\n);\neagle = AstroImage(\"eagle-656nmos.fits\") We can apply a non-linear stretch like a log-scale, power-scale, or asinh stretch: imview(eagle, stretch=asinhstretch) Once rendered, we can also tweak the bias and contrast: imview(eagle, stretch=asinhstretch, contrast=1.5) imview(eagle, stretch=asinhstretch, contrast=1.5, bias=0.6) These are the parameters that change when you click and drag in some applications like DS9. Once rendered via  imview , the resulting image can be saved in traditional image formats like PNG, JPG, GIF, etc: save(\"out.png\", imview(eagle, cmap=:viridis)) Very large Images are automatically downscaled to ensure consistent performance using  restrict  from Images.jl. This function filters the data before downscaling to prevent aliasing, so it may take a moment for truly huge images. In these cases, a faster method that doesn't prevent aliasing would be  imview(img[begin:10:end, begin:10:end])  or similar. imview  is called automatically on  AstroImage{<:Number}  when using a Julia environment with rich graphical IO capabilities (e.g. VSCode, Jupyter, Pluto, etc.). The defaults for this case can be modified using  AstroImages.set_clims!(...) ,  AstroImages.set_cmap!(...) , and  AstroImages.set_stretch!(...) ."},{"id":1744,"pagetitle":"Displaying Images","title":"Note on Views","ref":"/AstroImages/stable/manual/displaying-images/#Note-on-Views","content":" Note on Views The function  imview  has its name because it produces a \"view\" into the image. The result from calling  imview  is an object that lazily maps data values into RGBA colors on the fly. This means that if you change the underlying data array, the view will update (the next time it is shown). If you have many data files to render, you may find it faster to create a single  imview  and then mutate the data in the underlying array. This is faster since  imview  only has to resolve colormaps and compute limits once. For example: data = randn(100,100)\niv = imview(data)\ndisplay(iv)\ndata[1:50,1:50] .= 0\ndisplay(iv) iv  will reflect the changes to  data  when it is displayed the second time."},{"id":1745,"pagetitle":"Displaying Images","title":"implot","ref":"/AstroImages/stable/manual/displaying-images/#implot","content":" implot implot   is a Plots.jl recipe, which means before you can use it you first have to load  Plots.jl : using Plots implot  accepts all the arguments  imview  does for controlling how data is rendered to the screen: implot(img; clims=Percent(99.5), cmap=:magma, stretch=identity, contrast=1.0, bias=0.5) For more on  implot , including offset dimensions and world coordinates, see  Dimensions and World Coordinates ."},{"id":1748,"pagetitle":"Getting Started","title":"Getting Started","ref":"/AstroImages/stable/manual/getting-started/#Getting-Started","content":" Getting Started To get started, you will first need to install AstroImages. After starting Julia, enter package-mode by typing  ]  and then pkg> add AstroImages To display images and save them in traditional graphics formats like PNG, JPG, GIF, etc., you will also need to add the  ImageIO  package. Once installed, this package doesn't need to be loaded explicitly. For some of the more advanced visualizations you may also want  Plots : pkg> add Plots To load the package, run: using AstroImages\n# And if desired:\nusing Plots"},{"id":1751,"pagetitle":"Headers","title":"Headers","ref":"/AstroImages/stable/manual/headers/#Headers","content":" Headers FITS files consist of one or more HDUs (header data units), and each HDU can contain an N-dimensional image or table. Before the data is a  header . Headers contain (key, value, comment) groups as well as dedicated long-form COMMENT and HISTORY sections used to document, for example, the series of post-processing steps applied to an image."},{"id":1752,"pagetitle":"Headers","title":"Accessing Headers","ref":"/AstroImages/stable/manual/headers/#Accessing-Headers","content":" Accessing Headers Here are some examples of how to set and read keys, comments, and history. Well start by making a blank image. img = AstroImage(zeros(10,10))\n# Set keys to values with different data types\nimg[\"KEY1\"] = 2   # Integer\nimg[\"KEY2\"] = 2.0 # Float\nimg[\"KEY3\"] = \"STRING\"\nimg[\"KEY4\"] = true\nimg[\"KEY5\"] = false\nimg[\"KEY6\"] = nothing\n\n# Set comments\nimg[\"KEY1\", Comment] = \"A key with an integer value\"\n\n# Read keys\na = img[\"KEY3\"]\n\n# Read comment\ncom = img[\"KEY1\", Comment]\n\n# Add long-form COMMENT\npush!(img, Comment, \"\"\"\nWe now describe how to add a long form comment to the end of a header.\n\"\"\")\n\n# Add HISTORY entry\npush!(img, History, \"\"\"\nWe now describe how to add a long form history to the end of a header.\n\"\"\")\n\n# Retrieve long form comments/ history\ncomment_strings = img[Comment]\nhistory_strings = img[History] Note that floating point values are formatted as ASCII strings when written to the FITS files, so the precision may be limited. AstroImage  objects wrap a FITSIO.jl  FITSHeader . If necessary, you can recover it using  header(img) ; however, in most cases you can access header keywords directly from the image. API docs: Comment History header"},{"id":1755,"pagetitle":"Loading & Saving Images","title":"Loading Images","ref":"/AstroImages/stable/manual/loading-images/#Loading-Images","content":" Loading Images FITS (Flexible Image Transport System) files can be loaded and saved using AstroImages thanks to the FITSIO package. AstroImages is registered with  FileIO , so if you have FileIO and AstroImages installed you can get started with the  load  function. When you pass a file name with the appropriate file extension (\".fits\", \".fit\", etc.) FileIO will import AstroImages automatically. Alternatively, you can use the  AstroImage  contructor instead of load. This will work on fits files with any file extension, including compressed files (e.g. \".fits.gz\"). julia> img = load(\"myfitsimg.fits\")\n1600×1600 AstroImage{Float32,2} with dimensions:\n  X Sampled Base.OneTo(1600) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(1600) ForwardOrdered Regular Points\n 0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n ⋮                        ⋱\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0 Note: if you are in an interactive environment like VSCode, Jupyter, or Pluto, instead of a REPL, AstroImages are automatically rendered to images and displayed. You can see this plain text output by explicitly calling:  show(stdout, MIME(\"text/plain\"), img) . Or: julia> img = AstroImage(\"myfitsimg.fits.gz\")\n1600×1600 AstroImage{Float32,2} with dimensions:\n  X Sampled Base.OneTo(1600) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(1600) ForwardOrdered Regular Points\n 0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n ⋮                        ⋱\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0 A FITS file can contain multiple N-dimensional images and tables. When you call load or AstroImage with a file name and no other arguments, the package will search through the file and return the first image HDU. That is, it will skip any FITS tables or empty HDUs with only headers. You can also specify an HDU number explicitly: julia> img = load(\"myfitsimg.fits\",1)\n1600×1600 AstroImage{Float32,2} with dimensions:\n  X Sampled Base.OneTo(1600) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(1600) ForwardOrdered Regular Points\n... This way, you can load specific images from multi-extension files. You can load all HDUs simultaneously by passing  : : julia> hdus = load(\"multiext.fits\", :);\njulia> hdus[2] # Second HDU as an AstroImage\n10×10 AstroImage{Float64,2} with dimensions:\n  X Sampled Base.OneTo(10) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(10) ForwardOrdered Regular Points\n -0.777315  -1.36683   -0.580179     1.39629      …  -2.14298     0.450059   0.432065\n -1.09619    0.789249   0.938415     0.959903        -0.88995    -1.29406   -0.4291\n  0.47427   -1.41855    0.814823    -1.15975          0.0427149  -1.20116   -0.0920709\n -0.179858  -1.60228    1.09648     -0.497927        -1.31824    -0.156529  -0.0223846\n  2.64162    0.131437   0.320476     0.331197        -0.914713   -1.55162   -0.18862\n  0.209669  -1.17923   -0.656512     0.000775311  …   0.377461   -0.24278    0.967202\n  1.01442   -0.762895  -2.13238     -0.456932        -0.415733   -1.21416   -1.6108\n  0.385626   0.389335  -0.00726015   0.309936        -0.533175    0.157878   0.100876\n -1.24799    0.461216  -0.868826    -0.255654        -0.37151     0.49479   -1.87129\n  1.39356    2.29254    0.0548325    1.50674         -0.0880865   0.580978  -1.81629\njulia> # Or:\njulia> hdu1, hdu2, hdu3 = load(\"multiext.fits\", :); There is also limited support for table HDUs. In this case, a bare-bones Tables.jl compatible object is returned."},{"id":1756,"pagetitle":"Loading & Saving Images","title":"Dimension Names","ref":"/AstroImages/stable/manual/loading-images/#Dimension-Names","content":" Dimension Names You may have noticed the entries above the image array: 10×10 AstroImage{Float64,2} with dimensions:\n  X Sampled Base.OneTo(10) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(10) ForwardOrdered Regular Points AstroImages are based on  Dimensional Data . Each axis is assigned a dimension name and the indices are tracked. The automatic dimension names are  X ,  Y ,  Z ,  Dim{4} ,  Dim{5} , and so on; however you can pass in other names or orders to the load function and/or AstroImage contructor: julia> img = load(\"img.fits\", 1, (Y=1:1600,Z=1:1600))\n1600×1600 AstroImage{Float32,2} with dimensions:\n  Y Sampled 1:1600 ForwardOrdered Regular Points,\n  Z Sampled 1:1600 ForwardOrdered Regular Points Other useful dimension names are  Spec  for spectral axes,  Pol  for polarization data, and  Ti  for time axes. These will be further discussed in Dimensions and World Coordinates."},{"id":1757,"pagetitle":"Loading & Saving Images","title":"Saving Images","ref":"/AstroImages/stable/manual/loading-images/#Saving-Images","content":" Saving Images You can save one or more AstroImages and tables to a FITS file using the  save  function: julia> save(\"abc.fits\", astroimage1, astroimage2, table1) You can also save individual images to traditional graphics formats by first rendering them with  imview  (for more on imview, see Displaying Images). julia> save(\"abc.png\", imview(astroimage1)) You can save animated GIFs by saving a 3D datacube that has been rendered with imview: julia> cube =  imview(AstroImage(randn(100,100,10)));\njulia> save(\"abc.gif\", cube, fps=10)\n\njulia> # Or a more complex example (changing color schemes each frame)\njulia> img = randn(10,10)\njulia> cube2 = [imview(img1, cmap=:magma) ;;; imview(img2, cmap=:plasma) ;;; imview(img3, cmap=:viridis)]\n\njulia> # Alternative syntax:\njulia> cube2 = cat(imview(img1, cmap=:magma), imview(img2, cmap=:plasma), imview(img3, cmap=:viridis), dims=3)\n\njulia> save(\"abc.gif\", cube, fps=10)"},{"id":1762,"pagetitle":"Preserving Wrapper","title":"Preserving the AstroImage Wrapper","ref":"/AstroImages/stable/manual/preserving-wrapper/#Preserving-the-AstroImage-Wrapper","content":" Preserving the AstroImage Wrapper Wherever possible, overloads have been added to DimensionalData and AstroImages so that common operations retain the  AstroImage  wrapper with associated dimensions, FITS header, and WCS information. Most of the time this works automatically if libraries follow good patterns like allocating outputs using  Base.similar . However, some other library functions may follow patterns like allocating a plain  Array  of the correct size and then filling it. To make it easier to work with these libraries, AstroImages exports two functions  copyheader  and  shareheader . These functions wrap an AbstractArray in an AstroImage while copying over the header, dimensions, and WCS info. Consider the function: function badfunc(arr)\n    out = zeros(size(arr)) # instead of similar(arr)\n    out .= arr.^2\n    return out\nend Calling  badfunc(astroimg)  will return a plain  Array  . We can use  copyheader  to retain the  AstroImage  wrapper: copyheader(astroimg, badfunc(astroimg)) For particularly incompatible functions that require an Array (not subtype of AbstractArray) we can go one step further: copyheader(astroimg, worsefunc(parent(astroimg)))\n# Or:\ncopyheader(astroimg, worsefunc(collect(astroimg)))"},{"id":1767,"pagetitle":"Home","title":"CFITSIO.jl","ref":"/CFITSIO/stable/#CFITSIO.jl","content":" CFITSIO.jl This module provides an interface familiar to users of the  CFITSIO  C library. It can be used with using CFITSIO The functions exported by this module operate on  FITSFile  objects, which is a thin wrapper around a pointer to a CFITSIO  fitsfile . For the most part, the functions are thin wrappers around the CFITSIO routines of the same names. Typically, they: Convert from Julia types to C types as necessary. Check the returned status value and raise an appropriate exception if non-zero. The functionality is described in the various sections. CFITSIO.jl Quick start Type Conversions File access HDU Routines Header Keyword Routines Image HDU Routines Table Routines Miscellaneous Note For a higher-level interface, consider using  FITSIO.jl ."},{"id":1768,"pagetitle":"Home","title":"Quick start","ref":"/CFITSIO/stable/#Quick-start","content":" Quick start julia> fname = tempname() * \".fits\"; julia> f = fits_create_file(fname); julia> A = ones(2,2) 2×2 Matrix{Float64}:\n 1.0  1.0\n 1.0  1.0 julia> fits_create_img(f, A) julia> fits_get_hdu_type(f) :image_hdu julia> fits_write_pix(f, A) julia> B = similar(A); julia> fits_read_pix(f, B); julia> B 2×2 Matrix{Float64}:\n 1.0  1.0\n 1.0  1.0 julia> fits_read_key_str(f, \"NAXIS\") (\"2\", \"number of data axes\") julia> fits_create_binary_tbl(f, 0, [(\"COUNT\", \"J\", \"counts\"), (\"ENERGY\", \"D\", \"energy\")], \"Spectrum\") julia> fits_write_col(f, 1, 1, 1, [2, 10, 5]) julia> fits_write_col(f, 2, 1, 1, [10.0, 15.0, 20.0]) julia> counts, energy = zeros(Int,3), zeros(Float64,3) ([0, 0, 0], [0.0, 0.0, 0.0]) julia> fits_read_col(f, 1, 1, 1, counts) 3-element Vector{Int64}:\n  2\n 10\n  5 julia> fits_read_col(f, 1, 1, 1, energy) 3-element Vector{Float64}:\n  2.0\n 10.0\n  5.0 julia> counts, energy ([2, 10, 5], [2.0, 10.0, 5.0]) julia> fits_close_file(f)"},{"id":1771,"pagetitle":"File","title":"File access","ref":"/CFITSIO/stable/file/#File-access","content":" File access"},{"id":1772,"pagetitle":"File","title":"CFITSIO.fits_assert_open","ref":"/CFITSIO/stable/file/#CFITSIO.fits_assert_open","content":" CFITSIO.fits_assert_open  —  Function fits_assert_open(f::FITSFile) Assert that the FITS file  f  is open, otherwise throw an error. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_assert_open(f)\n\njulia> fits_create_empty_img(f)\n\njulia> close(f)\n\njulia> fits_assert_open(f)\nERROR: ArgumentError: attempt to access a FITS file that has been closed previously\n[...] source"},{"id":1773,"pagetitle":"File","title":"CFITSIO.fits_create_file","ref":"/CFITSIO/stable/file/#CFITSIO.fits_create_file","content":" CFITSIO.fits_create_file  —  Function fits_create_file(filename::AbstractString) Create and open a new empty output  FITSFile . This methods uses the  extended file name syntax  to create the file. Note This function does not overwrite an existing file with the same name, and will throw an exception if this is the case. See  fits_clobber_file  to delete existing files before creating one. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_file_mode(f) # opened in read-write mode\n1\n\njulia> fits_create_empty_img(f)\n\njulia> close(f) See also  fits_create_diskfile  which does not use the extended filename parser. source"},{"id":1774,"pagetitle":"File","title":"CFITSIO.fits_create_diskfile","ref":"/CFITSIO/stable/file/#CFITSIO.fits_create_diskfile","content":" CFITSIO.fits_create_diskfile  —  Function fits_create_diskfile(filename::AbstractString) Create and open a new empty output  FITSFile . Unlike  fits_create_file , this function does not use an extended filename parser and treats the string as is as the filename. Note This function does not overwrite an existing file with the same name, and will throw an exception if this is the case. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_diskfile(fname);\n\njulia> fits_file_mode(f) # opened in read-write mode\n1\n\njulia> fits_create_empty_img(f)\n\njulia> close(f) source"},{"id":1775,"pagetitle":"File","title":"CFITSIO.fits_clobber_file","ref":"/CFITSIO/stable/file/#CFITSIO.fits_clobber_file","content":" CFITSIO.fits_clobber_file  —  Function fits_clobber_file(filename::AbstractString) Like  fits_create_file , but overwrites  filename  if it exists. source"},{"id":1776,"pagetitle":"File","title":"CFITSIO.fits_close_file","ref":"/CFITSIO/stable/file/#CFITSIO.fits_close_file","content":" CFITSIO.fits_close_file  —  Function fits_close_file(f::FITSFile) Close a previously opened FITS file. This is equivalent to calling  close(f)  on the  FITSFile  object. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_close_file(f)\n\njulia> fits_assert_open(f)\nERROR: ArgumentError: attempt to access a FITS file that has been closed previously\n[...] source"},{"id":1777,"pagetitle":"File","title":"CFITSIO.fits_delete_file","ref":"/CFITSIO/stable/file/#CFITSIO.fits_delete_file","content":" CFITSIO.fits_delete_file  —  Function fits_delete_file(f::FITSFile) Close an opened FITS file (like  fits_close_file ) and removes it from the disk. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_delete_file(f)\n\njulia> isfile(fname)\nfalse\n\njulia> fits_assert_open(f)\nERROR: ArgumentError: attempt to access a FITS file that has been closed previously\n[...] source"},{"id":1778,"pagetitle":"File","title":"CFITSIO.fits_file_name","ref":"/CFITSIO/stable/file/#CFITSIO.fits_file_name","content":" CFITSIO.fits_file_name  —  Function fits_file_name(f::FITSFile)::String Return the name of the file associated with object  f . Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_file_name(f) |> basename\n\"test.fits\"\n\njulia> fits_file_name(f) == fname\ntrue\n\njulia> fits_create_empty_img(f)\n\njulia> close(f) source"},{"id":1779,"pagetitle":"File","title":"CFITSIO.fits_file_mode","ref":"/CFITSIO/stable/file/#CFITSIO.fits_file_mode","content":" CFITSIO.fits_file_mode  —  Function fits_file_mode(f::FITSFile) Return the I/O mode of the FITS file, where 0 indicates a read-only mode and 1 indicates a read-write mode. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_file_mode(f)\n1\n\njulia> fits_create_empty_img(f)\n\njulia> close(f)\n\njulia> f = fits_open_file(fname, CFITSIO.READONLY);\n\njulia> fits_file_mode(f)\n0\n\njulia> close(f) source"},{"id":1780,"pagetitle":"File","title":"CFITSIO.fits_flush_buffer","ref":"/CFITSIO/stable/file/#CFITSIO.fits_flush_buffer","content":" CFITSIO.fits_flush_buffer  —  Function fits_flush_buffer(f::FITSFile) Flush the buffer to disk without updating and closing the current HDU. This is faster than  fits_flush_file , and may be used to write the state of the file to disk after each row of a table is written. Note In most cases, this function should not be needed, as the library automatically flushes the file when it is closed. source"},{"id":1781,"pagetitle":"File","title":"CFITSIO.fits_flush_file","ref":"/CFITSIO/stable/file/#CFITSIO.fits_flush_file","content":" CFITSIO.fits_flush_file  —  Function fits_flush_file(f::FITSFile) Flush the file to disk. This is equivalent to closing the file and reopening it. Note In most cases, this function should not be needed, as the library automatically flushes the file when it is closed. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\", \"units\")])\n\njulia> fits_write_col(f, 1, 1, 1, [1, 2, 3])\n\njulia> CFITSIO.fits_flush_file(f) # flush the file to disk\n\njulia> fits_read_col(f, 1, 1, 1, zeros(Int32, 3))\n3-element Vector{Int32}:\n 1\n 2\n 3\n\njulia> close(f) source"},{"id":1782,"pagetitle":"File","title":"CFITSIO.fits_open_file","ref":"/CFITSIO/stable/file/#CFITSIO.fits_open_file","content":" CFITSIO.fits_open_file  —  Function fits_open_file(filename::String, [mode = 0]) Open an existing data file. Modes: 0 : Read only (equivalently denoted by  CFITSIO.READONLY  or  CFITSIO.R ) 1 : Read-write (equivalently denoted by  CFITSIO.READWRITE  or  CFITSIO.RW ) This function uses the extended filename syntax to open the file. See also  fits_open_diskfile  that does not use the extended filename parser and uses  filename  as is as the name of the file. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> close(f)\n\njulia> f = fits_open_file(fname, CFITSIO.READONLY);\n\njulia> fits_file_mode(f) # opened in read-only mode\n0\n\njulia> fits_movabs_hdu(f, 1) # move to primary HDU\n:image_hdu\n\njulia> fits_get_img_dim(f) # get image dimensions\n0\n\njulia> close(f) source"},{"id":1783,"pagetitle":"File","title":"CFITSIO.fits_open_diskfile","ref":"/CFITSIO/stable/file/#CFITSIO.fits_open_diskfile","content":" CFITSIO.fits_open_diskfile  —  Function fits_open_diskfile(filename::String, [mode = 0]) Open an existing data file. Modes: 0 : Read only (equivalently denoted by  CFITSIO.READONLY  or  CFITSIO.R ) 1 : Read-write (equivalently denoted by  CFITSIO.READWRITE  or  CFITSIO.RW ) This function does not use the extended filename parser, and uses  filename  as is as the name of the file that is to be opened. See also  fits_open_file  which uses the extended filename syntax. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_diskfile(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> close(f)\n\njulia> f = fits_open_diskfile(fname, CFITSIO.READONLY);\n\njulia> fits_file_mode(f) # opened in read-only mode\n0\n\njulia> fits_movabs_hdu(f, 1) # move to primary HDU\n:image_hdu\n\njulia> fits_get_img_dim(f) # get image dimensions\n0\n\njulia> close(f) source"},{"id":1784,"pagetitle":"File","title":"CFITSIO.fits_open_table","ref":"/CFITSIO/stable/file/#CFITSIO.fits_open_table","content":" CFITSIO.fits_open_table  —  Function fits_open_table(filename::String, [mode = 0]) Open an existing data file (like  fits_open_file ) and move to the first HDU containing either an ASCII or a binary table. Modes: 0 : Read only (equivalently denoted by  CFITSIO.READONLY  or  CFITSIO.R ) 1 : Read-write (equivalently denoted by  CFITSIO.READWRITE  or  CFITSIO.RW ) Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\"), (\"col2\", \"1D\")])\n\njulia> close(f)\n\njulia> f = fits_open_table(fname, CFITSIO.READONLY);\n\njulia> fits_get_hdu_num(f)\n2\n\njulia> fits_get_num_rows(f)\n0\n\njulia> fits_get_num_cols(f)\n2\n\njulia> close(f) source"},{"id":1785,"pagetitle":"File","title":"CFITSIO.fits_open_image","ref":"/CFITSIO/stable/file/#CFITSIO.fits_open_image","content":" CFITSIO.fits_open_image  —  Function fits_open_image(filename::String, [mode = 0]) Open an existing data file (like  fits_open_file ) and move to the first HDU containing an image. Modes: 0 : Read only (equivalently denoted by  CFITSIO.READONLY  or  CFITSIO.R ) 1 : Read-write (equivalently denoted by  CFITSIO.READWRITE  or  CFITSIO.RW ) Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\"), (\"col2\", \"1D\")])\n\njulia> A = [1 2; 3 4];\n\njulia> fits_create_img(f, A)\n\njulia> fits_write_pix(f, A)\n\njulia> close(f)\n\njulia> f = fits_open_image(fname, CFITSIO.READONLY); # moves to the last HDU\n\njulia> fits_get_hdu_num(f)\n3\n\njulia> B = similar(A);\n\njulia> fits_read_pix(f, B);\n\njulia> B == A\ntrue\n\njulia> close(f) source"},{"id":1786,"pagetitle":"File","title":"CFITSIO.fits_open_data","ref":"/CFITSIO/stable/file/#CFITSIO.fits_open_data","content":" CFITSIO.fits_open_data  —  Function fits_open_data(filename::String, [mode = 0]) Open an existing data file (like  fits_open_file ) and move to the first HDU containing either an image or a table. Modes: 0 : Read only (equivalently denoted by  CFITSIO.READONLY  or  CFITSIO.R ) 1 : Read-write (equivalently denoted by  CFITSIO.READWRITE  or  CFITSIO.RW ) Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> A = [1 2; 3 4];\n\njulia> fits_create_img(f, A)\n\njulia> fits_write_pix(f, A)\n\njulia> close(f)\n\njulia> f = fits_open_data(fname, CFITSIO.READONLY);\n\njulia> B = similar(A);\n\njulia> fits_read_pix(f, B);\n\njulia> B == A\ntrue\n\njulia> close(f) source"},{"id":1789,"pagetitle":"HDU","title":"HDU Routines","ref":"/CFITSIO/stable/hdu/#HDU-Routines","content":" HDU Routines The functions described in this section change the current HDU and to find their number and type. The following is a short example which shows how to use them: num = fits_get_num_hdus(f)\nprintln(\"Number of HDUs in the file: \", num)\n\nfor i = 1:num\n    hdu_type = fits_movabs_hdu(f, i)\n    println(i, \") hdu_type = \", hdu_type)\nend"},{"id":1790,"pagetitle":"HDU","title":"CFITSIO.fits_get_num_hdus","ref":"/CFITSIO/stable/hdu/#CFITSIO.fits_get_num_hdus","content":" CFITSIO.fits_get_num_hdus  —  Function fits_get_num_hdus(f::FITSFile) Return the number of HDUs in the file. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_img(f, [1, 2, 3]);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\", \"units\")]);\n\njulia> close(f)\n\njulia> f = fits_open_file(fname, CFITSIO.READONLY);\n\njulia> fits_get_num_hdus(f)\n2\n\njulia> close(f) source"},{"id":1791,"pagetitle":"HDU","title":"CFITSIO.fits_get_hdu_num","ref":"/CFITSIO/stable/hdu/#CFITSIO.fits_get_hdu_num","content":" CFITSIO.fits_get_hdu_num  —  Function fits_get_hdu_num(f::FITSFile) Return the index of the current HDU in the FITS file. The primary HDU is numbered 1, the first extension HDU is numbered 2, etc. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\"), (\"col2\", \"1E\")])\n\njulia> fits_get_hdu_num(f)\n2\n\njulia> fits_movabs_hdu(f, 1) # move to the primary HDU\n:image_hdu\n\njulia> fits_get_hdu_num(f)\n1\n\njulia> fits_movabs_hdu(f, 2) # move to the binary table HDU\n:binary_table\n\njulia> fits_get_hdu_num(f)\n2\n\njulia> close(f) source"},{"id":1792,"pagetitle":"HDU","title":"CFITSIO.fits_get_hdu_type","ref":"/CFITSIO/stable/hdu/#CFITSIO.fits_get_hdu_type","content":" CFITSIO.fits_get_hdu_type  —  Function fits_get_hdu_type(f::FITSFile) Return the type of the current HDU as a symbol. Possible symbols are:  :image_hdu ,  :ascii_table , or  :binary_table . If the HDU is not one of these types, it returns  :unknown . Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_get_hdu_type(f)\n:image_hdu\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\"), (\"col2\", \"1E\")])\n\njulia> fits_get_hdu_type(f)\n:binary_table\n\njulia> close(f) source"},{"id":1793,"pagetitle":"HDU","title":"CFITSIO.fits_movabs_hdu","ref":"/CFITSIO/stable/hdu/#CFITSIO.fits_movabs_hdu","content":" CFITSIO.fits_movabs_hdu  —  Function fits_movabs_hdu(f::FITSFile, hduNum::Integer) Change the current HDU to the value specified by  hduNum , and return a symbol describing the type of the HDU. Possible symbols are:  image_hdu ,  ascii_table , or  binary_table . The value of  hduNum  must range between 1 and the value returned by  fits_get_num_hdus . Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\"), (\"col2\", \"1E\")])\n\njulia> fits_movabs_hdu(f, 2)\n:binary_table\n\njulia> fits_movabs_hdu(f, 1)\n:image_hdu\n\njulia> close(f) source"},{"id":1794,"pagetitle":"HDU","title":"CFITSIO.fits_movrel_hdu","ref":"/CFITSIO/stable/hdu/#CFITSIO.fits_movrel_hdu","content":" CFITSIO.fits_movrel_hdu  —  Function fits_movrel_hdu(f::FITSFile, hduNum::Integer) Change the current HDU by moving forward or backward by  hduNum  HDUs (positive means forward), and return the same as  fits_movabs_hdu . Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\"), (\"col2\", \"1E\")])\n\njulia> fits_movabs_hdu(f, 2)\n:binary_table\n\njulia> fits_movrel_hdu(f, -1) # move back to the image HDU\n:image_hdu\n\njulia> fits_movrel_hdu(f, 1) # move forward to the binary table HDU\n:binary_table\n\njulia> close(f) source"},{"id":1795,"pagetitle":"HDU","title":"CFITSIO.fits_movnam_hdu","ref":"/CFITSIO/stable/hdu/#CFITSIO.fits_movnam_hdu","content":" CFITSIO.fits_movnam_hdu  —  Function fits_movnam_hdu(f::FITSFile, extname::String, extver::Integer=0,\n                hdu_type_int::Integer=-1) Change the current HDU by moving to the (first) HDU which has the specified extension type and EXTNAME and EXTVER keyword values (or HDUNAME and HDUVER keywords). If  extver  is 0 (the default) then the EXTVER keyword is ignored and the first HDU with a matching EXTNAME (or HDUNAME) keyword will be found. If  hdu_type_int  is -1 (the default) only the extname and extver values will be used to locate the correct extension. If no matching HDU is found in the file, the current HDU will remain unchanged. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_write_key(f, \"EXTNAME\", \"MyImage\", \"Name of the Image\")\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\"), (\"col2\", \"1E\")], \"MyTable\")\n\njulia> fits_movnam_hdu(f, \"MyImage\")\n\njulia> fits_get_hdu_type(f), fits_get_hdu_num(f)\n(:image_hdu, 1)\n\njulia> fits_movnam_hdu(f, \"MyTable\")\n\njulia> fits_get_hdu_type(f), fits_get_hdu_num(f)\n(:binary_table, 2)\n\njulia> close(f) source"},{"id":1796,"pagetitle":"HDU","title":"CFITSIO.fits_copy_file","ref":"/CFITSIO/stable/hdu/#CFITSIO.fits_copy_file","content":" CFITSIO.fits_copy_file  —  Function fits_copy_file(fin::FITSFile, fout::FITSFile, previous::Bool, current::Bool, following::Bool) Copy all or a part of the HDUs from the input file  fin , and append them to the output file  fout . The flags  previous ,  current  and  following  specify which HDUs are to be copied. If  previous  is true, all the HDUs prior to the current input HDU are copied. If  current  is true, the current input HDU is copied. If  following  is true, all the HDUs following the current input HDU are copied. These flags may be combined, so if all are set to  true  then all the HDUs are copied from  fin  to  fout . On exit, the input is unchanged, and the last HDU in the output is set as the current HDU. Example julia> fname_in = joinpath(mktempdir(), \"test_in.fits\");\n\njulia> fname_out = joinpath(mktempdir(), \"test_out.fits\");\n\njulia> fin = fits_create_file(fname_in);\n\njulia> fits_create_empty_img(fin);\n\njulia> fits_write_key(fin, \"KEY1\", 1, \"First keyword\");\n\njulia> fits_create_binary_tbl(fin, 0, [(\"col1\", \"1J\"), (\"col2\", \"1E\")], \"MyTable\");\n\njulia> fout = fits_create_file(fname_out);\n\njulia> fits_copy_file(fin, fout, true, true, true);\n\njulia> fits_get_hdu_num(fout)\n2\n\njulia> fits_get_hdu_type(fout)\n:binary_table\n\njulia> fits_movabs_hdu(fout, 1) # move to the primary HDU\n:image_hdu\n\njulia> fits_read_key_str(fout, \"NAXIS\")\n(\"0\", \"number of data axes\")\n\njulia> fits_read_key_str(fout, \"KEY1\")\n(\"1\", \"First keyword\")\n\njulia> foreach(close, (fin, fout)); source"},{"id":1797,"pagetitle":"HDU","title":"CFITSIO.fits_copy_hdu","ref":"/CFITSIO/stable/hdu/#CFITSIO.fits_copy_hdu","content":" CFITSIO.fits_copy_hdu  —  Function fits_copy_hdu(fin::FITSFile, fout::FITSFile, morekeys::Integer = 0) Copy the current HDU from the input file  fin  and append it to the output file  fout . Space may be reserved for  morekeys  additional keywords in the output header. Example julia> fname_in = joinpath(mktempdir(), \"test_in.fits\");\n\njulia> fname_out = joinpath(mktempdir(), \"test_out.fits\");\n\njulia> fin = fits_create_file(fname_in);\n\njulia> fits_create_empty_img(fin)\n\njulia> fits_write_key(fin, \"KEY1\", 1, \"First keyword\")\n\njulia> fout = fits_create_file(fname_out);\n\njulia> fits_copy_hdu(fin, fout)\n\njulia> fits_get_hdu_num(fout)\n1\n\njulia> fits_get_hdu_type(fout)\n:image_hdu\n\njulia> fits_read_key_str(fout, \"NAXIS\")\n(\"0\", \"number of data axes\")\n\njulia> fits_read_key_str(fout, \"KEY1\")\n(\"1\", \"First keyword\")\n\njulia> foreach(close, (fin, fout)) source"},{"id":1798,"pagetitle":"HDU","title":"CFITSIO.fits_copy_data","ref":"/CFITSIO/stable/hdu/#CFITSIO.fits_copy_data","content":" CFITSIO.fits_copy_data  —  Function fits_copy_data(fin::FITSFile, fout::FITSFile) Copy the data (not the header) from the current HDU in  fin  to the current HDU in  fout . This will overwrite pre-existing data in the output HDU. Example julia> fname_in = joinpath(mktempdir(), \"test_in.fits\");\n\njulia> fname_out = joinpath(mktempdir(), \"test_out.fits\");\n\njulia> fin = fits_create_file(fname_in);\n\njulia> fits_create_img(fin, Int64, (2, 2))\n\njulia> fits_write_pix(fin, [1, 1], 4, [1, 2, 3, 4])\n\njulia> fits_write_key(fin, \"KEY1\", 1, \"First keyword\")\n\njulia> fout = fits_create_file(fname_out);\n\njulia> fits_create_img(fout, Int64, (2, 2));\n\njulia> fits_copy_data(fin, fout)\n\njulia> B = zeros(Int64, 2, 2);\n\njulia> fits_read_pix(fout, [1, 1], 4, B);\n\njulia> B\n2×2 Matrix{Int64}:\n 1  3\n 2  4\n\njulia> fits_read_key_str(fout, \"KEY1\") # the header isn't copied\nERROR: CFITSIO has encountered an error. Error code 202: keyword not found in header\n[...]\n\njulia> foreach(close, (fin, fout)) source"},{"id":1799,"pagetitle":"HDU","title":"CFITSIO.fits_delete_hdu","ref":"/CFITSIO/stable/hdu/#CFITSIO.fits_delete_hdu","content":" CFITSIO.fits_delete_hdu  —  Function fits_delete_hdu(f::FITSFile) Delete the HDU from the FITS file and shift the following HDUs forward. If  f  is the primary HDU in the file then it'll be replaced by a null primary HDU with no data and minimal header information. Return a symbol to indicate the type of the new current HDU. Possible symbols are:  :image_hdu ,  :ascii_table , or  :binary_table . The value of  hduNum  must range between 1 and the value returned by  fits_get_num_hdus . Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\"), (\"col2\", \"1E\")])\n\njulia> fits_get_hdu_num(f)\n2\n\njulia> fits_get_hdu_type(f)\n:binary_table\n\njulia> fits_delete_hdu(f) # delete the binary table HDU\n:image_hdu\n\njulia> fits_get_hdu_num(f)\n1\n\njulia> fits_get_hdu_type(f)\n:image_hdu\n\njulia> close(f) source"},{"id":1800,"pagetitle":"HDU","title":"CFITSIO.fits_write_chksum","ref":"/CFITSIO/stable/hdu/#CFITSIO.fits_write_chksum","content":" CFITSIO.fits_write_chksum  —  Function fits_write_chksum(f::FITSFile) Compute and write the  DATASUM  and  CHECKSUM  keyword values for the CHDU into the current header. If the keywords already exist, their values will be updated only if necessary (i.e., if the file has been modified since the original keyword values were computed). Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\", \"units\")]);\n\njulia> fits_write_col(f, 1, 1, 1, [1, 2, 3]);\n\njulia> fits_write_chksum(f); # write the checksum keywords\n\njulia> fits_read_key_str(f, \"DATASUM\", comment = nothing)\n(\"6\", nothing)\n\njulia> fits_read_key_str(f, \"CHECKSUM\", comment = nothing)\n(\"9TbBESbA9SbACSbA\", nothing)\n\njulia> close(f) source"},{"id":1801,"pagetitle":"HDU","title":"CFITSIO.fits_update_chksum","ref":"/CFITSIO/stable/hdu/#CFITSIO.fits_update_chksum","content":" CFITSIO.fits_update_chksum  —  Function fits_update_chksum(f::FITSFile) Update the  CHECKSUM  keyword value in the CHDU, assuming that the  DATASUM  keyword exists and already has the correct value. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\", \"units\")]);\n\njulia> fits_write_col(f, 1, 1, 1, [1, 2, 3]);\n\njulia> fits_write_chksum(f); # write the checksum keywords\n\njulia> fits_read_key_str(f, \"DATASUM\", comment = nothing)\n(\"6\", nothing)\n\njulia> fits_read_key_str(f, \"CHECKSUM\", comment = nothing)\n(\"5UdCATZB7TdBATZB\", nothing)\n\njulia> fits_write_key(f, \"TEST\", \"test\", \"test comment\"); # modify the header\n\njulia> fits_update_chksum(f); # update the CHECKSUM keyword\n\njulia> fits_read_key_str(f, \"CHECKSUM\", comment = nothing)\n(\"Y3amY0UjY0ZjY0Zj\", nothing)\n\njulia> close(f) source"},{"id":1802,"pagetitle":"HDU","title":"CFITSIO.fits_verify_chksum","ref":"/CFITSIO/stable/hdu/#CFITSIO.fits_verify_chksum","content":" CFITSIO.fits_verify_chksum  —  Function fits_verify_chksum(f::FITSFile) Verify if the checksum of the data and the HDU matches the stored values. Returns a tuple of  CFITSIO.ChecksumVerificationStatus  values, indicating the status of the data and HDU checksums. For either value, a status of  MISSING  indicates that the corresponding keyword is not present, while a status of  MISMATCH  indicates that the keyword is present but the value is incorrect. Finally, a value of  VERIFIED  indicates that the checksum was validated successfully. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\", \"units\")]);\n\njulia> fits_write_col(f, 1, 1, 1, [1, 2, 3]);\n\njulia> fits_verify_chksum(f) # no checksum keywords present\n(CFITSIO.MISSING, CFITSIO.MISSING)\n\njulia> fits_write_chksum(f); # write the checksum keywords\n\njulia> fits_verify_chksum(f)\n(CFITSIO.VERIFIED, CFITSIO.VERIFIED)\n\njulia> close(f) source"},{"id":1805,"pagetitle":"Header","title":"Header Keyword Routines","ref":"/CFITSIO/stable/header/#Header-Keyword-Routines","content":" Header Keyword Routines"},{"id":1806,"pagetitle":"Header","title":"CFITSIO.fits_copy_header","ref":"/CFITSIO/stable/header/#CFITSIO.fits_copy_header","content":" CFITSIO.fits_copy_header  —  Function fits_copy_header(fin::FITSFile, fout::FITSFile) Copy the header (not the data) associated with the current HDU from  fin  to  fout . If the current HDU in  fout  is not empty, it will be closed and a new HDU will be appended. An empty output HDU will be created with the header but no data. Example julia> fname_in = joinpath(mktempdir(), \"test_in.fits\");\n\njulia> fname_out = joinpath(mktempdir(), \"test_out.fits\");\n\njulia> fin = fits_create_file(fname_in);\n\njulia> fits_create_empty_img(fin)\n\njulia> fits_write_key(fin, \"KEY1\", 1, \"First keyword\")\n\njulia> fout = fits_create_file(fname_out);\n\njulia> fits_copy_header(fin, fout)\n\njulia> fits_read_key_str(fout, \"NAXIS\")\n(\"0\", \"number of data axes\")\n\njulia> fits_read_key_str(fout, \"KEY1\")\n(\"1\", \"First keyword\")\n\njulia> foreach(close, (fin, fout)) source"},{"id":1807,"pagetitle":"Header","title":"CFITSIO.fits_delete_key","ref":"/CFITSIO/stable/header/#CFITSIO.fits_delete_key","content":" CFITSIO.fits_delete_key  —  Function fits_delete_key(f::FITSFile, keyname::String) Delete the keyword named  keyname . Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_write_key(f, \"KEY1\", 1, \"First keyword\")\n\njulia> fits_read_key_str(f, \"KEY1\")\n(\"1\", \"First keyword\")\n\njulia> fits_delete_key(f, \"KEY1\") # delete the keyword\n\njulia> fits_read_key_str(f, \"KEY1\")\nERROR: CFITSIO has encountered an error. Error code 202: keyword not found in header\n[...]\n\njulia> close(f) source"},{"id":1808,"pagetitle":"Header","title":"CFITSIO.fits_delete_record","ref":"/CFITSIO/stable/header/#CFITSIO.fits_delete_record","content":" CFITSIO.fits_delete_record  —  Function fits_delete_record(f::FITSFile, keynum::Integer) Delete the keyword record at the specified index. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_write_key(f, \"KEY1\", 1, \"First keyword\")\n\njulia> fits_read_key_str(f, \"KEY1\")\n(\"1\", \"First keyword\")\n\njulia> fits_delete_record(f, 7) # delete the keyword\n\njulia> fits_read_key_str(f, \"KEY1\")\nERROR: CFITSIO has encountered an error. Error code 202: keyword not found in header\n[...]\n\njulia> close(f) source"},{"id":1809,"pagetitle":"Header","title":"CFITSIO.fits_hdr2str","ref":"/CFITSIO/stable/header/#CFITSIO.fits_hdr2str","content":" CFITSIO.fits_hdr2str  —  Function fits_hdr2str(f::FITSFile, nocomments::Bool=false) Return the header of the CHDU as a string. If  nocomments  is  true , comment cards are stripped from the output. source"},{"id":1810,"pagetitle":"Header","title":"CFITSIO.fits_get_hdrspace","ref":"/CFITSIO/stable/header/#CFITSIO.fits_get_hdrspace","content":" CFITSIO.fits_get_hdrspace  —  Function fits_get_hdrspace(f::FITSFile) -> (keysexist, morekeys) Return the number of existing keywords (not counting the END keyword) and the amount of space currently available for more keywords. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_clobber_file(fname);\n\njulia> fits_create_img(f, Int32, (2, 2));\n\njulia> nkeywords, _ = fits_get_hdrspace(f)\n(8, -1)\n\njulia> [fits_read_keyn(f, i) for i in 1:nkeywords]\n8-element Vector{Tuple{String, String, String}}:\n (\"SIMPLE\", \"T\", \"file does conform to FITS standard\")\n (\"BITPIX\", \"32\", \"number of bits per data pixel\")\n (\"NAXIS\", \"2\", \"number of data axes\")\n (\"NAXIS1\", \"2\", \"length of data axis 1\")\n (\"NAXIS2\", \"2\", \"length of data axis 2\")\n (\"EXTEND\", \"T\", \"FITS dataset may contain extensions\")\n (\"COMMENT\", \"\", \"  FITS (Flexible Image Transport System) format is defined in 'Astronomy\")\n (\"COMMENT\", \"\", \"  and Astrophysics', volume 376, page 359; bibcode: 2001A&A...376..359H\")\n\njulia> close(f) source"},{"id":1811,"pagetitle":"Header","title":"CFITSIO.fits_read_key_lng","ref":"/CFITSIO/stable/header/#CFITSIO.fits_read_key_lng","content":" CFITSIO.fits_read_key_lng  —  Function fits_read_key_lng(f::FITSFile, keyname::String) Read the value of a keyword as a  Clong , as well as the comment associated with the keyword. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_img(f, Int32, (100, 100));\n\njulia> fits_read_key_lng(f, \"NAXIS1\")\n(100, \"length of data axis 1\")\n\njulia> close(f) source"},{"id":1812,"pagetitle":"Header","title":"CFITSIO.fits_read_key_str","ref":"/CFITSIO/stable/header/#CFITSIO.fits_read_key_str","content":" CFITSIO.fits_read_key_str  —  Function fits_read_key_str(f::FITSFile, keyname::String) Read the value associated with the keyword as a  String , along with the comment. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_read_key_str(f, \"SIMPLE\")\n(\"T\", \"file does conform to FITS standard\")\n\njulia> close(f) source"},{"id":1813,"pagetitle":"Header","title":"CFITSIO.fits_read_key_unit","ref":"/CFITSIO/stable/header/#CFITSIO.fits_read_key_unit","content":" CFITSIO.fits_read_key_unit  —  Function fits_read_key_unit(f::FITSFile, keyname::String) Read the physical unit of the keyword  keyname  in the header. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_write_key(f, \"Velocity\", 2.0, \"Velocity of the object\")\n\njulia> fits_write_key_unit(f, \"Velocity\", \"m/s\")\n\njulia> fits_read_key_unit(f, \"Velocity\")\n\"m/s\"\n\njulia> fits_read_keyword(f, \"Velocity\")\n(\"2.\", \"[m/s] Velocity of the object\")\n\njulia> close(f) See also  fits_write_key_unit  to write a unit to a keyword. source"},{"id":1814,"pagetitle":"Header","title":"CFITSIO.fits_read_keyn","ref":"/CFITSIO/stable/header/#CFITSIO.fits_read_keyn","content":" CFITSIO.fits_read_keyn  —  Function fits_read_keyn(f::FITSFile, keynum::Int) -> (name, value, comment) Return the nth header record in the CHU. The first keyword in the header is at  keynum = 1 . Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_read_keyn(f, 1)\n(\"SIMPLE\", \"T\", \"file does conform to FITS standard\")\n\njulia> fits_read_keyn(f, 3)\n(\"NAXIS\", \"0\", \"number of data axes\")\n\njulia> close(f) source"},{"id":1815,"pagetitle":"Header","title":"CFITSIO.fits_read_keyword","ref":"/CFITSIO/stable/header/#CFITSIO.fits_read_keyword","content":" CFITSIO.fits_read_keyword  —  Function fits_read_keyword(f::FITSFile, keyname::String) -> (value, comment) Return the specified keyword value and comment (as a tuple of strings), throws and error if the keyword is not found. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_read_keyword(f, \"SIMPLE\")\n(\"T\", \"file does conform to FITS standard\")\n\njulia> close(f) source"},{"id":1816,"pagetitle":"Header","title":"CFITSIO.fits_read_record","ref":"/CFITSIO/stable/header/#CFITSIO.fits_read_record","content":" CFITSIO.fits_read_record  —  Function fits_read_record(f::FITSFile, keynum::Int)::String Return the  keynum -th header record in the CHU. The first keyword in the header is at  keynum = 1 . Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_read_record(f, 1)\n\"SIMPLE  =                    T / file does conform to FITS standard\"\n\njulia> fits_read_record(f, 3)\n\"NAXIS   =                    0 / number of data axes\"\n\njulia> close(f) source"},{"id":1817,"pagetitle":"Header","title":"CFITSIO.fits_update_key","ref":"/CFITSIO/stable/header/#CFITSIO.fits_update_key","content":" CFITSIO.fits_update_key  —  Function fits_update_key(f::FITSFile, key::String, value, comment::Union{String,Ptr{Nothing},Nothing} = nothing) Update the value of an existing keyword in the FITS header, or add a new keyword if it does not exist. This function is a convenience wrapper that calls the appropriate  ffuk*  function based on the type of  value . If  comment  is provided, it is added to the keyword comment field. If  value  is  Nothing , the keyword is set to a null value. If  value  is a string, it is checked to be ASCII compliant. If  value  is a floating-point number, it is written as a double-precision value. If  value  is a boolean, it is written as an integer (1 for true, 0 for false). Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_update_key(f, \"NEWKEY\", 2, \"This is a new keyword\")\n\njulia> fits_read_key_str(f, \"NEWKEY\")\n(\"2\", \"This is a new keyword\")\n\njulia> fits_update_key(f, \"NEWKEY\", 3.14, \"Updated value\")\n\njulia> fits_read_key_str(f, \"NEWKEY\")\n(\"3.14\", \"Updated value\")\n\njulia> fits_update_key(f, \"NEWKEY\", true, \"Boolean value\")\n\njulia> fits_read_key_str(f, \"NEWKEY\")\n(\"T\", \"Boolean value\")\n\njulia> fits_update_key(f, \"NEWKEY\", \"Value\", \"String value\")\n\njulia> fits_read_key_str(f, \"NEWKEY\")\n(\"Value\", \"String value\")\n\njulia> close(f) source"},{"id":1818,"pagetitle":"Header","title":"CFITSIO.fits_write_comment","ref":"/CFITSIO/stable/header/#CFITSIO.fits_write_comment","content":" CFITSIO.fits_write_comment  —  Function fits_write_comment(f::FITSFile, comment::String) Append to the keyword  COMMENT  in the FITS header. If the keyword does not exist, it is created. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_write_comment(f, \"This is a comment\")\n\njulia> fits_read_record(f, 7)\n\"COMMENT This is a comment\"\n\njulia> close(f) source"},{"id":1819,"pagetitle":"Header","title":"CFITSIO.fits_write_date","ref":"/CFITSIO/stable/header/#CFITSIO.fits_write_date","content":" CFITSIO.fits_write_date  —  Function fits_write_date(f::FITSFile) Write the current date and time into the FITS header. If a DATE keyword already exists, it is replaced by the new value. The date is written in the format  YYYY-MM-DDThh:mm:ss  (ISO 8601). Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_write_date(f)\n\njulia> fits_read_key_str(f, \"DATE\")\n(\"2025-05-28T10:41:08\", \"file creation date (YYYY-MM-DDThh:mm:ss UT)\")\n\njulia> close(f) source"},{"id":1820,"pagetitle":"Header","title":"CFITSIO.fits_write_history","ref":"/CFITSIO/stable/header/#CFITSIO.fits_write_history","content":" CFITSIO.fits_write_history  —  Function fits_write_history(f::FITSFile, history::String) Append to the keyword  HISTORY  in the FITS header. If the keyword does not exist, it is created. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_write_history(f, \"This is a history entry\")\n\njulia> fits_read_record(f, 7)\n\"HISTORY This is a history entry\"\n\njulia> close(f) source"},{"id":1821,"pagetitle":"Header","title":"CFITSIO.fits_write_key","ref":"/CFITSIO/stable/header/#CFITSIO.fits_write_key","content":" CFITSIO.fits_write_key  —  Function fits_write_key(f::FITSFile, keyname::String, value, comment::Union{String, Nothing} = nothing) Write a keyword of the appropriate data type into the CHU. If  comment  is  nothing , the keyword is written without a comment. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_write_key(f, \"NEWKEY\", 2, \"This is a new keyword\")\n\njulia> fits_read_key_str(f, \"NEWKEY\")\n(\"2\", \"This is a new keyword\")\n\njulia> close(f) source"},{"id":1822,"pagetitle":"Header","title":"CFITSIO.fits_write_key_unit","ref":"/CFITSIO/stable/header/#CFITSIO.fits_write_key_unit","content":" CFITSIO.fits_write_key_unit  —  Function fits_write_key_unit(f::FITSFile, keyname::String, unit::String) Write the physical units string into an existing keyword record. The keyword must already exist in the header. The unit string is enclosed in square brackets at the beginning of the keyword comment field. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_write_key(f, \"Velocity\", 2.0, \"Velocity of the object\")\n\njulia> fits_write_key_unit(f, \"Velocity\", \"m/s\")\n\njulia> fits_read_key_unit(f, \"Velocity\")\n\"m/s\"\n\njulia> fits_read_keyword(f, \"Velocity\")\n(\"2.\", \"[m/s] Velocity of the object\")\n\njulia> close(f) source"},{"id":1823,"pagetitle":"Header","title":"CFITSIO.fits_write_record","ref":"/CFITSIO/stable/header/#CFITSIO.fits_write_record","content":" CFITSIO.fits_write_record  —  Function fits_write_record(f::FITSFile, card::String) Write a user specified keyword record into the CHU. This is a low–level routine which can be used to write any arbitrary record into the header. It is not recommended to use this function unless you know what you are doing. It is typically used to write hierarchical keywords in the ESO convention, which allows keyword names longer than 8 characters. It is also used to write comments or history entries directly into the header. If the keyword already exists, it is replaced by the new value. If the keyword does not exist, it is added to the header. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_write_record(f, \"HIERARCH ESO OBS ID = '12345'\")\n\njulia> fits_read_record(f, 7)\n\"HIERARCH ESO OBS ID = '12345'\"\n\njulia> close(f) source"},{"id":1826,"pagetitle":"Image","title":"Image HDU Routines","ref":"/CFITSIO/stable/image/#Image-HDU-Routines","content":" Image HDU Routines"},{"id":1827,"pagetitle":"Image","title":"CFITSIO.fits_get_img_dim","ref":"/CFITSIO/stable/image/#CFITSIO.fits_get_img_dim","content":" CFITSIO.fits_get_img_dim  —  Function fits_get_img_dim(f::FITSFile) Return the number of dimensions in the current image HDU. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_img(f, Int64, (2,2))\n\njulia> fits_get_img_dim(f)\n2\n\njulia> close(f) See also  fits_get_img_type ,  fits_get_img_size  and  fits_get_img_param . source"},{"id":1828,"pagetitle":"Image","title":"CFITSIO.fits_get_img_size","ref":"/CFITSIO/stable/image/#CFITSIO.fits_get_img_size","content":" CFITSIO.fits_get_img_size  —  Function fits_get_img_size(f::FITSFile) Return the size along each dimension in the current Image HDU. See also  fits_get_img_type ,  fits_get_img_dim  and  fits_get_img_param . Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_img(f, Int64, (2,2))\n\njulia> fits_get_img_size(f)\n2-element Vector{Int64}:\n 2\n 2\n\njulia> fits_get_img_size(f, Val(2))\n(2, 2)\n\njulia> close(f) source"},{"id":1829,"pagetitle":"Image","title":"CFITSIO.fits_get_img_type","ref":"/CFITSIO/stable/image/#CFITSIO.fits_get_img_type","content":" CFITSIO.fits_get_img_type  —  Function fits_get_img_type(f::FITSFile) Return the datatype (bitpix) of the current image HDU. This may be converted to a Julia type by using the function  type_from_bitpix . Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_img(f, Int64, (2,2))\n\njulia> fits_get_img_type(f)\n64\n\njulia> type_from_bitpix(fits_get_img_type(f))\nInt64\n\njulia> close(f) source"},{"id":1830,"pagetitle":"Image","title":"CFITSIO.fits_get_img_param","ref":"/CFITSIO/stable/image/#CFITSIO.fits_get_img_param","content":" CFITSIO.fits_get_img_param  —  Function fits_get_img_param(f::FITSFile) Return the bitpix, number of dimensions and the size along each dimension of the current image HDU. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_img(f, Int64, (2,2))\n\njulia> fits_get_img_param(f)\n(64, 2, [2, 2])\n\njulia> close(f) See also  fits_get_img_type ,  fits_get_img_dim  and  fits_get_img_size . source"},{"id":1831,"pagetitle":"Image","title":"CFITSIO.fits_create_img","ref":"/CFITSIO/stable/image/#CFITSIO.fits_create_img","content":" CFITSIO.fits_create_img  —  Function fits_create_img(f::FITSFile, T::Type, naxes::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}) Create a new primary array or IMAGE extension with the specified data type  T  and size  naxes . Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_img(f, Int64, [2, 2])\n\njulia> fits_get_img_dim(f)\n2\n\njulia> fits_get_img_size(f)\n2-element Vector{Int64}:\n 2\n 2\n\njulia> fits_get_img_type(f)\n64\n\njulia> type_from_bitpix(fits_get_img_type(f))\nInt64\n\njulia> fits_create_img(f, Int64, (1, 3, 2))\n\njulia> fits_get_img_dim(f)\n3\n\njulia> fits_get_img_size(f)\n3-element Vector{Int64}:\n 1\n 3\n 2\n\njulia> close(f) source fits_create_img(f::FITSFile, A::AbstractArray) Create a new primary array or IMAGE extension with the element type and size of  A , that is capable of storing the entire array  A . Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> a = rand(2, 2);\n\njulia> fits_create_img(f, a)\n\njulia> fits_get_img_dim(f)\n2\n\njulia> fits_get_img_size(f)\n2-element Vector{Int64}:\n 2\n 2\n\njulia> type_from_bitpix(fits_get_img_type(f))\nFloat64\n\njulia> close(f) source"},{"id":1832,"pagetitle":"Image","title":"CFITSIO.fits_create_empty_img","ref":"/CFITSIO/stable/image/#CFITSIO.fits_create_empty_img","content":" CFITSIO.fits_create_empty_img  —  Function fits_create_empty_img(f::FITSFile) Create an empty image HDU with no dimensions, and of type  Int . See  fits_create_img . Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_empty_img(f)\n\njulia> fits_get_img_dim(f)\n0\n\njulia> fits_get_img_size(f)\nInt64[]\n\njulia> close(f) source"},{"id":1833,"pagetitle":"Image","title":"CFITSIO.fits_insert_img","ref":"/CFITSIO/stable/image/#CFITSIO.fits_insert_img","content":" CFITSIO.fits_insert_img  —  Function fits_insert_img(f::FITSFile, T::Type,\n                naxes::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}; prepend_primary::Bool = false) Insert a new image extension immediately following the current HDU (CHDU), or insert a new primary array at the beginning of the file. A new primary array may be inserted at the beginning of the FITS file by calling  fits_insert_img  with  prepend_primary  set to  true . In this case, the existing primary HDU is converted to an image extension, and the new primary array will become the CHDU. The inserted array has an eltype  T  and size  naxes . fits_insert_img(f::FITSFile, a::AbstractArray{<:Real}; prepend_primary::Bool = false) Insert a new image HDU with an element type of  eltype(a)  and a size of  size(a)  that is capable of storing the array  a . The flag  prepend_primary  may be specified to insert a new primary array at the beginning of the FITS file. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_insert_img(f, Int64, [2, 2])\n\njulia> fits_get_img_dim(f)\n2\n\njulia> fits_get_img_size(f)\n2-element Vector{Int64}:\n 2\n 2\n\njulia> type_from_bitpix(fits_get_img_type(f))\nInt64\n\njulia> fits_insert_img(f, Float64, (3, 4, 5), prepend_primary=true)\n\njulia> fits_get_img_dim(f)\n3\n\njulia> fits_get_img_size(f)\n3-element Vector{Int64}:\n 3\n 4\n 5\n\njulia> type_from_bitpix(fits_get_img_type(f))\nFloat64\n\njulia> fits_get_hdu_num(f)\n1\n\njulia> a = rand(2, 2);\n\njulia> fits_insert_img(f, a)\n\njulia> fits_get_img_dim(f)\n2\n\njulia> fits_get_img_size(f)\n2-element Vector{Int64}:\n 2\n 2\n\njulia> type_from_bitpix(fits_get_img_type(f))\nFloat64\n\njulia> fits_get_hdu_num(f)\n2\n\njulia> fits_get_num_hdus(f)\n3\n\njulia> close(f) source"},{"id":1834,"pagetitle":"Image","title":"CFITSIO.fits_write_pix","ref":"/CFITSIO/stable/image/#CFITSIO.fits_write_pix","content":" CFITSIO.fits_write_pix  —  Function fits_write_pix(f::FITSFile,\n               [fpixel::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}},\n               nelements::Integer,] data::StridedArray) Write  nelements  pixels from  data  into the FITS file starting from the pixel  fpixel . The arguments  fpixel  and  nelements  are optional, and are necessary if only a section of the array is to be written out. If these are not provided, the entire  data  array is written to the FITS file. Note The HDU must have been created previously, and its length must match the number of elements being written. Note data  needs to be stored contiguously in memory. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_img(f, Int64, (2,))\n\njulia> A = [1 3; 2 4]\n2×2 Matrix{Int64}:\n 1  3\n 2  4\n\njulia> fits_write_pix(f, first.(axes(A)), 2, A) # write the first two elements from A\n\njulia> B = similar(A, 2);\n\njulia> fits_read_pix(f, B);\n\njulia> B\n2-element Vector{Int64}:\n 1\n 2\n\njulia> fits_create_img(f, Float64, size(A))\n\njulia> fits_write_pix(f, A) # write the entire array, implicitly casting to Float64\n\njulia> Bf = similar(A, Float64);\n\njulia> fits_read_pix(f, Bf);\n\njulia> Bf\n2×2 Matrix{Float64}:\n 1.0  3.0\n 2.0  4.0\n\njulia> close(f) See also:  fits_write_pixnull ,  fits_write_subset source"},{"id":1835,"pagetitle":"Image","title":"CFITSIO.fits_write_pixnull","ref":"/CFITSIO/stable/image/#CFITSIO.fits_write_pixnull","content":" CFITSIO.fits_write_pixnull  —  Function fits_write_pixnull(f::FITSFile,\n                   [fpixel::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}},\n                   nelements::Integer,] data::StridedArray, nulval) Write  nelements  pixels from  data  into the FITS file starting from the pixel  fpixel . The argument  nulval  specifies the values that are to be considered as \"null values\", and replaced by appropriate numbers corresponding to the element type of  data . For integer FITS arrays, the FITS null value is defined by the  BLANK  keyword (an error is returned if the  BLANK  keyword doesn’t exist). For floating point FITS arrays,  NaN  of the appropriate type will be written into the FITS file. The arguments  fpixel  and  nelements  are optional, and are necessary if only a section of the array is to be written out. If these are not provided, the entire  data  array is written to the FITS file. Note The HDU must have been created previously, and its size must match the number of elements being written. Note data  needs to be stored contiguously in memory. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_img(f, Int64, (2, 2));\n\njulia> fits_write_key(f, \"BLANK\", 0, \"Null value for integer arrays\");\n\njulia> fits_write_pixnull(f, [1, 1], 4, [1 3; 2 4], 3);\n\njulia> B = zeros(Int64, 2, 2);\n\njulia> fits_read_pix(f, B);\n\njulia> B\n2×2 Matrix{Int64}:\n 1  0\n 2  4\n\njulia> fits_create_img(f, Float64, (2, 2));\n\njulia> fits_write_pixnull(f, [1.0 3.0; 2.0 4.0], 1.0);\n\njulia> Bf = zeros(Float64, 2, 2);\n\njulia> fits_read_pix(f, Bf);\n\njulia> Bf\n2×2 Matrix{Float64}:\n NaN    3.0\n   2.0  4.0\n\njulia> close(f); See also:  fits_write_pix ,  fits_write_subset . source"},{"id":1836,"pagetitle":"Image","title":"CFITSIO.fits_write_subset","ref":"/CFITSIO/stable/image/#CFITSIO.fits_write_subset","content":" CFITSIO.fits_write_subset  —  Function fits_write_subset(f::FITSFile,\n                  fpixel::V, lpixel::V,\n                  data::StridedArray) where {V<:Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}} Write a rectangular section of the FITS image. The number of pixels to be written will be computed from the first and last pixels (specified as the  fpixel  and  lpixel  arguments respectively). Note The HDU must have been created previously, and its size must match the number of elements being written. Note The section to be written out must be contiguous in memory, so all the dimensions aside from the last one must span the entire axis range. The arguments  fpixel  and  lpixel  must account for this. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_img(f, Int64, (3, 2))\n\njulia> A = reshape([1:9;], 3, 3)\n3×3 Matrix{Int64}:\n 1  4  7\n 2  5  8\n 3  6  9\n\njulia> fits_write_subset(f, [1, 1], [3, 2], A)\n\njulia> B = zeros(Int64, 3, 2);\n\njulia> fits_read_pix(f, B);\n\njulia> B\n3×2 Matrix{Int64}:\n 1  4\n 2  5\n 3  6\n\njulia> close(f) See also:  fits_write_pix ,  fits_write_pixnull . source"},{"id":1837,"pagetitle":"Image","title":"CFITSIO.fits_read_pix","ref":"/CFITSIO/stable/image/#CFITSIO.fits_read_pix","content":" CFITSIO.fits_read_pix  —  Function fits_read_pix(f::FITSFile,\n              fpixel::NTuple{Vector{<:Integer}, Tuple{Vararg{Integer}}},\n              nelements::Integer, [nulval,] data::StridedArray) Read  nelements  pixels from the FITS file into  data  starting from the pixel  fpixel . If the optional argument  nulval  is specified and is non-zero, any null value present in the array will be replaced by it. Note data  needs to be stored contiguously in memory. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_img(f, Int64, (2, 2))\n\njulia> fits_write_pix(f, [1 3; 2 4])\n\njulia> B = zeros(Int64, 2, 2);\n\njulia> fits_read_pix(f, [1, 1], 4, B);\n\njulia> B\n2×2 Matrix{Int64}:\n 1  3\n 2  4\n\njulia> fits_create_img(f, Float64, (2, 2))\n\njulia> fits_write_pix(f, [1.0 3.0; NaN 4.0])\n\njulia> Bf = zeros(Float64, 2, 2);\n\njulia> fits_read_pix(f, [1, 1], 4, 2.0, Bf); # replace NaN with 2.0\n\njulia> Bf\n2×2 Matrix{Float64}:\n 1.0  3.0\n 2.0  4.0\n\njulia> close(f) See also:  fits_read_pixnull ,  fits_read_subset source fits_read_pix(f::FITSFile, data::StridedArray, [nulval]) Read  length(data)  pixels from the FITS file into  data  starting from the first pixel. The optional argument  nulval , if specified and non-zero, is used to replace any null value present in the array. Note data  needs to be stored contiguously in memory. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_img(f, Int64, (2, 2))\n\njulia> A = [1 3; 2 4]\n2×2 Matrix{Int64}:\n 1  3\n 2  4\n\njulia> fits_write_pix(f, A)\n\njulia> B = similar(A);\n\njulia> fits_read_pix(f, B);\n\njulia> B\n2×2 Matrix{Int64}:\n 1  3\n 2  4\n\njulia> close(f) See also:  fits_read_pixnull source"},{"id":1838,"pagetitle":"Image","title":"CFITSIO.fits_read_pixnull","ref":"/CFITSIO/stable/image/#CFITSIO.fits_read_pixnull","content":" CFITSIO.fits_read_pixnull  —  Function fits_read_pixnull(f::FITSFile,\n                  fpixel::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}},\n                  nelements::Integer, data::StridedArray, nullarray::Array{UInt8}) Read  nelements  pixels from the FITS file into  data  starting from the pixel  fpixel . At output, the indices of  nullarray  where  data  has a corresponding null value are set to  1 . Note data  needs to be stored contiguously in memory. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> A = Float64[NaN 2; 3 4]\n2×2 Matrix{Float64}:\n NaN    2.0\n   3.0  4.0\n\njulia> fits_create_img(f, A)\n\njulia> fits_write_pix(f, A)\n\njulia> B = similar(A);\n\njulia> nullarray = zeros(UInt8, size(A));\n\njulia> fits_read_pixnull(f, first.(axes(B)), length(B), B, nullarray);\n\njulia> nullarray\n2×2 Matrix{UInt8}:\n 0x01  0x00\n 0x00  0x00\n\njulia> B[2:4] == A[2:4]\ntrue\n\njulia> close(f) See also:  fits_read_pix source fits_read_pixnull(f::FITSFile, data::StridedArray, nullarray::Array{UInt8}) Read  length(data)  pixels from the FITS file into  data  starting from the first pixel. At output, the indices of  nullarray  where  data  has a corresponding null value are set to  1 . Note data  needs to be stored contiguously in memory. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> A = Float64[NaN 2; 3 4]\n2×2 Matrix{Float64}:\n NaN    2.0\n   3.0  4.0\n\njulia> fits_create_img(f, A)\n\njulia> fits_write_pix(f, A)\n\njulia> B = similar(A);\n\njulia> nullarray = zeros(UInt8, size(A));\n\njulia> fits_read_pixnull(f, B, nullarray);\n\njulia> nullarray\n2×2 Matrix{UInt8}:\n 0x01  0x00\n 0x00  0x00\n\njulia> B[2:4] == A[2:4]\ntrue\n\njulia> close(f) See also:  fits_read_pix source"},{"id":1839,"pagetitle":"Image","title":"CFITSIO.fits_read_subset","ref":"/CFITSIO/stable/image/#CFITSIO.fits_read_subset","content":" CFITSIO.fits_read_subset  —  Function fits_read_subset(f::FITSFile,\n                 fpixel::V, lpixel::V, inc::V,\n                 [nulval],\n                 data::StridedArray) where {V<:Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}} Read a rectangular section of the FITS image. The number of pixels to be read will be computed from the first and last pixels (specified as the  fpixel  and  lpixel  arguments respectively). The argument  inc  specifies the step-size in pixels along each dimension. If the optional argument  nulval  is specified and is non-zero, null values in  data  will be replaced by it. Note data  needs to be stored contiguously in memory, and will be populated contiguously with the pixels that are read in. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> A = [1 3; 2 4]\n2×2 Matrix{Int64}:\n 1  3\n 2  4\n\njulia> fits_create_img(f, A)\n\njulia> fits_write_pix(f, A)\n\njulia> Bf = similar(A, 2);\n\njulia> fits_read_subset(f, [1,1], [2,1], [1,1], Bf);\n\njulia> Bf\n2-element Vector{Int64}:\n 1\n 2\n\njulia> close(f) See also:  fits_read_pix source"},{"id":1840,"pagetitle":"Image","title":"CFITSIO.fits_read_imghdr","ref":"/CFITSIO/stable/image/#CFITSIO.fits_read_imghdr","content":" CFITSIO.fits_read_imghdr  —  Function fits_read_imghdr(f::FITSFile, maxdim::Integer = 99) Read the header of an image HDU, where  maxdim  represents the maximum number of dimensions to read. By default,  maxdim == 99  will read the size along every dimension of the image. The function returns the values of  SIMPLE::Bool ,  BITPIX::Int ,  NAXIS::Int ,  NAXES::Vector{Int} ,  PCOUNT::Int ,  GCOUNT::Int , and  EXTEND::Bool . The length of  NAXES  is set equal to  min(NAXIS, maxdim) . The  BITPIX  value indicates the data type of the image, and it may be converted to a Julia type using the  type_from_bitpix  function. Note PCOUNT  is typically  0  for image HDUs, and  GCOUNT  is typically  1  for modern files. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_img(f, Int32, (100, 200))\n\njulia> fits_read_imghdr(f)\n(true, 32, 2, [100, 200], 0, 1, true)\n\njulia> close(f) source"},{"id":1841,"pagetitle":"Image","title":"CFITSIO.fits_copy_image_section","ref":"/CFITSIO/stable/image/#CFITSIO.fits_copy_image_section","content":" CFITSIO.fits_copy_image_section  —  Function fits_copy_image_section(fin::FITSFile, fout::FITSFile, section::String) Copy a rectangular section of an image from  fin  and write it to a new FITS primary image or image extension in  fout . The section specifier is described on the  CFITSIO website . Example julia> fin_name = joinpath(mktempdir(), \"test_in.fits\");\n\njulia> fout_name = joinpath(mktempdir(), \"test_out.fits\");\n\njulia> fin = fits_create_file(fin_name);\n\njulia> fout = fits_create_file(fout_name);\n\njulia> A = reshape([1:16;], 4, 4)\n4×4 Matrix{Int64}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> fits_create_img(fin, A)\n\njulia> fits_write_pix(fin, A)\n\njulia> fits_copy_image_section(fin, fout, \"1:2,1:3\");\n\njulia> B = zeros(Int64, 2, 3);\n\njulia> fits_read_pix(fout, B);\n\njulia> B\n2×3 Matrix{Int64}:\n 1  5   9\n 2  6  10\n\njulia> foreach(close, (fin, fout)); source"},{"id":1842,"pagetitle":"Image","title":"CFITSIO.fits_write_null_img","ref":"/CFITSIO/stable/image/#CFITSIO.fits_write_null_img","content":" CFITSIO.fits_write_null_img  —  Function fits_write_null_img(f::FITSFile, firstelem::Integer, nelements::Integer) Set a stretch of elements to the appropriate null value, starting from the pixel number  firstelem  and extending over  nelements  pixels. For  Integer  arrays, the  BLANK  keyword sets the null value, while for  Float64  arrays, the  NAN  value is used. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> A = Float64[1 2; 3 4]\n2×2 Matrix{Float64}:\n 1.0  2.0\n 3.0  4.0\n\njulia> fits_create_img(f, A)\n\njulia> fits_write_pix(f, A)\n\njulia> fits_write_null_img(f, 1, 2)\n\njulia> B = zeros(Float64, 2, 2);\n\njulia> fits_read_pix(f, B);\n\njulia> B\n2×2 Matrix{Float64}:\n NaN  2.0\n NaN  4.0\n\njulia> fits_write_pix(f, A) # reset the image\n\njulia> fits_write_null_img(f, 3, 2) # set the last two pixels to null\n\njulia> fits_read_pix(f, B);\n\njulia> B\n2×2 Matrix{Float64}:\n 1.0  NaN\n 3.0  NaN\n\njulia> close(f) source"},{"id":1843,"pagetitle":"Image","title":"CFITSIO.fits_resize_img","ref":"/CFITSIO/stable/image/#CFITSIO.fits_resize_img","content":" CFITSIO.fits_resize_img  —  Function fits_resize_img(f::FITSFile, T::Type, naxis::Integer,\n                sz::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}) Modify the size, dimensions and optionally the element type of the image in  f . The new image will have an element type  T , be a  naxis -dimensional image with size  sz . If the new image is larger than the existing one, it will be zero-padded at the end. If the new image is smaller, existing image data will be truncated. Note This method reinterprets the data instead of coercing the elements. Example julia> f = fits_clobber_file(tempname());\n\njulia> a = [1 2; 3 4];\n\njulia> fits_create_img(f, a);\n\njulia> fits_write_pix(f, a);\n\njulia> fits_get_img_size(f)\n2-element Vector{Int64}:\n 2\n 2\n\njulia> fits_resize_img(f, [3,3]);\n\njulia> fits_get_img_size(f)\n2-element Vector{Int64}:\n 3\n 3\n\njulia> b = similar(a, (3,3));\n\njulia> fits_read_pix(f, b); b\n3×3 Matrix{Int64}:\n 1  4  0\n 3  0  0\n 2  0  0\n\njulia> fits_resize_img(f, [4]);\n\njulia> b = similar(a, (4,));\n\njulia> fits_read_pix(f, b); b\n4-element Vector{Int64}:\n 1\n 3\n 2\n 4 source fits_resize_img(f::FITSFile, sz::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}) Resize the image to the new size  sz . The element type is preserved, and the number of dimensions is set equal to  length(sz) . source fits_resize_img(f::FITSFile, T::Type) Change the element type of the image to  T , leaving the size unchanged. source"},{"id":1844,"pagetitle":"Image","title":"CFITSIO.fits_get_img_equivtype","ref":"/CFITSIO/stable/image/#CFITSIO.fits_get_img_equivtype","content":" CFITSIO.fits_get_img_equivtype  —  Function fits_get_img_equivtype(f::FITSFile) Return the equivalent datatype (bitpix) of the current image HDU. This is the same as  fits_get_img_type  except that it returns the bitpix value for the equivalent type, which is the type that would be used if the image were to be read as an array. The equivalent type is determined by the  BSCALE  and  BZERO  keywords in the header. If the image is not scaled, the equivalent type is the same as the type returned by  fits_get_img_type . Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_img(f, Int16, (2,2))\n\njulia> fits_write_key(f, \"BSCALE\", 0.1, \"Scale factor for the image\")\n\njulia> fits_write_key(f, \"BZERO\", 0.0, \"Zero point for the image\")\n\njulia> fits_get_img_equivtype(f)\n-32\n\njulia> type_from_bitpix(fits_get_img_equivtype(f))\nFloat32\n\njulia> fits_get_img_type(f)\n16\n\njulia> type_from_bitpix(fits_get_img_type(f))\nInt16\n\njulia> close(f) source"},{"id":1847,"pagetitle":"Miscellaneous","title":"Miscellaneous","ref":"/CFITSIO/stable/misc/#Miscellaneous","content":" Miscellaneous"},{"id":1848,"pagetitle":"Miscellaneous","title":"CFITSIO.libcfitsio_version","ref":"/CFITSIO/stable/misc/#CFITSIO.libcfitsio_version","content":" CFITSIO.libcfitsio_version  —  Function libcfitsio_version()::VersionNumber Return the version of the underlying CFITSIO library Example julia> libcfitsio_version()\nv\"4.6.0\" source"},{"id":1849,"pagetitle":"Miscellaneous","title":"CFITSIO.fits_get_version","ref":"/CFITSIO/stable/misc/#CFITSIO.fits_get_version","content":" CFITSIO.fits_get_version  —  Function fits_get_version()::Cfloat Return the version of the CFITSIO library as a floating point number. Example julia> fits_get_version()\n4.0601997f0 See also  libcfitsio_version , which returns a  VersionNumber . source"},{"id":1852,"pagetitle":"Table","title":"Table Routines","ref":"/CFITSIO/stable/table/#Table-Routines","content":" Table Routines There are two functions to create a new HDU table extension:  fits_create_ascii_table  and  fits_create_binary_table . In general, one should pick the second as binary tables require less space on the disk and are more efficient to read and write. (Moreover, a few datatypes are not supported in ASCII tables). In order to create a table, the programmer must specify the characteristics of each column by passing an array of tuples. Here is an example: f = fits_create_file(\"!new.fits\")\ncoldefs = [(\"SPEED\", \"1D\", \"m/s\"),\n           (\"MASS\", \"1E\", \"kg\"),\n           (\"PARTICLE\", \"20A\", \"Name\")]\nfits_create_binary_tbl(f, 10, coldefs, \"PARTICLE\") This example creates a table with room for 10 entries, each of them describing the characteristics of a particle: its speed, its mass, and its name (codified as a 20-character string). See the documentation of  fits_create_ascii_tbl  for more details."},{"id":1853,"pagetitle":"Table","title":"CFITSIO.fits_create_ascii_tbl","ref":"/CFITSIO/stable/table/#CFITSIO.fits_create_ascii_tbl","content":" CFITSIO.fits_create_ascii_tbl  —  Function fits_create_ascii_tbl(f::FITSFile, numrows::Integer,\n                      coldefs::Union{Array{NTuple{3,String}}, Array{NTuple{2,String}}},\n                      extname::Union{String, Nothing} = nothing) Append a new HDU containing an ASCII table. The table will have  numrows  rows (this parameter can be set to zero), each initialized with the default value. In order to create a table, the programmer must specify the characteristics of each column. The columns are specified by the  coldefs  variable, which is an array of tuples. Each tuple must have two or three string fields: The name of the column. The data type and the repetition count. It must be a string made by a number (the repetition count) followed by a letter specifying the type (in the example above,  D  stands for  Float64 ,  E  stands for  Float32 ,  A  stands for  Char ). Refer to the CFITSIO documentation for more information about the syntax of this parameter. The unit of this field. This is used to set the corresponding  TUNITn  keywords. If  coldefs  is a two-tuple, the unit keywords are left unset. If the third field of a tuple is an empty string, the corresponding unit keyword is also left unset. The value of  extname  sets the \"extended name\" of the table, i.e., a string that in some situations can be used to refer to the HDU itself. This may be omitted by setting  extname  to  nothing  (which is the default behavior). Note that, unlike for binary tables, CFITSIO puts some limitations to the types that can be used in an ASCII table column. Refer to the CFITSIO manual for further information. See also  fits_create_binary_tbl  for a similar function which creates binary tables. In general, one should pick this function for creating tables in a new HDU, as binary tables require less space on the disk and are more efficient to read and write. (Moreover, a few datatypes are not supported in ASCII tables). Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> cols = [\n                (\"ID\", \"I6\", \"\"),\n                (\"VALUE\", \"F10.2\", \"meters\"),\n                (\"NAME\", \"A10\", \"\")\n            ];\n\njulia> fits_create_ascii_tbl(f, 0, cols);\n\njulia> fits_write_col(f, 1, 1, 1, Int32[1, 2, 3, 4, 5])\n\njulia> fits_write_col(f, 2, 1, 1, Float64[1.1, 2.2, 3.3, 4.4, 5.5])\n\njulia> fits_write_col(f, 3, 1, 1, [\"alpha\", \"beta\", \"gamma\", \"delta\", \"epsilon\"])\n\njulia> close(f)\n\njulia> f = fits_open_file(fname, CFITSIO.READONLY);\n\njulia> fits_get_num_hdus(f)\n2\n\njulia> fits_movabs_hdu(f, 2)\n:ascii_table\n\njulia> nrows = fits_get_num_rows(f)\n5\n\njulia> fits_get_num_cols(f)\n3\n\njulia> fits_read_col(f, 1, 1, 1, Vector{Int32}(undef, nrows))\n5-element Vector{Int32}:\n 1\n 2\n 3\n 4\n 5\n\njulia> close(f) source"},{"id":1854,"pagetitle":"Table","title":"CFITSIO.fits_create_binary_tbl","ref":"/CFITSIO/stable/table/#CFITSIO.fits_create_binary_tbl","content":" CFITSIO.fits_create_binary_tbl  —  Function fits_create_binary_tbl(f::FITSFile, numrows::Integer,\n                       coldefs::Union{Array{NTuple{3,String}}, Array{NTuple{2,String}}},\n                       extname::Union{String, Nothing} = nothing) Append a new HDU containing a binary table. The meaning of the parameters is the same as in a call to  fits_create_ascii_tbl . In general, one should pick this function for creating tables in a new HDU, as binary tables require less space on the disk and are more efficient to read and write. (Moreover, a few datatypes are not supported in ASCII tables). Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> coldefs = [\n           (\"col1\", \"1J\", \"units\"),\n           (\"col2\", \"1E\", \"\"),\n           (\"col3\", \"1A\", \"m/s\"),\n       ];\n\njulia> fits_create_binary_tbl(f, 0, coldefs);\n\njulia> fits_write_col(f, 1, 1, 1, [1, 2, 3]);\n\njulia> fits_write_col(f, 2, 1, 1, [1.0, 2.0, 3.0]);\n\njulia> fits_write_col(f, 3, 1, 1, [\"a\", \"b\", \"c\"]);\n\njulia> close(f)\n\njulia> f = fits_open_file(fname, CFITSIO.READONLY);\n\njulia> fits_get_num_hdus(f)\n2\n\njulia> fits_movabs_hdu(f, 2)\n:binary_table\n\njulia> fits_get_num_rows(f)\n3\n\njulia> fits_get_num_cols(f)\n3\n\njulia> fits_read_col(f, 1, 1, 1, zeros(Int32, 3))\n3-element Vector{Int32}:\n 1\n 2\n 3\n\njulia> close(f) source"},{"id":1855,"pagetitle":"Table","title":"CFITSIO.fits_create_tbl","ref":"/CFITSIO/stable/table/#CFITSIO.fits_create_tbl","content":" CFITSIO.fits_create_tbl  —  Function fits_create_tbl(f::FITSFile, tbltype, numrows::Integer,\n    ttype::Vector{String}, tform::Vector{String},\n    tunit::Union{Vector{String}, Nothing} = nothing,\n    extname::Union{String, Nothing} = nothing) Create a new table HDU in the FITS file  f  with the specified parameters. The  tbltype  sets the type of the table, which can be either  CFITSIO.ASCII_TBL  or  CFITSIO.BINARY_TBL . The  numrows  parameter reserves space for a specified number of rows in the table, and it can be set to zero if the table is populated later. The  ttype  and  tform  parameters specify the names and types of the columns in the table, respectively. The  tunit  parameter is optional and can be used to specify the units of the columns. If  tunit  is not provided, the units will not be set in the table. The  extname  parameter is also optional and can be used to set the extended name of the table. If  extname  is not provided, the table will not have an extended name. The  ttype ,  tform , and  tunit  parameters must be vectors of the same length, where each element corresponds to a column in the table. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> ttype = [\"col1\", \"col2\", \"col3\"];\n\njulia> tform = [\"1J\", \"1E\", \"1A\"];\n\njulia> tunit = [\"units1\", \"units2\", \"m/s\"];\n\njulia> fits_create_tbl(f, CFITSIO.BINARY_TBL, 0, ttype, tform, tunit);\n\njulia> fits_write_col(f, 1, 1, 1, [1, 2, 3]);\n\njulia> fits_write_col(f, 2, 1, 1, [1.0, 2.0, 3.0]);\n\njulia> fits_write_col(f, 3, 1, 1, [\"a\", \"b\", \"c\"]);\n\njulia> close(f);\n\njulia> f = fits_open_file(fname, CFITSIO.READONLY);\n\njulia> fits_get_num_hdus(f)\n2\n\njulia> fits_movabs_hdu(f, 2)\n:binary_table\n\njulia> fits_get_num_rows(f)\n3\n\njulia> fits_get_num_cols(f)\n3\n\njulia> fits_read_col(f, 1, 1, 1, zeros(Int32, 3))\n3-element Vector{Int32}:\n 1\n 2\n 3\n\njulia> close(f); See also  fits_create_ascii_tbl  and  fits_create_binary_tbl  for similar functions that create ASCII and binary tables, respectively. source"},{"id":1856,"pagetitle":"Table","title":"CFITSIO.fits_delete_col","ref":"/CFITSIO/stable/table/#CFITSIO.fits_delete_col","content":" CFITSIO.fits_delete_col  —  Function fits_delete_col(f::FITSFile, colnum::Integer) Delete the column at position  colnum  in the current HDU. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\", \"units\"), (\"col2\", \"1E\", \"units\")]);\n\njulia> fits_write_col(f, 1, 1, 1, [1, 2, 3]);\n\njulia> fits_write_col(f, 2, 1, 1, [1.0, 2.0, 3.0]);\n\njulia> fits_get_num_cols(f)\n2\n\njulia> fits_get_coltype(f, 1)\n(41, 1, 4)\n\njulia> fits_delete_col(f, 1); # delete the first column\n\njulia> fits_get_num_cols(f)\n1\n\njulia> fits_get_coltype(f, 1)\n(42, 1, 4)\n\njulia> close(f) source"},{"id":1857,"pagetitle":"Table","title":"CFITSIO.fits_delete_rowlist","ref":"/CFITSIO/stable/table/#CFITSIO.fits_delete_rowlist","content":" CFITSIO.fits_delete_rowlist  —  Function fits_delete_rowlist(f::FITSFile, rowlist::Vector{<:Integer}) Delete a list of rows from the current HDU. The rows to be deleted are specified by the  rowlist  vector, which contains the row numbers to be deleted. The row numbers are 1-based, so the first row is at position 1. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\", \"units\")]);\n\njulia> fits_write_col(f, 1, 1, 1, [1, 2, 3, 4, 5])\n\njulia> CFITSIO.fits_flush_file(f); # flush the file to disk\n\njulia> fits_delete_rowlist(f, [1, 3, 5]); # delete rows 1, 3 and 5\n\njulia> fits_read_col(f, 1, 1, 1, zeros(Int32, 2))\n2-element Vector{Int32}:\n 2\n 4\n\njulia> close(f); source"},{"id":1858,"pagetitle":"Table","title":"CFITSIO.fits_get_colnum","ref":"/CFITSIO/stable/table/#CFITSIO.fits_get_colnum","content":" CFITSIO.fits_get_colnum  —  Function fits_get_colnum(f::FITSFile, tmplt::String; case_sensitive::Bool = true) Return the column number of the first column whose name matches the template  tmplt . If no column matches, an error is thrown. The template can contain the  *  character, which matches any number of characters. The keyword argument  case_sensitive  determines whether the search is case-sensitive or not. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"Count\", \"1J\", \"units\"), (\"Energy\", \"1E\", \"eV\")]);\n\njulia> fits_get_colnum(f, \"Energy\")\n2\n\njulia> fits_get_colnum(f, \"e*\"; case_sensitive = false)\n2\n\njulia> fits_get_colnum(f, \"col\")\nERROR: CFITSIO has encountered an error. Error code 219: named column not found\nDetailed error message follows:\nffgcnn could not find column: col\n[...]\n\njulia> close(f) source"},{"id":1859,"pagetitle":"Table","title":"CFITSIO.fits_get_coltype","ref":"/CFITSIO/stable/table/#CFITSIO.fits_get_coltype","content":" CFITSIO.fits_get_coltype  —  Function fits_get_coltype(f::FITSFile, colnum::Integer) Provided that the current HDU contains either an ASCII or binary table, return information about the column at position  colnum  (counting from 1). Returns a tuple containing typecode : CFITSIO integer type code of the column. repcount : Repetition count for the column. width : Width of an individual element. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\", \"units\")]);\n\njulia> fits_get_coltype(f, 1)\n(41, 1, 4)\n\njulia> close(f) source"},{"id":1860,"pagetitle":"Table","title":"CFITSIO.fits_get_eqcoltype","ref":"/CFITSIO/stable/table/#CFITSIO.fits_get_eqcoltype","content":" CFITSIO.fits_get_eqcoltype  —  Function fits_get_eqcoltype(ff::FITSFile, colnum::Integer) Provided that the current HDU contains either an ASCII or binary table, return information about the column at position  colnum  (counting from 1). This returns the equivalent data type of the column. Returns a tuple containing typecode : CFITSIO integer type code of the column. repcount : Repetition count for the column. width : Width of an individual element. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1I\", \"units\")]); # Int16 values\n\njulia> fits_write_key(f, \"TSCAL1\", 0.1, \"scale factor\")\n\njulia> fits_write_key(f, \"TZERO1\", 0.0, \"zero point\")\n\njulia> fits_get_eqcoltype(f, 1) # equivalent element type is Float32, code 42\n(42, 1, 2)\n\njulia> close(f) source"},{"id":1861,"pagetitle":"Table","title":"CFITSIO.fits_get_num_cols","ref":"/CFITSIO/stable/table/#CFITSIO.fits_get_num_cols","content":" CFITSIO.fits_get_num_cols  —  Function fits_get_num_cols(f::FITSFile) Return the number of columns in the current table HDU. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\", \"units\")]);\n\njulia> close(f)\n\njulia> f = fits_open_file(fname, CFITSIO.READONLY);\n\njulia> fits_movabs_hdu(f, 2);\n\njulia> fits_get_num_cols(f)\n1\n\njulia> close(f) source"},{"id":1862,"pagetitle":"Table","title":"CFITSIO.fits_get_num_rows","ref":"/CFITSIO/stable/table/#CFITSIO.fits_get_num_rows","content":" CFITSIO.fits_get_num_rows  —  Function fits_get_num_rows(f::FITSFile) Return the number of rows in the current table HDU. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\", \"units\")]);\n\njulia> fits_get_num_rows(f)\n0\n\njulia> fits_write_col(f, 1, 1, 1, [1, 2, 3]);\n\njulia> fits_get_num_rows(f)\n3\n\njulia> close(f) source"},{"id":1863,"pagetitle":"Table","title":"CFITSIO.fits_get_rowsize","ref":"/CFITSIO/stable/table/#CFITSIO.fits_get_rowsize","content":" CFITSIO.fits_get_rowsize  —  Function fits_get_rowsize(f::FITSFile) Return optimal number of rows to read or write at one time for maximum I/O efficiency. source"},{"id":1864,"pagetitle":"Table","title":"CFITSIO.fits_insert_col","ref":"/CFITSIO/stable/table/#CFITSIO.fits_insert_col","content":" CFITSIO.fits_insert_col  —  Function fits_insert_col(f::FITSFile, colnum::Integer, ttype::String, tform::String) Insert a new column at position  colnum  in the current table HDU. The  ttype  and  tform  parameters specify the name and type of the column, respectively. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\", \"units\")]);\n\njulia> fits_insert_col(f, 2, \"col2\", \"1E\");\n\njulia> fits_write_col(f, 2, 1, 1, [1.0, 2.0, 3.0]);\n\njulia> fits_read_col(f, 2, 1, 1, zeros(Float32, 3))\n3-element Vector{Float32}:\n 1.0\n 2.0\n 3.0\n\njulia> close(f); source"},{"id":1865,"pagetitle":"Table","title":"CFITSIO.fits_insert_cols","ref":"/CFITSIO/stable/table/#CFITSIO.fits_insert_cols","content":" CFITSIO.fits_insert_cols  —  Function fits_insert_cols(f::FITSFile, colnum::Integer,\n    ttype::Vector{String}, tform::Vector{String}) Insert a number of new columns at position  colnum  in the current table HDU. The  ttype  and  tform  parameters specify the names and types of the columns, respectively. The length of  ttype  and  tform  must match, as each column corresponds to one element in these vectors. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\", \"units\")]);\n\njulia> fits_insert_cols(f, 2, [\"col2\", \"col3\"], [\"1E\", \"1D\"]);\n\njulia> fits_write_col(f, 2, 1, 1, [1.0, 2.0, 3.0]);\n\njulia> fits_write_col(f, 3, 1, 1, [1.0, 2.0, 3.0]);\n\njulia> fits_read_col(f, 2, 1, 1, zeros(Float32, 3))\n3-element Vector{Float32}:\n 1.0\n 2.0\n 3.0\n\njulia> fits_read_col(f, 3, 1, 1, zeros(Float64, 3))\n3-element Vector{Float64}:\n 1.0\n 2.0\n 3.0\n\njulia> close(f); source"},{"id":1866,"pagetitle":"Table","title":"CFITSIO.fits_insert_rows","ref":"/CFITSIO/stable/table/#CFITSIO.fits_insert_rows","content":" CFITSIO.fits_insert_rows  —  Function fits_insert_rows(f::FITSFile, firstrow::Integer, nrows::Integer) Insert a number of rows equal to  nrows after  the row number  firstrow . The elements in each row are initialized to their default value: you can modify them later using  fits_write_col . Since the first row is at position 1, in order to insert rows  before  the first one  firstrow  must be equal to zero. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\", \"units\")])\n\njulia> fits_write_col(f, 1, 1, 1, [1, 2, 3])\n\njulia> fits_insert_rows(f, 0, 2)\n\njulia> fits_write_col(f, 1, 1, 1, [4, 5])\n\njulia> fits_read_col(f, 1, 1, 1, zeros(Int32, 5))\n5-element Vector{Int32}:\n 4\n 5\n 1\n 2\n 3\n\njulia> close(f) source"},{"id":1867,"pagetitle":"Table","title":"CFITSIO.fits_delete_rows","ref":"/CFITSIO/stable/table/#CFITSIO.fits_delete_rows","content":" CFITSIO.fits_delete_rows  —  Function fits_delete_rows(f::FITSFile, firstrow::integer, nrows::Integer) Delete  nrows  rows, starting from the one at position  firstrow . The index of the first row is 1. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\", \"units\")]);\n\njulia> fits_write_col(f, 1, 1, 1, [1, 2, 3]);\n\njulia> fits_delete_rows(f, 1, 2); # delete the first two rows\n\njulia> fits_read_col(f, 1, 1, 1, zeros(Int32, 1))\n1-element Vector{Int32}:\n 3\n\njulia> close(f); source"},{"id":1868,"pagetitle":"Table","title":"CFITSIO.fits_read_col","ref":"/CFITSIO/stable/table/#CFITSIO.fits_read_col","content":" CFITSIO.fits_read_col  —  Function fits_read_col(f::FITSFile, colnum::Integer, firstrow::Integer, firstelem::Integer, data::Array) Read data from one column of an ASCII/binary table into  data . Arguments f::FITSFile : the file to be read. colnum::Integer : the column number, where the value of the first column is  1 . firstrow::Integer : the elements to be read start from this row. firstelem::Integer : specifies which is the first element to be read, when each cell contains more than one element (i.e., the \"repetition count\" of the field is greater than one). data::Array : at the end of the call, this will be filled with the elements read from the column. The length of the array gives the overall number of elements. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\", \"units\")]);\n\njulia> fits_write_col(f, 1, 1, 1, [1, 2, 3]);\n\njulia> fits_read_col(f, 1, 1, 1, zeros(Int32, 3))\n3-element Vector{Int32}:\n 1\n 2\n 3\n\njulia> close(f) source"},{"id":1869,"pagetitle":"Table","title":"CFITSIO.fits_read_atblhdr","ref":"/CFITSIO/stable/table/#CFITSIO.fits_read_atblhdr","content":" CFITSIO.fits_read_atblhdr  —  Function fits_read_atblhdr(f::FITSFile, maxdim::Integer = 99) Read the header of an ASCII table HDU, where  maxdim  represents the maximum number of columns to read. The function returns the length of a row in bytes, the number of rows, the number of columns, the column names as a  Vector{String} , the byte offsets to each column, the TFORMn values as a  Vector{String} , the TUNITn values as a  Vector{String} , and the  EXTNAME::String  keyword, if any. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_ascii_tbl(f, 0, [(\"col1\", \"D10\"), (\"col2\", \"F10.2\")])\n\njulia> fits_read_atblhdr(f)\n(21, 0, 2, [\"col1\", \"col2\"], [1, 12], [\"D10\", \"F10.2\"], [\"\", \"\"], \"\")\n\njulia> close(f) source"},{"id":1870,"pagetitle":"Table","title":"CFITSIO.fits_read_btblhdr","ref":"/CFITSIO/stable/table/#CFITSIO.fits_read_btblhdr","content":" CFITSIO.fits_read_btblhdr  —  Function fits_read_btblhdr(f::FITSFile, maxdim::Integer = 99) Read the header of a binary table HDU, where  maxdim  represents the maximum number of columns to read. The function returns the number of rows, the number of columns, the column names as a  Vector{String} , the TFORMn values  as a  Vector{String} , the TUNITn values as a  Vector{String} , and the  EXTNAME::String  and  PCOUNT::Int  keywords. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\"), (\"col2\", \"1E\")])\n\njulia> fits_read_btblhdr(f)\n(0, 2, [\"col1\", \"col2\"], [\"1J\", \"1E\"], [\"\", \"\"], \"\", 0)\n\njulia> close(f) source"},{"id":1871,"pagetitle":"Table","title":"CFITSIO.fits_read_descript","ref":"/CFITSIO/stable/table/#CFITSIO.fits_read_descript","content":" CFITSIO.fits_read_descript  —  Function fits_read_descript(ff::FITSFile, colnum::Integer, rownum::Integer) Return the descriptor for a variable length column in a binary table. The descriptor consists of 2 integer parameters: the number of elements in the array and the starting offset relative to the start of the heap. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1PJ\", \"units\")]) # P = variable length column\n\njulia> fits_write_col(f, 1, 1, 1, [1, 2, 3]) # write a vector to the column\n\njulia> fits_read_descript(f, 1, 1) # read the descriptor for the first row and first column\n(3, 0)\n\njulia> fits_write_col(f, 1, 2, 1, [1, 2, 3, 4])\n\njulia> fits_read_descript(f, 1, 2)\n(4, 12)\n\njulia> close(f) source"},{"id":1872,"pagetitle":"Table","title":"CFITSIO.fits_read_keys_lng","ref":"/CFITSIO/stable/table/#CFITSIO.fits_read_keys_lng","content":" CFITSIO.fits_read_keys_lng  —  Function fits_read_keys_lng(f::FITSFile, keyname::String, nstart::Integer, nmax::Integer) Read a sequence of indexed keyword values (e.g.,  NAXIS1 ,  NAXIS2 , ...) as an  Integer  vector. Return the values of the keywords as a  Vector{Clong} , as well as the number of values found. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_img(f, Int32, (2, 3));\n\njulia> fits_read_keys_lng(f, \"NAXIS\", 1, 2)\n([2, 3], 2)\n\njulia> close(f) source"},{"id":1873,"pagetitle":"Table","title":"CFITSIO.fits_read_tdim","ref":"/CFITSIO/stable/table/#CFITSIO.fits_read_tdim","content":" CFITSIO.fits_read_tdim  —  Function fits_read_tdim(ff::FITSFile, colnum::Integer) Return the dimensions of a multidimensional array column in a binary table. The elements are stored contiguously in the column, and the dimensions of the array are normally provided by the  TDIMn  keyword. If this keyword is not present, then this routine returns  [r]  with  r  equals to the repeat count in the TFORM keyword. If the  TDIMn  keyword is present, it returns the dimensions as specified in that keyword. If the HDU is not a binary table, an error is thrown. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"3E\", \"units\")])\n\njulia> fits_write_col(f, 1, 1, 1, [1.0 2.0 3.0])\n\njulia> fits_read_tdim(f, 1)\n1-element Vector{Int64}:\n 3\n\njulia> fits_write_tdim(f, 1, [1,3]) # specify the dimensions\n\njulia> fits_read_key_str(f, \"TDIM1\")\n(\"(1,3)\", \"size of the multidimensional array\")\n\njulia> fits_read_tdim(f, 1)\n2-element Vector{Int64}:\n 1\n 3\n\njulia> close(f) See also  fits_write_tdim  for writing the dimensions of arrays stored in a column. source"},{"id":1874,"pagetitle":"Table","title":"CFITSIO.fits_write_col","ref":"/CFITSIO/stable/table/#CFITSIO.fits_write_col","content":" CFITSIO.fits_write_col  —  Function fits_write_col(f::FITSFile, colnum::Integer, firstrow::Integer, firstelem::Integer, data::Array) Write some data in one column of a ASCII/binary table. If there is no room for the elements, new rows will be created. (It is therefore useless to call  fits_insert_rows  if you only need to  append  elements to the end of a table.) f::FITSFile : the file in which data will be written. colnum::Integer : the column number, where the value of the first column is  1 . firstrow::Integer : the data wil be written from this row onwards. firstelem::Integer : specifies the position in the row where the first element will be written. data::Array : contains the elements that are to be written to the column of the table. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"1J\", \"units\")]);\n\njulia> fits_write_col(f, 1, 1, 1, [1, 2, 3]);\n\njulia> fits_read_col(f, 1, 1, 1, zeros(Int32, 3))\n3-element Vector{Int32}:\n 1\n 2\n 3\n\njulia> close(f) source"},{"id":1875,"pagetitle":"Table","title":"CFITSIO.fits_write_tdim","ref":"/CFITSIO/stable/table/#CFITSIO.fits_write_tdim","content":" CFITSIO.fits_write_tdim  —  Function fits_write_tdim(ff::FITSFile, colnum::Integer, naxes::Vector{Int64}) Write the dimensions of a multidimensional array column in a binary table. The data is stored contiguously in the column, and the dimensions are specified by the  TDIMn  keyword. Example julia> fname = joinpath(mktempdir(), \"test.fits\");\n\njulia> f = fits_create_file(fname);\n\njulia> fits_create_binary_tbl(f, 0, [(\"col1\", \"3E\", \"units\")])\n\njulia> fits_write_col(f, 1, 1, 1, [1.0 2.0 3.0])\n\njulia> fits_write_tdim(f, 1, [3]) # interpret the data as a 1D array\n\njulia> fits_read_key_str(f, \"TDIM1\")\n(\"(3)\", \"size of the multidimensional array\")\n\njulia> fits_read_tdim(f, 1)\n1-element Vector{Int64}:\n 3\n\njulia> fits_delete_key(f, \"TDIM1\") # remove the TDIM keyword\n\njulia> fits_write_tdim(f, 1, [1,3]) # interpret the data as a 2D array\n\njulia> fits_read_key_str(f, \"TDIM1\")\n(\"(1,3)\", \"size of the multidimensional array\")\n\njulia> fits_read_tdim(f, 1)\n2-element Vector{Int64}:\n 1\n 3\n\njulia> close(f) See also  fits_read_tdim  for reading the dimensions of arrays stored in a column. source"},{"id":1878,"pagetitle":"Type Conversions","title":"Type Conversions","ref":"/CFITSIO/stable/types/#Type-Conversions","content":" Type Conversions The following tables give the correspondances between CFITSIO \"types\", the BITPIX keyword and Julia types."},{"id":1879,"pagetitle":"Type Conversions","title":"CFITSIO Types","ref":"/CFITSIO/stable/types/#CFITSIO-Types","content":" CFITSIO Types CODE CFITSIO Julia int Cint long Clong LONGLONG Int64"},{"id":1880,"pagetitle":"Type Conversions","title":"FITS BITPIX","ref":"/CFITSIO/stable/types/#FITS-BITPIX","content":" FITS BITPIX CODE CFITSIO Julia 8 BYTE_IMG UInt8 16 SHORT_IMG Int16 32 LONG_IMG Int32 64 LONGLONG_IMG Int64 -32 FLOAT_IMG Float32 -64 DOUBLE_IMG Float64"},{"id":1881,"pagetitle":"Type Conversions","title":"CFITSIO Aliases","ref":"/CFITSIO/stable/types/#CFITSIO-Aliases","content":" CFITSIO Aliases CODE CFITSIO Julia Comments 10 SBYTE_IMG Int8 written as: BITPIX = 8, BSCALE = 1, BZERO = -128 20 USHORT_IMG UInt16 written as: BITPIX = 16, BSCALE = 1, BZERO = 32768 40 LONG_IMG UInt32 written as: BITPIX = 32, BSCALE = 1, BZERO = 2147483648 80 ULONGLONG_IMG UInt64 written as: BITPIX = 64, BSCALE = 1, BZERO = 9223372036854775808"},{"id":1882,"pagetitle":"Type Conversions","title":"FITS Table Data Types","ref":"/CFITSIO/stable/types/#FITS-Table-Data-Types","content":" FITS Table Data Types CODE CFITSIO Julia 1 TBIT 11 TBYTE Cuchar ,  UInt8 12 TSBYTE Cchar ,  Int8 14 TLOGICAL Bool 16 TSTRING String 20 TUSHORT Cushort 21 TSHORT Cshort 30 TUINT Cuint 31 TINT Cint 40 TULONG Culong 41 TLONG Clong 42 TFLOAT Cfloat 80 TULONGLONG UInt64 81 TLONGLONG Int64 82 TDOUBLE Cdouble 83 TCOMPLEX Complex{Cfloat} 163 TDBLCOMPLEX Complex{Cdouble}"},{"id":1883,"pagetitle":"Type Conversions","title":"CFITSIO.bitpix_from_type","ref":"/CFITSIO/stable/types/#CFITSIO.bitpix_from_type","content":" CFITSIO.bitpix_from_type  —  Function bitpix_from_type(::Type)::Cint Return the FITS BITPIX code for the given Julia type Example julia> CFITSIO.bitpix_from_type(Int64)\n64 See also  type_from_bitpix source"},{"id":1884,"pagetitle":"Type Conversions","title":"CFITSIO.type_from_bitpix","ref":"/CFITSIO/stable/types/#CFITSIO.type_from_bitpix","content":" CFITSIO.type_from_bitpix  —  Function type_from_bitpix(::Integer)::Type Return the Julia type from the FITS BITPIX code Example julia> CFITSIO.type_from_bitpix(64)\nInt64 See also  bitpix_from_type source"},{"id":1885,"pagetitle":"Type Conversions","title":"CFITSIO.cfitsio_typecode","ref":"/CFITSIO/stable/types/#CFITSIO.cfitsio_typecode","content":" CFITSIO.cfitsio_typecode  —  Function cfitsio_typecode(::Type)::Cint Return the CFITSIO type code for the given Julia type. Example julia> CFITSIO.cfitsio_typecode(Int64)\n81 source"},{"id":1888,"pagetitle":"FITSFiles","title":"Introduction","ref":"/FITSFiles/stable/#Introduction","content":" Introduction FITSFiles.jl  is a Julia implementation of the Flexible Image Transport System (FITS) file IO standard. FITSFiles.fits  —  Method fits(io::IO; <keywords>)\nfits(filename::AbstractString; <keywords>) Open and read a FITS file, returning a vector of header-data units (HDUs). The default data stucture for Random and Bintable HDUs is a named tuple of arrays. Keywords record::Bool=false : structure the data as a list of records scale::Bool=true : apply the scale and zero keywords to the data source FITSFiles.info  —  Method info(hdus::Vector{HDU}) Briefly describe the list of header-data units (HDUs). source FITSFiles.write  —  Method write(io::IO, hdus::Vector{HDU})    write(filename::AbstractString, hdus::Vector{HDU}) Write a vector of header-data units (HDUs) to a file. source FITSFiles.Bintable  —  Type Bintable header-data unit (HDU) A Bintable HDU consists of a vector of cards and optionally a 2-dimensional array of binary data structured as a vector of records. source FITSFiles.DataFormat  —  Type DataFormat(type, leng, shape, param, group, heap) The generic data format descriptor for HDUs. source FITSFiles.HDU  —  Type HDU{T}(cards, data)\nHDU([data, [cards]]; <keywords>)\nHDU(cards; <keywords>)\nHDU(type, nothing, [cards]; <keywords>)\nHDU(type, data, [cards]; <keywords>) Create an header-data unit described by data and cards of type AbstractHDU. The HDU function tries to determine the HDU type based on the data and cards. If only data is provided, then an array is interpreted as a Primary HDU and a Tuple or NamedTuple as a BinaryTable. If mandatory cards are provided, then they are used to determine the HDU type. Otherwise, the HDU type must be specified. HDU types are: Primary, Random, Image, Table, Bintable, and Conform. arguments data::U=nothing : the binary or ASCII data, where U<:Union{AbstractArray,   Tuple, NamedTuple, Nothing} cards::U=nothing : the list of cards, where U<:Union{Card, Vector{Card}, Nothing} Keywords record::Bool=false : structure the data as a list of records scale::Bool=true : apply the scale and zero keywords to the data append::Bool=false : append CONTINUE cards for long strings (>68 characters) fixed::Bool=true : create fixed format cards slash::Integer=32 : character index of the comment separator (/) lpad::Integer=1 : number of spaces before the comment separator rpad::Integer=1 : number of spaces after the comment separator truncate::Bool=true : truncate the comment string at the end of the card source FITSFiles.Image  —  Type Image header-data unit (HDU) An Image HDU consists of a vector cards and optionally a multidimensional array (<=999 dimensions). source FITSFiles.Primary  —  Type Primary header-data unit (HDU) A Primary HDU consists of a vector of cards and optionally a multidimensional array (<=999 dimensions). The Primary HDU is the first HDU in a vector of HDUs. source FITSFiles.Random  —  Type Random header-data unit (HDU) A Random HDU consists of a vector of cards and optionally a vector of records containing a list of parameters followed by a multidimensional array. The Random HDU is the first HDU in a vector of HDUs. source FITSFiles.Table  —  Type Table header-data unit (HDU) A Table HDU consists of a vector of cards and optionally a 2-dimensional array of ASCII data structured as vector of records. source FITSFiles.info  —  Method info(hdu::HDU) Briefly describe the header-data unit. source FITSFiles.read  —  Method read(io, type; <keywords>) Read the specified HDU type from a file. source FITSFiles.typeofhdu  —  Method typeofhdu(data)\ntypeofhdu(dict)\ntypeofhdu(data, dict) Determine the HDU type based on the data structure, the mandatory keywords, or both. source FITSFiles.write  —  Method write(io, hdu; <keywords>) Write the specified HDU type to a file. source FITSFiles.Card  —  Type Card(type, key, value, comment, format)\nCard([key, [value, [comment]]]; <keywords>)\nCard(\"HIERARCH\", key, [key, [value, [comment]]]; <keywords>) Create a card type, where type is Comment, End, Hierarch, History, Invalid, or Value{T}. Argments key::AbstractString=\"\" : keyword string value::U=missing : keyword value, where U is Bool, Number, or String comment::AbstractString=\"\" : comment string Keywords append::Bool=false : append CONTINUE cards for long strings (>68 characters) fixed::Bool=true : use fixed format slash::Integer=32 : index of comment separator (/) lpad::Integer=1 : number of spaces before comment separator rpad::Integer=1 : number of spaces after comment separator truncate::Bool=true : truncate comment at end of card source FITSFiles.CardFormat  —  Type CardFormat(fixd, vbeg, vend, ampr, slsh, cbeg, cend) Create a card format descriptor. source FITSFiles.join_cards  —  Method join_cards(cards) Join CONTINUE cards to initial long string card to create a long value and comment card source FITSFiles.parse  —  Method parse(Card, image) Parse 80 character card image from string buffer. source FITSFiles.split_card  —  Method split_card(key, value, comment, format) Split card having long value and comment fields into multiple cards If length of comment field is 0 because comment separator index is too large, then comment is deleted.  Decreasing comment separator index will allow inclusion of comment. source"},{"id":1891,"pagetitle":"Introduction","title":"FITSIO.jl","ref":"/FITSIO/stable/#FITSIO.jl","content":" FITSIO.jl A  Julia  package for reading and writing Flexible Image Transport System (FITS) files, based on the  cfitsio  library. The interface is inspired by Erin Sheldon's  fitsio  Python package. Warning The  Libcfitsio  submodule has been moved to  CFITSIO.jl  and will be deprecated in a future release."},{"id":1892,"pagetitle":"Introduction","title":"Installation","ref":"/FITSIO/stable/#Installation","content":" Installation FITSIO.jl  can be installed using the built-in package manager pkg> add FITSIO"},{"id":1893,"pagetitle":"Introduction","title":"Usage","ref":"/FITSIO/stable/#Usage","content":" Usage To open an existing file for reading: julia> using FITSIO\n\njulia> f = FITS(\"file.fits\")\nFile: file.fits\nMode: \"w\" (read-write)\nHDUs: Num  Name  Type\n      1          Image\n      2          Table (At the REPL, information about the file contents is shown.) A FITS file consists of one or more header-data units (HDUs), concatenated one after the other. The  FITS  object therefore is represented as a collection of these HDUs. Get information about the first HDU: julia> f[1]\nFile: file.fits\nHDU: 1\nType: Image\nDatatype: Float64\nDatasize: (800, 800) Iterate over HDUs in the file: julia> for hdu in f; println(typeof(hdu)); end\nFITSIO.ImageHDU\nFITSIO.TableHDU Each HDU can contain image data, or table data (either binary or ASCII-formatted). For image extensions, get the size of the image without reading it: julia> ndims(f[1])\n    2\n\njulia> size(f[1])\n(800,800)\n\njulia> size(f[1], 2)\n800 Read an image from disk: julia> data = read(f[1]);  # read an image from disk\n\njulia> data = read(f[1], :, 790:end);  # read just a subset of image Show info about a binary table: julia> f[2]\nFile: file.fits\nHDU: 2\nType: Table\nRows: 20\nColumns: Name  Size  Type    TFORM\n         col2        String  5A\n         col1        Int64   1K Read a column from the table: julia> data = read(f[2], \"col1\") Table HDUs implement the  Tables.jl  interface, so you can load them into other table types, like  DataFrames . julia> df = DataFrame(f[2]) Variable length columns are not supported by the Tables.jl interface, and  Tables  methods will ignore them. Read the entire header into memory and get values from it: julia> header = read_header(f[1]);  # read the entire header from disk\n\njulia> length(header)  # total number of records in header\n17\n\njulia> haskey(header, \"NAXIS1\")  # check if a key exists\ntrue\n\njulia> header[\"NAXIS1\"]  # get value by keyword\n800\n\njulia> header[4]  # get value by position\n800\n\njulia> get_comment(header, \"NAXIS\")  # get comment for a given keyword\n\"length of data axis 1\" Read just a single header record without reading the entire header: julia> read_key(f[1], 4)  # by position\n(\"NAXIS1\",800,\"length of data axis 1\")\n\njulia> read_key(f[1], \"NAXIS1\")  # read by keyword\n(800,\"length of data axis 1\") Manipulate a header in memory: julia> header[\"NEWKEY\"] = 10  # change or add a keyword\n\njulia> set_comment!(header, \"NEWKEY\", \"this is a comment\") Close the file: julia> close(f) ( FITS  objects are also closed automatically when garbage collected.) Open a new file for writing: julia> f = FITS(\"newfile.fits\", \"w\"); The second argument can be  \"r\"  (read-only; default),  \"r+\"  (read-write) or  \"w\"  (write). In \"write\" mode, any existing file of the same name is overwritten. Write an image to the file: julia> data = reshape([1:100;], 5, 20)\n\njulia> write(f, data)  # Write a new image extension with the data\njulia> close(f) To write some header keywords in the new extension, pass a  FITSHeader  instance as a keyword:  write(f, data; header=header) Overwrite image data in an existing file: julia> f = FITS(\"newfile.fits\", \"r+\")  # Reopen the file in read-write mode\njulia> data = reshape([101:200;], 5, 20)  # Prepare new image data\njulia> image_hdu = f[1]\njulia> write(image_hdu, data)  # Overwrite the image Write a table to the file: julia> data = Dict(\"col1\"=>[1., 2., 3.], \"col2\"=>[1, 2, 3]);\n\njulia> write(f, data)  # write a new binary table to a new extension Compressed storage Setting the file extension to  .gz  will automatically use GZIP compression and save on storage space. julia> FITS(\"abc.fits\", \"w\") do f # save the image uncompressed\n           write(f, ones(200,200))\n       end\n\njulia> filesize(\"abc.fits\")\n325440\n\njulia> FITS(\"abc.fits.gz\", \"w\") do f # save the image compressed\n            write(f, ones(200,200))\n       end\n\njulia> filesize(\"abc.fits.gz\")\n2117 Alternately the compression algorithm might be specified in square brackets after the filename. Check the  CFITSIO website  for the details of this usage. julia> FITS(\"abc.fits[compress R 100,100]\", \"w\") do f # Rice algorithm with a 100 x 100 pixel tile size\n           write(f, ones(200,200))\n       end\n\njulia> filesize(\"abc.fits\")\n8640 Warn Compression is \"loss-less\" for images with integer pixel values, and might be lossy for floating-point images."},{"id":1896,"pagetitle":"API Reference","title":"API Reference","ref":"/FITSIO/stable/api/#API-Reference","content":" API Reference"},{"id":1897,"pagetitle":"API Reference","title":"File operations","ref":"/FITSIO/stable/api/#File-operations","content":" File operations"},{"id":1898,"pagetitle":"API Reference","title":"FITSIO.FITS","ref":"/FITSIO/stable/api/#FITSIO.FITS","content":" FITSIO.FITS  —  Type FITS(filename::String[, mode::String = \"r\"]; extendedparser = true) Open or create a FITS file.  mode  can be one of  \"r\"  (read-only),  \"r+\"  (read-write) or  \"w\"  (write). In \"write\" mode, any existing file of the same name is overwritten. A  FITS  object is a collection of \"Header-Data Units\" (HDUs) and supports the following operations: f[i] : Return the  i -th HDU. f[name]  or  f[name, ver] : Return the HDU containing the given the given EXTNAME (or HDUNAME) keyword (a String), and optionally the given EXTVER (or HDUVER) number (an Integer). Iteration: for hdu in f\n    ...\nend The keyword argument  extendedparser  may be used to enable or disable the  extended filename parser . If disabled,  filename  is treated exactly as the name of the file and is not tokenized into parameters. source"},{"id":1899,"pagetitle":"API Reference","title":"Base.length","ref":"/FITSIO/stable/api/#Base.length","content":" Base.length  —  Function length(f::FITS) Number of HDUs in the file. source length(hdr::FITSHeader) Number of records in header of HDU. source length(hdu::ImageHDU) Get total number of pixels in image (product of  size(hdu) ). source"},{"id":1900,"pagetitle":"API Reference","title":"Base.close","ref":"/FITSIO/stable/api/#Base.close","content":" Base.close  —  Function close(f::FITS) Close the file. Subsequent attempts to operate on  f  will result in an error.  FITS  objects are also automatically closed when they are garbage collected. source"},{"id":1901,"pagetitle":"API Reference","title":"Base.deleteat!","ref":"/FITSIO/stable/api/#Base.deleteat!","content":" Base.deleteat!  —  Function deleteat!(f::FITS, i::Integer) Delete the HDU at index  i  in the FITS file. If  i == 1 , this deletes the primary HDU and replaces it with a bare HDU with no data and a minimal header. If  i > 1 , this removes the HDU at index  i  and moves the following HDUs forward. source"},{"id":1902,"pagetitle":"API Reference","title":"Header operations","ref":"/FITSIO/stable/api/#Header-operations","content":" Header operations"},{"id":1903,"pagetitle":"API Reference","title":"FITSIO.read_key","ref":"/FITSIO/stable/api/#FITSIO.read_key","content":" FITSIO.read_key  —  Function read_key(hdu::HDU, key::String) -> (value, comment) Read the HDU header record specified by keyword and return a tuple where  value  is the keyword parsed value (of type  String ,  Bool ,  Int ,  Float64  or  Nothing ),  comment  is the keyword comment (as a string). Throw an error if  key  is not found. source read_key(hdu::HDU, key::Integer) -> (keyname, value, comment) Same as  above  but FITS card is specified by its position and returns a 3 element tuple where  keyname  is the keyword name (a string). source"},{"id":1904,"pagetitle":"API Reference","title":"FITSIO.write_key","ref":"/FITSIO/stable/api/#FITSIO.write_key","content":" FITSIO.write_key  —  Function write_key(hdu::HDU, key::String, value[, comment]) Write a keyword value the HDU's header.  value  can be a standard header type ( String ,  Bool ,  Integer ,  AbstractFloat ) or  nothing , in which case the value part of the record will be empty. If the keyword already exists, the value will be overwritten. The comment will only be overwritten if given. If the keyword does not already exist, a new record will be appended at the end of the header. source"},{"id":1905,"pagetitle":"API Reference","title":"FITSIO.read_header","ref":"/FITSIO/stable/api/#FITSIO.read_header","content":" FITSIO.read_header  —  Function read_header(filename::AbstractString, hduindex = 1) -> FITSHeader Convenience function to read the entire header corresponding to the HDU at index  hduindex  contained in the FITS file named  filename . Functionally  read_header(filename, hduindex)  is equivalent to FITS(filename, \"r\") do f\n    read_header(f[hduindex])\nend source read_header(hdu::HDU) -> FITSHeader Read the entire header from the given HDU and return a  FITSHeader  object. The value of each header record is parsed as  Int ,  Float64 ,  String ,  Bool  or  nothing  according to the FITS standard. If the value cannot be parsed according to the FITS standard, the value is stored as the raw unparsed  String . source read_header(hdu::HDU, String) -> String Read the entire header from the given HDU as a single string. source"},{"id":1906,"pagetitle":"API Reference","title":"FITSIO.FITSHeader","ref":"/FITSIO/stable/api/#FITSIO.FITSHeader","content":" FITSIO.FITSHeader  —  Type FITSHeader(keys::Vector{String}, values::Vector, comments::Vector{String}) An in-memory representation of the header of an HDU. It stores the (key, value, comment) information for each 80-character \"card\" in a header. Note that this structure is not linked to a FITS file in any way; it is just a convenient structure for storing the header contents after reading from a file. (This is similar to how an  Array  returned by  read(f[1])  is not linked to the FITS file  f .)  Manipulating a  FITSHeader  will therefore have no immediate impact on any file, even if it was created by  read_header(::HDU) .  You can, however, write a  FITSHeader  to a file using the  write(::FITS, ...)  methods that append a new HDU to a file. source"},{"id":1907,"pagetitle":"API Reference","title":"Base.length","ref":"/FITSIO/stable/api/#Base.length-Tuple{FITSHeader}","content":" Base.length  —  Method length(hdr::FITSHeader) Number of records in header of HDU. source"},{"id":1908,"pagetitle":"API Reference","title":"Base.haskey","ref":"/FITSIO/stable/api/#Base.haskey-Tuple{FITSHeader, String}","content":" Base.haskey  —  Method haskey(hdr::FITSHeader, key::String) Returns true if  key  exists in header, otherwise false. source"},{"id":1909,"pagetitle":"API Reference","title":"Base.keys","ref":"/FITSIO/stable/api/#Base.keys-Tuple{FITSHeader}","content":" Base.keys  —  Method keys(hdr::FITSHeader) Array of keywords in header of HDU (not a copy). source"},{"id":1910,"pagetitle":"API Reference","title":"Base.values","ref":"/FITSIO/stable/api/#Base.values-Tuple{FITSHeader}","content":" Base.values  —  Method values(hdr::FITSHeader) Array of values in header of HDU (not a copy). source"},{"id":1911,"pagetitle":"API Reference","title":"FITSIO.get_comment","ref":"/FITSIO/stable/api/#FITSIO.get_comment","content":" FITSIO.get_comment  —  Function get_comment(hdr::FITSHeader, key_or_index::Union{String,Integer}) Get the comment based on keyword or index. source"},{"id":1912,"pagetitle":"API Reference","title":"FITSIO.set_comment!","ref":"/FITSIO/stable/api/#FITSIO.set_comment!","content":" FITSIO.set_comment!  —  Function set_comment!(hdr::FITSHeader, key_or_index::Union{String,Integer}, comment::String) Set the comment based on keyword or index. source"},{"id":1913,"pagetitle":"API Reference","title":"FITSIO.default_header","ref":"/FITSIO/stable/api/#FITSIO.default_header","content":" FITSIO.default_header  —  Function default_header(data::AbstractArray) Creates a default header for the given array with the  SIMPLE ,  BITPIX ,  NAXIS ,  NAXIS* , and  EXTEND  entries. source"},{"id":1914,"pagetitle":"API Reference","title":"Image operations","ref":"/FITSIO/stable/api/#Image-operations","content":" Image operations"},{"id":1915,"pagetitle":"API Reference","title":"Base.read","ref":"/FITSIO/stable/api/#Base.read-Tuple{ImageHDU}","content":" Base.read  —  Method read(hdu::ImageHDU)\nread(hdu::ImageHDU, range...) Read the data array or a subset thereof from disk. The first form reads the entire data array. The second form reads a slice of the array given by the specified ranges or integers. Dimensions specified by integers will be dropped in the returned array, while those specified by ranges will be retained. Note Julia follows a column-major array indexing convention, so the indices provided must account for this. In particular this means that FITS files created externally following a row-major convention (eg. using astropy) will have the sequence of axes flipped when read in using FITSIO. source"},{"id":1916,"pagetitle":"API Reference","title":"Base.read!","ref":"/FITSIO/stable/api/#Base.read!","content":" Base.read!  —  Function read!(hdu::ImageHDU, A::StridedArray)\nread!(hdu::ImageHDU, A::StridedArray, range...) Read the data or a subset thereof from disk, and save it in a pre-allocated output array  A . The first form reads the entire data from disk. The second form reads a slice of the array given by the specified ranges or integers. The array  A  needs to have the same length as the number of elements to be read in. Additionally  A  needs to be stored contiguously in memory. Note Julia follows a column-major array indexing convention, so the indices provided must account for this. In particular this means that FITS files created externally following a row-major convention (eg. using astropy) will have the sequence of the axes flipped when read in using FITSIO. source"},{"id":1917,"pagetitle":"API Reference","title":"FITSIO.fitsread","ref":"/FITSIO/stable/api/#FITSIO.fitsread","content":" FITSIO.fitsread  —  Function fitsread(filename::AbstractString[, hduindex = 1[, arrayindices...]]; extendedparser = true) Convenience function to read in an image corresponding to the HDU at index  hduindex  contained in the FITS file named  filename . If  arrayindices  are provided, only a slice of the image corresponding to the indices is read in. Functionally  fitsread(filename, hduindex, arrayindices...; extendedparser)  is equivalent to FITS(filename, \"r\"; extendedparser = extendedparser) do f\n    read(f[hduindex], arrayindices...)\nend The keyword argument  extendedparser  may be used to enable or disable the  extended filename parser . If disabled,  filename  is treated exactly as the name of the file and is not tokenized into parameters. Note Julia follows a column-major array indexing convention, so the indices provided must account for this. In particular this means that FITS files created externally following a row-major convention (eg. using astropy) will have the sequence of axes flipped when read in using FITSIO. See also:  read source"},{"id":1918,"pagetitle":"API Reference","title":"Base.write","ref":"/FITSIO/stable/api/#Base.write-Tuple{FITS, StridedArray{<:Real}}","content":" Base.write  —  Method write(f::FITS, data::StridedArray{<:Real}; header=nothing, name=nothing, ver=nothing) Add a new image HDU to FITS file  f  with contents  data . The following array element types are supported:  UInt8 ,  Int8 ,  UInt16 ,  Int16 ,  UInt32 ,  Int32 ,  Int64 ,  Float32 ,  Float64 . If a  FITSHeader  object is passed as the  header  keyword argument, the header will also be added to the new HDU. The data to be written out must be stored contiguously in memory. Unsupported element types It might be possible to write out an array with an element type other than those mentioned above by  reinterpret ing it as one that is supported. For example, to write out a  Complex  array and read it back in, we may use julia> a = rand(ComplexF64, 2)\n2-element Array{Complex{Float64},1}:\n 0.4943325325752195 + 0.2034650017475852im\n 0.2495752009567498 + 0.819163869249041im\n\n# We may write this out as Float64\njulia> FITSIO.fitswrite(\"temp.fits\", reinterpret(Float64, a))\n\n# reinterpret it back as a complex one while reading it in\njulia> reinterpret(ComplexF64, FITSIO.fitsread(\"temp.fits\"))\n2-element reinterpret(Complex{Float64}, ::Array{Float64,1}):\n 0.4943325325752195 + 0.2034650017475852im\n 0.2495752009567498 + 0.819163869249041im While this often works in practice, such a workaround is not officially supported by FITSIO, and care must be taken to ensure the correctness of data. source"},{"id":1919,"pagetitle":"API Reference","title":"Base.write","ref":"/FITSIO/stable/api/#Base.write-Tuple{ImageHDU, StridedArray{<:Real}}","content":" Base.write  —  Method write(hdu::ImageHDU, data::StridedArray{<:Real}) Write data to an existing image HDU. The data to be written out must be stored contiguously in memory. source"},{"id":1920,"pagetitle":"API Reference","title":"FITSIO.fitswrite","ref":"/FITSIO/stable/api/#FITSIO.fitswrite","content":" FITSIO.fitswrite  —  Function fitswrite(filename::AbstractString, data; extendedparser = true, kwargs...) Convenience function to write the image array  data  to a file named  filename . Functionally  fitswrite(filename, data; extendedparser, kwargs...)  is equivalent to FITS(filename, \"w\"; extendedparser = extendedparser) do f\n    write(f, data; kwargs...)\nend The keyword argument  extendedparser  may be used to enable or disable the  extended filename parser . If disabled,  filename  is treated exactly as the name of the file and is not tokenized into parameters. Warning Existing files with the same name will be overwritten. See also:  write source"},{"id":1921,"pagetitle":"API Reference","title":"Base.eltype","ref":"/FITSIO/stable/api/#Base.eltype-Tuple{ImageHDU}","content":" Base.eltype  —  Method eltype(hdu::ImageHDU) Return the element type of the image in  hdu . source"},{"id":1922,"pagetitle":"API Reference","title":"Base.ndims","ref":"/FITSIO/stable/api/#Base.ndims-Tuple{ImageHDU}","content":" Base.ndims  —  Method ndims(hdu::ImageHDU) Get number of image dimensions, without reading the image into memory. source"},{"id":1923,"pagetitle":"API Reference","title":"Base.size","ref":"/FITSIO/stable/api/#Base.size-Tuple{ImageHDU}","content":" Base.size  —  Method size(hdu::ImageHDU)\nsize(hdu::ImageHDU, i) Get image dimensions (or  i th dimension), without reading the image into memory. source"},{"id":1924,"pagetitle":"API Reference","title":"Base.length","ref":"/FITSIO/stable/api/#Base.length-Tuple{ImageHDU}","content":" Base.length  —  Method length(hdu::ImageHDU) Get total number of pixels in image (product of  size(hdu) ). source"},{"id":1925,"pagetitle":"API Reference","title":"FITSIO.copy_section","ref":"/FITSIO/stable/api/#FITSIO.copy_section","content":" FITSIO.copy_section  —  Function copy_section(hdu, dest, r...) Copy a rectangular section of an image and write it to a new FITS primary image or image extension in  FITS  object  dest . The new image HDU is appended to the end of  dest . All the keywords in the input image will be copied to the output image. The common WCS keywords will be updated if necessary to correspond to the coordinates of the section. Examples Copy the lower-left 200 x 200 pixel section of the image in  hdu  to an open file,  f copy_section(hdu, f, 1:200, 1:200) Same as above but only copy odd columns in y: copy_section(hdu, f, 1:200, 1:2:200) source"},{"id":1926,"pagetitle":"API Reference","title":"Table operations","ref":"/FITSIO/stable/api/#Table-operations","content":" Table operations"},{"id":1927,"pagetitle":"API Reference","title":"FITSIO.colnames","ref":"/FITSIO/stable/api/#FITSIO.colnames","content":" FITSIO.colnames  —  Function colnames(hdu) -> Vector{String} Return the names of columns in a table HDU. source"},{"id":1928,"pagetitle":"API Reference","title":"Base.write","ref":"/FITSIO/stable/api/#Base.write-Tuple{FITS, Dict{String}}","content":" Base.write  —  Method write(f::FITS, data::Dict;\n      hdutype=TableHDU, name=nothing, ver=nothing,\n      header=nothing, units=nothing, varcols=nothing) Create a new table extension and write data to it. If the FITS file is currently empty then a dummy primary array will be created before appending the table extension to it.  data  should be a dictionary with String keys (giving the column names) and Array values (giving data to write to each column). The following types are supported in binary tables:  UInt8 ,  Int8 ,  UInt16 ,  Int16 ,  UInt32 ,  Int32 ,  UInt64 ,  Int64 ,  Float32 ,  Float64 ,  Complex{Float32} ,  Complex{Float64} ,  String ,  Bool . Optional inputs: hdutype : Type of table extension to create. Can be either  TableHDU  (binary table) or  ASCIITableHDU  (ASCII table). name : Name of extension. ver : Version of extension (Int). header : FITSHeader instance to write to new extension. units : Dictionary mapping column name to units (as a string). varcols : An array giving the column names or column indicies to write as \"variable-length columns\". Variable length columns Variable length columns allow a column's row entries to contain arrays of different lengths. They can potentially save diskspace when the rows of a column vary greatly in length, as the column data is all written to a contiguous heap area at the end of the table. Only column data of type  Vector{String}  or types such as  Vector{Vector{UInt8}}  can be written as variable length columns. In the second case, ensure that the column data type is a  leaf type . That is, the type cannot be  Vector{Vector{T}} , which would be an array of arrays having potentially non-uniform element types (which would not be writable as a FITS table column). source"},{"id":1929,"pagetitle":"API Reference","title":"Base.write","ref":"/FITSIO/stable/api/#Base.write-Tuple{FITS, Vector{String}, Vector}","content":" Base.write  —  Method write(f::FITS, colnames, coldata;\n      hdutype=TableHDU, name=nothing, ver=nothing,\n      header=nothing, units=nothing, varcols=nothing) Same as  write(f::FITS, data::Dict; ...)  but providing column names and column data as a separate arrays. This is useful for specifying the order of the columns. Column names must be  Vector{String}  and column data must be a vector of arrays. source"},{"id":1930,"pagetitle":"API Reference","title":"Base.read","ref":"/FITSIO/stable/api/#Base.read-Tuple{TableHDU, String}","content":" Base.read  —  Method read(hdu::TableHDU, colname; case_sensitive=true) Read a column as an array from the given table HDU. The column name may contain wild card characters ( * ,  ? , or  # ). The  *  wild card character matches any sequence of characters (including zero characters) and the  ?  character matches any single character. The  #  wildcard will match any consecutive string of decimal digits (0-9). The string must match a unique column.  The optional boolean keyword  case_sensitive ,  true  by default, specifies whether the column name is to be considered case sensitive. Array order Julia arrays are column-major (like Fortran), not row-major (like C and numpy), so elements of multi-dimensional columns will be the transpose of what you get with astropy. source"},{"id":1933,"pagetitle":"The XPA package for Julia","title":"The XPA package for Julia","ref":"/XPA/stable/#The-XPA-package-for-Julia","content":" The XPA package for Julia The  XPA Messaging System  provides seamless communication between many kinds of Unix/Windows programs, including X programs, Tcl/Tk programs. It is used to control some popular astronomical tools such as  SAOImage-DS9 . The  XPA.jl  package is a  Julia  interface to the XPA Messaging System.  XPA.jl  can be used to send data or commands to XPA servers, to query data from XPA servers, or to implement an XPA server. The package uses  ccall  to directly call the routines of the compiled XPA library. SAOImageDS9.jl  is a Julia package that exploits  XPA.jl  to communicate with  SAOImage-DS9 ."},{"id":1934,"pagetitle":"The XPA package for Julia","title":"Table of contents","ref":"/XPA/stable/#Table-of-contents","content":" Table of contents Using the XPA messaging system Client operations Persistent client connection Identifying XPA servers Getting data from one or more servers Examples Sending data to one or more servers Messages Installation Installation for Julia ≥ 1.3 Installation for older Julia versions Utilities Implementing a server Create an XPA server Manage XPA requests Frequently asked questions XPA.list()  or  XPA.find()  do not find my XPA server Reference XPA client methods and types XPA server methods and types Utilities Constants Index"},{"id":1935,"pagetitle":"The XPA package for Julia","title":"Index","ref":"/XPA/stable/#Index","content":" Index XPA.CDefs XPA.FAILURE XPA.SUCCESS XPA.AccessPoint XPA.CDefs.ClipRec XPA.CDefs.InfoCb XPA.CDefs.MyFree XPA.CDefs.NSRec XPA.CDefs.ReceiveCb XPA.CDefs.SelAdd XPA.CDefs.SelDel XPA.CDefs.SelOff XPA.CDefs.SelOn XPA.CDefs.SendCb XPA.CDefs.XPAClientRec XPA.CDefs.XPACmdRec XPA.CDefs.XPACommRec XPA.CDefs.XPAInputRec XPA.Client XPA.NullBuffer XPA.ReceiveBuffer XPA.ReceiveCallback XPA.Reply XPA.SendBuffer XPA.SendCallback XPA.Server XPA.TupleOf Base.error XPA.address XPA.buffer XPA.connection XPA.find XPA.get XPA.get_data XPA.get_message XPA.get_server XPA.getconfig XPA.has_error XPA.has_errors XPA.has_message XPA.join_arguments XPA.list XPA.mainloop XPA.message XPA.peek XPA.poll XPA.preserve_state XPA.restore_state XPA.set XPA.setconfig! XPA.store! XPA.verify"},{"id":1938,"pagetitle":"Client operations","title":"Client operations","ref":"/XPA/stable/client/#Client-operations","content":" Client operations Client operations involve querying data from one or several XPA servers or sending data to one or several XPA servers."},{"id":1939,"pagetitle":"Client operations","title":"Persistent client connection","ref":"/XPA/stable/client/#Persistent-client-connection","content":" Persistent client connection To avoid reconnecting to the XPA server for each client request,  XPA.jl  maintains a per-task persistent connection to the server. The end-user should therefore not have to worry about creating persistent XPA client connections by calling  XPA.Client()  for its application. Persistent XPA client connections are automatically shutdown and related resources freed when tasks are garbage collected. The  close()  method can be applied to a persistent XPA client connection (if this is done for one of the memorized per-task connection, the connection will be automatically re-open if necessary). If needed,  XPA.connection()  yields the persistent XPA client of the calling task."},{"id":1940,"pagetitle":"Client operations","title":"Identifying XPA servers","ref":"/XPA/stable/client/#Identifying-XPA-servers","content":" Identifying XPA servers The utility  XPA.list  can be called to get a list of running XPA servers: julia> XPA.list()\n2-element Vector{XPA.AccessPoint}:\n XPA.AccessPoint(class=\"DS9\", name=\"ds9\", address=\"/tmp/.xpa/DS9_ds9-8.7b1.17760\", user=\"eric\", access=\"gs\")\n XPA.AccessPoint(class=\"DS9\", name=\"ds9\", address=\"7f000001:43881\", user=\"eric\", access=\"gs\") indicates that two XPA servers are available and that both are  SAOImage-DS9 , an astronomical tool to display images, the first one is using a Unix socket connection, the 2nd one an internet socket. The identities of XPA servers is the string  $class:$name  which can be matched by a template like  $class:* . In this case, both servers are identified by  \"DS9:ds9\"  and matched by  \"DS9:*\" , to distinguish them, their address (which is unique) must be used. Using the address is thus the recommended way to identify a unique XPA server. XPA.list  may be called with a predicate function to filter the list of servers. This function is called with each  XPA.AccessPoint  of the running XPA servers and shall return a Boolean to indicate whether the server is to be selected. For example, using the  do -block syntax: julia> apts = XPA.list() do apt\n           apt.class == \"DS9\" && startswith(apt.address, \"/\")\n       end\n1-element Vector{XPA.AccessPoint}:\n XPA.AccessPoint(class=\"DS9\", name=\"ds9-8.7b1\", address=\"/tmp/.xpa/DS9_ds9-8.7b1.17760\", user=\"eric\", access=\"gs\")\n lists the SAOImage/DS9 servers with a Unix socket connection while: julia> apts = XPA.list() do apt\n           apt.class == \"DS9\" && startswith(apt.address, r\"[0-9a-fA-F]\")\n       end\n1-element Vector{XPA.AccessPoint}:\n XPA.AccessPoint(class=\"DS9\", name=\"ds9-8.7b1\", address=\"7f000001:43881\", user=\"eric\", access=\"gs\")\n lists the SAOImage/DS9 servers with an internet socket connection. The  method  keyword may also be used to choose a specific connection type. See  XPA.list  documentation for more details and for other keywords. In order to get the address of a unique XPA server, you may call  XPA.find  with a predicate function to filter the matching servers and a selection method to keep a single one among all matching servers. For example: julia> apt = XPA.find(; select=first) do apt\n           apt.class == \"DS9\" && startswith(apt.name, \"ds9\")\n       end\nXPA.AccessPoint(class=\"DS9\", name=\"ds9-8.7b1\", address=\"/tmp/.xpa/DS9_ds9-8.7b1.17760\", user=\"eric\", access=\"gs\")\n The  select  keyword may be a function (as above) or a symbol such as  :interact  to have an interactive menu for the user to choose one of the servers if there are more than one matching servers: julia> apt = XPA.find(; select=:interact) do apt\n           apt.class == \"DS9\"\n       end\nPlease select one of:\n > (none)\n   DS9:ds9-8.7b1 [address=\"/tmp/.xpa/DS9_ds9-8.7b1.17760\", user=\"eric\"]\n   DS9:ds9-8.7b1 [address=\"7f000001:43881\", user=\"eric\"] If there are no matching servers,  XPA.find  returns  nothing  unless the  throwerrors  keyword is  true  to throw an exception if no match is found. If there are more than one matching servers and no  select  method is specified or if it is not  :interact ,  XPA.find  throws an error. The address of an  XPA.AccessPoint  instance  apt  is given by  apt.address . See the documentation of  XPA.AccessPoint  for other properties of  apt  that can be used in the filter and select functions."},{"id":1941,"pagetitle":"Client operations","title":"Getting data from one or more servers","ref":"/XPA/stable/client/#Getting-data-from-one-or-more-servers","content":" Getting data from one or more servers"},{"id":1942,"pagetitle":"Client operations","title":"Available methods","ref":"/XPA/stable/client/#Available-methods","content":" Available methods To query something from one or more XPA servers, call the  XPA.get  method: XPA.get([conn,] apt, args...) -> rep which uses the persistent client connection  conn  to retrieve data from one or more XPA access-points identified by  apt  as a result of the command build from arguments  args... . Argument  conn  is optional, if it is not specified, a per-task persistent connection is used. The XPA access-point  apt  is an instance of  XPA.AccessPoint  or a string which can be a template name, a  host:port  string or the path to a Unix socket file. The arguments  args...  are converted into a single command string where the elements of  args...  are separated by a single space. For example, to query the version number of up to 5 running SAOImage-DS9 servers: julia> rep = XPA.get(\"DS9:*\", \"version\"; nmax=5)\nXPA.Reply (2 answers):\n  1: server = \"DS9:ds9-8.7b1 7f000001:43881\", message = \"\", data = \"ds9-8.7b1 8.7b1\\n\"\n  2: server = \"DS9:ds9-8.7b1 7f000001:36785\", message = \"\", data = \"ds9-8.7b1 8.7b1\\n\"\n For best performances or to make sure to receive answers from a single server, a unique server address shall be used, not a template as above. The answer, bound to variable  rep  in the above example, to the  XPA.get  request is an instance of  XPA.Reply  which is an abstract vector of answer(s). To access the different parts of the  i -th answer, use its properties. Property  rep[i].server  yields the identifier and address of the server who sent the answer. Properties  rep[i].has_message  and  rep[i].has_error  indicate whether  rep[i]  has an associated message, respectively a normal one or an error one, which is given by  rep[i].message  (see the  Messages  section below). For example: julia> rep[1].server\n\"DS9:ds9-8.7b1 7f000001:43881\"\n\njulia> rep[1].has_message\nfalse\n\njulia> rep[1].has_error\nfalse\n\njulia> rep[1].message\n\"\"\n Usually the most interesting part of a particular answer is its data part and property  rep[i].data  is a callable object to access such data with the following syntax: rep[i].data()                  # a vector of bytes\nrep[i].data(String)            # an ASCII string\nrep[i].data(T)                 # a value of type `T`\nrep[i].data(Vector{T})         # the largest possible vector with elements of type `T`\nrep[i].data(Array{T}, dims...) # an array of element type `T` and size `dims...` For example: julia> rep[1].data(String)\n\"ds9-8.7b1 8.7b1\\n\"\n See the documentation of  XPA.Reply  for more details. To avoid checking for errors for every answer to an XPA request,  XPA.has_errors(rep)  yields whether any of the answers in  rep  has an error. Otherwise, the  XPA.get  method has a  throwerrors  keyword that can be set  true  in order to automatically throw an exception if there are any errors in the answers. The syntax  rep[]  can be used to index the  unique answer  in  rep  throwing an error if  length(rep) != 1 . If you are only interested in the data associated to a single answer, you may thus do: XPA.get(apt, args...)[].data(T, dims...) This is so common that the same result is obtained by directly specifying  T  and, optionally,  dims  as the leading arguments of a  XPA.get  call: XPA.get(T, apt, args...)\nXPA.get(T, dims, apt, args...) In this context, exactly one answer and no errors are expected from the request (as if  nmax=1  and  throwerrors=true  were specified) and  dims , if specified, must be a single integer or a tuple of integers."},{"id":1943,"pagetitle":"Client operations","title":"Examples","ref":"/XPA/stable/client/#Examples","content":" Examples The following examples assume that  apt  is the access-point or the unique address of a SAOImage-DS9 server. For instance: using XPA\napt = XPA.find(apt -> apt.class == \"DS9\"; select=:interact) To retrieve the version as a string: julia> XPA.get(String, apt, \"version\")\n\"ds9-8.7b1 8.7b1\\n\" To retrieve the  about  answer as (non-empty) lines: julia> split(XPA.get(String, apt, \"about\"), r\"\\n|\\r\\n?\"; keepempty=false)\n10-element Vector{SubString{String}}:\n \"SAOImageDS9\"\n \"Version 8.7b1\"\n \"Authors\"\n \"William Joye (Smithsonian Astrophysical Observatory)\"\n \"Eric Mandel (Smithsonian Astrophysical Observatory)\"\n \"Steve Murray (Smithsonian Astrophysical Observatory)\"\n \"Development funding\"\n \"NASA's Applied Information Systems Research Program (NASA/ETSO)\"\n \"Chandra X-ray Science Center (CXC)\"\n \"High Energy Astrophysics Science Archive Center (NASA/HEASARC)\"\n To retrieve the bits-per-pixel and the dimensions of the current image: bitpix = parse(Int, XPA.get(String, apt, \"fits bitpix\"))\ndims = map(s -> parse(Int, s), split(XPA.get(String, apt, \"fits size\"); keepempty=false))"},{"id":1944,"pagetitle":"Client operations","title":"Sending data to one or more servers","ref":"/XPA/stable/client/#Sending-data-to-one-or-more-servers","content":" Sending data to one or more servers The  XPA.set  method is called to send a command and some optional data to a server. The general syntax is: XPA.set([conn,] apt, args...; data=nothing) -> rep which sends  data  to one or more XPA access-points identified by  apt  with arguments  args... . As with  XPA.get , arguments  args...  are converted into a string with a single space to separate them and the result  rep  is an abstract vector of answer(s) stored by an instance of  XPA.Reply . The  XPA.set  method accepts the same keywords as  XPA.get  plus the  data  keyword used to specify the data to send to the server(s). The value of  data  may be  nothing  if there is no data to send (this is the default). Otherwise, the value of  data  may be an array, or an ASCII string. Arrays are sent as binary data, if the array  data  does not have contiguous elements (that is not a  dense array ), it is converted to an  Array . As an example, here is how to make SAOImage-DS9 server to quit: XPA.set(apt, \"quit\");"},{"id":1945,"pagetitle":"Client operations","title":"Messages","ref":"/XPA/stable/client/#Messages","content":" Messages If not empty, message strings associated with XPA answers are of the form: XPA$ERROR message (class:name ip:port) or XPA$MESSAGE message (class:name ip:port) depending whether an error or an informative message has been set. When a message indicates an error, the corresponding data buffers may or may not be empty, depending on the particularities of the server."},{"id":1948,"pagetitle":"Frequently asked questions","title":"Frequently asked questions","ref":"/XPA/stable/faq/#Frequently-asked-questions","content":" Frequently asked questions"},{"id":1949,"pagetitle":"Frequently asked questions","title":"XPA.list() or XPA.find() do not find my XPA server","ref":"/XPA/stable/faq/#XPA.list()-or-XPA.find()-do-not-find-my-XPA-server","content":" XPA.list()  or  XPA.find()  do not find my XPA server In principle, XPA servers are able to automatically launch an XPA name-server for their type of connection (internet or Unix socket) if none is running. If an XPA name-server is killed or stop working, XPA servers registered by this name-server have to reconnect to another name-server. In SAOImage/DS9 server, this can be done by using the menu  File > XPA > Disconnect  and then  File > XPA > Connect . If you have several SAOImage/DS9 servers, you may have to do this with each server."},{"id":1952,"pagetitle":"Installation","title":"Installation","ref":"/XPA/stable/install/#Installation","content":" Installation"},{"id":1953,"pagetitle":"Installation","title":"Installation for Julia ≥ 1.3","ref":"/XPA/stable/install/#Installation-for-Julia-1.3","content":" Installation for Julia ≥ 1.3 Since version 0.1.0 and provided you use Julia version ≥ 1.3,  XPA.jl  uses  XPA_jll  artifact to provide the XPA dynamic library so it is sufficient to just install  XPA.jl  from Julia's package manager."},{"id":1954,"pagetitle":"Installation","title":"Installation for older Julia versions","ref":"/XPA/stable/install/#Installation-for-older-Julia-versions","content":" Installation for older Julia versions To use XPA.jl package, XPA dynamic library and header files must be installed on your computer.  If this is not the case, they may be available for your operating system.  Otherwise, you'll have to build it and install it yourself. Depending on this condition, there are two possibilities described below. The source code of XPA.jl is available  here ."},{"id":1955,"pagetitle":"Installation","title":"Eays installation","ref":"/XPA/stable/install/#Eays-installation","content":" Eays installation The easiest installation is when your system provides XPA dynamic library and header files as a package.  For example, on Ubuntu, just do: sudo apt-get install xpa-tools libxpa-dev Then, to install XPA.jl package from Julia, just do: using Pkg\nPkg.add(\"XPA\")"},{"id":1956,"pagetitle":"Installation","title":"Custom installation","ref":"/XPA/stable/install/#Custom-installation","content":" Custom installation If XPA dynamic library and header files are not provided by your system, you may install it manually.  That's easy but make sure that you compile and install the shared library of XPA since this is the one that will be used by Julia.  You have to download the source archive  here , unpack it in some directory, build and install it.  For instance: cd \"$SRCDIR\"\nwget -O xpa-2.1.18.tar.gz https://github.com/ericmandel/xpa/archive/v2.1.18.tar.gz\ntar -zxvf xpa-2.1.18.tar.gz\ncd xpa-2.1.18\n./configure --prefix=\"$PREFIX\" --enable-shared\nmkdir -p \"$PREFIX/lib\" \"$PREFIX/include\" \"$PREFIX/bin\"\nmake install where  $SRCDIR  is the directory where to download the archive and extract the source while  $PREFIX  is the directory where to install XPA library, header file(s) and executables.  You may consider other configuration options (run  ./configure --help  for a list) but make sure to have  --enable-shared  for building the shared library.  As of the current version of XPA (2.1.18), the installation script does not automatically build some destination directories, hence the  mkdir -p ...  command above. In order to use XPA.jl with a custom XPA installation, you may define the environment variables  XPA_DEFS  and  XPA_LIBS  to suitable values before building XPA package.  The environment variable  XPA_DEFS  specifies the C-preprocessor flags for finding the headers  \"xpa.h\"  and  \"prsetup.h\"  while the environment variable  XPA_LIBS  specifies the linker flags for linking with the XPA dynamic library.  If you have installed XPA as explained above, do: export XPA_DEFS=\"-I$PREFIX/include\"\nexport XPA_LIBS=\"-L$PREFIX/lib -lxpa\" It may also be the case that you want to use a specific XPA dynamic library even though your system provides one.  Then define the environment variable  XPA_DEFS  as explained above and define the environment variable  XPA_DLL  with the full path to the dynamic library to use.  For instance: export XPA_DEFS=\"-I$PREFIX/include\"\nexport XPA_DLL=\"$PREFIX/lib/libxpa.so\" Note that if both  XPA_LIBS  and  XPA_DLL  are defined, the latter has precedence. These variables must be defined before launching Julia and cloning/building the XPA package.  You may also add the following lines in  ~/.julia/config/startup.jl : ENV[\"XPA_DEFS\"] = \"-I/InstallDir/include\"\nENV[\"XPA_LIBS\"] = \"-L/InstallDir/lib -lxpa\" or (depending on the situation): ENV[\"XPA_DEFS\"] = \"-I/InstallDir/include\"\nENV[\"XPA_DLL\"] = \"/InstallDir/lib/libxpa.so\" where  InstallDir  should be modified according to your specific installation."},{"id":1959,"pagetitle":"Using the XPA messaging system","title":"Using the XPA messaging system","ref":"/XPA/stable/intro/#Using-the-XPA-messaging-system","content":" Using the XPA messaging system In your Julia code/session, it is sufficient to do: import XPA or: using XPA This makes no differences as nothing is exported by the  XPA  module. This means that all methods or constants are prefixed by  XPA. ; but you may change the suffix, for instance: import XPA as xpa or in Julia version 1.5 or older: using XPA\nconst xpa = XPA The implemented methods are described in what follows, first the client side, then the server side and finally some utilities. More extensive XPA documentation can be found  here ."},{"id":1962,"pagetitle":"Reference","title":"Reference","ref":"/XPA/stable/library/#Reference","content":" Reference The following provides detailled documentation about types and methods provided by the XPA package.  This information is also available from the REPL by typing  ?  followed by the name of a method or a type."},{"id":1963,"pagetitle":"Reference","title":"XPA client methods and types","ref":"/XPA/stable/library/#XPA-client-methods-and-types","content":" XPA client methods and types"},{"id":1964,"pagetitle":"Reference","title":"XPA.Client","ref":"/XPA/stable/library/#XPA.Client","content":" XPA.Client  —  Type XPA.Client An instance of the mutable structure  XPA.Client  represents a client connection in the XPA Messaging System. source"},{"id":1965,"pagetitle":"Reference","title":"XPA.connection","ref":"/XPA/stable/library/#XPA.connection","content":" XPA.connection  —  Function XPA.connection() yields a persistent XPA client connection that is kept open for the calling task (a different connection is memorized for each Julia task). Per-task client connections are automatically open (or even re-open) and closed as needed. source"},{"id":1966,"pagetitle":"Reference","title":"XPA.get","ref":"/XPA/stable/library/#XPA.get","content":" XPA.get  —  Function XPA.get([T, [dims,]] [conn,] apt, args...; kwds...) retrieves data from one or more XPA access-points  apt  with arguments  args... . Argument  apt  is an instance of  XPA.AccessPoint , a template name, a  host:port  string, or the path to a Unix socket file. Arguments  args...  are converted into a single string with elements of  args...  separated by a single space. Optional argument  conn  is a persistent XPA client connection created by  XPA.Client ; if omitted, a per-task connection is used (see  XPA.connection ). The returned value depends on the optional arguments  T  and  dims . If neither  T  nor  dims  are specified, an instance of  XPA.Reply  is returned with all the answer(s) from the XPA server(s). If  T  and, possibly,  dims  are specified, a single answer and no errors are expected (as if  nmax=1  and  throwerrors=true ) and the data part of the answer is converted according to  T  which must be a type and  dims  which is an optional array size: With  dims  an  N -dimensional array size and  T  an array type like  Array{S}  or  Array{S,N} , the data is returned as an array of this type and size. Without  dims  and if  T  is a vector type like  Vector{S}  or  Memory{S} , the data is returned as a vector of type  T  with as many elements of type  S  that fit into the data. Without  dims  and if  T  is  String , a string interpreting the data as ASCII characters is returned. Without  dims  and for any other types  T , the  sizeof(T)  leading bytes of the data are returned as a single value of type  T . Except if  T  is  String , trailing data bytes, if any, are ignored. Keywords Keyword  nmax  specifies the maximum number of answers. Specify  nmax=-1  to use the maximum number of XPA hosts. This keyword is forced to be  1  if  T  is specified; otherwise,  nmax=1  by default. Keyword  throwerrors  specifies whether to check for errors. If this keyword is set true, an exception is thrown for the first error message encountered in the list of answers. This keyword is forced to be  true  if  T  is specified; otherwise,  throwerrors  is false by default. Keyword  mode  specifies options in the form  \"key1=value1,key2=value2\" . Keyword  users  specifies the list of possible users owning the access-point. This (temporarily) overrides the settings in environment variable  XPA_NSUSERS . By default and if the environment variable  XPA_NSUSERS  is not set, the access-point must be owned the caller (see Section  Distinguishing Users  in XPA documentation). The value is a string which may be a list of comma separated user names or  \"*\"  to access all users on a given machine. See also XPA.Client ,  XPA.get_data ,  XPA.set , and  XPA.verify . source"},{"id":1967,"pagetitle":"Reference","title":"XPA.Reply","ref":"/XPA/stable/library/#XPA.Reply","content":" XPA.Reply  —  Type XPA.Reply type of structure used to store the answer(s) of  XPA.get  and  XPA.set  requests. Assuming  A  is an instance of  XPA.Reply , it can be used as an abstract vector and  A[i]  yields the  i -th answer in  A . The syntax  A[]  yields  A[1]  if  A  has a single answer and throws otherwise. A single answer  A[i]  implements the following properties: A[i].server       # identifier of the XPA server which sent the `i`-th answer\nA[i].data(...)    # data associated with `i`-th answer (see below)\nA[i].has_message  # whether `i`-th answer contains a message\nA[i].has_error    # whether `i`-th answer has an error\nA[i].message      # message or error message associated with `i`-th answer To retrieve the data associated with a reply, the  data  property can be used as follows: A[i].data()                  # a vector of bytes\nA[i].data(String)            # a single ASCII string\nA[i].data(T)                 # a single value of type `T`\nA[i].data(Vector{T})         # the largest possible vector with elements of type `T`\nA[i].data(Array{T}, dims...) # an array of element type `T` and size `dims...` If  Base.Memory  exists  Vector{T}  can be replaced by  Memory{T} . See also XPA.get ,  XPA.set , and  XPA.has_errors . source"},{"id":1968,"pagetitle":"Reference","title":"XPA.get_data","ref":"/XPA/stable/library/#XPA.get_data","content":" XPA.get_data  —  Function XPA.get_data([T, [dims,]] rep::XPA.Reply, i=1; take=false)\nXPA.get_data([T, [dims,]] rep[i]; take=false)\nrep[i].data([T, [dims,]]; take=false) yields the data associated with the  i -th answer in XPA reply  rep . The returned value depends on the optional leading arguments  T  and  dims : If neither  T  nor  dims  are specified, the data is returned as a vector of bytes ( UInt8 ). With  dims  an  N -dimensional array size and  T  an array type like  Array{S}  or  Array{S,N} , the data is returned as an array of this type and size. Without  dims  and if  T  is a vector type like  Vector{S}  or  Memory{S} , the data is returned as a vector of type  T  with as many elements of type  S  that fit into the data. Without  dims  and if  T  is  String , a string interpreting the data as ASCII characters is returned. Without  dims  and for any other types  T , the  sizeof(T)  leading bytes of the data are returned as a single value of type  T . Except if  T  is  String , trailing data bytes, if any, are ignored. The  take  keyword specifies whether the returned result may steal the internal data buffer in  rep[i]  thus saving some memory and copy but preventing other retrieval of the data by another call to  XPA.get_data . This keyword is ignored if the result cannot directly use the internal buffer. By default,  take=false . In any cases, the type of the result is predictable, so there should be no type instability issue. Note In the future  XPA.get_data  will be deprecated;  rep[i].data(...)  is the recommended syntax. See also XPA.get ,  XPA.get_message , and  XPA.get_server . source"},{"id":1969,"pagetitle":"Reference","title":"XPA.get_server","ref":"/XPA/stable/library/#XPA.get_server","content":" XPA.get_server  —  Function XPA.get_server(rep::XPA.Reply, i=1)\nXPA.get_server(rep[i])\nrep[i].server yields a string identifying the server who provided the  i -th answer in XPA reply  rep . Note In the future  XPA.get_server  will be deprecated;  rep[i].server  is the recommended syntax. See also XPA.get ,  XPA.has_message ,  XPA.has_error ,  XPA.get_data  and  XPA.get_message . source"},{"id":1970,"pagetitle":"Reference","title":"XPA.get_message","ref":"/XPA/stable/library/#XPA.get_message","content":" XPA.get_message  —  Function XPA.get_message(rep::XPA.Reply, i=1)\nXPA.get_message(rep[i])\nrep[i].message yields the message associated with the  i -th answer in XPA reply  rep . An empty string is returned if there is no message. Note In the future  XPA.get_message  will be deprecated;  rep[i].message  is the recommended syntax. See also XPA.get ,  XPA.has_message ,  XPA.has_error ,  XPA.get_data  and  XPA.get_server . source"},{"id":1971,"pagetitle":"Reference","title":"XPA.has_error","ref":"/XPA/stable/library/#XPA.has_error","content":" XPA.has_error  —  Function XPA.has_error(rep::XPA.Reply, i=1)\nXPA.has_error(rep[i])\nrep[i].has_error yields whether  i -th answer in XPA reply  rep  has an error whose message is given by  rep[i].message . Note In the future  XPA.has_error  will be deprecated;  rep[i].has_error  is the recommended syntax. See also XPA.get ,  XPA.get_message ,  XPA.has_message ,  XPA.get_data , and  XPA.get_server , source"},{"id":1972,"pagetitle":"Reference","title":"XPA.has_errors","ref":"/XPA/stable/library/#XPA.has_errors","content":" XPA.has_errors  —  Function XPA.has_errors(rep::Reply) -> Bool yields whether answer  rep  contains any error messages. See also XPA.get ,  XPA.has_error , and  XPA.get_message . source"},{"id":1973,"pagetitle":"Reference","title":"XPA.has_message","ref":"/XPA/stable/library/#XPA.has_message","content":" XPA.has_message  —  Function XPA.has_message(rep::XPA.Reply, i=1)\nXPA.has_message(rep[i])\nrep[i].has_message yields whether  i -th answer in XPA reply  rep  has an associated message that is given by  rep[i].message . Note In the future  XPA.has_message  will be deprecated;  rep[i].has_message  is the recommended syntax. See also XPA.get ,  XPA.get_message ,  XPA.has_error ,  XPA.get_data , and  XPA.get_server , source"},{"id":1974,"pagetitle":"Reference","title":"XPA.join_arguments","ref":"/XPA/stable/library/#XPA.join_arguments","content":" XPA.join_arguments  —  Function XPA.join_arguments(args) -> str::String joins a tuple of arguments into a single string where arguments are separated by a single space. It is implemented so as to be faster than  join(args, \" \")  when  args  has less than 2 arguments. It is intended to build XPA command string from arguments. source"},{"id":1975,"pagetitle":"Reference","title":"XPA.verify","ref":"/XPA/stable/library/#XPA.verify","content":" XPA.verify  —  Function XPA.verify(rep::Reply [, i]; throwerrors::Bool=false) -> Bool verifies whether answer(s) in the result  rep  from an  XPA.get  or  XPA.set  request has no errors. If index  i  is specified only that specific answer is considered; otherwise, all answers are verified. If keyword  throwerrors  is true, an exception is thrown for the first error found if any. source"},{"id":1976,"pagetitle":"Reference","title":"XPA.set","ref":"/XPA/stable/library/#XPA.set","content":" XPA.set  —  Function XPA.set([conn,] apt, args...; data=nothing, kwds...) -> rep sends  data  to one or more XPA access-points identified by  apt  with arguments  args...  (automatically converted into a single string where the arguments are separated by a single space). The result is an instance of  XPA.Reply . Optional argument  conn  is a persistent XPA client connection (created by  XPA.Client ); if omitted, a per-task connection is used (see  XPA.connection ). Keywords data  specifies the data to send, may be  nothing , an array, or a string. nmax  specifies the maximum number of recipients,  nmax=1  by default. Specify  nmax=-1  to use the maximum possible number of XPA hosts. mode  specifies options in the form  \"key1=value1,key2=value2\" . throwerrors  specifies whether to check for errors. If this keyword is set  true , an exception is thrown for the first error message encountered in the list of answers. By default,  throwerrors  is false. users  specifies the list of possible users owning the access-point. This (temporarily) overrides the settings in environment variable  XPA_NSUSERS . By default and if the environment variable  XPA_NSUSERS  is not set, the access-point must be owned by the caller (see Section  Distinguishing Users  in XPA documentation). The value is a string which may be a list of comma separated user names or  \"*\"  to access all users on a given machine. See also XPA.Client ,  XPA.get  and  XPA.verify . source"},{"id":1977,"pagetitle":"Reference","title":"XPA.buffer","ref":"/XPA/stable/library/#XPA.buffer","content":" XPA.buffer  —  Function buf = XPA.buffer(data) yields an object  buf  representing the contents of  data  and which can be used as an argument to  ccall . Argument  data  can be  nothing , an array, or a string. If  data  is a dense array,  buf  is  data . If  data  is another type of array,  buf  is  data  converted to an  Array . If  data  is an ASCII string,  buf  is copy of  data  in a temporary byte buffer. If  data  is  nothing ,  XPA.NullBuffer()  is returned. Standard methods like  pointer  or  sizeof  can be applied to  buf  to retrieve the address and the size (in bytes) of the data and  Base.unsafe_convert(Ptr{Cvoid}, buf)  can also be used. See also XPA.set . source"},{"id":1978,"pagetitle":"Reference","title":"XPA server methods and types","ref":"/XPA/stable/library/#XPA-server-methods-and-types","content":" XPA server methods and types"},{"id":1979,"pagetitle":"Reference","title":"XPA.Server","ref":"/XPA/stable/library/#XPA.Server","content":" XPA.Server  —  Type XPA.Server An instance of the mutable structure  XPA.Server  represents a server connection in the XPA Messaging System. source"},{"id":1980,"pagetitle":"Reference","title":"XPA.SendCallback","ref":"/XPA/stable/library/#XPA.SendCallback","content":" XPA.SendCallback  —  Type XPA.SendCallback <: XPA.Callback An instance of the  XPA.SendCallback  structure represents a callback called to serve an  XPA.get  request. source"},{"id":1981,"pagetitle":"Reference","title":"XPA.store!","ref":"/XPA/stable/library/#XPA.store!","content":" XPA.store!  —  Function XPA.store!(buf, data)\nXPA.store!(buf, ptr, len) store into the send buffer  buf  a dynamically allocated copy of the contents of  data  or of the  len  bytes at address  ptr . Warning This method is meant to be used in a  send  callback to store the result of an  XPA.get  request processed by an XPA server. Memory leaks are expected if used in another context. See also XPA.Server ,  XPA.SendCallback , and  XPA.get . source"},{"id":1982,"pagetitle":"Reference","title":"XPA.ReceiveCallback","ref":"/XPA/stable/library/#XPA.ReceiveCallback","content":" XPA.ReceiveCallback  —  Type XPA.ReceiveCallback <: XPA.Callback An instance of the  XPA.ReceiveCallback  structure represents a callback called to serve an  XPA.set  request. source"},{"id":1983,"pagetitle":"Reference","title":"XPA.peek","ref":"/XPA/stable/library/#XPA.peek","content":" XPA.peek  —  Function XPA.peek(T, buf, i=1) -> val yields the  i -th binary value of type  T  stored into receive buffer  buf . Bounds checking is performed unless  @inbounds  is active. Another usage of the  XPA.peek  method is to  convert  the contents of the receive buffer into an array: XPA.peek(Vector{T}, [len,] buf) -> vec\nXPA.peek(Array{T[,N]}, (dim1, ..., dimN), buf) -> arr yield a Julia vector  vec  or array  arr  whose elements are of type  T  and dimensions are  len  or  (dim1, ..., dimN) . For a vector, if the length is unspecified, the vector of maximal length that fits in the buffer is returned. If keyword  temporary  is true, then  unsafe_wrap  is called (with option  own=false ) to wrap the buffer contents into a Julia array whose life-time cannot exceeds that of the callback. Otherwise, a copy of the buffer contents is returned. See also XPA.ReceiveCallback . source"},{"id":1984,"pagetitle":"Reference","title":"Base.error","ref":"/XPA/stable/library/#Base.error-Tuple{XPA.Server, AbstractString}","content":" Base.error  —  Method error(srv, msg) -> XPA.FAILURE Communicates error message  msg  to the client when serving a request by XPA server  srv . This method shall only be used by the send/receive callbacks of an XPA server. See also XPA.Server ,  XPA.message ,  XPA.SendCallback , and  XPA.ReceiveCallback . source"},{"id":1985,"pagetitle":"Reference","title":"XPA.poll","ref":"/XPA/stable/library/#XPA.poll","content":" XPA.poll  —  Function XPA.poll(sec, maxreq) polls for XPA events. This method is meant to implement a polling event loop which checks for and processes XPA requests without blocking. Argument  sec  specifies a timeout in seconds (rounded to millisecond precision). If  sec  is positive, the method blocks no longer than this amount of time. If  sec  is strictly negative, the routine blocks until the occurrence of an event to be processed. Argument  maxreq  specifies how many requests will be processed. If  maxreq < 0 , then no events are processed, but instead, the returned value indicates the number of events that are pending. If  maxreq == 0 , then all currently pending requests will be processed. Otherwise, up to  maxreq  requests will be processed. The most usual values for  maxreq  are  0  to process all requests and  1  to process one request. The following example implements a polling loop which has no noticeable impact on the consumption of CPU when no requests are emitted to the server: const __running = Ref{Bool}(false)\n\nfunction run()\n    global __running\n    __running[] = true\n    while __running[]\n        XPA.poll(-1, 1)\n    end\nend Here the global variable  __running  is a reference to a boolean whose value indicates whether to continue to run the XPA server(s) created by the process. The idea is to pass the reference to the callbacks of the server (as their client data for instance) and let the callbacks stop the loop by setting the contents of the reference to  false . Another possibility is to use  XPA.mainloop  (which to see). To let Julia performs other tasks, the polling method may be repeatedly called by a Julia timer. The following example does this. Calling  resume  starts polling for XPA events immediately and then every 100ms. Calling  suspend  suspends the processing of XPA events. const __timer = Ref{Timer}()\n\nispolling() = (isdefined(__timer, 1) && isopen(__timer[]))\n\nresume() =\n    if ! ispolling()\n        __timer[] = Timer((tm) -> XPA.poll(0, 0), 0.0, interval=0.1)\n    end\n\nsuspend() =\n    ispolling() && close(__timer[]) See also XPA.Server  and  XPA.mainloop . source"},{"id":1986,"pagetitle":"Reference","title":"XPA.message","ref":"/XPA/stable/library/#XPA.message","content":" XPA.message  —  Function XPA.message(srv, msg) sets a specific acknowledgment message back to the client. Argument  srv  is the XPA server serving the client and  msg  is the acknowledgment message. This method shall only be used by the receive callback of an XPA server. See also XPA.Server ,  XPA.error , and  XPA.ReceiveCallback . source"},{"id":1987,"pagetitle":"Reference","title":"XPA.mainloop","ref":"/XPA/stable/library/#XPA.mainloop","content":" XPA.mainloop  —  Function XPA.mainloop() runs XPA event loop which handles the requests sent to the server(s) created by this process. The loop runs until all servers created by this process have been closed. In the following example, the receive callback function close the server when it receives a  \"quit\"  command: function rproc(::Nothing, srv::XPA.Server, params::String,\n               buf::Ptr{UInt8}, len::Integer)\n    status = XPA.SUCCESS\n    if params == \"quit\"\n        close(srv)\n    elseif params == ...\n        ...\n    end\n    return status\nend See also XPA.Server  and  XPA.mainloop . source"},{"id":1988,"pagetitle":"Reference","title":"Utilities","ref":"/XPA/stable/library/#Utilities","content":" Utilities"},{"id":1989,"pagetitle":"Reference","title":"XPA.address","ref":"/XPA/stable/library/#XPA.address","content":" XPA.address  —  Function XPA.address(apt) -> addr yields the address of XPA access-point  apt  which can be: an instance of  XPA.AccessPoint , a string with a valid XPA server address or a server  class:name  identifier. In the latter case,  XPA.find  is called to find a matching server which is much longer. source"},{"id":1990,"pagetitle":"Reference","title":"XPA.list","ref":"/XPA/stable/library/#XPA.list","content":" XPA.list  —  Function XPA.list(f = Returns(true); kwds...) yields a list of available XPA access-points. The result is a vector of  XPA.AccessPoint  instances. Optional argument  f  is a predicate function to filter which access-points to keep. For example, to only keep the access-points owned by the user: apts = XPA.list() do apt\n    apt.user == ENV[\"USER\"]\nend Keywords method  is  nothing  (the default) or one of  inet ,  unix  (or  local ), or  localhost  as a symbol or a string to require a specific connection method. on_error  is a symbol indicating what to do in case of unexpected reply by the XPA name server; it can be  :throw  to throw an exception,  :warn  (the default) to print a warning, anything else to silently ignore the error. xpaget  is to specify the method to contact the XPA name server; it can be a string with the path to the  xpaget  executable or a function behaving like  XPA.get . Using  XPA.get  has fewer possibilities so, by default, the  xpaget  executable provided by  XPA_jll  artifact is used. See also XPA.find  to select a single access-point. XPA.AccessPoint  for the properties of access-points that can be used in the predicate function  f . source"},{"id":1991,"pagetitle":"Reference","title":"XPA.AccessPoint","ref":"/XPA/stable/library/#XPA.AccessPoint","content":" XPA.AccessPoint  —  Type apt = XPA.AccessPoint(str)\napt = XPA.AccessPoint(class, name, address, user, access)\napt = XPA.AccessPoint(; class=\"\", name=\"\", address=\"\", user=\"\", access=0) builds a structure representing an XPA server for a client. If single argument is a string  str , it is parsed assuming the same format as the output of  xpans . Otherwise the arguments/keywords reflect the properties of the object: apt.class   # access-point class\napt.name    # access-point name\napt.address # server address (host:port for inet socket, path for unix socket)\napt.user    # access-point owner\napt.access  # allowed access At least the  address  shall be provided. All properties are strings except  access  which is an unsigned integer whose bits are set as follows:  !iszero(apt.access & 1) # holds if `set` command allowed\n !iszero(apt.access & 2) # holds if `get` command allowed\n !iszero(apt.access & 4) # holds if `info` command allowed The constructors also accept  access  as a string composed of characters  'g' ,  's' , and  'i'  respectively indicating whether  get ,  set , and  info  commands are implemented by the server. Method  isopen(apt)  yields whether  address  is not an empty string. See also XPA.list  to retrieve a vector of existing XPA servers possibly filtered by some provided function. XPA.find  to obtain the access-point of a single XPA server. source"},{"id":1992,"pagetitle":"Reference","title":"XPA.find","ref":"/XPA/stable/library/#XPA.find","content":" XPA.find  —  Function XPA.find(f = Returns(true); kwds...) yields the access-point of the XPA server matching the requirements implemented by the predicate function  f  and keywords  kwds... . In principle, the result is either a single instance of  XPA.AccessPoint  or  nothing  if no matching server is found (this type assertion may only be invalidated by the function specified via the  select  keyword). Keywords In addition to the keywords accepted by  XPA.list , the following keyword(s) are available: select  specifies a strategy to apply if more than one access-point is found.  select  can be a function (like  first  or  last  to keep the first or last entry), the symbolic name  :interact  to ask the user to make the selection via a REPL menu, or anything else to throw an exception. The default is  :throw . If  select  is a function, it is called with a vector of 2 or more matching instances of  XPA.AccessPoint  and the result of  select  is returned by  XPA.find . throwerrors  specifies whether to throw an error if no matching servers are found instead of returning  nothing . Example apt = XPA.find(; interact = isinteractive(), method = :local) See also XPA.list  which is called to retrieve a list of access-points with the predicate function  f . XPA.AccessPoint  for the properties of access-points that can be used in the predicate function  f . source"},{"id":1993,"pagetitle":"Reference","title":"XPA.getconfig","ref":"/XPA/stable/library/#XPA.getconfig","content":" XPA.getconfig  —  Function XPA.getconfig(key) -> val yields the value associated with configuration parameter  key  (a string or a symbol). The following parameters are available (see XPA doc. for more information): Key Name Default Value \"XPA_MAXHOSTS\" 100 \"XPA_SHORT_TIMEOUT\" 15 \"XPA_LONG_TIMEOUT\" 180 \"XPA_CONNECT_TIMEOUT\" 10 \"XPA_TMPDIR\" \"/tmp/.xpa\" \"XPA_VERBOSITY\" true \"XPA_IOCALLSXPA\" false Also see  XPA.setconfig! . source"},{"id":1994,"pagetitle":"Reference","title":"XPA.setconfig!","ref":"/XPA/stable/library/#XPA.setconfig!","content":" XPA.setconfig!  —  Function XPA.setconfig!(key, val) -> oldval set the value associated with configuration parameter  key  to be  val . The previous value is returned. Also see  XPA.getconfig . source"},{"id":1995,"pagetitle":"Reference","title":"XPA.preserve_state","ref":"/XPA/stable/library/#XPA.preserve_state","content":" XPA.preserve_state  —  Function s = XPA.preserve_state(dict, key[, val]) Yield an object that can be used to restore the state of dictionary  dict  for entry  key  with  XPA.restore_state . For improved type-stability, optional argument  val  may be specified with a substitute value of the same type as those stored in  dict  if  key  is not in  dict . The call: XPA.preserve_state(f::Function, dict, key[, val]) is equivalent to: let s = XPA.preserve_state(dict, key[, val])\n    try\n        f()\n    finally\n        XPA.restore_state(s)\n    end\nend which is suitable for the  do -block syntax. source"},{"id":1996,"pagetitle":"Reference","title":"XPA.restore_state","ref":"/XPA/stable/library/#XPA.restore_state","content":" XPA.restore_state  —  Function XPA.restore_state(s) Restore the state saved in  s  by  XPA.preserve_state . source"},{"id":1997,"pagetitle":"Reference","title":"Constants","ref":"/XPA/stable/library/#Constants","content":" Constants"},{"id":1998,"pagetitle":"Reference","title":"XPA.SUCCESS","ref":"/XPA/stable/library/#XPA.SUCCESS","content":" XPA.SUCCESS  —  Constant XPA.SUCCESS  and  XPA.FAILURE  are the possible values returned by the callbacks of an XPA server. source"},{"id":1999,"pagetitle":"Reference","title":"XPA.FAILURE","ref":"/XPA/stable/library/#XPA.FAILURE","content":" XPA.FAILURE  —  Constant XPA.SUCCESS  and  XPA.FAILURE  are the possible values returned by the callbacks of an XPA server. source"},{"id":2000,"pagetitle":"Reference","title":"Index","ref":"/XPA/stable/library/#Index","content":" Index XPA.FAILURE XPA.SUCCESS XPA.AccessPoint XPA.Client XPA.ReceiveCallback XPA.Reply XPA.SendCallback XPA.Server Base.error XPA.address XPA.buffer XPA.connection XPA.find XPA.get XPA.get_data XPA.get_message XPA.get_server XPA.getconfig XPA.has_error XPA.has_errors XPA.has_message XPA.join_arguments XPA.list XPA.mainloop XPA.message XPA.peek XPA.poll XPA.preserve_state XPA.restore_state XPA.set XPA.setconfig! XPA.store! XPA.verify"},{"id":2003,"pagetitle":"Utilities","title":"Utilities","ref":"/XPA/stable/misc/#Utilities","content":" Utilities The method: XPA.list([xpa]) -> arr returns a list of the existing XPA access points as an array of structured elements of type  XPA.AccessPoint  such that: arr[i].class    # class of the access point\narr[i].name     # name of the access point\narr[i].address  # internet socket address or path to Unix socket file\narr[i].user     # user name of access point owner\narr[i].access   # allowed access (g=xpaget, s=xpaset, i=xpainfo) all fields but  access  are strings, the  addr  field is the name of the socket used for the connection (either  host:port  for internet socket, or a file path for local unix socket),  access  is a combination of the bits  XPA.GET ,  XPA.SET  and/or  XPA.INFO  depending whether  XPA.get() ,  XPA.set()  and/or  XPA.info()  access are granted. Note that  XPA.info()  is not yet implemented. XPA messaging system can be configured via environment variables. The methods  XPA.getconfig  and  XPA.setconfig!  provides means to get or set XPA settings: XPA.getconfig(key) -> val yields the current value of the XPA parameter  key  which is one of: \"XPA_MAXHOSTS\"\n\"XPA_SHORT_TIMEOUT\"\n\"XPA_LONG_TIMEOUT\"\n\"XPA_CONNECT_TIMEOUT\"\n\"XPA_TMPDIR\"\n\"XPA_VERBOSITY\"\n\"XPA_IOCALLSXPA\" The key may be a symbol or a string, the value of a parameter may be a boolean, an integer or a string. To set an XPA parameter, call the method: XPA.setconfig!(key, val) -> old which returns the previous value of the parameter."},{"id":2006,"pagetitle":"Private methods","title":"Private methods","ref":"/XPA/stable/private/#Private-methods","content":" Private methods This page documents the internal methods for  XPA.jl  developers. Since these are not part of the public API, the page is hidden from the site navigation. Warning The functions documented here are internal to  XPA.jl  and should not be considered as being part of the stable/public API."},{"id":2007,"pagetitle":"Private methods","title":"Types","ref":"/XPA/stable/private/#Types","content":" Types"},{"id":2008,"pagetitle":"Private methods","title":"XPA.SendBuffer","ref":"/XPA/stable/private/#XPA.SendBuffer","content":" XPA.SendBuffer  —  Type XPA.SendBuffer An instance of the  XPA.SendBuffer  structure is provided to send callbacks to record the addresses where to store the address and size of the data associated to the answer of an  XPA.get  request. A send callback shall use  XPA.store!  to set the buffer contents. See also XPA.store! ,  XPA.get ,  XPA.Server  and  XPA.SendCallback . source"},{"id":2009,"pagetitle":"Private methods","title":"XPA.ReceiveBuffer","ref":"/XPA/stable/private/#XPA.ReceiveBuffer","content":" XPA.ReceiveBuffer  —  Type An instance of the  XPA.ReceiveBuffer  structure is provided to receive callbacks to record the address and the size of the data sent by an  XPA.set  request. Methods  pointer(buf)  and  sizeof(buf)  can be used to query the address and the number of bytes of the buffer  buf . See also XPA.get ,  XPA.Server , and  XPA.ReceiveCallback . source"},{"id":2010,"pagetitle":"Private methods","title":"XPA.NullBuffer","ref":"/XPA/stable/private/#XPA.NullBuffer","content":" XPA.NullBuffer  —  Type XPA.NullBuffer singleton type representing an empty buffer when sending data to a server. Its length is  0  byte and its address is  Ptr{Cvoid}(0) . source"},{"id":2011,"pagetitle":"Private methods","title":"XPA.TupleOf","ref":"/XPA/stable/private/#XPA.TupleOf","content":" XPA.TupleOf  —  Type XPA.TupleOf{T}  represents a tuple of any number of elements of type  T , it is an alias for  Tuple{Vararg{T}} source"},{"id":2012,"pagetitle":"Private methods","title":"XPA.CDefs module","ref":"/XPA/stable/private/#XPA.CDefs-module","content":" XPA.CDefs  module"},{"id":2013,"pagetitle":"Private methods","title":"XPA.CDefs","ref":"/XPA/stable/private/#XPA.CDefs","content":" XPA.CDefs  —  Module Module  XPA.CDefs  provides Julia equivalents to constants and structures defined in C header  xpa.h . These  private  definitions are put in a sub-module to make them not directly accessible. source"},{"id":2014,"pagetitle":"Private methods","title":"XPA.CDefs.SelOn","ref":"/XPA/stable/private/#XPA.CDefs.SelOn","content":" XPA.CDefs.SelOn  —  Type abstract type SelOn Wrapper around XPA's  SelOn  type: typedef void (*SelOn)(void *client_data); source"},{"id":2015,"pagetitle":"Private methods","title":"XPA.CDefs.SelOff","ref":"/XPA/stable/private/#XPA.CDefs.SelOff","content":" XPA.CDefs.SelOff  —  Type abstract type SelOff Wrapper around XPA's  SelOff  type: typedef void (*SelOff)(void *client_data); source"},{"id":2016,"pagetitle":"Private methods","title":"XPA.CDefs.SelAdd","ref":"/XPA/stable/private/#XPA.CDefs.SelAdd","content":" XPA.CDefs.SelAdd  —  Type abstract type SelAdd Wrapper around XPA's  SelAdd  type: typedef void *(*SelAdd)(void *client_data, int fd); source"},{"id":2017,"pagetitle":"Private methods","title":"XPA.CDefs.SelDel","ref":"/XPA/stable/private/#XPA.CDefs.SelDel","content":" XPA.CDefs.SelDel  —  Type abstract type SelDel Wrapper around XPA's  SelDel  type: typedef void (*SelDel)(void *client_data); source"},{"id":2018,"pagetitle":"Private methods","title":"XPA.CDefs.SendCb","ref":"/XPA/stable/private/#XPA.CDefs.SendCb","content":" XPA.CDefs.SendCb  —  Type SendCb Wrapper around XPA's  SendCb  type: typedef int (*SendCb)(void *client_data, void *call_data, char *paramlist,\n                      char **buf, size_t *len); source"},{"id":2019,"pagetitle":"Private methods","title":"XPA.CDefs.ReceiveCb","ref":"/XPA/stable/private/#XPA.CDefs.ReceiveCb","content":" XPA.CDefs.ReceiveCb  —  Type ReceiveCb Wrapper around XPA's  ReceiveCb  type: typedef int (*ReceiveCb)(void *client_data, void *call_data,\n                         char *paramlist, char *buf, size_t len); source"},{"id":2020,"pagetitle":"Private methods","title":"XPA.CDefs.MyFree","ref":"/XPA/stable/private/#XPA.CDefs.MyFree","content":" XPA.CDefs.MyFree  —  Type MyFree Wrapper around XPA's  MyFree  type: typedef void (*MyFree)(void *buf); source"},{"id":2021,"pagetitle":"Private methods","title":"XPA.CDefs.InfoCb","ref":"/XPA/stable/private/#XPA.CDefs.InfoCb","content":" XPA.CDefs.InfoCb  —  Type InfoCb Wrapper around XPA's  InfoCb  type: typedef int (*InfoCb)(void *client_data, void *call_data, char *paramlist); source"},{"id":2022,"pagetitle":"Private methods","title":"XPA.CDefs.XPACommRec","ref":"/XPA/stable/private/#XPA.CDefs.XPACommRec","content":" XPA.CDefs.XPACommRec  —  Type XPACommRec XPA communication structure for each connection. source"},{"id":2023,"pagetitle":"Private methods","title":"XPA.CDefs.NSRec","ref":"/XPA/stable/private/#XPA.CDefs.NSRec","content":" XPA.CDefs.NSRec  —  Type abstract type NSRec Opaque structure for  struct nsrec . source"},{"id":2024,"pagetitle":"Private methods","title":"XPA.CDefs.ClipRec","ref":"/XPA/stable/private/#XPA.CDefs.ClipRec","content":" XPA.CDefs.ClipRec  —  Type abstract type ClipRec Opaque structure for  struct cliprec . source"},{"id":2025,"pagetitle":"Private methods","title":"XPA.CDefs.XPAInputRec","ref":"/XPA/stable/private/#XPA.CDefs.XPAInputRec","content":" XPA.CDefs.XPAInputRec  —  Type abstract type XPAInputRec Opaque structure for  struct xpainputrec . source"},{"id":2026,"pagetitle":"Private methods","title":"XPA.CDefs.XPAClientRec","ref":"/XPA/stable/private/#XPA.CDefs.XPAClientRec","content":" XPA.CDefs.XPAClientRec  —  Type abstract type XPAClientRec Opaque structure for  struct xpaclientrec . source"},{"id":2027,"pagetitle":"Private methods","title":"XPA.CDefs.XPACmdRec","ref":"/XPA/stable/private/#XPA.CDefs.XPACmdRec","content":" XPA.CDefs.XPACmdRec  —  Type abstract type XPACmdRec Opaque structure for  struct xpacmdrec . source"},{"id":2030,"pagetitle":"Implementing a server","title":"Implementing a server","ref":"/XPA/stable/server/#Implementing-a-server","content":" Implementing a server"},{"id":2031,"pagetitle":"Implementing a server","title":"Create an XPA server","ref":"/XPA/stable/server/#Create-an-XPA-server","content":" Create an XPA server To create a new XPA server, call the  XPA.Server  method: server = XPA.Server(class, name, help, send, recv) where  class ,  name  and  help  are strings while  send  and  recv  are callbacks created by the  XPA.SendCallback  and  XPA.ReceiveCallback  methods: send = XPA.SendCallback(sendfunc, senddata)\nrecv = XPA.ReceiveCallback(recvfunc, recvdata) where  sendfunc  and  recvfunc  are the Julia methods to call while  senddata  and  recvdata  are any data needed by the callback other than what is specified by the client request (if omitted,  nothing  is assumed).  The callbacks have the following forms: function sendfunc(senddata, xpa::Server, params::String,\n                  buf::Ptr{Ptr{UInt8}}, len::Ptr{Csize_t})\n    ...\n    return XPA.SUCCESS\nend The callbacks must return an integer status (of type  Cint ): either  XPA.SUCCESS  or  XPA.FAILURE .  The methods  XPA.seterror()  and  XPA.setmessage()  can be used to specify a message accompanying the result. XPA.store!(...)\nXPA.get_send_mode(xpa)\nXPA.get_recv_mode(xpa)\nXPA.get_name(xpa)\nXPA.get_class(xpa)\nXPA.get_method(xpa)\nXPA.get_sendian(xpa)\nXPA.get_cmdfd(xpa)\nXPA.get_datafd(xpa)\nXPA.get_ack(xpa)\nXPA.get_status(xpa)\nXPA.get_cendian(xpa)"},{"id":2032,"pagetitle":"Implementing a server","title":"Manage XPA requests","ref":"/XPA/stable/server/#Manage-XPA-requests","content":" Manage XPA requests XPA.poll(msec, maxreq) or XPA.mainloop()"},{"id":2035,"pagetitle":"Home","title":"Home","ref":"/Astroalign/stable/#Home","content":" Home Align astronomical images of point sources. Based on the  astroalign  Python package. Credit:  Beroiz, M., Cabral, J. B., & Sanchez, B. (2020) Warning This package is still in the experimental stage. If you notice an issue, please feel free to  let us know !"},{"id":2036,"pagetitle":"Home","title":"Installation","ref":"/Astroalign/stable/#Installation","content":" Installation pkg> add Astroalign"},{"id":2037,"pagetitle":"Home","title":"Getting Started","ref":"/Astroalign/stable/#Getting-Started","content":" Getting Started The following will align  img_from  onto  img_to : using Astroalign\n\nimg_aligned, params = align_frame(img_to, img_from) Info See the accompanying  Pluto.jl notebook  for more on supported keywords and additional analysis."},{"id":2038,"pagetitle":"Home","title":"Contributing","ref":"/Astroalign/stable/#Contributing","content":" Contributing Issues  and  pull requests  welcome."},{"id":2039,"pagetitle":"Home","title":"API / Reference","ref":"/Astroalign/stable/#API-/-Reference","content":" API / Reference"},{"id":2040,"pagetitle":"Home","title":"Astroalign.align_frame","ref":"/Astroalign/stable/#Astroalign.align_frame","content":" Astroalign.align_frame  —  Function function align_frame(img_to, img_from;\n    [box_size],\n    [ap_radius],\n    [f],\n    [min_fwhm],\n    [nsigma],\n) Align  img_from  onto  img_to . See below for keyword arguments currently available to control this process. box_size : The size of the grid cells (in pixels) used to extract candidate point sources to use for alignment. Defaults to a tenth of the greatest common denominator of the dimensions of  img_to . See  Photometry.jl > Source Detection Algorithms  for more. ap_radius : The radius of the apertures (in pixel) to place around each point source. Defaults to 60% of  first(box_size) . See  Photometry.jl > Aperture Photometry  for more. f : The function to compute within each aperture. Defaults to a 2D Gaussian fitted to the aperture center. See the  Source characterization  section of the accompanying Pluto.jl notebook for more. min_fwhm : The minimum FWHM (in pixels) that an extracted point source must have to be considered as a control point. Defaults to a fifth of the width of the first image. See  PSFModels.jl > Fitting data  for more. nsigma : The number of standard deviations above the estimated background that a source must be to be considered as a control point. Defaults to 1. See  Photometry.jl > Source Detection Algorithms  for more. source"},{"id":2041,"pagetitle":"Home","title":"Astroalign.get_sources","ref":"/Astroalign/stable/#Astroalign.get_sources","content":" Astroalign.get_sources  —  Function get_sources(img; box_size = nothing, nsigma = 1) Extract candidate sources in  img  according to  Photometry.Detection.extract_sources . By default,  img  is first sigma clipped and then background subtracted before the candidate sources are extracted.  box_size  is passed to  Photometry.Background.estimate_background , and  nsigma  is passed to  Photometry.Detection.extract_sources . See the  Photometry.jl  documentation for more. TODO: Pass more options to clipping, background estimating, and extraction methods in  Photometry.jl . source"},{"id":2042,"pagetitle":"Home","title":"Astroalign.find_nearest","ref":"/Astroalign/stable/#Astroalign.find_nearest","content":" Astroalign.find_nearest  —  Function find_nearest(C_to, ℳ_to, C_from, ℳ_from) Return the closes pair of three points between the  from  and  to  frames in the invariant  $\\mathscr M$  space as computed by  Astroalign.triangle_invariants . source"},{"id":2043,"pagetitle":"Home","title":"Astroalign.triangle_invariants","ref":"/Astroalign/stable/#Astroalign.triangle_invariants","content":" Astroalign.triangle_invariants  —  Function triangle_invariants(phot) Returns all combinations ( $C$ ) of three candidate point sources from the table of sources  phot  returned by  Photometry.Aperture.photometry , and the computed invariant  $\\mathscr M$  for each according to Eq. 3 from  Beroiz, M., Cabral, J. B., & Sanchez, B. (2020) . source"},{"id":2046,"pagetitle":"Home","title":"BackgroundMeshes.jl","ref":"/BackgroundMeshes/stable/#BackgroundMeshes.jl","content":" BackgroundMeshes.jl Create meshes for estimating the background in astronomical images. Originally a submodule of  Photometry.jl ."},{"id":2047,"pagetitle":"Home","title":"Quickstart","ref":"/BackgroundMeshes/stable/#Quickstart","content":" Quickstart Currently, this package is unregistered and must be installed directly from this repository using the built-in package manager julia> ]\n# Or, using Pkg; Pkg.add(url = \"https://github.com/JuliaAstro/BackgroundMeshes.jl\")\npkg> add https://github.com/JuliaAstro/BackgroundMeshes.jl\njulia> using BackgroundMeshes"},{"id":2048,"pagetitle":"Home","title":"Contributing and Support","ref":"/BackgroundMeshes/stable/#Contributing-and-Support","content":" Contributing and Support If you would like to contribute, feel free to open a  pull request . If you want to discuss something before contributing, head over to  discussions  and join or open a new topic. If you're having problems with something, please open an  issue ."},{"id":2049,"pagetitle":"Home","title":"License","ref":"/BackgroundMeshes/stable/#License","content":" License The work derived from  astropy/photutils  is BSD 3-clause. All other work uses the MIT license. Therefore, this work as a whole is BSD 3-clause.  LICENSE  contains all licenses and any files using derived work are noted at the top of the file."},{"id":2052,"pagetitle":"API/Reference","title":"API/Reference","ref":"/BackgroundMeshes/stable/api/#API/Reference","content":" API/Reference BackgroundMeshes.BackgroundInterpolator BackgroundMeshes.BiweightLocationBackground BackgroundMeshes.BiweightScaleRMS BackgroundMeshes.IDWInterpolator BackgroundMeshes.LocationEstimator BackgroundMeshes.MADStdRMS BackgroundMeshes.MMMBackground BackgroundMeshes.RMSEstimator BackgroundMeshes.SourceExtractorBackground BackgroundMeshes.StdRMS BackgroundMeshes.ZoomInterpolator BackgroundMeshes.estimate_background BackgroundMeshes.sigma_clip BackgroundMeshes.sigma_clip!"},{"id":2053,"pagetitle":"API/Reference","title":"General","ref":"/BackgroundMeshes/stable/api/#General","content":" General"},{"id":2054,"pagetitle":"API/Reference","title":"BackgroundMeshes.estimate_background","ref":"/BackgroundMeshes/stable/api/#BackgroundMeshes.estimate_background","content":" BackgroundMeshes.estimate_background  —  Function estimate_background(data;\n    location=SourceExtractorBackground(),\n    rms=StdRMS(),\n    dims=:) Perform scalar background estimation using the given estimators. The value returned will be two values corresponding to the estimated background and the estimated background RMS. The dimensionality will depend on the  dims  keyword. location  and  rms  can be anything that is callable, for example  median , or one of the estimators we provide in  Background Estimators . Examples julia> data = ones(3, 5);\n\njulia> bkg, bkg_rms = estimate_background(data)\n(1.0, 0.0)\n\njulia> using Statistics: median\n\njulia> bkg, bkg_rms = estimate_background(data; location=median, rms=MADStdRMS())\n(1.0, 0.0) See Also Location Estimators ,  RMS Estimators source estimate_background(data, box_size;\n    location=SourceExtractorBackground(),\n    rms=StdRMS(),\n    itp=ZoomInterpolator(box_size),\n    edge_method=:pad,\n    [filter_size]) Perform 2D background estimation using the given estimators mapped over windows of the data.. This function will estimate backgrounds in boxes of size  box_size . When  size(data)  is not an integer multiple of the box size, there are two edge methods:  :pad  and  :crop . The default is to pad (and is recommend to avoid losing image data). If  box_size  is an integer, the implicit shape will be square (eg.  box_size=4  is equivalent to  box_size=(4,4) ). For evaluating the meshes, each box will be passed into  location  to estimate the background and then into  rms  to estimate the background root-mean-square value. These can be anything that is callable, like  median  or one of our  Background Estimators . Once the meshes are created they will be median filtered if  filter_size  is given.  filter_size  can be either an integer or a tuple, with the integer being converted to a tuple the same way  box_size  is. Filtering is done via  ImageFiltering.MapWindow.mapwindow .  filter_size  must be odd. After filtering (if applicable), the meshes are passed to the  itp  to recreate a low-order estimate of the background at the same resolution as the input. Note If your  box_size  is not an integer multiple of the input size, the output background and rms arrays will not have the same size. See Also Location Estimators ,  RMS Estimators ,  Interpolators source"},{"id":2055,"pagetitle":"API/Reference","title":"BackgroundMeshes.sigma_clip","ref":"/BackgroundMeshes/stable/api/#BackgroundMeshes.sigma_clip","content":" BackgroundMeshes.sigma_clip  —  Function sigma_clip(x, sigma; fill=:clamp, center=median(x), std=std(x, corrected=false))\nsigma_clip(x, sigma_low, sigma_high; fill=:clamp, center=median(x), std=std(x, corrected=false)) This function returns sigma-clipped values of the input  x . Specify the upper and lower bounds with  sigma_low  and  sigma_high , otherwise assume they are equal.  center  and  std  are optional keyword arguments which are functions for finding central element and standard deviation. If  fill === :clamp , this will clamp values in  x  lower than  center - sigma_low * std  and values higher than  center + sigma_high * std . Otherwise, they will be replaced with  fill . Examples julia> x = randn(rng, 100_000); # rng is a pre-defined generator for reproducibility\n\njulia> extrema(x)\n(-4.308034628060624, 4.082248634424802)\n\n\njulia> x_clip = sigma_clip(x, 1);\n\njulia> extrema(x_clip) # should be close to (-1, 1)\n(-0.9912911763341569, 1.0077955853440512) source"},{"id":2056,"pagetitle":"API/Reference","title":"BackgroundMeshes.sigma_clip!","ref":"/BackgroundMeshes/stable/api/#BackgroundMeshes.sigma_clip!","content":" BackgroundMeshes.sigma_clip!  —  Function sigma_clip!(x, sigma; fill=:clamp, center=median(x), std=std(x))\nsigma_clip!(x, sigma_low, sigma_high; fill=:clamp, center=median(x), std=std(x)) In-place version of  sigma_clip Warning sigma_clip!  mutates the element in place and mutation cannot lead to change in type. Please be considerate of your input type, because if you are using  Int64  and we try to clip it to  0.5  an  InexactError  will be thrown. To avoid this, we recommend converting to float before clipping, or using  sigma_clip  which does this internally. source"},{"id":2057,"pagetitle":"API/Reference","title":"Background Estimators","ref":"/BackgroundMeshes/stable/api/#Background-Estimators","content":" Background Estimators All of these estimators are subtypes of  BackgroundMeshes.LocationEstimator  or  BackgroundMeshes.RMSEstimator  and are derived using various statistical and image processing methods."},{"id":2058,"pagetitle":"API/Reference","title":"Location Estimators","ref":"/BackgroundMeshes/stable/api/#Location-Estimators-API","content":" Location Estimators These estimators are used for estimating the background using some form of a central statistic."},{"id":2059,"pagetitle":"API/Reference","title":"BackgroundMeshes.LocationEstimator","ref":"/BackgroundMeshes/stable/api/#BackgroundMeshes.LocationEstimator","content":" BackgroundMeshes.LocationEstimator  —  Type BackgroundMeshes.LocationEstimator This abstract type embodies the possible background estimation algorithms for dispatch with  estimate_background . To implement a new estimator, you must define the struct and define a method like  (::MyEstimator)(data::AbstractArray; dims=:) . See Also Location Estimators source"},{"id":2060,"pagetitle":"API/Reference","title":"BackgroundMeshes.MMMBackground","ref":"/BackgroundMeshes/stable/api/#BackgroundMeshes.MMMBackground","content":" BackgroundMeshes.MMMBackground  —  Type MMMBackground(median_factor=3, mean_factor=2) Estimate the background using a mode estimator of the form  median_factor * median - mean_factor * mean . This algorithm is based on the  MMMBackground  routine originally implemented in DAOPHOT.  MMMBackground  uses factors of  median_factor=3  and  mean_factor=2  by default. This estimator assumes that contaminated sky pixel values overwhelmingly display positive departures from the true value. Examples julia> x = ones(3, 5);\n\njulia> MMMBackground()(x)\n1.0\n\njulia> MMMBackground(median_factor=4, mean_factor=3)(x, dims = 1)\n1×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0 See Also SourceExtractorBackground source"},{"id":2061,"pagetitle":"API/Reference","title":"BackgroundMeshes.SourceExtractorBackground","ref":"/BackgroundMeshes/stable/api/#BackgroundMeshes.SourceExtractorBackground","content":" BackgroundMeshes.SourceExtractorBackground  —  Type SourceExtractorBackground() This estimator returns the background of the input using the SourceExtractorBackground algorithm. The background is calculated using a mode estimator of the form  (2.5 * median) - (1.5 * mean) . If  (mean - median) / std > 0.3  then the median is used and if  std = 0  then the mean is used. Examples julia> data = ones(3, 5);\n\njulia> SourceExtractorBackground()(data)\n1.0\n\njulia> SourceExtractorBackground()(data, dims=1)\n1×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0 source"},{"id":2062,"pagetitle":"API/Reference","title":"BackgroundMeshes.BiweightLocationBackground","ref":"/BackgroundMeshes/stable/api/#BackgroundMeshes.BiweightLocationBackground","content":" BackgroundMeshes.BiweightLocationBackground  —  Type BiweightLocationBackground(c = 6.0, M = nothing) Estimate the background using the robust biweight location statistic. See  BiweightStats.jl  for more information. Examples julia> x = ones(3,5);\n\njulia> BiweightLocationBackground()(x)\n1.0\n\njulia> BiweightLocationBackground(c=5.5)(x; dims = 1)\n1×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0 source"},{"id":2063,"pagetitle":"API/Reference","title":"RMS Estimators","ref":"/BackgroundMeshes/stable/api/#RMS-Estimators-API","content":" RMS Estimators These estimators are used for estimating the root-mean-square (RMS) of the background using some form of a deviation statistic."},{"id":2064,"pagetitle":"API/Reference","title":"BackgroundMeshes.RMSEstimator","ref":"/BackgroundMeshes/stable/api/#BackgroundMeshes.RMSEstimator","content":" BackgroundMeshes.RMSEstimator  —  Type BackgroundMeshes.RMSEstimator This abstract type embodies the possible background RMS estimation algorithms for dispatch with  estimate_background . To implement a new estimator, you must define the struct and define a method like  (::MyRMSEstimator)(data::AbstractArray; dims=:) . See Also RMS Estimators source"},{"id":2065,"pagetitle":"API/Reference","title":"BackgroundMeshes.StdRMS","ref":"/BackgroundMeshes/stable/api/#BackgroundMeshes.StdRMS","content":" BackgroundMeshes.StdRMS  —  Type StdRMS() Uses the standard deviation statistic for background RMS estimation. Examples julia> data = ones(3, 5);\n\njulia> StdRMS()(data)\n0.0\n\njulia> StdRMS()(data, dims=1)\n1×5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0 source"},{"id":2066,"pagetitle":"API/Reference","title":"BackgroundMeshes.MADStdRMS","ref":"/BackgroundMeshes/stable/api/#BackgroundMeshes.MADStdRMS","content":" BackgroundMeshes.MADStdRMS  —  Type MADStdRMS() Uses the standard median absolute deviation (MAD) statistic for background RMS estimation. This is typically given as $\\sigma \\approx 1.4826 \\cdot \\text{MAD}$ Examples julia> data = ones(3, 5);\n\njulia> MADStdRMS()(data)\n0.0\n\njulia> MADStdRMS()(data, dims=1)\n1×5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0 source"},{"id":2067,"pagetitle":"API/Reference","title":"BackgroundMeshes.BiweightScaleRMS","ref":"/BackgroundMeshes/stable/api/#BackgroundMeshes.BiweightScaleRMS","content":" BackgroundMeshes.BiweightScaleRMS  —  Type BiweightScaleRMS(c=9.0, M=nothing) Uses the robust biweight scale statistic for background RMS estimation. The biweight scale is the square root of the biweight midvariance. The biweight midvariance uses a tuning constant,  c , and an optional initial guess of the central value  M . See  BiweightStats.jl  for more information. Examples julia> data = ones(3, 5);\n\njulia> BiweightScaleRMS()(data)\n0.0\n\njulia> BiweightScaleRMS(c=3.0)(data, dims=1)\n1×5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0 source"},{"id":2068,"pagetitle":"API/Reference","title":"Background Interpolators","ref":"/BackgroundMeshes/stable/api/#Background-Interpolators","content":" Background Interpolators Background interpolators provide a method for converting a low-resolution mesh into a low-order high-resolution image."},{"id":2069,"pagetitle":"API/Reference","title":"BackgroundMeshes.BackgroundInterpolator","ref":"/BackgroundMeshes/stable/api/#BackgroundMeshes.BackgroundInterpolator","content":" BackgroundMeshes.BackgroundInterpolator  —  Type BackgroundInterpolator This abstract type embodies the different ways of converting a low-resolution mesh into a high-resolution image, especially for dispatch with  estimate_background To implement a new interpolation scheme, you must define the struct and define a method like  (::MyInterpolator)(mesh) See Also Interpolators source"},{"id":2070,"pagetitle":"API/Reference","title":"Interpolators","ref":"/BackgroundMeshes/stable/api/#Interpolators","content":" Interpolators"},{"id":2071,"pagetitle":"API/Reference","title":"BackgroundMeshes.ZoomInterpolator","ref":"/BackgroundMeshes/stable/api/#BackgroundMeshes.ZoomInterpolator","content":" BackgroundMeshes.ZoomInterpolator  —  Type ZoomInterpolator(factors) Use a cubic-spline interpolation scheme to increase resolution of a mesh. factors  represents the level of \"zoom\", so an input mesh of size  (10, 10)  with factors  (2, 2)  will have an output size of  (20, 20) . If only an integer is provided, it will be used as the factor for every axis. Examples julia> ZoomInterpolator(2)([1 0; 0 1])\n4×4 Matrix{Float64}:\n  1.0          0.75   0.25   -2.77556e-17\n  0.75         0.625  0.375   0.25\n  0.25         0.375  0.625   0.75\n -5.55112e-17  0.25   0.75    1.0\n\njulia> ZoomInterpolator(3, 1)([1 0; 0 1])\n6×2 Matrix{Float64}:\n  1.0          -2.77556e-17\n  1.0          -2.77556e-17\n  0.666667      0.333333\n  0.333333      0.666667\n -5.55112e-17   1.0\n -5.55112e-17   1.0\n source"},{"id":2072,"pagetitle":"API/Reference","title":"BackgroundMeshes.IDWInterpolator","ref":"/BackgroundMeshes/stable/api/#BackgroundMeshes.IDWInterpolator","content":" BackgroundMeshes.IDWInterpolator  —  Type IDWInterpolator(factors; leafsize=10, k=8, power=1, reg=0, conf_dist=1e-12) Use Shepard Inverse Distance Weighing interpolation scheme to increase resolution of a mesh. factors  represents the level of \"zoom\", so an input mesh of size  (10, 10)  with factors  (2, 2)  will have an output size of  (20, 20) . If only an integer is provided, it will be used as the factor for every axis. The interpolator can be called with some additional parameters: leaf_size  determines at what number of points to stop splitting the tree further, k  which is the number of nearest neighbors to be considered, power  is the exponent for distance in the weighing factor, reg  is the offset for the weighing factor in denominator, conf_dist  is the distance below which two points would be considered as the same point. Examples julia> IDWInterpolator(2, k=2)([1 0; 0 1])\n4×4 Matrix{Float64}:\n 1.0   0.75      0.25      0.0\n 0.75  0.690983  0.309017  0.25\n 0.25  0.309017  0.690983  0.75\n 0.0   0.25      0.75      1.0\n\njulia> IDWInterpolator(3, 1; k=2, power=4)([1 0; 0 1])\n6×2 Matrix{Float64}:\n 1.0        0.0\n 1.0        0.0\n 0.941176   0.0588235\n 0.0588235  0.941176\n 0.0        1.0\n 0.0        1.0 source"},{"id":2075,"pagetitle":"1. Basics","title":"1. Basics","ref":"/BackgroundMeshes/stable/examples/1_basics/#1.-Basics","content":" 1. Basics Let's dig into the basics of how these background meshes work. Let's start by creating some data. For this image, we'll create a 2-D polynomial gradient across a 1000x1000 image: using AstroImages\nusing BackgroundMeshes\nusing Random\nusing Statistics\nusing Plots\nrng = Random.seed!(125512)\n\nxs = range(0, 1; length=1000)\nys = xs'\ndata = xs .* ys\nimplot(data)"},{"id":2076,"pagetitle":"1. Basics","title":"Mesh size","ref":"/BackgroundMeshes/stable/examples/1_basics/#Mesh-size","content":" Mesh size Background meshes are defined by a grid of sub-images across the original data. Within these sub-images we use various statistics to estimate the background signal. Here we show directly how the sub-image size (i.e., mesh size) affects the background estimation: box_sizes = (10, 50, 100)\nbackgrounds = map(n -> first(estimate_background(data, n; location=mean)), box_sizes)\nplot(\n    implot(backgrounds[1]; title=\"N=10\", cbar=false),\n    implot(backgrounds[2]; title=\"N=50\", cbar=false),\n    implot(backgrounds[3]; title=\"N=100\", cbar=false);\n    layout=(1, 3),\n)"},{"id":2077,"pagetitle":"1. Basics","title":"Location Estimators","ref":"/BackgroundMeshes/stable/examples/1_basics/#Location-Estimators","content":" Location Estimators As mentioned above, statistics are calculated inside each of the sub-images. Depending on your workflow and data quality, you can choose between a variety of estimators: mean  or  median  from Statistics SourceExtractorBackground MMMBackground BiweightLocationBackground See the  LocationEstimator  docs for more information about each estimator. Let's create some data with outliers and look at how each estimator handles the outliers: true_background = 10\nsub_img = randn(rng, 100, 100) .+ true_background\n\n# Add in hot pixels\nx_idxs = rand(rng, axes(sub_img, 1), 50)\ny_idxs = rand(rng, axes(sub_img, 2), 50)\nfor (x, y) in zip(x_idxs, y_idxs)\n    sub_img[x, y] = 2^16\nend\n\nimplot(sub_img; clims=zscale(sub_img)) Let's see how each estimator compares: bkgs = [\n    \"mean\" => mean(sub_img),\n    \"median\" => median(sub_img),\n    \"source extractor\" => SourceExtractorBackground()(sub_img),\n    \"MMM\" => MMMBackground()(sub_img),\n    \"biweight location\" => BiweightLocationBackground()(sub_img),\n]\nscatter(first.(bkgs), last.(bkgs); lab=\"\")\nhline!([true_background]; c=:black, ls=:dash, lab=\"true value\") Here we see that  median  and  BiweightLocationBackground  do a good job of estimating the background despite the outliers, however the outliers can be removed ahead of time with a tool like  LACosmic.jl ."},{"id":2078,"pagetitle":"1. Basics","title":"RMS Estimators","ref":"/BackgroundMeshes/stable/examples/1_basics/#RMS-Estimators","content":" RMS Estimators Within each sub-image we also calulate the root-mean-square (RMS) estimate of noise, which can be forward propagated in your analysis. StdRMS MADStdRMS BiweightScaleRMS See the  RMSEstimator  docs for more information about each estimator. Let's create some data with outliers and look at how each estimator handles the outliers: # Use same data before N(10, 1)\ntrue_rms = 1\nrmss = [\n    \"std\" => StdRMS()(sub_img),\n    \"MAD\" => MADStdRMS()(sub_img),\n    \"biweight scale\" => BiweightScaleRMS()(sub_img),\n]\nscatter(first.(rmss), last.(rmss); lab=\"\")\nhline!([true_rms]; c=:black, ls=:dash, lab=\"true value\") Again, we see the median-based  MADStdRMS  as well as the  BiweightScaleRMS  do well despite the outliers."},{"id":2081,"pagetitle":"2. Background Estimation on Real Data","title":"2. Background Estimation on Real Data","ref":"/BackgroundMeshes/stable/examples/2_background_estimation/#2.-Background-Estimation-on-Real-Data","content":" 2. Background Estimation on Real Data Estimating backgrounds is an important step in performing photometry. Ideally, we could perfectly describe the background with a scalar value or with some distribution. Unfortunately, it's impossible for us to precisely separate the background and foreground signals. Here, we use mixture of robust statistical estimators and meshing to let us get the spatially varying background from an astronomical photo. Let's show an example: using AstroImages\nusing BackgroundMeshes\nusing FITSIO\nusing Plots\n\n# Download our image, courtesy of astropy\nurl = \"https://rawcdn.githack.com/astropy/photutils-datasets/8c97b4fa3a6c9e6ea072faeed2d49a20585658ba/data/M6707HH.fits\"\nhdu = FITS(download(url))\nimage = read(hdu[1])\n\n# Plot\nfunction imshow(image; kwargs...)\n    xs, ys = axes(image)\n    data = transpose(image)\n    heatmap(xs, ys, data;\n        aspect_ratio = 1,\n        xlim = extrema(xs),\n        ylim = extrema(ys),\n        kwargs...\n    )\nend\n\nimshow(image) Now let's try and estimate the background using  estimate_background . First, we'll sigma-clip to try and remove the signals from the stars. Then, the background is broken down into boxes, in this case of size  (50, 50) . Within each box, the given statistical estimators get the background value and RMS. By default, we use  SourceExtractorBackground  and  StdRMS . This creates a low-resolution image, which we then need to resize. We can accomplish this using an interpolator, by default a cubic-spline interpolator via  ZoomInterpolator . The end result is a smooth estimate of the spatially varying background and background RMS. # Sigma-clip\nclipped = sigma_clip(image, 1; fill=NaN)\n\n# Get background and background rms with box-size (50, 50)\nbkg, bkg_rms = estimate_background(clipped, 50)\n\n# Plot\nplot(\n    imshow(image; title=\"Original\"),\n    imshow(clipped; title=\"Sigma-Clipped\"),\n    imshow(bkg; title=\"Background\"),\n    imshow(bkg_rms; title=\"Background RMS\");\n    layout = (2, 2),\n    ticks = false,\n) We could apply a median filter, too, by specifying  filter_size : # Get background and background rms with box-size (50, 50) and filter_size (5, 5)\nbkg_f, bkg_rms_f = estimate_background(clipped, 50; filter_size = 5)\n\n# Plot\nplot(\n    imshow(bkg; title=\"Unfiltered\", ylabel=\"Background\"),\n    imshow(bkg_f; title=\"Filtered\"),\n    imshow(bkg_rms; ylabel=\"RMS\"),\n    imshow(bkg_rms_f);\n    layout = (2, 2),\n    ticks = false,\n) Now we can see our image after subtracting the filtered background and ready for further analysis! subt = image .- bkg_f[axes(image)...]\n\n# Plot\nplot(\n    imshow(image; title=\"Original\", colorbar=false),\n    imshow(subt; title=\"Subtracted\");\n    layout = (1, 2),\n    size = (600, 260),\n    xlims = (400, 800),\n    ylims = ( 400, 800),\n    clims = (minimum(subt), maximum(image)),\n    ticks = false,\n    aspect_ratio = 1,\n)"},{"id":2082,"pagetitle":"2. Background Estimation on Real Data","title":"IDW Interpolator","ref":"/BackgroundMeshes/stable/examples/2_background_estimation/#IDW-Interpolator","content":" IDW Interpolator Here is a quick example using the  IDWInterpolator : b1, r1 = estimate_background(clipped, 50; filter_size=5)\nb2, r2 = estimate_background(clipped, 50; itp=IDWInterpolator(50), filter_size=5)\n\n# Plot\nplot(\n    imshow(b1; title=\"ZoomInterpolator\", ylabel=\"Background\"),\n    imshow(b2; title=\"IDWInterpolator\"),\n    imshow(r1; ylabel=\"RMS\"),\n    imshow(r2);\n    layout = (2, 2),\n    ticks = false,\n)"},{"id":2085,"pagetitle":"Home","title":"Home","ref":"/AstroImages/stable/#Home","content":" Home AstroImage.jl is a Julia package for loading, manipulating, and visualizing astronomical images. It supports FITS files ( FITSIO.jl ), world coordinates ( WCS.jl ), rendering images ( Images.jl ), and plot recipes ( Plots.jl )."},{"id":2086,"pagetitle":"Home","title":"Videos","ref":"/AstroImages/stable/#Videos","content":" Videos AstroImages.jl was presented at JuliaCon in 2022. You can view the talk  here ."},{"id":2089,"pagetitle":"API","title":"API Documentation","ref":"/AstroImages/stable/api/#API-Documentation","content":" API Documentation"},{"id":2090,"pagetitle":"API","title":"FileIO.load","ref":"/AstroImages/stable/api/#FileIO.load","content":" FileIO.load  —  Function load(filename)  loads the contents of a formatted file, trying to infer the format from  filename  and/or magic bytes in the file (see  query ). load(strm)  loads from an  IOStream  or similar object. In this case, there is no filename extension, so we rely on the magic bytes for format identification. load(File{format\"PNG\"}(filename))  specifies the format directly, and bypasses the format  query . load(Stream{format\"PNG\"}(io))  specifies the format directly, and bypasses the format  query . load(f; options...)  passes keyword arguments on to the loader. source"},{"id":2091,"pagetitle":"API","title":"FileIO.save","ref":"/AstroImages/stable/api/#FileIO.save","content":" FileIO.save  —  Function save(filename, data...)  saves the contents of a formatted file, trying to infer the format from  filename . save(Stream{format\"PNG\"}(io), data...)  specifies the format directly, and bypasses the format  query . save(File{format\"PNG\"}(filename), data...)  specifies the format directly, and bypasses the format  query . save(f, data...; options...)  passes keyword arguments on to the saver. source"},{"id":2092,"pagetitle":"API","title":"FileIO.query","ref":"/AstroImages/stable/api/#FileIO.query","content":" FileIO.query  —  Function query(filename; checkfile=true) Return a  File  object with information about the format inferred from the file's extension and/or magic bytes. If  filename  already exists, the file's magic bytes will take priority unless  checkfile  is false. source query(io, [filename]) Returns a  Stream  object with information about the format inferred from the magic bytes. source"},{"id":2093,"pagetitle":"API","title":"AstroImages.AstroImage","ref":"/AstroImages/stable/api/#AstroImages.AstroImage","content":" AstroImages.AstroImage  —  Type AstroImage Provides access to a FITS image along with its accompanying header and WCS information, if applicable. source"},{"id":2094,"pagetitle":"API","title":"AstroImages.imview","ref":"/AstroImages/stable/api/#AstroImages.imview","content":" AstroImages.imview  —  Function imview(img; clims=Percent(99.5), stretch=identity, cmap=:magma, contrast=1.0, bias=0.5) Create a read only view of an array or AstroImageMat mapping its data values to Colors according to  clims ,  stretch , and  cmap . The data is first clamped to  clims , which can either be a tuple of (min, max) values or a function accepting an iterator of pixel values that returns (min, max). By default,  clims=Percent(99.5)  which sets the display min and max to the central 99.5 percentile range of pixel values. Convenient functions to use for  clims  are:  extrema ,  Zscale , and  Percent(p) Next, the data is rescaled to [0,1] and remapped according to the function  stretch . Stretch can be any monotonic fuction mapping values in the range [0,1] to some range [a,b]. Note that  log(0)  is not defined so is not directly supported. For a list of convenient stretch functions, see:  logstretch ,  powstretch ,  squarestretch ,  asinhstretch ,  sinhstretch ,  powerdiststretch Finally the data is mapped to RGB values according to  cmap . If cmap is  nothing , grayscale is used. ColorSchemes.jl defines hundreds of colormaps. A few nice ones for images include:  :viridis ,  :magma ,  :plasma ,  :thermal , and  :turbo . Crucially, this function returns a view over the underlying data. If  img  is updated then those changes will be reflected by this view with the exception of  clims  which is not recalculated. Note: if clims or stretch is a function, the pixel values passed in are first filtered to remove non-finite or missing values. Defaults The default values of  clims ,  stretch , and  cmap  are  extrema ,  identity , and  nothing  respectively. You may alter these defaults using  AstroImages.set_clims! ,   AstroImages.set_stretch! , and  AstroImages.set_cmap! . Automatic Display Arrays wrapped by  AstroImageMat()  get displayed as images automatically by calling  imview  on them with the default settings when using displays that support showing PNG images. Missing data Pixels that are  NaN  or  missing  will be displayed as transparent when  cmap  is set or black if. +/- Inf will be displayed as black or white respectively. Exporting Images The view returned by  imview  can be saved using general  FileIO.save  methods. Example: v = imview(data, cmap=:magma, stretch=asinhstretch, clims=Percent(95))\nsave(\"output.png\", v) source imview(img::AbstractArray{<:Complex}; ...) When applied to an image with complex values, display the magnitude of the pixels using  imview  and display the phase angle as a panel below using a cyclical color map. For more customatization, you can create a view like this yourself: vcat(\n    imview(abs.(img)),\n    imview(angle.(img)),\n) source"},{"id":2095,"pagetitle":"API","title":"AstroImages.implot","ref":"/AstroImages/stable/api/#AstroImages.implot","content":" AstroImages.implot  —  Function implot(\n    img::AbstractArray;\n    clims=Percent(99.5),\n    stretch=identity,\n    cmap=:magma,\n    bias=0.5,\n    contrast=1,\n    wcsticks=true,\n    grid=true,\n    platescale=1\n) Create a read only view of an array or AstroImageMat mapping its data values to an array of Colors. Equivalent to: implot(\n    imview(\n        img::AbstractArray;\n        clims=Percent(99.5),\n        stretch=identity,\n        cmap=:magma,\n        bias=0.5,\n        contrast=1,\n    ),\n    wcsn=1,\n    wcsticks=true,\n    wcstitle=true,\n    grid=true,\n    platescale=1\n) Image Rendering See  imview  for how data is mapped to RGBA pixel values. WCS & Image Coordinates If provided with an AstroImage that has WCS headers set, the tick marks and plot grid are calculated using WCS.jl. By default, use the first WCS coordinate system. The underlying pixel coordinates are those returned by  dims(img)  multiplied by  platescale . This allows you to overplot lines, regions, etc. using pixel coordinates. If you wish to compute the pixel coordinate of a point in world coordinates, see  world_to_pix . wcsn  (default  1 ) select which WCS transform in the headers to use for ticks & grid wcsticks  (default  true  if WCS headers present) display ticks and labels, and title using world coordinates wcstitle  (default  true  if WCS headers present and  length(refdims(img))>0 ). When slicing a cube, display the location along unseen axes in world coordinates instead of pixel coordinates. grid  (default  true ) show a grid over the plot. Uses WCS coordinates if  wcsticks  is true, otherwise pixel coordinates multiplied by  platescale . platescale  (default  1 ). Scales the underlying pixel coordinates to ease overplotting, etc. If  wcsticks  is false, the displayed pixel coordinates are also scaled. Defaults The default values of  clims ,  stretch , and  cmap  are  extrema ,  identity , and  nothing  respectively. You may alter these defaults using  AstroImages.set_clims! ,   AstroImages.set_stretch! , and  AstroImages.set_cmap! . source"},{"id":2096,"pagetitle":"API","title":"AstroImages.Comment","ref":"/AstroImages/stable/api/#AstroImages.Comment","content":" AstroImages.Comment  —  Type Index for accessing a comment associated with a header keyword or COMMENT entry. Example: img = AstroImage(randn(10,10))\nimg[\"ABC\"] = 1\nimg[\"ABC\", Comment] = \"A comment describing this key\"\n\npush!(img, Comment, \"The purpose of this file is to demonstrate comments\")\nimg[Comment] # [\"The purpose of this file is to demonstrate comments\"] source"},{"id":2097,"pagetitle":"API","title":"AstroImages.History","ref":"/AstroImages/stable/api/#AstroImages.History","content":" AstroImages.History  —  Type Allows accessing and setting HISTORY header entries img = AstroImage(randn(10,10))\npush!(img, History, \"2023-04-19: Added history entry.\")\nimg[History] # [\"2023-04-19: Added history entry.\"] source"},{"id":2098,"pagetitle":"API","title":"WCS.pix_to_world","ref":"/AstroImages/stable/api/#WCS.pix_to_world","content":" WCS.pix_to_world  —  Function pix_to_world(wcs, pixcoords) Convert the array of pixel coordinates  pixcoords  to world coordinates according to the WCSTransform  wcs .  pixcoords  should be a 2-d array where \"pixcoords[:, i]\" is the i-th set of coordinates, or a 1-d array representing a single set of coordinates. The return value is the same shape as  pixcoords . source pix_to_world(img::AstroImage, pixcoords; all=false) Given an astro image, look up the world coordinates of the pixels given by  pixcoords . World coordinates are resolved using WCS.jl and a WCSTransform calculated from any FITS header present in  img . If no WCS information is in the header, or the axes are all linear, this will just return pixel coordinates. pixcoords  should be the coordinates in your current selection of the image. For example, if you select a slice like this: julia> cube = load(\"some-3d-cube.fits\")\njulia> slice = cube[10:20, 30:40, 5] Then to look up the coordinates of the pixel in the bottom left corner of  slice , run: julia> world_coords = pix_to_world(img, [1, 1])\n[10, 30] If WCS information was present in the header of  cube , then those coordinates would be resolved using axis 1, 2, and 3 respectively. To include world coordinates in all axes, pass  all=true julia> world_coords = pix_to_world(img, [1, 1], all=true)\n[10, 30, 5] !! Coordinates must be provided in the order of  dims(img) . If you transpose an image, the order you pass the coordinates should not change. source"},{"id":2099,"pagetitle":"API","title":"WCS.world_to_pix","ref":"/AstroImages/stable/api/#WCS.world_to_pix","content":" WCS.world_to_pix  —  Function world_to_pix(wcs, worldcoords) Convert the array of world coordinates  worldcoords  to pixel coordinates according to the WCSTransform  wcs .  worldcoords  is a 2-d array where \"worldcoords[:, i]\" is the i-th set of coordinates, or a 1-d array representing a single set of coordinates. The return value is the same size as  worldcoords . source"},{"id":2100,"pagetitle":"API","title":"DimensionalData.Dimensions.X","ref":"/AstroImages/stable/api/#DimensionalData.Dimensions.X","content":" DimensionalData.Dimensions.X  —  Type X <: XDim\n\nX(val=:) X  Dimension .  X <: XDim <: IndependentDim Examples xdim = X(2:2:10) val = A[X(1)] mean(A; dims=X) source"},{"id":2101,"pagetitle":"API","title":"DimensionalData.Dimensions.Y","ref":"/AstroImages/stable/api/#DimensionalData.Dimensions.Y","content":" DimensionalData.Dimensions.Y  —  Type Y <: YDim\n\nY(val=:) Y  Dimension .  Y <: YDim <: DependentDim Examples ydim = Y(['a', 'b', 'c']) val = A[Y(1)] mean(A; dims=Y) source"},{"id":2102,"pagetitle":"API","title":"DimensionalData.Dimensions.Z","ref":"/AstroImages/stable/api/#DimensionalData.Dimensions.Z","content":" DimensionalData.Dimensions.Z  —  Type Z <: ZDim\n\nZ(val=:) Z  Dimension .  Z <: ZDim <: Dimension Example: zdim = Z(10:10:100) val = A[Z(1)] mean(A; dims=Z) source"},{"id":2103,"pagetitle":"API","title":"DimensionalData.Dimensions.Dim","ref":"/AstroImages/stable/api/#DimensionalData.Dimensions.Dim","content":" DimensionalData.Dimensions.Dim  —  Type Dim{S}(val=:) A generic dimension. For use when custom dims are required when loading data from a file. Can be used as keyword arguments for indexing. Dimension types take precedence over same named  Dim  types when indexing with symbols, or e.g. creating Tables.jl keys. julia> dim = Dim{:custom}(['a', 'b', 'c'])\ncustom ['a', 'b', 'c'] source"},{"id":2104,"pagetitle":"API","title":"DimensionalData.Dimensions.Lookups.At","ref":"/AstroImages/stable/api/#DimensionalData.Dimensions.Lookups.At","content":" DimensionalData.Dimensions.Lookups.At  —  Type At <: IntSelector\n\nAt(x; atol=nothing, rtol=nothing)\nAt(a, b; kw...) Selector that exactly matches the value on the passed-in dimensions, or throws an error. For ranges and arrays, every intermediate value must match an existing value - not just the end points. x  can be any value to select a single index, or a  Vector  of values to select vector of indices. If two values  a  and  b  are used, the range between them will be selected. Keyword  atol  is passed to  isapprox . Example using DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))\nA[X(At(20)), Y(At(6))]\n\n# output\n\n5 source"},{"id":2105,"pagetitle":"API","title":"DimensionalData.Dimensions.Lookups.Near","ref":"/AstroImages/stable/api/#DimensionalData.Dimensions.Lookups.Near","content":" DimensionalData.Dimensions.Lookups.Near  —  Type Near <: IntSelector\n\nNear(x)\nNear(a, b) Selector that selects the nearest index to  x . With  Points  this is simply the lookup values nearest to the  x , however with  Intervals  it is the interval  center  nearest to  x . This will be offset from the index value for  Start  and  End  locus. x  can be any value to select a single index, or a  Vector  of values to select vector of indices. If two values  a  and  b   are used, the range between the nearsest value to each of them will be selected. Example using DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))\nA[X(Near(23)), Y(Near(5.1))]\n\n# output\n4 source"},{"id":2106,"pagetitle":"API","title":"DimensionalData.Dimensions.dims","ref":"/AstroImages/stable/api/#DimensionalData.Dimensions.dims","content":" DimensionalData.Dimensions.dims  —  Function dims(x, query) => Tuple{Vararg{Dimension}}\ndims(x, query...) => Tuple{Vararg{Dimension}} Get the dimension(s) matching the type(s) of the query dimension. Lookup can be an Int or an Dimension, or a tuple containing any combination of either. Arguments x : any object with a  dims  method, or a  Tuple  of  Dimension . query : Tuple or a single  Dimension  or  Dimension Type . Example julia> using DimensionalData\n\njulia> A = DimArray(ones(2, 3, 2), (X, Y, Z))\n╭───────────────────────────╮\n│ 2×3×2 DimArray{Float64,3} │\n├───────────────────── dims ┤\n  ↓ X, → Y, ↗ Z\n└───────────────────────────┘\n[:, :, 1]\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n\njulia> dims(A, (X, Y))\n(↓ X, → Y)\n source dims(x, [dims::Tuple]) => Tuple{Vararg{Dimension}}\ndims(x, dim) => Dimension Return a tuple of  Dimension s for an object, in the order that matches the axes or columns of the underlying data. dims  can be  Dimension ,  Dimension  types, or  Symbols  for  Dim{Symbol} . The default is to return  nothing . source"},{"id":2107,"pagetitle":"API","title":"DimensionalData.Dimensions.refdims","ref":"/AstroImages/stable/api/#DimensionalData.Dimensions.refdims","content":" DimensionalData.Dimensions.refdims  —  Function refdims(x, [dims::Tuple]) => Tuple{Vararg{Dimension}}\nrefdims(x, dim) => Dimension Reference dimensions for an array that is a slice or view of another array with more dimensions. slicedims(a, dims)  returns a tuple containing the current new dimensions and the new reference dimensions. Refdims can be stored in a field or discarded, as it is mostly to give context to plots. Ignoring refdims will simply leave some captions empty. The default is to return an empty  Tuple () . source"},{"id":2108,"pagetitle":"API","title":"AstroImages.header","ref":"/AstroImages/stable/api/#AstroImages.header","content":" AstroImages.header  —  Function header(img::AstroImage) Return the underlying FITSIO.FITSHeader object wrapped by an AstroImage. Note that this object has less flexible getindex and setindex methods. Indexing by symbol, Comment, History, etc are not supported. source header(array::AbstractArray) Returns an empty FITSIO.FITSHeader object when called with a non-AstroImage abstract array. source"},{"id":2109,"pagetitle":"API","title":"AstroImages.wcs","ref":"/AstroImages/stable/api/#AstroImages.wcs","content":" AstroImages.wcs  —  Function wcs(img) Computes and returns a list of World Coordinate System WCSTransform objects from WCS.jl. The resultss are cached after the first call, so subsequent calls are fast. Modifying a WCS header invalidates this cache automatically, so users should call  wcs(...)  each time rather than keeping the WCSTransform object around. source wcs(img, index) Computes and returns a World Coordinate System WCSTransform objects from WCS.jl by index. This is to support files with multiple WCS transforms specified.  wcs(img,1)  is useful for selecting selecting the first WCSTranform object. The resultss are cached after the first call, so subsequent calls are fast. Modifying a WCS header invalidates this cache automatically, so users should call  wcs(...)  each time rather than keeping the WCSTransform object around. source wcs(array) Returns a list with a single basic WCSTransform object when called with a non-AstroImage abstract array. source"},{"id":2110,"pagetitle":"API","title":"AstroImages.WCSGrid","ref":"/AstroImages/stable/api/#AstroImages.WCSGrid","content":" AstroImages.WCSGrid  —  Type WCSGrid(img::AstroImageMat, ax=(1,2), coords=(first(axes(img,ax[1])),first(axes(img,ax[2])))) Given an AstroImageMat, return information necessary to plot WCS gridlines in physical coordinates against the image's pixel coordinates. This function has to work on both plotted axes at once to handle rotation and general curvature of the WCS grid projected on the image coordinates. source"},{"id":2111,"pagetitle":"API","title":"AstroImages.composecolors","ref":"/AstroImages/stable/api/#AstroImages.composecolors","content":" AstroImages.composecolors  —  Function composecolors(\n    images,\n    cmap=[\"#F00\", \"#0F0\", \"#00F\"];\n    clims,\n    stretch,\n    contrast,\n    bias,\n    multiplier\n) Create a color composite of multiple images by applying  imview  and blending the results. This function can be used to create RGB composites using any number of channels (e.g. red, green, blue, and hydrogen alpha) as well as more exotic images like blending radio and optical data using two different colormaps. cmap  should be a list of colorants, named colors (see Colors.jl), or colorschemes (see ColorSchemes.jl).  clims ,  stretch ,  contrast , and  bias  are passed on to  imview . They can be a single value or a list of different values for each image. The headers of the returned image are copied from the first image. Examples: # Basic RGB\ncomposecolors([redimage, greenimage, blueimage])\n# Non-linear stretch before blending\ncomposecolors([redimage, greenimage, blueimage], stretch=asinhstretch)\n# More than three channels are allowed (H alpha in pink)\ncomposecolors(\n    [antred, antgreen, antblue, anthalp],\n    [\"red\", \"green\", \"blue\", \"maroon1\"],\n    multiplier=[1,2,1,1]\n)\n# Can mix\ncomposecolors([radioimage, xrayimage], [:ice, :magma], clims=extrema)\ncomposecolors([radioimage, xrayimage], [:magma, :viridis], clims=[Percent(99), Zscale()]) source"},{"id":2112,"pagetitle":"API","title":"AstroImages.Zscale","ref":"/AstroImages/stable/api/#AstroImages.Zscale","content":" AstroImages.Zscale  —  Type Zscale(options)(data) Wraps PlotUtils.zscale in a callable with default parameters. This is a common algorithm for agressively stretching astronomical data to see faint structure that originated in IRAF:  https://iraf.net/forum/viewtopic.php?showtopic=134139  but is now seen in many other applications/libraries (DS9, Astropy, etc.) Usage: imview(img, clims=Zscale())\nimplot(img, clims=Zscale(contrast=0.1)) Default parameters: nsamples::Int=1000\ncontrast::Float64=0.25\nmax_reject::Float64=0.5\nmin_npixels::Float64=5\nk_rej::Float64=2.5\nmax_iterations::Int=5 source"},{"id":2113,"pagetitle":"API","title":"AstroImages.Percent","ref":"/AstroImages/stable/api/#AstroImages.Percent","content":" AstroImages.Percent  —  Type Percent(99.5) Returns a callable that calculates display limits that include the given percent of the image data. Reproduces the behaviour of the SAO DS9 scale menu. Example: julia> imview(img, clims=Percent(90)) This will set the limits to be the 5th percentile to the 95th percentile. source"},{"id":2114,"pagetitle":"API","title":"AstroImages.logstretch","ref":"/AstroImages/stable/api/#AstroImages.logstretch","content":" AstroImages.logstretch  —  Function logstretch(num,a=1000) A log-stretch as defined by the SAO DS9 application:  http://ds9.si.edu/doc/ref/how.html source"},{"id":2115,"pagetitle":"API","title":"AstroImages.powstretch","ref":"/AstroImages/stable/api/#AstroImages.powstretch","content":" AstroImages.powstretch  —  Function powstretch(num, a=1000) A power-stretch as defined by the SAO DS9 application:  http://ds9.si.edu/doc/ref/how.html source"},{"id":2116,"pagetitle":"API","title":"AstroImages.sqrtstretch","ref":"/AstroImages/stable/api/#AstroImages.sqrtstretch","content":" AstroImages.sqrtstretch  —  Function sqrtstretch(num) A square root stretch (simply defined as Base.sqrt) source"},{"id":2117,"pagetitle":"API","title":"AstroImages.squarestretch","ref":"/AstroImages/stable/api/#AstroImages.squarestretch","content":" AstroImages.squarestretch  —  Function squarestretch(num) A squarestretch-stretch as defined by the SAO DS9 application:  http://ds9.si.edu/doc/ref/how.html source"},{"id":2118,"pagetitle":"API","title":"AstroImages.asinhstretch","ref":"/AstroImages/stable/api/#AstroImages.asinhstretch","content":" AstroImages.asinhstretch  —  Function asinhstretch(num) A hyperbolic arcsin stretch as defined by the SAO DS9 application:  http://ds9.si.edu/doc/ref/how.html source"},{"id":2119,"pagetitle":"API","title":"AstroImages.sinhstretch","ref":"/AstroImages/stable/api/#AstroImages.sinhstretch","content":" AstroImages.sinhstretch  —  Function sinhstretch(num) A hyperbolic sin stretch as defined by the SAO DS9 application:  http://ds9.si.edu/doc/ref/how.html source"},{"id":2120,"pagetitle":"API","title":"AstroImages.powerdiststretch","ref":"/AstroImages/stable/api/#AstroImages.powerdiststretch","content":" AstroImages.powerdiststretch  —  Function powerdiststretch(num, a=1000) A power distance stretch as defined by astropy. source"},{"id":2121,"pagetitle":"API","title":"AstroImages.copyheader","ref":"/AstroImages/stable/api/#AstroImages.copyheader","content":" AstroImages.copyheader  —  Function copyheader(img::AstroImage, data) -> imgnew Create a new image copying the header of  img  but using the data of the AbstractArray  data . Note that changing the header of  imgnew  does not affect the header of  img . See also:  shareheader . source"},{"id":2122,"pagetitle":"API","title":"AstroImages.shareheader","ref":"/AstroImages/stable/api/#AstroImages.shareheader","content":" AstroImages.shareheader  —  Function shareheader(img::AstroImage, data) -> imgnew Create a new image reusing the header dictionary of  img  but using the data of the AbstractArray  data . The two images have synchronized header; modifying one also affects the other. See also:  copyheader . source"},{"id":2123,"pagetitle":"API","title":"AstroImages.recenter","ref":"/AstroImages/stable/api/#AstroImages.recenter","content":" AstroImages.recenter  —  Function recenter(img::AstroImage)\nrecenter(img::AstroImage, newcentx, newcenty, ...) Adjust the dimensions of an AstroImage so that they are centered on the pixel locations given by  newcentx , .. etc. This does not affect the underlying array, it just updates the dimensions associated with it by the AstroImage. If no  newcent  arguments are provided, center the image in all dimensions to the middle pixel (or fractional pixel). Example: a = AstroImage(randn(11,11))\na[1,1] # Bottom left\na[At(1),At(1)] # Bottom left\nr = recenter(a, 6, 6)\nr[1,1] # Still bottom left\nr[At(1),At(1)] # Center pixel source"},{"id":2126,"pagetitle":"Plotting Contours","title":"Contours","ref":"/AstroImages/stable/guide/contours/#Contours","content":" Contours This guide shows a few different ways to measure and visualize contours of images."},{"id":2127,"pagetitle":"Plotting Contours","title":"Using Plots","ref":"/AstroImages/stable/guide/contours/#Using-Plots","content":" Using Plots The most basic way to create a contour plot is simply to use Plots.jl  contour  and  contourf  functions on your image. Let's see how that works: using AstroImages, Plots\n\n\n# First load a FITS file of interest\nfname = download(\n    \"https://www.chandra.harvard.edu/photo/2014/archives/fits/herca/herca_radio.fits\",\n    \"herca-radio.fits\"\n)\n\nherca = load(\"herca-radio.fits\") Create a contour plot contour(herca) Create a filled contour plot contourf(herca) Specify the number of levels contour(herca, levels=5) Specify specific levels contour(herca, levels=[1, 1000, 5000]) Overplot contours on image: implot(herca)\ncontour!(herca, levels=4, color=:cyan)"},{"id":2128,"pagetitle":"Plotting Contours","title":"Using Contour.jl","ref":"/AstroImages/stable/guide/contours/#Using-Contour.jl","content":" Using Contour.jl For more control over how contours are calculated and plotted, you can use the  Contour.jl  package: using Contour\nherca = load(\"herca-radio.fits\")\n\np = implot(herca, cmap=nothing, colorbar=false)\n\n# Note: Contour.jl only supports float inputs.\n# See https://github.com/JuliaGeometry/Contour.jl/issues/73\nfor cl in levels(contours(dims(herca)..., float.(herca)))\n    lvl = level(cl) # the z-value of this contour level\n    for line in lines(cl)\n        xs, ys = coordinates(line) # coordinates of this line segment\n        plot!(p, xs, ys, line_z=lvl, label=\"\")\n    end\nend\n\np Here we plot just the contours, now in world coordinates: p = plot(xlabel=\"RA\", ylabel=\"DEC\")\nfor cl in levels(contours(dims(herca)..., float.(herca)))\n    lvl = level(cl) # the z-value of this contour level\n    for line in lines(cl)\n        xs, ys = coordinates(line) # coordinates of this line segment\n        worldcoords = map(zip(xs,ys)) do pixcoord\n            pix_to_world(herca, [pixcoord...])\n        end\n        plot!(p, getindex.(worldcoords,1), getindex.(worldcoords,2), line_z=lvl, label=\"\")\n    end\nend\np"},{"id":2131,"pagetitle":"Blurring & Filtering Images","title":"Image Filtering","ref":"/AstroImages/stable/guide/image-filtering/#Image-Filtering","content":" Image Filtering The package  ImageFiltering.jl  makes it easy to apply arbitrary filters to images."},{"id":2132,"pagetitle":"Blurring & Filtering Images","title":"Gaussian Blurs","ref":"/AstroImages/stable/guide/image-filtering/#Gaussian-Blurs","content":" Gaussian Blurs Let's start by downloading a radio image of Hercules A: using AstroImages\nusing ImageFiltering\n\nfname = download(\n    \"https://www.chandra.harvard.edu/photo/2014/archives/fits/herca/herca_radio.fits\",\n    \"herca-radio.fits\"\n)\n\nherca = load(\"herca-radio.fits\") Let's now apply a Gaussian blur (aka a low pass filter) using the  imfilter  function: herca_blur_20 = imfilter(herca, Kernel.gaussian(20.0)) The image has been smoothed out by convolving it with a wide Gaussian. Let's now do the opposite and perform a high-pass filter. This will bring out faint variations in structure. We can do this by subtracting a blurred image from the original: herca_blur_4 = imfilter(herca, Kernel.gaussian(4.0))\nherca_highpass = herca .- herca_blur_4 We now see lots of faint structure inside the jets! Finally, let's adjust how the image is displayed and apply a non-linear stretch: imview(\n    herca_highpass,\n    cmap=:seaborn_rocket_gradient,\n    clims=(-50,1500),\n    stretch=asinhstretch\n) If you have Plots loaded, we can add a colorbar and coordinate axes by switching to  implot : using Plots\nimplot(\n    herca_highpass,\n    cmap=:seaborn_rocket_gradient,\n    clims=(-50,1500),\n    stretch=asinhstretch\n)"},{"id":2133,"pagetitle":"Blurring & Filtering Images","title":"Median Filtering","ref":"/AstroImages/stable/guide/image-filtering/#Median-Filtering","content":" Median Filtering In addition to linear filters using  imfilter , ImageFiltering.jl also includes a great function called  mapwindow . This functions allows you to map an arbitrary function over a patch of an image. Let's use  mapwindow  to perform a median filter. This is a great way to suppress salt and pepper noise, or remove stars from some images. We'll use a Hubble picture of the Eagle nebula: using AstroImages\nusing ImageFiltering\n\nfname = download(\n    \"https://ds9.si.edu/download/data/673nmos.fits\",\n    \"eagle-673nmos.fits\"\n)\n\neagle673 = load(\"eagle-673nmos.fits\") The data is originally from  https://esahubble.org/projects/fits_liberator/eagledata/ . We can apply a median filter using  mapwindow . Make sure the patch size is an odd number in each direction! using Statistics\nmedfilt = copyheader(eagle673, mapwindow(median, eagle673, (11,11))) We use  copyheader  here since  mapwindow  returns a plain array and drops the image meta data. We can put this side by side with the original to see how some of the faint stars have been removed from the image: imview([eagle673[1:800,1:800]; medfilt[1:800,1:800]])"},{"id":2136,"pagetitle":"Transforming Images","title":"Image Transformations","ref":"/AstroImages/stable/guide/image-transformations/#Image-Transformations","content":" Image Transformations The  ImageTransformations.jl  package contains many useful functions for manipulating astronomical images. Note however that many of these functions drop the AstroImage wrapper and return plain arrays or OffsetArrays. They can be re-wrapped using  copyheader  or  shareheader  if you'd like to preserve the FITS header, dimension labels, WCS information, etc. You can install ImageTransformations by running  ] add ImageTransformations  at the REPL. For these examples, we'll download an image of the Antenae galaxies from Hubble: using AstroImages\nusing ImageTransformations\n\nfname = download(\n    \"https://esahubble.org/static/projects/fits_liberator/datasets/antennae/blue.fits\",\n    \"ant-blue.fits\"\n)\n\nantblue = load(\"ant-blue.fits\")\n\n# We'll change the defaults to avoid setting them each time\nAstroImages.set_clims!(Percent(99))\nAstroImages.set_cmap!(:ice)\nAstroImages.set_stretch!(asinhstretch)\n\nimview(antblue)"},{"id":2137,"pagetitle":"Transforming Images","title":"Rotations","ref":"/AstroImages/stable/guide/image-transformations/#Rotations","content":" Rotations We can rotate images using the  imrotate  function. imrotate(antblue, 3π/4) |> imview The rotation angle is in radians, but you can use the function  rad2deg  to convert from degrees."},{"id":2138,"pagetitle":"Transforming Images","title":"Resizing","ref":"/AstroImages/stable/guide/image-transformations/#Resizing","content":" Resizing We can resize images using the  imresize  function: imresize(antblue, ratio=0.2) |> imview"},{"id":2139,"pagetitle":"Transforming Images","title":"Arbitrary Transformations","ref":"/AstroImages/stable/guide/image-transformations/#Arbitrary-Transformations","content":" Arbitrary Transformations Arbitrary transformations can be performed using ImageTransformation's  warp  function. See the documentation linked above for more details."},{"id":2140,"pagetitle":"Transforming Images","title":"Mapping from One Coordinate System to Another","ref":"/AstroImages/stable/guide/image-transformations/#Mapping-from-One-Coordinate-System-to-Another","content":" Mapping from One Coordinate System to Another For transforming an image from one coordiante system (say, RA & DEC) to another (e.g., galactic lattitude & logitude), see  Reprojecting Images ."},{"id":2143,"pagetitle":"Extracting Photometry","title":"Photometry","ref":"/AstroImages/stable/guide/photometry/#Photometry","content":" Photometry The following examples are adapted from  Photometry.jl  to show the same examples combined with AstroImages.jl. To learn how to measure background levels, perform aperture photometry, etc see the  Photometry.jl documentation ."},{"id":2144,"pagetitle":"Extracting Photometry","title":"Background Estimation","ref":"/AstroImages/stable/guide/photometry/#Background-Estimation","content":" Background Estimation From Photometry.jl: Estimating backgrounds is an important step in performing photometry. Ideally, we could perfectly describe the background with a scalar value or with some distribution. Unfortunately, it's impossible for us to precisely separate the background and foreground signals. Here, we use mixture of robust statistical estimators and meshing to let us get the spatially varying background from an astronomical photo. Let's show an example [...] Now let's try and estimate the background using estimate_background. First, we'll si gma-clip to try and remove the signals from the stars. Then, the background is broken down into boxes, in this case of size (50, 50). Within each box, the given statistical estimators get the background value and RMS. By default, we use SourceExtractorBackground and StdRMS. This creates a low-resolution image, which we then need to resize. We can accomplish this using an interpolator, by default a cubic-spline interpolator via ZoomInterpolator. The end result is a smooth estimate of the spatially varying background and background RMS. using Photometry\nusing AstroImages\nusing Plots # optional, for implot functionality\n\n# Download our image, courtesy of astropy\nurl = \"https://rawcdn.githack.com/astropy/photutils-datasets/8c97b4fa3a6c9e6ea072faeed2d49a20585658ba/data/M6707HH.fits\"\nimage = AstroImage(download(url))\n\n# sigma-clip\nclipped = sigma_clip(image, 1, fill=NaN)\n\n# get background and background rms with box-size (50, 50)\nbkg, bkg_rms = estimate_background(clipped, 50)\n\nimview(image)\nimview(clipped)\nimview(bkg)\nimview(bkg_rms) Or, if you have Plots loaded: using Plots\n\nAstroImages.set_clims!(Percent(99.5))\nAstroImages.set_cmap!(:magma)\nAstroImages.set_stretch!(identity)\n\nplot(\n    implot(image, title=\"Original\"),\n    implot(clipped, title=\"Sigma-Clipped\"),\n    implot(bkg, title=\"Background\"),\n    implot(bkg_rms, title=\"Background RMS\"),\n    layout=(2, 2),\n    ticks=false,\n) We could apply a median filter, too, by specifying  filter_size # get background and background rms with box-size (50, 50) and filter_size (5, 5)\nbkg_f, bkg_rms_f = estimate_background(clipped, 50, filter_size=5)\n\n# plot\nplot(\n    implot(bkg, title=\"Unfiltered\", ylabel=\"Background\"),\n    implot(bkg_f, title=\"Filtered\"),\n    implot(bkg_rms, ylabel=\"RMS\"),\n    implot(bkg_rms_f);\n    layout=(2, 2),\n    ticks=false,\n) Now we can see our image after subtracting the filtered background and ready for Aperture Photometry! subt = image .- bkg_f[axes(image)...]\nclims = extrema(vcat(vec(image), vec(subt)))\nplot(\n    implot(image; title=\"Original\", clims),\n    implot(subt; title=\"Subtracted\", clims),\n    size=(1600,1000)\n)"},{"id":2145,"pagetitle":"Extracting Photometry","title":"Source Extraction","ref":"/AstroImages/stable/guide/photometry/#Source-Extraction","content":" Source Extraction From the background-subtracted image, we can detect all sources in the image: # We specify the uncertainty in the pixel data. We'll set it equal to zero.\nerrs = zeros(axes(subt))\nsources = extract_sources(PeakMesh(), subt, errs, true) # sort from brightest to darkest Table with 3 columns and 60924 rows:\n      x     y     value\n    ┌────────────────────\n 1  │ 255   226   9762.42\n 2  │ 940   681   9661.5\n 3  │ 219   924   9653.78\n 4  │ 38    678   9647.93\n 5  │ 245   85    9637.55\n 6  │ 44    1001  9633.13\n 7  │ 503   904   9627.34\n 8  │ 819   775   9625.92\n 9  │ 610   62    9617.79\n 10 │ 133   110   9616.88\n 11 │ 592   123   9614.86\n 12 │ 1055  248   9612.46\n 13 │ 424   86    9611.86\n 14 │ 558   125   9585.93\n 15 │ 125   1021  9582.11\n 16 │ 112   637   9579.71\n 17 │ 196   2     9579.49\n ⋮  │  ⋮     ⋮       ⋮ There's over 60,000 sources! We'll define a circular apperture for each source: aps = CircularAperture.(sources.x, sources.y, 6)[1:1000] # just brightest thousand point sources 1000-element Vector{CircularAperture{Int64}}:\n CircularAperture(255, 226, r=6)\n CircularAperture(940, 681, r=6)\n CircularAperture(219, 924, r=6)\n CircularAperture(38, 678, r=6)\n CircularAperture(245, 85, r=6)\n CircularAperture(44, 1001, r=6)\n CircularAperture(503, 904, r=6)\n CircularAperture(819, 775, r=6)\n CircularAperture(610, 62, r=6)\n CircularAperture(133, 110, r=6)\n ⋮\n CircularAperture(697, 975, r=6)\n CircularAperture(703, 599, r=6)\n CircularAperture(893, 878, r=6)\n CircularAperture(291, 457, r=6)\n CircularAperture(660, 855, r=6)\n CircularAperture(711, 920, r=6)\n CircularAperture(708, 271, r=6)\n CircularAperture(701, 273, r=6)\n CircularAperture(710, 273, r=6) We can overplot them on our original image. The coordinate sytem used by the Photometry.jl plot recipes (but not the actual return values) doesn't match AstroImages, so we must transpose our image: implot(subt', colorbar=false)\nplot!(aps)"},{"id":2146,"pagetitle":"Extracting Photometry","title":"Measuring Photometry","ref":"/AstroImages/stable/guide/photometry/#Measuring-Photometry","content":" Measuring Photometry Finally we can extract the source photometry table = photometry(aps, subt) Table with 3 columns and 1000 rows:\n      xcenter  ycenter  aperture_sum\n    ┌───────────────────────────────\n 1  │ 255      226      20542.4\n 2  │ 940      681      7125.3\n 3  │ 219      924      14741.0\n 4  │ 38       678      31056.4\n 5  │ 245      85       -910.308\n 6  │ 44       1001     2792.62\n 7  │ 503      904      6954.07\n 8  │ 819      775      -3136.61\n 9  │ 610      62       4338.13\n 10 │ 133      110      22219.0\n 11 │ 592      123      18562.2\n 12 │ 1055     248      3277.33\n 13 │ 424      86       255299.0\n 14 │ 558      125      6659.03\n 15 │ 125      1021     11524.1\n 16 │ 112      637      1349.78\n 17 │ 196      2        -797.491\n ⋮  │    ⋮        ⋮          ⋮ And plot them: scatter(\n    table.xcenter,\n    table.ycenter,\n    aspectratio=1,\n    marker_z=table.aperture_sum,\n    markerstrokewidth=0,\n    label=\"\",\n    framestyle=:box,\n    background_inside=:black,\n    color=:white\n)"},{"id":2149,"pagetitle":"Reprojecting Images","title":"Reprojecting Images","ref":"/AstroImages/stable/guide/reproject/#Reprojecting-Images","content":" Reprojecting Images Integration with the  Reproject.jl  package is not yet complete."},{"id":2152,"pagetitle":"Array Operations","title":"Array Operations","ref":"/AstroImages/stable/manual/array/#Array-Operations","content":" Array Operations You can operate on an  AstroImage  like any other Julia array. using AstroImages\n\nimg = AstroImage(randn(10,10))"},{"id":2153,"pagetitle":"Array Operations","title":"Indexing","ref":"/AstroImages/stable/manual/array/#Indexing","content":" Indexing You can look up individual pixels (see  Conventions ) img[1,1] # Bottom left 1.823493617711442 img[1:5,1:5]"},{"id":2154,"pagetitle":"Array Operations","title":"Broadcasting","ref":"/AstroImages/stable/manual/array/#Broadcasting","content":" Broadcasting AstroImages participate in broadcasting as expected: @. img + img^2 + 2img^3 You can update them in-place (if the underlying array you passed supports mutation) img[1:5,:] .= 0\nimg"},{"id":2157,"pagetitle":"Conventions","title":"Conventions","ref":"/AstroImages/stable/manual/conventions/#Conventions","content":" Conventions In the Julia Astro ecosystem, images follow the following conventions."},{"id":2158,"pagetitle":"Conventions","title":"Axes","ref":"/AstroImages/stable/manual/conventions/#Axes","content":" Axes For simple 2D images, the first axis is the horizontal axis and the second axis is the vertical axis. So images are indexed by  img[xi, yi] . The origin is at the bottom left of the image, so  img[1,1]  refers to the bottom left corner as does  img[begin,begin] .  img[end,end]  is the top right corner,  img[begin,end]  is the top left, etc. Note that this is transposed and flipped from how Julia prints arrays at the REPL."},{"id":2159,"pagetitle":"Conventions","title":"Pixels","ref":"/AstroImages/stable/manual/conventions/#Pixels","content":" Pixels This library considers the exact location of  img[1,1]  to be the center of the pixel in the bottom left corner. This means that plot limits should have the  1  tick slightly away from the left/bottom spines of the image. The default plot limits for  implot  are  -0.5  to  end+0.5  along both axes. There is a  known bug  with the Plots.jl GR backend that leads ticks to be slightly offset. PyPlot and Plotly backends show the correct tick locations."},{"id":2162,"pagetitle":"Converting from RGB","title":"Converting From RGB Images","ref":"/AstroImages/stable/manual/converting-from-rgb/#Converting-From-RGB-Images","content":" Converting From RGB Images If you encouter an image in a standard graphics format (e.g. PNG, JPG) that you want to analyze or store in an AstroImage, it will likely contain RGB (or similar) pixels. It is possible to store RGB data in an AstroImage. Let's see how that works: using AstroImages\ndownload(\"https://upload.wikimedia.org/wikipedia/commons/1/15/154-panel_Widefield_Milky_Way_Panorama.jpg\",\"mw-crop2-small.png\")\n\n# First we load it from the PNG file\nmw_png = load(\"mw-crop2-small.png\") You will need the Images.jl package installed to load formats like PNG. Once the RGB image is loaded, we can store it in an AstroImage if we'd like: mw_ai = AstroImage(mw_png) However, we may want to extract the RGB channels first. We can do this using  Images.channelview . Images.channelview  returns a view into the RGB data as a 3 × X × Y dimension cube. Unfortunately, we will have to permute the dimensions slightly. using Images\nmw_png = load(\"mw-crop2-small.png\")\nmw_chan_view = channelview(mw_png)\nmw_rgb_cube = AstroImage(\n    permutedims(mw_chan_view, (3, 2, 1))[:,end:-1:begin,:],\n    # Optional:\n    (X=:, Y=:, Spec=[:R,:G,:B])\n) ╭─────────────────────────────────╮ \n │  11096 × 2979 × 3  AstroImage{N0f8,3}  │ \n ├─────────────────────────────────┴────────────────────────────────────── dims ┐ \n   ↓ X    ,\n   → Y    ,\n   ↗ Spec  Categorical{Symbol}  [:R, :G, :B]   ReverseOrdered \n └──────────────────────────────────────────────────────────────────────────────┘ \n[ : ,  : ,  1 ]\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n ⋮                        ⋮              ⋱                 ⋮              \n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0 Here we chose to mark the third axis as a spectral axis with keys  :R ,  :G , and  :B . We can now visualize each channel: mw_rgb_cube[Spec=At(:R)] # Or just: mw_rgb_cube[:,:,1] imview(\n    mw_rgb_cube[Spec=At(:R)],\n    cmap=nothing # Grayscale mode\n) using Plots\nimplot(mw_rgb_cube[Spec=At(:B)])"},{"id":2165,"pagetitle":"Converting to RGB","title":"Converting to RGB","ref":"/AstroImages/stable/manual/converting-to-rgb/#Converting-to-RGB","content":" Converting to RGB If you have two or more images of the same scene taken at different wavelengths, you may wish to combine them to create a colour composite. For ultimate control, you can do this manually using  imview . Simply map your channels to  RGB  values using  imview  and then sum the results. For convenience, AstroImages.jl provides the function  composecolors ."},{"id":2166,"pagetitle":"Converting to RGB","title":"Using composecolors","ref":"/AstroImages/stable/manual/converting-to-rgb/#Using-composecolors","content":" Using  composecolors We'll demonstrate  composecolors  using Hubble images of the Antenae colliding galaxies. One can be very scientific about this process, but often the goal of producing color composites is aesthetic or about highlighting certain features for public consumption. I'll set the default color map to grayscale to avoid confusion. using AstroImages\n\nAstroImages.set_cmap!(nothing) Let's start by downloading the separate color channel FITS files: # We crop some of the images a bit to help align them with the other color channels\nantred = AstroImage(download(\"https://esahubble.org/static/projects/fits_liberator/datasets/antennae/red.fits\"))[:, begin+14:end] antgreen = AstroImage(download(\"https://esahubble.org/static/projects/fits_liberator/datasets/antennae/green.fits\")) antblue = AstroImage(download(\"https://esahubble.org/static/projects/fits_liberator/datasets/antennae/blue.fits\"))[:, begin+14:end] anthalph = AstroImage(download(\"https://esahubble.org/static/projects/fits_liberator/datasets/antennae/hydrogen.fits\"))[:, begin+14:end]; # Hydrogen-Alpha; we'll revisit later In order to compose these images, we'll have to match the relative intensity scales and clip outlying values. Thankfully,  composecolors  handles most of these details automatically. rgb1 = composecolors([antred, antgreen, antblue]) It's a start! Note For best results, the images should be properly aligned and cropped to the same size before making a color composite. The simple cropping we did here is just for demonstration purposes. By default, if you provide three images these are mapped to the color channels red, green, and blue. The intensities are limited to  Percent(99.5) . We can now tweak these defaults to our tastes. We could try clamping the intensities more agressively to bring out more of the galaxy structure: rgb2 = composecolors(\n    [antred, antgreen, antblue],\n    clims=Percent(97)\n) This looks okay but saturates the galaxy cores. Let's take care of that gash through the image by just blanking it out. mask = antgreen .== antgreen[end,begin]\n# remove holes in the mask\nusing ImageFiltering, Statistics\nmask = BitMatrix(mapwindow(median, mask, (3,3)))\nimview(mask) antred[mask] .= NaN\nantgreen[mask] .= NaN\nantblue[mask] .= NaN\nanthalph[mask] .= NaN Typically we need to perform a \"gamma correction\" aka non-lienar stretch to map the wide dynamic range of astronomical images into a narrower human visible range. We can do this using the  stretch  keyword. An  asinhstretch  is typically recommended when preparing RGB images: rgb3 = composecolors(\n    [antred, antgreen, antblue],\n    stretch=asinhstretch\n) Keywords like  strech ,  clims , etc can be either a single value for all channels or a list of separate values/functions per channel. The green channel appears to be quite faint compared to the red and blue channels. We can modify that by adjusting the relative intensities of the channels. We could also do this using a combination of the  contrast  and  bias  keywords. rgb4 = composecolors(\n    [antred, antgreen, antblue],\n    stretch=asinhstretch,\n    multiplier=[1,1.7,1]\n) That's better! Let's go one step further, and incorporate a fourth chanel: Hydrogen Alpha. Hydrogen Alpha is a narrow filter centered around one of the emission lines of Hydrogen atoms. It traces locations with hot gas; mostly star-formation regions in this case. imview(anthalph, cmap=:magma, clims=Zscale()) We'll now need to specify the color channels we want to use for each wavelength since we can't use just the default three RGB. We can use any named color or julia ColorScheme. rgb5 = composecolors(\n    [antred, antgreen, antblue, anthalph],\n    [\"red\", \"green\", \"blue\", \"maroon1\"],\n    stretch=asinhstretch,\n    multiplier=[1,1.7,1,0.8]\n) Additionally, I'd like to just show the brightest areas of Hydrogen alpha emission rather than adding a diffuse pink glow. We can turn off the stretch for this one channel: rgb6 = composecolors(\n    [antred, antgreen, antblue, anthalph],\n    [\"red\", \"green\", \"blue\", \"maroon1\"],\n    stretch=[\n        asinhstretch,\n        asinhstretch,\n        asinhstretch,\n        identity,\n    ],\n    multiplier=[1,1.7,1,0.8]\n) Finally, we can crop the image and save it as a PNG. crop = rgb6[200:end-100,50:end-50] save(\"antenae-composite.png\", crop) If you want to save it in a format like  JPG  that doesn't support transparent pixels, you could replace the masked area with zeros instead of  NaN ."},{"id":2169,"pagetitle":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","ref":"/AstroImages/stable/manual/dimensions-and-world-coordinates/#Dimensions-and-World-Coordinates","content":" Dimensions and World Coordinates AstroImages are based on  Dimensional Data . Each axis is assigned a dimension name and the indices are tracked."},{"id":2170,"pagetitle":"Dimensions and World Coordinates","title":"World Coordinates","ref":"/AstroImages/stable/manual/dimensions-and-world-coordinates/#World-Coordinates","content":" World Coordinates FITS files with world coordinate system (WCS) headers contain all the information necessary to map a pixel location into celestial coordinates & back. Let's see how this works with a 2D image with RA & DEC coordinates. using AstroImages\nusing Plots\n\n# Download a Hubble image of the Eagle nebula\ndownload(\n    \"https://ds9.si.edu/download/data/656nmos.fits\",\n    \"eagle-656nmos.fits\"\n);\neagle = load(\"eagle-656nmos.fits\") This image contains world coordinate system headers. AstroImages.jl uses WCS.jl (and wcslib under the hood) to parse these headers. We can generate a WCSTransform object to inspect: wcs(eagle, 1) # specify which coordinate system WCSTransform(naxis=2,cdelt=[1.0, 1.0],crval=[274.71149247724, -13.816384007184],crpix=[386.5, 396.0]) Note that we specify with an index which coordinate system we'd like to use. Most images just contain one, but some contain multiple systems. We can lookup a coordinate from the image: world = pix_to_world(eagle, [1, 1]) # Bottom left corner 2-element Vector{Float64}:\n 274.712299241082\n -13.801135972688115 Or convert back from world coordinates to pixel coordinates: We can lookup a coordinate from the image: world_to_pix(eagle, world) # Bottom left corner 2-element Vector{Float64}:\n 1.000000000336172\n 0.9999999992196535 These pixel coordinates do not necessarily have to lie within the bounds of the original image, and in general lie at a fractional pixel position. If an image contains WCS headers, we can visualize them using  implot : implot(eagle) We can adjust the color of the grid: implot(eagle, gridcolor=:cyan) If these aren't desired, we can turn off the grid or the WCS tick marks: plot(\n  implot(eagle, grid=false),\n  implot(eagle, wcsticks=false),\n  size=(900,300),\n  bottommargin=10Plots.mm\n) Since AstroImages are based on DimensionalData's AbstractDimArray, the mapping between pixel coordinates and world coordinates are preserved when slicing an AstroImage: slice1 = eagle[1:800,1:800]\nslice2 = eagle[800:1600,1:800]\nplot(\n  implot(slice1),\n  implot(slice2),\n  size=(900,300),\n  bottommargin=10Plots.mm\n) World coordinate queries from that slice are aware of their position in the parent image: @show pix_to_world(slice1, [1,1]) 2-element Vector{Float64}:\n 274.712299241082\n -13.801135972688115 @show pix_to_world(slice2, [1,1]) 2-element Vector{Float64}:\n 274.7277517847315\n -13.817350009028138 Note that you can query the dimensions of an image using the  dims  function from DimensionalData: dims(slice2) ( ↓ X  Sampled{Int64}  800:1600   ForwardOrdered   Regular   Points ,\n → Y  Sampled{Int64}  1:800   ForwardOrdered   Regular   Points )"},{"id":2171,"pagetitle":"Dimensions and World Coordinates","title":"Named Dimensions","ref":"/AstroImages/stable/manual/dimensions-and-world-coordinates/#Named-Dimensions","content":" Named Dimensions Each dimension of an AstroImage is named. The automatic dimension names are  X ,  Y ,  Z ,  Dim{4} ,  Dim{5} , and so on; however you can pass in other names or orders to the load function and/or AstroImage contructor: julia> img = load(\"eagle-656nmos.fits\", 1, (Y,Z))\n1600×1600 AstroImage{Float32,2} with dimensions:\n  Y Sampled 1:1600 ForwardOrdered Regular Points,\n  Z Sampled 1:1600 ForwardOrdered Regular Points Other useful dimension names are  Spec  for spectral axes,  Pol  for polarization data, and  Ti  for time axes. These are tracked the same way as the automatic dimension names and interact smoothly with any WCS headers. You can give a dimension an arbitrary name using  Dim{Symbol} , e.g.,  Dim{:Velocity} . You can access AstroImages using dimension names: eagle[X=100] ╭────────────────────────────────────╮ \n │  1600-element  AstroImage{Float32,1}  │ \n ├────────────────────────────────────┴─────────────────────────────────── dims ┐ \n   ↓ Y  Sampled{Int64}  1:1600   ForwardOrdered   Regular   Points \n └──────────────────────────────────────────────────────────────────────────────┘ \n     1   0.0\n     2   0.0\n     3   0.0\n     4   0.0\n     5   0.0\n     6   0.0\n    ⋮  \n  1596   0.0\n  1597   0.0\n  1598   0.0\n  1599   0.0\n  1600   0.0 When indexing into a slice out of a larger parent image or cube, this named access refers to the  parent  dimensions: slice1 = eagle[600:800,600:800]\nslice1[X=At(700),Y=At(700)] == eagle[X=At(700),Y=At(700)] == eagle[700,700] true"},{"id":2172,"pagetitle":"Dimensions and World Coordinates","title":"Cubes","ref":"/AstroImages/stable/manual/dimensions-and-world-coordinates/#Cubes","content":" Cubes Let's see how this works with a 3D cube. using AstroImages\n\nHIcube = load(download(\"https://www.astropy.org/astropy-data/tutorials/FITS-cubes/reduced_TAN_C14.fits\")) ╭───────────────────────────────────╮ \n │  150 × 150 × 450  AstroImage{Float32,3}  │ \n ├───────────────────────────────────┴──────────────────────────────────── dims ┐ \n   ↓ X  Sampled{Int64}  Base.OneTo(150)   ForwardOrdered   Regular   Points ,\n   → Y  Sampled{Int64}  Base.OneTo(150)   ForwardOrdered   Regular   Points ,\n   ↗ Z  Sampled{Int64}  Base.OneTo(450)   ForwardOrdered   Regular   Points \n └──────────────────────────────────────────────────────────────────────────────┘ \n[ : ,  : ,  1 ]\n    ↓   →      1      2      3      4      5      6   …   144    145    146    147    148    149    150 \n    1     NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n    2     NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n    3     NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n    4     NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n   ⋮                          ⋮       ⋱         ⋮                        ⋮\n  147     NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n  148     NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n  149     NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n  150     NaN  NaN  NaN  NaN  NaN  NaN  …  NaN  NaN  NaN  NaN  NaN  NaN  NaN Notice how the cube is not displayed automatically. We have to pick a specific slice: HIcube[Z=228] Using  implot , the world coordinates are displayed automatically: implot(HIcube[Z=228], cmap=:turbo) The plot automatically reflects the world coordinates embeded in the file. It displays the x axis in galactic longitude, the y-axis in galactic latitude, and even shows the curved projection from pixel coordinates to galactic coordinates. The title is automatically set to the world coordinate along the Z axis in units of velocity. It also picks up the unit of the data (Kelvins) to display on the colorbar. If we pick another slice, the title updates accordingly: implot(HIcube[Z=308], cmap=:turbo) This works for other slices through the cube as well: implot(HIcube[Y=45],  cmap=:turbo, aspectratio=0.3)"},{"id":2173,"pagetitle":"Dimensions and World Coordinates","title":"Custom Dimensions","ref":"/AstroImages/stable/manual/dimensions-and-world-coordinates/#Custom-Dimensions","content":" Custom Dimensions julia> img = load(\"img.fits\",1,(Y=1:1600,Z=1:1600))\n1600×1600 AstroImage{Float32,2} with dimensions:\n  Y Sampled 1:1600 ForwardOrdered Regular Points,\n  Z Sampled 1:1600 ForwardOrdered Regular Points Other useful dimension names are  Spec  for spectral axes,  Pol  for polarization data, and  Ti  for time axes. These are tracked the same was as the automatic dimension names and interact smoothly with any WCS headers. Often times we have images or cubes that we want to index with physical coordinates where setting up a full WCS transform is overkill. In these cases, it's easier to leverage custom dimensions. For example, one may wish to julia> img = load(\"img.fits\",1,(X=801:2400,Y=1:2:3200))\n1600×1600 AstroImage{Float32,2} with dimensions:\n  X Sampled 801:2400 ForwardOrdered Regular Points,\n  Y Sampled 1:2:3199 ForwardOrdered Regular Points\n... Unlike OffsetArrays, the usual indexing remains so  img[1,1]  is still the bottom left of the image; however, data can be looked up according to the offset dimensions using specifiers: julia> img[X=Near(2000),Y=1..100]\n50-element AstroImage{Float32,1} with dimensions:\n  Y Sampled 1:2:99 ForwardOrdered Regular Points\nand reference dimensions:\n  X Sampled 2000:2000 ForwardOrdered Regular Points\n  0.0 You can adjust the center of an image's dimensions using  recenter : eagle_cen = recenter(eagle, 801, 801); Unlike an OffsetArray,  eagle_cen[1,1]  still refers to the bottom left of the image. This also has no effect on broadcasting;  eagle_cen .+ ones(1600,1600)  is perfectly valid. However, we see the new centered dimensions when we go to plot the image: implot(eagle_cen, wcsticks=false) And we can query positions using the offset dimensions: implot(eagle_cen[X=-300..300, Y=-300..300], wcsticks=false)"},{"id":2176,"pagetitle":"Displaying Images","title":"Displaying Images","ref":"/AstroImages/stable/manual/displaying-images/#Displaying-Images","content":" Displaying Images The  imview  and  implot  functions are very similar. Both allow any abstract array of numbers to be rendered into an image or a Plots.jl image series.  implot  is largely a superset of  imview  because it also supports colorbars, tick marks, WCS grid lines, overplotting other data & shapes, and automatic axis and title naming (from the FITS header if available)."},{"id":2177,"pagetitle":"Displaying Images","title":"imview","ref":"/AstroImages/stable/manual/displaying-images/#imview","content":" imview Any AbstractArray (including an AstroImage) can be displayed using  imview . This function renders an arbitrary array into an array of  RGBA  values using a number of parameters. If the input is an AstroImage{<:Number}, an AstroImage{RGBA} will be returned that retains headers, WCS information, etc. The defaults for the  imview  function are: img = randn(50,50);\nimview(img; clims=Percent(99.5), cmap=:magma, stretch=identity, contrast=1.0, bias=0.5) We can adjust the color limits explicitly: imview(img; clims=(-1, 1)) Or pass a function/callable object to calculate them for us: imview(img; clims=Zscale()) We can turn off the colormap and use it in grayscale mode: imview(img; cmap=nothing) Pass any color scheme from ColorSchemes.jl: imview(img; cmap=:ice) imview(img; cmap=:seaborn_rocket_gradient) Or an RGB or named color value: imview(img; cmap=\"#F00\")\nimview(img; cmap=\"red\") Let's now switch to an astronomical image: fname = download(\n    \"https://ds9.si.edu/download/data/656nmos.fits\",\n    \"eagle-656nmos.fits\"\n);\neagle = AstroImage(\"eagle-656nmos.fits\") We can apply a non-linear stretch like a log-scale, power-scale, or asinh stretch: imview(eagle, stretch=asinhstretch) Once rendered, we can also tweak the bias and contrast: imview(eagle, stretch=asinhstretch, contrast=1.5) imview(eagle, stretch=asinhstretch, contrast=1.5, bias=0.6) These are the parameters that change when you click and drag in some applications like DS9. Once rendered via  imview , the resulting image can be saved in traditional image formats like PNG, JPG, GIF, etc: save(\"out.png\", imview(eagle, cmap=:viridis)) Very large Images are automatically downscaled to ensure consistent performance using  restrict  from Images.jl. This function filters the data before downscaling to prevent aliasing, so it may take a moment for truly huge images. In these cases, a faster method that doesn't prevent aliasing would be  imview(img[begin:10:end, begin:10:end])  or similar. imview  is called automatically on  AstroImage{<:Number}  when using a Julia environment with rich graphical IO capabilities (e.g. VSCode, Jupyter, Pluto, etc.). The defaults for this case can be modified using  AstroImages.set_clims!(...) ,  AstroImages.set_cmap!(...) , and  AstroImages.set_stretch!(...) ."},{"id":2178,"pagetitle":"Displaying Images","title":"Note on Views","ref":"/AstroImages/stable/manual/displaying-images/#Note-on-Views","content":" Note on Views The function  imview  has its name because it produces a \"view\" into the image. The result from calling  imview  is an object that lazily maps data values into RGBA colors on the fly. This means that if you change the underlying data array, the view will update (the next time it is shown). If you have many data files to render, you may find it faster to create a single  imview  and then mutate the data in the underlying array. This is faster since  imview  only has to resolve colormaps and compute limits once. For example: data = randn(100,100)\niv = imview(data)\ndisplay(iv)\ndata[1:50,1:50] .= 0\ndisplay(iv) iv  will reflect the changes to  data  when it is displayed the second time."},{"id":2179,"pagetitle":"Displaying Images","title":"implot","ref":"/AstroImages/stable/manual/displaying-images/#implot","content":" implot implot   is a Plots.jl recipe, which means before you can use it you first have to load  Plots.jl : using Plots implot  accepts all the arguments  imview  does for controlling how data is rendered to the screen: implot(img; clims=Percent(99.5), cmap=:magma, stretch=identity, contrast=1.0, bias=0.5) For more on  implot , including offset dimensions and world coordinates, see  Dimensions and World Coordinates ."},{"id":2182,"pagetitle":"Getting Started","title":"Getting Started","ref":"/AstroImages/stable/manual/getting-started/#Getting-Started","content":" Getting Started To get started, you will first need to install AstroImages. After starting Julia, enter package-mode by typing  ]  and then pkg> add AstroImages To display images and save them in traditional graphics formats like PNG, JPG, GIF, etc., you will also need to add the  ImageIO  package. Once installed, this package doesn't need to be loaded explicitly. For some of the more advanced visualizations you may also want  Plots : pkg> add Plots To load the package, run: using AstroImages\n# And if desired:\nusing Plots"},{"id":2185,"pagetitle":"Headers","title":"Headers","ref":"/AstroImages/stable/manual/headers/#Headers","content":" Headers FITS files consist of one or more HDUs (header data units), and each HDU can contain an N-dimensional image or table. Before the data is a  header . Headers contain (key, value, comment) groups as well as dedicated long-form COMMENT and HISTORY sections used to document, for example, the series of post-processing steps applied to an image."},{"id":2186,"pagetitle":"Headers","title":"Accessing Headers","ref":"/AstroImages/stable/manual/headers/#Accessing-Headers","content":" Accessing Headers Here are some examples of how to set and read keys, comments, and history. Well start by making a blank image. img = AstroImage(zeros(10,10))\n# Set keys to values with different data types\nimg[\"KEY1\"] = 2   # Integer\nimg[\"KEY2\"] = 2.0 # Float\nimg[\"KEY3\"] = \"STRING\"\nimg[\"KEY4\"] = true\nimg[\"KEY5\"] = false\nimg[\"KEY6\"] = nothing\n\n# Set comments\nimg[\"KEY1\", Comment] = \"A key with an integer value\"\n\n# Read keys\na = img[\"KEY3\"]\n\n# Read comment\ncom = img[\"KEY1\", Comment]\n\n# Add long-form COMMENT\npush!(img, Comment, \"\"\"\nWe now describe how to add a long form comment to the end of a header.\n\"\"\")\n\n# Add HISTORY entry\npush!(img, History, \"\"\"\nWe now describe how to add a long form history to the end of a header.\n\"\"\")\n\n# Retrieve long form comments/ history\ncomment_strings = img[Comment]\nhistory_strings = img[History] Note that floating point values are formatted as ASCII strings when written to the FITS files, so the precision may be limited. AstroImage  objects wrap a FITSIO.jl  FITSHeader . If necessary, you can recover it using  header(img) ; however, in most cases you can access header keywords directly from the image. API docs: Comment History header"},{"id":2189,"pagetitle":"Loading & Saving Images","title":"Loading Images","ref":"/AstroImages/stable/manual/loading-images/#Loading-Images","content":" Loading Images FITS (Flexible Image Transport System) files can be loaded and saved using AstroImages thanks to the FITSIO package. AstroImages is registered with  FileIO , so if you have FileIO and AstroImages installed you can get started with the  load  function. When you pass a file name with the appropriate file extension (\".fits\", \".fit\", etc.) FileIO will import AstroImages automatically. Alternatively, you can use the  AstroImage  contructor instead of load. This will work on fits files with any file extension, including compressed files (e.g. \".fits.gz\"). julia> img = load(\"myfitsimg.fits\")\n1600×1600 AstroImage{Float32,2} with dimensions:\n  X Sampled Base.OneTo(1600) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(1600) ForwardOrdered Regular Points\n 0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n ⋮                        ⋱\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0 Note: if you are in an interactive environment like VSCode, Jupyter, or Pluto, instead of a REPL, AstroImages are automatically rendered to images and displayed. You can see this plain text output by explicitly calling:  show(stdout, MIME(\"text/plain\"), img) . Or: julia> img = AstroImage(\"myfitsimg.fits.gz\")\n1600×1600 AstroImage{Float32,2} with dimensions:\n  X Sampled Base.OneTo(1600) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(1600) ForwardOrdered Regular Points\n 0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n ⋮                        ⋱\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0 A FITS file can contain multiple N-dimensional images and tables. When you call load or AstroImage with a file name and no other arguments, the package will search through the file and return the first image HDU. That is, it will skip any FITS tables or empty HDUs with only headers. You can also specify an HDU number explicitly: julia> img = load(\"myfitsimg.fits\",1)\n1600×1600 AstroImage{Float32,2} with dimensions:\n  X Sampled Base.OneTo(1600) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(1600) ForwardOrdered Regular Points\n... This way, you can load specific images from multi-extension files. You can load all HDUs simultaneously by passing  : : julia> hdus = load(\"multiext.fits\", :);\njulia> hdus[2] # Second HDU as an AstroImage\n10×10 AstroImage{Float64,2} with dimensions:\n  X Sampled Base.OneTo(10) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(10) ForwardOrdered Regular Points\n -0.777315  -1.36683   -0.580179     1.39629      …  -2.14298     0.450059   0.432065\n -1.09619    0.789249   0.938415     0.959903        -0.88995    -1.29406   -0.4291\n  0.47427   -1.41855    0.814823    -1.15975          0.0427149  -1.20116   -0.0920709\n -0.179858  -1.60228    1.09648     -0.497927        -1.31824    -0.156529  -0.0223846\n  2.64162    0.131437   0.320476     0.331197        -0.914713   -1.55162   -0.18862\n  0.209669  -1.17923   -0.656512     0.000775311  …   0.377461   -0.24278    0.967202\n  1.01442   -0.762895  -2.13238     -0.456932        -0.415733   -1.21416   -1.6108\n  0.385626   0.389335  -0.00726015   0.309936        -0.533175    0.157878   0.100876\n -1.24799    0.461216  -0.868826    -0.255654        -0.37151     0.49479   -1.87129\n  1.39356    2.29254    0.0548325    1.50674         -0.0880865   0.580978  -1.81629\njulia> # Or:\njulia> hdu1, hdu2, hdu3 = load(\"multiext.fits\", :); There is also limited support for table HDUs. In this case, a bare-bones Tables.jl compatible object is returned."},{"id":2190,"pagetitle":"Loading & Saving Images","title":"Dimension Names","ref":"/AstroImages/stable/manual/loading-images/#Dimension-Names","content":" Dimension Names You may have noticed the entries above the image array: 10×10 AstroImage{Float64,2} with dimensions:\n  X Sampled Base.OneTo(10) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(10) ForwardOrdered Regular Points AstroImages are based on  Dimensional Data . Each axis is assigned a dimension name and the indices are tracked. The automatic dimension names are  X ,  Y ,  Z ,  Dim{4} ,  Dim{5} , and so on; however you can pass in other names or orders to the load function and/or AstroImage contructor: julia> img = load(\"img.fits\", 1, (Y=1:1600,Z=1:1600))\n1600×1600 AstroImage{Float32,2} with dimensions:\n  Y Sampled 1:1600 ForwardOrdered Regular Points,\n  Z Sampled 1:1600 ForwardOrdered Regular Points Other useful dimension names are  Spec  for spectral axes,  Pol  for polarization data, and  Ti  for time axes. These will be further discussed in Dimensions and World Coordinates."},{"id":2191,"pagetitle":"Loading & Saving Images","title":"Saving Images","ref":"/AstroImages/stable/manual/loading-images/#Saving-Images","content":" Saving Images You can save one or more AstroImages and tables to a FITS file using the  save  function: julia> save(\"abc.fits\", astroimage1, astroimage2, table1) You can also save individual images to traditional graphics formats by first rendering them with  imview  (for more on imview, see Displaying Images). julia> save(\"abc.png\", imview(astroimage1)) You can save animated GIFs by saving a 3D datacube that has been rendered with imview: julia> cube =  imview(AstroImage(randn(100,100,10)));\njulia> save(\"abc.gif\", cube, fps=10)\n\njulia> # Or a more complex example (changing color schemes each frame)\njulia> img = randn(10,10)\njulia> cube2 = [imview(img1, cmap=:magma) ;;; imview(img2, cmap=:plasma) ;;; imview(img3, cmap=:viridis)]\n\njulia> # Alternative syntax:\njulia> cube2 = cat(imview(img1, cmap=:magma), imview(img2, cmap=:plasma), imview(img3, cmap=:viridis), dims=3)\n\njulia> save(\"abc.gif\", cube, fps=10)"},{"id":2196,"pagetitle":"Preserving Wrapper","title":"Preserving the AstroImage Wrapper","ref":"/AstroImages/stable/manual/preserving-wrapper/#Preserving-the-AstroImage-Wrapper","content":" Preserving the AstroImage Wrapper Wherever possible, overloads have been added to DimensionalData and AstroImages so that common operations retain the  AstroImage  wrapper with associated dimensions, FITS header, and WCS information. Most of the time this works automatically if libraries follow good patterns like allocating outputs using  Base.similar . However, some other library functions may follow patterns like allocating a plain  Array  of the correct size and then filling it. To make it easier to work with these libraries, AstroImages exports two functions  copyheader  and  shareheader . These functions wrap an AbstractArray in an AstroImage while copying over the header, dimensions, and WCS info. Consider the function: function badfunc(arr)\n    out = zeros(size(arr)) # instead of similar(arr)\n    out .= arr.^2\n    return out\nend Calling  badfunc(astroimg)  will return a plain  Array  . We can use  copyheader  to retain the  AstroImage  wrapper: copyheader(astroimg, badfunc(astroimg)) For particularly incompatible functions that require an Array (not subtype of AbstractArray) we can go one step further: copyheader(astroimg, worsefunc(parent(astroimg)))\n# Or:\ncopyheader(astroimg, worsefunc(collect(astroimg)))"},{"id":2201,"pagetitle":"Home","title":"AstroAngles.jl","ref":"/AstroAngles/stable/#AstroAngles.jl","content":" AstroAngles.jl Lightweight string parsing and representation of angles."},{"id":2202,"pagetitle":"Home","title":"Installation","ref":"/AstroAngles/stable/#Installation","content":" Installation To install use  Pkg . From the REPL, press  ]  to enter Pkg-mode pkg> add AstroAngles If you want to use the most up-to-date version of the code, check it out from  main pkg> add AstroAngles#main"},{"id":2203,"pagetitle":"Home","title":"Usage","ref":"/AstroAngles/stable/#Usage","content":" Usage"},{"id":2204,"pagetitle":"Home","title":"Angle Parsing Utilities","ref":"/AstroAngles/stable/#Angle-Parsing-Utilities","content":" Angle Parsing Utilities String representations of angles in both \"degree:arcmin:arcsec\" and  \"hour:min:sec\" format can be parsed using a variety of delimiters, which can be mixed together (e.g. can use  °  after degrees but  :  after the arcminutes). The directions \"S\" and \"W\" are considered negative and \"-1:0:0S\" is 1 degree North, for example."},{"id":2205,"pagetitle":"Home","title":"dms formats","ref":"/AstroAngles/stable/#dms-formats","content":" dms formats \"[+-]xx:xx:xx.x[NESW]\"\n\"[+-]xx xx xx.x[NESW]\"\n\"[+-]xxdxxmxx.xs[NESW]\"\n\"[+-]xx°xx'xx.x\\\"[NESW]\"\n\"[+-]xx°xx′xx.x″[NESW]\" # \\prime, \\pprime"},{"id":2206,"pagetitle":"Home","title":"hms formats","ref":"/AstroAngles/stable/#hms-formats","content":" hms formats \"[+-]xx:xx:xx.x[NESW]\"\n\"[+-]xx xx xx.x[NESW]\"\n\"[+-]xxhxxmxx.xs[NESW]\"\n\"[+-]xxhxx'xx.x\\\"[NESW]\"\n\"[+-]xx°xx′xx.x″[NESW]\" the simplest way to convert is to use the  @dms_str  and  @hms_str  macros, which allows you to choose the output angle type julia> dms\"12:17:25.3\"\n0.21450726764795752\n\njulia> dms\"12:17:25.3\"rad # default\n0.21450726764795752\n\njulia> dms\"12:17:25.3\"deg\n12.29036111111111\n\njulia> dms\"12:17:25.3\"ha\n0.8193574074074074 here is a showcase of the variety of ways to parse inputs julia> dms\"10.2345d\"deg\n10.2345\n\njulia> dms\"1:2:30.43\"deg\n1.041786111111111\n\njulia> hms\"1 2 0\"ha\n1.0333333333333334\n\njulia> dms\"1°2′3″\"deg\n1.0341666666666667\n\njulia> dms\"1°2′3″N\"deg\n1.0341666666666667\n\njulia> dms\"1d2m3.4s\"deg\n1.0342777777777779\n\njulia> dms\"1d2m3.4sS\"deg\n-1.0342777777777779\n\njulia> hms\"-1h2m3s\"ha\n-1.0341666666666667\n\njulia> hms\"-1h2m3sW\"ha\n1.0341666666666667 for more control on the output, you can use the  parse_dms  and  parse_hms  methods, which returns a tuple of the parsed  dms  or  hms  values parse_dms # string -> (deg, arcmin, arcsec)\nparse_hms # string -> (hours, mins, secs) julia> parse_dms(\"12:17:25.3\")\n(12.0, 17.0, 25.3)\n\njulia> parse_hms(\"-4:4:6\")\n(-4.0, 4.0, 6.0)"},{"id":2207,"pagetitle":"Home","title":"Angle Conversion Utilities","ref":"/AstroAngles/stable/#Angle-Conversion-Utilities","content":" Angle Conversion Utilities The following methods are added for converting to and from hour angles deg2ha # degrees -> hour angles\nrad2ha # radians -> hour angles\nha2deg # hour angles -> degrees\nha2rad # hour angles -> radians The following methods convert from angles as a single number to tuples consistent with sexagesimal deg2dms # degrees -> (deg, arcmin, arcsec)\nrad2dms # radians -> (deg, arcmin, arcsec)\nha2dms  # hour angles -> (deg, arcmin, arcsec)\n\ndeg2hms # degrees -> (hours, mins, secs)\nrad2hms # radians -> (hours, mins, secs)\nha2hms  # hour angles -> (hours, mins, secs) and the inverse dms2deg # (deg, arcmin, arcsec) -> degrees\ndms2rad # (deg, arcmin, arcsec) -> radians\ndms2ha  # (deg, arcmin, arcsec) -> hour angles\n\nhms2deg # (hours, mins, secs) -> degrees\nhms2rad # (hours, mins, secs) -> radians\nhms2ha  # (hours, mins, secs) -> hour angles the above functions can take a string as input and will automatically parse it (using  parse_dms  or  parse_hms , respectively) before converting."},{"id":2208,"pagetitle":"Home","title":"Formatting angles","ref":"/AstroAngles/stable/#Formatting-angles","content":" Formatting angles Lastly, we have some simple methods for formatting angles into strings, although for more fine-tuned control we recommend using  Printf  or a package like  Format.jl .  format_angle  takes parts (like from  deg2dms  or  rad2hms ) and a delimiter (or collection of 3 delimiters for each value). julia> format_angle(deg2dms(45.0))\n\"45:0:0.0\"\n\njulia> format_angle(deg2hms(-65.0); delim=[\"h\", \"m\", \"s\"])\n\"-4h19m59.999999999998934s\""},{"id":2209,"pagetitle":"Home","title":"Example: reading coordinates from a table","ref":"/AstroAngles/stable/#Example:-reading-coordinates-from-a-table","content":" Example: reading coordinates from a table Here's an example of reading sky coordinates from a CSV formatted target list and converting them to degrees: julia> using AstroAngles, CSV, DataFrames\n\njulia> table = CSV.File(\"target_list.csv\") |> DataFrame;\n\njulia> [table.ra table.dec]\n203×2 Matrix{String}:\n \"00 05 01.42\"  \"40 03 35.82\"\n \"00 05 07.52\"  \"73 13 11.34\"\n \"00 36 01.40\"  \"-11 12 13.00\"\n[...]\n\njulia> ra_d = @. hms2deg(table.ra)\n203-element Vector{Float64}:\n   1.2559166666666666\n   1.2813333333333332\n   9.005833333333333\n[...]\n\njulia> dec_d = @. dms2deg(table.dec)\n203-element Vector{Float64}:\n  40.05995\n  73.21981666666667\n -11.203611111111112\n[...]"},{"id":2210,"pagetitle":"Home","title":"Contributing/Support","ref":"/AstroAngles/stable/#Contributing/Support","content":" Contributing/Support To contribute, feel free to open a  pull request . If you run into problems, please open an  issue . To discuss ideas, usage, or to plan contributions, open a new  discussion ."},{"id":2211,"pagetitle":"Home","title":"License","ref":"/AstroAngles/stable/#License","content":" License This code is MIT licensed. For more information, see the LICENSE file in the AstroAngles.jl repository."},{"id":2214,"pagetitle":"API Reference","title":"API Reference","ref":"/AstroAngles/stable/api/#API-Reference","content":" API Reference"},{"id":2215,"pagetitle":"API Reference","title":"AstroAngles.deg2dms","ref":"/AstroAngles/stable/api/#AstroAngles.deg2dms-Tuple{Any}","content":" AstroAngles.deg2dms  —  Method deg2dms(angle) Convert degrees to (degrees, arcminutes, arcseconds) tuple source"},{"id":2216,"pagetitle":"API Reference","title":"AstroAngles.deg2ha","ref":"/AstroAngles/stable/api/#AstroAngles.deg2ha-Tuple{Any}","content":" AstroAngles.deg2ha  —  Method deg2ha(angle) Convert degrees to hour angles source"},{"id":2217,"pagetitle":"API Reference","title":"AstroAngles.deg2hms","ref":"/AstroAngles/stable/api/#AstroAngles.deg2hms-Tuple{Any}","content":" AstroAngles.deg2hms  —  Method deg2hms(angle) Convert degrees to (hours, minutes, seconds) tuple source"},{"id":2218,"pagetitle":"API Reference","title":"AstroAngles.dms2deg","ref":"/AstroAngles/stable/api/#AstroAngles.dms2deg-Tuple{Any, Any, Any}","content":" AstroAngles.dms2deg  —  Method dms2deg(degrees, arcmin, arcsec)\ndms2deg(parts)\ndms2deg(input::AbstractString) Convert (degrees, arcminutes, arcseconds) tuple to degrees. If a string is given, will parse with  parse_dms  first. If an angle is input will treat as a no-op. source"},{"id":2219,"pagetitle":"API Reference","title":"AstroAngles.dms2ha","ref":"/AstroAngles/stable/api/#AstroAngles.dms2ha-Tuple{Any, Any, Any}","content":" AstroAngles.dms2ha  —  Method dms2ha(degrees, arcmin, arcsec)\ndms2ha(parts)\ndms2ha(input::AbstractString) Convert (degrees, arcminutes, arcseconds) tuple to hour angles. If a string is given, will parse with  parse_dms  first. If an angle is input will treat as a no-op. source"},{"id":2220,"pagetitle":"API Reference","title":"AstroAngles.dms2rad","ref":"/AstroAngles/stable/api/#AstroAngles.dms2rad-Tuple{Any, Any, Any}","content":" AstroAngles.dms2rad  —  Method dms2rad(degrees, arcmin, arcsec)\ndms2rad(parts)\ndms2rad(input::AbstractString) Convert (degrees, arcminutes, arcseconds) tuple to radians. If a string is given, will parse with  parse_dms  first. If an angle is input will treat as a no-op. source"},{"id":2221,"pagetitle":"API Reference","title":"AstroAngles.format_angle","ref":"/AstroAngles/stable/api/#AstroAngles.format_angle-Tuple{Any}","content":" AstroAngles.format_angle  —  Method format_angle(parts; delim=':') Given the  (whole, minutes, seconds)  parts of an angle, will format into a string with the given delimiter(s). These parts can be generated by the  xxx2dms  and  xxx2hms  methods, for sexagesimal and  hour:minute:second  outputs. Multiple delimiters can be given in a tuple or vector placed after their respective values. For more control over formatting, consider using  Printf  or a package like  Format.jl . Examples julia> ang = 45.0; # degrees\n\njulia> format_angle(deg2dms(ang))\n\"45:0:0.0\"\n\njulia> format_angle(deg2hms(ang))\n\"3:0:0.0\"\n\njulia> format_angle(rad2hms(1.5), delim=[\"h\", \"m\", \"s\"])\n\"5h43m46.48062470963538s\" See also deg2dms ,  deg2hms ,  rad2dms ,  rad2hms ,  ha2dms ,  ha2hms source"},{"id":2222,"pagetitle":"API Reference","title":"AstroAngles.ha2deg","ref":"/AstroAngles/stable/api/#AstroAngles.ha2deg-Tuple{Any}","content":" AstroAngles.ha2deg  —  Method ha2deg(angle) Convert hour angles to degrees source"},{"id":2223,"pagetitle":"API Reference","title":"AstroAngles.ha2dms","ref":"/AstroAngles/stable/api/#AstroAngles.ha2dms-Tuple{Any}","content":" AstroAngles.ha2dms  —  Method ha2dms(angle) Convert hour angles to (degrees, arcminutes, arcseconds) tuple source"},{"id":2224,"pagetitle":"API Reference","title":"AstroAngles.ha2hms","ref":"/AstroAngles/stable/api/#AstroAngles.ha2hms-Tuple{Any}","content":" AstroAngles.ha2hms  —  Method ha2hms(angle) Convert hour angles to (hours, minutes, seconds) tuple source"},{"id":2225,"pagetitle":"API Reference","title":"AstroAngles.ha2rad","ref":"/AstroAngles/stable/api/#AstroAngles.ha2rad-Tuple{Any}","content":" AstroAngles.ha2rad  —  Method ha2rad(angle) Convert hour angles to radians source"},{"id":2226,"pagetitle":"API Reference","title":"AstroAngles.hms2deg","ref":"/AstroAngles/stable/api/#AstroAngles.hms2deg-Tuple{Any, Any, Any}","content":" AstroAngles.hms2deg  —  Method hms2deg(hours, mins, secs)\nhms2deg(parts)\nhms2deg(input::AbstractString) Convert (hours, minutes, seconds) tuple to degrees. If a string is given, will parse with  parse_hms  first. If an angle is input will treat as a no-op. source"},{"id":2227,"pagetitle":"API Reference","title":"AstroAngles.hms2ha","ref":"/AstroAngles/stable/api/#AstroAngles.hms2ha-Tuple{Any, Any, Any}","content":" AstroAngles.hms2ha  —  Method hms2ha(hours, mins, secs)\nhms2ha(parts)\nhms2ha(input::AbstractString) Convert (hours, minutes, seconds) tuple to hour angles. If a string is given, will parse with  parse_hms  first. If an angle is input will treat as a no-op. source"},{"id":2228,"pagetitle":"API Reference","title":"AstroAngles.hms2rad","ref":"/AstroAngles/stable/api/#AstroAngles.hms2rad-Tuple{Any, Any, Any}","content":" AstroAngles.hms2rad  —  Method hms2rad(hours, mins, secs)\nhms2rad(parts)\nhms2rad(input::AbstractString) Convert (hours, minutes, seconds) tuple to radians. If a string is given, will parse with  parse_hms  first. If an angle is input will treat as a no-op. source"},{"id":2229,"pagetitle":"API Reference","title":"AstroAngles.parse_dms","ref":"/AstroAngles/stable/api/#AstroAngles.parse_dms-Tuple{Any}","content":" AstroAngles.parse_dms  —  Method parse_dms(input) Parses a string input in \"deg:arcmin:arcsec\" format to the tuple  (degrees, arcminutes, arcseconds) . The following delimiters will all work and can be mixed together (the last delimiter is optional): \"[+-]xx[°d: ]xx['′m: ]xx[\\\"″s][NESW]\" if the direction is provided, \"S\" and \"E\" are considered negative (and \"-1:0:0S\" is 1 degree North) source"},{"id":2230,"pagetitle":"API Reference","title":"AstroAngles.parse_hms","ref":"/AstroAngles/stable/api/#AstroAngles.parse_hms-Tuple{Any}","content":" AstroAngles.parse_hms  —  Method parse_hms(input) Parses a string input in \"ha:min:sec\" format to the tuple  (hours, minutes, seconds) . The following delimiters will all work and can be mixed together (the last delimiter is optional): \"[+-]xx[h ]xx['′m: ]xx[\\\"″s][EW]\" if the direction is provided, \"S\" and \"E\" are considered negative (and \"-1:0:0W\" is 1 degree East) source"},{"id":2231,"pagetitle":"API Reference","title":"AstroAngles.rad2dms","ref":"/AstroAngles/stable/api/#AstroAngles.rad2dms-Tuple{Any}","content":" AstroAngles.rad2dms  —  Method rad2dms(angle) Convert radians to (degrees, arcminutes, arcseconds) tuple source"},{"id":2232,"pagetitle":"API Reference","title":"AstroAngles.rad2ha","ref":"/AstroAngles/stable/api/#AstroAngles.rad2ha-Tuple{Any}","content":" AstroAngles.rad2ha  —  Method rad2ha(angle) Convert radians to hour angles source"},{"id":2233,"pagetitle":"API Reference","title":"AstroAngles.rad2hms","ref":"/AstroAngles/stable/api/#AstroAngles.rad2hms-Tuple{Any}","content":" AstroAngles.rad2hms  —  Method rad2hms(angle) Convert radians to (hours, minutes, seconds) tuple source"},{"id":2234,"pagetitle":"API Reference","title":"AstroAngles.@dms_str","ref":"/AstroAngles/stable/api/#AstroAngles.@dms_str","content":" AstroAngles.@dms_str  —  Macro @dms_str Parse a string in  \"deg:arcmin:arcsec\"  format directly to an angle. By default, it will be parsed as radians, but the angle can be chosen by adding a flag to the end of the string dms\"...\"rad  -> radians (default) dms\"...\"deg  -> degrees dms\"...\"ha  -> hour angles Examples julia> dms\"12:17:25.3\"\n0.21450726764795752\n\njulia> dms\"12:17:25.3\"rad # default\n0.21450726764795752\n\njulia> dms\"12:17:25.3\"deg\n12.29036111111111\n\njulia> dms\"12:17:25.3\"ha\n0.8193574074074074 See also parse_dms source"},{"id":2235,"pagetitle":"API Reference","title":"AstroAngles.@hms_str","ref":"/AstroAngles/stable/api/#AstroAngles.@hms_str","content":" AstroAngles.@hms_str  —  Macro @hms_str Parse a string in  \"ha:min:sec\"  format directly to an angle. By default, it will be parsed as radians, but the angle can be chosen by adding a flag to the end of the string hms\"...\"rad  -> radians (default) hms\"...\"deg  -> degrees hms\"...\"ha  -> hour angles Examples julia> hms\"12:17:25.3\"\n3.2176090147193626\n\njulia> hms\"12:17:25.3\"rad # default\n3.2176090147193626\n\njulia> hms\"12:17:25.3\"deg\n184.35541666666666\n\njulia> hms\"12:17:25.3\"ha\n12.29036111111111 See also parse_hms source"},{"id":2238,"pagetitle":"Home","title":"UnitfulAstro.jl Documentation","ref":"/UnitfulAstro/stable/#UnitfulAstro.jl-Documentation","content":" UnitfulAstro.jl Documentation UnitfulAstro.jl is an extension of  Unitful.jl  to include units commonly encountered in astronomy."},{"id":2239,"pagetitle":"Home","title":"Table of Units","ref":"/UnitfulAstro/stable/#Table-of-Units","content":" Table of Units The list of additional units is given below: Name Binding Value Erg UnitfulAstro.erg 1//10000000 J Dyne UnitfulAstro.dyn 1//100000 N Arcminute UnitfulAstro.arcminute 1//60 ° Arcsecond UnitfulAstro.arcsecond 1//3600 ° Julian year UnitfulAstro.yr 1461//4 d Astronomical unit UnitfulAstro.AU 1.495978707e13 cm Light year UnitfulAstro.ly 946073047258080000 cm Parsec UnitfulAstro.pc 3.0856775814913674e18 cm Jansky UnitfulAstro.Jy 1.0e-23 erg Hz^-1 cm^-2 s^-1 Solar radius UnitfulAstro.Rsun 6.957e10 cm Solar irradiance UnitfulAstro.Ssun 1.361e6 erg cm^-2 s^-1 Solar luminosity UnitfulAstro.Lsun 3.828e33 erg s^-1 G × Solar mass UnitfulAstro.GMsun 1.3271244e20 m^3 s^-2 Solar mass UnitfulAstro.Msun 1.988409870698051e33 g Earth radius (equatorial) UnitfulAstro.Rearth_e 6.3781e8 cm Earth radius (polar) UnitfulAstro.Rearth_p 6.3568e8 cm Earth radius UnitfulAstro.Rearth 6.3781e8 cm G × Earth mass UnitfulAstro.GMearth 3.986004e14 m^3 s^-2 Earth mass UnitfulAstro.Mearth 5.972167867791379e27 g Jupiter radius (equatorial) UnitfulAstro.Rjup_e 7.1492e9 cm Jupiter radius (polar) UnitfulAstro.Rjup_p 6.6854e9 cm Jupiter radius UnitfulAstro.Rjup 7.1492e9 cm G × Jupiter mass UnitfulAstro.GMjup 1.2668653e17 m^3 s^-2 Jupiter mass UnitfulAstro.Mjup 1.8981245973360504e30 g Fifty-one ergs UnitfulAstro.foe 1.0e51 erg Solar flux unit UnitfulAstro.SFU 10 kJy Total electron content unit UnitfulAstro.TECU 1.0e12 cm^-2"},{"id":2240,"pagetitle":"Home","title":"Examples","ref":"/UnitfulAstro/stable/#Examples","content":" Examples julia> using Unitful, UnitfulAstro\n\njulia> uconvert(u\"erg\", 1 * Unitful.kg * Unitful.gn * Unitful.m)\n9.80665e7 erg\n\njulia> uconvert(u\"Jy\", 1.23e-20 * u\"erg/s/cm^2/Hz\")\n1230.0000000000002 Jy\n\njulia> uconvert(u\"ly\", 1u\"pc\")\n3.2615637771674333 ly"},{"id":2241,"pagetitle":"Home","title":"Magnitudes","ref":"/UnitfulAstro/stable/#Magnitudes","content":" Magnitudes Name Binding Zero Point absolute bolometric Magnitude UnitfulAstro.bol_Mag 3.0128e28 W apparent bolometric magnitude UnitfulAstro.bol_mag 2.518021002e-8 W m^-2 AB magnitude UnitfulAstro.AB_mag 3631 Jy Johnson U magnitude UnitfulAstro.U_mag 1810 Jy Johnson B magnitude UnitfulAstro.B_mag 4260 Jy Johnson V magnitude UnitfulAstro.V_mag 3640 Jy Johnson R magnitude UnitfulAstro.R_mag 3080 Jy Johnson I magnitude UnitfulAstro.I_mag 2550 Jy Johnson J magnitude UnitfulAstro.J_mag 1600 Jy Johnson H magnitude UnitfulAstro.H_mag 1080 Jy Johnson K magnitude UnitfulAstro.K_mag 670 Jy Gunn g magnitude UnitfulAstro.g_mag 3730 Jy Gunn r magnitude UnitfulAstro.r_mag 4490 Jy Gunn i magnitude UnitfulAstro.i_mag 4760 Jy Gunn z magnitude UnitfulAstro.z_mag 4810 Jy Warn Support for magnitudes is experimental. Please use care and report any issues you experience on the  UnitfulAstro.jl GitHub issue tracker . Currently only AB, bolometric, Johnson, and Gunn magnitudes are supported. For example julia> 5u\"AB_mag\" + 5u\"AB_mag\"\n4.247425010840047 AB mag\n\njulia> 5u\"U_mag\"/100\n10.0 Johnson U mag\n\njulia> 5u\"g_mag\" + 10u\"Jy\" # magnitudes can be mixed with ordinary linear units\n47.300000000000004 Jy\n\njulia> uconvert(u\"AB_mag\", 1u\"μJy\") # converting one μJy to AB magnitudes\n23.90006562228223 AB mag\n\njulia> uconvert(u\"bol_mag\", 1u\"Ssun\") # apparent bolometric magnitude of the Sun\n-26.83199694276591 bol mag\n\njulia> uconvert(u\"bol_Mag\", 1u\"Lsun\") # absolute bolometric magnitude of the Sun\n4.7399959339194595 bol Mag"},{"id":2242,"pagetitle":"Home","title":"Color","ref":"/UnitfulAstro/stable/#Color","content":" Color Color index  is also supported julia> 1u\"B_mag\" - 0.5u\"V_mag\"\n0.4999999999999999 Note:  that the only operation that can happen between different bands is subtraction julia> 1u\"B_mag\" + 0.5u\"V_mag\"\nERROR: MagnitudeError: an invalid operation was attempted with magnitudes: 0.9999999999999999 Johnson B mag, 0.5 Johnson V mag and  that  +  and  -  work on individual bands julia> 1u\"B_mag\" - 1.5u\"B_mag\"\n2.0823085833406205 Johnson B mag\n\njulia> 1u\"B_mag\" + 1.5u\"B_mag\"\n0.46889349301415084 Johnson B mag"},{"id":2243,"pagetitle":"Home","title":"IAU Resolutions","ref":"/UnitfulAstro/stable/#IAU-Resolutions","content":" IAU Resolutions Copies of recent IAU resolutions which formalize the definitions of some units used in this package are linked below. IAU 2012 (pdf) IAU 2015 (pdf)"},{"id":2246,"pagetitle":"API Reference","title":"API Reference","ref":"/UnitfulAstro/stable/api/#API-Reference","content":" API Reference"},{"id":2247,"pagetitle":"API Reference","title":"Lengths and Distances","ref":"/UnitfulAstro/stable/api/#Lengths-and-Distances","content":" Lengths and Distances"},{"id":2248,"pagetitle":"API Reference","title":"UnitfulAstro.AU","ref":"/UnitfulAstro/stable/api/#UnitfulAstro.AU","content":" UnitfulAstro.AU  —  Constant UnitfulAstro.AU The astronomical unit, an IAU unit of distance, defined as 149 597 870 700 m, in IAU 2012. It is intended to represent the mean distance between the Earth and the Sun. Dimension:  𝐋 Reference:  IAU 2012 Resolution B2 source"},{"id":2249,"pagetitle":"API Reference","title":"UnitfulAstro.ly","ref":"/UnitfulAstro/stable/api/#UnitfulAstro.ly","content":" UnitfulAstro.ly  —  Constant UnitfulAstro.ly The light-year, a unit of distance, defined as 1 c⋅yr (speed of light times year). It is intended to represent the amount of distance traveled by an object traveling at the speed of light (e.g., a photon) in a year. Dimesion:  𝐋 See also:  c  (speed of light) ,  yr source"},{"id":2250,"pagetitle":"API Reference","title":"UnitfulAstro.pc","ref":"/UnitfulAstro/stable/api/#UnitfulAstro.pc","content":" UnitfulAstro.pc  —  Constant UnitfulAstro.pc The parsec, a unit of distance, defined as 1 AU/arcsecond, in IAU 2015. The exact conversion is 648000/π AU. It is intended to represent the distance to an object whose apparent parallax is 1 arcsecond when viewed from two distances 1 AU apart. Dimension:  𝐋 See also:  AU ,  arcsecond References:  Binney & Tremaine (2008) ,  Cox (2002) ,  IAU 2015 Resolution B2 source"},{"id":2251,"pagetitle":"API Reference","title":"UnitfulAstro.Rsun","ref":"/UnitfulAstro/stable/api/#UnitfulAstro.Rsun","content":" UnitfulAstro.Rsun  —  Constant UnitfulAstro.Rsun The solar radius, a unit of length. It is defined as 6.957 × 10^8 m in IAU 2015. It is intended to represent the radius of the sun. Dimension:  𝐋 Reference:  IAU 2015 Resolution B3 source"},{"id":2252,"pagetitle":"API Reference","title":"UnitfulAstro.Rearth","ref":"/UnitfulAstro/stable/api/#UnitfulAstro.Rearth","content":" UnitfulAstro.Rearth  —  Constant UnitfulAstro.Rearth The terrestrial radius, a unit of length. It is defined as 1 equatorial Earth radius. Dimension:  𝐋 See also:  Rearth_e ,  Rearth_p source"},{"id":2253,"pagetitle":"API Reference","title":"UnitfulAstro.Rearth_e","ref":"/UnitfulAstro/stable/api/#UnitfulAstro.Rearth_e","content":" UnitfulAstro.Rearth_e  —  Constant UnitfulAstro.Rearth_e The equatorial Earth radius, a unit of length. It is defined as 6.3781 × 10^6 m. It is intended to represent the distance from the Earth's center to its equator. Dimension:  𝐋 See also:  Rearth_p Reference:  IAU 2015 Resolution B3 source"},{"id":2254,"pagetitle":"API Reference","title":"UnitfulAstro.Rearth_p","ref":"/UnitfulAstro/stable/api/#UnitfulAstro.Rearth_p","content":" UnitfulAstro.Rearth_p  —  Constant UnitfulAstro.Rearth_p The polar Earth radius, a unit of length. It is defined as 6.3568 × 10^6 m. It is intended to represent the distance from the Earth's center to its poles. Dimension:  𝐋 See also:  Rearth_e Reference:  IAU 2015 Resolution B3 source"},{"id":2255,"pagetitle":"API Reference","title":"UnitfulAstro.Rjup","ref":"/UnitfulAstro/stable/api/#UnitfulAstro.Rjup","content":" UnitfulAstro.Rjup  —  Constant UnitfulAstro.Rjup The jovian radius, a unit of length. It is defined as 1 equatorial Jupiter radius. Dimension:  𝐋 See also:  Rjup_e ,  Rjup_p source"},{"id":2256,"pagetitle":"API Reference","title":"UnitfulAstro.Rjup_e","ref":"/UnitfulAstro/stable/api/#UnitfulAstro.Rjup_e","content":" UnitfulAstro.Rjup_e  —  Constant UnitfulAstro.Rjup_e The equatorial Jupiter radius, a unit of length. It is defined as 7.1492 × 10^7 m. It is intended to represent the distance from Jupiter's center to its equator. Dimension:  𝐋 See also:  Rjup_p Reference:  IAU 2015 Resolution B3 source"},{"id":2257,"pagetitle":"API Reference","title":"UnitfulAstro.Rjup_p","ref":"/UnitfulAstro/stable/api/#UnitfulAstro.Rjup_p","content":" UnitfulAstro.Rjup_p  —  Constant UnitfulAstro.Rjup_p The polar Jupiter radius, a unit of length. It is defined as 6.6854 × 10^7 m. It is intended to represent the distance from Jupiter's center to its equator. Dimension:  𝐋 See also:  Rjup_e Reference:  IAU 2015 Resolution B3 source"},{"id":2258,"pagetitle":"API Reference","title":"Masses and mass parameters","ref":"/UnitfulAstro/stable/api/#Masses-and-mass-parameters","content":" Masses and mass parameters"},{"id":2259,"pagetitle":"API Reference","title":"UnitfulAstro.GMsun","ref":"/UnitfulAstro/stable/api/#UnitfulAstro.GMsun","content":" UnitfulAstro.GMsun  —  Constant UnitfulAstro.GMSun The solar mass parameter. It is defined as 1.3271244 × 10^20 m^3 s^-2. It is intended to represent the product of G (the universal gravitational constant) and Msun (the solar mass). Dimension:  𝐋^3 𝐓^-2 See also:  G ,  Msun Reference:  IAU 2015 Resolution B3 source"},{"id":2260,"pagetitle":"API Reference","title":"UnitfulAstro.Msun","ref":"/UnitfulAstro/stable/api/#UnitfulAstro.Msun","content":" UnitfulAstro.Msun  —  Constant UnitfulAstro.Msun The solar mass, a unit of mass. It is defined as 1 GMsun/G. It is approximately equal to 1.988 × 10^30 kg. It is intended to represent the entire mass of the Sun. Dimension:  𝐌 See also:  G ,  GMsun Reference:  IAU 2015 Resolution B3 source"},{"id":2261,"pagetitle":"API Reference","title":"UnitfulAstro.GMearth","ref":"/UnitfulAstro/stable/api/#UnitfulAstro.GMearth","content":" UnitfulAstro.GMearth  —  Constant UnitfulAstro.GMearth The terrestrial mass parameter. It is defined as 3.986 004 × 10^14 m^3 s^-2. It is intended to represent the product of G (the universal gravitational constant) and Mearth (the terrestrial mass). Dimension:  𝐋^3 𝐓^-2 See also:  G ,  Mearth Reference:  IAU 2015 Resolution B3 source"},{"id":2262,"pagetitle":"API Reference","title":"UnitfulAstro.Mearth","ref":"/UnitfulAstro/stable/api/#UnitfulAstro.Mearth","content":" UnitfulAstro.Mearth  —  Constant UnitfulAstro.Mearth The terrestrial mass, a unit of mass. It is defined as 1 GMearth/G. It is approximately 5.972 × 10^24 kg. It is intended to represent the total mass of the Earth. Dimension:  𝐌 See also:  G ,  GMearth source"},{"id":2263,"pagetitle":"API Reference","title":"UnitfulAstro.GMjup","ref":"/UnitfulAstro/stable/api/#UnitfulAstro.GMjup","content":" UnitfulAstro.GMjup  —  Constant UnitfulAstro.GMjup The jovian mass parameter. It is defined as 1.266 8653 × 10^17 m^3 s^-2. It is intended to represent the product of G (the universal gravitational constant) and Mjup (the jovian mass). Dimension:  𝐋^3 𝐓^-2 See also:  G ,  Mjup Reference:  IAU 2015 Resolution B3 source"},{"id":2264,"pagetitle":"API Reference","title":"UnitfulAstro.Mjup","ref":"/UnitfulAstro/stable/api/#UnitfulAstro.Mjup","content":" UnitfulAstro.Mjup  —  Constant UnitfulAstro.Mjup The jovian mass, a unit of mass. It is defined as 1 GMjup/G. It is approximately 1.898 × 10^27 kg. It is intended to represent the total mass of Jupiter . Dimension:  𝐌 See also:  G ,  GMjup source"},{"id":2265,"pagetitle":"API Reference","title":"Energy and fluxes","ref":"/UnitfulAstro/stable/api/#Energy-and-fluxes","content":" Energy and fluxes"},{"id":2266,"pagetitle":"API Reference","title":"UnitfulAstro.Jy","ref":"/UnitfulAstro/stable/api/#UnitfulAstro.Jy","content":" UnitfulAstro.Jy  —  Constant UnitfulAstro.Jy The jansky, a unit of spectral flux density, or spectral irradiance. It is defined as 10^-26 W m^-2 Hz^-1, or 10^-23 erg/s cm^-2 Hz^-1. Dimension:  𝐌 𝐓^-2 source"},{"id":2267,"pagetitle":"API Reference","title":"UnitfulAstro.Lsun","ref":"/UnitfulAstro/stable/api/#UnitfulAstro.Lsun","content":" UnitfulAstro.Lsun  —  Constant UnitfulAstro.Lsun The solar luminosity, a unit of power. It is defined as 3.828 × 10^26 W in IAU 2015. It is intended to represent the total power emitted by the sun. Dimension:  𝐌 𝐋^2 𝐓^-3 Reference:  IAU 2015 Resolution B3 source"},{"id":2268,"pagetitle":"API Reference","title":"UnitfulAstro.foe","ref":"/UnitfulAstro/stable/api/#UnitfulAstro.foe","content":" UnitfulAstro.foe  —  Constant UnitfulAstro.foe The foe, a unit of energy. It is defined as 10^51 erg (ten to the Fifty-One Ergs), or 10^44 J. It is intended to represent the approximate energy released in a supernova explosion. Dimension:  𝐌 𝐋^-2 𝐓^-2 References:  Herant et al. (1997) ,  Hartmann (1999) source"},{"id":2269,"pagetitle":"API Reference","title":"UnitfulAstro.SFU","ref":"/UnitfulAstro/stable/api/#UnitfulAstro.SFU","content":" UnitfulAstro.SFU  —  Constant UnitfulAstro.SFU The solar flux unit, a unit of spectral flux density, or spectral irradiance. It is defined as 10 kJy, or 10^4 Jy. Dimension:  𝐌 𝐓^-2 See also:  Jy Reference:  Tapping (2013) source"},{"id":2270,"pagetitle":"API Reference","title":"UnitfulAstro.TECU","ref":"/UnitfulAstro/stable/api/#UnitfulAstro.TECU","content":" UnitfulAstro.TECU  —  Constant UnitfulAstro.TECU The total electron content unit, a unit of areal number density. It is defined as 10^16 m^-2. TODO cite Hofmann-Wellenhof (2001). Dimension:  𝐋^-2 Reference:  Hofmann-Wellenhof (2001) source"},{"id":2273,"pagetitle":"Bibliography","title":"Bibliography","ref":"/UnitfulAstro/stable/bibliography/#Bibliography","content":" Bibliography [1] IAU Division I Working Group Numerical Standards.  Resolution B2 on the Re-Definition of the Astronomical Unit of Length  (2012). [2] J. Binney and S. Tremaine.  Galactic Dynamics . 2nd Edition,  Princeton Series in Astrophysics  (Princeton University Press, Princeton, 2008). [3] Allen's Astrophysical Quantities  (Springer New York, New York, NY, 2002). [4] IAU Inter-Division A-G Working Group on Nominal Units for Stellar & Planetary Astronomy.  Resolution B2 on Recommended Zero Points for the Absolute and Apparent Bolometric Magnitude Scales  (2015). [5] IAU Inter-Division A-G Working Group on Nominal Units for Stellar & Planetary Astronomy.  Resolution B3 on Recommended Nominal Conversion Constants for Selected Solar and Planetary Properties  (2015). [6] M. Herant, S. Colgate, W. Benz and C. Fryer.  Neutrinos and Supernovae . Los Alamos Science, 164―178 (1997). [7] D. H. Hartmann.  Afterglows From the Largest Explosions in the Universe .  Proceedings of the National Academy of Science  96 , 4752–4755  (1999). [8] K. F. Tapping.  The 10.7 cm solar radio flux (F10.7) .  Space Weather  11 , 394–406  (2013). [9] B. Hofmann-Wellenhof.  Global Positioning System: Theory and Practice . 5th Edition (Springer Wien, Vienna, 2001)."}]