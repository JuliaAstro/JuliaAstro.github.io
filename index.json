[{"id":3,"pagetitle":"Home","title":"AstroAngles.jl","ref":"/previews/PR43/AstroAngles/stable/#AstroAngles.jl","content":" AstroAngles.jl Lightweight string parsing and representation of angles."},{"id":4,"pagetitle":"Home","title":"Installation","ref":"/previews/PR43/AstroAngles/stable/#Installation","content":" Installation To install use  Pkg . From the REPL, press  ]  to enter Pkg-mode pkg> add AstroAngles If you want to use the most up-to-date version of the code, check it out from  main pkg> add AstroAngles#main"},{"id":5,"pagetitle":"Home","title":"Usage","ref":"/previews/PR43/AstroAngles/stable/#Usage","content":" Usage"},{"id":6,"pagetitle":"Home","title":"Angle Parsing Utilities","ref":"/previews/PR43/AstroAngles/stable/#Angle-Parsing-Utilities","content":" Angle Parsing Utilities String representations of angles in both \"degree:arcmin:arcsec\" and  \"hour:min:sec\" format can be parsed using a variety of delimiters, which can be mixed together (e.g. can use  °  after degrees but  :  after the arcminutes). The directions \"S\" and \"W\" are considered negative and \"-1:0:0S\" is 1 degree North, for example."},{"id":7,"pagetitle":"Home","title":"dms formats","ref":"/previews/PR43/AstroAngles/stable/#dms-formats","content":" dms formats \"[+-]xx:xx:xx.x[NESW]\"\n\"[+-]xx xx xx.x[NESW]\"\n\"[+-]xxdxxmxx.xs[NESW]\"\n\"[+-]xx°xx'xx.x\\\"[NESW]\"\n\"[+-]xx°xx′xx.x″[NESW]\" # \\prime, \\pprime"},{"id":8,"pagetitle":"Home","title":"hms formats","ref":"/previews/PR43/AstroAngles/stable/#hms-formats","content":" hms formats \"[+-]xx:xx:xx.x[NESW]\"\n\"[+-]xx xx xx.x[NESW]\"\n\"[+-]xxhxxmxx.xs[NESW]\"\n\"[+-]xxhxx'xx.x\\\"[NESW]\"\n\"[+-]xx°xx′xx.x″[NESW]\" the simplest way to convert is to use the  @dms_str  and  @hms_str  macros, which allows you to choose the output angle type julia> dms\"12:17:25.3\"\n0.21450726764795752\n\njulia> dms\"12:17:25.3\"rad # default\n0.21450726764795752\n\njulia> dms\"12:17:25.3\"deg\n12.29036111111111\n\njulia> dms\"12:17:25.3\"ha\n0.8193574074074074 here is a showcase of the variety of ways to parse inputs julia> dms\"10.2345d\"deg\n10.2345\n\njulia> dms\"1:2:30.43\"deg\n1.041786111111111\n\njulia> hms\"1 2 0\"ha\n1.0333333333333334\n\njulia> dms\"1°2′3″\"deg\n1.0341666666666667\n\njulia> dms\"1°2′3″N\"deg\n1.0341666666666667\n\njulia> dms\"1d2m3.4s\"deg\n1.0342777777777779\n\njulia> dms\"1d2m3.4sS\"deg\n-1.0342777777777779\n\njulia> hms\"-1h2m3s\"ha\n-1.0341666666666667\n\njulia> hms\"-1h2m3sW\"ha\n1.0341666666666667 for more control on the output, you can use the  parse_dms  and  parse_hms  methods, which returns a tuple of the parsed  dms  or  hms  values parse_dms # string -> (deg, arcmin, arcsec)\nparse_hms # string -> (hours, mins, secs) julia> parse_dms(\"12:17:25.3\")\n(12.0, 17.0, 25.3)\n\njulia> parse_hms(\"-4:4:6\")\n(-4.0, 4.0, 6.0)"},{"id":9,"pagetitle":"Home","title":"Angle Conversion Utilities","ref":"/previews/PR43/AstroAngles/stable/#Angle-Conversion-Utilities","content":" Angle Conversion Utilities The following methods are added for converting to and from hour angles deg2ha # degrees -> hour angles\nrad2ha # radians -> hour angles\nha2deg # hour angles -> degrees\nha2rad # hour angles -> radians The following methods convert from angles as a single number to tuples consistent with sexagesimal deg2dms # degrees -> (deg, arcmin, arcsec)\nrad2dms # radians -> (deg, arcmin, arcsec)\nha2dms  # hour angles -> (deg, arcmin, arcsec)\n\ndeg2hms # degrees -> (hours, mins, secs)\nrad2hms # radians -> (hours, mins, secs)\nha2hms  # hour angles -> (hours, mins, secs) and the inverse dms2deg # (deg, arcmin, arcsec) -> degrees\ndms2rad # (deg, arcmin, arcsec) -> radians\ndms2ha  # (deg, arcmin, arcsec) -> hour angles\n\nhms2deg # (hours, mins, secs) -> degrees\nhms2rad # (hours, mins, secs) -> radians\nhms2ha  # (hours, mins, secs) -> hour angles the above functions can take a string as input and will automatically parse it (using  parse_dms  or  parse_hms , respectively) before converting."},{"id":10,"pagetitle":"Home","title":"Formatting angles","ref":"/previews/PR43/AstroAngles/stable/#Formatting-angles","content":" Formatting angles Lastly, we have some simple methods for formatting angles into strings, although for more fine-tuned control we recommend using  Printf  or a package like  Format.jl .  format_angle  takes parts (like from  deg2dms  or  rad2hms ) and a delimiter (or collection of 3 delimiters for each value). julia> format_angle(deg2dms(45.0))\n\"45:0:0.0\"\n\njulia> format_angle(deg2hms(-65.0); delim=[\"h\", \"m\", \"s\"])\n\"-4h19m59.999999999998934s\""},{"id":11,"pagetitle":"Home","title":"Example: reading coordinates from a table","ref":"/previews/PR43/AstroAngles/stable/#Example:-reading-coordinates-from-a-table","content":" Example: reading coordinates from a table Here's an example of reading sky coordinates from a CSV formatted target list and converting them to degrees: julia> using AstroAngles, CSV, DataFrames\n\njulia> table = CSV.File(\"target_list.csv\") |> DataFrame;\n\njulia> [table.ra table.dec]\n203×2 Matrix{String}:\n \"00 05 01.42\"  \"40 03 35.82\"\n \"00 05 07.52\"  \"73 13 11.34\"\n \"00 36 01.40\"  \"-11 12 13.00\"\n[...]\n\njulia> ra_d = @. hms2deg(table.ra)\n203-element Vector{Float64}:\n   1.2559166666666666\n   1.2813333333333332\n   9.005833333333333\n[...]\n\njulia> dec_d = @. dms2deg(table.dec)\n203-element Vector{Float64}:\n  40.05995\n  73.21981666666667\n -11.203611111111112\n[...]"},{"id":12,"pagetitle":"Home","title":"Contributing/Support","ref":"/previews/PR43/AstroAngles/stable/#Contributing/Support","content":" Contributing/Support To contribute, feel free to open a  pull request . If you run into problems, please open an  issue . To discuss ideas, usage, or to plan contributions, open a new  discussion ."},{"id":13,"pagetitle":"Home","title":"License","ref":"/previews/PR43/AstroAngles/stable/#License","content":" License This code is MIT licensed. For more information, see the LICENSE file in the AstroAngles.jl repository."},{"id":16,"pagetitle":"API Reference","title":"API Reference","ref":"/previews/PR43/AstroAngles/stable/api/#API-Reference","content":" API Reference"},{"id":17,"pagetitle":"API Reference","title":"AstroAngles.deg2dms","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.deg2dms-Tuple{Any}","content":" AstroAngles.deg2dms  —  Method deg2dms(angle) Convert degrees to (degrees, arcminutes, arcseconds) tuple source"},{"id":18,"pagetitle":"API Reference","title":"AstroAngles.deg2ha","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.deg2ha-Tuple{Any}","content":" AstroAngles.deg2ha  —  Method deg2ha(angle) Convert degrees to hour angles source"},{"id":19,"pagetitle":"API Reference","title":"AstroAngles.deg2hms","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.deg2hms-Tuple{Any}","content":" AstroAngles.deg2hms  —  Method deg2hms(angle) Convert degrees to (hours, minutes, seconds) tuple source"},{"id":20,"pagetitle":"API Reference","title":"AstroAngles.dms2deg","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.dms2deg-Tuple{Any, Any, Any}","content":" AstroAngles.dms2deg  —  Method dms2deg(degrees, arcmin, arcsec)\ndms2deg(parts)\ndms2deg(input::AbstractString) Convert (degrees, arcminutes, arcseconds) tuple to degrees. If a string is given, will parse with  parse_dms  first. If an angle is input will treat as a no-op. source"},{"id":21,"pagetitle":"API Reference","title":"AstroAngles.dms2ha","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.dms2ha-Tuple{Any, Any, Any}","content":" AstroAngles.dms2ha  —  Method dms2ha(degrees, arcmin, arcsec)\ndms2ha(parts)\ndms2ha(input::AbstractString) Convert (degrees, arcminutes, arcseconds) tuple to hour angles. If a string is given, will parse with  parse_dms  first. If an angle is input will treat as a no-op. source"},{"id":22,"pagetitle":"API Reference","title":"AstroAngles.dms2rad","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.dms2rad-Tuple{Any, Any, Any}","content":" AstroAngles.dms2rad  —  Method dms2rad(degrees, arcmin, arcsec)\ndms2rad(parts)\ndms2rad(input::AbstractString) Convert (degrees, arcminutes, arcseconds) tuple to radians. If a string is given, will parse with  parse_dms  first. If an angle is input will treat as a no-op. source"},{"id":23,"pagetitle":"API Reference","title":"AstroAngles.format_angle","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.format_angle-Tuple{Any}","content":" AstroAngles.format_angle  —  Method format_angle(parts; delim=':') Given the  (whole, minutes, seconds)  parts of an angle, will format into a string with the given delimiter(s). These parts can be generated by the  xxx2dms  and  xxx2hms  methods, for sexagesimal and  hour:minute:second  outputs. Multiple delimiters can be given in a tuple or vector placed after their respective values. For more control over formatting, consider using  Printf  or a package like  Format.jl . Examples julia> ang = 45.0; # degrees\n\njulia> format_angle(deg2dms(ang))\n\"45:0:0.0\"\n\njulia> format_angle(deg2hms(ang))\n\"3:0:0.0\"\n\njulia> format_angle(rad2hms(1.5), delim=[\"h\", \"m\", \"s\"])\n\"5h43m46.48062470963538s\" See also deg2dms ,  deg2hms ,  rad2dms ,  rad2hms ,  ha2dms ,  ha2hms source"},{"id":24,"pagetitle":"API Reference","title":"AstroAngles.ha2deg","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.ha2deg-Tuple{Any}","content":" AstroAngles.ha2deg  —  Method ha2deg(angle) Convert hour angles to degrees source"},{"id":25,"pagetitle":"API Reference","title":"AstroAngles.ha2dms","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.ha2dms-Tuple{Any}","content":" AstroAngles.ha2dms  —  Method ha2dms(angle) Convert hour angles to (degrees, arcminutes, arcseconds) tuple source"},{"id":26,"pagetitle":"API Reference","title":"AstroAngles.ha2hms","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.ha2hms-Tuple{Any}","content":" AstroAngles.ha2hms  —  Method ha2hms(angle) Convert hour angles to (hours, minutes, seconds) tuple source"},{"id":27,"pagetitle":"API Reference","title":"AstroAngles.ha2rad","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.ha2rad-Tuple{Any}","content":" AstroAngles.ha2rad  —  Method ha2rad(angle) Convert hour angles to radians source"},{"id":28,"pagetitle":"API Reference","title":"AstroAngles.hms2deg","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.hms2deg-Tuple{Any, Any, Any}","content":" AstroAngles.hms2deg  —  Method hms2deg(hours, mins, secs)\nhms2deg(parts)\nhms2deg(input::AbstractString) Convert (hours, minutes, seconds) tuple to degrees. If a string is given, will parse with  parse_hms  first. If an angle is input will treat as a no-op. source"},{"id":29,"pagetitle":"API Reference","title":"AstroAngles.hms2ha","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.hms2ha-Tuple{Any, Any, Any}","content":" AstroAngles.hms2ha  —  Method hms2ha(hours, mins, secs)\nhms2ha(parts)\nhms2ha(input::AbstractString) Convert (hours, minutes, seconds) tuple to hour angles. If a string is given, will parse with  parse_hms  first. If an angle is input will treat as a no-op. source"},{"id":30,"pagetitle":"API Reference","title":"AstroAngles.hms2rad","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.hms2rad-Tuple{Any, Any, Any}","content":" AstroAngles.hms2rad  —  Method hms2rad(hours, mins, secs)\nhms2rad(parts)\nhms2rad(input::AbstractString) Convert (hours, minutes, seconds) tuple to radians. If a string is given, will parse with  parse_hms  first. If an angle is input will treat as a no-op. source"},{"id":31,"pagetitle":"API Reference","title":"AstroAngles.parse_dms","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.parse_dms-Tuple{Any}","content":" AstroAngles.parse_dms  —  Method parse_dms(input) Parses a string input in \"deg:arcmin:arcsec\" format to the tuple  (degrees, arcminutes, arcseconds) . The following delimiters will all work and can be mixed together (the last delimiter is optional): \"[+-]xx[°d: ]xx['′m: ]xx[\\\"″s][NESW]\" if the direction is provided, \"S\" and \"E\" are considered negative (and \"-1:0:0S\" is 1 degree North) source"},{"id":32,"pagetitle":"API Reference","title":"AstroAngles.parse_hms","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.parse_hms-Tuple{Any}","content":" AstroAngles.parse_hms  —  Method parse_hms(input) Parses a string input in \"ha:min:sec\" format to the tuple  (hours, minutes, seconds) . The following delimiters will all work and can be mixed together (the last delimiter is optional): \"[+-]xx[h ]xx['′m: ]xx[\\\"″s][EW]\" if the direction is provided, \"S\" and \"E\" are considered negative (and \"-1:0:0W\" is 1 degree East) source"},{"id":33,"pagetitle":"API Reference","title":"AstroAngles.rad2dms","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.rad2dms-Tuple{Any}","content":" AstroAngles.rad2dms  —  Method rad2dms(angle) Convert radians to (degrees, arcminutes, arcseconds) tuple source"},{"id":34,"pagetitle":"API Reference","title":"AstroAngles.rad2ha","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.rad2ha-Tuple{Any}","content":" AstroAngles.rad2ha  —  Method rad2ha(angle) Convert radians to hour angles source"},{"id":35,"pagetitle":"API Reference","title":"AstroAngles.rad2hms","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.rad2hms-Tuple{Any}","content":" AstroAngles.rad2hms  —  Method rad2hms(angle) Convert radians to (hours, minutes, seconds) tuple source"},{"id":36,"pagetitle":"API Reference","title":"AstroAngles.@dms_str","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.@dms_str","content":" AstroAngles.@dms_str  —  Macro @dms_str Parse a string in  \"deg:arcmin:arcsec\"  format directly to an angle. By default, it will be parsed as radians, but the angle can be chosen by adding a flag to the end of the string dms\"...\"rad  -> radians (default) dms\"...\"deg  -> degrees dms\"...\"ha  -> hour angles Examples julia> dms\"12:17:25.3\"\n0.21450726764795752\n\njulia> dms\"12:17:25.3\"rad # default\n0.21450726764795752\n\njulia> dms\"12:17:25.3\"deg\n12.29036111111111\n\njulia> dms\"12:17:25.3\"ha\n0.8193574074074074 See also parse_dms source"},{"id":37,"pagetitle":"API Reference","title":"AstroAngles.@hms_str","ref":"/previews/PR43/AstroAngles/stable/api/#AstroAngles.@hms_str","content":" AstroAngles.@hms_str  —  Macro @hms_str Parse a string in  \"ha:min:sec\"  format directly to an angle. By default, it will be parsed as radians, but the angle can be chosen by adding a flag to the end of the string hms\"...\"rad  -> radians (default) hms\"...\"deg  -> degrees hms\"...\"ha  -> hour angles Examples julia> hms\"12:17:25.3\"\n3.2176090147193626\n\njulia> hms\"12:17:25.3\"rad # default\n3.2176090147193626\n\njulia> hms\"12:17:25.3\"deg\n184.35541666666666\n\njulia> hms\"12:17:25.3\"ha\n12.29036111111111 See also parse_hms source"},{"id":40,"pagetitle":"Home","title":"AstroTime","ref":"/previews/PR43/AstroTime/stable/#AstroTime","content":" AstroTime Astronomical time keeping in Julia AstroTime.jl provides a high-precision, time-scale aware,  DateTime -like data type which supports all commonly used astronomical time scales."},{"id":41,"pagetitle":"Home","title":"Installation","ref":"/previews/PR43/AstroTime/stable/#Installation","content":" Installation The package can be installed through Julia's package manager: julia> import Pkg; Pkg.add(\"AstroTime\")"},{"id":42,"pagetitle":"Home","title":"Quickstart","ref":"/previews/PR43/AstroTime/stable/#Quickstart","content":" Quickstart # Create an Epoch based on the TT (Terrestial Time) scale\ntt = TTEpoch(\"2018-01-01T12:00:00\")\n\n# Transform to TAI (International Atomic Time)\ntai = TAIEpoch(tt)\n\n# Transform to TDB (Barycentric Dynamical Time)\ntdb = TDBEpoch(tai)\n\n# Shift an Epoch by one day\nanother_day = tt + 1days"},{"id":43,"pagetitle":"Home","title":"Next Steps","ref":"/previews/PR43/AstroTime/stable/#Next-Steps","content":" Next Steps Follow the  Tutorial  to get an in-depth look at AstroTime.jl's functionality."},{"id":46,"pagetitle":"Epochs","title":"Epochs","ref":"/previews/PR43/AstroTime/stable/api/epochs/#Epochs","content":" Epochs"},{"id":47,"pagetitle":"Epochs","title":"AstroTime.Epochs.Epoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.Epoch","content":" AstroTime.Epochs.Epoch  —  Type Epoch(str[, format]) Construct an  Epoch  from a string  str . Optionally a  format  definition can be passed as a  DateFormat  object or as a string. In addition to the character codes supported by  DateFormat  the character code  D  is supported which is parsed as \"day of year\" (see the example below) and the character code  t  which is parsed as the time scale.  The default format is  yyyy-mm-ddTHH:MM:SS.sss ttt . Note:  Please be aware that this constructor requires that the time scale is part of  str , e.g.  2018-02-06T00:00 TAI . Otherwise use an explicit constructor, e.g.  Epoch{TAI} . Example julia> Epoch(\"2018-02-06T20:45:00.0 TAI\")\n2018-02-06T20:45:00.000 TAI\n\njulia> Epoch(\"2018-037T00:00 TAI\", \"yyyy-DDDTHH:MM ttt\")\n2018-02-06T00:00:00.000 TAI source"},{"id":48,"pagetitle":"Epochs","title":"AstroTime.Epochs.Epoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.Epoch-Union{Tuple{AbstractString}, Tuple{S}, Tuple{AbstractString, Dates.DateFormat}} where S","content":" AstroTime.Epochs.Epoch  —  Method Epoch{S}(str[, format]) where S Construct an  Epoch  with time scale  S  from a string  str . Optionally a  format  definition can be passed as a  DateFormat  object or as a string. In addition to the character codes supported by  DateFormat  the code  D  can be used which is parsed as \"day of year\" (see the example below).  The default format is  yyyy-mm-ddTHH:MM:SS.sss . Example julia> Epoch{InternationalAtomicTime}(\"2018-02-06T20:45:00.0\")\n2018-02-06T20:45:00.000 TAI\n\njulia> Epoch{InternationalAtomicTime}(\"February 6, 2018\", \"U d, y\")\n2018-02-06T00:00:00.000 TAI\n\njulia> Epoch{InternationalAtomicTime}(\"2018-037T00:00\", \"yyyy-DDDTHH:MM\")\n2018-02-06T00:00:00.000 TAI source"},{"id":49,"pagetitle":"Epochs","title":"AstroTime.Epochs.Epoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.Epoch-Union{Tuple{Epoch{S1, T} where T}, Tuple{S2}, Tuple{S1}} where {S1<:TimeScale, S2<:TimeScale}","content":" AstroTime.Epochs.Epoch  —  Method Epoch{S2}(ep::Epoch{S1}) where {S1, S2} Convert  ep , an  Epoch  with time scale  S1 , to an  Epoch  with time scale  S2 . Examples julia> ep = TTEpoch(2000,1,1)\n2000-01-01T00:00:00.000 TT\n\njulia> TAIEpoch(ep)\n1999-12-31T23:59:27.816 TAI source"},{"id":50,"pagetitle":"Epochs","title":"AstroTime.Epochs.Epoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.Epoch-Union{Tuple{Int64, Int64, Int64}, NTuple{4, Int64}, NTuple{5, Int64}, Tuple{S}, Tuple{Int64, Int64, Int64, Int64, Int64, Float64, Vararg{Any, N} where N}} where S","content":" AstroTime.Epochs.Epoch  —  Method Epoch{S}(year, month, day, hour=0, minute=0, second=0.0) where S Construct an  Epoch  with time scale  S  from date and time components. Example julia> Epoch{InternationalAtomicTime}(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TAI\n\njulia> Epoch{InternationalAtomicTime}(2018, 2, 6)\n2018-02-06T00:00:00.000 TAI source"},{"id":51,"pagetitle":"Epochs","title":"AstroTime.Epochs.Epoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.Epoch-Union{Tuple{S2}, Tuple{S1}, Tuple{Any, Epoch{S1, T} where T}} where {S1<:TimeScale, S2<:TimeScale}","content":" AstroTime.Epochs.Epoch  —  Method Epoch{S}(Δtai, ep::TAIEpoch) where S Convert  ep , a  TAIEpoch , to an  Epoch  with time scale  S  by overriding the offset between  S2  and  TAI  with  Δtai . Examples julia> ep = TAIEpoch(2000,1,1)\n2000-01-01T00:00:00.000 TAI\n\njulia> TTEpoch(32.184, ep)\n2000-01-01T00:00:32.184 TT source"},{"id":52,"pagetitle":"Epochs","title":"AstroTime.Epochs.Epoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.Epoch-Union{Tuple{S2}, Tuple{S1}, Tuple{Epoch{S1, T} where T, S2}} where {S1<:TimeScale, S2<:TimeScale}","content":" AstroTime.Epochs.Epoch  —  Method Epoch(ep::Epoch{S1}, scale::S2) where {S1, S2} Convert  ep , an  Epoch  with time scale  S1 , to an  Epoch  with time scale  S2 . Examples julia> ep = TTEpoch(2000,1,1)\n2000-01-01T00:00:00.000 TT\n\njulia> Epoch(ep, TAI)\n1999-12-31T23:59:27.816 TAI source"},{"id":53,"pagetitle":"Epochs","title":"AstroTime.Epochs.Epoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.Epoch-Union{Tuple{T}, Tuple{S}, Tuple{T, T, Vararg{Any, N} where N}} where {S, T<:AstroPeriod}","content":" AstroTime.Epochs.Epoch  —  Method Epoch{S}(jd1::T, jd2::T=zero(T); origin=:j2000) where {S, T<:AstroPeriod} Construct an  Epoch  with time scale  S  from a Julian date (optionally split into  jd1  and  jd2 ).  origin  determines the variant of Julian date that is used. Possible values are: :j2000 : J2000 Julian date, starts at  2000-01-01T12:00 :julian : Julian date, starts at  -4712-01-01T12:00 :modified_julian : Modified Julian date, starts at  1858-11-17T00:00 Examples julia> Epoch{InternationalAtomicTime}(0.0days, 0.5days)\n2000-01-02T00:00:00.000 TAI\n\njulia> Epoch{InternationalAtomicTime}(2.451545e6days, origin=:julian)\n2000-01-01T12:00:00.000 TAI source"},{"id":54,"pagetitle":"Epochs","title":"AstroTime.Epochs.TAIEpoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.TAIEpoch-Tuple{AbstractString}","content":" AstroTime.Epochs.TAIEpoch  —  Method TAIEpoch(str[, format]) Construct a TAIEpoch from a string  str . Optionally a  format  definition can be passed as a  DateFormat  object or as a string. In addition to the character codes supported by  DateFormat  the code  D  is supported which is parsed as \"day of year\" (see the example below). The default format is  yyyy-mm-ddTHH:MM:SS.sss . Example julia> TAIEpoch(\"2018-02-06T20:45:00.0\")\n2018-02-06T20:45:00.000 TAI\n\njulia> TAIEpoch(\"February 6, 2018\", \"U d, y\")\n2018-02-06T00:00:00.000 TAI\n\njulia> TAIEpoch(\"2018-37T00:00\", \"yyyy-DDDTHH:MM\")\n2018-02-06T00:00:00.000 TAI source"},{"id":55,"pagetitle":"Epochs","title":"AstroTime.Epochs.TAIEpoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.TAIEpoch-Tuple{Int64, Int64, Int64}","content":" AstroTime.Epochs.TAIEpoch  —  Method TAIEpoch(year, month, day, hour=0, minute=0, second=0.0) Construct a TAIEpoch from date and time components. Example julia> TAIEpoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TAI\n\njulia> TAIEpoch(2018, 2, 6)\n2018-02-06T00:00:00.000 TAI source"},{"id":56,"pagetitle":"Epochs","title":"AstroTime.Epochs.TAIEpoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.TAIEpoch-Tuple{Number, Number}","content":" AstroTime.Epochs.TAIEpoch  —  Method TAIEpoch(jd1::T, jd2::T=zero(T); origin=:j2000) where T<:AstroPeriod Construct a TAIEpoch from a Julian date (optionally split into  jd1  and  jd2 ).  origin  determines the variant of Julian date that is used. Possible values are: :j2000 : J2000 Julian date, starts at  2000-01-01T12:00 :julian : Julian date, starts at  -4712-01-01T12:00 :modified_julian : Modified Julian date, starts at  1858-11-17T00:00 Examples julia> TAIEpoch(0.0days, 0.5days)\n2000-01-02T00:00:00.000 TAI\n\njulia> TAIEpoch(2.451545e6days, origin=:julian)\n2000-01-01T12:00:00.000 TAI source"},{"id":57,"pagetitle":"Epochs","title":"AstroTime.Epochs.TCBEpoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.TCBEpoch-Tuple{AbstractString}","content":" AstroTime.Epochs.TCBEpoch  —  Method TCBEpoch(str[, format]) Construct a TCBEpoch from a string  str . Optionally a  format  definition can be passed as a  DateFormat  object or as a string. In addition to the character codes supported by  DateFormat  the code  D  is supported which is parsed as \"day of year\" (see the example below). The default format is  yyyy-mm-ddTHH:MM:SS.sss . Example julia> TCBEpoch(\"2018-02-06T20:45:00.0\")\n2018-02-06T20:45:00.000 TCB\n\njulia> TCBEpoch(\"February 6, 2018\", \"U d, y\")\n2018-02-06T00:00:00.000 TCB\n\njulia> TCBEpoch(\"2018-37T00:00\", \"yyyy-DDDTHH:MM\")\n2018-02-06T00:00:00.000 TCB source"},{"id":58,"pagetitle":"Epochs","title":"AstroTime.Epochs.TCBEpoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.TCBEpoch-Tuple{Int64, Int64, Int64}","content":" AstroTime.Epochs.TCBEpoch  —  Method TCBEpoch(year, month, day, hour=0, minute=0, second=0.0) Construct a TCBEpoch from date and time components. Example julia> TCBEpoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TCB\n\njulia> TCBEpoch(2018, 2, 6)\n2018-02-06T00:00:00.000 TCB source"},{"id":59,"pagetitle":"Epochs","title":"AstroTime.Epochs.TCBEpoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.TCBEpoch-Tuple{Number, Number}","content":" AstroTime.Epochs.TCBEpoch  —  Method TCBEpoch(jd1::T, jd2::T=zero(T); origin=:j2000) where T<:AstroPeriod Construct a TCBEpoch from a Julian date (optionally split into  jd1  and  jd2 ).  origin  determines the variant of Julian date that is used. Possible values are: :j2000 : J2000 Julian date, starts at  2000-01-01T12:00 :julian : Julian date, starts at  -4712-01-01T12:00 :modified_julian : Modified Julian date, starts at  1858-11-17T00:00 Examples julia> TCBEpoch(0.0days, 0.5days)\n2000-01-02T00:00:00.000 TCB\n\njulia> TCBEpoch(2.451545e6days, origin=:julian)\n2000-01-01T12:00:00.000 TCB source"},{"id":60,"pagetitle":"Epochs","title":"AstroTime.Epochs.TCGEpoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.TCGEpoch-Tuple{AbstractString}","content":" AstroTime.Epochs.TCGEpoch  —  Method TCGEpoch(str[, format]) Construct a TCGEpoch from a string  str . Optionally a  format  definition can be passed as a  DateFormat  object or as a string. In addition to the character codes supported by  DateFormat  the code  D  is supported which is parsed as \"day of year\" (see the example below). The default format is  yyyy-mm-ddTHH:MM:SS.sss . Example julia> TCGEpoch(\"2018-02-06T20:45:00.0\")\n2018-02-06T20:45:00.000 TCG\n\njulia> TCGEpoch(\"February 6, 2018\", \"U d, y\")\n2018-02-06T00:00:00.000 TCG\n\njulia> TCGEpoch(\"2018-37T00:00\", \"yyyy-DDDTHH:MM\")\n2018-02-06T00:00:00.000 TCG source"},{"id":61,"pagetitle":"Epochs","title":"AstroTime.Epochs.TCGEpoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.TCGEpoch-Tuple{Int64, Int64, Int64}","content":" AstroTime.Epochs.TCGEpoch  —  Method TCGEpoch(year, month, day, hour=0, minute=0, second=0.0) Construct a TCGEpoch from date and time components. Example julia> TCGEpoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TCG\n\njulia> TCGEpoch(2018, 2, 6)\n2018-02-06T00:00:00.000 TCG source"},{"id":62,"pagetitle":"Epochs","title":"AstroTime.Epochs.TCGEpoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.TCGEpoch-Tuple{Number, Number}","content":" AstroTime.Epochs.TCGEpoch  —  Method TCGEpoch(jd1::T, jd2::T=zero(T); origin=:j2000) where T<:AstroPeriod Construct a TCGEpoch from a Julian date (optionally split into  jd1  and  jd2 ).  origin  determines the variant of Julian date that is used. Possible values are: :j2000 : J2000 Julian date, starts at  2000-01-01T12:00 :julian : Julian date, starts at  -4712-01-01T12:00 :modified_julian : Modified Julian date, starts at  1858-11-17T00:00 Examples julia> TCGEpoch(0.0days, 0.5days)\n2000-01-02T00:00:00.000 TCG\n\njulia> TCGEpoch(2.451545e6days, origin=:julian)\n2000-01-01T12:00:00.000 TCG source"},{"id":63,"pagetitle":"Epochs","title":"AstroTime.Epochs.TDBEpoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.TDBEpoch-Tuple{AbstractString}","content":" AstroTime.Epochs.TDBEpoch  —  Method TDBEpoch(str[, format]) Construct a TDBEpoch from a string  str . Optionally a  format  definition can be passed as a  DateFormat  object or as a string. In addition to the character codes supported by  DateFormat  the code  D  is supported which is parsed as \"day of year\" (see the example below). The default format is  yyyy-mm-ddTHH:MM:SS.sss . Example julia> TDBEpoch(\"2018-02-06T20:45:00.0\")\n2018-02-06T20:45:00.000 TDB\n\njulia> TDBEpoch(\"February 6, 2018\", \"U d, y\")\n2018-02-06T00:00:00.000 TDB\n\njulia> TDBEpoch(\"2018-37T00:00\", \"yyyy-DDDTHH:MM\")\n2018-02-06T00:00:00.000 TDB source"},{"id":64,"pagetitle":"Epochs","title":"AstroTime.Epochs.TDBEpoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.TDBEpoch-Tuple{Int64, Int64, Int64}","content":" AstroTime.Epochs.TDBEpoch  —  Method TDBEpoch(year, month, day, hour=0, minute=0, second=0.0) Construct a TDBEpoch from date and time components. Example julia> TDBEpoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TDB\n\njulia> TDBEpoch(2018, 2, 6)\n2018-02-06T00:00:00.000 TDB source"},{"id":65,"pagetitle":"Epochs","title":"AstroTime.Epochs.TDBEpoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.TDBEpoch-Tuple{Number, Number}","content":" AstroTime.Epochs.TDBEpoch  —  Method TDBEpoch(jd1::T, jd2::T=zero(T); origin=:j2000) where T<:AstroPeriod Construct a TDBEpoch from a Julian date (optionally split into  jd1  and  jd2 ).  origin  determines the variant of Julian date that is used. Possible values are: :j2000 : J2000 Julian date, starts at  2000-01-01T12:00 :julian : Julian date, starts at  -4712-01-01T12:00 :modified_julian : Modified Julian date, starts at  1858-11-17T00:00 Examples julia> TDBEpoch(0.0days, 0.5days)\n2000-01-02T00:00:00.000 TDB\n\njulia> TDBEpoch(2.451545e6days, origin=:julian)\n2000-01-01T12:00:00.000 TDB source"},{"id":66,"pagetitle":"Epochs","title":"AstroTime.Epochs.TTEpoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.TTEpoch-Tuple{AbstractString}","content":" AstroTime.Epochs.TTEpoch  —  Method TTEpoch(str[, format]) Construct a TTEpoch from a string  str . Optionally a  format  definition can be passed as a  DateFormat  object or as a string. In addition to the character codes supported by  DateFormat  the code  D  is supported which is parsed as \"day of year\" (see the example below). The default format is  yyyy-mm-ddTHH:MM:SS.sss . Example julia> TTEpoch(\"2018-02-06T20:45:00.0\")\n2018-02-06T20:45:00.000 TT\n\njulia> TTEpoch(\"February 6, 2018\", \"U d, y\")\n2018-02-06T00:00:00.000 TT\n\njulia> TTEpoch(\"2018-37T00:00\", \"yyyy-DDDTHH:MM\")\n2018-02-06T00:00:00.000 TT source"},{"id":67,"pagetitle":"Epochs","title":"AstroTime.Epochs.TTEpoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.TTEpoch-Tuple{Int64, Int64, Int64}","content":" AstroTime.Epochs.TTEpoch  —  Method TTEpoch(year, month, day, hour=0, minute=0, second=0.0) Construct a TTEpoch from date and time components. Example julia> TTEpoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TT\n\njulia> TTEpoch(2018, 2, 6)\n2018-02-06T00:00:00.000 TT source"},{"id":68,"pagetitle":"Epochs","title":"AstroTime.Epochs.TTEpoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.TTEpoch-Tuple{Number, Number}","content":" AstroTime.Epochs.TTEpoch  —  Method TTEpoch(jd1::T, jd2::T=zero(T); origin=:j2000) where T<:AstroPeriod Construct a TTEpoch from a Julian date (optionally split into  jd1  and  jd2 ).  origin  determines the variant of Julian date that is used. Possible values are: :j2000 : J2000 Julian date, starts at  2000-01-01T12:00 :julian : Julian date, starts at  -4712-01-01T12:00 :modified_julian : Modified Julian date, starts at  1858-11-17T00:00 Examples julia> TTEpoch(0.0days, 0.5days)\n2000-01-02T00:00:00.000 TT\n\njulia> TTEpoch(2.451545e6days, origin=:julian)\n2000-01-01T12:00:00.000 TT source"},{"id":69,"pagetitle":"Epochs","title":"AstroTime.Epochs.UT1Epoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.UT1Epoch-Tuple{AbstractString}","content":" AstroTime.Epochs.UT1Epoch  —  Method UT1Epoch(str[, format]) Construct a UT1Epoch from a string  str . Optionally a  format  definition can be passed as a  DateFormat  object or as a string. In addition to the character codes supported by  DateFormat  the code  D  is supported which is parsed as \"day of year\" (see the example below). The default format is  yyyy-mm-ddTHH:MM:SS.sss . Example julia> UT1Epoch(\"2018-02-06T20:45:00.0\")\n2018-02-06T20:45:00.000 UT1\n\njulia> UT1Epoch(\"February 6, 2018\", \"U d, y\")\n2018-02-06T00:00:00.000 UT1\n\njulia> UT1Epoch(\"2018-37T00:00\", \"yyyy-DDDTHH:MM\")\n2018-02-06T00:00:00.000 UT1 source"},{"id":70,"pagetitle":"Epochs","title":"AstroTime.Epochs.UT1Epoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.UT1Epoch-Tuple{Int64, Int64, Int64}","content":" AstroTime.Epochs.UT1Epoch  —  Method UT1Epoch(year, month, day, hour=0, minute=0, second=0.0) Construct a UT1Epoch from date and time components. Example julia> UT1Epoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 UT1\n\njulia> UT1Epoch(2018, 2, 6)\n2018-02-06T00:00:00.000 UT1 source"},{"id":71,"pagetitle":"Epochs","title":"AstroTime.Epochs.UT1Epoch","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.UT1Epoch-Tuple{Number, Number}","content":" AstroTime.Epochs.UT1Epoch  —  Method UT1Epoch(jd1::T, jd2::T=zero(T); origin=:j2000) where T<:AstroPeriod Construct a UT1Epoch from a Julian date (optionally split into  jd1  and  jd2 ).  origin  determines the variant of Julian date that is used. Possible values are: :j2000 : J2000 Julian date, starts at  2000-01-01T12:00 :julian : Julian date, starts at  -4712-01-01T12:00 :modified_julian : Modified Julian date, starts at  1858-11-17T00:00 Examples julia> UT1Epoch(0.0days, 0.5days)\n2000-01-02T00:00:00.000 UT1\n\njulia> UT1Epoch(2.451545e6days, origin=:julian)\n2000-01-01T12:00:00.000 UT1 source"},{"id":72,"pagetitle":"Epochs","title":"AstroTime.AstroDates.fractionofday","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.AstroDates.fractionofday-Tuple{Epoch}","content":" AstroTime.AstroDates.fractionofday  —  Method fractionofday(ep::Epoch) Get the time of the day of the epoch  ep  as a fraction. source"},{"id":73,"pagetitle":"Epochs","title":"AstroTime.AstroDates.fractionofsecond","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.AstroDates.fractionofsecond-Tuple{Epoch}","content":" AstroTime.AstroDates.fractionofsecond  —  Method fractionofsecond(ep::Epoch) Get the fraction of the current second of the epoch  ep . source"},{"id":74,"pagetitle":"Epochs","title":"AstroTime.AstroDates.j2000","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.AstroDates.j2000-Tuple{Epoch}","content":" AstroTime.AstroDates.j2000  —  Method j2000(ep) Return the J2000 Julian Date for epoch  ep . Example julia> j2000(TAIEpoch(2000, 1, 1, 12))\n0.0 days source"},{"id":75,"pagetitle":"Epochs","title":"AstroTime.AstroDates.julian","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.AstroDates.julian-Tuple{Epoch}","content":" AstroTime.AstroDates.julian  —  Method julian(ep) Return the Julian Date for epoch  ep . Example julia> julian(TAIEpoch(2000, 1, 1, 12))\n2.451545e6 days source"},{"id":76,"pagetitle":"Epochs","title":"AstroTime.AstroDates.julian_twopart","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.AstroDates.julian_twopart-Tuple{Epoch}","content":" AstroTime.AstroDates.julian_twopart  —  Method julian_twopart(ep) Return the two-part Julian Date for epoch  ep , which is a tuple consisting of the Julian day number and the fraction of the day. Example julia> julian_twopart(TAIEpoch(2000, 1, 2))\n(2.451545e6 days, 0.5 days) source"},{"id":77,"pagetitle":"Epochs","title":"AstroTime.AstroDates.subsecond","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.AstroDates.subsecond-Tuple{Epoch, Any}","content":" AstroTime.AstroDates.subsecond  —  Method subsecond(ep::Epoch, n) Get the number of fractional seconds with the unit  $s * \\frac{1}{10^n}$ , e.g.  subsecond(ep, 3)  for milliseconds, of the epoch  ep .  n  must be divisible by 3. source"},{"id":78,"pagetitle":"Epochs","title":"AstroTime.Epochs.from_utc","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.from_utc","content":" AstroTime.Epochs.from_utc  —  Function from_utc(str::AbstractString, dateformat::Dates.DateFormat; scale=TAI)\nfrom_utc(dt::Dates.DateTime; scale=TAI)\nfrom_utc(year, month, day, hour=0, minute=0, second=0, fraction=0.0; scale=TAI)\nfrom_utc(year, month, day, hour, minute, seconds; scale=TAI) Create an  Epoch  in  scale  based on a UTC timestamp,  Dates.DateTime  or date and time components. Examples julia> from_utc(2016, 12, 31, 23, 59, 60, 0.0)\n2017-01-01T00:00:36.000 TAI\n\njulia> from_utc(2016, 12, 31, 23, 59, 60.0)\n2017-01-01T00:00:36.000 TAI\n\njulia> from_utc(\"2016-12-31T23:59:60.0\")\n2017-01-01T00:00:36.000 TAI\n\njulia> from_utc(\"2016-12-31T23:59:60.0\", scale=TDB)\n2017-01-01T00:01:08.183 TDB source"},{"id":79,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset","content":" AstroTime.Epochs.getoffset  —  Function getoffset(UT1, TAI, second, fraction[, eop]) Return the offset between  UT1  and  TAI  for the current epoch ( second  after J2000 and  fraction ) in seconds. Optionally, a custom Earth orientation data struct  eop  can be provided, see  EarthOrientation.jl . Example julia> getoffset(UT1, TAI, 0, 0.0)\n31.644974965344606 source"},{"id":80,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset","content":" AstroTime.Epochs.getoffset  —  Function getoffset(TAI, UT1, second, fraction[, eop]) Return the offset between  TAI  and  UT1  for the current epoch ( second  after J2000 and  fraction ) in seconds. Optionally, a custom Earth orientation data struct  eop  can be provided, see  EarthOrientation.jl . Example julia> getoffset(TAI, UT1, 0, 0.0)\n-31.644974644349812 source"},{"id":81,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Tuple{BarycentricCoordinateTime, BarycentricDynamicalTime, Any, Any}","content":" AstroTime.Epochs.getoffset  —  Method getoffset(TCB, TDB, second, fraction) Return the linear offset between  TCB  and  TDB  for the current epoch ( second  after J2000 and  fraction ) in seconds. Example julia> getoffset(TCB, TDB, 0, 0.0)\n-11.253721593757295 source"},{"id":82,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Tuple{BarycentricDynamicalTime, BarycentricCoordinateTime, Any, Any}","content":" AstroTime.Epochs.getoffset  —  Method getoffset(TDB, TCB, second, fraction) Return the linear offset between  TDB  and  TCB  for the current epoch ( second  after J2000 and  fraction ) in seconds. Example julia> getoffset(TDB, TCB, 0, 0.0)\n11.253721768248475 source"},{"id":83,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Tuple{BarycentricDynamicalTime, TerrestrialTime, Any, Any, Any, Any, Any}","content":" AstroTime.Epochs.getoffset  —  Method getoffset(TDB, TT, second, fraction[, eop]) Return the offset between  TDB  and  TT  for the current epoch ( second  after J2000 and  fraction ) for an observer on earth in seconds. Arguments second ,  fraction : Current epoch elong : Longitude (east positive, radians) u : Distance from Earth's spin axis (km) v : Distance north of equatorial plane (km) Example julia> getoffset(TDB, TT, 0, 0.0, π, 6371.0, 0.0)\n9.928419814106208e-5 References ERFA source"},{"id":84,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Tuple{BarycentricDynamicalTime, TerrestrialTime, Any, Any}","content":" AstroTime.Epochs.getoffset  —  Method getoffset(TDB, TT, second, fraction[, eop]) Return the offset between  TDB  and  TT  for the current epoch ( second  after J2000 and  fraction ) in seconds. This routine is accurate to ~40 microseconds over the interval 1900-2100. Note An accurate transformation between TDB and TT depends on the trajectory of the observer. For two observers fixed on Earth's surface the quantity TDB-TT can differ by as much as ~4 microseconds. See  here . Example julia> getoffset(TDB, TT, 0, 0.0)\n7.273677616693264e-5 References https://www.cv.nrao.edu/~rfisher/Ephemerides/times.html#TDB Issue #26 source"},{"id":85,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Tuple{GeocentricCoordinateTime, TerrestrialTime, Any, Any}","content":" AstroTime.Epochs.getoffset  —  Method getoffset(TCG, TT, second, fraction) Return the linear offset between  TCG  and  TT  for the current epoch ( second  after J2000 and  fraction ) in seconds. Example julia> getoffset(TCG, TT, 0, 0.0)\n-0.5058332856685995 source"},{"id":86,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Tuple{InternationalAtomicTime, TerrestrialTime, Vararg{Any, N} where N}","content":" AstroTime.Epochs.getoffset  —  Method getoffset(TAI, TT, args...) Return the fixed offset between  TAI  and  TT  in seconds. Example julia> getoffset(TAI, TT)\n32.184 source"},{"id":87,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Tuple{TerrestrialTime, BarycentricDynamicalTime, Any, Any, Any, Any, Any}","content":" AstroTime.Epochs.getoffset  —  Method getoffset(TT, TDB, second, fraction[, eop]) Return the offset between  TT  and  TDB  for the current epoch ( second  after J2000 and  fraction ) for an observer on earth in seconds. Arguments second ,  fraction : Current epoch elong : Longitude (east positive, radians) u : Distance from Earth's spin axis (km) v : Distance north of equatorial plane (km) Example julia> getoffset(TT, TDB, 0, 0.0, π, 6371.0, 0.0)\n-9.928419818977206e-5 References ERFA source"},{"id":88,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Tuple{TerrestrialTime, BarycentricDynamicalTime, Any, Any}","content":" AstroTime.Epochs.getoffset  —  Method getoffset(TT, TDB, second, fraction[, eop]) Return the offset between  TT  and  TDB  for the current epoch ( second  after J2000 and  fraction ) in seconds. This routine is accurate to ~40 microseconds over the interval 1900-2100. Note An accurate transformation between TDB and TT depends on the trajectory of the observer. For two observers fixed on Earth's surface the quantity TDB-TT can differ by as much as ~4 microseconds. See  here . Example julia> getoffset(TT, TDB, 0, 0.0)\n-7.273677619130569e-5 References https://www.cv.nrao.edu/~rfisher/Ephemerides/times.html#TDB Issue #26 source"},{"id":89,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Tuple{TerrestrialTime, GeocentricCoordinateTime, Any, Any}","content":" AstroTime.Epochs.getoffset  —  Method getoffset(TT, TCG, second, fraction) Return the linear offset between  TT  and  TCG  for the current epoch ( second  after J2000 and  fraction ) in seconds. Example julia> getoffset(TT, TCG, 0, 0.0)\n0.5058332860211293 source"},{"id":90,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Tuple{TerrestrialTime, InternationalAtomicTime, Vararg{Any, N} where N}","content":" AstroTime.Epochs.getoffset  —  Method getoffset(TT, TAI, args...) Return the fixed offset between  TT  and  TAI  in seconds. Example julia> getoffset(TT, TAI)\n-32.184 source"},{"id":91,"pagetitle":"Epochs","title":"AstroTime.Epochs.getoffset","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.getoffset-Union{Tuple{S}, Tuple{Epoch{S, T} where T, TimeScale, Vararg{Any, N} where N}} where S<:TimeScale","content":" AstroTime.Epochs.getoffset  —  Method getoffset(ep::Epoch, scale::TimeScale) For a given epoch  ep  return the offset between its time scale and another time  scale  in seconds. Example julia> tai = TAIEpoch(2000, 1, 1)\n2000-01-01T00:00:00.000 TAI\n\njulia> getoffset(tai, TT)\n32.184 source"},{"id":92,"pagetitle":"Epochs","title":"AstroTime.Epochs.julian_period","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.julian_period-Tuple{Epoch}","content":" AstroTime.Epochs.julian_period  —  Method julian_period([T,] ep::Epoch; origin=:j2000, scale=timescale(ep), unit=days) Return the period since Julian Epoch  origin  within the time scale  scale  expressed in  unit  for a given epoch  ep . The result is an  AstroPeriod  object by default. If the type argument  T  is present, the result is converted to  T  instead. Example julia> ep = TAIEpoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TAI\n\njulia> julian_period(ep; scale=TT)\n6611.364955833334 days\n\njulia> julian_period(ep; unit=years)\n18.100929728496464 years\n\njulia> julian_period(Float64, ep)\n6611.364583333333 source"},{"id":93,"pagetitle":"Epochs","title":"AstroTime.Epochs.modified_julian","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.modified_julian-Tuple{Epoch}","content":" AstroTime.Epochs.modified_julian  —  Method modified_julian(ep) Return the Modified Julian Date for epoch  ep . Example julia> modified_julian(TAIEpoch(2000, 1, 1, 12))\n51544.5 days source"},{"id":94,"pagetitle":"Epochs","title":"AstroTime.Epochs.timescale","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.timescale-Tuple{Epoch}","content":" AstroTime.Epochs.timescale  —  Method timescale(ep) Return the time scale of epoch  ep . Example julia> ep = TTEpoch(2000, 1, 1)\n2000-01-01T00:00:00.000 TT\n\njulia> timescale(ep)\nTT source"},{"id":95,"pagetitle":"Epochs","title":"AstroTime.Epochs.to_utc","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.Epochs.to_utc","content":" AstroTime.Epochs.to_utc  —  Function to_utc(ep)\nto_utc(::Type{DateTime}, ep)\nto_utc(::Type{Dates.DateTime}, ep)\nto_utc(::Type{String}, ep, dateformat=Dates.default_format(DateTime)) Create a UTC timestamp or  Dates.DateTime  from an  Epoch ep . Examples julia> tai = from_utc(Dates.DateTime(2018, 2, 6, 20, 45, 0, 0))\n2018-02-06T20:45:37.000 TAI\n\njulia> to_utc(tai)\n\"2018-02-06T20:45:00.000\"\n\njulia> to_utc(String, tai, Dates.dateformat\"yyyy-mm-dd\")\n\"2018-02-06\"\n\njulia> to_utc(Dates.DateTime, tai)\n2018-02-06T20:45:00 source"},{"id":96,"pagetitle":"Epochs","title":"Base.:-","ref":"/previews/PR43/AstroTime/stable/api/epochs/#Base.:--Union{Tuple{S}, Tuple{Epoch{S, T} where T, Epoch{S, T} where T}} where S<:TimeScale","content":" Base.:-  —  Method -(a::Epoch, b::Epoch) Return the duration between epoch  a  and epoch  b . Examples julia> TAIEpoch(2018, 2, 6, 20, 45, 20.0) - TAIEpoch(2018, 2, 6, 20, 45, 0.0)\n20.0 seconds source"},{"id":97,"pagetitle":"Epochs","title":"Dates.day","ref":"/previews/PR43/AstroTime/stable/api/epochs/#Dates.day-Tuple{Epoch}","content":" Dates.day  —  Method day(ep::Epoch) Get the day of the epoch  ep . source"},{"id":98,"pagetitle":"Epochs","title":"Dates.dayofyear","ref":"/previews/PR43/AstroTime/stable/api/epochs/#Dates.dayofyear-Tuple{Epoch}","content":" Dates.dayofyear  —  Method dayofyear(ep::Epoch) Get the day of the year of the epoch  ep . source"},{"id":99,"pagetitle":"Epochs","title":"Dates.hour","ref":"/previews/PR43/AstroTime/stable/api/epochs/#Dates.hour-Tuple{Epoch}","content":" Dates.hour  —  Method hour(ep::Epoch) Get the hour of the epoch  ep . source"},{"id":100,"pagetitle":"Epochs","title":"Dates.microsecond","ref":"/previews/PR43/AstroTime/stable/api/epochs/#Dates.microsecond-Tuple{Epoch}","content":" Dates.microsecond  —  Method microsecond(ep::Epoch) Get the number of microseconds of the epoch  ep . source"},{"id":101,"pagetitle":"Epochs","title":"Dates.millisecond","ref":"/previews/PR43/AstroTime/stable/api/epochs/#Dates.millisecond-Tuple{Epoch}","content":" Dates.millisecond  —  Method millisecond(ep::Epoch) Get the number of milliseconds of the epoch  ep . source"},{"id":102,"pagetitle":"Epochs","title":"Dates.minute","ref":"/previews/PR43/AstroTime/stable/api/epochs/#Dates.minute-Tuple{Epoch}","content":" Dates.minute  —  Method minute(ep::Epoch) Get the minute of the epoch  ep . source"},{"id":103,"pagetitle":"Epochs","title":"Dates.month","ref":"/previews/PR43/AstroTime/stable/api/epochs/#Dates.month-Tuple{Epoch}","content":" Dates.month  —  Method month(ep::Epoch) Get the month of the epoch  ep . source"},{"id":104,"pagetitle":"Epochs","title":"Dates.nanosecond","ref":"/previews/PR43/AstroTime/stable/api/epochs/#Dates.nanosecond-Tuple{Epoch}","content":" Dates.nanosecond  —  Method nanosecond(ep::Epoch) Get the number of nanoseconds of the epoch  ep . source"},{"id":105,"pagetitle":"Epochs","title":"Dates.now","ref":"/previews/PR43/AstroTime/stable/api/epochs/#Dates.now-Union{Tuple{Type{Epoch{S, T} where T}}, Tuple{S}} where S","content":" Dates.now  —  Method now(::Type{Epoch})\nnow(::Type{Epoch{S}}) where S<:TimeScale Get the current date and time as an  Epoch . The default time scale is TAI. Example julia> now(Epoch)\n2021-04-11T13:20:29.160 TAI\n\njulia> now(TDBEpoch)\n2021-04-11T13:21:21.518 TDB source"},{"id":106,"pagetitle":"Epochs","title":"Dates.second","ref":"/previews/PR43/AstroTime/stable/api/epochs/#Dates.second-Tuple{Any, Epoch}","content":" Dates.second  —  Method second(type, ep::Epoch) Get the second of the epoch  ep  as a  type . source"},{"id":107,"pagetitle":"Epochs","title":"Dates.second","ref":"/previews/PR43/AstroTime/stable/api/epochs/#Dates.second-Tuple{Epoch}","content":" Dates.second  —  Method second(ep::Epoch) -> Int Get the second of the epoch  ep  as an  Int . source"},{"id":108,"pagetitle":"Epochs","title":"Dates.year","ref":"/previews/PR43/AstroTime/stable/api/epochs/#Dates.year-Tuple{Epoch}","content":" Dates.year  —  Method year(ep::Epoch) Get the year of the epoch  ep . source"},{"id":109,"pagetitle":"Epochs","title":"Dates.yearmonthday","ref":"/previews/PR43/AstroTime/stable/api/epochs/#Dates.yearmonthday-Tuple{Epoch}","content":" Dates.yearmonthday  —  Method yearmonthday(ep::Epoch) Get the year, month, and day of the epoch  ep  as a tuple. source"},{"id":110,"pagetitle":"Epochs","title":"AstroTime.AstroDates.DateTime","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.AstroDates.DateTime","content":" AstroTime.AstroDates.DateTime  —  Type DateTime(ep::Epoch) Convert the epoch  ep  to an  AstroDates.DateTime . source"},{"id":111,"pagetitle":"Epochs","title":"AstroTime.AstroDates.Date","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.AstroDates.Date","content":" AstroTime.AstroDates.Date  —  Type Date(ep::Epoch) Get the  Date  of the epoch  ep . source"},{"id":112,"pagetitle":"Epochs","title":"AstroTime.AstroDates.Time","ref":"/previews/PR43/AstroTime/stable/api/epochs/#AstroTime.AstroDates.Time","content":" AstroTime.AstroDates.Time  —  Type Time(ep::Epoch) Get the  Time  of the epoch  ep . source"},{"id":115,"pagetitle":"Periods","title":"Periods","ref":"/previews/PR43/AstroTime/stable/api/periods/#Periods","content":" Periods"},{"id":116,"pagetitle":"Periods","title":"AstroTime.Periods.AstroPeriod","ref":"/previews/PR43/AstroTime/stable/api/periods/#AstroTime.Periods.AstroPeriod","content":" AstroTime.Periods.AstroPeriod  —  Type AstroPeriod{U, T}(unit, Δt) where {U<:TimeUnit, T} An  AstroPeriod  object represents a time interval of  Δt  with a  TimeUnit  of  unit .  Periods should be constructed via the shorthand syntax shown in the examples below. Examples julia> 3.0seconds\n3.0 seconds\n\njulia> 1.0minutes\n1.0 minutes\n\njulia> 12hours\n12.0 hours\n\njulia> days_per_year = 365\n365\njulia> days_per_year * days\n365.0 days\n\njulia> 10.0years\n10.0 years\n\njulia> 1centuries\n1.0 centuries source"},{"id":117,"pagetitle":"Periods","title":"AstroTime.Periods.TimeUnit","ref":"/previews/PR43/AstroTime/stable/api/periods/#AstroTime.Periods.TimeUnit","content":" AstroTime.Periods.TimeUnit  —  Type All time units are subtypes of the abstract type  TimeUnit . The following time units are defined: Second Minute Hour Day Year Century source"},{"id":118,"pagetitle":"Periods","title":"AstroTime.Periods.unit","ref":"/previews/PR43/AstroTime/stable/api/periods/#AstroTime.Periods.unit-Tuple{AstroPeriod}","content":" AstroTime.Periods.unit  —  Method unit(p::AstroPeriod) Return the unit of the period  p . Examples julia> unit(3.0seconds)\nAstroTime.Periods.Second() source"},{"id":119,"pagetitle":"Periods","title":"AstroTime.Periods.value","ref":"/previews/PR43/AstroTime/stable/api/periods/#AstroTime.Periods.value-Tuple{AstroPeriod}","content":" AstroTime.Periods.value  —  Method value(p::AstroPeriod) Return the unitless value of the period  p . Examples julia> value(3.0seconds)\n3.0 source"},{"id":122,"pagetitle":"Time Scales","title":"Time Scales","ref":"/previews/PR43/AstroTime/stable/api/timescales/#Time-Scales","content":" Time Scales"},{"id":123,"pagetitle":"Time Scales","title":"AstroTime.update","ref":"/previews/PR43/AstroTime/stable/api/timescales/#AstroTime.update","content":" AstroTime.update  —  Function AstroTime.update() Download up-to-date IERS tables from the internet to enable transformations to and from the  UT1  time scale. source"},{"id":124,"pagetitle":"Time Scales","title":"AstroTime.@timescale","ref":"/previews/PR43/AstroTime/stable/api/timescales/#AstroTime.@timescale","content":" AstroTime.@timescale  —  Macro @timescale scale [parent[, oneway]] Define a new time scale and the corresponding  Epoch  type alias. Arguments scale : The name of the time scale parent : The \"parent\" time scale to which it should be linked (optional) oneway : If  true , only the transformation from  parent  to  scale  is   registered (optional, default:  false ) Example julia> @timescale GMT TAI\n\njulia> GMT isa TimeScale\ntrue\n\njulia> GMTEpoch\nEpoch{GMTScale, T} where T\n\njulia> find_path(TT, GMT)\n3-element Vector{TimeScale}:\n TT\n TAI\n GMT source"},{"id":125,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.TAI","ref":"/previews/PR43/AstroTime/stable/api/timescales/#AstroTime.TimeScales.TAI","content":" AstroTime.TimeScales.TAI  —  Constant TAI The singleton instance of the  InternationalAtomicTime  type representing the International Atomic Time (TAI) time scale. References Wikipedia source"},{"id":126,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.TCB","ref":"/previews/PR43/AstroTime/stable/api/timescales/#AstroTime.TimeScales.TCB","content":" AstroTime.TimeScales.TCB  —  Constant TCB The singleton instance of the  BarycentricCoordinateTime  type representing the Barycentric Coordinate Time (TCB) time scale. References Wikipedia source"},{"id":127,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.TCG","ref":"/previews/PR43/AstroTime/stable/api/timescales/#AstroTime.TimeScales.TCG","content":" AstroTime.TimeScales.TCG  —  Constant TCG The singleton instance of the  GeocentricCoordinateTime  type representing the Geocentric Coordinate Time (TCG) time scale. References Wikipedia source"},{"id":128,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.TDB","ref":"/previews/PR43/AstroTime/stable/api/timescales/#AstroTime.TimeScales.TDB","content":" AstroTime.TimeScales.TDB  —  Constant TDB The singleton instance of the  BarycentricDynamicalTime  type representing the Barycentric Dynamical Time (TDB) time scale. References Wikipedia source"},{"id":129,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.TT","ref":"/previews/PR43/AstroTime/stable/api/timescales/#AstroTime.TimeScales.TT","content":" AstroTime.TimeScales.TT  —  Constant TT The singleton instance of the  TerrestrialTime  type representing the Terrestrial Time (TT) time scale. References Wikipedia source"},{"id":130,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.UT1","ref":"/previews/PR43/AstroTime/stable/api/timescales/#AstroTime.TimeScales.UT1","content":" AstroTime.TimeScales.UT1  —  Constant UT1 The singleton instance of the  UniversalTime  type representing the Universal Time (UT1) time scale. References Wikipedia source"},{"id":131,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.BarycentricCoordinateTime","ref":"/previews/PR43/AstroTime/stable/api/timescales/#AstroTime.TimeScales.BarycentricCoordinateTime","content":" AstroTime.TimeScales.BarycentricCoordinateTime  —  Type BarycentricCoordinateTime A type representing the Barycentric Coordinate Time (TCB) time scale. References Wikipedia source"},{"id":132,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.BarycentricDynamicalTime","ref":"/previews/PR43/AstroTime/stable/api/timescales/#AstroTime.TimeScales.BarycentricDynamicalTime","content":" AstroTime.TimeScales.BarycentricDynamicalTime  —  Type BarycentricDynamicalTime A type representing the Barycentric Dynamical Time (TDB) time scale. References Wikipedia source"},{"id":133,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.GeocentricCoordinateTime","ref":"/previews/PR43/AstroTime/stable/api/timescales/#AstroTime.TimeScales.GeocentricCoordinateTime","content":" AstroTime.TimeScales.GeocentricCoordinateTime  —  Type GeocentricCoordinateTime A type representing the Geocentric Coordinate Time (TCG) time scale. References Wikipedia source"},{"id":134,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.InternationalAtomicTime","ref":"/previews/PR43/AstroTime/stable/api/timescales/#AstroTime.TimeScales.InternationalAtomicTime","content":" AstroTime.TimeScales.InternationalAtomicTime  —  Type InternationalAtomicTime A type representing the International Atomic Time (TAI) time scale. References Wikipedia source"},{"id":135,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.TerrestrialTime","ref":"/previews/PR43/AstroTime/stable/api/timescales/#AstroTime.TimeScales.TerrestrialTime","content":" AstroTime.TimeScales.TerrestrialTime  —  Type TerrestrialTime A type representing the Terrestrial Time (TT) time scale. References Wikipedia source"},{"id":136,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.TimeScale","ref":"/previews/PR43/AstroTime/stable/api/timescales/#AstroTime.TimeScales.TimeScale","content":" AstroTime.TimeScales.TimeScale  —  Type All timescales are subtypes of the abstract type  TimeScale . The following timescales are defined: UT1  — Universal Time TAI  — International Atomic Time TT  — Terrestrial Time TCG  — Geocentric Coordinate Time TCB  — Barycentric Coordinate Time TDB  — Barycentric Dynamical Time source"},{"id":137,"pagetitle":"Time Scales","title":"AstroTime.TimeScales.UniversalTime","ref":"/previews/PR43/AstroTime/stable/api/timescales/#AstroTime.TimeScales.UniversalTime","content":" AstroTime.TimeScales.UniversalTime  —  Type UniversalTime A type representing the Universal Time (UT1) time scale. References Wikipedia source"},{"id":142,"pagetitle":"Tutorial","title":"Tutorial","ref":"/previews/PR43/AstroTime/stable/tutorial/#Tutorial","content":" Tutorial This tutorial will walk you through the features and functionality of AstroTime.jl. Everything in this package revolves around the  Epoch  data type.  Epochs  are a high-precision, time-scale aware version of the  DateTime  type from Julia's standard library. This means that while  DateTime  timestamps are always assumed to be based on Universal Time (UT),  Epochs  can be created in several pre-defined time scales or custom user-defined time scales."},{"id":143,"pagetitle":"Tutorial","title":"Creating Epochs","ref":"/previews/PR43/AstroTime/stable/tutorial/#Creating-Epochs","content":" Creating Epochs You construct  Epoch  instances similar to  DateTime  instances, for example by using date and time components. The main difference is that you need to supply the time scale to be used. Out of the box, the following time scales are defined: TAI :  International Atomic Time UT1 :  Universal Time [1] TT :  Terrestrial Time TCG :  Geocentric Coordinate Time TCB :  Barycentric Coordinate Time TDB :  Barycentric Dynamical Time Conspicuously missing from this list is  Coordinated Universal Time (UTC) . While AstroTime.jl does support UTC, it requires special treatment due to the discontinuities in the time scale from the introduction of leap seconds. See  UTC and Leap Seconds  for more details. using AstroTime\n\nep = Epoch{InternationalAtomicTime}(2018, 2, 6, 20, 45, 0.0)\n\n# The following shorthand syntax also works\nep = TAIEpoch(2018, 2, 6, 20, 45, 0.0)\n\n# Or in another time scale\nep = TTEpoch(2018, 2, 6, 20, 45, 0.0)\n\n# Or use UTC with leap second handling\nep = from_utc(2018, 2, 6, 20, 45, 0.0) You can also parse an  Epoch  from a string. AstroTime.jl uses the  DateFormat  type and specification language from the  Dates  module from Julia's standard library. For example: ep = TAIEpoch(\"2018-02-06T20:45:00.000\", \"yyyy-mm-ddTHH:MM:SS.fff\")\n\n# The format string above `yyyy-mm-ddTHH:MM:SS.fff` is also the default format.\n# Thus, this also works...\nep = TAIEpoch(\"2018-02-06T20:45:00.000\")\n\nimport Dates\n\n# You can also reuse the format string\ndf = Dates.dateformat\"dd.mm.yyyy HH:MM\"\n\nutc = from_utc(\"06.02.2018 20:45\", df)\ntai = TAIEpoch(\"06.02.2018 20:45\", df) There are three additional character codes supported. f : This character code is parsed as the fraction of the current second and supports an arbitrary number of decimal places. t : This character code is parsed as the time scale. D : This character code is parsed as the day number within a year. # The time scale can be omitted from the constructor because it is already\n# defined in the input string\njulia> Epoch(\"2018-02-06T20:45:00.000 TAI\", \"yyyy-mm-ddTHH:MM:SS.fff ttt\")\n2018-02-06T20:45:00.000 TAI\n\n# February 6 is the 37th day of the year\njulia> TAIEpoch(\"2018-037T20:45:00.000\", \"yyyy-DDDTHH:MM:SS.fff\")\n2018-02-06T20:45:00.000 TAI When printing  Epochs , you can format the output in the same way. julia> ep = TAIEpoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TAI\njulia> AstroTime.format(ep, \"dd.mm.yyyy HH:MM ttt\")\n06.02.2018 20:45 TAI"},{"id":144,"pagetitle":"Tutorial","title":"Working with Epochs and Periods","ref":"/previews/PR43/AstroTime/stable/tutorial/#Working-with-Epochs-and-Periods","content":" Working with Epochs and Periods You can shift an  Epoch  in time by adding or subtracting an  AstroPeriod  to it. AstroTime.jl provides a convenient way to construct periods by multiplying a value with a time unit. julia> 23 * seconds\n23 seconds\n\njulia> 1hours # You can use Julia's factor juxtaposition syntax and omit the `*`\n1 hour The following time units are available: seconds minutes hours days years centuries To shift an  Epoch  forward in time add an  AstroPeriod  to it. julia> ep = TAIEpoch(2000, 1, 1)\n2000-01-01T00:00:00.000 TAI\n\njulia> ep + 1days\n2000-01-02T00:00:00.000 TAI Or subtract it to shift the  Epoch  backwards. julia> ep = TAIEpoch(2000, 1, 1)\n2000-01-01T00:00:00.000 TAI\n\njulia> ep - 1days\n1999-12-31T00:00:00.000 TAI If you subtract two epochs you will receive the time between them as an  AstroPeriod . julia> ep1 = TAIEpoch(2000, 1, 1)\n2000-01-01T00:00:00.000 TAI\n\njulia> ep2 = TAIEpoch(2000, 1, 2)\n2000-01-02T00:00:00.000 TAI\n\njulia> ep2 - ep1\n86400.0 seconds You can also construct an  AstroPeriod  with a different time unit from another  AstroPeriod . julia> dt = 86400.0seconds\n86400.0 seconds\n\njulia> days(dt)\n1.0 days To access the raw value of a period, i.e. without a unit, use the  value  function. julia> dt = 86400.0seconds\n86400.0 seconds\n\njulia> value(days(dt))\n1.0"},{"id":145,"pagetitle":"Tutorial","title":"Ranges","ref":"/previews/PR43/AstroTime/stable/tutorial/#Ranges","content":" Ranges You can also construct ranges of  Epoch s. The default step size one second. julia> TAIEpoch(2021, 7, 30, 17, 34, 30.0):TAIEpoch(2021, 7, 30, 17, 34, 31.0)\n2021-07-30T17:34:30.000 TAI:1.0 seconds:2021-07-30T17:34:31.000 TAI Or you can adjust the step size with any of the units supported. julia> collect(TAIEpoch(2000, 1, 1):1days:TAIEpoch(2000, 1, 5))\n5-element Vector{TAIEpoch{Float64}}:\n 2000-01-01T00:00:00.000 TAI\n 2000-01-02T00:00:00.000 TAI\n 2000-01-03T00:00:00.000 TAI\n 2000-01-04T00:00:00.000 TAI\n 2000-01-05T00:00:00.000 TAI"},{"id":146,"pagetitle":"Tutorial","title":"Converting Between Time Scales","ref":"/previews/PR43/AstroTime/stable/tutorial/#Converting-Between-Time-Scales","content":" Converting Between Time Scales You convert an  Epoch  to another time scale by constructing a new  Epoch  with the target time scale from it. julia> tai = TAIEpoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TAI\n\njulia> tt = TTEpoch(tai) # Convert to TT\n2018-02-06T20:45:32.184 TT"},{"id":147,"pagetitle":"Tutorial","title":"UTC and Leap Seconds","ref":"/previews/PR43/AstroTime/stable/tutorial/#UTC-and-Leap-Seconds","content":" UTC and Leap Seconds UTC is the primary civil time standard and aims to provide a time scale based on TAI and uniform SI seconds that is at the same time aligned with UT1 which is based on solar time and governed by the rotation of the Earth. The problem is that Earth's rotation speed is much more irregular compared to atomic clocks which define the SI second. Over the past decades, Earth's rotation has continuously slowed and thus TAI has been running ahead of UT1. Leap seconds are inserted into the UTC time scale to keep it within 0.9 seconds of UT1. This introduces ambiguities in AstroTime.jl's data model (see  #50 ). As a consequence,  UTCEpoch s are not supported. Nevertheless, UTC is supported as an I/O format for timestamps through the  from_utc  and  to_utc  functions. The last leap second was introduced at the end of December 31, 2016. You can create a  TAIEpoch  (or other  Epoch s) from a UTC date with proper leap second handling: julia> from_utc(2016, 12, 31, 23, 59, 60.0)\n2017-01-01T00:00:36.000 TAI\n\njulia> from_utc(\"2016-12-31T23:59:60.0\")\n2017-01-01T00:00:36.000 TAI\n\njulia> from_utc(\"2016-12-31T23:59:60.0\", scale=TDB)\n2017-01-01T00:01:08.183 TDB You can also use  Dates.DateTime  but note that you cannot represent a leap second date with it. julia> tai = from_utc(Dates.DateTime(2018, 2, 6, 20, 45, 0, 0))\n2018-02-06T20:45:37.000 TAI And go back to UTC: julia> to_utc(tai)\n\"2018-02-06T20:45:00.000\"\n\njulia> to_utc(String, tai, Dates.dateformat\"yyyy-mm-dd\")\n\"2018-02-06\"\n\njulia> to_utc(Dates.DateTime, tai)\n2018-02-06T20:45:00"},{"id":148,"pagetitle":"Tutorial","title":"High-Precision Conversions and Custom Offsets","ref":"/previews/PR43/AstroTime/stable/tutorial/#High-Precision-Conversions-and-Custom-Offsets","content":" High-Precision Conversions and Custom Offsets Some time scale transformations depend on measured quantities which cannot be accurately predicted (e.g. UT1) or there are different algorithms which offer variable levels of accuracy. For the former, AstroTime.jl can download the required data automatically from the internet. You need to run  AstroTime.update()  periodically (weekly) to keep this data up-to-date. For the latter, AstroTime.jl will use the alogrithm which provides the best trade-off between accuracy and performance for most applications. If you cannot use the internet or want to use a different data source, e.g. a time ephemeris, to obtain the offset between time scales, you can use the following constructor for epochs which overrides the default algorithms. # AstroTime.jl provides a higher precision TDB<->TT transformation that is dependent on\n# the position of the observer on Earth\n\ntt = TTEpoch(2018, 2, 6, 20, 46, 9.184)\ndt = getoffset(tt, TDB, elong, u, v)\n\n# Use the custom offset for the transformation\ntdb = TDBEpoch(dt, tt)"},{"id":149,"pagetitle":"Tutorial","title":"Working with Julian Dates","ref":"/previews/PR43/AstroTime/stable/tutorial/#Working-with-Julian-Dates","content":" Working with Julian Dates Epochs can be converted to and from  Julian Dates . Three different base epochs are supported: The (default) J2000 date which starts at January 1, 2000, at 12h, the standard Julian date which starts at January 1, 4712BC, at 12h, and the Modified Julian date which starts at November 17, 1858, at midnight. You can get Julian date in days from an  Epoch  like this: julia> ep = TTEpoch(2000,1,2)\n2000-01-02T00:00:00.000 TT\n\njulia> j2000(ep)\n0.5 days\n\njulia> julian(ep)\n2.4515455e6 days\n\njulia> modified_julian(ep)\n51545.0 days To construct an  Epoch  from a Julian date do this: julia> TTEpoch(0.5days) # J2000 is the default\n2000-01-02T00:00:00.000 TT\n\njulia> TTEpoch(0.5days, origin=:j2000)\n2000-01-02T00:00:00.000 TT\n\njulia> TTEpoch(2.4515455e6days, origin=:julian)\n2000-01-02T00:00:00.000 TT\n\njulia> TTEpoch(51545.0days, origin=:modified_julian)\n2000-01-02T00:00:00.000 TT\n\njulia> TTEpoch(86400.0seconds, origin=:j2000)\n2000-01-02T12:00:00.000 TT Some libraries (such as  ERFA ) expect a two-part Julian date as input. You can use  julian_twopart(ep)  in this case. If you need more control over the output, have a look at the  julian_period  function. Warning You should not convert an  Epoch  to a Julian date to do arithmetic because this will result in a loss of accuracy."},{"id":150,"pagetitle":"Tutorial","title":"Converting to Standard Library Types","ref":"/previews/PR43/AstroTime/stable/tutorial/#Converting-to-Standard-Library-Types","content":" Converting to Standard Library Types Epoch  instances satisfy the  AbstractDateTime  interface specified in the  Dates  module of Julia's standard library.  Thus, you should be able to pass them to other libraries which expect a standard  DateTime . Please open an issue on  the issue tracker  if you encounter any problems with this. It is nevertheless possible to convert an  Epoch  to a  DateTime  if it should become necessary. Please note that the time scale information will be lost in the process. julia> ep = TTEpoch(2000,1,1)\n2000-01-01T00:00:00.000 TT\n\njulia> import Dates; Dates.DateTime(ep)\n2000-01-01T00:00:00"},{"id":151,"pagetitle":"Tutorial","title":"Defining Custom Time Scales","ref":"/previews/PR43/AstroTime/stable/tutorial/#Defining-Custom-Time-Scales","content":" Defining Custom Time Scales AstroTime.jl enables you to create your own first-class time scales via the  @timescale  macro. The macro will define the necessary structs and register the new time scale. Let's start with a simple example and assume that you want to define  EphemerisTime  as an alias for  TDB . You need to provide the name of the time scale and optionally a \"parent\" time scale to which it is linked. @timescale EphemerisTime TDB At this point, you can already use the new time scale to create epochs. julia> EphemerisTime\nEphemerisTime\n\njulia> typeof(EphemerisTime)\nEphemerisTimeScale\n\njulia> et = EphemerisTimeEpoch(2000, 1, 1)\n2000-01-01T00:00:00.000 EphemerisTime Conversion to other  Epoch  types will not yet work for the newly created time because you need to provide the necessary methods for  getoffset . If you are unsure which methods are needed, you can try to transform the epoch and the resulting error message will provide a hint. julia> TDBEpoch(et)\nERROR: No conversion 'EphemerisTime->TDB' available. If one of these is a custom time scale,\nyou may need to define `AstroTime.Epochs.getoffset(::EphemerisTimeScale, ::BarycentricDynamicalTime, second, fraction, args...)`. To enable transformations between  EphemerisTime  and  TDB  in both directions you need to define the following methods. Since  EphemerisTime  and  TDB  are identical, the offset between them is zero. AstroTime.Epochs.getoffset(::EphemerisTimeType, ::CoordinatedUniversalTime, second, fraction) = 0.0\nAstroTime.Epochs.getoffset(::CoordinatedUniversalTime, ::EphemerisTimeType, second, fraction) = 0.0 You can now use  EphemerisTimeEpoch  like any other epoch type, e.g. julia> ep = TDBEpoch(2000, 1, 1)\n2000-01-01T00:00:00.000 TDB\n\njulia> EphemerisTimeEpoch(ep)\n2000-01-01T00:00:00.000 EphemerisTime For a more complex example, let's reimplement the Geocentric Coordinate Time (TCG) scale. It is a linear transformation from Terrestrial Time (TT), i.e. the transformation is dependent on the point in time in the current time scale (the  second  and  fraction  arguments to  getoffset ). @timescale CustomTCG TT\n\n# The reference point\nconst JD77_SEC = -7.25803167816e8\n# The linear rate of change\nconst LG_RATE = 6.969290134e-10\n\nfunction getoffset(::CustomTCGScale, ::TerrestrialTime, second, fraction)\n    # `second` is the number of full seconds since 2000-01-01\n    # `fraction` is the fraction of the current second\n    dt = second - JD77_SEC + fraction\n    return -LG_RATE * dt\nend\n\nfunction getoffset(::TerrestrialTime, ::CustomTCGScale, second, fraction)\n    # The inverse rate for the backwards transformation\n    rate = LG_RATE / (1.0 - LG_RATE)\n    dt = second - JD77_SEC + fraction\n    return rate * dt\nend\n Let's assume that you want to define a time scale that determines the  Spacecraft Event Time  which takes the one-way light time into account. You could use the following definitions adding the  distance  parameter which is the distance of the spacecraft from Earth. const speed_of_light = 299792458.0 # m/s\n\n@timescale SCET TAI\n\nfunction AstroTime.Epochs.getoffset(::SCETScale, ::InternationalAtomicTime,\n                                    second, fraction, distance)\n    return distance / speed_of_light\nend\nfunction AstroTime.Epochs.getoffset(::InternationalAtomicTime, ::SCETScale,\n                                    second, fraction, distance)\n    return -distance / speed_of_light\nend If you want to convert another epoch to  SCET , you now need to pass this additional parameter. For example, for a spacecraft that is one astronomical unit away from Earth: julia> astronomical_unit = 149597870700.0 # m\n149597870700.0\n\njulia> ep = TAIEpoch(2000, 1, 1)\n2000-01-01T00:00:00.000 TAI\n\njulia> SCETEpoch(ep, astronomical_unit)\n1999-12-31T23:51:40.995 SCET Note At this time, custom epochs with additional parameters cannot be parsed from strings. You can also introduce time scales that are disjoint from AstroTime.jl's default graph of time scales by defining a time scale without a parent. julia> @timescale Disjoint\n\njulia> typeof(Disjoint)\nDisjointScale By defining additional time scales connected to this scale and the appropriate  getoffset  methods, you can create your own graph of time scales that is completely independent of the defaults provided by the library. 1 Transformations to and from UT1 depend on the measured quantity ΔUT1 which is published in  IERS  tables on a weekly basis. AstroTime.jl can automatically fetch these tables by running  AstroTime.update() . If you work with  UT1 , you need to run this function periodically."},{"id":154,"pagetitle":"Home","title":"ERFA.jl","ref":"/previews/PR43/ERFA/stable/#ERFA.jl","content":" ERFA.jl Julia wrapper for  liberfa ."},{"id":155,"pagetitle":"Home","title":"Installation","ref":"/previews/PR43/ERFA/stable/#Installation","content":" Installation julia> import Pkg; Pkg.add(\"ERFA\")"},{"id":156,"pagetitle":"Home","title":"Example","ref":"/previews/PR43/ERFA/stable/#Example","content":" Example julia> using ERFA\n\njulia> u1, u2 = dtf2d(\"UTC\", 2010, 7, 24, 11, 18, 7.318)\n(2.4554015e6, 0.47091803240740737)\n\njulia> a1, a2 = utctai(u1, u2)\n(2.4554015e6, 0.4713115509259259)\n\njulia> t1, t2 = taitt(a1, a2)\n(2.4554015e6, 0.4716840509259259)\n\njulia> d2dtf(\"TT\", 3, t1, t2)\n(2010, 7, 24, 11, 19, 13, 502)"},{"id":159,"pagetitle":"Functions","title":"Functions","ref":"/previews/PR43/ERFA/stable/api/functions/#Functions","content":" Functions"},{"id":160,"pagetitle":"Functions","title":"ERFA.a2af","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.a2af","content":" ERFA.a2af  —  Function a2af(ndp, a) Decompose radians into degrees, arcminutes, arcseconds, fraction. Given ndp : Resolution (Note 1) angle : Angle in radians Returned sign : '+' or '-' idmsf : Degrees, arcminutes, arcseconds, fraction Called d2tf : decompose days to hms Notes The argument ndp is interpreted as follows: ndp resolution : ...0000 00 00 -7 1000 00 00 -6 100 00 00 -5 10 00 00 -4 1 00 00 -3 0 10 00 -2 0 01 00 -1 0 00 10 0 0 00 01 1 0 00 00.1 2 0 00 00.01 3 0 00 00.001 : 0 00 00.000... The largest positive useful value for ndp is determined by the size of angle, the format of doubles on the target platform, and the risk of overflowing idmsf[3].  On a typical platform, for angle up to 2pi, the available floating-point precision might correspond to ndp=12.  However, the practical limit is typically ndp=9, set by the capacity of a 32-bit int, or ndp=4 if int is only 16 bits. The absolute value of angle may exceed 2pi.  In cases where it does not, it is up to the caller to test for and handle the case where angle is very nearly 2pi and rounds up to 360 degrees, by testing for idmsf[0]=360 and setting idmsf[0-3] to zero. source"},{"id":161,"pagetitle":"Functions","title":"ERFA.a2tf","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.a2tf","content":" ERFA.a2tf  —  Function a2tf(ndp, a) Decompose radians into hours, minutes, seconds, fraction. Given ndp : Resolution (Note 1) angle : Angle in radians Returned sign : '+' or '-' ihmsf : Hours, minutes, seconds, fraction Called d2tf : decompose days to hms Notes The argument ndp is interpreted as follows: ndp resolution : ...0000 00 00 -7 1000 00 00 -6 100 00 00 -5 10 00 00 -4 1 00 00 -3 0 10 00 -2 0 01 00 -1 0 00 10 0 0 00 01 1 0 00 00.1 2 0 00 00.01 3 0 00 00.001 : 0 00 00.000... The largest positive useful value for ndp is determined by the size of angle, the format of doubles on the target platform, and the risk of overflowing ihmsf[3].  On a typical platform, for angle up to 2pi, the available floating-point precision might correspond to ndp=12.  However, the practical limit is typically ndp=9, set by the capacity of a 32-bit int, or ndp=4 if int is only 16 bits. The absolute value of angle may exceed 2pi.  In cases where it does not, it is up to the caller to test for and handle the case where angle is very nearly 2pi and rounds up to 24 hours, by testing for ihmsf[0]=24 and setting ihmsf[0-3] to zero. source"},{"id":162,"pagetitle":"Functions","title":"ERFA.ab","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.ab-NTuple{4, Any}","content":" ERFA.ab  —  Method ab(pnat, v, s, bm1) Apply aberration to transform natural direction into proper direction. Given pnat : Natural direction to the source (unit vector) v : Observer barycentric velocity in units of c s : Distance between the Sun and the observer (au) bm1 :  $\\sqrt{1-|v|^2}$  reciprocal of Lorenz factor Returned ppr : Proper direction to source (unit vector) Notes The algorithm is based on Expr. (7.40) in the Explanatory Supplement (Urban & Seidelmann 2013), but with the following changes: Rigorous rather than approximate normalization is applied. The gravitational potential term from Expr. (7) in  Klioner (2003) is added, taking into account only the Sun's  contribution.  This has a maximum effect of about  0.4 microarcsecond. In almost all cases, the maximum accuracy will be limited by the supplied velocity.  For example, if the ERFA  epv00  function is used, errors of up to 5 microarcseconds could occur. References Urban, S. & Seidelmann, P. K. (eds), Explanatory Supplement to   the Astronomical Almanac, 3rd ed., University Science Books   (2013). Klioner, Sergei A., \"A practical relativistic model for micro-   arcsecond astrometry in space\", Astr. J. 125, 1580-1597 (2003). Called pdp : scalar product of two p-vectors source"},{"id":163,"pagetitle":"Functions","title":"ERFA.ae2hd","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.ae2hd-Tuple{Any, Any, Any}","content":" ERFA.ae2hd  —  Method ae2hd(az, el, phi) Horizon to equatorial coordinates:  transform azimuth and altitude to hour angle and declination. Given az : Azimuth el : Altitude (informally, elevation) phi : Site latitude Returned ha : Hour angle (local) dec : Declination Notes All the arguments are angles in radians. The sign convention for azimuth is north zero, east +pi/2. HA is returned in the range +/-pi.  Declination is returned in the range +/-pi/2. The latitude phi is pi/2 minus the angle between the Earth's rotation axis and the adopted zenith.  In many applications it will be sufficient to use the published geodetic latitude of the site.  In very precise (sub-arcsecond. applications, phi can be corrected for polar motion. The azimuth az must be with respect to the rotational north pole, as opposed to the ITRS pole, and an azimuth with respect to north on a map of the Earth's surface will need to be adjusted for polar motion if sub-arcsecond accuracy is required. Should the user wish to work with respect to the astronomical zenith rather than the geodetic zenith, phi will need to be adjusted for deflection of the vertical (often tens of arcseconds), and the zero point of ha will also be affected. The transformation is the same as  Ve = Ry(phi-pi/2)*Rz(pi)*Vh , where Ve and Vh are lefthanded unit vectors in the (ha,dec. and (az,el. systems respectively and Rz and Ry are rotations about first the z-axis and then the y-axis.  (n.b. Rz(pi. simply reverses the signs of the x and y components.. For efficiency, the algorithm is written out rather than calling other utility functions.  For applications that require even greater efficiency, additional savings are possible if constant terms such as functions of latitude are computed once and for all. Again for efficiency, no range checking of arguments is carried out. source"},{"id":164,"pagetitle":"Functions","title":"ERFA.af2a","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.af2a-NTuple{4, Any}","content":" ERFA.af2a  —  Method af2a(s, ideg, iamin, asec) Convert degrees, arcminutes, arcseconds to radians. Given s : Sign:  '-' = negative, otherwise positive ideg : Degrees iamin : Arcminutes asec : Arcseconds Returned rad : Angle in radians Notes The result is computed even if any of the range checks fail. Negative ideg, iamin and/or asec produce a warning status, but  the absolute value is used in the conversion. If there are multiple errors, the status value reflects only the  first, the smallest taking precedence. source"},{"id":165,"pagetitle":"Functions","title":"ERFA.anp","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.anp","content":" ERFA.anp  —  Function anp(a) Normalize angle into the range 0 <= a < 2pi. Deprecated Use  Base.mod2pi  instead. Given a : Angle (radians) Returned Angle in range 0-2pi source"},{"id":166,"pagetitle":"Functions","title":"ERFA.anpm","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.anpm-Tuple{Any}","content":" ERFA.anpm  —  Method anpm(a) Normalize angle into the range -pi <= a < +pi. Given a : Angle (radians) Returned Angle in range +/-pi source"},{"id":167,"pagetitle":"Functions","title":"ERFA.apcg","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.apcg-NTuple{4, Any}","content":" ERFA.apcg  —  Method apcg(date1, date2, ebpv, ehp) For a geocentric observer, prepare star-independent astrometry parameters for transformations between ICRS and GCRS coordinates. The Earth ephemeris is supplied by the caller. The parameters produced by this function are required in the parallax, light deflection and aberration parts of the astrometric transformation chain. Given date1 : TDB as a 2-part... date2 : ...Julian Date (Note 1) ebpv : Earth barycentric pos/vel (au, au/day) ehp : Earth heliocentric position (au) Returned astrom : Star-independent astrometry parameters: pmt : PM time interval (SSB, Julian years) eb : SSB to observer (vector, au) eh : Sun to observer (unit vector) em : Distance from Sun to observer (au) v : Barycentric observer velocity (vector, c) bm1 :  $\\sqrt{1-|v|^2}$  Reciprocal of Lorenz factor bpn : Bias-precession-nutation matrix along : unchanged xpl : unchanged ypl : unchanged sphi : unchanged cphi : unchanged diurab : unchanged l : unchanged refa : unchanged refb : unchanged Notes The TDB date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TDB)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience.  For most applications of this function the choice will not be at all critical. TT can be used instead of TDB without any significant impact on accuracy. All the vectors are with respect to BCRS axes. This is one of several functions that inserts into the astrom structure star-independent parameters needed for the chain of astrometric transformations ICRS <-> GCRS <-> CIRS <-> observed. The various functions support different classes of observer and portions of the transformation chain: Functions Observer Transformation apcg apcg13 geocentric ICRS <-> GCRS apci apci13 terrestrial ICRS <-> CIRS apco apco13 terrestrial ICRS <-> observed apcs apcs13 space ICRS <-> GCRS aper aper13 terrestrial update Earth rotation apio apio13 terrestrial CIRS <-> observed Those with names ending in \"13\" use contemporary ERFA models to compute the various ephemerides.  The others accept ephemerides supplied by the caller. The transformation from ICRS to GCRS covers space motion, parallax, light deflection, and aberration.  From GCRS to CIRS comprises frame bias and precession-nutation.  From CIRS to observed takes account of Earth rotation, polar motion, diurnal aberration and parallax (unless subsumed into the ICRS <-> GCRS transformation), and atmospheric refraction. The context structure astrom produced by this function is used by  atciq*  and  aticq* . Called apcs : astrometry parameters, ICRS-GCRS, space observer source"},{"id":168,"pagetitle":"Functions","title":"ERFA.apcg13","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.apcg13-Tuple{Any, Any}","content":" ERFA.apcg13  —  Method apcg13(date1, date2) For a geocentric observer, prepare star-independent astrometry parameters for transformations between ICRS and GCRS coordinates. The caller supplies the date, and ERFA models are used to predict the Earth ephemeris. The parameters produced by this function are required in the parallax, light deflection and aberration parts of the astrometric transformation chain. Given date1 : TDB as a 2-part... date2 : ...Julian Date (Note 1) Returned astrom : Star-independent astrometry parameters: pmt : PM time interval (SSB, Julian years) eb : SSB to observer (vector, au) eh : Sun to observer (unit vector) em : Distance from Sun to observer (au) v : Barycentric observer velocity (vector, c) bm1 :  $\\sqrt{1-|v|^2}$  Reciprocal of Lorenz factor bpn : Bias-precession-nutation matrix along : unchanged xpl : unchanged ypl : unchanged sphi : unchanged cphi : unchanged diurab : unchanged l : unchanged refa : unchanged refb : unchanged Notes The TDB date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TDB)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience.  For most applications of this function the choice will not be at all critical. TT can be used instead of TDB without any significant impact on accuracy. All the vectors are with respect to BCRS axes. In cases where the caller wishes to supply his own Earth ephemeris, the function  apcg  can be used instead of the present function. This is one of several functions that inserts into the astrom structure star-independent parameters needed for the chain of astrometric transformations ICRS <-> GCRS <-> CIRS <-> observed. The various functions support different classes of observer and portions of the transformation chain: Functions Observer Transformation apcg apcg13 geocentric ICRS <-> GCRS apci apci13 terrestrial ICRS <-> CIRS apco apco13 terrestrial ICRS <-> observed apcs apcs13 space ICRS <-> GCRS aper aper13 terrestrial update Earth rotation apio apio13 terrestrial CIRS <-> observed Those with names ending in \"13\" use contemporary ERFA models to compute the various ephemerides.  The others accept ephemerides supplied by the caller. The transformation from ICRS to GCRS covers space motion, parallax, light deflection, and aberration.  From GCRS to CIRS comprises frame bias and precession-nutation.  From CIRS to observed takes account of Earth rotation, polar motion, diurnal aberration and parallax (unless subsumed into the ICRS <-> GCRS transformation), and atmospheric refraction. The context structure astrom produced by this function is used by  atciq*  and  aticq* . Called epv00 : Earth position and velocity apcg : astrometry parameters, ICRS-GCRS, geocenter source"},{"id":169,"pagetitle":"Functions","title":"ERFA.apci","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.apci-NTuple{7, Any}","content":" ERFA.apci  —  Method apci(date1, date2, ebpv, ehp, x, y, s) For a terrestrial observer, prepare star-independent astrometry parameters for transformations between ICRS and geocentric CIRS coordinates.  The Earth ephemeris and CIP/CIO are supplied by the caller. The parameters produced by this function are required in the parallax, light deflection, aberration, and bias-precession-nutation parts of the astrometric transformation chain. Given date1 : TDB as a 2-part... date2 : ...Julian Date (Note 1) ebpv : Earth barycentric position/velocity (au, au/day) ehp : Earth heliocentric position (au) x ,  y : CIP X,Y (components of unit vector) s : The CIO locator s (radians) Returned astrom : Star-independent astrometry parameters: pmt : PM time interval (SSB, Julian years) eb : SSB to observer (vector, au) eh : Sun to observer (unit vector) em : Distance from Sun to observer (au) v : Barycentric observer velocity (vector, c) bm1 :  $\\sqrt{1-|v|^2}$  Reciprocal of Lorenz factor bpn : Bias-precession-nutation matrix along : unchanged xpl : unchanged ypl : unchanged sphi : unchanged cphi : unchanged diurab : unchanged l : unchanged refa : unchanged refb : unchanged Notes The TDB date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TDB)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience.  For most applications of this function the choice will not be at all critical. TT can be used instead of TDB without any significant impact on accuracy. All the vectors are with respect to BCRS axes. In cases where the caller does not wish to provide the Earth ephemeris and CIP/CIO, the function  apci13  can be used instead of the present function.  This computes the required quantities using other ERFA functions. This is one of several functions that inserts into the astrom structure star-independent parameters needed for the chain of astrometric transformations ICRS <-> GCRS <-> CIRS <-> observed. The various functions support different classes of observer and portions of the transformation chain: Functions Observer Transformation apcg apcg13 geocentric ICRS <-> GCRS apci apci13 terrestrial ICRS <-> CIRS apco apco13 terrestrial ICRS <-> observed apcs apcs13 space ICRS <-> GCRS aper aper13 terrestrial update Earth rotation apio apio13 terrestrial CIRS <-> observed Those with names ending in \"13\" use contemporary ERFA models to compute the various ephemerides.  The others accept ephemerides supplied by the caller. The transformation from ICRS to GCRS covers space motion, parallax, light deflection, and aberration.  From GCRS to CIRS comprises frame bias and precession-nutation.  From CIRS to observed takes account of Earth rotation, polar motion, diurnal aberration and parallax (unless subsumed into the ICRS <-> GCRS transformation), and atmospheric refraction. The context structure astrom produced by this function is used by  atciq*  and  aticq* . Called apcg : astrometry parameters, ICRS-GCRS, geocenter c2ixys : celestial-to-intermediate matrix, given X,Y and s source"},{"id":170,"pagetitle":"Functions","title":"ERFA.apci13","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.apci13-Tuple{Any, Any}","content":" ERFA.apci13  —  Method apci13(date1, date2) For a terrestrial observer, prepare star-independent astrometry parameters for transformations between ICRS and geocentric CIRS coordinates.  The caller supplies the date, and ERFA models are used to predict the Earth ephemeris and CIP/CIO. The parameters produced by this function are required in the parallax, light deflection, aberration, and bias-precession-nutation parts of the astrometric transformation chain. Given date1 : TDB as a 2-part... date2 : ...Julian Date (Note 1) Returned astrom : Star-independent astrometry parameters: pmt : PM time interval (SSB, Julian years) eb : SSB to observer (vector, au) eh : Sun to observer (unit vector) em : Distance from Sun to observer (au) v : Barycentric observer velocity (vector, c) bm1 :  $\\sqrt{1-|v|^2}$  Reciprocal of Lorenz factor bpn : Bias-precession-nutation matrix along : unchanged xpl : unchanged ypl : unchanged sphi : unchanged cphi : unchanged diurab : unchanged l : unchanged refa : unchanged refb : unchanged eo : Equation of the origins (ERA-GST) Notes The TDB date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TDB)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience.  For most applications of this function the choice will not be at all critical. TT can be used instead of TDB without any significant impact on accuracy. All the vectors are with respect to BCRS axes. In cases where the caller wishes to supply his own Earth ephemeris and CIP/CIO, the function  apci  can be used instead of the present function. This is one of several functions that inserts into the astrom structure star-independent parameters needed for the chain of astrometric transformations ICRS <-> GCRS <-> CIRS <-> observed. The various functions support different classes of observer and portions of the transformation chain: Functions Observer Transformation apcg apcg13 geocentric ICRS <-> GCRS apci apci13 terrestrial ICRS <-> CIRS apco apco13 terrestrial ICRS <-> observed apcs apcs13 space ICRS <-> GCRS aper aper13 terrestrial update Earth rotation apio apio13 terrestrial CIRS <-> observed Those with names ending in \"13\" use contemporary ERFA models to compute the various ephemerides.  The others accept ephemerides supplied by the caller. The transformation from ICRS to GCRS covers space motion, parallax, light deflection, and aberration.  From GCRS to CIRS comprises frame bias and precession-nutation.  From CIRS to observed takes account of Earth rotation, polar motion, diurnal aberration and parallax (unless subsumed into the ICRS <-> GCRS transformation), and atmospheric refraction. The context structure astrom produced by this function is used by  atciq*  and  aticq* . Called epv00 : Earth position and velocity pnm06a : classical NPB matrix, IAU 2006/2000A bpn2xy : extract CIP X,Y coordinates from NPB matrix s06 : the CIO locator s, given X,Y, IAU 2006 apci : astrometry parameters, ICRS-CIRS eors : equation of the origins, given NPB matrix and s source"},{"id":171,"pagetitle":"Functions","title":"ERFA.apco","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.apco-NTuple{16, Any}","content":" ERFA.apco  —  Method apco(date1, date2, ebpv, ehp, x, y, s, theta, elong, phi, hm, xp, yp, sp, refa, refb) For a terrestrial observer, prepare star-independent astrometry parameters for transformations between ICRS and observed coordinates.  The caller supplies the Earth ephemeris, the Earth rotation information and the refraction constants as well as the site coordinates. Given date1 : TDB as a 2-part... date2 : ...Julian Date (Note 1) ebpv : Earth barycentric PV (au, au/day, Note 2) ehp : Earth heliocentric P (au, Note 2) x ,  y : CIP X,Y (components of unit vector) s : The CIO locator s (radians) theta : Earth rotation angle (radians) elong : Longitude (radians, east +ve, Note 3) phi : Latitude (geodetic, radians, Note 3) hm : Height above ellipsoid (m, geodetic, Note 3) xp ,  yp : Polar motion coordinates (radians, Note 4) sp : The TIO locator s' (radians, Note 4) refa : Refraction constant A (radians, Note 5) refb : Refraction constant B (radians, Note 5) Returned astrom : Star-independent astrometry parameters: pmt : PM time interval (SSB, Julian years) eb : SSB to observer (vector, au) eh : Sun to observer (unit vector) em : Distance from Sun to observer (au) v : Barycentric observer velocity (vector, c) bm1 :  $\\sqrt{1-|v|^2}$  Reciprocal of Lorenz factor bpn : Bias-precession-nutation matrix along : Longitude + s' (radians) xp1 : Polar motion xp wrt local meridian (radians) yp1 : Polar motion yp wrt local meridian (radians) sphi : Sine of geodetic latitude cphi : Cosine of geodetic latitude diurab : Magnitude of diurnal aberration vector l : \"Local\" Earth rotation angle (radians) refa : Refraction constant A (radians) refb : Refraction constant B (radians) Notes The TDB date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TDB)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience.  For most applications of this function the choice will not be at all critical. TT can be used instead of TDB without any significant impact on accuracy. The vectors eb, eh, and all the astrom vectors, are with respect to BCRS axes. The geographical coordinates are with respect to the  WGS84  reference ellipsoid.  TAKE CARE WITH THE LONGITUDE SIGN CONVENTION:  the longitude required by the present function is right-handed, i.e. east-positive, in accordance with geographical convention. xp and yp are the coordinates (in radians) of the Celestial Intermediate Pole with respect to the International Terrestrial Reference System (see IERS Conventions), measured along the meridians 0 and 90 deg west respectively.  sp is the TIO locator s', in radians, which positions the Terrestrial Intermediate Origin on the equator.  For many applications, xp, yp and (especially) sp can be set to zero. Internally, the polar motion is stored in a form rotated onto the local meridian. The refraction constants refa and refb are for use in a  $dZ = A*\\tan(Z)+B*\\tan^3(Z)$  model, where Z is the observed (i.e. refracted) zenith distance and dZ is the amount of refraction. It is advisable to take great care with units, as even unlikely values of the input parameters are accepted and processed in accordance with the models used. In cases where the caller does not wish to provide the Earth Ephemeris, the Earth rotation information and refraction constants, the function  apco13  can be used instead of the present function.  This starts from UTC and weather readings etc. and computes suitable values using other ERFA functions. This is one of several functions that inserts into the astrom structure star-independent parameters needed for the chain of astrometric transformations ICRS <-> GCRS <-> CIRS <-> observed. The various functions support different classes of observer and portions of the transformation chain: Functions Observer Transformation apcg apcg13 geocentric ICRS <-> GCRS apci apci13 terrestrial ICRS <-> CIRS apco apco13 terrestrial ICRS <-> observed apcs apcs13 space ICRS <-> GCRS aper aper13 terrestrial update Earth rotation apio apio13 terrestrial CIRS <-> observed Those with names ending in \"13\" use contemporary ERFA models to compute the various ephemerides.  The others accept ephemerides supplied by the caller. The transformation from ICRS to GCRS covers space motion, parallax, light deflection, and aberration.  From GCRS to CIRS comprises frame bias and precession-nutation.  From CIRS to observed takes account of Earth rotation, polar motion, diurnal aberration and parallax (unless subsumed into the ICRS <-> GCRS transformation), and atmospheric refraction. The context structure astrom produced by this function is used by  atioq ,  atoiq ,  atciq  and  aticq . Called aper : astrometry parameters: update ERA c2ixys : celestial-to-intermediate matrix, given X,Y and s pvtob : position/velocity of terrestrial station trxpv : product of transpose of r-matrix and pv-vector apcs : astrometry parameters, ICRS-GCRS, space observer cr : copy r-matrix source"},{"id":172,"pagetitle":"Functions","title":"ERFA.apco13","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.apco13-NTuple{12, Any}","content":" ERFA.apco13  —  Method apco13(utc1, utc2, dut1, elong, phi, hm, xp, yp, phpa, tk, rh, wl) For a terrestrial observer, prepare star-independent astrometry parameters for transformations between ICRS and observed coordinates.  The caller supplies UTC, site coordinates, ambient air conditions and observing wavelength, and ERFA models are used to obtain the Earth ephemeris, CIP/CIO and refraction constants. The parameters produced by this function are required in the parallax, light deflection, aberration, and bias-precession-nutation parts of the ICRS/CIRS transformations. Given utc1 : UTC as a 2-part... utc2 : ...quasi Julian Date (Notes 1,2) dut1 : UT1-UTC (seconds, Note 3) elong : Longitude (radians, east +ve, Note 4) phi : Latitude (geodetic, radians, Note 4) hm : Height above ellipsoid (m, geodetic, Notes 4,6) xp ,  yp : Polar motion coordinates (radians, Note 5) phpa : Pressure at the observer (hPa = mB, Note 6) tc : Ambient temperature at the observer (deg C) rh : Relative humidity at the observer (range 0-1) wl : Wavelength (micrometers, Note 7) Returned astrom : Star-independent astrometry parameters: pmt : PM time interval (SSB, Julian years) eb : SSB to observer (vector, au) eh : Sun to observer (unit vector) em : Distance from Sun to observer (au) v : Barycentric observer velocity (vector, c) bm1 :  $\\sqrt{1-|v|^2}$  Reciprocal of Lorenz factor bpn : Bias-precession-nutation matrix along : Longitude + s' (radians) xp1 : Polar motion xp wrt local meridian (radians) yp1 : Polar motion yp wrt local meridian (radians) sphi : Sine of geodetic latitude cphi : Cosine of geodetic latitude diurab : Magnitude of diurnal aberration vector l : \"Local\" Earth rotation angle (radians) refa : Refraction constant A (radians) refb : Refraction constant B (radians) eo : Equation of the origins (ERA-GST) Notes utc1+utc2 is quasi Julian Date (see Note 2), apportioned in any  convenient way between the two arguments, for example where utc1  is the Julian Day Number and utc2 is the fraction of a day. However, JD cannot unambiguously represent UTC during a leap  second unless special measures are taken.  The convention in the  present function is that the JD day represents UTC days whether  the length is 86399, 86400 or 86401 SI seconds. Applications should use the function  dtf2d  to convert from  calendar date and time of day into 2-part quasi Julian Date, as  it implements the leap-second-ambiguity convention just  described. The warning status \"dubious year\" flags UTCs that predate the  introduction of the time scale or that are too far in the  future to be trusted.  See  dat  for further details. UT1-UTC is tabulated in IERS bulletins.  It increases by exactly  one second at the end of each positive UTC leap second,  introduced in order to keep UT1-UTC within +/- 0.9s.  n.b. This  practice is under review, and in the future UT1-UTC may grow  essentially without limit. The geographical coordinates are with respect to the  WGS84   reference ellipsoid.  TAKE CARE WITH THE LONGITUDE SIGN:  the  longitude required by the present function is east-positive  (i.e. right-handed), in accordance with geographical convention. The polar motion xp,yp can be obtained from IERS bulletins.  The  values are the coordinates (in radians) of the Celestial  Intermediate Pole with respect to the International Terrestrial  Reference System (see IERS Conventions 2003), measured along the  meridians 0 and 90 deg west respectively.  For many  applications, xp and yp can be set to zero. Internally, the polar motion is stored in a form rotated onto  the local meridian. If hm, the height above the ellipsoid of the observing station  in meters, is not known but phpa, the pressure in hPa (=mB), is  available, an adequate estimate of hm can be obtained from the  expression hm = -29.3 * tsl * log ( phpa / 1013.25 ); where tsl is the approximate sea-level air temperature in K  (See Astrophysical Quantities, C.W.Allen, 3rd edition, section  52).  Similarly, if the pressure phpa is not known, it can be  estimated from the height of the observing station, hm, as  follows: phpa = 1013.25 * exp ( -hm / ( 29.3 * tsl ) ); Note, however, that the refraction is nearly proportional to  the pressure and that an accurate phpa value is important for  precise work. The argument wl specifies the observing wavelength in  micrometers.  The transition from optical to radio is assumed to  occur at 100 micrometers (about 3000 GHz). It is advisable to take great care with units, as even unlikely  values of the input parameters are accepted and processed in  accordance with the models used. In cases where the caller wishes to supply his own Earth  ephemeris, Earth rotation information and refraction constants,  the function  apco  can be used instead of the present function. This is one of several functions that inserts into the astrom  structure star-independent parameters needed for the chain of  astrometric transformations ICRS <-> GCRS <-> CIRS <-> observed. The various functions support different classes of observer and  portions of the transformation chain: Functions Observer Transformation apcg apcg13 geocentric ICRS <-> GCRS apci apci13 terrestrial ICRS <-> CIRS apco apco13 terrestrial ICRS <-> observed apcs apcs13 space ICRS <-> GCRS aper aper13 terrestrial update Earth rotation apio apio13 terrestrial CIRS <-> observed Those with names ending in \"13\" use contemporary ERFA models to  compute the various ephemerides.  The others accept ephemerides  supplied by the caller. The transformation from ICRS to GCRS covers space motion,  parallax, light deflection, and aberration.  From GCRS to CIRS  comprises frame bias and precession-nutation.  From CIRS to  observed takes account of Earth rotation, polar motion, diurnal  aberration and parallax (unless subsumed into the ICRS <-> GCRS  transformation), and atmospheric refraction. The context structure astrom produced by this function is used  by  atioq ,  atoiq ,  atciq*  and  aticq* . Called utctai : UTC to TAI taitt : TAI to TT utcut1 : UTC to UT1 epv00 : Earth position and velocity pnm06a : classical NPB matrix, IAU 2006/2000A bpn2xy : extract CIP X,Y coordinates from NPB matrix s06 : the CIO locator s, given X,Y, IAU 2006 era00 : Earth rotation angle, IAU 2000 sp00 : the TIO locator s', IERS 2000 refco : refraction constants for given ambient conditions apco : astrometry parameters, ICRS-observed eors : equation of the origins, given NPB matrix and s source"},{"id":173,"pagetitle":"Functions","title":"ERFA.apcs","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.apcs-NTuple{5, Any}","content":" ERFA.apcs  —  Method apcs(date1, date2, pv, ebpv, ehp) For an observer whose geocentric position and velocity are known, prepare star-independent astrometry parameters for transformations between ICRS and GCRS.  The Earth ephemeris is supplied by the caller. The parameters produced by this function are required in the space motion, parallax, light deflection and aberration parts of the astrometric transformation chain. Given date1 : TDB as a 2-part... date2 : ...Julian Date (Note 1) pv : Observer's geocentric pos/vel (m, m/s) ebpv : Earth barycentric PV (au, au/day) ehp : Earth heliocentric P (au) Returned astrom : Star-independent astrometry parameters: pmt : PM time interval (SSB, Julian years) eb : SSB to observer (vector, au) eh : Sun to observer (unit vector) em : Distance from Sun to observer (au) v : Barycentric observer velocity (vector, c) bm1 :  $\\sqrt{1-|v|^2}$  Reciprocal of Lorenz factor bpn : Bias-precession-nutation matrix along : unchanged xpl : unchanged ypl : unchanged sphi : unchanged cphi : unchanged diurab : unchanged l : unchanged refa : unchanged refb : unchanged Notes The TDB date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TDB)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience.  For most applications of this function the choice will not be at all critical. TT can be used instead of TDB without any significant impact on accuracy. All the vectors are with respect to BCRS axes. Providing separate arguments for (i) the observer's geocentric position and velocity and (ii) the Earth ephemeris is done for convenience in the geocentric, terrestrial and Earth orbit cases. For deep space applications it maybe more convenient to specify zero geocentric position and velocity and to supply the observer's position and velocity information directly instead of with respect to the Earth.  However, note the different units: m and m/s for the geocentric vectors, au and au/day for the heliocentric and barycentric vectors. In cases where the caller does not wish to provide the Earth ephemeris, the function  apcs13  can be used instead of the present function.  This computes the Earth ephemeris using the ERFA function  epv00 . This is one of several functions that inserts into the astrom structure star-independent parameters needed for the chain of astrometric transformations ICRS <-> GCRS <-> CIRS <-> observed. The various functions support different classes of observer and portions of the transformation chain: Functions Observer Transformation apcg apcg13 geocentric ICRS <-> GCRS apci apci13 terrestrial ICRS <-> CIRS apco apco13 terrestrial ICRS <-> observed apcs apcs13 space ICRS <-> GCRS aper aper13 terrestrial update Earth rotation apio apio13 terrestrial CIRS <-> observed Those with names ending in \"13\" use contemporary ERFA models to compute the various ephemerides.  The others accept ephemerides supplied by the caller. The transformation from ICRS to GCRS covers space motion, parallax, light deflection, and aberration.  From GCRS to CIRS comprises frame bias and precession-nutation.  From CIRS to observed takes account of Earth rotation, polar motion, diurnal aberration and parallax (unless subsumed into the ICRS <-> GCRS transformation), and atmospheric refraction. The context structure astrom produced by this function is used by  atciq*  and  aticq* . Called erfa_cp : copy p-vector pm : modulus of p-vector pn : decompose p-vector into modulus and direction ir : initialize r-matrix to identity source"},{"id":174,"pagetitle":"Functions","title":"ERFA.apcs13","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.apcs13-Tuple{Any, Any, Any}","content":" ERFA.apcs13  —  Method apcs13(date1, date2, pv) For an observer whose geocentric position and velocity are known, prepare star-independent astrometry parameters for transformations between ICRS and GCRS.  The Earth ephemeris is from ERFA models. The parameters produced by this function are required in the space motion, parallax, light deflection and aberration parts of the astrometric transformation chain. Given date1 : TDB as a 2-part... date2 : ...Julian Date (Note 1) pv : Observer's geocentric pos/vel (Note 3) Returned EraASTROM*   star-independent astrometry parameters: pmt : PM time interval (SSB, Julian years) eb : SSB to observer (vector, au) eh : Sun to observer (unit vector) em : Distance from Sun to observer (au) v : Barycentric observer velocity (vector, c) bm1 :  $\\sqrt{1-|v|^2}$  Reciprocal of Lorenz factor bpn : Bias-precession-nutation matrix along : unchanged xpl : unchanged ypl : unchanged sphi : unchanged cphi : unchanged diurab : unchanged l : unchanged refa : unchanged refb : unchanged Notes The TDB date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TDB)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience.  For most applications of this function the choice will not be at all critical. TT can be used instead of TDB without any significant impact on accuracy. All the vectors are with respect to BCRS axes. The observer's position and velocity pv are geocentric but with respect to BCRS axes, and in units of m and m/s.  No assumptions are made about proximity to the Earth, and the function can be used for deep space applications as well as Earth orbit and terrestrial. In cases where the caller wishes to supply his own Earth ephemeris, the function  apcs  can be used instead of the present function. This is one of several functions that inserts into the astrom structure star-independent parameters needed for the chain of astrometric transformations ICRS <-> GCRS <-> CIRS <-> observed. The various functions support different classes of observer and portions of the transformation chain: Functions Observer Transformation apcg apcg13 geocentric ICRS <-> GCRS apci apci13 terrestrial ICRS <-> CIRS apco apco13 terrestrial ICRS <-> observed apcs apcs13 space ICRS <-> GCRS aper aper13 terrestrial update Earth rotation apio apio13 terrestrial CIRS <-> observed Those with names ending in \"13\" use contemporary ERFA models to compute the various ephemerides.  The others accept ephemerides supplied by the caller. The transformation from ICRS to GCRS covers space motion, parallax, light deflection, and aberration.  From GCRS to CIRS comprises frame bias and precession-nutation.  From CIRS to observed takes account of Earth rotation, polar motion, diurnal aberration and parallax (unless subsumed into the ICRS <-> GCRS transformation), and atmospheric refraction. The context structure astrom produced by this function is used by  atciq*  and  aticq* . Called epv00 : Earth position and velocity apcs : astrometry parameters, ICRS-GCRS, space observer source"},{"id":175,"pagetitle":"Functions","title":"ERFA.aper","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.aper-Tuple{Any, Any}","content":" ERFA.aper  —  Method aper(theta, astrom) In the star-independent astrometry parameters, update only the Earth rotation angle, supplied by the caller explicitly. Given theta : Earth rotation angle (radians, Note 2) astrom : Star-independent astrometry parameters: pmt : unchanged eb : unchanged eh : unchanged em : unchanged v : unchanged bm1 : unchanged bpn : unchanged along : Longitude + s' (radians) xpl : unchanged ypl : unchanged sphi : unchanged cphi : unchanged diurab : unchanged l : unchanged refa : unchanged refb : unchanged Returned astrom : Star-independent astrometry parameters: pmt : unchanged eb : unchanged eh : unchanged em : unchanged v : unchanged bm1 : unchanged bpn : unchanged along : unchanged xpl : unchanged ypl : unchanged sphi : unchanged cphi : unchanged diurab : unchanged l : \"Local\" Earth rotation angle (radians) refa : unchanged refb : unchanged Notes This function exists to enable sidereal-tracking applications to avoid wasteful recomputation of the bulk of the astrometry parameters:  only the Earth rotation is updated. For targets expressed as equinox based positions, such as classical geocentric apparent (RA,Dec), the supplied theta can be Greenwich apparent sidereal time rather than Earth rotation angle. The function  aper13  can be used instead of the present function, and starts from UT1 rather than ERA itself. This is one of several functions that inserts into the astrom structure star-independent parameters needed for the chain of astrometric transformations ICRS <-> GCRS <-> CIRS <-> observed. The various functions support different classes of observer and portions of the transformation chain: Functions Observer Transformation apcg apcg13 geocentric ICRS <-> GCRS apci apci13 terrestrial ICRS <-> CIRS apco apco13 terrestrial ICRS <-> observed apcs apcs13 space ICRS <-> GCRS aper aper13 terrestrial update Earth rotation apio apio13 terrestrial CIRS <-> observed Those with names ending in \"13\" use contemporary ERFA models to compute the various ephemerides.  The others accept ephemerides supplied by the caller. The transformation from ICRS to GCRS covers space motion, parallax, light deflection, and aberration.  From GCRS to CIRS comprises frame bias and precession-nutation.  From CIRS to observed takes account of Earth rotation, polar motion, diurnal aberration and parallax (unless subsumed into the ICRS <-> GCRS transformation), and atmospheric refraction. source"},{"id":176,"pagetitle":"Functions","title":"ERFA.aper13","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.aper13-Tuple{Any, Any, Any}","content":" ERFA.aper13  —  Method aper13(ut11, ut12, astrom) In the star-independent astrometry parameters, update only the Earth rotation angle.  The caller provides UT1, (n.b. not UTC). Given ut11 : UT1 as a 2-part... ut12 : ...Julian Date (Note 1) astrom : Star-independent astrometry parameters: pmt : unchanged eb : unchanged eh : unchanged em : unchanged v : unchanged bm1 : unchanged bpn : unchanged along : Longitude + s' (radians) xpl : unchanged ypl : unchanged sphi : unchanged cphi : unchanged diurab : unchanged l : unchanged refa : unchanged refb : unchanged Returned astrom : Star-independent astrometry parameters: pmt : unchanged eb : unchanged eh : unchanged em : unchanged v : unchanged bm1 : unchanged bpn : unchanged along : unchanged xpl : unchanged ypl : unchanged sphi : unchanged cphi : unchanged diurab : unchanged l : \"Local\" Earth rotation angle (radians) refa : unchanged refb : unchanged Notes The UT1 date (n.b. not UTC) ut11+ut12 is a Julian Date, apportioned in any convenient way between the arguments ut11 and ut12.  For example, JD(UT1)=2450123.7 could be expressed in any of these ways, among others: ut11 ut12 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 and MJD methods are good compromises between resolution and convenience.  The date & time method is best matched to the algorithm used:  maximum precision is delivered when the ut11 argument is for 0hrs UT1 on the day in question and the ut12 argument lies in the range 0 to 1, or vice versa. If the caller wishes to provide the Earth rotation angle itself, the function  aper  can be used instead.  One use of this technique is to substitute Greenwich apparent sidereal time and thereby to support equinox based transformations directly. This is one of several functions that inserts into the astrom structure star-independent parameters needed for the chain of astrometric transformations ICRS <-> GCRS <-> CIRS <-> observed. The various functions support different classes of observer and portions of the transformation chain: Functions Observer Transformation apcg apcg13 geocentric ICRS <-> GCRS apci apci13 terrestrial ICRS <-> CIRS apco apco13 terrestrial ICRS <-> observed apcs apcs13 space ICRS <-> GCRS aper aper13 terrestrial update Earth rotation apio apio13 terrestrial CIRS <-> observed Those with names ending in \"13\" use contemporary ERFA models to compute the various ephemerides.  The others accept ephemerides supplied by the caller. The transformation from ICRS to GCRS covers space motion, parallax, light deflection, and aberration.  From GCRS to CIRS comprises frame bias and precession-nutation.  From CIRS to observed takes account of Earth rotation, polar motion, diurnal aberration and parallax (unless subsumed into the ICRS <-> GCRS transformation), and atmospheric refraction. Called aper : astrometry parameters: update ERA era00 : Earth rotation angle, IAU 2000 source"},{"id":177,"pagetitle":"Functions","title":"ERFA.apio","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.apio-NTuple{9, Any}","content":" ERFA.apio  —  Method apio(sp, theta, elong, phi, hm, xp, yp, refa, refb) For a terrestrial observer, prepare star-independent astrometry parameters for transformations between CIRS and observed coordinates.  The caller supplies the Earth orientation information and the refraction constants as well as the site coordinates. Given sp : The TIO locator s' (radians, Note 1) theta : Earth rotation angle (radians) elong : Longitude (radians, east +ve, Note 2) phi : Geodetic latitude (radians, Note 2) hm : Height above ellipsoid (m, geodetic Note 2) xp ,  yp : Polar motion coordinates (radians, Note 3) refa : Refraction constant A (radians, Note 4) refb : Refraction constant B (radians, Note 4) Returned astrom : Star-independent astrometry parameters: pmt : unchanged eb : unchanged eh : unchanged em : unchanged v : unchanged bm1 : unchanged bpn : unchanged along : Longitude + s' (radians) xp1 : Polar motion xp wrt local meridian (radians) yp1 : Polar motion yp wrt local meridian (radians) sphi : Sine of geodetic latitude cphi : Cosine of geodetic latitude diurab : Magnitude of diurnal aberration vector l : \"Local\" Earth rotation angle (radians) refa : Refraction constant A (radians) refb : Refraction constant B (radians) Notes sp, the TIO locator s', is a tiny quantity needed only by the most precise applications.  It can either be set to zero or predicted using the ERFA function  sp00 . The geographical coordinates are with respect to the  WGS84  reference ellipsoid.  TAKE CARE WITH THE LONGITUDE SIGN:  the longitude required by the present function is east-positive (i.e. right-handed), in accordance with geographical convention. The polar motion xp,yp can be obtained from IERS bulletins.  The values are the coordinates (in radians) of the Celestial Intermediate Pole with respect to the International Terrestrial Reference System (see IERS Conventions 2003), measured along the meridians 0 and 90 deg west respectively.  For many applications, xp and yp can be set to zero. Internally, the polar motion is stored in a form rotated onto the local meridian. The refraction constants refa and refb are for use in a  $dZ = A*\\tan(Z)+B*\\tan^3(Z)$  model, where Z is the observed (i.e. refracted) zenith distance and dZ is the amount of refraction. It is advisable to take great care with units, as even unlikely values of the input parameters are accepted and processed in accordance with the models used. In cases where the caller does not wish to provide the Earth rotation information and refraction constants, the function  apio13  can be used instead of the present function.  This starts from UTC and weather readings etc. and computes suitable values using other ERFA functions. This is one of several functions that inserts into the astrom structure star-independent parameters needed for the chain of astrometric transformations ICRS <-> GCRS <-> CIRS <-> observed. The various functions support different classes of observer and portions of the transformation chain: Functions Observer Transformation apcg apcg13 geocentric ICRS <-> GCRS apci apci13 terrestrial ICRS <-> CIRS apco apco13 terrestrial ICRS <-> observed apcs apcs13 space ICRS <-> GCRS aper aper13 terrestrial update Earth rotation apio apio13 terrestrial CIRS <-> observed Those with names ending in \"13\" use contemporary ERFA models to compute the various ephemerides.  The others accept ephemerides supplied by the caller. The transformation from ICRS to GCRS covers space motion, parallax, light deflection, and aberration.  From GCRS to CIRS comprises frame bias and precession-nutation.  From CIRS to observed takes account of Earth rotation, polar motion, diurnal aberration and parallax (unless subsumed into the ICRS <-> GCRS transformation), and atmospheric refraction. The context structure astrom produced by this function is used by  atioq  and  atoiq . Called pvtob : position/velocity of terrestrial station aper : astrometry parameters: update ERA source"},{"id":178,"pagetitle":"Functions","title":"ERFA.apio13","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.apio13-NTuple{12, Any}","content":" ERFA.apio13  —  Method apio13(utc1, utc2, dut1, elong, phi, hm, xp, yp, phpa, tk, rh, wl) For a terrestrial observer, prepare star-independent astrometry parameters for transformations between CIRS and observed coordinates.  The caller supplies UTC, site coordinates, ambient air conditions and observing wavelength. Given utc1 : UTC as a 2-part... utc2 : ...quasi Julian Date (Notes 1,2) dut1 : UT1-UTC (seconds) elong : Longitude (radians, east +ve, Note 3) phi : Geodetic latitude (radians, Note 3) hm : Height above ellipsoid (m, geodetic Notes 4,6) xp ,  yp : Polar motion coordinates (radians, Note 5) phpa : Pressure at the observer (hPa = mB, Note 6) tc : Ambient temperature at the observer (deg C) rh : Relative humidity at the observer (range 0-1) wl : Wavelength (micrometers, Note 7) Returned astrom : Star-independent astrometry parameters: pmt : unchanged eb : unchanged eh : unchanged em : unchanged v : unchanged bm1 : unchanged bpn : unchanged along : Longitude + s' (radians) xp1 : Polar motion xp wrt local meridian (radians) yp1 : Polar motion yp wrt local meridian (radians) sphi : Sine of geodetic latitude cphi : Cosine of geodetic latitude diurab : Magnitude of diurnal aberration vector l : \"Local\" Earth rotation angle (radians) refa : Refraction constant A (radians) refb : Refraction constant B (radians) Notes utc1+utc2 is quasi Julian Date (see Note 2), apportioned in any  convenient way between the two arguments, for example where utc1  is the Julian Day Number and utc2 is the fraction of a day. However, JD cannot unambiguously represent UTC during a leap  second unless special measures are taken.  The convention in the  present function is that the JD day represents UTC days whether  the length is 86399, 86400 or 86401 SI seconds. Applications should use the function  dtf2d  to convert from  calendar date and time of day into 2-part quasi Julian Date, as  it implements the leap-second-ambiguity convention just  described. The warning status \"dubious year\" flags UTCs that predate the  introduction of the time scale or that are too far in the future  to be trusted.  See  dat  for further details. UT1-UTC is tabulated in IERS bulletins.  It increases by exactly  one second at the end of each positive UTC leap second,  introduced in order to keep UT1-UTC within +/- 0.9s.  n.b. This  practice is under review, and in the future UT1-UTC may grow  essentially without limit. The geographical coordinates are with respect to the  WGS84   reference ellipsoid.  TAKE CARE WITH THE LONGITUDE SIGN:  the  longitude required by the present function is east-positive  (i.e. right-handed), in accordance with geographical convention. The polar motion xp,yp can be obtained from IERS bulletins.  The  values are the coordinates (in radians) of the Celestial  Intermediate Pole with respect to the International Terrestrial  Reference System (see IERS Conventions 2003), measured along the  meridians 0 and 90 deg west respectively.  For many applications,  xp and yp can be set to zero. Internally, the polar motion is stored in a form rotated onto  the local meridian. If hm, the height above the ellipsoid of the observing station  in meters, is not known but phpa, the pressure in hPa (=mB), is  available, an adequate estimate of hm can be obtained from the  expression hm = -29.3 * tsl * log ( phpa / 1013.25 ); where tsl is the approximate sea-level air temperature in K  (See Astrophysical Quantities, C.W.Allen, 3rd edition, section  52).  Similarly, if the pressure phpa is not known, it can be  estimated from the height of the observing station, hm, as  follows: phpa = 1013.25 * exp ( -hm / ( 29.3 * tsl ) ); Note, however, that the refraction is nearly proportional to the  pressure and that an accurate phpa value is important for  precise work. The argument wl specifies the observing wavelength in  micrometers.  The transition from optical to radio is assumed to  occur at 100 micrometers (about 3000 GHz). It is advisable to take great care with units, as even unlikely  values of the input parameters are accepted and processed in  accordance with the models used. In cases where the caller wishes to supply his own Earth  rotation information and refraction constants, the function   apc*  can be used instead of the present function. This is one of several functions that inserts into the astrom  structure star-independent parameters needed for the chain of  astrometric transformations ICRS <-> GCRS <-> CIRS <-> observed. The various functions support different classes of observer and  portions of the transformation chain: Functions Observer Transformation apcg apcg13 geocentric ICRS <-> GCRS apci apci13 terrestrial ICRS <-> CIRS apco apco13 terrestrial ICRS <-> observed apcs apcs13 space ICRS <-> GCRS aper aper13 terrestrial update Earth rotation apio apio13 terrestrial CIRS <-> observed Those with names ending in \"13\" use contemporary ERFA models to  compute the various ephemerides.  The others accept ephemerides  supplied by the caller. The transformation from ICRS to GCRS covers space motion,  parallax, light deflection, and aberration.  From GCRS to CIRS  comprises frame bias and precession-nutation.  From CIRS to  observed takes account of Earth rotation, polar motion, diurnal  aberration and parallax (unless subsumed into the ICRS <-> GCRS  transformation), and atmospheric refraction. The context structure astrom produced by this function is used  by  atioq  and  atoiq . Called utctai : UTC to TAI taitt : TAI to TT utcut1 : UTC to UT1 sp00 : the TIO locator s', IERS 2000 era00 : Earth rotation angle, IAU 2000 refco : refraction constants for given ambient conditions apio : astrometry parameters, CIRS-observed source"},{"id":179,"pagetitle":"Functions","title":"ERFA.atcc13","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.atcc13-NTuple{8, Any}","content":" ERFA.atcc13  —  Method atcc13(rc, dc, pr, pd, px, rv, date1, date2) Transform a star's ICRS catalog entry (epoch J2000.0) into ICRS astrometric place. Given rc : ICRS right ascension at J2000.0 (radians, Note 1) dc : ICRS declination at J2000.0 (radians, Note 1) pr : RA proper motion (radians/year, Note 2) pd : Dec proper motion (radians/year) px : parallax (arcsec) rv : radial velocity (km/s, +ve if receding) date1 : TDB as a 2-part... date2 : ...Julian Date (Note 3) Returned ra ,  da : ICRS astrometric RA,Dec (radians) Notes Star data for an epoch other than J2000.0 (for example from the Hipparcos catalog, which has an epoch of J1991.25) will require a preliminary call to eraPmsafe before use. The proper motion in RA is dRA/dt rather than cos(Dec)*dRA/dt. The TDB date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TDB)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience.  For most applications of this function the choice will not be at all critical. TT can be used instead of TDB without any significant impact on accuracy. Called apci13 : astrometry parameters, ICRS-CIRS, 2013 atccq : quick catalog ICRS to astrometric source"},{"id":180,"pagetitle":"Functions","title":"ERFA.atccq","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.atccq-NTuple{7, Any}","content":" ERFA.atccq  —  Method atccq(rc, dc, pr, pd, px, rv, astrom) Quick transformation of a star's ICRS catalog entry (epoch J2000.0) into ICRS astrometric place, given precomputed star-independent astrometry parameters. Use of this function is appropriate when efficiency is important and where many star positions are to be transformed for one date.  The star-independent parameters can be obtained by calling one of the functions  apci ,  apci13 ,  apcg ,  apcg13 ,  apco ,  apco13 ,  apcs ,  apcs13 . If the parallax and proper motions are zero the transformation has no effect. Given rc ,  dc : ICRS RA,Dec at J2000.0 (radians) pr : RA proper motion (radians/year, Note 3) pd : Dec proper motion (radians/year) px : parallax (arcsec) rv : radial velocity (km/s, +ve if receding) astrom : Star-independent astrometry parameters: pmt : unchanged eb : unchanged eh : unchanged em : unchanged v : unchanged bm1 : unchanged bpn : unchanged along : Longitude + s' (radians) xp1 : Polar motion xp wrt local meridian (radians) yp1 : Polar motion yp wrt local meridian (radians) sphi : Sine of geodetic latitude cphi : Cosine of geodetic latitude diurab : Magnitude of diurnal aberration vector l : \"Local\" Earth rotation angle (radians) refa : Refraction constant A (radians) refb : Refraction constant B (radians) Returned ra ,  da : ICRS astrometric RA,Dec (radians) Notes All the vectors are with respect to BCRS axes. Star data for an epoch other than J2000.0 (for example from the Hipparcos catalog, which has an epoch of J1991.25) will require a preliminary call to eraPmsafe before use. The proper motion in RA is dRA/dt rather than cos(Dec)*dRA/dt. Called pmpx : proper motion and parallax c2s : p-vector to spherical anp : normalize angle into range 0 to 2pi source"},{"id":181,"pagetitle":"Functions","title":"ERFA.atci13","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.atci13-NTuple{8, Any}","content":" ERFA.atci13  —  Method atci13(rc, dc, pr, pd, px, rv, date1, date2) Transform ICRS star data, epoch J2000.0, to CIRS. Given rc : ICRS right ascension at J2000.0 (radians, Note 1) dc : ICRS declination at J2000.0 (radians, Note 1) pr : RA proper motion (radians/year; Note 2) pd : Dec proper motion (radians/year) px : Parallax (arcsec) rv : Radial velocity (km/s, +ve if receding) date1 : TDB as a 2-part... date2 : ...Julian Date (Note 3) Returned ri ,  di : CIRS geocentric RA,Dec (radians) eo : Equation of the origins (ERA-GST, Note 5) Notes Star data for an epoch other than J2000.0 (for example from the Hipparcos catalog, which has an epoch of J1991.25) will require a preliminary call to  pmsafe  before use. The proper motion in RA is dRA/dt rather than cos(Dec)*dRA/dt. The TDB date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TDB)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience.  For most applications of this function the choice will not be at all critical. TT can be used instead of TDB without any significant impact on accuracy. The available accuracy is better than 1 milliarcsecond, limited mainly by the precession-nutation model that is used, namely IAU 2000A/2006.  Very close to solar system bodies, additional errors of up to several milliarcseconds can occur because of unmodeled light deflection;  however, the Sun's contribution is taken into account, to first order.  The accuracy limitations of the ERFA function  epv00  (used to compute Earth position and velocity) can contribute aberration errors of up to 5 microarcseconds.  Light deflection at the Sun's limb is uncertain at the 0.4 mas level. Should the transformation to (equinox based) apparent place be required rather than (CIO based) intermediate place, subtract the equation of the origins from the returned right ascension: RA = RI - EO. (The  anp  function can then be applied, as required, to keep the result in the conventional 0-2pi range.) Called apci13 : astrometry parameters, ICRS-CIRS, 2013 atciq : quick ICRS to CIRS source"},{"id":182,"pagetitle":"Functions","title":"ERFA.atciq","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.atciq-NTuple{7, Any}","content":" ERFA.atciq  —  Method atciq(rc, dc, pr, pd, px, rv, astrom) Quick ICRS, epoch J2000.0, to CIRS transformation, given precomputed star-independent astrometry parameters. Use of this function is appropriate when efficiency is important and where many star positions are to be transformed for one date.  The star-independent parameters can be obtained by calling one of the functions  apci[13] ,  apcg[13] ,  apco[13]  or  apcs[13] . If the parallax and proper motions are zero the  atciqz  function can be used instead. Given rc ,  dc : ICRS RA,Dec at J2000.0 (radians) pr : RA proper motion (radians/year; Note 3) pd : Dec proper motion (radians/year) px : Parallax (arcsec) rv : Radial velocity (km/s, +ve if receding) astrom : Star-independent astrometry parameters: pmt : PM time interval (SSB, Julian years) eb : SSB to observer (vector, au) eh : Sun to observer (unit vector) em : Distance from Sun to observer (au) v : Barycentric observer velocity (vector, c) bm1 :  $\\sqrt{1-|v|^2}$  Reciprocal of Lorenz factor bpn : Bias-precession-nutation matrix along : Longitude + s' (radians) xp1 : Polar motion xp wrt local meridian (radians) yp1 : Polar motion yp wrt local meridian (radians) sphi : Sine of geodetic latitude cphi : Cosine of geodetic latitude diurab : Magnitude of diurnal aberration vector l : \"Local\" Earth rotation angle (radians) refa : Refraction constant A (radians) refb : Refraction constant B (radians) Returned ri ,  di : CIRS RA,Dec (radians) Notes All the vectors are with respect to BCRS axes. Star data for an epoch other than J2000.0 (for example from the Hipparcos catalog, which has an epoch of J1991.25) will require a preliminary call to  pmsafe  before use. The proper motion in RA is dRA/dt rather than cos(Dec)*dRA/dt. Called pmpx : proper motion and parallax ldsun : light deflection by the Sun ab : stellar aberration rxp : product of r-matrix and pv-vector c2s : p-vector to spherical anp : normalize angle into range 0 to 2pi source"},{"id":183,"pagetitle":"Functions","title":"ERFA.atciqn","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.atciqn-Tuple{Any, Any, Any, Any, Any, Any, Any, Vector{ERFA.LDBODY}}","content":" ERFA.atciqn  —  Method atciqn(rc, dc, pr, pd, px, rv, astrom, b::Vector{LDBODY}) Quick ICRS, epoch J2000.0, to CIRS transformation, given precomputed star-independent astrometry parameters plus a list of light- deflecting bodies. Use of this function is appropriate when efficiency is important and where many star positions are to be transformed for one date.  The star-independent parameters can be obtained by calling one of the functions  apci[13] ,  apcg[13] ,  apco[13]  or  apcs[13] . If the only light-deflecting body to be taken into account is the Sun, the  atciq  function can be used instead.  If in addition the parallax and proper motions are zero, the  atciqz  function can be used. Given rc ,  dc : ICRS RA,Dec at J2000.0 (radians) pr : RA proper motion (radians/year; Note 3) pd : Dec proper motion (radians/year) px : Parallax (arcsec) rv : Radial velocity (km/s, +ve if receding) EraASTROM*   star-independent astrometry parameters: pmt : PM time interval (SSB, Julian years) eb : SSB to observer (vector, au) eh : Sun to observer (unit vector) em : Distance from Sun to observer (au) v : Barycentric observer velocity (vector, c) bm1 :  $\\sqrt{1-|v|^2}$  Reciprocal of Lorenz factor bpn : Bias-precession-nutation matrix along : Longitude + s' (radians) xp1 : Polar motion xp wrt local meridian (radians) yp1 : Polar motion yp wrt local meridian (radians) sphi : Sine of geodetic latitude cphi : Cosine of geodetic latitude diurab : Magnitude of diurnal aberration vector l : \"Local\" Earth rotation angle (radians) refa : Refraction constant A (radians) refb : Refraction constant B (radians) n : Number of bodies (Note 3) b::Vector{LDBODY} : Data for each of the n bodies (Notes 3,4): bm : Mass of the body (solar masses, Note 5) dl : Deflection limiter (Note 6) pv : Barycentric PV of the body (au, au/day) Returned ri ,  di : CIRS RA,Dec (radians) Notes Star data for an epoch other than J2000.0 (for example from the Hipparcos catalog, which has an epoch of J1991.25) will require a preliminary call to  pmsafe  before use. The proper motion in RA is dRA/dt rather than cos(Dec)*dRA/dt. The struct b contains n entries, one for each body to be considered.  If n = 0, no gravitational light deflection will be applied, not even for the Sun. The struct b should include an entry for the Sun as well as for any planet or other body to be taken into account.  The entries should be in the order in which the light passes the body. In the entry in the b struct for body i, the mass parameter b[i].bm can, as required, be adjusted in order to allow for such effects as quadrupole field. The deflection limiter parameter b[i].dl is phi^2/2, where phi is the angular separation (in radians) between star and body at which limiting is applied.  As phi shrinks below the chosen threshold, the deflection is artificially reduced, reaching zero for phi = 0.   Example values suitable for a terrestrial observer, together with masses, are as follows: body i b[i].bm b[i].dl Sun 1.0 6e-6 Jupiter 0.00095435 3e-9 Saturn 0.00028574 3e-10 For efficiency, validation of the contents of the b array is omitted.  The supplied masses must be greater than zero, the position and velocity vectors must be right, and the deflection limiter greater than zero. Called pmpx : proper motion and parallax ldn : light deflection by n bodies ab : stellar aberration rxp : product of r-matrix and pv-vector c2s : p-vector to spherical anp : normalize angle into range 0 to 2pi source"},{"id":184,"pagetitle":"Functions","title":"ERFA.atciqz","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.atciqz-Tuple{Any, Any, Any}","content":" ERFA.atciqz  —  Method atciqz(rc, dc, astrom) Quick ICRS to CIRS transformation, given precomputed star- independent astrometry parameters, and assuming zero parallax and proper motion. Use of this function is appropriate when efficiency is important and where many star positions are to be transformed for one date.  The star-independent parameters can be obtained by calling one of the functions  apci[13] ,  apcg[13] ,  apco[13]  or  apcs[13] . The corresponding function for the case of non-zero parallax and proper motion is  atciq . Given rc ,  dc : ICRS astrometric RA,Dec (radians) astrom : Star-independent astrometry parameters: pmt : PM time interval (SSB, Julian years) eb : SSB to observer (vector, au) eh : Sun to observer (unit vector) em : Distance from Sun to observer (au) v : Barycentric observer velocity (vector, c) bm1 :  $\\sqrt{1-|v|^2}$  Reciprocal of Lorenz factor bpn : Bias-precession-nutation matrix along : Longitude + s' (radians) xp1 : Polar motion xp wrt local meridian (radians) yp1 : Polar motion yp wrt local meridian (radians) sphi : Sine of geodetic latitude cphi : Cosine of geodetic latitude diurab : Magnitude of diurnal aberration vector l : \"Local\" Earth rotation angle (radians) refa : Refraction constant A (radians) refb : Refraction constant B (radians) Returned ri ,  di : CIRS RA,Dec (radians) Note All the vectors are with respect to BCRS axes. References Urban, S. & Seidelmann, P. K. (eds), Explanatory Supplement to   the Astronomical Almanac, 3rd ed., University Science Books   (2013). Klioner, Sergei A., \"A practical relativistic model for micro-   arcsecond astrometry in space\", Astr. J. 125, 1580-1597 (2003). Called s2c : spherical coordinates to unit vector ldsun : light deflection due to Sun ab : stellar aberration rxp : product of r-matrix and p-vector c2s : p-vector to spherical anp : normalize angle into range +/- pi source"},{"id":185,"pagetitle":"Functions","title":"ERFA.atco13","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.atco13-NTuple{18, Any}","content":" ERFA.atco13  —  Method atco13(rc, dc, pr, pd, px, rv, utc1, utc2, dut1, elong, phi, hm, xp, yp, phpa, tk, rh, wl) ICRS RA,Dec to observed place.  The caller supplies UTC, site coordinates, ambient air conditions and observing wavelength. ERFA models are used for the Earth ephemeris, bias-precession- nutation, Earth orientation and refraction. Given rc ,  dc : ICRS right ascension at J2000.0 (radians, Note 1) pr : RA proper motion (radians/year; Note 2) pd : Dec proper motion (radians/year) px : Parallax (arcsec) rv : Radial velocity (km/s, +ve if receding) utc1 : UTC as a 2-part... utc2 : ...quasi Julian Date (Notes 3-4) dut1 : UT1-UTC (seconds, Note 5) elong : Longitude (radians, east +ve, Note 6) phi : Latitude (geodetic, radians, Note 6) hm : Height above ellipsoid (m, geodetic, Notes 6,8) xp ,  yp : Polar motion coordinates (radians, Note 7) phpa : Pressure at the observer (hPa = mB, Note 8) tc : Ambient temperature at the observer (deg C) rh : Relative humidity at the observer (range 0-1) wl : Wavelength (micrometers, Note 9) Returned aob : Observed azimuth (radians: N=0,E=90) zob : Observed zenith distance (radians) hob : Observed hour angle (radians) dob : Observed declination (radians) rob : Observed right ascension (CIO-based, radians) eo : Equation of the origins (ERA-GST) Notes Star data for an epoch other than J2000.0 (for example from the  Hipparcos catalog, which has an epoch of J1991.25) will require  a preliminary call to  pmsafe  before use. The proper motion in RA is dRA/dt rather than cos(Dec)*dRA/dt. utc1+utc2 is quasi Julian Date (see Note 2), apportioned in any  convenient way between the two arguments, for example where utc1  is the Julian Day Number and utc2 is the fraction of a day. However, JD cannot unambiguously represent UTC during a leap  second unless special measures are taken.  The convention in the  present function is that the JD day represents UTC days whether  the length is 86399, 86400 or 86401 SI seconds. Applications should use the function  dtf2d  to convert from  calendar date and time of day into 2-part quasi Julian Date, as  it implements the leap-second-ambiguity convention just  described. The warning status \"dubious year\" flags UTCs that predate the  introduction of the time scale or that are too far in the  future to be trusted.  See  dat  for further details. UT1-UTC is tabulated in IERS bulletins.  It increases by exactly  one second at the end of each positive UTC leap second,  introduced in order to keep UT1-UTC within +/- 0.9s.  n.b. This  practice is under review, and in the future UT1-UTC may grow  essentially without limit. The geographical coordinates are with respect to the  WGS84   reference ellipsoid.  TAKE CARE WITH THE LONGITUDE SIGN:  the  longitude required by the present function is east-positive  (i.e. right-handed), in accordance with geographical convention. The polar motion xp,yp can be obtained from IERS bulletins.  The  values are the coordinates (in radians) of the Celestial  Intermediate Pole with respect to the International Terrestrial  Reference System (see IERS Conventions 2003), measured along the  meridians 0 and 90 deg west respectively.  For many  applications, xp and yp can be set to zero. If hm, the height above the ellipsoid of the observing station  in meters, is not known but phpa, the pressure in hPa (=mB),  is available, an adequate estimate of hm can be obtained from  the expression hm = -29.3 * tsl * log ( phpa / 1013.25 ); where tsl is the approximate sea-level air temperature in K  (See Astrophysical Quantities, C.W.Allen, 3rd edition, section  52).  Similarly, if the pressure phpa is not known, it can be  estimated from the height of the observing station, hm, as  follows: phpa = 1013.25 * exp ( -hm / ( 29.3 * tsl ) ); Note, however, that the refraction is nearly proportional to  the pressure and that an accurate phpa value is important for  precise work. The argument wl specifies the observing wavelength in  micrometers.  The transition from optical to radio is assumed to  occur at 100 micrometers (about 3000 GHz). The accuracy of the result is limited by the corrections for  refraction, which use a simple  $A*tan(z) + B*tan^3(z)$  model.  Providing the meteorological parameters are known accurately and  there are no gross local effects, the predicted observed  coordinates should be within 0.05 arcsec (optical) or 1 arcsec  (radio) for a zenith distance of less than 70 degrees, better  than 30 arcsec (optical or radio) at 85 degrees and better  than 20 arcmin (optical) or 30 arcmin (radio) at the horizon. Without refraction, the complementary functions  atco13  and   atoc13  are self-consistent to better than 1 microarcsecond  all over the celestial sphere.  With refraction included,  consistency falls off at high zenith distances, but is still  better than 0.05 arcsec at 85 degrees. \"Observed\" Az,ZD means the position that would be seen by a  perfect geodetically aligned theodolite.  (Zenith distance is  used rather than altitude in order to reflect the fact that no  allowance is made for depression of the horizon.)  This is  related to the observed HA,Dec via the standard rotation, using  the geodetic latitude (corrected for polar motion), while the  observed HA and RA are related simply through the Earth rotation  angle and the site longitude.  \"Observed\" RA,Dec or HA,Dec thus  means the position that would be seen by a perfect equatorial  with its polar axis aligned to the Earth's axis of rotation. It is advisable to take great care with units, as even unlikely  values of the input parameters are accepted and processed in  accordance with the models used. Called apco13 : astrometry parameters, ICRS-observed, 2013 atciq : quick ICRS to CIRS atioq : quick CIRS to observed source"},{"id":186,"pagetitle":"Functions","title":"ERFA.atic13","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.atic13-NTuple{4, Any}","content":" ERFA.atic13  —  Method atic13(ri, di, date1, date2) Transform star RA,Dec from geocentric CIRS to ICRS astrometric. Given ri ,  di : CIRS geocentric RA,Dec (radians) date1 : TDB as a 2-part... date2 : ...Julian Date (Note 1) Returned rc ,  dc : ICRS astrometric RA,Dec (radians) eo : Equation of the origins (ERA-GST, Note 4) Notes The TDB date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TDB)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience.  For most applications of this function the choice will not be at all critical. TT can be used instead of TDB without any significant impact on accuracy. Iterative techniques are used for the aberration and light deflection corrections so that the functions  atic13  (or  aticq ) and  atci13  (or  atciq ) are accurate inverses; even at the edge of the Sun's disk the discrepancy is only about 1 nanoarcsecond. The available accuracy is better than 1 milliarcsecond, limited mainly by the precession-nutation model that is used, namely IAU 2000A/2006.  Very close to solar system bodies, additional errors of up to several milliarcseconds can occur because of unmodeled light deflection;  however, the Sun's contribution is taken into account, to first order.  The accuracy limitations of the ERFA function  epv00  (used to compute Earth position and velocity) can contribute aberration errors of up to 5 microarcseconds.  Light deflection at the Sun's limb is uncertain at the 0.4 mas level. Should the transformation to (equinox based) J2000.0 mean place be required rather than (CIO based) ICRS coordinates, subtract the equation of the origins from the returned right ascension: RA = RI - EO.  (The  anp  function can then be applied, as required, to keep the result in the conventional 0-2pi range.) Called apci13 : astrometry parameters, ICRS-CIRS, 2013 aticq : quick CIRS to ICRS astrometric source"},{"id":187,"pagetitle":"Functions","title":"ERFA.aticq","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.aticq-Tuple{Any, Any, Any}","content":" ERFA.aticq  —  Method aticq(ri, di, astrom) Quick CIRS RA,Dec to ICRS astrometric place, given the star- independent astrometry parameters. Use of this function is appropriate when efficiency is important and where many star positions are all to be transformed for one date. The star-independent astrometry parameters can be obtained by calling one of the functions  apci[13] ,  apcg[13] ,  apco[13]  or  apcs[13] . Given ri ,  di : CIRS RA,Dec (radians) astrom : Star-independent astrometry parameters: pmt : PM time interval (SSB, Julian years) eb : SSB to observer (vector, au) eh : Sun to observer (unit vector) em : Distance from Sun to observer (au) v : Barycentric observer velocity (vector, c) bm1 :  $\\sqrt{1-|v|^2}$  Reciprocal of Lorenz factor bpn : Bias-precession-nutation matrix along : Longitude + s' (radians) xp1 : Polar motion xp wrt local meridian (radians) yp1 : Polar motion yp wrt local meridian (radians) sphi : Sine of geodetic latitude cphi : Cosine of geodetic latitude diurab : Magnitude of diurnal aberration vector l : \"Local\" Earth rotation angle (radians) refa : Refraction constant A (radians) refb : Refraction constant B (radians) Returned rc ,  dc : ICRS astrometric RA,Dec (radians) Notes Only the Sun is taken into account in the light deflection correction. Iterative techniques are used for the aberration and light deflection corrections so that the functions  atic13  (or  aticq ) and  atci13  (or  atciq ) are accurate inverses; even at the edge of the Sun's disk the discrepancy is only about 1 nanoarcsecond. Called s2c : spherical coordinates to unit vector trxp : product of transpose of r-matrix and p-vector zp : zero p-vector ab : stellar aberration ldsun : light deflection by the Sun c2s : p-vector to spherical anp : normalize angle into range +/- pi source"},{"id":188,"pagetitle":"Functions","title":"ERFA.aticqn","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.aticqn-Tuple{Any, Any, Any, Array{ERFA.LDBODY}}","content":" ERFA.aticqn  —  Method aticqn(ri, di, astrom, b::Array{LDBODY}) Quick CIRS to ICRS astrometric place transformation, given the star- independent astrometry parameters plus a list of light-deflecting bodies. Use of this function is appropriate when efficiency is important and where many star positions are all to be transformed for one date. The star-independent astrometry parameters can be obtained by calling one of the functions  apci[13] ,  apcg[13] ,  apco[13]  or  apcs[13] . Given ri ,  di : CIRS RA,Dec (radians) astrom : Star-independent astrometry parameters: pmt : PM time interval (SSB, Julian years) eb : SSB to observer (vector, au) eh : Sun to observer (unit vector) em : Distance from Sun to observer (au) v : Barycentric observer velocity (vector, c) bm1 :  $\\sqrt{1-|v|^2}$  Reciprocal of Lorenz factor bpn : Bias-precession-nutation matrix along : Longitude + s' (radians) xp1 : Polar motion xp wrt local meridian (radians) yp1 : Polar motion yp wrt local meridian (radians) sphi : Sine of geodetic latitude cphi : Cosine of geodetic latitude diurab : Magnitude of diurnal aberration vector l : \"Local\" Earth rotation angle (radians) refa : Refraction constant A (radians) refb : Refraction constant B (radians) n : Number of bodies (Note 3) b::Vector{LDBODY} : Data for each of the n bodies (Notes 3,4): bm : Mass of the body (solar masses, Note 5) dl : Deflection limiter (Note 6) pv : Barycentric PV of the body (au, au/day) Returned rc ,  dc : ICRS astrometric RA,Dec (radians) Notes Iterative techniques are used for the aberration and light deflection corrections so that the functions  aticqn  and  atciqn  are accurate inverses; even at the edge of the Sun's disk the discrepancy is only about 1 nanoarcsecond. If the only light-deflecting body to be taken into account is the Sun, the  aticq  function can be used instead. The struct b contains n entries, one for each body to be considered.  If n = 0, no gravitational light deflection will be applied, not even for the Sun. The struct b should include an entry for the Sun as well as for any planet or other body to be taken into account.  The entries should be in the order in which the light passes the body. In the entry in the b struct for body i, the mass parameter b[i].bm can, as required, be adjusted in order to allow for such effects as quadrupole field. The deflection limiter parameter b[i].dl is phi^2/2, where phi is the angular separation (in radians) between star and body at which limiting is applied.  As phi shrinks below the chosen threshold, the deflection is artificially reduced, reaching zero for phi = 0.   Example values suitable for a terrestrial observer, together with masses, are as follows: body i b[i].bm b[i].dl Sun 1.0 6e-6 Jupiter 0.00095435 3e-9 Saturn 0.00028574 3e-10 For efficiency, validation of the contents of the b array is omitted.  The supplied masses must be greater than zero, the position and velocity vectors must be right, and the deflection limiter greater than zero. Called s2c : spherical coordinates to unit vector trxp : product of transpose of r-matrix and p-vector zp : zero p-vector ab : stellar aberration ldn : light deflection by n bodies c2s : p-vector to spherical anp : normalize angle into range +/- pi source"},{"id":189,"pagetitle":"Functions","title":"ERFA.atio13","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.atio13-NTuple{14, Any}","content":" ERFA.atio13  —  Method atio13(ri, di, utc1, utc2, dut1, elong, phi, hm, xp, yp, phpa, tk, rh, wl) CIRS RA,Dec to observed place.  The caller supplies UTC, site coordinates, ambient air conditions and observing wavelength. Given ri : CIRS right ascension (CIO-based, radians) di : CIRS declination (radians) utc1 : UTC as a 2-part... utc2 : ...quasi Julian Date (Notes 1,2) dut1 : UT1-UTC (seconds, Note 3) elong : Longitude (radians, east +ve, Note 4) phi : Geodetic latitude (radians, Note 4) hm : Height above ellipsoid (m, geodetic Notes 4,6) xp ,  yp : Polar motion coordinates (radians, Note 5) phpa : Pressure at the observer (hPa = mB, Note 6) tc : Ambient temperature at the observer (deg C) rh : Relative humidity at the observer (range 0-1) wl : Wavelength (micrometers, Note 7) Returned aob : Observed azimuth (radians: N=0,E=90) zob : Observed zenith distance (radians) hob : Observed hour angle (radians) dob : Observed declination (radians) rob : Observed right ascension (CIO-based, radians) Notes utc1+utc2 is quasi Julian Date (see Note 2), apportioned in any  convenient way between the two arguments, for example where utc1  is the Julian Day Number and utc2 is the fraction of a day. However, JD cannot unambiguously represent UTC during a leap  second unless special measures are taken.  The convention in the  present function is that the JD day represents UTC days whether  the length is 86399, 86400 or 86401 SI seconds. Applications should use the function  dtf2d  to convert from  calendar date and time of day into 2-part quasi Julian Date, as  it implements the leap-second-ambiguity convention just  described. The warning status \"dubious year\" flags UTCs that predate the  introduction of the time scale or that are too far in the  future to be trusted.  See  dat  for further details. UT1-UTC is tabulated in IERS bulletins.  It increases by exactly  one second at the end of each positive UTC leap second,  introduced in order to keep UT1-UTC within +/- 0.9s.  n.b. This  practice is under review, and in the future UT1-UTC may grow  essentially without limit. The geographical coordinates are with respect to the  WGS84   reference ellipsoid.  TAKE CARE WITH THE LONGITUDE SIGN:  the  longitude required by the present function is east-positive  (i.e. right-handed), in accordance with geographical convention. The polar motion xp,yp can be obtained from IERS bulletins.  The  values are the coordinates (in radians) of the Celestial  Intermediate Pole with respect to the International Terrestrial  Reference System (see IERS Conventions 2003), measured along the  meridians 0 and 90 deg west respectively.  For many  applications, xp and yp can be set to zero. If hm, the height above the ellipsoid of the observing station  in meters, is not known but phpa, the pressure in hPa (=mB), is  available, an adequate estimate of hm can be obtained from the  expression hm = -29.3 * tsl * log ( phpa / 1013.25 ); where tsl is the approximate sea-level air temperature in K  (See Astrophysical Quantities, C.W.Allen, 3rd edition, section  52).  Similarly, if the pressure phpa is not known, it can be  estimated from the height of the observing station, hm, as  follows: phpa = 1013.25 * exp ( -hm / ( 29.3 * tsl ) ); Note, however, that the refraction is nearly proportional to  the pressure and that an accurate phpa value is important for  precise work. The argument wl specifies the observing wavelength in  micrometers.  The transition from optical to radio is assumed to  occur at 100 micrometers (about 3000 GHz). \"Observed\" Az,ZD means the position that would be seen by a  perfect geodetically aligned theodolite.  (Zenith distance is  used rather than altitude in order to reflect the fact that no  allowance is made for depression of the horizon.)  This is  related to the observed HA,Dec via the standard rotation, using  the geodetic latitude (corrected for polar motion), while the  observed HA and RA are related simply through the Earth rotation  angle and the site longitude.  \"Observed\" RA,Dec or HA,Dec thus  means the position that would be seen by a perfect equatorial  with its polar axis aligned to the Earth's axis of rotation. The accuracy of the result is limited by the corrections for  refraction, which use a simple  $A*tan(z) + B*tan^3(z)$  model.  Providing the meteorological parameters are known accurately and  there are no gross local effects, the predicted astrometric  coordinates should be within 0.05 arcsec (optical) or 1 arcsec  (radio) for a zenith distance of less than 70 degrees, better  than 30 arcsec (optical or radio) at 85 degrees and better  than 20 arcmin (optical) or 30 arcmin (radio) at the horizon. The complementary functions  atio13  and  atoi13  are self-  consistent to better than 1 microarcsecond all over the  celestial sphere. It is advisable to take great care with units, as even unlikely  values of the input parameters are accepted and processed in  accordance with the models used. Called apio13 : astrometry parameters, CIRS-observed, 2013 atioq : quick CIRS to observed source"},{"id":190,"pagetitle":"Functions","title":"ERFA.atioq","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.atioq-Tuple{Any, Any, Any}","content":" ERFA.atioq  —  Method atioq(ri, di, astrom) Quick CIRS to observed place transformation. Use of this function is appropriate when efficiency is important and where many star positions are all to be transformed for one date. The star-independent astrometry parameters can be obtained by calling  apio[13]  or  apco[13] . Given ri : CIRS right ascension di : CIRS declination astrom : Star-independent astrometry parameters: pmt : PM time interval (SSB, Julian years) eb : SSB to observer (vector, au) eh : Sun to observer (unit vector) em : Distance from Sun to observer (au) v : Barycentric observer velocity (vector, c) bm1 :  $\\sqrt{1-|v|^2}$  Reciprocal of Lorenz factor bpn : Bias-precession-nutation matrix along : Longitude + s' (radians) xp1 : Polar motion xp wrt local meridian (radians) yp1 : Polar motion yp wrt local meridian (radians) sphi : Sine of geodetic latitude cphi : Cosine of geodetic latitude diurab : Magnitude of diurnal aberration vector l : \"Local\" Earth rotation angle (radians) refa : Refraction constant A (radians) refb : Refraction constant B (radians) Returned aob : Observed azimuth (radians: N=0,E=90) zob : Observed zenith distance (radians) hob : Observed hour angle (radians) dob : Observed declination (radians) rob : Observed right ascension (CIO-based, radians) Notes This function returns zenith distance rather than altitude in order to reflect the fact that no allowance is made for depression of the horizon. The accuracy of the result is limited by the corrections for refraction, which use a simple  $A*tan(z) + B*tan^3(z)$  model. Providing the meteorological parameters are known accurately and there are no gross local effects, the predicted observed coordinates should be within 0.05 arcsec (optical) or 1 arcsec (radio) for a zenith distance of less than 70 degrees, better than 30 arcsec (optical or radio) at 85 degrees and better than 20 arcmin (optical) or 30 arcmin (radio) at the horizon. Without refraction, the complementary functions  atioq  and  atoiq  are self-consistent to better than 1 microarcsecond all over the celestial sphere.  With refraction included, consistency falls off at high zenith distances, but is still better than 0.05 arcsec at 85 degrees. It is advisable to take great care with units, as even unlikely values of the input parameters are accepted and processed in accordance with the models used. The CIRS RA,Dec is obtained from a star catalog mean place by allowing for space motion, parallax, the Sun's gravitational lens effect, annual aberration and precession-nutation.  For star positions in the ICRS, these effects can be applied by means of the  atci13  (etc.) functions.  Starting from classical \"mean place\" systems, additional transformations will be needed first. \"Observed\" Az,El means the position that would be seen by a perfect geodetically aligned theodolite.  This is obtained from the CIRS RA,Dec by allowing for Earth orientation and diurnal aberration, rotating from equator to horizon coordinates, and then adjusting for refraction.  The HA,Dec is obtained by rotating back into equatorial coordinates, and is the position that would be seen by a perfect equatorial with its polar axis aligned to the Earth's axis of rotation.  Finally, the RA is obtained by subtracting the HA from the local ERA. The star-independent CIRS-to-observed-place parameters in ASTROM may be computed with  apio[13]  or  apco[13] .  If nothing has changed significantly except the time,  aper[13]  may be used to perform the requisite adjustment to the astrom structure. Called s2c : spherical coordinates to unit vector c2s : p-vector to spherical anp : normalize angle into range 0 to 2pi source"},{"id":191,"pagetitle":"Functions","title":"ERFA.atoc13","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.atoc13-NTuple{15, Any}","content":" ERFA.atoc13  —  Method atoc13(typeofcoordinates, ob1, ob2, utc1, utc2, dut1, elong, phi, hm, xp, yp, phpa, tk, rh, wl) Observed place at a groundbased site to to ICRS astrometric RA,Dec. The caller supplies UTC, site coordinates, ambient air conditions and observing wavelength. Given type : Type of coordinates - \"R\", \"H\" or \"A\" (Notes 1,2) ob1 : Observed Az, HA or RA (radians; Az is N=0,E=90) ob2 : Observed ZD or Dec (radians) utc1 : UTC as a 2-part... utc2 : ...quasi Julian Date (Notes 3,4) dut1 : UT1-UTC (seconds, Note 5) elong : Longitude (radians, east +ve, Note 6) phi : Geodetic latitude (radians, Note 6) hm : Height above ellipsoid (m, geodetic Notes 6,8) xp ,  yp : Polar motion coordinates (radians, Note 7) phpa : Pressure at the observer (hPa = mB, Note 8) tc : Ambient temperature at the observer (deg C) rh : Relative humidity at the observer (range 0-1) wl : Wavelength (micrometers, Note 9) Returned rc ,  dc : ICRS astrometric RA,Dec (radians) Notes \"Observed\" Az,ZD means the position that would be seen by a  perfect geodetically aligned theodolite.  (Zenith distance is  used rather than altitude in order to reflect the fact that no  allowance is made for depression of the horizon.)  This is  related to the observed HA,Dec via the standard rotation, using  the geodetic latitude (corrected for polar motion), while the  observed HA and RA are related simply through the Earth rotation  angle and the site longitude.  \"Observed\" RA,Dec or HA,Dec thus  means the position that would be seen by a perfect equatorial  with its polar axis aligned to the Earth's axis of rotation. Only the first character of the type argument is significant.  \"R\" or \"r\" indicates that ob1 and ob2 are the observed right  ascension and declination;  \"H\" or \"h\" indicates that they are  hour angle (west +ve) and declination;  anything else (\"A\" or  \"a\" is recommended) indicates that ob1 and ob2 are azimuth  (north zero, east 90 deg) and zenith distance. utc1+utc2 is quasi Julian Date (see Note 2), apportioned in any  convenient way between the two arguments, for example where utc1  is the Julian Day Number and utc2 is the fraction of a day. However, JD cannot unambiguously represent UTC during a leap  second unless special measures are taken.  The convention in the  present function is that the JD day represents UTC days whether  the length is 86399, 86400 or 86401 SI seconds. Applications should use the function  dtf2d  to convert from  calendar date and time of day into 2-part quasi Julian Date, as  it implements the leap-second-ambiguity convention just  described. The warning status \"dubious year\" flags UTCs that predate the  introduction of the time scale or that are too far in the  future to be trusted.  See  dat  for further details. UT1-UTC is tabulated in IERS bulletins.  It increases by exactly  one second at the end of each positive UTC leap second,  introduced in order to keep UT1-UTC within +/- 0.9s.  n.b. This  practice is under review, and in the future UT1-UTC may grow  essentially without limit. The geographical coordinates are with respect to the  WGS84   reference ellipsoid.  TAKE CARE WITH THE LONGITUDE SIGN:  the  longitude required by the present function is east-positive  (i.e. right-handed), in accordance with geographical convention. The polar motion xp,yp can be obtained from IERS bulletins.  The  values are the coordinates (in radians) of the Celestial  Intermediate Pole with respect to the International Terrestrial  Reference System (see IERS Conventions 2003), measured along the  meridians 0 and 90 deg west respectively.  For many  applications, xp and yp can be set to zero. If hm, the height above the ellipsoid of the observing station  in meters, is not known but phpa, the pressure in hPa (=mB), is  available, an adequate estimate of hm can be obtained from the  expression hm = -29.3 * tsl * log ( phpa / 1013.25 ); where tsl is the approximate sea-level air temperature in K  (See Astrophysical Quantities, C.W.Allen, 3rd edition, section  52).  Similarly, if the pressure phpa is not known, it can be  estimated from the height of the observing station, hm, as  follows: phpa = 1013.25 * exp ( -hm / ( 29.3 * tsl ) ); Note, however, that the refraction is nearly proportional to  the pressure and that an accurate phpa value is important for  precise work. The argument wl specifies the observing wavelength in  micrometers.  The transition from optical to radio is assumed to  occur at 100 micrometers (about 3000 GHz). The accuracy of the result is limited by the corrections for  refraction, which use a simple  $A*tan(z) + B*tan^3(z)$  model.  Providing the meteorological parameters are known accurately and  there are no gross local effects, the predicted astrometric  coordinates should be within 0.05 arcsec (optical) or 1 arcsec  (radio) for a zenith distance of less than 70 degrees, better  than 30 arcsec (optical or radio) at 85 degrees and better  than 20 arcmin (optical) or 30 arcmin (radio) at the horizon. Without refraction, the complementary functions  atco13  and   atoc13  are self-consistent to better than 1 microarcsecond  all over the celestial sphere.  With refraction included,  consistency falls off at high zenith distances, but is still  better than 0.05 arcsec at 85 degrees. It is advisable to take great care with units, as even unlikely  values of the input parameters are accepted and processed in  accordance with the models used. Called apco13 : astrometry parameters, ICRS-observed atoiq : quick observed to CIRS aticq : quick CIRS to ICRS source"},{"id":192,"pagetitle":"Functions","title":"ERFA.atoi13","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.atoi13-NTuple{15, Any}","content":" ERFA.atoi13  —  Method atoi13(typeofcoordinates, ob1, ob2, utc1, utc2, dut1, elong, phi, hm, xp, yp, phpa, tk, rh, wl) Observed place to CIRS.  The caller supplies UTC, site coordinates, ambient air conditions and observing wavelength. Given type : Type of coordinates - \"R\", \"H\" or \"A\" (Notes 1,2) ob1 : Observed Az, HA or RA (radians; Az is N=0,E=90) ob2 : Observed ZD or Dec (radians) utc1 : UTC as a 2-part... utc2 : ...quasi Julian Date (Notes 3,4) dut1 : UT1-UTC (seconds, Note 5) elong : Longitude (radians, east +ve, Note 6) phi : Geodetic latitude (radians, Note 6) hm : Height above the ellipsoid (meters, Notes 6,8) xp ,  yp : Polar motion coordinates (radians, Note 7) phpa : Pressure at the observer (hPa = mB, Note 8) tc : Ambient temperature at the observer (deg C) rh : Relative humidity at the observer (range 0-1) wl : Wavelength (micrometers, Note 9) Returned ri : CIRS right ascension (CIO-based, radians) di : CIRS declination (radians) Notes \"Observed\" Az,ZD means the position that would be seen by a  perfect geodetically aligned theodolite.  (Zenith distance is  used rather than altitude in order to reflect the fact that no  allowance is made for depression of the horizon.)  This is  related to the observed HA,Dec via the standard rotation, using  the geodetic latitude (corrected for polar motion), while the  observed HA and RA are related simply through the Earth rotation  angle and the site longitude.  \"Observed\" RA,Dec or HA,Dec thus  means the position that would be seen by a perfect equatorial  with its polar axis aligned to the Earth's axis of rotation. Only the first character of the type argument is significant.  \"R\" or \"r\" indicates that ob1 and ob2 are the observed right  ascension and declination;  \"H\" or \"h\" indicates that they are  hour angle (west +ve) and declination;  anything else (\"A\" or  \"a\" is recommended) indicates that ob1 and ob2 are azimuth  (north zero, east 90 deg) and zenith distance. utc1+utc2 is quasi Julian Date (see Note 2), apportioned in any  convenient way between the two arguments, for example where utc1  is the Julian Day Number and utc2 is the fraction of a day. However, JD cannot unambiguously represent UTC during a leap  second unless special measures are taken.  The convention in the  present function is that the JD day represents UTC days whether  the length is 86399, 86400 or 86401 SI seconds. Applications should use the function  dtf2d  to convert from  calendar date and time of day into 2-part quasi Julian Date, as  it implements the leap-second-ambiguity convention just  described. The warning status \"dubious year\" flags UTCs that predate the  introduction of the time scale or that are too far in the  future to be trusted.  See  dat  for further details. UT1-UTC is tabulated in IERS bulletins.  It increases by exactly  one second at the end of each positive UTC leap second,  introduced in order to keep UT1-UTC within +/- 0.9s.  n.b. This  practice is under review, and in the future UT1-UTC may grow  essentially without limit. The geographical coordinates are with respect to the  WGS84   reference ellipsoid.  TAKE CARE WITH THE LONGITUDE SIGN:  the  longitude required by the present function is east-positive  (i.e. right-handed), in accordance with geographical convention. The polar motion xp,yp can be obtained from IERS bulletins.  The  values are the coordinates (in radians) of the Celestial  Intermediate Pole with respect to the International Terrestrial  Reference System (see IERS Conventions 2003), measured along the  meridians 0 and 90 deg west respectively.  For many  applications, xp and yp can be set to zero. If hm, the height above the ellipsoid of the observing station  in meters, is not known but phpa, the pressure in hPa (=mB), is  available, an adequate estimate of hm can be obtained from the  expression hm = -29.3 * tsl * log ( phpa / 1013.25 ); where tsl is the approximate sea-level air temperature in K  (See Astrophysical Quantities, C.W.Allen, 3rd edition, section  52).  Similarly, if the pressure phpa is not known, it can be  estimated from the height of the observing station, hm, as  follows: phpa = 1013.25 * exp ( -hm / ( 29.3 * tsl ) ); Note, however, that the refraction is nearly proportional to  the pressure and that an accurate phpa value is important for  precise work. The argument wl specifies the observing wavelength in  micrometers.  The transition from optical to radio is assumed to  occur at 100 micrometers (about 3000 GHz). The accuracy of the result is limited by the corrections for  refraction, which use a simple  $A*tan(z) + B*tan^3(z)$  model.  Providing the meteorological parameters are known accurately and  there are no gross local effects, the predicted astrometric  coordinates should be within 0.05 arcsec (optical) or 1 arcsec  (radio) for a zenith distance of less than 70 degrees, better  than 30 arcsec (optical or radio) at 85 degrees and better  than 20 arcmin (optical) or 30 arcmin (radio) at the horizon. Without refraction, the complementary functions  atio13  and   atoi13  are self-consistent to better than 1 microarcsecond  all over the celestial sphere.  With refraction included,  consistency falls off at high zenith distances, but is still  better than 0.05 arcsec at 85 degrees. It is advisable to take great care with units, as even unlikely  values of the input parameters are accepted and processed in  accordance with the models used. Called apio13 : astrometry parameters, CIRS-observed, 2013 atoiq : quick observed to CIRS source"},{"id":193,"pagetitle":"Functions","title":"ERFA.atoiq","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.atoiq-NTuple{4, Any}","content":" ERFA.atoiq  —  Method atoiq(typeofcoordinates, ob1, ob2, astrom) Quick observed place to CIRS, given the star-independent astrometry parameters. Use of this function is appropriate when efficiency is important and where many star positions are all to be transformed for one date. The star-independent astrometry parameters can be obtained by calling  apio[13]  or  apco[13] . Given type : Type of coordinates: \"R\", \"H\" or \"A\" (Note 1) ob1 : Observed Az, HA or RA (radians; Az is N=0,E=90) ob2 : Observed ZD or Dec (radians) astrom : Star-independent astrometry parameters: pmt : PM time interval (SSB, Julian years) eb : SSB to observer (vector, au) eh : Sun to observer (unit vector) em : Distance from Sun to observer (au) v : Barycentric observer velocity (vector, c) bm1 :  $\\sqrt{1-|v|^2}$  Reciprocal of Lorenz factor bpn : Bias-precession-nutation matrix along : Longitude + s' (radians) xp1 : Polar motion xp wrt local meridian (radians) yp1 : Polar motion yp wrt local meridian (radians) sphi : Sine of geodetic latitude cphi : Cosine of geodetic latitude diurab : Magnitude of diurnal aberration vector l : \"Local\" Earth rotation angle (radians) refa : Refraction constant A (radians) refb : Refraction constant B (radians) Returned ri : CIRS right ascension (CIO-based, radians) di : CIRS declination (radians) Notes \"Observed\" Az,El means the position that would be seen by a perfect geodetically aligned theodolite.  This is related to the observed HA,Dec via the standard rotation, using the geodetic latitude (corrected for polar motion), while the observed HA and RA are related simply through the Earth rotation angle and the site longitude.  \"Observed\" RA,Dec or HA,Dec thus means the position that would be seen by a perfect equatorial with its polar axis aligned to the Earth's axis of rotation.  By removing from the observed place the effects of atmospheric refraction and diurnal aberration, the CIRS RA,Dec is obtained. Only the first character of the type argument is significant. \"R\" or \"r\" indicates that ob1 and ob2 are the observed right ascension and declination;  \"H\" or \"h\" indicates that they are hour angle (west +ve) and declination;  anything else (\"A\" or \"a\" is recommended) indicates that ob1 and ob2 are azimuth (north zero, east 90 deg) and zenith distance.  (Zenith distance is used rather than altitude in order to reflect the fact that no allowance is made for depression of the horizon.) The accuracy of the result is limited by the corrections for refraction, which use a simple  $A*tan(z) + B*tan^3(z)$  model. Providing the meteorological parameters are known accurately and there are no gross local effects, the predicted observed coordinates should be within 0.05 arcsec (optical) or 1 arcsec (radio) for a zenith distance of less than 70 degrees, better than 30 arcsec (optical or radio) at 85 degrees and better than 20 arcmin (optical) or 30 arcmin (radio) at the horizon. Without refraction, the complementary functions  atioq  and  atoiq  are self-consistent to better than 1 microarcsecond all over the celestial sphere.  With refraction included, consistency falls off at high zenith distances, but is still better than 0.05 arcsec at 85 degrees. It is advisable to take great care with units, as even unlikely values of the input parameters are accepted and processed in accordance with the models used. Called s2c : spherical coordinates to unit vector c2s : p-vector to spherical anp : normalize angle into range 0 to 2pi source"},{"id":194,"pagetitle":"Functions","title":"ERFA.bi00","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.bi00-Tuple{}","content":" ERFA.bi00  —  Method bi00() Frame bias components of IAU 2000 precession-nutation models (part of MHB2000 with additions). Returned dpsibi ,  depsbi : Longitude and obliquity corrections dra : The ICRS RA of the J2000.0 mean equinox Notes The frame bias corrections in longitude and obliquity (radians) are required in order to correct for the offset between the GCRS pole and the mean J2000.0 pole.  They define, with respect to the GCRS frame, a J2000.0 mean pole that is consistent with the rest of the IAU 2000A precession-nutation model. In addition to the displacement of the pole, the complete description of the frame bias requires also an offset in right ascension.  This is not part of the IAU 2000A model, and is from Chapront et al. (2002).  It is returned in radians. This is a supplemented implementation of one aspect of the IAU 2000A nutation model, formally adopted by the IAU General Assembly in 2000, namely MHB2000 (Mathews et al. 2002). References Chapront, J., Chapront-Touze, M. & Francou, G., Astron.   Astrophys., 387, 700, 2002. Mathews, P.M., Herring, T.A., Buffet, B.A., \"Modeling of nutation   and precession: New nutation series for nonrigid Earth and   insights into the Earth's interior\", J.Geophys.Res., 107, B4, 2002.   The MHB2000 code itself was obtained on 9th September 2002   from ftp://maia.usno.navy.mil/conv2000/chapter5/IAU2000A. source"},{"id":195,"pagetitle":"Functions","title":"ERFA.bp00","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.bp00","content":" ERFA.bp00  —  Function bp00(date1, date2) Frame bias and precession, IAU 2000. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned rb : Frame bias matrix (Note 2) rp : Precession matrix (Note 3) rbp : Bias-precession matrix (Note 4) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix rb transforms vectors from GCRS to mean J2000.0 by applying frame bias. The matrix rp transforms vectors from J2000.0 mean equator and equinox to mean equator and equinox of date by applying precession. The matrix rbp transforms vectors from GCRS to mean equator and equinox of date by applying frame bias then precession.  It is the product rp x rb. It is permissible to re-use the same array in the returned arguments.  The arrays are filled in the order given. Called bi00 : frame bias components, IAU 2000 pr00 : IAU 2000 precession adjustments ir : initialize r-matrix to identity rx : rotate around X-axis ry : rotate around Y-axis rz : rotate around Z-axis cr : copy r-matrix rxr : product of two r-matrices Reference \"Expressions for the Celestial Intermediate Pole and Celestial   Ephemeris Origin consistent with the IAU 2000A precession-   nutation model\", Astron.Astrophys. 400, 1145-1154 (2003) n.b. The celestial ephemeris origin (CEO) was renamed \"celestial   intermediate origin\" (CIO) by IAU 2006 Resolution 2. source"},{"id":196,"pagetitle":"Functions","title":"ERFA.bp06","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.bp06","content":" ERFA.bp06  —  Function bp06(date1, date2) Frame bias and precession, IAU 2006. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned rb : Frame bias matrix (Note 2) rp : Precession matrix (Note 3) rbp : Bias-precession matrix (Note 4) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix rb transforms vectors from GCRS to mean J2000.0 by applying frame bias. The matrix rp transforms vectors from mean J2000.0 to mean of date by applying precession. The matrix rbp transforms vectors from GCRS to mean of date by applying frame bias then precession.  It is the product rp x rb. It is permissible to re-use the same array in the returned arguments.  The arrays are filled in the order given. Called pfw06 : bias-precession F-W angles, IAU 2006 fw2m : F-W angles to r-matrix pmat06 : PB matrix, IAU 2006 tr : transpose r-matrix rxr : product of two r-matrices cr : copy r-matrix References Capitaine, N. & Wallace, P.T., 2006, Astron.Astrophys. 450, 855 Wallace, P.T. & Capitaine, N., 2006, Astron.Astrophys. 459, 981 source"},{"id":197,"pagetitle":"Functions","title":"ERFA.bpn2xy","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.bpn2xy-Tuple{Any}","content":" ERFA.bpn2xy  —  Method bpn2xy(rbpn) Extract from the bias-precession-nutation matrix the X,Y coordinates of the Celestial Intermediate Pole. Given rbpn : Celestial-to-true matrix (Note 1) Returned x ,  y : Celestial Intermediate Pole (Note 2) Notes The matrix rbpn transforms vectors from GCRS to true equator (and CIO or equinox) of date, and therefore the Celestial Intermediate Pole unit vector is the bottom row of the matrix. The arguments x,y are components of the Celestial Intermediate Pole unit vector in the Geocentric Celestial Reference System. Reference \"Expressions for the Celestial Intermediate Pole and Celestial   Ephemeris Origin consistent with the IAU 2000A precession-   nutation model\", Astron.Astrophys. 400, 1145-1154   (2003) n.b. The celestial ephemeris origin (CEO) was renamed \"celestial   intermediate origin\" (CIO) by IAU 2006 Resolution 2. source"},{"id":198,"pagetitle":"Functions","title":"ERFA.c2i00a","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.c2i00a","content":" ERFA.c2i00a  —  Function c2i00a(a, b) Form the celestial-to-intermediate matrix for a given date using the IAU 2000A precession-nutation model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned rc2i : Celestial-to-intermediate matrix (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix rc2i is the first stage in the transformation from celestial to terrestrial coordinates: [TRS]  =  RPOM * R_3(ERA) * rc2i * [CRS] =  rc2t * [CRS] where [CRS] is a vector in the Geocentric Celestial Reference System and [TRS] is a vector in the International Terrestrial Reference System (see IERS Conventions 2003), ERA is the Earth Rotation Angle and RPOM is the polar motion matrix. A faster, but slightly less accurate result (about 1 mas), can be obtained by using instead the  c2i00b  function. Called pnm00a : classical NPB matrix, IAU 2000A c2ibpn : celestial-to-intermediate matrix, given NPB matrix References \"Expressions for the Celestial Intermediate Pole and Celestial   Ephemeris Origin consistent with the IAU 2000A precession-   nutation model\", Astron.Astrophys. 400, 1145-1154   (2003) n.b. The celestial ephemeris origin (CEO) was renamed \"celestial   intermediate origin\" (CIO) by IAU 2006 Resolution 2. McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":199,"pagetitle":"Functions","title":"ERFA.c2i00b","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.c2i00b","content":" ERFA.c2i00b  —  Function c2i00b(a, b) Form the celestial-to-intermediate matrix for a given date using the IAU 2000B precession-nutation model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned rc2i : Celestial-to-intermediate matrix (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix rc2i is the first stage in the transformation from celestial to terrestrial coordinates: [TRS]  =  RPOM * R_3(ERA) * rc2i * [CRS] =  rc2t * [CRS] where [CRS] is a vector in the Geocentric Celestial Reference System and [TRS] is a vector in the International Terrestrial Reference System (see IERS Conventions 2003), ERA is the Earth Rotation Angle and RPOM is the polar motion matrix. The present function is faster, but slightly less accurate (about 1 mas), than the  c2i00a  function. Called pnm00b : classical NPB matrix, IAU 2000B c2ibpn : celestial-to-intermediate matrix, given NPB matrix References \"Expressions for the Celestial Intermediate Pole and Celestial   Ephemeris Origin consistent with the IAU 2000A precession-   nutation model\", Astron.Astrophys. 400, 1145-1154   (2003) n.b. The celestial ephemeris origin (CEO) was renamed \"celestial   intermediate origin\" (CIO) by IAU 2006 Resolution 2. McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":200,"pagetitle":"Functions","title":"ERFA.c2i06a","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.c2i06a","content":" ERFA.c2i06a  —  Function c2i06a(a, b) Form the celestial-to-intermediate matrix for a given date using the IAU 2006 precession and IAU 2000A nutation models. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned rc2i : Celestial-to-intermediate matrix (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix rc2i is the first stage in the transformation from celestial to terrestrial coordinates: [TRS]  =  RPOM * R_3(ERA) * rc2i * [CRS] =  RC2T * [CRS] where [CRS] is a vector in the Geocentric Celestial Reference System and [TRS] is a vector in the International Terrestrial Reference System (see IERS Conventions 2003), ERA is the Earth Rotation Angle and RPOM is the polar motion matrix. Called pnm06a : classical NPB matrix, IAU 2006/2000A bpn2xy : extract CIP X,Y coordinates from NPB matrix s06 : the CIO locator s, given X,Y, IAU 2006 c2ixys : celestial-to-intermediate matrix, given X,Y and s References McCarthy, D. D., Petit, G. (eds.), 2004, IERS Conventions (2003),   IERS Technical Note No. 32, BKG source"},{"id":201,"pagetitle":"Functions","title":"ERFA.c2ibpn","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.c2ibpn-Tuple{Any, Any, Any}","content":" ERFA.c2ibpn  —  Method c2ibpn(date1, date2, rbpn) Form the celestial-to-intermediate matrix for a given date given the bias-precession-nutation matrix.  IAU 2000. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) rbpn : Celestial-to-true matrix (Note 2) Returned rc2i : Celestial-to-intermediate matrix (Note 3) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix rbpn transforms vectors from GCRS to true equator (and CIO or equinox) of date.  Only the CIP (bottom row) is used. The matrix rc2i is the first stage in the transformation from celestial to terrestrial coordinates: [TRS] = RPOM * R_3(ERA) * rc2i * [CRS] = RC2T * [CRS] where [CRS] is a vector in the Geocentric Celestial Reference System and [TRS] is a vector in the International Terrestrial Reference System (see IERS Conventions 2003), ERA is the Earth Rotation Angle and RPOM is the polar motion matrix. Although its name does not include \"00\", This function is in fact specific to the IAU 2000 models. Called bpn2xy : extract CIP X,Y coordinates from NPB matrix c2ixy : celestial-to-intermediate matrix, given X,Y References \"Expressions for the Celestial Intermediate Pole and Celestial   Ephemeris Origin consistent with the IAU 2000A precession-   nutation model\", Astron.Astrophys. 400, 1145-1154 (2003) n.b. The celestial ephemeris origin (CEO) was renamed \"celestial   intermediate origin\" (CIO) by IAU 2006 Resolution 2. McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":202,"pagetitle":"Functions","title":"ERFA.c2ixy","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.c2ixy-NTuple{4, Any}","content":" ERFA.c2ixy  —  Method c2ixy(x, y, s, t) Form the celestial to intermediate-frame-of-date matrix for a given date when the CIP X,Y coordinates are known.  IAU 2000. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) x ,  y : Celestial Intermediate Pole (Note 2) Returned rc2i : Celestial-to-intermediate matrix (Note 3) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The Celestial Intermediate Pole coordinates are the x,y components of the unit vector in the Geocentric Celestial Reference System. The matrix rc2i is the first stage in the transformation from celestial to terrestrial coordinates: [TRS] = RPOM * R_3(ERA) * rc2i * [CRS] = RC2T * [CRS] where [CRS] is a vector in the Geocentric Celestial Reference System and [TRS] is a vector in the International Terrestrial Reference System (see IERS Conventions 2003), ERA is the Earth Rotation Angle and RPOM is the polar motion matrix. Although its name does not include \"00\", This function is in fact specific to the IAU 2000 models. Called c2ixys : celestial-to-intermediate matrix, given X,Y and s s00 : the CIO locator s, given X,Y, IAU 2000A Reference McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":203,"pagetitle":"Functions","title":"ERFA.c2ixys","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.c2ixys-Tuple{Any, Any, Any}","content":" ERFA.c2ixys  —  Method c2ixys(x, y, s) Form the celestial to intermediate-frame-of-date matrix given the CIP X,Y and the CIO locator s. Given x ,  y : Celestial Intermediate Pole (Note 1) s : The CIO locator s (Note 2) Returned rc2i : Celestial-to-intermediate matrix (Note 3) Notes The Celestial Intermediate Pole coordinates are the x,y components of the unit vector in the Geocentric Celestial Reference System. The CIO locator s (in radians) positions the Celestial Intermediate Origin on the equator of the CIP. The matrix rc2i is the first stage in the transformation from celestial to terrestrial coordinates: [TRS] = RPOM * R_3(ERA) * rc2i * [CRS] = RC2T * [CRS] where [CRS] is a vector in the Geocentric Celestial Reference System and [TRS] is a vector in the International Terrestrial Reference System (see IERS Conventions 2003), ERA is the Earth Rotation Angle and RPOM is the polar motion matrix. Called ir : initialize r-matrix to identity rz : rotate around Z-axis ry : rotate around Y-axis Reference McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":204,"pagetitle":"Functions","title":"ERFA.c2s","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.c2s-Tuple{Any}","content":" ERFA.c2s  —  Method c2s(p) P-vector to spherical coordinates. Given p : P-vector Returned theta : Longitude angle (radians) phi : Latitude angle (radians) Notes The vector p can have any magnitude; only its direction is used. If p is null, zero theta and phi are returned. At either pole, zero theta is returned. source"},{"id":205,"pagetitle":"Functions","title":"ERFA.c2t00a","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.c2t00a","content":" ERFA.c2t00a  —  Function c2t00a(tta, ttb, uta, utb, xp, yp) Form the celestial to terrestrial matrix given the date, the UT1 and the polar motion, using the IAU 2000A nutation model. Given tta ,  ttb : TT as a 2-part Julian Date (Note 1) uta ,  utb : UT1 as a 2-part Julian Date (Note 1) xp ,  yp : Coordinates of the pole (radians, Note 2) Returned rc2t : Celestial-to-terrestrial matrix (Note 3) Notes The TT and UT1 dates tta+ttb and uta+utb are Julian Dates, apportioned in any convenient way between the arguments uta and utb.  For example, JD(UT1)=2450123.7 could be expressed in any of these ways, among others: uta utb Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 and MJD methods are good compromises between resolution and convenience.  In the case of uta,utb, the date & time method is best matched to the Earth rotation angle algorithm used:  maximum precision is delivered when the uta argument is for 0hrs UT1 on the day in question and the utb argument lies in the range 0 to 1, or vice versa. The arguments xp and yp are the coordinates (in radians) of the Celestial Intermediate Pole with respect to the International Terrestrial Reference System (see IERS Conventions 2003), measured along the meridians to 0 and 90 deg west respectively. The matrix rc2t transforms from celestial to terrestrial coordinates: [TRS] = RPOM * R_3(ERA) * RC2I * [CRS] = rc2t * [CRS] where [CRS] is a vector in the Geocentric Celestial Reference System and [TRS] is a vector in the International Terrestrial Reference System (see IERS Conventions 2003), RC2I is the celestial-to-intermediate matrix, ERA is the Earth rotation angle and RPOM is the polar motion matrix. A faster, but slightly less accurate result (about 1 mas), can be obtained by using instead the  c2t00b  function. Called c2i00a : celestial-to-intermediate matrix, IAU 2000A era00 : Earth rotation angle, IAU 2000 sp00 : the TIO locator s', IERS 2000 pom00 : polar motion matrix c2tcio : form CIO-based celestial-to-terrestrial matrix Reference McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":206,"pagetitle":"Functions","title":"ERFA.c2t00b","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.c2t00b","content":" ERFA.c2t00b  —  Function c2t00b(tta, ttb, uta, utb, xp, yp) Form the celestial to terrestrial matrix given the date, the UT1 and the polar motion, using the IAU 2000B nutation model. Given tta ,  ttb : TT as a 2-part Julian Date (Note 1) uta ,  utb : UT1 as a 2-part Julian Date (Note 1) xp ,  yp : Coordinates of the pole (radians, Note 2) Returned rc2t : Celestial-to-terrestrial matrix (Note 3) Notes The TT and UT1 dates tta+ttb and uta+utb are Julian Dates, apportioned in any convenient way between the arguments uta and utb.  For example, JD(UT1)=2450123.7 could be expressed in any of these ways, among others: uta utb Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 and MJD methods are good compromises between resolution and convenience.  In the case of uta,utb, the date & time method is best matched to the Earth rotation angle algorithm used:  maximum precision is delivered when the uta argument is for 0hrs UT1 on the day in question and the utb argument lies in the range 0 to 1, or vice versa. The arguments xp and yp are the coordinates (in radians) of the Celestial Intermediate Pole with respect to the International Terrestrial Reference System (see IERS Conventions 2003), measured along the meridians to 0 and 90 deg west respectively. The matrix rc2t transforms from celestial to terrestrial coordinates: [TRS] = RPOM * R_3(ERA) * RC2I * [CRS] = rc2t * [CRS] where [CRS] is a vector in the Geocentric Celestial Reference System and [TRS] is a vector in the International Terrestrial Reference System (see IERS Conventions 2003), RC2I is the celestial-to-intermediate matrix, ERA is the Earth rotation angle and RPOM is the polar motion matrix. The present function is faster, but slightly less accurate (about 1 mas), than the  c2t00a  function. Called c2i00b : celestial-to-intermediate matrix, IAU 2000B era00 : Earth rotation angle, IAU 2000 pom00 : polar motion matrix c2tcio : form CIO-based celestial-to-terrestrial matrix Reference McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":207,"pagetitle":"Functions","title":"ERFA.c2t06a","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.c2t06a","content":" ERFA.c2t06a  —  Function c2t06a(tta, ttb, uta, utb, xp, yp) Form the celestial to terrestrial matrix given the date, the UT1 and the polar motion, using the IAU 2006 precession and IAU 2000A nutation models. Given tta ,  ttb : TT as a 2-part Julian Date (Note 1) uta ,  utb : UT1 as a 2-part Julian Date (Note 1) xp ,  yp : Coordinates of the pole (radians, Note 2) Returned rc2t : Celestial-to-terrestrial matrix (Note 3) Notes The TT and UT1 dates tta+ttb and uta+utb are Julian Dates, apportioned in any convenient way between the arguments uta and utb.  For example, JD(UT1)=2450123.7 could be expressed in any of these ways, among others: uta utb Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 and MJD methods are good compromises between resolution and convenience.  In the case of uta,utb, the date & time method is best matched to the Earth rotation angle algorithm used:  maximum precision is delivered when the uta argument is for 0hrs UT1 on the day in question and the utb argument lies in the range 0 to 1, or vice versa. The arguments xp and yp are the coordinates (in radians) of the Celestial Intermediate Pole with respect to the International Terrestrial Reference System (see IERS Conventions 2003), measured along the meridians to 0 and 90 deg west respectively. The matrix rc2t transforms from celestial to terrestrial coordinates: [TRS] = RPOM * R_3(ERA) * RC2I * [CRS] = rc2t * [CRS] where [CRS] is a vector in the Geocentric Celestial Reference System and [TRS] is a vector in the International Terrestrial Reference System (see IERS Conventions 2003), RC2I is the celestial-to-intermediate matrix, ERA is the Earth rotation angle and RPOM is the polar motion matrix. Called c2i06a : celestial-to-intermediate matrix, IAU 2006/2000A era00 : Earth rotation angle, IAU 2000 sp00 : the TIO locator s', IERS 2000 pom00 : polar motion matrix c2tcio : form CIO-based celestial-to-terrestrial matrix Reference McCarthy, D. D., Petit, G. (eds.), 2004, IERS Conventions (2003),   IERS Technical Note No. 32, BKG source"},{"id":208,"pagetitle":"Functions","title":"ERFA.c2tcio","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.c2tcio","content":" ERFA.c2tcio  —  Function c2tcio(rc2i, era, rpom) Assemble the celestial to terrestrial matrix from CIO-based components (the celestial-to-intermediate matrix, the Earth Rotation Angle and the polar motion matrix). Given rc2i : Celestial-to-intermediate matrix era : Earth rotation angle (radians) rpom : Polar-motion matrix Returned rc2t : Celestial-to-terrestrial matrix Notes This function constructs the rotation matrix that transforms vectors in the celestial system into vectors in the terrestrial system.  It does so starting from precomputed components, namely the matrix which rotates from celestial coordinates to the intermediate frame, the Earth rotation angle and the polar motion matrix.  One use of the present function is when generating a series of celestial-to-terrestrial matrices where only the Earth Rotation Angle changes, avoiding the considerable overhead of recomputing the precession-nutation more often than necessary to achieve given accuracy objectives. The relationship between the arguments is as follows: [TRS] = RPOM * R_3(ERA) * rc2i * [CRS] = rc2t * [CRS] where [CRS] is a vector in the Geocentric Celestial Reference System and [TRS] is a vector in the International Terrestrial Reference System (see IERS Conventions 2003). Called cr : copy r-matrix rz : rotate around Z-axis rxr : product of two r-matrices Reference McCarthy, D. D., Petit, G. (eds.), 2004, IERS Conventions (2003),   IERS Technical Note No. 32, BKG source"},{"id":209,"pagetitle":"Functions","title":"ERFA.c2teqx","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.c2teqx","content":" ERFA.c2teqx  —  Function c2teqx(rc2i, era, rpom) Assemble the celestial to terrestrial matrix from equinox-based components (the celestial-to-true matrix, the Greenwich Apparent Sidereal Time and the polar motion matrix). Given rbpn : Celestial-to-true matrix gst : Greenwich (apparent) Sidereal Time (radians) rpom : Polar-motion matrix Returned rc2t : Celestial-to-terrestrial matrix (Note 2) Notes This function constructs the rotation matrix that transforms vectors in the celestial system into vectors in the terrestrial system.  It does so starting from precomputed components, namely the matrix which rotates from celestial coordinates to the true equator and equinox of date, the Greenwich Apparent Sidereal Time and the polar motion matrix.  One use of the present function is when generating a series of celestial-to-terrestrial matrices where only the Sidereal Time changes, avoiding the considerable overhead of recomputing the precession-nutation more often than necessary to achieve given accuracy objectives. The relationship between the arguments is as follows: [TRS] = rpom * R_3(gst) * rbpn * [CRS] = rc2t * [CRS] where [CRS] is a vector in the Geocentric Celestial Reference System and [TRS] is a vector in the International Terrestrial Reference System (see IERS Conventions 2003). Called cr : copy r-matrix rz : rotate around Z-axis rxr : product of two r-matrices Reference McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":210,"pagetitle":"Functions","title":"ERFA.c2tpe","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.c2tpe","content":" ERFA.c2tpe  —  Function c2tpe(tta, ttb, uta, utb, x, y, xp, yp) Form the celestial to terrestrial matrix given the date, the UT1, the nutation and the polar motion.  IAU 2000. Given tta ,  ttb : TT as a 2-part Julian Date (Note 1) uta ,  utb : UT1 as a 2-part Julian Date (Note 1) dpsi ,  deps : Nutation (Note 2) xp ,  yp : Coordinates of the pole (radians, Note 3) Returned rc2t : Celestial-to-terrestrial matrix (Note 4) Notes The TT and UT1 dates tta+ttb and uta+utb are Julian Dates, apportioned in any convenient way between the arguments uta and utb.  For example, JD(UT1)=2450123.7 could be expressed in any of these ways, among others: uta utb Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 and MJD methods are good compromises between resolution and convenience.  In the case of uta,utb, the date & time method is best matched to the Earth rotation angle algorithm used:  maximum precision is delivered when the uta argument is for 0hrs UT1 on the day in question and the utb argument lies in the range 0 to 1, or vice versa. The caller is responsible for providing the nutation components; they are in longitude and obliquity, in radians and are with respect to the equinox and ecliptic of date.  For high-accuracy applications, free core nutation should be included as well as any other relevant corrections to the position of the CIP. The arguments xp and yp are the coordinates (in radians) of the Celestial Intermediate Pole with respect to the International Terrestrial Reference System (see IERS Conventions 2003), measured along the meridians to 0 and 90 deg west respectively. The matrix rc2t transforms from celestial to terrestrial coordinates: [TRS] = RPOM * R_3(GST) * RBPN * [CRS] = rc2t * [CRS] where [CRS] is a vector in the Geocentric Celestial Reference System and [TRS] is a vector in the International Terrestrial Reference System (see IERS Conventions 2003), RBPN is the bias-precession-nutation matrix, GST is the Greenwich (apparent) Sidereal Time and RPOM is the polar motion matrix. Although its name does not include \"00\", This function is in fact specific to the IAU 2000 models. Called pn00 : bias/precession/nutation results, IAU 2000 gmst00 : Greenwich mean sidereal time, IAU 2000 sp00 : the TIO locator s', IERS 2000 ee00 : equation of the equinoxes, IAU 2000 pom00 : polar motion matrix c2teqx : form equinox-based celestial-to-terrestrial matrix Reference McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":211,"pagetitle":"Functions","title":"ERFA.c2txy","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.c2txy","content":" ERFA.c2txy  —  Function c2txy(tta, ttb, uta, utb, x, y, xp, yp) Form the celestial to terrestrial matrix given the date, the UT1, the CIP coordinates and the polar motion.  IAU 2000. Given tta ,  ttb : TT as a 2-part Julian Date (Note 1) uta ,  utb : UT1 as a 2-part Julian Date (Note 1) x ,  y : Celestial Intermediate Pole (Note 2) xp ,  yp : Coordinates of the pole (radians, Note 3) Returned rc2t : Celestial-to-terrestrial matrix (Note 4) Notes The TT and UT1 dates tta+ttb and uta+utb are Julian Dates, apportioned in any convenient way between the arguments uta and utb.  For example, JD(UT1)=2450123.7 could be expressed in any o these ways, among others: uta utb Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 and MJD methods are good compromises between resolution and convenience.  In the case of uta,utb, the date & time method is best matched to the Earth rotation angle algorithm used:  maximum precision is delivered when the uta argument is for 0hrs UT1 on the day in question and the utb argument lies in the range 0 to 1, or vice versa. The Celestial Intermediate Pole coordinates are the x,y components of the unit vector in the Geocentric Celestial Reference System. The arguments xp and yp are the coordinates (in radians) of the Celestial Intermediate Pole with respect to the International Terrestrial Reference System (see IERS Conventions 2003), measured along the meridians to 0 and 90 deg west respectively. The matrix rc2t transforms from celestial to terrestrial coordinates: [TRS] = RPOM * R_3(ERA) * RC2I * [CRS] = rc2t * [CRS] where [CRS] is a vector in the Geocentric Celestial Reference System and [TRS] is a vector in the International Terrestrial Reference System (see IERS Conventions 2003), ERA is the Earth Rotation Angle and RPOM is the polar motion matrix. Although its name does not include \"00\", This function is in fact specific to the IAU 2000 models. Called c2ixy : celestial-to-intermediate matrix, given X,Y era00 : Earth rotation angle, IAU 2000 sp00 : the TIO locator s', IERS 2000 pom00 : polar motion matrix c2tcio : form CIO-based celestial-to-terrestrial matrix Reference McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":212,"pagetitle":"Functions","title":"ERFA.cal2jd","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.cal2jd-Tuple{Any, Any, Any}","content":" ERFA.cal2jd  —  Method cal2jd(iy, imo, id) Gregorian Calendar to Julian Date. Given iy ,  im ,  id : Year, month, day in Gregorian calendar (Note 1) Returned djm0 : MJD zero-point: always 2400000.5 djm : Modified Julian Date for 0 hrs Notes The algorithm used is valid from -4800 March 1, but this implementation rejects dates before -4799 January 1. The Julian Date is returned in two pieces, in the usual ERFA manner, which is designed to preserve time resolution.  The Julian Date is available as a single number by adding djm0 and djm. In early eras the conversion is from the \"Proleptic Gregorian Calendar\";  no account is taken of the date(s) of adoption of the Gregorian Calendar, nor is the AD/BC numbering convention observed. Reference Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992),   Section 12.92 (p604). source"},{"id":213,"pagetitle":"Functions","title":"ERFA.cpv","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.cpv","content":" ERFA.cpv  —  Function cpv(pv) Copy a position/velocity vector. Deprecated Use  Base.deepcopy  instead. Given pv : position/velocity vector to be copied Returned c : copy source"},{"id":214,"pagetitle":"Functions","title":"ERFA.cr","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.cr","content":" ERFA.cr  —  Function cr(p) Copy an r-vector. Deprecated Use  Base.copy  instead. Given r : r-matrix to be copied Returned c : copy source"},{"id":215,"pagetitle":"Functions","title":"ERFA.d2dtf","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.d2dtf-Tuple{AbstractString, Any, Any, Any}","content":" ERFA.d2dtf  —  Method d2dtf(scale, ndp, d1, d2) Format for output a 2-part Julian Date (or in the case of UTC a quasi-JD form that includes special provision for leap seconds). Given scale : Time scale ID (Note 1) ndp : Resolution (Note 2) d1 ,  d2 : Time as a 2-part Julian Date (Notes 3,4) Returned iy ,  im ,  id : Year, month, day in Gregorian calendar (Note 5) ihmsf : Hours, minutes, seconds, fraction (Note 1) Notes scale identifies the time scale.  Only the value \"UTC\" (in upper case) is significant, and enables handling of leap seconds (see Note 4). ndp is the number of decimal places in the seconds field, and can have negative as well as positive values, such as: ndp resolution -4 1 00 00 -3 0 10 00 -2 0 01 00 -1 0 00 10 0 0 00 01 1 0 00 00.1 2 0 00 00.01 3 0 00 00.001 The limits are platform dependent, but a safe range is -5 to +9. d1+d2 is Julian Date, apportioned in any convenient way between the two arguments, for example where d1 is the Julian Day Number and d2 is the fraction of a day.  In the case of UTC, where the use of JD is problematical, special conventions apply:  see the next note. JD cannot unambiguously represent UTC during a leap second unless special measures are taken.  The ERFA internal convention is that the quasi-JD day represents UTC days whether the length is 86399, 86400 or 86401 SI seconds.  In the 1960-1972 era there were smaller jumps (in either direction) each time the linear UTC(TAI) expression was changed, and these \"mini-leaps\" are also included in the ERFA convention. The warning status \"dubious year\" flags UTCs that predate the introduction of the time scale or that are too far in the future to be trusted.  See  dat  for further details. For calendar conventions and limitations, see  cal2jd . Called jd2cal : JD to Gregorian calendar d2tf : decompose days to hms dat : delta(AT) = TAI-UTC source"},{"id":216,"pagetitle":"Functions","title":"ERFA.d2tf","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.d2tf-Tuple{Any, Any}","content":" ERFA.d2tf  —  Method d2tf(ndp, a) Decompose days to hours, minutes, seconds, fraction. Given ndp : Resolution (Note 1) days : Interval in days Returned sign : '+' or '-' ihmsf : Hours, minutes, seconds, fraction Notes The argument ndp is interpreted as follows: ndp resolution : ...0000 00 00 -7 1000 00 00 -6 100 00 00 -5 10 00 00 -4 1 00 00 -3 0 10 00 -2 0 01 00 -1 0 00 10 0 0 00 01 1 0 00 00.1 2 0 00 00.01 3 0 00 00.001 : 0 00 00.000... The largest positive useful value for ndp is determined by the size of days, the format of double on the target platform, and the risk of overflowing ihmsf[3].  On a typical platform, for days up to 1.0, the available floating-point precision might correspond to ndp=12.  However, the practical limit is typically ndp=9, set by the capacity of a 32-bit int, or ndp=4 if int is only 16 bits. The absolute value of days may exceed 1.0.  In cases where it does not, it is up to the caller to test for and handle the case where days is very nearly 1.0 and rounds up to 24 hours, by testing for ihmsf[0]=24 and setting ihmsf[0-3] to zero. source"},{"id":217,"pagetitle":"Functions","title":"ERFA.dat","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.dat-NTuple{4, Any}","content":" ERFA.dat  —  Method dat(iy, im, id, fd) For a given UTC date, calculate delta(AT) = TAI-UTC. IMPORTANT A new version of this function must be produced whenever a new leap second is announced.  There are four items to change on each such occasion: A new line must be added to the set  of statements that initialize the  array \"changes\". The constant IYV must be set to the  current year. The \"Latest leap second\" comment  below must be set to the new leap  second date. The \"This revision\" comment, later,  must be set to the current date. Change (2) must also be carried out whenever the function is re-issued, even if no leap seconds have been added. Latest leap second:  2016 December 31 Given iy : UTC:  year (Notes 1 and 2) im : Month (Note 2) id : Day (Notes 2 and 3) fd : Fraction of day (Note 4) Returned deltat : TAI minus UTC, seconds Notes UTC began at 1960 January 1.0 (JD 2436934.5) and it is improper to call the function with an earlier date.  If this is attempted, zero is returned together with a warning status. Because leap seconds cannot, in principle, be predicted in advance, a reliable check for dates beyond the valid range is impossible.  To guard against gross errors, a year five or more after the release year of the present function (see the constant IYV) is considered dubious.  In this case a warning status is returned but the result is computed in the normal way. For both too-early and too-late years, the warning status is +1. This is distinct from the error status -1, which signifies a year so early that JD could not be computed. If the specified date is for a day which ends with a leap second, the TAI-UTC value returned is for the period leading up to the leap second.  If the date is for a day which begins as a leap second ends, the TAI-UTC returned is for the period following the leap second. The day number must be in the normal calendar range, for example 1 through 30 for April.  The \"almanac\" convention of allowing such dates as January 0 and December 32 is not supported in this function, in order to avoid confusion near leap seconds. The fraction of day is used only for dates before the introduction of leap seconds, the first of which occurred at the end of 1971.  It is tested for validity (0 to 1 is the valid range) even if not used;  if invalid, zero is used and status -4 is returned.  For many applications, setting fd to zero is acceptable;  the resulting error is always less than 3 ms (and occurs only pre-1972). The status value returned in the case where there are multiple errors refers to the first error detected.  For example, if the month and day are 13 and 32 respectively, status -2 (bad month) will be returned.  The \"internal error\" status refers to a case that is impossible but causes some compilers to issue a warning. In cases where a valid result is not available, zero is returned. References For dates from 1961 January 1 onwards, the expressions from the file ftp://maia.usno.navy.mil/ser7/tai-utc.dat are used. The 5ms timestep at 1961 January 1 is taken from 2.58.1 (p87) of the 1992 Explanatory Supplement. Called cal2jd : Gregorian calendar to JD source"},{"id":218,"pagetitle":"Functions","title":"ERFA.dtdb","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.dtdb-NTuple{6, Any}","content":" ERFA.dtdb  —  Method dtdb(date1, date2, ut, elong, u, v) An approximation to TDB-TT, the difference between barycentric dynamical time and terrestrial time, for an observer on the Earth. The different time scales - proper, coordinate and realized - are related to each other:           TAI             <-  physically realized\n           :\n        offset            <-  observed (nominally +32.184s)\n           :\n          TT              <-  terrestrial time\n           :\n  rate adjustment (L_G)   <-  definition of TT\n           :\n          TCG             <-  time scale for GCRS\n           :\n    \"periodic\" terms      <-  [`dtdb`](@ref)  is an implementation\n           :\n  rate adjustment (L_C)   <-  function of solar-system ephemeris\n           :\n          TCB             <-  time scale for BCRS\n           :\n  rate adjustment (-L_B)  <-  definition of TDB\n           :\n          TDB             <-  TCB scaled to track TT\n           :\n    \"periodic\" terms      <-  -eraDtdb is an approximation\n           :\n          TT              <-  terrestrial time Adopted values for the various constants can be found in the IERS Conventions (McCarthy & Petit 2003). Given date1 ,  date2 : Date, TDB (Notes 1-3) ut : Universal time (UT1, fraction of one day) elong : Longitude (east positive, radians) u : Distance from Earth spin axis (km) v : Distance north of equatorial plane (km) Returned TDB-TT (seconds) Notes The date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. Although the date is, formally, barycentric dynamical time (TDB), the terrestrial dynamical time (TT) can be used with no practical effect on the accuracy of the prediction. TT can be regarded as a coordinate time that is realized as an offset of 32.184s from International Atomic Time, TAI.  TT is a specific linear transformation of geocentric coordinate time TCG, which is the time scale for the Geocentric Celestial Reference System, GCRS. TDB is a coordinate time, and is a specific linear transformation of barycentric coordinate time TCB, which is the time scale for the Barycentric Celestial Reference System, BCRS. The difference TCG-TCB depends on the masses and positions of the bodies of the solar system and the velocity of the Earth.  It is dominated by a rate difference, the residual being of a periodic character.  The latter, which is modeled by the present function, comprises a main (annual) sinusoidal term of amplitude approximately 0.00166 seconds, plus planetary terms up to about 20 microseconds, and lunar and diurnal terms up to 2 microseconds. These effects come from the changing transverse Doppler effect and gravitational red-shift as the observer (on the Earth's surface) experiences variations in speed (with respect to the BCRS) and gravitational potential. TDB can be regarded as the same as TCB but with a rate adjustment to keep it close to TT, which is convenient for many applications. The history of successive attempts to define TDB is set out in Resolution 3 adopted by the IAU General Assembly in 2006, which defines a fixed TDB(TCB) transformation that is consistent with contemporary solar-system ephemerides.  Future ephemerides will imply slightly changed transformations between TCG and TCB, which could introduce a linear drift between TDB and TT;  however, any such drift is unlikely to exceed 1 nanosecond per century. The geocentric TDB-TT model used in the present function is that of Fairhead & Bretagnon (1990), in its full form.  It was originally supplied by Fairhead (private communications with P.T.Wallace, 1990) as a Fortran subroutine.  The present C function contains an adaptation of the Fairhead code.  The numerical results are essentially unaffected by the changes, the differences with respect to the Fairhead & Bretagnon original being at the 1e-20 s level. The topocentric part of the model is from Moyer (1981) and Murray (1983), with fundamental arguments adapted from Simon et al. 1994.  It is an approximation to the expression ( v / c ) . ( r / c ), where v is the barycentric velocity of the Earth, r is the geocentric position of the observer and c is the speed of light. By supplying zeroes for u and v, the topocentric part of the model can be nullified, and the function will return the Fairhead & Bretagnon result alone. During the interval 1950-2050, the absolute accuracy is better than +/- 3 nanoseconds relative to time ephemerides obtained by direct numerical integrations based on the JPL DE405 solar system ephemeris. It must be stressed that the present function is merely a model, and that numerical integration of solar-system ephemerides is the definitive method for predicting the relationship between TCG and TCB and hence between TT and TDB. References Fairhead, L., & Bretagnon, P., Astron.Astrophys., 229, 240-247   (1990). IAU 2006 Resolution 3. McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Moyer, T.D., Cel.Mech., 23, 33 (1981). Murray, C.A., Vectorial Astrometry, Adam Hilger (1983). Seidelmann, P.K. et al., Explanatory Supplement to the   Astronomical Almanac, Chapter 2, University Science Books (1992). Simon, J.L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G. & Laskar, J., Astron.Astrophys., 282, 663-683 (1994). source"},{"id":219,"pagetitle":"Functions","title":"ERFA.dtf2d","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.dtf2d-Tuple{AbstractString, Vararg{Any, 6}}","content":" ERFA.dtf2d  —  Method dtf2d(scale, iy, imo, id, ih, imi, sec) Encode date and time fields into 2-part Julian Date (or in the case of UTC a quasi-JD form that includes special provision for leap seconds). Given scale : Time scale ID (Note 1) iy ,  im ,  id : Year, month, day in Gregorian calendar (Note 2) ihr ,  imn : Hour, minute sec : Seconds Returned d1 ,  d2 : 2-part Julian Date (Notes 3,4) Notes scale identifies the time scale.  Only the value \"UTC\" (in upper case) is significant, and enables handling of leap seconds (see Note 4). For calendar conventions and limitations, see  cal2jd . The sum of the results, d1+d2, is Julian Date, where normally d1 is the Julian Day Number and d2 is the fraction of a day.  In the case of UTC, where the use of JD is problematical, special conventions apply:  see the next note. JD cannot unambiguously represent UTC during a leap second unless special measures are taken.  The ERFA internal convention is that the quasi-JD day represents UTC days whether the length is 86399, 86400 or 86401 SI seconds.  In the 1960-1972 era there were smaller jumps (in either direction) each time the linear UTC(TAI) expression was changed, and these \"mini-leaps\" are also included in the ERFA convention. The warning status \"time is after end of day\" usually means that the sec argument is greater than 60.0.  However, in a day ending in a leap second the limit changes to 61.0 (or 59.0 in the case of a negative leap second). The warning status \"dubious year\" flags UTCs that predate the introduction of the time scale or that are too far in the future to be trusted.  See  dat  for further details. Only in the case of continuous and regular time scales (TAI, TT, TCG, TCB and TDB) is the result d1+d2 a Julian Date, strictly speaking.  In the other cases (UT1 and UTC) the result must be used with circumspection;  in particular the difference between two such results cannot be interpreted as a precise time interval. Called cal2jd : Gregorian calendar to JD dat : delta(AT) = TAI-UTC jd2cal : JD to Gregorian calendar source"},{"id":220,"pagetitle":"Functions","title":"ERFA.eceq06","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.eceq06","content":" ERFA.eceq06  —  Function eceq06(date1, date2, dl, db) Transformation from ecliptic coordinates (mean equinox and ecliptic of date) to ICRS RA,Dec, using the IAU 2006 precession model. Given date1 ,  date2 : TT as a 2-part Julian date (Note 1) dl ,  db : Ecliptic longitude and latitude (radians) Returned dr ,  dd : ICRS right ascension and declination (radians) The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. No assumptions are made about whether the coordinates represent starlight and embody astrometric effects such as parallax or aberration. The transformation is approximately that from ecliptic longitude and latitude (mean equinox and ecliptic of date) to mean J2000.0 right ascension and declination, with only frame bias (always less than 25 mas) to disturb this classical picture. Called s2c : spherical coordinates to unit vector ecm06 : J2000.0 to ecliptic rotation matrix, IAU 2006 trxp : product of transpose of r-matrix and p-vector c2s : unit vector to spherical coordinates anp : normalize angle into range 0 to 2pi anpm : normalize angle into range +/- pi source"},{"id":221,"pagetitle":"Functions","title":"ERFA.ecm06","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.ecm06-Tuple{Any, Any}","content":" ERFA.ecm06  —  Method ecm06(date1, date2) ICRS equatorial to ecliptic rotation matrix, IAU 2006. Given date1 ,  date2 : TT as a 2-part Julian date (Note 1) Returned rm : ICRS to ecliptic rotation matrix Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix is in the sense E_ep = rm x P_ICRS, where  P_ICRS  is a vector with respect to ICRS right ascension and declination axes and  E_ep  is the same vector with respect to the (inertial) ecliptic and equinox of date. P_ICRS  is a free vector, merely a direction, typically of unit magnitude, and not bound to any particular spatial origin, such as the Earth, Sun or SSB.  No assumptions are made about whether it represents starlight and embodies astrometric effects such as parallax or aberration.  The transformation is approximately that between mean J2000.0 right ascension and declination and ecliptic longitude and latitude, with only frame bias (always less than 25 mas) to disturb this classical picture. Called obl06 : mean obliquity, IAU 2006 pmat06 : PB matrix, IAU 2006 ir : initialize r-matrix to identity rx : rotate around X-axis rxr : product of two r-matrices source"},{"id":222,"pagetitle":"Functions","title":"ERFA.ee00","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.ee00-NTuple{4, Any}","content":" ERFA.ee00  —  Method ee00(date1, date2, epsa, dpsi) The equation of the equinoxes, compatible with IAU 2000 resolutions, given the nutation in longitude and the mean obliquity. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) epsa : Mean obliquity (Note 2) dpsi : Nutation in longitude (Note 3) Returned Equation of the equinoxes (Note 4) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The obliquity, in radians, is mean of date. The result, which is in radians, operates in the following sense: Greenwich apparent ST = GMST + equation of the equinoxes The result is compatible with the IAU 2000 resolutions.  For further details, see IERS Conventions 2003 and Capitaine et al. (2002). Called eect00 : equation of the equinoxes complementary terms References Capitaine, N., Wallace, P.T. and McCarthy, D.D., \"Expressions to   implement the IAU 2000 definition of UT1\", Astronomy &   Astrophysics, 406, 1135-1149 (2003) McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":223,"pagetitle":"Functions","title":"ERFA.ee00a","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.ee00a","content":" ERFA.ee00a  —  Function ee00a(dj1, dj2) Equation of the equinoxes, compatible with IAU 2000 resolutions. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned Equation of the equinoxes (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The result, which is in radians, operates in the following sense: Greenwich apparent ST = GMST + equation of the equinoxes The result is compatible with the IAU 2000 resolutions.  For further details, see IERS Conventions 2003 and Capitaine et al. (2002). Called pr00 : IAU 2000 precession adjustments obl80 : mean obliquity, IAU 1980 nut00a : nutation, IAU 2000A ee00 : equation of the equinoxes, IAU 2000 References Capitaine, N., Wallace, P.T. and McCarthy, D.D., \"Expressions to   implement the IAU 2000 definition of UT1\", Astronomy &   Astrophysics, 406, 1135-1149 (2003). McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004). source"},{"id":224,"pagetitle":"Functions","title":"ERFA.ee00b","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.ee00b","content":" ERFA.ee00b  —  Function ee00b(dj1, dj2) Equation of the equinoxes, compatible with IAU 2000 resolutions but using the truncated nutation model IAU 2000B. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned Equation of the equinoxes (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The result, which is in radians, operates in the following sense: Greenwich apparent ST = GMST + equation of the equinoxes The result is compatible with the IAU 2000 resolutions except that accuracy has been compromised for the sake of speed.  For further details, see McCarthy & Luzum (2001), IERS Conventions 2003 and Capitaine et al. (2003). Called pr00 : IAU 2000 precession adjustments obl80 : mean obliquity, IAU 1980 nut00b : nutation, IAU 2000B ee00 : equation of the equinoxes, IAU 2000 References Capitaine, N., Wallace, P.T. and McCarthy, D.D., \"Expressions to   implement the IAU 2000 definition of UT1\", Astronomy &   Astrophysics, 406, 1135-1149 (2003) McCarthy, D.D. & Luzum, B.J., \"An abridged model of the   precession-nutation of the celestial pole\", Celestial Mechanics &   Dynamical Astronomy, 85, 37-49 (2003) McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":225,"pagetitle":"Functions","title":"ERFA.ee06a","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.ee06a","content":" ERFA.ee06a  —  Function ee06a(dj1, dj2) Equation of the equinoxes, compatible with IAU 2000 resolutions and IAU 2006/2000A precession-nutation. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned Equation of the equinoxes (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The result, which is in radians, operates in the following sense: Greenwich apparent ST = GMST + equation of the equinoxes Called anpm : normalize angle into range +/- pi gst06a : Greenwich apparent sidereal time, IAU 2006/2000A gmst06 : Greenwich mean sidereal time, IAU 2006 Reference McCarthy, D. D., Petit, G. (eds.), 2004, IERS Conventions (2003),   IERS Technical Note No. 32, BKG source"},{"id":226,"pagetitle":"Functions","title":"ERFA.eect00","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.eect00","content":" ERFA.eect00  —  Function eect00(date1, date2) Equation of the equinoxes complementary terms, consistent with IAU 2000 resolutions. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned Complementary terms (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The \"complementary terms\" are part of the equation of the equinoxes (EE), classically the difference between apparent and mean Sidereal Time: GAST = GMST + EE with: EE = dpsi * cos(eps) where dpsi is the nutation in longitude and eps is the obliquity of date.  However, if the rotation of the Earth were constant in an inertial frame the classical formulation would lead to apparent irregularities in the UT1 timescale traceable to side- effects of precession-nutation.  In order to eliminate these effects from UT1, \"complementary terms\" were introduced in 1994 (IAU, 1994) and took effect from 1997 (Capitaine and Gontier, 1993): GAST = GMST + CT + EE By convention, the complementary terms are included as part of the equation of the equinoxes rather than as part of the mean Sidereal Time.  This slightly compromises the \"geometrical\" interpretation of mean sidereal time but is otherwise inconsequential. The present function computes CT in the above expression, compatible with IAU 2000 resolutions (Capitaine et al., 2002, and IERS Conventions 2003). Called fal03 : mean anomaly of the Moon falp03 : mean anomaly of the Sun faf03 : mean argument of the latitude of the Moon fad03 : mean elongation of the Moon from the Sun faom03 : mean longitude of the Moon's ascending node fave03 : mean longitude of Venus fae03 : mean longitude of Earth fapa03 : general accumulated precession in longitude References Capitaine, N. & Gontier, A.-M., Astron. Astrophys., 275,   645-650 (1993) Capitaine, N., Wallace, P.T. and McCarthy, D.D., \"Expressions to   implement the IAU 2000 definition of UT1\", Astronomy &   Astrophysics, 406, 1135-1149 (2003) IAU Resolution C7, Recommendation 3 (1994) McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":227,"pagetitle":"Functions","title":"ERFA.eform","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.eform-Tuple{ERFA.Ellipsoid}","content":" ERFA.eform  —  Method eform(n::Ellipsoid) Earth reference ellipsoids. Given n : Ellipsoid identifier (Note 1) Returned a : Equatorial radius (meters, Note 2) f : Flattening (Note 2) Notes The identifier n is a number that specifies the choice of reference ellipsoid.  The following are supported: WGS84 GRS80 WGS72 The ellipsoid parameters are returned in the form of equatorial radius in meters (a) and flattening (f).  The latter is a number around 0.00335, i.e. around 1/298. For the case where an unsupported n value is supplied, zero a and f are returned, as well as error status. References Department of Defense World Geodetic System 1984, National   Imagery and Mapping Agency Technical Report 8350.2, Third   Edition, p3-2. Moritz, H., Bull. Geodesique 66-2, 187 (1992). The Department of Defense World Geodetic System 1972, World   Geodetic System Committee, May 1974. Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992),   p220. source"},{"id":228,"pagetitle":"Functions","title":"ERFA.eo06a","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.eo06a","content":" ERFA.eo06a  —  Function eo06a(date1, date2) Equation of the origins, IAU 2006 precession and IAU 2000A nutation. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned Equation of the origins in radians Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The equation of the origins is the distance between the true equinox and the celestial intermediate origin and, equivalently, the difference between Earth rotation angle and Greenwich apparent sidereal time (ERA-GST).  It comprises the precession (since J2000.0) in right ascension plus the equation of the equinoxes (including the small correction terms). Called pnm06a : classical NPB matrix, IAU 2006/2000A bpn2xy : extract CIP X,Y coordinates from NPB matrix s06 : the CIO locator s, given X,Y, IAU 2006 eors : equation of the origins, given NPB matrix and s References Capitaine, N. & Wallace, P.T., 2006, Astron.Astrophys. 450, 855 Wallace, P.T. & Capitaine, N., 2006, Astron.Astrophys. 459, 981 source"},{"id":229,"pagetitle":"Functions","title":"ERFA.eors","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.eors-Tuple{Any, Any}","content":" ERFA.eors  —  Method eors(rnpb, s) Equation of the origins, given the classical NPB matrix and the quantity s. Given rnpb : Classical nutation x precession x bias matrix s : The quantity s (the CIO locator) Returned The equation of the origins in radians. Notes The equation of the origins is the distance between the true  equinox and the celestial intermediate origin and, equivalently,  the difference between Earth rotation angle and Greenwich  apparent sidereal time (ERA-GST).  It comprises the precession  (since J2000.0) in right ascension plus the equation of the  equinoxes (including the small correction terms). The algorithm is from Wallace & Capitaine (2006). References Capitaine, N. & Wallace, P.T., 2006, Astron.Astrophys. 450, 855 Wallace, P. & Capitaine, N., 2006, Astron.Astrophys. 459, 981 source"},{"id":230,"pagetitle":"Functions","title":"ERFA.epb","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.epb","content":" ERFA.epb  —  Function epb(dj1, dj2) Julian Date to Besselian Epoch. Given dj1 ,  dj2 : Julian Date (see note) Returned Besselian Epoch. Note The Julian Date is supplied in two pieces, in the usual ERFA    manner, which is designed to preserve time resolution.  The    Julian Date is available as a single number by adding dj1 and    dj2.  The maximum resolution is achieved if dj1 is 2451545.0    (J2000.0). Reference Lieske, J.H., 1979. Astron.Astrophys., 73, 282. source"},{"id":231,"pagetitle":"Functions","title":"ERFA.epb2jd","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.epb2jd","content":" ERFA.epb2jd  —  Function epb2jd(epj) Besselian Epoch to Julian Date. Given epb : Besselian Epoch (e.g. 1957.3) Returned djm0 : MJD zero-point: always 2400000.5 djm : Modified Julian Date Note The Julian Date is returned in two pieces, in the usual ERFA    manner, which is designed to preserve time resolution.  The    Julian Date is available as a single number by adding djm0 and    djm. Reference Lieske, J.H., 1979, Astron.Astrophys. 73, 282. source"},{"id":232,"pagetitle":"Functions","title":"ERFA.epj","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.epj","content":" ERFA.epj  —  Function epj(dj1, dj2) Julian Date to Julian Epoch. Given dj1 ,  dj2 : Julian Date (see note) Returned Julian Epoch Note The Julian Date is supplied in two pieces, in the usual ERFA    manner, which is designed to preserve time resolution.  The    Julian Date is available as a single number by adding dj1 and    dj2.  The maximum resolution is achieved if dj1 is 2451545.0    (J2000.0). Reference Lieske, J.H., 1979, Astron.Astrophys. 73, 282. source"},{"id":233,"pagetitle":"Functions","title":"ERFA.epj2jd","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.epj2jd","content":" ERFA.epj2jd  —  Function epj2jd(epj) Julian Epoch to Julian Date. Given epj : Julian Epoch (e.g. 1996.8) Returned djm0 : MJD zero-point: always 2400000.5 djm : Modified Julian Date Note The Julian Date is returned in two pieces, in the usual ERFA    manner, which is designed to preserve time resolution.  The    Julian Date is available as a single number by adding djm0 and    djm. Reference Lieske, J.H., 1979, Astron.Astrophys. 73, 282. source"},{"id":234,"pagetitle":"Functions","title":"ERFA.epv00","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.epv00-Tuple{Any, Any}","content":" ERFA.epv00  —  Method epv00(date1, date2) Earth position and velocity, heliocentric and barycentric, with respect to the Barycentric Celestial Reference System. Given date1 ,  date2 : TDB date (Note 1) Returned pvh : Heliocentric Earth position/velocity pvb : Barycentric Earth position/velocity Notes The TDB date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TDB)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience.  However, the accuracy of the result is more likely to be limited by the algorithm itself than the way the date has been expressed. n.b. TT can be used instead of TDB in most applications. On return, the arrays pvh and pvb contain the following: pvh[0][0]  x       }\npvh[0][1]  y       } heliocentric position, au\npvh[0][2]  z       }\n\npvh[1][0]  xdot    }\npvh[1][1]  ydot    } heliocentric velocity, au/d\npvh[1][2]  zdot    }\n\npvb[0][0]  x       }\npvb[0][1]  y       } barycentric position, au\npvb[0][2]  z       }\n\npvb[1][0]  xdot    }\npvb[1][1]  ydot    } barycentric velocity, au/d\npvb[1][2]  zdot    } The vectors are with respect to the Barycentric Celestial Reference System.  The time unit is one day in TDB. The function is a SIMPLIFIED SOLUTION from the planetary theory VSOP2000 (X. Moisson, P. Bretagnon, 2001, Celes. Mechanics & Dyn. Astron., 80, 3/4, 205-213) and is an adaptation of original Fortran code supplied by P. Bretagnon (private comm., 2000). Comparisons over the time span 1900-2100 with this simplified solution and the JPL DE405 ephemeris give the following results:                       RMS    max\nHeliocentric:\n    position error    3.7   11.2   km\n    velocity error    1.4    5.0   mm/s\n\nBarycentric:\n    position error    4.6   13.4   km\n    velocity error    1.4    4.9   mm/s Comparisons with the JPL DE406 ephemeris show that by 1800 and 2200 the position errors are approximately double their 1900-2100 size.  By 1500 and 2500 the deterioration is a factor of 10 and by 1000 and 3000 a factor of 60.  The velocity accuracy falls off at about half that rate. It is permissible to use the same array for pvh and pvb, which will receive the barycentric values. source"},{"id":235,"pagetitle":"Functions","title":"ERFA.eqec06","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.eqec06","content":" ERFA.eqec06  —  Function eqec06(date1, date2, dr, dd) Transformation from ICRS equatorial coordinates to ecliptic coordinates (mean equinox and ecliptic of date) using IAU 2006 precession model. Given date1 ,  date2 : TT as a 2-part Julian date (Note 1) dr ,  dd : ICRS right ascension and declination (radians) Returned dl ,  db : Ecliptic longitude and latitude (radians) The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. No assumptions are made about whether the coordinates represent starlight and embody astrometric effects such as parallax or aberration. The transformation is approximately that from mean J2000.0 right ascension and declination to ecliptic longitude and latitude (mean equinox and ecliptic of date), with only frame bias (always less than 25 mas) to disturb this classical picture. Called s2c : spherical coordinates to unit vector ecm06 : J2000.0 to ecliptic rotation matrix, IAU 2006 rxp : product of r-matrix and p-vector c2s : unit vector to spherical coordinates anp : normalize angle into range 0 to 2pi anpm : normalize angle into range +/- pi source"},{"id":236,"pagetitle":"Functions","title":"ERFA.eqeq94","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.eqeq94","content":" ERFA.eqeq94  —  Function eqeq94(date1, date2) Equation of the equinoxes, IAU 1994 model. Given date1 ,  date2 : TDB date (Note 1) Returned Equation of the equinoxes (Note 2) Notes The date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The result, which is in radians, operates in the following sense: Greenwich apparent ST = GMST + equation of the equinoxes Called anpm : normalize angle into range +/- pi nut80 : nutation, IAU 1980 obl80 : mean obliquity, IAU 1980 References IAU Resolution C7, Recommendation 3 (1994). Capitaine, N. & Gontier, A.-M., 1993, Astron. Astrophys., 275,   645-650. source"},{"id":237,"pagetitle":"Functions","title":"ERFA.era00","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.era00","content":" ERFA.era00  —  Function era00(dj1, dj2) Earth rotation angle (IAU 2000 model). Given dj1 ,  dj2 : UT1 as a 2-part Julian Date (see note) Returned Earth rotation angle (radians), range 0-2pi Notes The UT1 date dj1+dj2 is a Julian Date, apportioned in any convenient way between the arguments dj1 and dj2.  For example, JD(UT1)=2450123.7 could be expressed in any of these ways, among others: dj1 dj2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 and MJD methods are good compromises between resolution and convenience.  The date & time method is best matched to the algorithm used:  maximum precision is delivered when the dj1 argument is for 0hrs UT1 on the day in question and the dj2 argument lies in the range 0 to 1, or vice versa. The algorithm is adapted from Expression 22 of Capitaine et al. 2000. The time argument has been expressed in days directly, and, to retain precision, integer contributions have been eliminated.  The same formulation is given in IERS Conventions (2003), Chap. 5, Eq. 14. Called anp : normalize angle into range 0 to 2pi References Capitaine N., Guinot B. and McCarthy D.D, 2000, Astron.   Astrophys., 355, 398-405. McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":238,"pagetitle":"Functions","title":"ERFA.erfa_cp","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.erfa_cp","content":" ERFA.erfa_cp  —  Function erfa_cp(p) Copy a p-vector. Deprecated Use  Base.copy  instead. Given p : p-vector to be copied Returned c : copy source"},{"id":239,"pagetitle":"Functions","title":"ERFA.fad03","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.fad03","content":" ERFA.fad03  —  Function fad03(t) Fundamental argument, IERS Conventions (2003): mean elongation of the Moon from the Sun. Given t : TDB, Julian centuries since J2000.0 (Note 1) Returned D , radians (Note 2) Notes Though t is strictly TDB, it is usually more convenient to use TT, which makes no significant difference. The expression used is as adopted in IERS Conventions (2003) and is from Simon et al. (1994). References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683 source"},{"id":240,"pagetitle":"Functions","title":"ERFA.fae03","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.fae03","content":" ERFA.fae03  —  Function fae03(t) Fundamental argument, IERS Conventions (2003): Mean longitude of Earth. Given t : TDB, Julian centuries since J2000.0 (Note 1) Returned Mean longitude of Earth, radians (Note 2) Notes Though t is strictly TDB, it is usually more convenient to use TT, which makes no significant difference. The expression used is as adopted in IERS Conventions (2003) and comes from Souchay et al. (1999) after Simon et al. (1994). References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683 Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M. 1999,   Astron.Astrophys.Supp.Ser. 135, 111 source"},{"id":241,"pagetitle":"Functions","title":"ERFA.faf03","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.faf03","content":" ERFA.faf03  —  Function faf03(t) Fundamental argument, IERS Conventions (2003): Mean longitude of the Moon minus mean longitude of the ascending node. Given t : TDB, Julian centuries since J2000.0 (Note 1) Returned F , radians (Note 2) Notes Though t is strictly TDB, it is usually more convenient to use TT, which makes no significant difference. The expression used is as adopted in IERS Conventions (2003) and is from Simon et al. (1994). References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683 source"},{"id":242,"pagetitle":"Functions","title":"ERFA.faju03","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.faju03","content":" ERFA.faju03  —  Function faju03(t) Fundamental argument, IERS Conventions (2003): Mean longitude of Jupiter. Given t : TDB, Julian centuries since J2000.0 (Note 1) Returned Mean longitude of Jupiter, radians (Note 2) Notes Though t is strictly TDB, it is usually more convenient to use TT, which makes no significant difference. The expression used is as adopted in IERS Conventions (2003) and comes from Souchay et al. (1999) after Simon et al. (1994). References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683 Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M. 1999,   Astron.Astrophys.Supp.Ser. 135, 111 source"},{"id":243,"pagetitle":"Functions","title":"ERFA.fal03","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.fal03","content":" ERFA.fal03  —  Function fal03(t) Fundamental argument, IERS Conventions (2003): mean anomaly of the Moon. Given t : TDB, Julian centuries since J2000.0 (Note 1) Returned l , radians (Note 2) Notes Though t is strictly TDB, it is usually more convenient to use TT, which makes no significant difference. The expression used is as adopted in IERS Conventions (2003) and is from Simon et al. (1994). References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683 source"},{"id":244,"pagetitle":"Functions","title":"ERFA.falp03","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.falp03","content":" ERFA.falp03  —  Function falp03(t) Fundamental argument, IERS Conventions (2003): mean anomaly of the Sun. Given t : TDB, Julian centuries since J2000.0 (Note 1) Returned l' , radians (Note 2) Notes Though t is strictly TDB, it is usually more convenient to use TT, which makes no significant difference. The expression used is as adopted in IERS Conventions (2003) and is from Simon et al. (1994). References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683 source"},{"id":245,"pagetitle":"Functions","title":"ERFA.fama03","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.fama03","content":" ERFA.fama03  —  Function fama03(t) Fundamental argument, IERS Conventions (2003): Mean longitude of Mars. Given t : TDB, Julian centuries since J2000.0 (Note 1) Returned Mean longitude of Mars, radians (Note 2) Notes Though t is strictly TDB, it is usually more convenient to use TT, which makes no significant difference. The expression used is as adopted in IERS Conventions (2003) and comes from Souchay et al. (1999) after Simon et al. (1994). References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683 Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M. 1999,   Astron.Astrophys.Supp.Ser. 135, 111 source"},{"id":246,"pagetitle":"Functions","title":"ERFA.fame03","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.fame03","content":" ERFA.fame03  —  Function fame03(t) Fundamental argument, IERS Conventions (2003): Mean longitude of Mercury. Given t : TDB, Julian centuries since J2000.0 (Note 1) Returned Mean longitude of Mercury, radians (Note 2) Notes Though t is strictly TDB, it is usually more convenient to use TT, which makes no significant difference. The expression used is as adopted in IERS Conventions (2003) and comes from Souchay et al. (1999) after Simon et al. (1994). References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683 Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M. 1999,   Astron.Astrophys.Supp.Ser. 135, 111 source"},{"id":247,"pagetitle":"Functions","title":"ERFA.fane03","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.fane03","content":" ERFA.fane03  —  Function fane03(t) Fundamental argument, IERS Conventions (2003): Mean longitude of Neptune. Given t : TDB, Julian centuries since J2000.0 (Note 1) Returned Mean longitude of Neptune, radians (Note 2) Notes Though t is strictly TDB, it is usually more convenient to use TT, which makes no significant difference. The expression used is as adopted in IERS Conventions (2003) and is adapted from Simon et al. (1994). References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683 source"},{"id":248,"pagetitle":"Functions","title":"ERFA.faom03","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.faom03","content":" ERFA.faom03  —  Function faom03(t) Fundamental argument, IERS Conventions (2003): Mean longitude of the Moon's ascending node. Given t : TDB, Julian centuries since J2000.0 (Note 1) Returned Omega , radians (Note 2) Notes Though t is strictly TDB, it is usually more convenient to use TT, which makes no significant difference. The expression used is as adopted in IERS Conventions (2003) and is from Simon et al. (1994). References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683 source"},{"id":249,"pagetitle":"Functions","title":"ERFA.fapa03","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.fapa03","content":" ERFA.fapa03  —  Function fapa03(t) Fundamental argument, IERS Conventions (2003): general accumulated precession in longitude. Given t : TDB, Julian centuries since J2000.0 (Note 1) Returned General precession in longitude, radians (Note 2) Notes Though t is strictly TDB, it is usually more convenient to use TT, which makes no significant difference. The expression used is as adopted in IERS Conventions (2003).  It is taken from Kinoshita & Souchay (1990) and comes originally from Lieske et al. (1977). References Kinoshita, H. and Souchay J. 1990, Celest.Mech. and Dyn.Astron.   48, 187 Lieske, J.H., Lederle, T., Fricke, W. & Morando, B. 1977,   Astron.Astrophys. 58, 1-16 McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":250,"pagetitle":"Functions","title":"ERFA.fasa03","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.fasa03","content":" ERFA.fasa03  —  Function fasa03(t) Fundamental argument, IERS Conventions (2003): Mean longitude of Saturn. Given t : TDB, Julian centuries since J2000.0 (Note 1) Returned Mean longitude of Saturn, radians (Note 2) Notes Though t is strictly TDB, it is usually more convenient to use TT, which makes no significant difference. The expression used is as adopted in IERS Conventions (2003) and comes from Souchay et al. (1999) after Simon et al. (1994). References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683 Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M. 1999,   Astron.Astrophys.Supp.Ser. 135, 111 source"},{"id":251,"pagetitle":"Functions","title":"ERFA.faur03","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.faur03","content":" ERFA.faur03  —  Function faur03(t) Fundamental argument, IERS Conventions (2003): Mean longitude of Uranus. Given t : TDB, Julian centuries since J2000.0 (Note 1) Returned Mean longitude of Uranus, radians (Note 2) Notes Though t is strictly TDB, it is usually more convenient to use TT, which makes no significant difference. The expression used is as adopted in IERS Conventions (2003) and is adapted from Simon et al. (1994). References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683 source"},{"id":252,"pagetitle":"Functions","title":"ERFA.fave03","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.fave03","content":" ERFA.fave03  —  Function fave03(t) Fundamental argument, IERS Conventions (2003): Mean longitude of Venus. Given t : TDB, Julian centuries since J2000.0 (Note 1) Returned Mean longitude of Venus, radians (Note 2) Notes Though t is strictly TDB, it is usually more convenient to use TT, which makes no significant difference. The expression used is as adopted in IERS Conventions (2003) and comes from Souchay et al. (1999) after Simon et al. (1994). References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683 Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M. 1999,   Astron.Astrophys.Supp.Ser. 135, 111 source"},{"id":253,"pagetitle":"Functions","title":"ERFA.fk425","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.fk425-NTuple{6, Any}","content":" ERFA.fk425  —  Method fk425(r1950, d1950, dr1950, dd1950, p1950, v1950) Convert B1950.0 FK4 star catalog data to J2000.0 FK5. This function converts a star's catalog data from the old FK4 Bessel-Newcomb) system to the later IAU 1976 FK5 (Fricke) system. Given (all B1950.0, FK4) r1950,d1950 : B1950.0 RA,Dec (rad) dr1950,dd1950 : B1950.0 proper motions (rad/trop.yr) p1950 : Parallax (arcsec) v1950 : Radial velocity (km/s, +ve = moving away) Returned (all J2000.0, FK5) r2000,d2000 : J2000.0 RA,Dec (rad) dr2000,dd2000 : J2000.0 proper motions (rad/Jul.yr) p2000 : Parallax (arcsec) v2000 : Radial velocity (km/s, +ve = moving away) Notes The proper motions in RA are dRA/dt rather than cos(Dec)*dRA/dt, and are per year rather than per century. The conversion is somewhat complicated, for several reasons: Change of standard epoch from B1950.0 to J2000.0. An intermediate transition date of 1984 January 1.0 TT. A change of precession model. Change of time unit for proper motion (tropical to Julian). FK4 positions include the E-terms of aberration, to simplify the hand computation of annual aberration.  FK5 positions assume a rigorous aberration computation based on the Earth's barycentric velocity. The E-terms also affect proper motions, and in particular cause objects at large distances to exhibit fictitious proper motions. The algorithm is based on Smith et al. (1989) and Yallop et al. (1989), which presented a matrix method due to Standish (1982) as developed by Aoki et al. (1983), using Kinoshita's development of Andoyer's post-Newcomb precession.  The numerical constants from Seidelmann (1992) are used canonically. Conversion from B1950.0 FK4 to J2000.0 FK5 only is provided for. Conversions for different epochs and equinoxes would require additional treatment for precession, proper motion and E-terms. In the FK4 catalog the proper motions of stars within 10 degrees of the poles do not embody differential E-terms effects and should, strictly speaking, be handled in a different manner from stars outside these regions.  However, given the general lack of homogeneity of the star data available for routine astrometry, the difficulties of handling positions that may have been determined from astrometric fields spanning the polar and non- polar regions, the likelihood that the differential E-terms effect was not taken into account when allowing for proper motion in past astrometry, and the undesirability of a discontinuity in the algorithm, the decision has been made in this ERFA algorithm to include the effects of differential E-terms on the proper motions for all stars, whether polar or not.  At epoch J2000.0, and measuring \"on the sky\" rather than in terms of RA change, the errors resulting from this simplification are less than 1 milliarcsecond in position and 1 milliarcsecond per century in proper motion. Called anp : normalize angle into range 0 to 2pi pv2s : pv-vector to spherical coordinates pdp : scalar product of two p-vectors pvmpv : pv-vector minus pv_vector pvppv : pv-vector plus pv_vector s2pv : spherical coordinates to pv-vector sxp : multiply p-vector by scalar References Aoki, S. et al., 1983, \"Conversion matrix of epoch B1950.0 FK4-based positions of stars to epoch J2000.0 positions in accordance with the new IAU resolutions\".  Astron.Astrophys. 128, 263-267. Seidelmann, P.K. (ed), 1992, \"Explanatory Supplement to the Astronomical Almanac\", ISBN 0-935702-68-7. Smith, C.A. et al., 1989, \"The transformation of astrometric catalog systems to the equinox J2000.0\".  Astron.J. 97, 265. Standish, E.M., 1982, \"Conversion of positions and proper motions from B1950.0 to the IAU system at J2000.0\".  Astron.Astrophys., 115, 1, 20-22. Yallop, B.D. et al., 1989, \"Transformation of mean star places from FK4 B1950.0 to FK5 J2000.0 using matrices in 6-space\". Astron.J. 97, 274. source"},{"id":254,"pagetitle":"Functions","title":"ERFA.fk45z","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.fk45z-Tuple{Any, Any, Any}","content":" ERFA.fk45z  —  Method fk45z(r1950, d1950, bepoch) Convert a B1950.0 FK4 star position to J2000.0 FK5, assuming zero proper motion in the FK5 system. This function converts a star's catalog data from the old FK4 (Bessel-Newcomb) system to the later IAU 1976 FK5 (Fricke) system, in such a way that the FK5 proper motion is zero.  Because such a star has, in general, a non-zero proper motion in the FK4 system, the function requires the epoch at which the position in the FK4 system was determined. Given r1950 ,  d1950 : B1950.0 FK4 RA,Dec at epoch (rad) bepoch : Besselian epoch (e.g. 1979.3) Returned r2000 ,  d2000 : J2000.0 FK5 RA,Dec (rad) Notes The epoch bepoch is strictly speaking Beselian, but if a Julian epoch is supplied the result will be affected only to a negligible extent. The method is from Appendix 2 of Aoki et al. (1983), but using the constants of Seidelmann (1992).  See the function eraFk425 for a general introduction to the FK4 to FK5 conversion. Conversion from equinox B1950.0 FK4 to equinox J2000.0 FK5 only is provided for.  Conversions for different starting and/or ending epochs would require additional treatment for precession, proper motion and E-terms. In the FK4 catalog the proper motions of stars within 10 degrees of the poles do not embody differential E-terms effects and should, strictly speaking, be handled in a different manner from stars outside these regions.  However, given the general lack of homogeneity of the star data available for routine astrometry, the difficulties of handling positions that may have been determined from astrometric fields spanning the polar and non- polar regions, the likelihood that the differential E-terms effect was not taken into account when allowing for proper motion in past astrometry, and the undesirability of a discontinuity in the algorithm, the decision has been made in this ERFA algorithm to include the effects of differential E-terms on the proper motions for all stars, whether polar or not.  At epoch 2000.0, and measuring \"on the sky\" rather than in terms of RA change, the errors resulting from this simplification are less than 1 milliarcsecond in position and 1 milliarcsecond per century in proper motion. References Aoki, S. et al., 1983, \"Conversion matrix of epoch B1950.0 FK4-based positions of stars to epoch J2000.0 positions in accordance with the new IAU resolutions\".  Astron.Astrophys. 128, 263-267. Seidelmann, P.K. (ed), 1992, \"Explanatory Supplement to the Astronomical Almanac\", ISBN 0-935702-68-7. Called anp : normalize angle into range 0 to 2pi c2s : p-vector to spherical epb2jd : Besselian epoch to Julian date epj : Julian date to Julian epoch pdp : scalar product of two p-vectors pmp : p-vector minus p-vector ppsp : p-vector plus scaled p-vector pvu : update a pv-vector s2c : spherical to p-vectors source"},{"id":255,"pagetitle":"Functions","title":"ERFA.fk524","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.fk524-NTuple{6, Any}","content":" ERFA.fk524  —  Method function fk524(r2000, d2000, dr2000, dd2000, p2000, v2000) Convert J2000.0 FK5 star catalog data to B1950.0 FK4. Given (all J2000.0, FK5) r2000 ,  d2000 : J2000.0 RA,Dec (rad) dr2000 ,  dd2000 : J2000.0 proper motions (rad/Jul.yr) p2000 : parallax (arcsec) v2000 : radial velocity (km/s, +ve = moving away) Returned (all B1950.0, FK4) r1950 ,  d1950 : B1950.0 RA,Dec (rad) dr1950 ,  dd1950 : B1950.0 proper motions (rad/trop.yr) p1950 : parallax (arcsec) v1950 : radial velocity (km/s, +ve = moving away) Notes The proper motions in RA are dRA/dt rather than cos(Dec)*dRA/dt, and are per year rather than per century. The conversion is somewhat complicated, for several reasons: Change of standard epoch from J2000.0 to B1950.0. An intermediate transition date of 1984 January 1.0 TT. A change of precession model. Change of time unit for proper motion (Julian to tropical). FK4 positions include the E-terms of aberration, to simplify the hand computation of annual aberration.  FK5 positions assume a rigorous aberration computation based on the Earth's barycentric velocity. The E-terms also affect proper motions, and in particular cause objects at large distances to exhibit fictitious proper motions. The algorithm is based on Smith et al. (1989) and Yallop et al. (1989), which presented a matrix method due to Standish (1982) as developed by Aoki et al. (1983), using Kinoshita's development of Andoyer's post-Newcomb precession.  The numerical constants from Seidelmann (1992) are used canonically. In the FK4 catalog the proper motions of stars within 10 degrees of the poles do not embody differential E-terms effects and should, strictly speaking, be handled in a different manner from stars outside these regions.  However, given the general lack of homogeneity of the star data available for routine astrometry, the difficulties of handling positions that may have been determined from astrometric fields spanning the polar and non- polar regions, the likelihood that the differential E-terms effect was not taken into account when allowing for proper motion in past astrometry, and the undesirability of a discontinuity in the algorithm, the decision has been made in this ERFA algorithm to include the effects of differential E-terms on the proper motions for all stars, whether polar or not.  At epoch J2000.0, and measuring \"on the sky\" rather than in terms of RA change, the errors resulting from this simplification are less than 1 milliarcsecond in position and 1 milliarcsecond per century in proper motion. Called anp : normalize angle into range 0 to 2pi pdp : scalar product of two p-vectors pm : modulus of p-vector pmp : p-vector minus p-vector ppp : p-vector plus p-vector pv2s : pv-vector to spherical coordinates s2pv : spherical coordinates to pv-vector sxp : multiply p-vector by scalar References Aoki, S. et al., 1983, \"Conversion matrix of epoch B1950.0 FK4-based positions of stars to epoch J2000.0 positions in accordance with the new IAU resolutions\".  Astron.Astrophys. 128, 263-267. Seidelmann, P.K. (ed), 1992, \"Explanatory Supplement to the Astronomical Almanac\", ISBN 0-935702-68-7. Smith, C.A. et al., 1989, \"The transformation of astrometric catalog systems to the equinox J2000.0\".  Astron.J. 97, 265. Standish, E.M., 1982, \"Conversion of positions and proper motions from B1950.0 to the IAU system at J2000.0\".  Astron.Astrophys., 115, 1, 20-22. Yallop, B.D. et al., 1989, \"Transformation of mean star places from FK4 B1950.0 to FK5 J2000.0 using matrices in 6-space\". Astron.J. 97, 274. source"},{"id":256,"pagetitle":"Functions","title":"ERFA.fk52h","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.fk52h-NTuple{6, Any}","content":" ERFA.fk52h  —  Method fk52h(ra, dec, dra, ddec, px, rv) Transform FK5 (J2000.0) star data into the Hipparcos system. Given (all FK5, equinox J2000.0, epoch J2000.0) r5 : RA (radians) d5 : Dec (radians) dr5 : Proper motion in RA (dRA/dt, rad/Jyear) dd5 : Proper motion in Dec (dDec/dt, rad/Jyear) px5 : Parallax (arcsec) rv5 : Radial velocity (km/s, positive = receding) Returned (all Hipparcos, epoch J2000.0) rh : RA (radians) dh : Dec (radians) drh : proper motion in RA (dRA/dt, rad/Jyear) ddh : proper motion in Dec (dDec/dt, rad/Jyear) pxh : parallax (arcsec) rvh : radial velocity (km/s, positive = receding) Notes This function transforms FK5 star positions and proper motions into the system of the Hipparcos catalog. The proper motions in RA are dRA/dt rather than cos(Dec)*dRA/dt, and are per year rather than per century. The FK5 to Hipparcos transformation is modeled as a pure rotation and spin;  zonal errors in the FK5 catalog are not taken into account. See also  h2fk5 ,  fk5hz ,  hfk5z . Called starpv : star catalog data to space motion pv-vector fk5hip : FK5 to Hipparcos rotation and spin rxp : product of r-matrix and p-vector pxp : vector product of two p-vectors ppp : p-vector plus p-vector pvstar : space motion pv-vector to star catalog data Reference F.Mignard & M.Froeschle, Astron. Astrophys. 354, 732-739 (2000). source"},{"id":257,"pagetitle":"Functions","title":"ERFA.fk54z","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.fk54z-Tuple{Any, Any, Any}","content":" ERFA.fk54z  —  Method fk54z(r2000, d2000, bepoch) Convert a J2000.0 FK5 star position to B1950.0 FK4, assuming zero proper motion in FK5 and parallax. Given r2000 ,  d2000 : J2000.0 FK5 RA,Dec (rad) bepoch : Besselian epoch (e.g. 1950.0) Returned r1950 ,  d1950 : B1950.0 FK4 RA,Dec (rad) at epoch BEPOCH dr1950 ,  dd1950 : B1950.0 FK4 proper motions (rad/trop.yr) Notes In contrast to the eraFk524 function, here the FK5 proper motions, the parallax and the radial velocity are presumed zero. This function converts a star position from the IAU 1976 FK5 (Fricke) system to the former FK4 (Bessel-Newcomb) system, for cases such as distant radio sources where it is presumed there is zero parallax and no proper motion.  Because of the E-terms of aberration, such objects have (in general) non-zero proper motion in FK4, and the present function returns those fictitious proper motions. Conversion from B1950.0 FK4 to J2000.0 FK5 only is provided for. Conversions involving other equinoxes would require additional treatment for precession. The position returned by this function is in the B1950.0 FK4 reference system but at Besselian epoch BEPOCH.  For comparison with catalogs the BEPOCH argument will frequently be 1950.0. (In this context the distinction between Besselian and Julian epoch is insignificant.) The RA component of the returned (fictitious) proper motion is dRA/dt rather than cos(Dec)*dRA/dt. Called anp : normalize angle into range 0 to 2pi c2s : p-vector to spherical fk524 : FK4 to FK5 s2c : spherical to p-vector source"},{"id":258,"pagetitle":"Functions","title":"ERFA.fk5hip","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.fk5hip-Tuple{}","content":" ERFA.fk5hip  —  Method fk5hip() FK5 to Hipparcos rotation and spin. Returned r5h : R-matrix: FK5 rotation wrt Hipparcos (Note 2) s5h : R-vector: FK5 spin wrt Hipparcos (Note 3) Notes This function models the FK5 to Hipparcos transformation as a pure rotation and spin;  zonal errors in the FK5 catalogue are not taken into account. The r-matrix r5h operates in the sense:   P_Hipparcos = r5h x P_FK5 where P FK5 is a p-vector in the FK5 frame, and P Hipparcos is the equivalent Hipparcos p-vector. The r-vector s5h represents the time derivative of the FK5 to Hipparcos rotation.  The units are radians per year (Julian, TDB). Called rv2m : r-vector to r-matrix Reference F.Mignard & M.Froeschle, Astron. Astrophys. 354, 732-739 (2000). source"},{"id":259,"pagetitle":"Functions","title":"ERFA.fk5hz","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.fk5hz-NTuple{4, Any}","content":" ERFA.fk5hz  —  Method fk5hz(r5, d5, date1, date2) Transform an FK5 (J2000.0) star position into the system of the Hipparcos catalogue, assuming zero Hipparcos proper motion. Given r5 : FK5 RA (radians), equinox J2000.0, at date d5 : FK5 Dec (radians), equinox J2000.0, at date date1 ,  date2 : TDB date (Notes 1,2) Returned rh : Hipparcos RA (radians) dh : Hipparcos Dec (radians) Notes This function converts a star position from the FK5 system to the Hipparcos system, in such a way that the Hipparcos proper motion is zero.  Because such a star has, in general, a non-zero proper motion in the FK5 system, the function requires the date at which the position in the FK5 system was determined. The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The FK5 to Hipparcos transformation is modeled as a pure rotation and spin;  zonal errors in the FK5 catalogue are not taken into account. The position returned by this function is in the Hipparcos reference system but at date date1+date2. See also  fk52h ,  h2fk5 ,  hfk5z . Called s2c : spherical coordinates to unit vector fk5hip : FK5 to Hipparcos rotation and spin sxp : multiply p-vector by scalar rv2m : r-vector to r-matrix trxp : product of transpose of r-matrix and p-vector pxp : vector product of two p-vectors c2s : p-vector to spherical anp : normalize angle into range 0 to 2pi Reference F.Mignard & M.Froeschle, 2000, Astron.Astrophys. 354, 732-739. source"},{"id":260,"pagetitle":"Functions","title":"ERFA.fw2m","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.fw2m-NTuple{4, Any}","content":" ERFA.fw2m  —  Method fw2m(x, y, s, t) Form rotation matrix given the Fukushima-Williams angles. Given gamb : F-W angle gamma_bar (radians) phib : F-W angle phi_bar (radians) psi : F-W angle psi (radians) eps : F-W angle epsilon (radians) Returned r : Rotation matrix Notes Naming the following points: e = J2000.0 ecliptic pole, p = GCRS pole, E = ecliptic pole of date, and P = CIP, the four Fukushima-Williams angles are as follows: gamb = gamma = epE phib = phi = pE psi = psi = pEP eps = epsilon = EP The matrix representing the combined effects of frame bias, precession and nutation is: NxPxB = R_1(-eps).R_3(-psi).R_1(phib).R_3(gamb) Three different matrices can be constructed, depending on the supplied angles: To obtain the nutation x precession x frame bias matrix,  generate the four precession angles, generate the nutation  components and add them to the  psi_bar  and  epsilon_A  angles,  and call the present function. To obtain the precession x frame bias matrix, generate the  four precession angles and call the present function. To obtain the frame bias matrix, generate the four precession  angles for date J2000.0 and call the present function. The nutation-only and precession-only matrices can if necessary be obtained by combining these three appropriately. Called ir : initialize r-matrix to identity rz : rotate around Z-axis rx : rotate around X-axis Reference Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351 source"},{"id":261,"pagetitle":"Functions","title":"ERFA.fw2xy","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.fw2xy-NTuple{4, Any}","content":" ERFA.fw2xy  —  Method fw2xy(gamb, phib, psi, eps) CIP X,Y given Fukushima-Williams bias-precession-nutation angles. Given gamb : F-W angle gamma_bar (radians) phib : F-W angle phi_bar (radians) psi : F-W angle psi (radians) eps : F-W angle epsilon (radians) Returned x ,  y : CIP unit vector X,Y Notes Naming the following points: e = J2000.0 ecliptic pole, p = GCRS pole E = ecliptic pole of date, and P = CIP, the four Fukushima-Williams angles are as follows: gamb = gamma = epE phib = phi = pE psi = psi = pEP eps = epsilon = EP The matrix representing the combined effects of frame bias, precession and nutation is: NxPxB = R_1(-epsA).R_3(-psi).R_1(phib).R_3(gamb) The returned values x,y are elements  [3, 1]  and  [2, 1]  of the matrix.  Near J2000.0, they are essentially angles in radians. Called fw2m : F-W angles to r-matrix bpn2xy : extract CIP X,Y coordinates from NPB matrix Reference Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351 source"},{"id":262,"pagetitle":"Functions","title":"ERFA.g2icrs","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.g2icrs-Tuple{Any, Any}","content":" ERFA.g2icrs  —  Method g2icrs(dl, db) Transformation from Galactic Coordinates to ICRS. Given dl : Galactic longitude (radians) db : Galactic latitude (radians) Returned dr : ICRS right ascension (radians) dd : ICRS declination (radians) Notes The IAU 1958 system of Galactic coordinates was defined with respect to the now obsolete reference system FK4 B1950.0.  When interpreting the system in a modern context, several factors have to be taken into account: The inclusion in FK4 positions of the E-terms of aberration. The distortion of the FK4 proper motion system by differential Galactic rotation. The use of the B1950.0 equinox rather than the now-standard J2000.0. The frame bias between ICRS and the J2000.0 mean place system. The Hipparcos Catalogue (Perryman & ESA 1997) provides a rotation matrix that transforms directly between ICRS and Galactic coordinates with the above factors taken into account.  The matrix is derived from three angles, namely the ICRS coordinates of the Galactic pole and the longitude of the ascending node of the galactic equator on the ICRS equator.  They are given in degrees to five decimal places and for canonical purposes are regarded as exact.  In the Hipparcos Catalogue the matrix elements are given to 10 decimal places (about 20 microarcsec). In the present ERFA function the matrix elements have been recomputed from the canonical three angles and are given to 30 decimal places. The inverse transformation is performed by the function  icrs2g . Called anp : normalize angle into range 0 to 2pi anpm : normalize angle into range +/- pi s2c : spherical coordinates to unit vector trxp : product of transpose of r-matrix and p-vector c2s : p-vector to spherical Reference Perryman M.A.C. & ESA, 1997, ESA SP-1200, The Hipparcos and Tycho   catalogues.  Astrometric and photometric star catalogues   derived from the ESA Hipparcos Space Astrometry Mission.  ESA   Publications Division, Noordwijk, Netherlands. source"},{"id":263,"pagetitle":"Functions","title":"ERFA.gc2gd","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.gc2gd-Tuple{ERFA.Ellipsoid, Any}","content":" ERFA.gc2gd  —  Method gc2gd(n::Ellipsoid, xyz) Transform geocentric coordinates to geodetic using the specified reference ellipsoid. Given n : Ellipsoid identifier (Note 1) xyz : Geocentric vector (Note 2) Returned elong : Longitude (radians, east +ve, Note 3) phi : Latitude (geodetic, radians, Note 3) height : Height above ellipsoid (geodetic, Notes 2,3) Notes The identifier n is a number that specifies the choice of reference ellipsoid.  The following are supported: WGS84 GRS80 WGS72 The geocentric vector (xyz, given) and height (height, returned) are in meters. An error status -1 means that the identifier n is illegal.  An error status -2 is theoretically impossible.  In all error cases, all three results are set to -1e9. The inverse transformation is performed in the function  gd2gc . Called eform : Earth reference ellipsoids gc2gde : geocentric to geodetic transformation, general source"},{"id":264,"pagetitle":"Functions","title":"ERFA.gc2gde","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.gc2gde-Tuple{Any, Any, Any}","content":" ERFA.gc2gde  —  Method gc2gde(a, f, xyz) Transform geocentric coordinates to geodetic for a reference ellipsoid of specified form. Given a : Equatorial radius (Notes 2,4) f : Flattening (Note 3) xyz : Geocentric vector (Note 4) Returned elong : Longitude (radians, east +ve) phi : Latitude (geodetic, radians) height : Height above ellipsoid (geodetic, Note 4) Notes This function is based on the GCONV2H Fortran subroutine by Toshio Fukushima (see reference). The equatorial radius, a, can be in any units, but meters is the conventional choice. The flattening, f, is (for the Earth) a value around 0.00335, i.e. around 1/298. The equatorial radius, a, and the geocentric vector, xyz, must be given in the same units, and determine the units of the returned height, height. If an error occurs (status < 0), elong, phi and height are unchanged. The inverse transformation is performed in the function  gd2gce . The transformation for a standard ellipsoid (such as  WGS84 ) can more conveniently be performed by calling  gc2gd , which uses a numerical code to identify the required A and F values. Reference Fukushima, T., \"Transformation from Cartesian to geodetic   coordinates accelerated by Halley's method\", J.Geodesy (2006)   79: 689-693 source"},{"id":265,"pagetitle":"Functions","title":"ERFA.gd2gc","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.gd2gc-NTuple{4, Any}","content":" ERFA.gd2gc  —  Method gd2gc(n, elong, phi, height) Transform geodetic coordinates to geocentric using the specified reference ellipsoid. Given n : Ellipsoid identifier (Note 1) elong : Longitude (radians, east +ve) phi : Latitude (geodetic, radians, Note 3) height : Height above ellipsoid (geodetic, Notes 2,3) Returned xyz : Geocentric vector (Note 2) Notes The identifier n is a number that specifies the choice of reference ellipsoid.  The following are supported: n ellipsoid 1 WGS84 2 GRS80 3 WGS72 The n value has no significance outside the ERFA software.  For convenience, the  Ellipsoid  enum provides these values. The height (height, given) and the geocentric vector (xyz, returned) are in meters. No validation is performed on the arguments elong, phi and height.  An error status -1 means that the identifier n is illegal.  An error status -2 protects against cases that would lead to arithmetic exceptions.  In all error cases, xyz is set to zeros. The inverse transformation is performed in the function  gc2gd . Called eform : Earth reference ellipsoids gd2gce : geodetic to geocentric transformation, general zp : zero p-vector source"},{"id":266,"pagetitle":"Functions","title":"ERFA.gd2gce","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.gd2gce-NTuple{5, Any}","content":" ERFA.gd2gce  —  Method gd2gce(a, f, elong, phi, height) Transform geodetic coordinates to geocentric for a reference ellipsoid of specified form. Given a : Equatorial radius (Notes 1,4) f : Flattening (Notes 2,4) elong : Longitude (radians, east +ve) phi : Latitude (geodetic, radians, Note 4) height : Height above ellipsoid (geodetic, Notes 3,4) Returned xyz : Geocentric vector (Note 3) Notes The equatorial radius, a, can be in any units, but meters is the conventional choice. The flattening, f, is (for the Earth) a value around 0.00335, i.e. around 1/298. The equatorial radius, a, and the height, height, must be given in the same units, and determine the units of the returned geocentric vector, xyz. No validation is performed on individual arguments.  The error status -1 protects against (unrealistic) cases that would lead to arithmetic exceptions.  If an error occurs, xyz is unchanged. The inverse transformation is performed in the function  gc2gde . The transformation for a standard ellipsoid (such as  WGS84 ) can more conveniently be performed by calling  gd2gc ,  which uses a numerical code to identify the required a and f values. References Green, R.M., Spherical Astronomy, Cambridge University Press,   (1985) Section 4.5, p96. Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992),   Section 4.22, p202. source"},{"id":267,"pagetitle":"Functions","title":"ERFA.gmst00","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.gmst00","content":" ERFA.gmst00  —  Function gmst00(uta, utb, tta, ttb) Greenwich mean sidereal time (model consistent with IAU 2000 resolutions). Given uta ,  utb : UT1 as a 2-part Julian Date (Notes 1,2) tta ,  ttb : TT as a 2-part Julian Date (Notes 1,2) Returned Greenwich mean sidereal time (radians) Notes The UT1 and TT dates uta+utb and tta+ttb respectively, are both Julian Dates, apportioned in any convenient way between the argument pairs.  For example, JD=2450123.7 could be expressed in any of these ways, among others: Part A Part B Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable (in the case of UT;  the TT is not at all critical in this respect).  The J2000 and MJD methods are good compromises between resolution and convenience.  For UT, the date & time method is best matched to the algorithm that is used by the Earth Rotation Angle function, called internally:  maximum precision is delivered when the uta argument is for 0hrs UT1 on the day in question and the utb argument lies in the range 0 to 1, or vice versa. Both UT1 and TT are required, UT1 to predict the Earth rotation and TT to predict the effects of precession.  If UT1 is used for both purposes, errors of order 100 microarcseconds result. This GMST is compatible with the IAU 2000 resolutions and must be used only in conjunction with other IAU 2000 compatible components such as precession-nutation and equation of the equinoxes. The result is returned in the range 0 to 2pi. The algorithm is from Capitaine et al. (2003) and IERS Conventions 2003. Called era00 : Earth rotation angle, IAU 2000 anp : normalize angle into range 0 to 2pi References Capitaine, N., Wallace, P.T. and McCarthy, D.D., \"Expressions to   implement the IAU 2000 definition of UT1\", Astronomy &   Astrophysics, 406, 1135-1149 (2003) McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":268,"pagetitle":"Functions","title":"ERFA.gmst06","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.gmst06","content":" ERFA.gmst06  —  Function gmst06(uta, utb, tta, ttb) Greenwich mean sidereal time (consistent with IAU 2006 precession). Given uta ,  utb : UT1 as a 2-part Julian Date (Notes 1,2) tta ,  ttb : TT as a 2-part Julian Date (Notes 1,2) Returned Greenwich mean sidereal time (radians) Notes The UT1 and TT dates uta+utb and tta+ttb respectively, are both Julian Dates, apportioned in any convenient way between the argument pairs.  For example, JD=2450123.7 could be expressed in any of these ways, among others: Part A Part B Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable (in the case of UT;  the TT is not at all critical in this respect).  The J2000 and MJD methods are good compromises between resolution and convenience.  For UT, the date & time method is best matched to the algorithm that is used by the Earth rotation angle function, called internally:  maximum precision is delivered when the uta argument is for 0hrs UT1 on the day in question and the utb argument lies in the range 0 to 1, or vice versa. Both UT1 and TT are required, UT1 to predict the Earth rotation and TT to predict the effects of precession.  If UT1 is used for both purposes, errors of order 100 microarcseconds result. This GMST is compatible with the IAU 2006 precession and must not be used with other precession models. The result is returned in the range 0 to 2pi. Called era00 : Earth rotation angle, IAU 2000 anp : normalize angle into range 0 to 2pi Reference Capitaine, N., Wallace, P.T. & Chapront, J., 2005,   Astron.Astrophys. 432, 355 source"},{"id":269,"pagetitle":"Functions","title":"ERFA.gmst82","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.gmst82","content":" ERFA.gmst82  —  Function gmst82(dj1, dj2) Universal Time to Greenwich mean sidereal time (IAU 1982 model). Given dj1 ,  dj2 : UT1 Julian Date (see note) Returned Greenwich mean sidereal time (radians) Notes The UT1 date dj1+dj2 is a Julian Date, apportioned in any convenient way between the arguments dj1 and dj2.  For example, JD(UT1)=2450123.7 could be expressed in any of these ways, among others: dj1 dj2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 and MJD methods are good compromises between resolution and convenience.  The date & time method is best matched to the algorithm used:  maximum accuracy (or, at least, minimum noise) is delivered when the dj1 argument is for 0hrs UT1 on the day in question and the dj2 argument lies in the range 0 to 1, or vice versa. The algorithm is based on the IAU 1982 expression.  This is always described as giving the GMST at 0 hours UT1.  In fact, it gives the difference between the GMST and the UT, the steady 4-minutes-per-day drawing-ahead of ST with respect to UT.  When whole days are ignored, the expression happens to equal the GMST at 0 hours UT1 each day. In this function, the entire UT1 (the sum of the two arguments dj1 and dj2) is used directly as the argument for the standard formula, the constant term of which is adjusted by 12 hours to take account of the noon phasing of Julian Date.  The UT1 is then added, but omitting whole days to conserve accuracy. Called anp : normalize angle into range 0 to 2pi References Transactions of the International Astronomical Union,   XVIII B, 67 (1983). Aoki et al., Astron. Astrophys. 105, 359-361 (1982). source"},{"id":270,"pagetitle":"Functions","title":"ERFA.gst00a","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.gst00a","content":" ERFA.gst00a  —  Function gst00a(uta, utb, tta, ttb) Greenwich apparent sidereal time (consistent with IAU 2000 resolutions). Given uta ,  utb : UT1 as a 2-part Julian Date (Notes 1,2) tta ,  ttb : TT as a 2-part Julian Date (Notes 1,2) Returned Greenwich apparent sidereal time (radians) Notes The UT1 and TT dates uta+utb and tta+ttb respectively, are both Julian Dates, apportioned in any convenient way between the argument pairs.  For example, JD=2450123.7 could be expressed in any of these ways, among others: Part A Part B Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable (in the case of UT;  the TT is not at all critical in this respect).  The J2000 and MJD methods are good compromises between resolution and convenience.  For UT, the date & time method is best matched to the algorithm that is used by the Earth Rotation Angle function, called internally:  maximum precision is delivered when the uta argument is for 0hrs UT1 on the day in question and the utb argument lies in the range 0 to 1, or vice versa. Both UT1 and TT are required, UT1 to predict the Earth rotation and TT to predict the effects of precession-nutation.  If UT1 is used for both purposes, errors of order 100 microarcseconds result. This GAST is compatible with the IAU 2000 resolutions and must be used only in conjunction with other IAU 2000 compatible components such as precession-nutation. The result is returned in the range 0 to 2pi. The algorithm is from Capitaine et al. (2003) and IERS Conventions 2003. Called gmst00 : Greenwich mean sidereal time, IAU 2000 ee00a : equation of the equinoxes, IAU 2000A anp : normalize angle into range 0 to 2pi References Capitaine, N., Wallace, P.T. and McCarthy, D.D., \"Expressions to   implement the IAU 2000 definition of UT1\", Astronomy &   Astrophysics, 406, 1135-1149 (2003) McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":271,"pagetitle":"Functions","title":"ERFA.gst00b","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.gst00b","content":" ERFA.gst00b  —  Function gst00b(dr, dd) Greenwich apparent sidereal time (consistent with IAU 2000 resolutions but using the truncated nutation model IAU 2000B). Given uta ,  utb : UT1 as a 2-part Julian Date (Notes 1,2) Returned Greenwich apparent sidereal time (radians) Notes The UT1 date uta+utb is a Julian Date, apportioned in any convenient way between the argument pair.  For example, JD=2450123.7 could be expressed in any of these ways, among others: uta utb Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 and MJD methods are good compromises between resolution and convenience.  For UT, the date & time method is best matched to the algorithm that is used by the Earth Rotation Angle function, called internally:  maximum precision is delivered when the uta argument is for 0hrs UT1 on the day in question and the utb argument lies in the range 0 to 1, or vice versa. The result is compatible with the IAU 2000 resolutions, except that accuracy has been compromised for the sake of speed and convenience in two respects: UT is used instead of TDB (or TT) to compute the precession component of GMST and the equation of the equinoxes.  This results in errors of order 0.1 mas at present. The IAU 2000B abridged nutation model (McCarthy & Luzum, 2001) is used, introducing errors of up to 1 mas. This GAST is compatible with the IAU 2000 resolutions and must be used only in conjunction with other IAU 2000 compatible components such as precession-nutation. The result is returned in the range 0 to 2pi. The algorithm is from Capitaine et al. (2003) and IERS Conventions 2003. Called gmst00 : Greenwich mean sidereal time, IAU 2000 ee00b : equation of the equinoxes, IAU 2000B anp : normalize angle into range 0 to 2pi References Capitaine, N., Wallace, P.T. and McCarthy, D.D., \"Expressions to   implement the IAU 2000 definition of UT1\", Astronomy &   Astrophysics, 406, 1135-1149 (2003) McCarthy, D.D. & Luzum, B.J., \"An abridged model of the   precession-nutation of the celestial pole\", Celestial Mechanics &   Dynamical Astronomy, 85, 37-49 (2003) McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":272,"pagetitle":"Functions","title":"ERFA.gst06","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.gst06-NTuple{5, Any}","content":" ERFA.gst06  —  Method gst06(uta, utb, tta, ttb, rnpb) Greenwich apparent sidereal time, IAU 2006, given the NPB matrix. Given uta ,  utb : UT1 as a 2-part Julian Date (Notes 1,2) tta ,  ttb : TT as a 2-part Julian Date (Notes 1,2) rnpb : Nutation x precession x bias matrix Returned Greenwich apparent sidereal time (radians) Notes The UT1 and TT dates uta+utb and tta+ttb respectively, are both Julian Dates, apportioned in any convenient way between the argument pairs.  For example, JD=2450123.7 could be expressed in any of these ways, among others: Part A Part B Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable (in the case of UT;  the TT is not at all critical in this respect).  The J2000 and MJD methods are good compromises between resolution and convenience.  For UT, the date & time method is best matched to the algorithm that is used by the Earth rotation angle function, called internally:  maximum precision is delivered when the uta argument is for 0hrs UT1 on the day in question and the utb argument lies in the range 0 to 1, or vice versa. Both UT1 and TT are required, UT1 to predict the Earth rotation and TT to predict the effects of precession-nutation.  If UT1 is used for both purposes, errors of order 100 microarcseconds result. Although the function uses the IAU 2006 series for s+XY/2, it is otherwise independent of the precession-nutation model and can in practice be used with any equinox-based NPB matrix. The result is returned in the range 0 to 2pi. Called bpn2xy : extract CIP X,Y coordinates from NPB matrix s06 : the CIO locator s, given X,Y, IAU 2006 anp : normalize angle into range 0 to 2pi era00 : Earth rotation angle, IAU 2000 eors : equation of the origins, given NPB matrix and s Reference Wallace, P.T. & Capitaine, N., 2006, Astron.Astrophys. 459, 981 source"},{"id":273,"pagetitle":"Functions","title":"ERFA.gst06a","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.gst06a","content":" ERFA.gst06a  —  Function gst06a(uta, utb, tta, ttb) Greenwich apparent sidereal time (consistent with IAU 2000 and 2006 resolutions). Given uta ,  utb : UT1 as a 2-part Julian Date (Notes 1,2) tta ,  ttb : TT as a 2-part Julian Date (Notes 1,2) Returned Greenwich apparent sidereal time (radians) Notes The UT1 and TT dates uta+utb and tta+ttb respectively, are both Julian Dates, apportioned in any convenient way between the argument pairs.  For example, JD=2450123.7 could be expressed in any of these ways, among others: Part A Part B Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable (in the case of UT;  the TT is not at all critical in this respect).  The J2000 and MJD methods are good compromises between resolution and convenience.  For UT, the date & time method is best matched to the algorithm that is used by the Earth rotation angle function, called internally:  maximum precision is delivered when the uta argument is for 0hrs UT1 on the day in question and the utb argument lies in the range 0 to 1, or vice versa. Both UT1 and TT are required, UT1 to predict the Earth rotation and TT to predict the effects of precession-nutation.  If UT1 is used for both purposes, errors of order 100 microarcseconds result. This GAST is compatible with the IAU 2000/2006 resolutions and must be used only in conjunction with IAU 2006 precession and IAU 2000A nutation. The result is returned in the range 0 to 2pi. Called pnm06a : classical NPB matrix, IAU 2006/2000A gst06 : Greenwich apparent ST, IAU 2006, given NPB matrix Reference Wallace, P.T. & Capitaine, N., 2006, Astron.Astrophys. 459, 981 source"},{"id":274,"pagetitle":"Functions","title":"ERFA.gst94","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.gst94","content":" ERFA.gst94  —  Function gst94(dr, dd) Greenwich apparent sidereal time (consistent with IAU 1982/94 resolutions). Given uta ,  utb : UT1 as a 2-part Julian Date (Notes 1,2) Returned Greenwich apparent sidereal time (radians) Notes The UT1 date uta+utb is a Julian Date, apportioned in any convenient way between the argument pair.  For example, JD=2450123.7 could be expressed in any of these ways, among others: uta utb Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 and MJD methods are good compromises between resolution and convenience.  For UT, the date & time method is best matched to the algorithm that is used by the Earth Rotation Angle function, called internally:  maximum precision is delivered when the uta argument is for 0hrs UT1 on the day in question and the utb argument lies in the range 0 to 1, or vice versa. The result is compatible with the IAU 1982 and 1994 resolutions, except that accuracy has been compromised for the sake of convenience in that UT is used instead of TDB (or TT) to compute the equation of the equinoxes. This GAST must be used only in conjunction with contemporaneous IAU standards such as 1976 precession, 1980 obliquity and 1982 nutation.  It is not compatible with the IAU 2000 resolutions. The result is returned in the range 0 to 2pi. Called gmst82 : Greenwich mean sidereal time, IAU 1982 eqeq94 : equation of the equinoxes, IAU 1994 anp : normalize angle into range 0 to 2pi References Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992) IAU Resolution C7, Recommendation 3 (1994) source"},{"id":275,"pagetitle":"Functions","title":"ERFA.h2fk5","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.h2fk5-NTuple{6, Any}","content":" ERFA.h2fk5  —  Method h2fk5(ra, dec, dra, ddec, px, rv) Transform Hipparcos star data into the FK5 (J2000.0) system. Given (all Hipparcos, epoch J2000.0) rh : RA (radians) dh : Dec (radians) drh : Proper motion in RA (dRA/dt, rad/Jyear) ddh : Proper motion in Dec (dDec/dt, rad/Jyear) pxh : Parallax (arcsec) rvh : Radial velocity (km/s, positive = receding) Returned (all FK5, equinox J2000.0, epoch J2000.0) r5 : RA (radians) d5 : Dec (radians) dr5 : Proper motion in RA (dRA/dt, rad/Jyear) dd5 : Proper motion in Dec (dDec/dt, rad/Jyear) px5 : Parallax (arcsec) rv5 : Radial velocity (km/s, positive = receding) Notes This function transforms Hipparcos star positions and proper motions into FK5 J2000.0. The proper motions in RA are dRA/dt rather than cos(Dec)*dRA/dt, and are per year rather than per century. The FK5 to Hipparcos transformation is modeled as a pure rotation and spin;  zonal errors in the FK5 catalog are not taken into account. See also  fk52h ,  fk5hz ,  hfk5z . Called starpv : star catalog data to space motion pv-vector fk5hip : FK5 to Hipparcos rotation and spin rv2m : r-vector to r-matrix rxp : product of r-matrix and p-vector trxp : product of transpose of r-matrix and p-vector pxp : vector product of two p-vectors pmp : p-vector minus p-vector pvstar : space motion pv-vector to star catalog data Reference F.Mignard & M.Froeschle, Astron. Astrophys. 354, 732-739 (2000). source"},{"id":276,"pagetitle":"Functions","title":"ERFA.hd2ae","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.hd2ae-Tuple{Any, Any, Any}","content":" ERFA.hd2ae  —  Method hd2ae(h, d, p) Equatorial to horizon coordinates:  transform hour angle and declination to azimuth and altitude. Given ha : hour angle (local) dec : declination phi : site latitude Returned az : azimuth el : altitude (informally, elevation) Notes All the arguments are angles in radians. Azimuth is returned in the range 0-2pi;  north is zero, and east is +pi/2.  Altitude is returned in the range +/- pi/2. The latitude phi is pi/2 minus the angle between the Earth's rotation axis and the adopted zenith.  In many applications it will be sufficient to use the published geodetic latitude of the site.  In very precise (sub-arcsecond) applications, phi can be corrected for polar motion. The returned azimuth az is with respect to the rotational north pole, as opposed to the ITRS pole, and for sub-arcsecond accuracy will need to be adjusted for polar motion if it is to be with respect to north on a map of the Earth's surface. Should the user wish to work with respect to the astronomical zenith rather than the geodetic zenith, phi will need to be adjusted for deflection of the vertical (often tens of arcseconds), and the zero point of the hour angle ha will also be affected. The transformation is the same as Vh = Rz(pi) Ry(pi/2-phi) Ve, where Vh and Ve are lefthanded unit vectors in the (az,el) and (ha,dec) systems respectively and Ry and Rz are rotations about first the y-axis and then the z-axis.  (n.b. Rz(pi) simply reverses the signs of the x and y components.)  For efficiency, the algorithm is written out rather than calling other utility functions.  For applications that require even greater efficiency, additional savings are possible if constant terms such as functions of latitude are computed once and for all. Again for efficiency, no range checking of arguments is carried out. source"},{"id":277,"pagetitle":"Functions","title":"ERFA.hd2pa","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.hd2pa-Tuple{Any, Any, Any}","content":" ERFA.hd2pa  —  Method hd2pa(h, d, p) Parallactic angle for a given hour angle and declination. Given ha : hour angle dec : declination phi : site latitude Returned Returns the parallactic angle Notes All the arguments are angles in radians. The parallactic angle at a point in the sky is the position angle of the vertical, i.e. the angle between the directions to the north celestial pole and to the zenith respectively. The result is returned in the range -pi to +pi. At the pole itself a zero result is returned. The latitude phi is pi/2 minus the angle between the Earth's rotation axis and the adopted zenith.  In many applications it will be sufficient to use the published geodetic latitude of the site.  In very precise (sub-arcsecond) applications, phi can be corrected for polar motion. Should the user wish to work with respect to the astronomical zenith rather than the geodetic zenith, phi will need to be adjusted for deflection of the vertical (often tens of arcseconds), and the zero point of the hour angle ha will also be affected. Reference Smart, W.M., \"Spherical Astronomy\", Cambridge University Press, 6th edition (Green, 1977), p49. source"},{"id":278,"pagetitle":"Functions","title":"ERFA.hfk5z","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.hfk5z-NTuple{4, Any}","content":" ERFA.hfk5z  —  Method hfk5z(rh, dh, date1, date2) Transform a Hipparcos star position into FK5 J2000.0, assuming zero Hipparcos proper motion. Given rh : Hipparcos RA (radians) dh : Hipparcos Dec (radians) date1 ,  date2 : TDB date (Note 1) Returned (all FK5, equinox J2000.0, date date1+date2) r5 : RA (radians) d5 : Dec (radians) dr5 : FK5 RA proper motion (rad/year, Note 4) dd5 : Dec proper motion (rad/year, Note 4) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The proper motion in RA is dRA/dt rather than cos(Dec)*dRA/dt. The FK5 to Hipparcos transformation is modeled as a pure rotation and spin;  zonal errors in the FK5 catalogue are not taken into account. It was the intention that Hipparcos should be a close approximation to an inertial frame, so that distant objects have zero proper motion;  such objects have (in general) non-zero proper motion in FK5, and this function returns those fictitious proper motions. The position returned by this function is in the FK5 J2000.0 reference system but at date date1+date2. See also  fk52h ,  h2fk5 ,  fk5hz . Called s2c : spherical coordinates to unit vector fk5hip : FK5 to Hipparcos rotation and spin rxp : product of r-matrix and p-vector sxp : multiply p-vector by scalar rxr : product of two r-matrices trxp : product of transpose of r-matrix and p-vector pxp : vector product of two p-vectors pv2s : pv-vector to spherical anp : normalize angle into range 0 to 2pi Reference F.Mignard & M.Froeschle, 2000, Astron.Astrophys. 354, 732-739. source"},{"id":279,"pagetitle":"Functions","title":"ERFA.icrs2g","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.icrs2g-Tuple{Any, Any}","content":" ERFA.icrs2g  —  Method icrs2g(dr, dd) Transformation from ICRS to Galactic Coordinates. Given dr : ICRS right ascension (radians) dd : ICRS declination (radians) Returned dl : Galactic longitude (radians) db : Galactic latitude (radians) Notes The IAU 1958 system of Galactic coordinates was defined with respect to the now obsolete reference system FK4 B1950.0.  When interpreting the system in a modern context, several factors have to be taken into account: The inclusion in FK4 positions of the E-terms of aberration. The distortion of the FK4 proper motion system by differential Galactic rotation. The use of the B1950.0 equinox rather than the now-standard J2000.0. The frame bias between ICRS and the J2000.0 mean place system. The Hipparcos Catalogue (Perryman & ESA 1997) provides a rotation matrix that transforms directly between ICRS and Galactic coordinates with the above factors taken into account.  The matrix is derived from three angles, namely the ICRS coordinates of the Galactic pole and the longitude of the ascending node of the galactic equator on the ICRS equator.  They are given in degrees to five decimal places and for canonical purposes are regarded as exact.  In the Hipparcos Catalogue the matrix elements are given to 10 decimal places (about 20 microarcsec). In the present ERFA function the matrix elements have been recomputed from the canonical three angles and are given to 30 decimal places. The inverse transformation is performed by the function  g2icrs . Called anp : normalize angle into range 0 to 2pi anpm : normalize angle into range +/- pi s2c : spherical coordinates to unit vector rxp : product of r-matrix and p-vector c2s : p-vector to spherical Reference Perryman M.A.C. & ESA, 1997, ESA SP-1200, The Hipparcos and Tycho   catalogues.  Astrometric and photometric star catalogues   derived from the ESA Hipparcos Space Astrometry Mission.  ESA   Publications Division, Noordwijk, Netherlands. source"},{"id":280,"pagetitle":"Functions","title":"ERFA.ir","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.ir","content":" ERFA.ir  —  Function ir() Initialize an r-matrix to the identity matrix. Deprecated Use  Array{Float64}(LinearAlgebra.I, 3, 3)  instead. Returned r : r-matrix source"},{"id":281,"pagetitle":"Functions","title":"ERFA.jd2cal","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.jd2cal-Tuple{Any, Any}","content":" ERFA.jd2cal  —  Method jd2cal(dj1, dj2) Julian Date to Gregorian year, month, day, and fraction of a day. Given dj1 ,  dj2 : Julian Date (Notes 1, 2) Returned iy : Year im : Month id : Day fd : Fraction of day Notes The earliest valid date is -68569.5 (-4900 March 1).  The largest value accepted is 1e9. The Julian Date is apportioned in any convenient way between the arguments dj1 and dj2.  For example, JD=2450123.7 could be expressed in any of these ways, among others: dj1 dj2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time In early eras the conversion is from the \"proleptic Gregorian calendar\";  no account is taken of the date(s) of adoption of the Gregorian calendar, nor is the AD/BC numbering convention observed. Reference Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992),   Section 12.92 (p604). source"},{"id":282,"pagetitle":"Functions","title":"ERFA.jdcalf","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.jdcalf-Tuple{Any, Any, Any}","content":" ERFA.jdcalf  —  Method jdcalf(ndp, dj1, dj2) Julian Date to Gregorian Calendar, expressed in a form convenient for formatting messages:  rounded to a specified precision. Given ndp : Number of decimal places of days in fraction dj1 ,  dj2 : Dj1+dj2 = Julian Date (Note 1) Returned iymdf : Year, month, day, fraction in Gregorian calendar Notes The Julian Date is apportioned in any convenient way between the arguments dj1 and dj2.  For example, JD=2450123.7 could be expressed in any of these ways, among others: dj1 dj2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time In early eras the conversion is from the \"Proleptic Gregorian Calendar\";  no account is taken of the date(s) of adoption of the Gregorian Calendar, nor is the AD/BC numbering convention observed. Refer to the function  jd2cal . NDP should be 4 or less if internal overflows are to be avoided on machines which use 16-bit integers. Called jd2cal : JD to Gregorian calendar Reference Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992),   Section 12.92 (p604). source"},{"id":283,"pagetitle":"Functions","title":"ERFA.ld","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.ld-NTuple{6, Any}","content":" ERFA.ld  —  Method ld(bm, p, q, e, em, dlim) Apply light deflection by a solar-system body, as part of transforming coordinate direction into natural direction. Given bm : Mass of the gravitating body (solar masses) p : Direction from observer to source (unit vector) q : Direction from body to source (unit vector) e : Direction from body to observer (unit vector) em : Distance from body to observer (au) dlim : Deflection limiter (Note 4) Returned p1 : Observer to deflected source (unit vector) Notes The algorithm is based on Expr. (70) in Klioner (2003) and Expr. (7.63) in the Explanatory Supplement (Urban & Seidelmann 2013), with some rearrangement to minimize the effects of machine precision. The mass parameter bm can, as required, be adjusted in order to allow for such effects as quadrupole field. The barycentric position of the deflecting body should ideally correspond to the time of closest approach of the light ray to the body. The deflection limiter parameter dlim is phi^2/2, where phi is the angular separation (in radians) between source and body at which limiting is applied.  As phi shrinks below the chosen threshold, the deflection is artificially reduced, reaching zero for phi = 0. The returned vector p1 is not normalized, but the consequential departure from unit magnitude is always negligible. The arguments p and p1 can be the same array. To accumulate total light deflection taking into account the contributions from several bodies, call the present function for each body in succession, in decreasing order of distance from the observer. For efficiency, validation is omitted.  The supplied vectors must be of unit magnitude, and the deflection limiter non-zero and positive. References Urban, S. & Seidelmann, P. K. (eds), Explanatory Supplement to   the Astronomical Almanac, 3rd ed., University Science Books   (2013). Klioner, Sergei A., \"A practical relativistic model for micro-   arcsecond astrometry in space\", Astr. J. 125, 1580-1597 (2003). Called pdp : scalar product of two p-vectors pxp : vector product of two p-vectors source"},{"id":284,"pagetitle":"Functions","title":"ERFA.ldn","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.ldn-Tuple{Vector{ERFA.LDBODY}, Any, Any}","content":" ERFA.ldn  —  Method ldn(l::Vector{LDBODY}, ob, sc) For a star, apply light deflection by multiple solar-system bodies, as part of transforming coordinate direction into natural direction. Given n : Number of bodies (note 1) b : Data for each of the n bodies (Notes 1,2): bm : Mass of the body (solar masses, Note 3) dl : Deflection limiter (Note 4) pv : Barycentric PV of the body (au, au/day) ob : Barycentric position of the observer (au) sc : Observer to star coord direction (unit vector) Returned sn : Observer to deflected star (unit vector) The array b contains n entries, one for each body to be considered.  If n = 0, no gravitational light deflection will be applied, not even for the Sun. The array b should include an entry for the Sun as well as for any planet or other body to be taken into account.  The entries should be in the order in which the light passes the body. In the entry in the b array for body i, the mass parameter b[i].bm can, as required, be adjusted in order to allow for such effects as quadrupole field. The deflection limiter parameter b[i].dl is phi^2/2, where phi is the angular separation (in radians) between star and body at which limiting is applied.  As phi shrinks below the chosen threshold, the deflection is artificially reduced, reaching zero for phi = 0.   Example values suitable for a terrestrial observer, together with masses, are as follows: body i b[i].bm b[i].dl Sun 1.0 6e-6 Jupiter 0.00095435 3e-9 Saturn 0.00028574 3e-10 For cases where the starlight passes the body before reaching the observer, the body is placed back along its barycentric track by the light time from that point to the observer.  For cases where the body is \"behind\" the observer no such shift is applied.  If a different treatment is preferred, the user has the option of instead using the  ld  function.  Similarly,  ld  can be used for cases where the source is nearby, not a star. The returned vector sn is not normalized, but the consequential departure from unit magnitude is always negligible. The arguments sc and sn can be the same array. For efficiency, validation is omitted.  The supplied masses must be greater than zero, the position and velocity vectors must be right, and the deflection limiter greater than zero. Reference Urban, S. & Seidelmann, P. K. (eds), Explanatory Supplement to   the Astronomical Almanac, 3rd ed., University Science Books   (2013), Section 7.2.4. Called erfa_cp : copy p-vector pdp : scalar product of two p-vectors pmp : p-vector minus p-vector ppsp : p-vector plus scaled p-vector pn : decompose p-vector into modulus and direction ld : light deflection by a solar-system body source"},{"id":285,"pagetitle":"Functions","title":"ERFA.ldsun","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.ldsun-Tuple{Any, Any, Any}","content":" ERFA.ldsun  —  Method ldsun(p, e, em) Deflection of starlight by the Sun. Given p : Direction from observer to star (unit vector) e : Direction from Sun to observer (unit vector) em : Distance from Sun to observer (au) Returned p1 : Observer to deflected star (unit vector) Notes The source is presumed to be sufficiently distant that its directions seen from the Sun and the observer are essentially the same. The deflection is restrained when the angle between the star and the center of the Sun is less than a threshold value, falling to zero deflection for zero separation.  The chosen threshold value is within the solar limb for all solar-system applications, and is about 5 arcminutes for the case of a terrestrial observer. The arguments p and p1 can be the same array. Called ld : light deflection by a solar-system body source"},{"id":286,"pagetitle":"Functions","title":"ERFA.lteceq","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.lteceq","content":" ERFA.lteceq  —  Function lteceq(epj, dr, dd) Transformation from ecliptic coordinates (mean equinox and ecliptic of date) to ICRS RA,Dec, using a long-term precession model. Given epj : Julian epoch (TT) dl ,  db : Ecliptic longitude and latitude (radians) Returned dr ,  dd : ICRS right ascension and declination (radians) No assumptions are made about whether the coordinates represent starlight and embody astrometric effects such as parallax or aberration. The transformation is approximately that from ecliptic longitude and latitude (mean equinox and ecliptic of date) to mean J2000.0 right ascension and declination, with only frame bias (always less than 25 mas) to disturb this classical picture. The Vondrak et al. (2011, 2012) 400 millennia precession model agrees with the IAU 2006 precession at J2000.0 and stays within 100 microarcseconds during the 20th and 21st centuries.  It is accurate to a few arcseconds throughout the historical period, worsening to a few tenths of a degree at the end of the +/- 200,000 year time span. Called s2c : spherical coordinates to unit vector ltecm : J2000.0 to ecliptic rotation matrix, long term trxp : product of transpose of r-matrix and p-vector c2s : unit vector to spherical coordinates anp : normalize angle into range 0 to 2pi anpm : normalize angle into range +/- pi References Vondrak, J., Capitaine, N. and Wallace, P., 2011, New precession   expressions, valid for long time intervals, Astron.Astrophys. 534,   A22 Vondrak, J., Capitaine, N. and Wallace, P., 2012, New precession   expressions, valid for long time intervals (Corrigendum),   Astron.Astrophys. 541, C1 source"},{"id":287,"pagetitle":"Functions","title":"ERFA.ltecm","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.ltecm","content":" ERFA.ltecm  —  Function ltecm(dr, dd) ICRS equatorial to ecliptic rotation matrix, long-term. Given epj : Julian epoch (TT) Returned rm : ICRS to ecliptic rotation matrix Notes The matrix is in the sense E_ep = rm x P_ICRS, where  P_ICRS  is a vector with respect to ICRS right ascension and declination axes and  E_ep  is the same vector with respect to the (inertial) ecliptic and equinox of epoch epj. P_ICRS  is a free vector, merely a direction, typically of unit magnitude, and not bound to any particular spatial origin, such as the Earth, Sun or SSB.  No assumptions are made about whether it represents starlight and embodies astrometric effects such as parallax or aberration.  The transformation is approximately that between mean J2000.0 right ascension and declination and ecliptic longitude and latitude, with only frame bias (always less than 25 mas) to disturb this classical picture. The Vondrak et al. (2011, 2012) 400 millennia precession model agrees with the IAU 2006 precession at J2000.0 and stays within 100 microarcseconds during the 20th and 21st centuries.  It is accurate to a few arcseconds throughout the historical period, worsening to a few tenths of a degree at the end of the +/- 200,000 year time span. Called ltpequ : equator pole, long term ltpecl : ecliptic pole, long term pxp : vector product pn : normalize vector References Vondrak, J., Capitaine, N. and Wallace, P., 2011, New precession   expressions, valid for long time intervals, Astron.Astrophys. 534,   A22 Vondrak, J., Capitaine, N. and Wallace, P., 2012, New precession   expressions, valid for long time intervals (Corrigendum),   Astron.Astrophys. 541, C1 source"},{"id":288,"pagetitle":"Functions","title":"ERFA.lteqec","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.lteqec","content":" ERFA.lteqec  —  Function lteqec(epj, dr, dd) Transformation from ICRS equatorial coordinates to ecliptic coordinates (mean equinox and ecliptic of date) using a long-term precession model. Given epj : Julian epoch (TT) dr ,  dd : ICRS right ascension and declination (radians) Returned dl ,  db : Ecliptic longitude and latitude (radians) No assumptions are made about whether the coordinates represent starlight and embody astrometric effects such as parallax or aberration. The transformation is approximately that from mean J2000.0 right ascension and declination to ecliptic longitude and latitude (mean equinox and ecliptic of date), with only frame bias (always less than 25 mas) to disturb this classical picture. The Vondrak et al. (2011, 2012) 400 millennia precession model agrees with the IAU 2006 precession at J2000.0 and stays within 100 microarcseconds during the 20th and 21st centuries.  It is accurate to a few arcseconds throughout the historical period, worsening to a few tenths of a degree at the end of the +/- 200,000 year time span. Called s2c : spherical coordinates to unit vector ltecm : J2000.0 to ecliptic rotation matrix, long term rxp : product of r-matrix and p-vector c2s : unit vector to spherical coordinates anp : normalize angle into range 0 to 2pi anpm : normalize angle into range +/- pi References Vondrak, J., Capitaine, N. and Wallace, P., 2011, New precession   expressions, valid for long time intervals, Astron.Astrophys. 534,   A22 Vondrak, J., Capitaine, N. and Wallace, P., 2012, New precession   expressions, valid for long time intervals (Corrigendum),   Astron.Astrophys. 541, C1 source"},{"id":289,"pagetitle":"Functions","title":"ERFA.ltp","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.ltp","content":" ERFA.ltp  —  Function ltp(dr, dd) Long-term precession matrix. Given epj : Julian epoch (TT) Returned rp : Precession matrix, J2000.0 to date Notes The matrix is in the sense P_date = rp x P_J2000, where  P_J2000  is a vector with respect to the J2000.0 mean equator and equinox and  P_date  is the same vector with respect to the equator and equinox of epoch epj. The Vondrak et al. (2011, 2012) 400 millennia precession model agrees with the IAU 2006 precession at J2000.0 and stays within 100 microarcseconds during the 20th and 21st centuries.  It is accurate to a few arcseconds throughout the historical period, worsening to a few tenths of a degree at the end of the +/- 200,000 year time span. Called ltpequ : equator pole, long term ltpecl : ecliptic pole, long term pxp : vector product pn : normalize vector References Vondrak, J., Capitaine, N. and Wallace, P., 2011, New precession   expressions, valid for long time intervals, Astron.Astrophys. 534,   A22 Vondrak, J., Capitaine, N. and Wallace, P., 2012, New precession   expressions, valid for long time intervals (Corrigendum),   Astron.Astrophys. 541, C1 source"},{"id":290,"pagetitle":"Functions","title":"ERFA.ltpb","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.ltpb","content":" ERFA.ltpb  —  Function ltpb(dr, dd) Long-term precession matrix, including ICRS frame bias. Given epj : Julian epoch (TT) Returned rpb : Precession-bias matrix, J2000.0 to date Notes The matrix is in the sense P_date = rpb x P_ICRS, where  P_ICRS  is a vector in the Geocentric Celestial Reference System, and  P_date  is the vector with respect to the Celestial Intermediate Reference System at that date but with nutation neglected. A first order frame bias formulation is used, of sub- microarcsecond accuracy compared with a full 3D rotation. The Vondrak et al. (2011, 2012) 400 millennia precession model agrees with the IAU 2006 precession at J2000.0 and stays within 100 microarcseconds during the 20th and 21st centuries.  It is accurate to a few arcseconds throughout the historical period, worsening to a few tenths of a degree at the end of the +/- 200,000 year time span. References Vondrak, J., Capitaine, N. and Wallace, P., 2011, New precession   expressions, valid for long time intervals, Astron.Astrophys. 534,   A22 Vondrak, J., Capitaine, N. and Wallace, P., 2012, New precession   expressions, valid for long time intervals (Corrigendum),   Astron.Astrophys. 541, C1 source"},{"id":291,"pagetitle":"Functions","title":"ERFA.ltpecl","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.ltpecl","content":" ERFA.ltpecl  —  Function ltpecl(epj) Long-term precession of the ecliptic. Given epj : Julian epoch (TT) Returned vec : Ecliptic pole unit vector Notes The returned vector is with respect to the J2000.0 mean equator and equinox. The Vondrak et al. (2011, 2012) 400 millennia precession model agrees with the IAU 2006 precession at J2000.0 and stays within 100 microarcseconds during the 20th and 21st centuries.  It is accurate to a few arcseconds throughout the historical period, worsening to a few tenths of a degree at the end of the +/- 200,000 year time span. References Vondrak, J., Capitaine, N. and Wallace, P., 2011, New precession   expressions, valid for long time intervals, Astron.Astrophys. 534,   A22 Vondrak, J., Capitaine, N. and Wallace, P., 2012, New precession   expressions, valid for long time intervals (Corrigendum),   Astron.Astrophys. 541, C1 source"},{"id":292,"pagetitle":"Functions","title":"ERFA.ltpequ","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.ltpequ","content":" ERFA.ltpequ  —  Function ltpequ(epj) Long-term precession of the equator. Given epj : Julian epoch (TT) Returned veq : Equator pole unit vector Notes The returned vector is with respect to the J2000.0 mean equator and equinox. The Vondrak et al. (2011, 2012) 400 millennia precession model agrees with the IAU 2006 precession at J2000.0 and stays within 100 microarcseconds during the 20th and 21st centuries.  It is accurate to a few arcseconds throughout the historical period, worsening to a few tenths of a degree at the end of the +/- 200,000 year time span. References Vondrak, J., Capitaine, N. and Wallace, P., 2011, New precession   expressions, valid for long time intervals, Astron.Astrophys. 534,   A22 Vondrak, J., Capitaine, N. and Wallace, P., 2012, New precession   expressions, valid for long time intervals (Corrigendum),   Astron.Astrophys. 541, C1 source"},{"id":293,"pagetitle":"Functions","title":"ERFA.moon98","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.moon98-Tuple{Any, Any}","content":" ERFA.moon98  —  Method moon98(date1, date2) Approximate geocentric position and velocity of the Moon. n.b. Not IAU-endorsed and without canonical status. Given date1 : TT date part A (Notes 1,4) date2 : TT date part B (Notes 1,4) Returned pv : Moon p,v, GCRS (AU, AU/d, Note 5) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience.  The limited accuracy of the present algorithm is such that any of the methods is satisfactory. This function is a full implementation of the algorithm published by Meeus (see reference) except that the light-time correction to the Moon's mean longitude has been omitted. Comparisons with ELP/MPP02 over the interval 1950-2100 gave RMS errors of 2.9 arcsec in geocentric direction, 6.1 km in position and 36 mm/s in velocity.  The worst case errors were 18.3 arcsec in geocentric direction, 31.7 km in position and 172 mm/s in velocity. The original algorithm is expressed in terms of \"dynamical time\", which can either be TDB or TT without any significant change in accuracy.  UT cannot be used without incurring significant errors (30 arcsec in the present era) due to the Moon's 0.5 arcsec/sec movement. The result is with respect to the GCRS (the same as J2000.0 mean equator and equinox to within 23 mas). Velocity is obtained by a complete analytical differentiation of the Meeus model. The Meeus algorithm generates position and velocity in mean ecliptic coordinates of date, which the present function then rotates into GCRS.  Because the ecliptic system is precessing, there is a coupling between this spin (about 1.4 degrees per century) and the Moon position that produces a small velocity contribution.  In the present function this effect is neglected as it corresponds to a maximum difference of less than 3 mm/s and increases the RMS error by only 0.4%. References Meeus, J., Astronomical Algorithms, 2nd edition, Willmann-Bell, 1998, p337. Simon, J.L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou, G. & Laskar, J., Astron.Astrophys., 1994, 282, 663 Called s2pv : spherical coordinates to pv-vector pfw06 : bias-precession F-W angles, IAU 2006 ir : initialize r-matrix to identity rz : rotate around Z-axis rx : rotate around X-axis rxpv : product of r-matrix and pv-vector source"},{"id":294,"pagetitle":"Functions","title":"ERFA.num00a","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.num00a","content":" ERFA.num00a  —  Function num00a(date1, date2) Form the matrix of nutation for a given date, IAU 2000A model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned rmatn : Nutation matrix Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix operates in the sense V(true) = rmatn * V(mean), where the p-vector V(true) is with respect to the true equatorial triad of date and the p-vector V(mean) is with respect to the mean equatorial triad of date. A faster, but slightly less accurate result (about 1 mas), can be obtained by using instead the  num00b  function. Called pn00a : bias/precession/nutation, IAU 2000A Reference Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992),   Section 3.222-3 (p114). source"},{"id":295,"pagetitle":"Functions","title":"ERFA.num00b","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.num00b","content":" ERFA.num00b  —  Function num00b(date1, date2) Form the matrix of nutation for a given date, IAU 2000B model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned rmatn : Nutation matrix Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix operates in the sense V(true) = rmatn * V(mean), where the p-vector V(true) is with respect to the true equatorial triad of date and the p-vector V(mean) is with respect to the mean equatorial triad of date. The present function is faster, but slightly less accurate (about 1 mas), than the  num00a  function. Called pn00b : bias/precession/nutation, IAU 2000B Reference Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992),   Section 3.222-3 (p114). source"},{"id":296,"pagetitle":"Functions","title":"ERFA.num06a","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.num06a","content":" ERFA.num06a  —  Function num06a(date1, date2) Form the matrix of nutation for a given date, IAU 2006/2000A model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned rmatn : Nutation matrix Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix operates in the sense V(true) = rmatn * V(mean), where the p-vector V(true) is with respect to the true equatorial triad of date and the p-vector V(mean) is with respect to the mean equatorial triad of date. Called obl06 : mean obliquity, IAU 2006 nut06a : nutation, IAU 2006/2000A numat : form nutation matrix Reference Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992),   Section 3.222-3 (p114). source"},{"id":297,"pagetitle":"Functions","title":"ERFA.numat","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.numat-Tuple{Any, Any, Any}","content":" ERFA.numat  —  Method numat(epsa, dpsi, deps) Form the matrix of nutation. Given epsa : Mean obliquity of date (Note 1) dpsi ,  deps : Nutation (Note 2) Returned rmatn : Nutation matrix (Note 3) Notes The supplied mean obliquity epsa, must be consistent with the precession-nutation models from which dpsi and deps were obtained. The caller is responsible for providing the nutation components; they are in longitude and obliquity, in radians and are with respect to the equinox and ecliptic of date. The matrix operates in the sense V(true) = rmatn * V(mean), where the p-vector V(true) is with respect to the true equatorial triad of date and the p-vector V(mean) is with respect to the mean equatorial triad of date. Called ir : initialize r-matrix to identity rx : rotate around X-axis rz : rotate around Z-axis Reference Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992),   Section 3.222-3 (p114). source"},{"id":298,"pagetitle":"Functions","title":"ERFA.nut00a","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.nut00a","content":" ERFA.nut00a  —  Function nut00a(date1, date2) Nutation, IAU 2000A model (MHB2000 luni-solar and planetary nutation with free core nutation omitted). Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned dpsi ,  deps : Nutation, luni-solar + planetary (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The nutation components in longitude and obliquity are in radians and with respect to the equinox and ecliptic of date.  The obliquity at J2000.0 is assumed to be the Lieske et al. (1977) value of 84381.448 arcsec. Both the luni-solar and planetary nutations are included.  The latter are due to direct planetary nutations and the perturbations of the lunar and terrestrial orbits. The function computes the MHB2000 nutation series with the associated corrections for planetary nutations.  It is an implementation of the nutation part of the IAU 2000A precession- nutation model, formally adopted by the IAU General Assembly in 2000, namely MHB2000 (Mathews et al. 2002), but with the free core nutation (FCN - see Note 4) omitted. The full MHB2000 model also contains contributions to the nutations in longitude and obliquity due to the free-excitation of the free-core-nutation during the period 1979-2000.  These FCN terms, which are time-dependent and unpredictable, are NOT included in the present function and, if required, must be independently computed.  With the FCN corrections included, the present function delivers a pole which is at current epochs accurate to a few hundred microarcseconds.  The omission of FCN introduces further errors of about that size. The present function provides classical nutation.  The MHB2000 algorithm, from which it is adapted, deals also with (i) the offsets between the GCRS and mean poles and (ii) the adjustments in longitude and obliquity due to the changed precession rates. These additional functions, namely frame bias and precession adjustments, are supported by the ERFA functions  bi00   and  pr00 . The MHB2000 algorithm also provides \"total\" nutations, comprising the arithmetic sum of the frame bias, precession adjustments, luni-solar nutation and planetary nutation.  These total nutations can be used in combination with an existing IAU 1976 precession implementation, such as  pmat76 ,  to deliver GCRS- to-true predictions of sub-mas accuracy at current dates. However, there are three shortcomings in the MHB2000 model that must be taken into account if more accurate or definitive results are required (see Wallace 2002): The MHB2000 total nutations are simply arithmetic sums, yet in reality the various components are successive Euler rotations.  This slight lack of rigor leads to cross terms that exceed 1 mas after a century.  The rigorous procedure is to form the GCRS-to-true rotation matrix by applying the bias, precession and nutation in that order. Although the precession adjustments are stated to be with respect to Lieske et al. (1977), the MHB2000 model does not specify which set of Euler angles are to be used and how the adjustments are to be applied.  The most literal and straightforward procedure is to adopt the 4-rotation epsilon 0, psi A, omega A, xi A option, and to add DPSIPR to psi A and DEPSPR to both omega A and eps_A. The MHB2000 model predates the determination by Chapront et al. (2002) of a 14.6 mas displacement between the J2000.0 mean equinox and the origin of the ICRS frame.  It should, however, be noted that neglecting this displacement when calculating star coordinates does not lead to a 14.6 mas change in right ascension, only a small second- order distortion in the pattern of the precession-nutation effect. For these reasons, the ERFA functions do not generate the \"total nutations\" directly, though they can of course easily be generated by calling  bi00 ,  pr00  and the present function and adding the results. The MHB2000 model contains 41 instances where the same frequency appears multiple times, of which 38 are duplicates and three are triplicates.  To keep the present code close to the original MHB algorithm, this small inefficiency has not been corrected. Called fal03 : mean anomaly of the Moon faf03 : mean argument of the latitude of the Moon faom03 : mean longitude of the Moon's ascending node fame03 : mean longitude of Mercury fave03 : mean longitude of Venus fae03 : mean longitude of Earth fama03 : mean longitude of Mars faju03 : mean longitude of Jupiter fasa03 : mean longitude of Saturn faur03 : mean longitude of Uranus fapa03 : general accumulated precession in longitude References Chapront, J., Chapront-Touze, M. & Francou, G. 2002,   Astron.Astrophys. 387, 700 Lieske, J.H., Lederle, T., Fricke, W. & Morando, B. 1977,   Astron.Astrophys. 58, 1-16 Mathews, P.M., Herring, T.A., Buffet, B.A. 2002, J.Geophys.Res.   107, B4.  The MHB_2000 code itself was obtained on 9th September   2002 from ftp//maia.usno.navy.mil/conv2000/chapter5/IAU2000A. Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683 Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M. 1999,   Astron.Astrophys.Supp.Ser. 135, 111 Wallace, P.T., \"Software for Implementing the IAU 2000   Resolutions\", in IERS Workshop 5.1 (2002) source"},{"id":299,"pagetitle":"Functions","title":"ERFA.nut00b","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.nut00b","content":" ERFA.nut00b  —  Function nut00b(date1, date2) Nutation, IAU 2000B model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned dpsi ,  deps : Nutation, luni-solar + planetary (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The nutation components in longitude and obliquity are in radians and with respect to the equinox and ecliptic of date.  The obliquity at J2000.0 is assumed to be the Lieske et al. (1977) value of 84381.448 arcsec.  (The errors that result from using this function with the IAU 2006 value of 84381.406 arcsec can be neglected.) The nutation model consists only of luni-solar terms, but includes also a fixed offset which compensates for certain long- period planetary terms (Note 7). This function is an implementation of the IAU 2000B abridged nutation model formally adopted by the IAU General Assembly in 2000. The function computes the MHB 2000 SHORT luni-solar nutation series (Luzum 2001), but without the associated corrections for the precession rate adjustments and the offset between the GCRS and J2000.0 mean poles. The full IAU 2000A (MHB2000) nutation model contains nearly 1400 terms.  The IAU 2000B model (McCarthy & Luzum 2003) contains only 77 terms, plus additional simplifications, yet still delivers results of 1 mas accuracy at present epochs.  This combination of accuracy and size makes the IAU 2000B abridged nutation model suitable for most practical applications. The function delivers a pole accurate to 1 mas from 1900 to 2100 (usually better than 1 mas, very occasionally just outside 1 mas).  The full IAU 2000A model, which is implemented in the function  nut00a  (q.v.), delivers considerably greater accuracy at current dates;  however, to realize this improved accuracy, corrections for the essentially unpredictable free-core-nutation (FCN) must also be included. The present function provides classical nutation.  The MHB 2000 SHORT algorithm, from which it is adapted, deals also with (i) the offsets between the GCRS and mean poles and (ii) the adjustments in longitude and obliquity due to the changed precession rates.  These additional functions, namely frame bias and precession adjustments, are supported by the ERFA functions  bi00   and  pr00 . The MHB 2000 SHORT algorithm also provides \"total\" nutations, comprising the arithmetic sum of the frame bias, precession adjustments, and nutation (luni-solar + planetary).  These total nutations can be used in combination with an existing IAU 1976 precession implementation, such as  pmat76 ,  to deliver GCRS- to-true predictions of mas accuracy at current epochs.  However, for symmetry with the  nut00a   function (q.v. for the reasons), the ERFA functions do not generate the \"total nutations\" directly.  Should they be required, they could of course easily be generated by calling  bi00 ,  pr00  and the present function and adding the results. The IAU 2000B model includes \"planetary bias\" terms that are fixed in size but compensate for long-period nutations.  The amplitudes quoted in McCarthy & Luzum (2003), namely Dpsi = -1.5835 mas and Depsilon = +1.6339 mas, are optimized for the \"total nutations\" method described in Note 6.  The Luzum (2001) values used in this ERFA implementation, namely -0.135 mas and +0.388 mas, are optimized for the \"rigorous\" method, where frame bias, precession and nutation are applied separately and in that order.  During the interval 1995-2050, the ERFA implementation delivers a maximum error of 1.001 mas (not including FCN). References Lieske, J.H., Lederle, T., Fricke, W., Morando, B., \"Expressions   for the precession quantities based upon the IAU /1976/ system of   astronomical constants\", Astron.Astrophys. 58, 1-2, 1-16. (1977) Luzum, B., private communication, 2001 (Fortran code   MHB 2000 SHORT) McCarthy, D.D. & Luzum, B.J., \"An abridged model of the   precession-nutation of the celestial pole\", Cel.Mech.Dyn.Astron.   85, 37-49 (2003) Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., Laskar, J., Astron.Astrophys. 282, 663-683 (1994) source"},{"id":300,"pagetitle":"Functions","title":"ERFA.nut06a","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.nut06a","content":" ERFA.nut06a  —  Function nut06a(date1, date2) IAU 2000A nutation with adjustments to match the IAU 2006 precession. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned dpsi ,  deps : Nutation, luni-solar + planetary (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The nutation components in longitude and obliquity are in radians and with respect to the mean equinox and ecliptic of date, IAU 2006 precession model (Hilton et al. 2006, Capitaine et al. 2005). The function first computes the IAU 2000A nutation, then applies adjustments for (i) the consequences of the change in obliquity from the IAU 1980 ecliptic to the IAU 2006 ecliptic and (ii) the secular variation in the Earth's dynamical form factor J2. The present function provides classical nutation, complementing the IAU 2000 frame bias and IAU 2006 precession.  It delivers a pole which is at current epochs accurate to a few tens of microarcseconds, apart from the free core nutation. Called nut00a : nutation, IAU 2000A References Chapront, J., Chapront-Touze, M. & Francou, G. 2002,   Astron.Astrophys. 387, 700 Lieske, J.H., Lederle, T., Fricke, W. & Morando, B. 1977,   Astron.Astrophys. 58, 1-16 Mathews, P.M., Herring, T.A., Buffet, B.A. 2002, J.Geophys.Res.   107, B4.  The MHB_2000 code itself was obtained on 9th September   2002 from ftp//maia.usno.navy.mil/conv2000/chapter5/IAU2000A. Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683 Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M. 1999,   Astron.Astrophys.Supp.Ser. 135, 111 Wallace, P.T., \"Software for Implementing the IAU 2000   Resolutions\", in IERS Workshop 5.1 (2002) source"},{"id":301,"pagetitle":"Functions","title":"ERFA.nut80","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.nut80","content":" ERFA.nut80  —  Function nut80(date1, date2) Nutation, IAU 1980 model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned dpsi : Nutation in longitude (radians) deps : Nutation in obliquity (radians) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The nutation components are with respect to the ecliptic of date. Called anpm : normalize angle into range +/- pi Reference Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992),   Section 3.222 (p111). source"},{"id":302,"pagetitle":"Functions","title":"ERFA.nutm80","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.nutm80","content":" ERFA.nutm80  —  Function nutm80(date1, date2) Form the matrix of nutation for a given date, IAU 1980 model. Given date1 ,  date2 : TDB date (Note 1) Returned rmatn : Nutation matrix Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix operates in the sense V(true) = rmatn * V(mean), where the p-vector V(true) is with respect to the true equatorial triad of date and the p-vector V(mean) is with respect to the mean equatorial triad of date. Called nut80 : nutation, IAU 1980 obl80 : mean obliquity, IAU 1980 numat : form nutation matrix source"},{"id":303,"pagetitle":"Functions","title":"ERFA.obl06","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.obl06","content":" ERFA.obl06  —  Function obl06(date1, date2) Mean obliquity of the ecliptic, IAU 2006 precession model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned Obliquity of the ecliptic (radians, Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The result is the angle between the ecliptic and mean equator of date date1+date2. Reference Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351 source"},{"id":304,"pagetitle":"Functions","title":"ERFA.obl80","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.obl80","content":" ERFA.obl80  —  Function obl80(date1, date2) Mean obliquity of the ecliptic, IAU 1980 model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned Obliquity of the ecliptic (radians, Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The result is the angle between the ecliptic and mean equator of date date1+date2. Reference Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992),   Expression 3.222-1 (p114). source"},{"id":305,"pagetitle":"Functions","title":"ERFA.p06e","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.p06e-Tuple{Any, Any}","content":" ERFA.p06e  —  Method p06e(date1, date2) Precession angles, IAU 2006, equinox based. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned (see Note 2) eps0 : epsilon_0 psia : psi_A oma : omega_A bpa : P_A bqa : Q_A pia : pi_A bpia : Pi_A epsa : obliquity epsilon_A chia : chi_A za : z_A zetaa : zeta_A thetaa : theta_A pa : p_A gam : F-W angle gamma_J2000 phi : F-W angle phi_J2000 psi : F-W angle psi_J2000 Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. This function returns the set of equinox based angles for the Capitaine et al. \"P03\" precession theory, adopted by the IAU in 2006. The angles are set out in Table 1 of Hilton et al. (2006): Angle Name Description eps0 epsilon_0 obliquity at J2000.0 psia psi_A luni-solar precession oma omega_A inclination of equator wrt J2000.0 ecliptic bpa P_A ecliptic pole x, J2000.0 ecliptic triad bqa Q_A ecliptic pole -y, J2000.0 ecliptic triad pia pi_A angle between moving and J2000.0 ecliptics bpia Pi_A longitude of ascending node of the ecliptic epsa epsilon_A obliquity of the ecliptic chia chi_A planetary precession za z_A equatorial precession: -3rd 323 Euler angle zetaa zeta_A equatorial precession: -1st 323 Euler angle thetaa theta_A equatorial precession: 2nd 323 Euler angle pa p_A general precession gam gamma_J2000 J2000.0 RA difference of ecliptic poles phi phi_J2000 J2000.0 codeclination of ecliptic pole psi psi_J2000 longitude difference of equator poles, J2000.0 The returned values are all radians. Hilton et al. (2006) Table 1 also contains angles that depend on models distinct from the P03 precession theory itself, namely the IAU 2000A frame bias and nutation.  The quoted polynomials are used in other ERFA functions: xy06   contains the polynomial parts of the X and Y series. s06   contains the polynomial part of the s+XY/2 series. pfw06   implements the series for the Fukushima-Williams angles that are with respect to the GCRS pole (i.e. the variants that include frame bias). The IAU resolution stipulated that the choice of parameterization was left to the user, and so an IAU compliant precession implementation can be constructed using various combinations of the angles returned by the present function. The parameterization used by ERFA is the version of the Fukushima- Williams angles that refers directly to the GCRS pole.  These angles may be calculated by calling the function  pfw06 .  ERFA also supports the direct computation of the CIP GCRS X,Y by series, available by calling  xy06 . The agreement between the different parameterizations is at the 1 microarcsecond level in the present era. When constructing a precession formulation that refers to the GCRS pole rather than the dynamical pole, it may (depending on the choice of angles) be necessary to introduce the frame bias explicitly. It is permissible to re-use the same variable in the returned arguments.  The quantities are stored in the stated order. Reference Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351 Called obl06 : mean obliquity, IAU 2006 source"},{"id":306,"pagetitle":"Functions","title":"ERFA.p2pv","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.p2pv","content":" ERFA.p2pv  —  Function p2pv(p) Deprecated Use  [p, zeros(3)]  instead. Extend a p-vector to a pv-vector by appending a zero velocity. Given p : P-vector Returned pv : Pv-vector Called erfa_cp : copy p-vector zp : zero p-vector source"},{"id":307,"pagetitle":"Functions","title":"ERFA.p2s","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.p2s-Tuple{Any}","content":" ERFA.p2s  —  Method p2s(p) P-vector to spherical polar coordinates. Given p : P-vector Returned theta : Longitude angle (radians) phi : Latitude angle (radians) r : Radial distance Notes If P is null, zero theta, phi and r are returned. At either pole, zero theta is returned. Called c2s : p-vector to spherical pm : modulus of p-vector source"},{"id":308,"pagetitle":"Functions","title":"ERFA.pap","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pap-Tuple{Any, Any}","content":" ERFA.pap  —  Method pap(a, b) Position-angle from two p-vectors. Given a : Direction of reference point b : Direction of point whose PA is required Returned Position angle of b with respect to a (radians) Notes The result is the position angle, in radians, of direction b with respect to direction a.  It is in the range -pi to +pi.  The sense is such that if b is a small distance \"north\" of a the position angle is approximately zero, and if b is a small distance \"east\" of a the position angle is approximately +pi/2. The vectors a and b need not be of unit length. Zero is returned if the two directions are the same or if either vector is null. If vector a is at a pole, the result is ill-defined. Called pn : decompose p-vector into modulus and direction pm : modulus of p-vector pxp : vector product of two p-vectors pmp : p-vector minus p-vector pdp : scalar product of two p-vectors source"},{"id":309,"pagetitle":"Functions","title":"ERFA.pas","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pas-NTuple{4, Any}","content":" ERFA.pas  —  Method pas(al, ap, bl, bp) Position-angle from spherical coordinates. Given al : Longitude of point A (e.g. RA) in radians ap : Latitude of point A (e.g. Dec) in radians bl : Longitude of point B bp : Latitude of point B Returned Position angle of B with respect to A Notes The result is the bearing (position angle), in radians, of point B with respect to point A.  It is in the range -pi to +pi.  The sense is such that if B is a small distance \"east\" of point A, the bearing is approximately +pi/2. Zero is returned if the two points are coincident. source"},{"id":310,"pagetitle":"Functions","title":"ERFA.pb06","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pb06-Tuple{Any, Any}","content":" ERFA.pb06  —  Method pb06(date1, date2) This function forms three Euler angles which implement general precession from epoch J2000.0, using the IAU 2006 model.  Frame bias (the offset between ICRS and mean J2000.0) is included. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned bzeta : 1st rotation: radians cw around z bz : 3rd rotation: radians cw around z btheta : 2nd rotation: radians ccw around y Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The traditional accumulated precession angles zeta A, z A, theta_A cannot be obtained in the usual way, namely through polynomial expressions, because of the frame bias.  The latter means that two of the angles undergo rapid changes near this date.  They are instead the results of decomposing the precession-bias matrix obtained by using the Fukushima-Williams method, which does not suffer from the problem.  The decomposition returns values which can be used in the conventional formulation and which include frame bias. The three angles are returned in the conventional order, which is not the same as the order of the corresponding Euler rotations.  The precession-bias matrix is  R_3(-z) x R_2(+theta) x R_3(-zeta) . Should  zeta_A ,  z_A ,  theta_A  angles be required that do not contain frame bias, they are available by calling the ERFA function  p06e . Called pmat06 : PB matrix, IAU 2006 rz : rotate around Z-axis source"},{"id":311,"pagetitle":"Functions","title":"ERFA.pdp","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pdp","content":" ERFA.pdp  —  Function pdp(a, b) p-vector inner (=scalar=dot) product. Deprecated Use  LinearAlgebra.dot(a, b)  instead. Given a : First p-vector b : Second p-vector Returned $a \\cdot b$ source"},{"id":312,"pagetitle":"Functions","title":"ERFA.pfw06","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pfw06-Tuple{Any, Any}","content":" ERFA.pfw06  —  Method pfw06(date1, date2) Precession angles, IAU 2006 (Fukushima-Williams 4-angle formulation). Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned gamb : F-W angle gamma_bar (radians) phib : F-W angle phi_bar (radians) psib : F-W angle psi_bar (radians) epsa : F-W angle epsilon_A (radians) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. Naming the following points: e = J2000.0 ecliptic pole, p = GCRS pole, E = mean ecliptic pole of date, and P = mean pole of date, the four Fukushima-Williams angles are as follows: gamb = gamma_bar = epE phib = phi_bar = pE psib = psi_bar = pEP epsa = epsilon_A = EP The matrix representing the combined effects of frame bias and precession is: PxB = R_1(-epsa).R_3(-psib).R_1(phib).R_3(gamb) The matrix representing the combined effects of frame bias, precession and nutation is simply: NxPxB = R_1(-epsa-dE).R_3(-psib-dP).R_1(phib).R_3(gamb) where dP and dE are the nutation components with respect to the ecliptic of date. Reference Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351 Called obl06 : mean obliquity, IAU 2006 source"},{"id":313,"pagetitle":"Functions","title":"ERFA.plan94","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.plan94-Tuple{Any, Any, Any}","content":" ERFA.plan94  —  Method plan94(date1, date2, np) Approximate heliocentric position and velocity of a nominated major planet:  Mercury, Venus, EMB, Mars, Jupiter, Saturn, Uranus or Neptune (but not the Earth itself). Given date1 : TDB date part A (Note 1) date2 : TDB date part B (Note 1) np : Planet (1=Mercury, 2=Venus, 3=EMB, 4=Mars,                          5=Jupiter, 6=Saturn, 7=Uranus, 8=Neptune) Returned (argument) Planet  p,v  (heliocentric, J2000.0, au,au/d) Notes The date date1+date2 is in the TDB time scale (in practice TT can be used) and is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TDB)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience.  The limited accuracy of the present algorithm is such that any of the methods is satisfactory. If an np value outside the range 1-8 is supplied, an error status (function value -1) is returned and the pv vector set to zeroes. For np=3 the result is for the Earth-Moon Barycenter.  To obtain the heliocentric position and velocity of the Earth, use instead the ERFA function  epv00 . On successful return, the arrays  p  and  v  contain the following: p : heliocentric position, au v : heliocentric velocity, au/d The reference frame is equatorial and is with respect to the mean equator and equinox of epoch J2000.0. The algorithm is due to J.L. Simon, P. Bretagnon, J. Chapront, M. Chapront-Touze, G. Francou and J. Laskar (Bureau des Longitudes, Paris, France).  From comparisons with JPL ephemeris DE102, they quote the following maximum errors over the interval 1800-2050: Body L (arcsec) B (arcsec) R (km) Mercury 4 1 300 Venus 5 1 800 EMB 6 1 1000 Mars 17 1 7700 Jupiter 71 5 76000 Saturn 81 13 267000 Uranus 86 7 712000 Neptune 11 1 253000 Over the interval 1000-3000, they report that the accuracy is no worse than 1.5 times that over 1800-2050.  Outside 1000-3000 the accuracy declines. Comparisons of the present function with the JPL DE200 ephemeris give the following RMS errors over the interval 1960-2025: Body position (km) velocity (m/s) Mercury 334 0.437 Venus 1060 0.855 EMB 2010 0.815 Mars 7690 1.98 Jupiter 71700 7.70 Saturn 199000 19.4 Uranus 564000 16.4 Neptune 158000 14.4 Comparisons against DE200 over the interval 1800-2100 gave the following maximum absolute differences.  (The results using DE406 were essentially the same.) Body L (arcsec) B (arcsec) R (km) Rdot (m/s) Mercury 7 1 500 0.7 Venus 7 1 1100 0.9 EMB 9 1 1300 1.0 Mars 26 1 9000 2.5 Jupiter 78 6 82000 8.2 Saturn 87 14 263000 24.6 Uranus 86 7 661000 27.4 Neptune 11 2 248000 21.4 The present ERFA re-implementation of the original Simon et al. Fortran code differs from the original in the following respects: C instead of Fortran. The date is supplied in two parts. The result is returned only in equatorial Cartesian form;  the ecliptic longitude, latitude and radius vector are not  returned. The result is in the J2000.0 equatorial frame, not ecliptic. More is done in-line: there are fewer calls to subroutines. Different error/warning status values are used. A different Kepler's-equation-solver is used (avoiding  use of double precision complex). Polynomials in t are nested to minimize rounding errors. Explicit double constants are used to avoid mixed-mode  expressions. None of the above changes affects the result significantly. The returned status indicates the most serious condition encountered during execution of the function.  Illegal np is considered the most serious, overriding failure to converge, which in turn takes precedence over the remote date warning. Called anp : normalize angle into range 0 to 2pi Reference Simon, J.L, Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G., and Laskar, J., Astron. Astrophys. 282, 663 (1994). source"},{"id":314,"pagetitle":"Functions","title":"ERFA.pm","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pm","content":" ERFA.pm  —  Function pm(p) Modulus of p-vector. Deprecated Use  LinearAlgebra.norm  instead. Given p : P-vector Returned Modulus source"},{"id":315,"pagetitle":"Functions","title":"ERFA.pmat00","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pmat00","content":" ERFA.pmat00  —  Function pmat00(date1, date2) Precession matrix (including frame bias) from GCRS to a specified date, IAU 2000 model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned rbp : Bias-precession matrix (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix operates in the sense V(date) = rbp * V(GCRS), where the p-vector V(GCRS) is with respect to the Geocentric Celestial Reference System (IAU, 2000) and the p-vector V(date) is with respect to the mean equatorial triad of the given date. Called bp00 : frame bias and precession matrices, IAU 2000 Reference IAU: Trans. International Astronomical Union, Vol. XXIVB;  Proc.   24th General Assembly, Manchester, UK.  Resolutions B1.3, B1.6.   (2000) source"},{"id":316,"pagetitle":"Functions","title":"ERFA.pmat06","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pmat06","content":" ERFA.pmat06  —  Function pmat06(date1, date2) Precession matrix (including frame bias) from GCRS to a specified date, IAU 2006 model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned rbp : Bias-precession matrix (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix operates in the sense V(date) = rbp * V(GCRS), where the p-vector V(GCRS) is with respect to the Geocentric Celestial Reference System (IAU, 2000) and the p-vector V(date) is with respect to the mean equatorial triad of the given date. Called pfw06 : bias-precession F-W angles, IAU 2006 fw2m : F-W angles to r-matrix References Capitaine, N. & Wallace, P.T., 2006, Astron.Astrophys. 450, 855 Wallace, P.T. & Capitaine, N., 2006, Astron.Astrophys. 459, 981 source"},{"id":317,"pagetitle":"Functions","title":"ERFA.pmat76","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pmat76","content":" ERFA.pmat76  —  Function pmat76(date1, date2) Precession matrix from J2000.0 to a specified date, IAU 1976 model. Given date1 ,  date2 : Ending date, TT (Note 1) Returned rmatp : Precession matrix, J2000.0 -> date1+date2 Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix operates in the sense V(date) = RMATP * V(J2000), where the p-vector V(J2000) is with respect to the mean equatorial triad of epoch J2000.0 and the p-vector V(date) is with respect to the mean equatorial triad of the given date. Though the matrix method itself is rigorous, the precession angles are expressed through canonical polynomials which are valid only for a limited time span.  In addition, the IAU 1976 precession rate is known to be imperfect.  The absolute accuracy of the present formulation is better than 0.1 arcsec from 1960AD to 2040AD, better than 1 arcsec from 1640AD to 2360AD, and remains below 3 arcsec for the whole of the period 500BC to 3000AD.  The errors exceed 10 arcsec outside the range 1200BC to 3900AD, exceed 100 arcsec outside 4200BC to 5600AD and exceed 1000 arcsec outside 6800BC to 8200AD. Called prec76 : accumulated precession angles, IAU 1976 ir : initialize r-matrix to identity rz : rotate around Z-axis ry : rotate around Y-axis cr : copy r-matrix References Lieske, J.H., 1979, Astron.Astrophys. 73, 282.   equations (6) & (7), p283. Kaplan,G.H., 1981. USNO circular no. 163, pA2. source"},{"id":318,"pagetitle":"Functions","title":"ERFA.pmp","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pmp","content":" ERFA.pmp  —  Function pmp(a, b) P-vector subtraction. Deprecated Use  a .- b  instead. Given a : First p-vector b : Second p-vector Returned amb : a - b source"},{"id":319,"pagetitle":"Functions","title":"ERFA.pmpx","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pmpx-NTuple{8, Any}","content":" ERFA.pmpx  —  Method pmpx(rc, dc, pr, pd, px, rv, pmt, vob) Proper motion and parallax. Given rc ,  dc : ICRS RA,Dec at catalog epoch (radians) pr : RA proper motion (radians/year; Note 1) pd : Dec proper motion (radians/year) px : Parallax (arcsec) rv : Radial velocity (km/s, +ve if receding) pmt : Proper motion time interval (SSB, Julian years) vob : SSB to observer vector (au) Returned pco : Coordinate direction (BCRS unit vector) Notes The proper motion in RA is dRA/dt rather than cos(Dec)*dRA/dt. The proper motion time interval is for when the starlight reaches the solar system barycenter. To avoid the need for iteration, the Roemer effect (i.e. the small annual modulation of the proper motion coming from the changing light time) is applied approximately, using the direction of the star at the catalog epoch. References 1984 Astronomical Almanac, pp B39-B41. Urban, S. & Seidelmann, P. K. (eds), Explanatory Supplement to   the Astronomical Almanac, 3rd ed., University Science Books   (2013), Section 7.2. Called pdp : scalar product of two p-vectors pn : decompose p-vector into modulus and direction source"},{"id":320,"pagetitle":"Functions","title":"ERFA.pmsafe","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pmsafe-NTuple{10, Any}","content":" ERFA.pmsafe  —  Method pmsafe(ra1, dec1, pmr1, pmd1, px1, rv1, ep1a, ep1b, ep2a, ep2b) Star proper motion:  update star catalog data for space motion, with special handling to handle the zero parallax case. Given ra1 : Right ascension (radians), before dec1 : Declination (radians), before pmr1 : RA proper motion (radians/year), before pmd1 : Dec proper motion (radians/year), before px1 : Parallax (arcseconds), before rv1 : Radial velocity (km/s, +ve = receding), before ep1a : \"before\" epoch, part A (Note 1) ep1b : \"before\" epoch, part B (Note 1) ep2a : \"after\" epoch, part A (Note 1) ep2b : \"after\" epoch, part B (Note 1) Returned ra2 : Right ascension (radians), after dec2 : Declination (radians), after pmr2 : RA proper motion (radians/year), after pmd2 : Dec proper motion (radians/year), after px2 : Parallax (arcseconds), after rv2 : Radial velocity (km/s, +ve = receding), after Notes The starting and ending TDB epochs ep1a+ep1b and ep2a+ep2b are Julian Dates, apportioned in any convenient way between the two parts (A and B).  For example, JD(TDB)=2450123.7 could be expressed in any of these ways, among others: epNa epNb Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. In accordance with normal star-catalog conventions, the object's right ascension and declination are freed from the effects of secular aberration.  The frame, which is aligned to the catalog equator and equinox, is Lorentzian and centered on the SSB. The proper motions are the rate of change of the right ascension and declination at the catalog epoch and are in radians per TDB Julian year. The parallax and radial velocity are in the same frame. Care is needed with units.  The star coordinates are in radians and the proper motions in radians per Julian year, but the parallax is in arcseconds. The RA proper motion is in terms of coordinate angle, not true angle.  If the catalog uses arcseconds for both RA and Dec proper motions, the RA proper motion will need to be divided by cos(Dec) before use. Straight-line motion at constant speed, in the inertial frame, is assumed. An extremely small (or zero or negative) parallax is overridden to ensure that the object is at a finite but very large distance, but not so large that the proper motion is equivalent to a large but safe speed (about 0.1c using the chosen constant).  A warning status of 1 is added to the status if this action has been taken. If the space velocity is a significant fraction of c (see the constant VMAX in the function  starpv ), it is arbitrarily set to zero.  When this action occurs, 2 is added to the status. The relativistic adjustment carried out in the  starpv  function involves an iterative calculation.  If the process fails to converge within a set number of iterations, 4 is added to the status. Called seps : angle between two points starpm : update star catalog data for space motion source"},{"id":321,"pagetitle":"Functions","title":"ERFA.pn","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pn","content":" ERFA.pn  —  Function pn(p) Convert a p-vector into modulus and unit vector. Deprecated Use  (LinearAlgebra.norm(p), LinearAlgebra.normalize(p))  instead. Given p : P-vector Returned r : Modulus u : Unit vector Notes If p is null, the result is null.  Otherwise the result is a unit vector. It is permissible to re-use the same array for any of the arguments. Called pm : modulus of p-vector zp : zero p-vector sxp : multiply p-vector by scalar source"},{"id":322,"pagetitle":"Functions","title":"ERFA.pn00","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pn00","content":" ERFA.pn00  —  Function pn00(date1, date2, dpsi, deps) Precession-nutation, IAU 2000 model:  a multi-purpose function, supporting classical (equinox-based) use directly and CIO-based use indirectly. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) dpsi ,  deps : Nutation (Note 2) Returned epsa : Mean obliquity (Note 3) rb : Frame bias matrix (Note 4) rp : Precession matrix (Note 5) rbp : Bias-precession matrix (Note 6) rn : Nutation matrix (Note 7) rbpn : GCRS-to-true matrix (Note 8) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The caller is responsible for providing the nutation components; they are in longitude and obliquity, in radians and are with respect to the equinox and ecliptic of date.  For high-accuracy applications, free core nutation should be included as well as any other relevant corrections to the position of the CIP. The returned mean obliquity is consistent with the IAU 2000 precession-nutation models. The matrix rb transforms vectors from GCRS to J2000.0 mean equator and equinox by applying frame bias. The matrix rp transforms vectors from J2000.0 mean equator and equinox to mean equator and equinox of date by applying precession. The matrix rbp transforms vectors from GCRS to mean equator and equinox of date by applying frame bias then precession.  It is the product rp x rb. The matrix rn transforms vectors from mean equator and equinox of date to true equator and equinox of date by applying the nutation (luni-solar + planetary). The matrix rbpn transforms vectors from GCRS to true equator and equinox of date.  It is the product rn x rbp, applying frame bias, precession and nutation in that order. It is permissible to re-use the same array in the returned arguments.  The arrays are filled in the order given. Called pr00 : IAU 2000 precession adjustments obl80 : mean obliquity, IAU 1980 bp00 : frame bias and precession matrices, IAU 2000 cr : copy r-matrix numat : form nutation matrix rxr : product of two r-matrices Reference Capitaine, N., Chapront, J., Lambert, S. and Wallace, P.,   \"Expressions for the Celestial Intermediate Pole and Celestial   Ephemeris Origin consistent with the IAU 2000A precession-   nutation model\", Astron.Astrophys. 400, 1145-1154 (2003) n.b. The celestial ephemeris origin (CEO) was renamed \"celestial   intermediate origin\" (CIO) by IAU 2006 Resolution 2. source"},{"id":323,"pagetitle":"Functions","title":"ERFA.pn00a","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pn00a","content":" ERFA.pn00a  —  Function pn00a(date1, date2) Precession-nutation, IAU 2000A model:  a multi-purpose function, supporting classical (equinox-based) use directly and CIO-based use indirectly. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned dpsi ,  deps : Nutation (Note 2) epsa : Mean obliquity (Note 3) rb : Frame bias matrix (Note 4) rp : Precession matrix (Note 5) rbp : Bias-precession matrix (Note 6) rn : Nutation matrix (Note 7) rbpn : GCRS-to-true matrix (Notes 8,9) Notes The TT date date1+date2 is a Julian Date, apportioned in any  convenient way between the two arguments.  For example,  JD(TT)=2450123.7 could be expressed in any of these ways,  among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in  cases where the loss of several decimal digits of resolution  is acceptable.  The J2000 method is best matched to the way  the argument is handled internally and will deliver the  optimum resolution.  The MJD method and the date & time methods  are both good compromises between resolution and convenience. The nutation components (luni-solar + planetary, IAU 2000A) in  longitude and obliquity are in radians and with respect to the  equinox and ecliptic of date.  Free core nutation is omitted;  for the utmost accuracy, use the  pn00   function, where the  nutation components are caller-specified.  For faster but  slightly less accurate results, use the  pn00b  function. The mean obliquity is consistent with the IAU 2000 precession. The matrix rb transforms vectors from GCRS to J2000.0 mean  equator and equinox by applying frame bias. The matrix rp transforms vectors from J2000.0 mean equator and  equinox to mean equator and equinox of date by applying  precession. The matrix rbp transforms vectors from GCRS to mean equator and  equinox of date by applying frame bias then precession.  It is  the product rp x rb. The matrix rn transforms vectors from mean equator and equinox  of date to true equator and equinox of date by applying the  nutation (luni-solar + planetary). The matrix rbpn transforms vectors from GCRS to true equator and  equinox of date.  It is the product rn x rbp, applying frame  bias, precession and nutation in that order. The X,Y,Z coordinates of the IAU 2000A Celestial Intermediate  Pole are elements (3,1-3) of the GCRS-to-true matrix,  i.e.  rbpn[3,1:3] . It is permissible to re-use the same array in the returned  arguments.  The arrays are filled in the order given. Called nut00a : nutation, IAU 2000A pn00 : bias/precession/nutation results, IAU 2000 Reference Capitaine, N., Chapront, J., Lambert, S. and Wallace, P.,   \"Expressions for the Celestial Intermediate Pole and Celestial   Ephemeris Origin consistent with the IAU 2000A precession-   nutation model\", Astron.Astrophys. 400, 1145-1154 (2003) n.b. The celestial ephemeris origin (CEO) was renamed \"celestial   intermediate origin\" (CIO) by IAU 2006 Resolution 2. source"},{"id":324,"pagetitle":"Functions","title":"ERFA.pn00b","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pn00b","content":" ERFA.pn00b  —  Function pn00b(date1, date2) Precession-nutation, IAU 2000B model:  a multi-purpose function, supporting classical (equinox-based) use directly and CIO-based use indirectly. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned dpsi ,  deps : Nutation (Note 2) epsa : Mean obliquity (Note 3) rb : Frame bias matrix (Note 4) rp : Precession matrix (Note 5) rbp : Bias-precession matrix (Note 6) rn : Nutation matrix (Note 7) rbpn : GCRS-to-true matrix (Notes 8,9) Notes The TT date date1+date2 is a Julian Date, apportioned in any  convenient way between the two arguments.  For example,  JD(TT)=2450123.7 could be expressed in any of these ways,  among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in  cases where the loss of several decimal digits of resolution  is acceptable.  The J2000 method is best matched to the way  the argument is handled internally and will deliver the  optimum resolution.  The MJD method and the date & time methods  are both good compromises between resolution and convenience. The nutation components (luni-solar + planetary, IAU 2000B) in  longitude and obliquity are in radians and with respect to the  equinox and ecliptic of date.  For more accurate results, but  at the cost of increased computation, use the  pn00a  function.  For the utmost accuracy, use the  pn00   function, where the  nutation components are caller-specified. The mean obliquity is consistent with the IAU 2000 precession. The matrix rb transforms vectors from GCRS to J2000.0 mean  equator and equinox by applying frame bias. The matrix rp transforms vectors from J2000.0 mean equator and  equinox to mean equator and equinox of date by applying  precession. The matrix rbp transforms vectors from GCRS to mean equator and  equinox of date by applying frame bias then precession.  It is  the product rp x rb. The matrix rn transforms vectors from mean equator and equinox  of date to true equator and equinox of date by applying the  nutation (luni-solar + planetary). The matrix rbpn transforms vectors from GCRS to true equator and  equinox of date.  It is the product rn x rbp, applying frame  bias, precession and nutation in that order. The X,Y,Z coordinates of the IAU 2000B Celestial Intermediate  Pole are elements (3,1-3) of the GCRS-to-true matrix,  i.e.  rbpn[3,1:3] . It is permissible to re-use the same array in the returned  arguments.  The arrays are filled in the stated order. Called nut00b : nutation, IAU 2000B pn00 : bias/precession/nutation results, IAU 2000 Reference Capitaine, N., Chapront, J., Lambert, S. and Wallace, P.,   \"Expressions for the Celestial Intermediate Pole and Celestial   Ephemeris Origin consistent with the IAU 2000A precession-   nutation model\", Astron.Astrophys. 400, 1145-1154 (2003). n.b. The celestial ephemeris origin (CEO) was renamed \"celestial   intermediate origin\" (CIO) by IAU 2006 Resolution 2. source"},{"id":325,"pagetitle":"Functions","title":"ERFA.pn06","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pn06","content":" ERFA.pn06  —  Function pn06(date1, date2, dpsi, deps) Precession-nutation, IAU 2006 model:  a multi-purpose function, supporting classical (equinox-based) use directly and CIO-based use indirectly. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) dpsi ,  deps : Nutation (Note 2) Returned epsa : Mean obliquity (Note 3) rb : Frame bias matrix (Note 4) rp : Precession matrix (Note 5) rbp : Bias-precession matrix (Note 6) rn : Nutation matrix (Note 7) rbpn : GCRS-to-true matrix (Note 8) Notes The TT date date1+date2 is a Julian Date, apportioned in any  convenient way between the two arguments.  For example,  JD(TT)=2450123.7 could be expressed in any of these ways,  among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in  cases where the loss of several decimal digits of resolution  is acceptable.  The J2000 method is best matched to the way  the argument is handled internally and will deliver the  optimum resolution.  The MJD method and the date & time methods  are both good compromises between resolution and convenience. The caller is responsible for providing the nutation components;  they are in longitude and obliquity, in radians and are with  respect to the equinox and ecliptic of date.  For high-accuracy  applications, free core nutation should be included as well as  any other relevant corrections to the position of the CIP. The returned mean obliquity is consistent with the IAU 2006  precession. The matrix rb transforms vectors from GCRS to J2000.0 mean  equator and equinox by applying frame bias. The matrix rp transforms vectors from J2000.0 mean equator and  equinox to mean equator and equinox of date by applying  precession. The matrix rbp transforms vectors from GCRS to mean equator and  equinox of date by applying frame bias then precession.  It is  the product rp x rb. The matrix rn transforms vectors from mean equator and equinox  of date to true equator and equinox of date by applying the  nutation (luni-solar + planetary). The matrix rbpn transforms vectors from GCRS to true equator and  equinox of date.  It is the product rn x rbp, applying frame  bias, precession and nutation in that order. The X,Y,Z coordinates of the Celestial Intermediate Pole are  elements (3,1-3) of the GCRS-to-true matrix, i.e.  rbpn[3,1:3] . It is permissible to re-use the same array in the returned  arguments.  The arrays are filled in the stated order. Called pfw06 : bias-precession F-W angles, IAU 2006 fw2m : F-W angles to r-matrix cr : copy r-matrix tr : transpose r-matrix rxr : product of two r-matrices References Capitaine, N. & Wallace, P.T., 2006, Astron.Astrophys. 450, 855 Wallace, P.T. & Capitaine, N., 2006, Astron.Astrophys. 459, 981 source"},{"id":326,"pagetitle":"Functions","title":"ERFA.pn06a","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pn06a","content":" ERFA.pn06a  —  Function pn06a(date1, date2) Precession-nutation, IAU 2006/2000A models:  a multi-purpose function, supporting classical (equinox-based) use directly and CIO-based use indirectly. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned dpsi ,  deps : Nutation (Note 2) epsa : Mean obliquity (Note 3) rb : Frame bias matrix (Note 4) rp : Precession matrix (Note 5) rbp : Bias-precession matrix (Note 6) rn : Nutation matrix (Note 7) rbpn : GCRS-to-true matrix (Notes 8,9) Notes The TT date date1+date2 is a Julian Date, apportioned in any  convenient way between the two arguments.  For example,  JD(TT)=2450123.7 could be expressed in any of these ways,  among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in  cases where the loss of several decimal digits of resolution  is acceptable.  The J2000 method is best matched to the way  the argument is handled internally and will deliver the  optimum resolution.  The MJD method and the date & time methods  are both good compromises between resolution and convenience. The nutation components (luni-solar + planetary, IAU 2000A) in  longitude and obliquity are in radians and with respect to the  equinox and ecliptic of date.  Free core nutation is omitted;  for the utmost accuracy, use the  pn06  function, where the  nutation components are caller-specified. The mean obliquity is consistent with the IAU 2006 precession. The matrix rb transforms vectors from GCRS to mean J2000.0 by  applying frame bias. The matrix rp transforms vectors from mean J2000.0 to mean of  date by applying precession. The matrix rbp transforms vectors from GCRS to mean of date by  applying frame bias then precession.  It is the product rp x rb. The matrix rn transforms vectors from mean of date to true of  date by applying the nutation (luni-solar + planetary). The matrix rbpn transforms vectors from GCRS to true of date  (CIP/equinox).  It is the product rn x rbp, applying frame bias,  precession and nutation in that order. The X,Y,Z coordinates of the IAU 2006/2000A Celestial  Intermediate Pole are elements (3,1-3) of the GCRS-to-true  matrix, i.e.  rbpn[3,1:3] . It is permissible to re-use the same array in the returned  arguments.  The arrays are filled in the stated order. Called nut06a : nutation, IAU 2006/2000A pn06 : bias/precession/nutation results, IAU 2006 Reference Capitaine, N. & Wallace, P.T., 2006, Astron.Astrophys. 450, 855 source"},{"id":327,"pagetitle":"Functions","title":"ERFA.pnm00a","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pnm00a","content":" ERFA.pnm00a  —  Function pnm00a(date1, date2) Form the matrix of precession-nutation for a given date (including frame bias), equinox-based, IAU 2000A model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned rbpn : Classical NPB matrix (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix operates in the sense V(date) = rbpn * V(GCRS), where the p-vector V(date) is with respect to the true equatorial triad of date date1+date2 and the p-vector V(GCRS) is with respect to the Geocentric Celestial Reference System (IAU, 2000). A faster, but slightly less accurate result (about 1 mas), can be obtained by using instead the  pnm00b  function. Called pn00a : bias/precession/nutation, IAU 2000A Reference IAU: Trans. International Astronomical Union, Vol. XXIVB;  Proc.   24th General Assembly, Manchester, UK.  Resolutions B1.3, B1.6.   (2000) source"},{"id":328,"pagetitle":"Functions","title":"ERFA.pnm00b","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pnm00b","content":" ERFA.pnm00b  —  Function pnm00b(date1, date2) Form the matrix of precession-nutation for a given date (including frame bias), equinox-based, IAU 2000B model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned rbpn : Bias-precession-nutation matrix (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix operates in the sense V(date) = rbpn * V(GCRS), where the p-vector V(date) is with respect to the true equatorial triad of date date1+date2 and the p-vector V(GCRS) is with respect to the Geocentric Celestial Reference System (IAU, 2000). The present function is faster, but slightly less accurate (about 1 mas), than the  pnm00a  function. Called pn00b : bias/precession/nutation, IAU 2000B Reference IAU: Trans. International Astronomical Union, Vol. XXIVB;  Proc.   24th General Assembly, Manchester, UK.  Resolutions B1.3, B1.6.   (2000) source"},{"id":329,"pagetitle":"Functions","title":"ERFA.pnm06a","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pnm06a","content":" ERFA.pnm06a  —  Function pnm06a(date1, date2) Form the matrix of precession-nutation for a given date (including frame bias), IAU 2006 precession and IAU 2000A nutation models. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned rnpb : Bias-precession-nutation matrix (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix operates in the sense V(date) = rnpb * V(GCRS), where the p-vector V(date) is with respect to the true equatorial triad of date date1+date2 and the p-vector V(GCRS) is with respect to the Geocentric Celestial Reference System (IAU, 2000). Called pfw06 : bias-precession F-W angles, IAU 2006 nut06a : nutation, IAU 2006/2000A fw2m : F-W angles to r-matrix Reference Capitaine, N. & Wallace, P.T., 2006, Astron.Astrophys. 450, 855. source"},{"id":330,"pagetitle":"Functions","title":"ERFA.pnm80","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pnm80","content":" ERFA.pnm80  —  Function pnm80(date1, date2) Form the matrix of precession/nutation for a given date, IAU 1976 precession model, IAU 1980 nutation model. Given date1 ,  date2 : TDB date (Note 1) Returned rmatpn : Combined precession/nutation matrix Notes The TDB date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TDB)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The matrix operates in the sense V(date) = rmatpn * V(J2000), where the p-vector V(date) is with respect to the true equatorial triad of date date1+date2 and the p-vector V(J2000) is with respect to the mean equatorial triad of epoch J2000.0. Called pmat76 : precession matrix, IAU 1976 nutm80 : nutation matrix, IAU 1980 rxr : product of two r-matrices Reference Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992),   Section 3.3 (p145). source"},{"id":331,"pagetitle":"Functions","title":"ERFA.pom00","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pom00-Tuple{Any, Any, Any}","content":" ERFA.pom00  —  Method pom00(xp, yp, sp) Form the matrix of polar motion for a given date, IAU 2000. Given xp ,  yp : Coordinates of the pole (radians, Note 1) sp : The TIO locator s' (radians, Note 2) Returned rpom : Polar-motion matrix (Note 3) Notes The arguments xp and yp are the coordinates (in radians) of the Celestial Intermediate Pole with respect to the International Terrestrial Reference System (see IERS Conventions 2003), measured along the meridians to 0 and 90 deg west respectively. The argument sp is the TIO locator s', in radians, which positions the Terrestrial Intermediate Origin on the equator.  It is obtained from polar motion observations by numerical integration, and so is in essence unpredictable.  However, it is dominated by a secular drift of about 47 microarcseconds per century, and so can be taken into account by using s' = -47*t, where t is centuries since J2000.0.  The function  sp00  implements this approximation. The matrix operates in the sense V(TRS) = rpom * V(CIP), meaning that it is the final rotation when computing the pointing direction to a celestial source. Called ir : initialize r-matrix to identity rz : rotate around Z-axis ry : rotate around Y-axis rx : rotate around X-axis Reference McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":332,"pagetitle":"Functions","title":"ERFA.ppp","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.ppp","content":" ERFA.ppp  —  Function ppp(a, b) P-vector addition. Deprecated Use  a .+ b  instead. Given a : First p-vector b : Second p-vector Returned apb : A + b source"},{"id":333,"pagetitle":"Functions","title":"ERFA.ppsp","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.ppsp","content":" ERFA.ppsp  —  Function ppsp(a, s, b) P-vector plus scaled p-vector. Deprecated Use  a .+ s .* b  instead. Given a : First p-vector s : Scalar (multiplier for b) b : Second p-vector Returned apsb : a + s*b Note It is permissible for any of a, b and apsb to be the same array. Called sxp : multiply p-vector by scalar ppp : p-vector plus p-vector source"},{"id":334,"pagetitle":"Functions","title":"ERFA.pr00","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pr00-Tuple{Any, Any}","content":" ERFA.pr00  —  Method pr00(date1, date2) Precession-rate part of the IAU 2000 precession-nutation models (part of MHB2000). Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned dpsipr ,  depspr : Precession corrections (Notes 2,3) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The precession adjustments are expressed as \"nutation components\", corrections in longitude and obliquity with respect to the J2000.0 equinox and ecliptic. Although the precession adjustments are stated to be with respect to Lieske et al. (1977), the MHB2000 model does not specify which set of Euler angles are to be used and how the adjustments are to be applied.  The most literal and straightforward procedure is to adopt the 4-rotation  epsilon_0 ,  psi_A ,  omega_A ,  xi_A  option, and to add  dpsipr  to  psi_A  and  depspr  to both  omega_A  and  eps_A . This is an implementation of one aspect of the IAU 2000A nutation model, formally adopted by the IAU General Assembly in 2000, namely MHB2000 (Mathews et al. 2002). References Lieske, J.H., Lederle, T., Fricke, W. & Morando, B., \"Expressions   for the precession quantities based upon the IAU (1976) System of   Astronomical Constants\", Astron.Astrophys., 58, 1-16 (1977) Mathews, P.M., Herring, T.A., Buffet, B.A., \"Modeling of nutation   and precession   New nutation series for nonrigid Earth and   insights into the Earth's interior\", J.Geophys.Res., 107, B4, 2002.   The MHB2000 code itself was obtained on 9th September 2002   from ftp://maia.usno.navy.mil/conv2000/chapter5/IAU2000A. Wallace, P.T., \"Software for Implementing the IAU 2000   Resolutions\", in IERS Workshop 5.1 (2002). source"},{"id":335,"pagetitle":"Functions","title":"ERFA.prec76","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.prec76-NTuple{4, Any}","content":" ERFA.prec76  —  Method prec76(date01, date02, date11, date12) IAU 1976 precession model. This function forms the three Euler angles which implement general precession between two dates, using the IAU 1976 model (as for the FK5 catalog). Given date01 ,  date02 : TDB starting date (Note 1) date11 ,  date12 : TDB ending date (Note 1) Returned zeta : 1st rotation: radians cw around z z : 3rd rotation: radians cw around z theta : 2nd rotation: radians ccw around y Notes The dates date01+date02 and date11+date12 are Julian Dates, apportioned in any convenient way between the arguments daten1 and daten2.  For example, JD(TDB)=2450123.7 could be expressed in any of these ways, among others: daten1 daten2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The two dates may be expressed using different methods, but at the risk of losing some resolution. The accumulated precession angles zeta, z, theta are expressed through canonical polynomials which are valid only for a limited time span.  In addition, the IAU 1976 precession rate is known to be imperfect.  The absolute accuracy of the present formulation is better than 0.1 arcsec from 1960AD to 2040AD, better than 1 arcsec from 1640AD to 2360AD, and remains below 3 arcsec for the whole of the period 500BC to 3000AD.  The errors exceed 10 arcsec outside the range 1200BC to 3900AD, exceed 100 arcsec outside 4200BC to 5600AD and exceed 1000 arcsec outside 6800BC to 8200AD. The three angles are returned in the conventional order, which is not the same as the order of the corresponding Euler rotations.  The precession matrix is  R_3(-z) x R_2(+theta) x R_3(-zeta) . Reference Lieske, J.H., 1979, Astron.Astrophys. 73, 282, equations   (6) & (7), p283. source"},{"id":336,"pagetitle":"Functions","title":"ERFA.pv2p","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pv2p","content":" ERFA.pv2p  —  Function pv2p(pv) Discard velocity component of a pv-vector. Deprecated Use  first(pv)  instead. Given pv : Pv-vector Returned p : P-vector Called erfa_cp : copy p-vector source"},{"id":337,"pagetitle":"Functions","title":"ERFA.pv2s","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pv2s-Tuple{Any}","content":" ERFA.pv2s  —  Method pv2s(pv) Convert position/velocity from Cartesian to spherical coordinates. Given pv : Pv-vector Returned theta : Longitude angle (radians) phi : Latitude angle (radians) r : Radial distance td : Rate of change of theta pd : Rate of change of phi rd : Rate of change of r Notes If the position part of pv is null, theta, phi, td and pd are indeterminate.  This is handled by extrapolating the position through unit time by using the velocity part of pv.  This moves the origin without changing the direction of the velocity component.  If the position and velocity components of pv are both null, zeroes are returned for all six results. If the position is a pole, theta, td and pd are indeterminate. In such cases zeroes are returned for all three. source"},{"id":338,"pagetitle":"Functions","title":"ERFA.pvdpv","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pvdpv-Tuple{Any, Any}","content":" ERFA.pvdpv  —  Method pvdpv(a, b) Inner (=scalar=dot) product of two pv-vectors. Given a : First pv-vector b : Second pv-vector Returned adb :  $a \\cdot b$  (see note) Note If the position and velocity components of the two pv-vectors are    ( ap, av ) and ( bp, bv ), the result, a . b, is the pair of    numbers ( ap . bp , ap . bv + av . bp ).  The two numbers are the    dot-product of the two p-vectors and its derivative. Called pdp : scalar product of two p-vectors source"},{"id":339,"pagetitle":"Functions","title":"ERFA.pvm","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pvm","content":" ERFA.pvm  —  Function pvm(pv) Modulus of pv-vector. Deprecated Use  LinearAlgebra.norm.(pv)  instead. Given pv : Pv-vector Returned r : Modulus of position component s : Modulus of velocity component Called pm : modulus of p-vector source"},{"id":340,"pagetitle":"Functions","title":"ERFA.pvmpv","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pvmpv","content":" ERFA.pvmpv  —  Function pvmpv(a, b) Subtract one pv-vector from another. Deprecated Use  a .- b  instead. Given a : First pv-vector b : Second pv-vector Returned amb : A - b Note It is permissible to re-use the same array for any of the    arguments. Called pmp : p-vector minus p-vector source"},{"id":341,"pagetitle":"Functions","title":"ERFA.pvppv","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pvppv","content":" ERFA.pvppv  —  Function pvppv(a, b) Add one pv-vector to another. Deprecated Use  a .+ b  instead. Given a : First pv-vector b : Second pv-vector Returned apb : A + b Note It is permissible to re-use the same array for any of the    arguments. Called ppp : p-vector plus p-vector source"},{"id":342,"pagetitle":"Functions","title":"ERFA.pvstar","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pvstar-Tuple{Any}","content":" ERFA.pvstar  —  Method pvstar(pv) Convert star position+velocity vector to catalog coordinates. Given (Note 1) pv : pv-vector (au, au/day) Returned (Note 2) ra : Right ascension (radians) dec : Declination (radians) pmr : RA proper motion (radians/year) pmd : Dec proper motion (radians/year) px : Parallax (arcsec) rv : Radial velocity (km/s, positive = receding) Notes The specified pv-vector is the coordinate direction (and its rate of change) for the date at which the light leaving the star reached the solar-system barycenter. The star data returned by this function are \"observables\" for an imaginary observer at the solar-system barycenter.  Proper motion and radial velocity are, strictly, in terms of barycentric coordinate time, TCB.  For most practical applications, it is permissible to neglect the distinction between TCB and ordinary \"proper\" time on Earth (TT/TAI).  The result will, as a rule, be limited by the intrinsic accuracy of the proper-motion and radial-velocity data;  moreover, the supplied pv-vector is likely to be merely an intermediate result (for example generated by the function  starpv ), so that a change of time unit will cancel out overall. In accordance with normal star-catalog conventions, the object's right ascension and declination are freed from the effects of secular aberration.  The frame, which is aligned to the catalog equator and equinox, is Lorentzian and centered on the SSB. Summarizing, the specified pv-vector is for most stars almost identical to the result of applying the standard geometrical \"space motion\" transformation to the catalog data.  The differences, which are the subject of the Stumpff paper cited below, are: In stars with significant radial velocity and proper motion, the constantly changing light-time distorts the apparent proper motion.  Note that this is a classical, not a relativistic, effect. The transformation complies with special relativity. Care is needed with units.  The star coordinates are in radians and the proper motions in radians per Julian year, but the parallax is in arcseconds; the radial velocity is in km/s, but the pv-vector result is in au and au/day. The proper motions are the rate of change of the right ascension and declination at the catalog epoch and are in radians per Julian year.  The RA proper motion is in terms of coordinate angle, not true angle, and will thus be numerically larger at high declinations. Straight-line motion at constant speed in the inertial frame is assumed.  If the speed is greater than or equal to the speed of light, the function aborts with an error status. The inverse transformation is performed by the function  starpv . Called pn : decompose p-vector into modulus and direction pdp : scalar product of two p-vectors sxp : multiply p-vector by scalar pmp : p-vector minus p-vector pm : modulus of p-vector ppp : p-vector plus p-vector pv2s : pv-vector to spherical anp : normalize angle into range 0 to 2pi Reference Stumpff, P., 1985, Astron.Astrophys. 144, 232-240. source"},{"id":343,"pagetitle":"Functions","title":"ERFA.pvtob","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pvtob-NTuple{7, Any}","content":" ERFA.pvtob  —  Method pvtob(elong, phi, height, xp, yp, sp, theta) Position and velocity of a terrestrial observing station. Given elong : Longitude (radians, east +ve, Note 1) phi : Latitude (geodetic, radians, Note 1) hm : Height above ref. ellipsoid (geodetic, m) xp ,  yp : Coordinates of the pole (radians, Note 2) sp : The TIO locator s' (radians, Note 2) theta : Earth rotation angle (radians, Note 3) Returned pv : Position/velocity vector (m, m/s, CIRS) Notes The terrestrial coordinates are with respect to the  WGS84  reference ellipsoid. xp and yp are the coordinates (in radians) of the Celestial Intermediate Pole with respect to the International Terrestrial Reference System (see IERS Conventions), measured along the meridians 0 and 90 deg west respectively.  sp is the TIO locator s', in radians, which positions the Terrestrial Intermediate Origin on the equator.  For many applications, xp, yp and (especially) sp can be set to zero. If theta is Greenwich apparent sidereal time instead of Earth rotation angle, the result is with respect to the true equator and equinox of date, i.e. with the x-axis at the equinox rather than the celestial intermediate origin. The velocity units are meters per UT1 second, not per SI second. This is unlikely to have any practical consequences in the modern era. No validation is performed on the arguments.  Error cases that could lead to arithmetic exceptions are trapped by the  gd2gc  function, and the result set to zeros. References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Urban, S. & Seidelmann, P. K. (eds), Explanatory Supplement to   the Astronomical Almanac, 3rd ed., University Science Books   (2013), Section 7.4.3.3. Called gd2gc : geodetic to geocentric transformation pom00 : polar motion matrix trxp : product of transpose of r-matrix and p-vector source"},{"id":344,"pagetitle":"Functions","title":"ERFA.pvu","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pvu-Tuple{Any, Any}","content":" ERFA.pvu  —  Method pvu(dt, pv) Update a pv-vector. Given dt : Time interval pv : Pv-vector Returned upv : P updated, v unchanged Notes \"Update\" means \"refer the position component of the vector to a new date dt time units from the existing date\". The time units of dt must match those of the velocity. It is permissible for pv and upv to be the same array. Called ppsp : p-vector plus scaled p-vector erfa_cp : copy p-vector source"},{"id":345,"pagetitle":"Functions","title":"ERFA.pvup","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pvup-Tuple{Any, Any}","content":" ERFA.pvup  —  Method pvup(dt, pv) Update a pv-vector, discarding the velocity component. Given dt : Time interval pv : Pv-vector Returned p : P-vector Notes \"Update\" means \"refer the position component of the vector to a new date dt time units from the existing date\". The time units of dt must match those of the velocity. source"},{"id":346,"pagetitle":"Functions","title":"ERFA.pvxpv","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pvxpv-Tuple{Any, Any}","content":" ERFA.pvxpv  —  Method pvxpv(a, b) Outer (=vector=cross) product of two pv-vectors. Given a : First pv-vector b : Second pv-vector Returned axb : A x b Notes If the position and velocity components of the two pv-vectors are ( ap, av ) and ( bp, bv ), the result, a x b, is the pair of vectors ( ap x bp, ap x bv + av x bp ).  The two vectors are the cross-product of the two p-vectors and its derivative. It is permissible to re-use the same array for any of the arguments. Called cpv : copy pv-vector pxp : vector product of two p-vectors ppp : p-vector plus p-vector source"},{"id":347,"pagetitle":"Functions","title":"ERFA.pxp","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.pxp","content":" ERFA.pxp  —  Function pxp(a, b) p-vector outer (=vector=cross) product. Deprecated Use  LinearAlgebra.cross  instead. Given a : First p-vector b : Second p-vector Returned axb : A x b source"},{"id":348,"pagetitle":"Functions","title":"ERFA.refco","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.refco-NTuple{4, Any}","content":" ERFA.refco  —  Method refco(phpa, tc, rh, wl) Determine the constants A and B in the atmospheric refraction model dZ = A tan Z + B tan^3 Z. Z is the \"observed\" zenith distance (i.e. affected by refraction) and dZ is what to add to Z to give the \"topocentric\" (i.e. in vacuo) zenith distance. Given phpa : Pressure at the observer (hPa = millibar) tc : Ambient temperature at the observer (deg C) rh : Relative humidity at the observer (range 0-1) wl : Wavelength (micrometers) Returned refa : tan Z coefficient (radians) refb : tan^3 Z coefficient (radians) Notes The model balances speed and accuracy to give good results in applications where performance at low altitudes is not paramount. Performance is maintained across a range of conditions, and applies to both optical/IR and radio. The model omits the effects of (i) height above sea level (apart from the reduced pressure itself), (ii) latitude (i.e. the flattening of the Earth), (iii) variations in tropospheric lapse rate and (iv) dispersive effects in the radio. The model was tested using the following range of conditions: lapse rates 0.0055, 0.0065, 0.0075 deg/meter latitudes 0, 25, 50, 75 degrees heights 0, 2500, 5000 meters ASL pressures mean for height -10% to +5% in steps of 5% temperatures -10 deg to +20 deg with respect to 280 deg at SL relative humidity 0, 0.5, 1 wavelengths 0.4, 0.6, ... 2 micron, + radio zenith distances 15, 45, 75 degrees The accuracy with respect to raytracing through a model atmosphere was as follows: worst RMS optical/IR 62 mas 8 mas radio 319 mas 49 mas For this particular set of conditions: lapse rate 0.0065 K/meter latitude 50 degrees sea level pressure 1005 mb temperature 280.15 K humidity 80% wavelength 5740 Angstroms the results were as follows: ZD raytrace refco Saastamoinen 10 10.27 10.27 10.27 20 21.19 21.20 21.19 30 33.61 33.61 33.60 40 48.82 48.83 48.81 45 58.16 58.18 58.16 50 69.28 69.30 69.27 55 82.97 82.99 82.95 60 100.51 100.54 100.50 65 124.23 124.26 124.20 70 158.63 158.68 158.61 72 177.32 177.37 177.31 74 200.35 200.38 200.32 76 229.45 229.43 229.42 78 267.44 267.29 267.41 80 319.13 318.55 319.10 deg arcsec arcsec arcsec The values for Saastamoinen's formula (which includes terms up to tan^5) are taken from Hohenkerk and Sinclair (1985). A wl value in the range 0-100 selects the optical/IR case and is wavelength in micrometers.  Any value outside this range selects the radio case. Outlandish input parameters are silently limited to mathematically safe values.  Zero pressure is permissible, and causes zeroes to be returned. The algorithm draws on several sources, as follows: The formula for the saturation vapour pressure of water as a function of temperature and temperature is taken from Equations (A4.5-A4.7) of Gill (1982). The formula for the water vapour pressure, given the saturation pressure and the relative humidity, is from Crane (1976), Equation (2.5.5). The refractivity of air is a function of temperature, total pressure, water-vapour pressure and, in the case of optical/IR, wavelength.  The formulae for the two cases are developed from Hohenkerk & Sinclair (1985) and Rueger (2002). The formula for beta, the ratio of the scale height of the atmosphere to the geocentric distance of the observer, is an adaption of Equation (9) from Stone (1996).  The adaptations, arrived at empirically, consist of (i) a small adjustment to the coefficient and (ii) a humidity term for the radio case only. The formulae for the refraction constants as a function of n-1 and beta are from Green (1987), Equation (4.31). References Crane, R.K., Meeks, M.L. (ed), \"Refraction Effects in the Neutral   Atmosphere\", Methods of Experimental Physics: Astrophysics 12B,   Academic Press, 1976. Gill, Adrian E., \"Atmosphere-Ocean Dynamics\", Academic Press, 1982. Green, R.M., \"Spherical Astronomy\", Cambridge University Press, 1987. Hohenkerk, C.Y., & Sinclair, A.T., NAO Technical Note No. 63, 1985. Rueger, J.M., \"Refractive Index Formulae for Electronic Distance   Measurement with Radio and Millimetre Waves\", in Unisurv Report   S-68, School of Surveying and Spatial Information Systems,   University of New South Wales, Sydney, Australia, 2002. Stone, Ronald C., P.A.S.P. 108, 1051-1058, 1996. source"},{"id":349,"pagetitle":"Functions","title":"ERFA.rm2v","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.rm2v-Tuple{Any}","content":" ERFA.rm2v  —  Method rm2v(r) Express an r-matrix as an r-vector. Given r : Rotation matrix Returned w : Rotation vector (Note 1) Notes A rotation matrix describes a rotation through some angle about some arbitrary axis called the Euler axis.  The \"rotation vector\" returned by this function has the same direction as the Euler axis, and its magnitude is the angle in radians.  (The magnitude and direction can be separated by means of the function  pn .) If r is null, so is the result.  If r is not a rotation matrix the result is undefined;  r must be proper (i.e. have a positive determinant) and real orthogonal (inverse = transpose). The reference frame rotates clockwise as seen looking along the rotation vector from the origin. source"},{"id":350,"pagetitle":"Functions","title":"ERFA.rv2m","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.rv2m-Tuple{Any}","content":" ERFA.rv2m  —  Method rv2m(w) Form the r-matrix corresponding to a given r-vector. Given w : Rotation vector (Note 1) Returned r : Rotation matrix Notes A rotation matrix describes a rotation through some angle about some arbitrary axis called the Euler axis.  The \"rotation vector\" supplied to This function has the same direction as the Euler axis, and its magnitude is the angle in radians. If w is null, the unit matrix is returned. The reference frame rotates clockwise as seen looking along the rotation vector from the origin. source"},{"id":351,"pagetitle":"Functions","title":"ERFA.rx","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.rx","content":" ERFA.rx  —  Function rx(phi, r) Rotate an r-matrix about the x-axis. Given phi : Angle (radians) Given and returned r : r-matrix, rotated Notes Calling this function with positive phi incorporates in the supplied r-matrix r an additional rotation, about the x-axis, anticlockwise as seen looking towards the origin from positive x. The additional rotation can be represented by this matrix: (  1        0            0      )\n(                               )\n(  0   + cos(phi)   + sin(phi)  )\n(                               )\n(  0   - sin(phi)   + cos(phi)  ) source"},{"id":352,"pagetitle":"Functions","title":"ERFA.rxp","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.rxp","content":" ERFA.rxp  —  Function rxp(r, p) Multiply a p-vector by an r-matrix. Deprecated Use  r * p  instead. Given r : R-matrix p : P-vector Returned rp : r * p Note It is permissible for p and rp to be the same array. Called erfa_cp : copy p-vector source"},{"id":353,"pagetitle":"Functions","title":"ERFA.rxpv","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.rxpv","content":" ERFA.rxpv  —  Function rxpv(r, pv) Multiply a pv-vector by an r-matrix. Deprecated Use  [r * pv[1], r * pv[2]]  instead. Given r : R-matrix pv : Pv-vector Returned rpv : R * pv Note It is permissible for pv and rpv to be the same array. Called rxp : product of r-matrix and p-vector source"},{"id":354,"pagetitle":"Functions","title":"ERFA.rxr","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.rxr","content":" ERFA.rxr  —  Function rxr(a, b) Multiply two r-matrices. Deprecated Use  a * b  instead. Given a : First r-matrix b : Second r-matrix Returned atb : a * b Note It is permissible to re-use the same array for any of the    arguments. Called cr : copy r-matrix source"},{"id":355,"pagetitle":"Functions","title":"ERFA.ry","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.ry","content":" ERFA.ry  —  Function ry(phi, r) Rotate an r-matrix about the y-axis. Given theta : Angle (radians) Given and returned r : r-matrix, rotated Notes Calling this function with positive theta incorporates in the supplied r-matrix r an additional rotation, about the y-axis, anticlockwise as seen looking towards the origin from positive y. The additional rotation can be represented by this matrix: (  + cos(theta)     0      - sin(theta)  )\n(                                        )\n(       0           1           0        )\n(                                        )\n(  + sin(theta)     0      + cos(theta)  ) source"},{"id":356,"pagetitle":"Functions","title":"ERFA.rz","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.rz","content":" ERFA.rz  —  Function rz(phi, r) Rotate an r-matrix about the z-axis. Given psi : Angle (radians) Given and returned r : r-matrix, rotated Notes Calling this function with positive psi incorporates in the supplied r-matrix r an additional rotation, about the z-axis, anticlockwise as seen looking towards the origin from positive z. The additional rotation can be represented by this matrix: (  + cos(psi)   + sin(psi)     0  )\n(                                 )\n(  - sin(psi)   + cos(psi)     0  )\n(                                 )\n(       0            0         1  ) source"},{"id":357,"pagetitle":"Functions","title":"ERFA.s00","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.s00","content":" ERFA.s00  —  Function s00(date1, date2, x, y) The CIO locator s, positioning the Celestial Intermediate Origin on the equator of the Celestial Intermediate Pole, given the CIP's X,Y coordinates.  Compatible with IAU 2000A precession-nutation. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) x ,  y : CIP coordinates (Note 3) Returned The CIO locator s in radians (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The CIO locator s is the difference between the right ascensions of the same point in two systems:  the two systems are the GCRS and the CIP,CIO, and the point is the ascending node of the CIP equator.  The quantity s remains below 0.1 arcsecond throughout 1900-2100. The series used to compute s is in fact for s+XY/2, where X and Y are the x and y components of the CIP unit vector;  this series is more compact than a direct series for s would be.  This function requires X,Y to be supplied by the caller, who is responsible for providing values that are consistent with the supplied date. The model is consistent with the IAU 2000A precession-nutation. Called fal03 : mean anomaly of the Moon falp03 : mean anomaly of the Sun faf03 : mean argument of the latitude of the Moon fad03 : mean elongation of the Moon from the Sun faom03 : mean longitude of the Moon's ascending node fave03 : mean longitude of Venus fae03 : mean longitude of Earth fapa03 : general accumulated precession in longitude References Capitaine, N., Chapront, J., Lambert, S. and Wallace, P.,   \"Expressions for the Celestial Intermediate Pole and Celestial   Ephemeris Origin consistent with the IAU 2000A precession-   nutation model\", Astron.Astrophys. 400, 1145-1154 (2003) n.b. The celestial ephemeris origin (CEO) was renamed \"celestial   intermediate origin\" (CIO) by IAU 2006 Resolution 2. McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":358,"pagetitle":"Functions","title":"ERFA.s00a","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.s00a","content":" ERFA.s00a  —  Function s00a(date1, date2) The CIO locator s, positioning the Celestial Intermediate Origin on the equator of the Celestial Intermediate Pole, using the IAU 2000A precession-nutation model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned The CIO locator s in radians (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The CIO locator s is the difference between the right ascensions of the same point in two systems.  The two systems are the GCRS and the CIP,CIO, and the point is the ascending node of the CIP equator.  The CIO locator s remains a small fraction of 1 arcsecond throughout 1900-2100. The series used to compute s is in fact for s+XY/2, where X and Y are the x and y components of the CIP unit vector;  this series is more compact than a direct series for s would be.  The present function uses the full IAU 2000A nutation model when predicting the CIP position.  Faster results, with no significant loss of accuracy, can be obtained via the function  s00b , which uses instead the IAU 2000B truncated model. Called pnm00a : classical NPB matrix, IAU 2000A bpn2xy : extract CIP X,Y from the BPN matrix s00 : the CIO locator s, given X,Y, IAU 2000A References Capitaine, N., Chapront, J., Lambert, S. and Wallace, P.,   \"Expressions for the Celestial Intermediate Pole and Celestial   Ephemeris Origin consistent with the IAU 2000A precession-   nutation model\", Astron.Astrophys. 400, 1145-1154 (2003) n.b. The celestial ephemeris origin (CEO) was renamed \"celestial   intermediate origin\" (CIO) by IAU 2006 Resolution 2. McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":359,"pagetitle":"Functions","title":"ERFA.s00b","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.s00b","content":" ERFA.s00b  —  Function s00b(date1, date2) The CIO locator s, positioning the Celestial Intermediate Origin on the equator of the Celestial Intermediate Pole, using the IAU 2000B precession-nutation model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned The CIO locator s in radians (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The CIO locator s is the difference between the right ascensions of the same point in two systems.  The two systems are the GCRS and the CIP,CIO, and the point is the ascending node of the CIP equator.  The CIO locator s remains a small fraction of 1 arcsecond throughout 1900-2100. The series used to compute s is in fact for s+XY/2, where X and Y are the x and y components of the CIP unit vector;  this series is more compact than a direct series for s would be.  The present function uses the IAU 2000B truncated nutation model when predicting the CIP position.  The function  s00a  uses instead the full IAU 2000A model, but with no significant increase in accuracy and at some cost in speed. Called pnm00b : classical NPB matrix, IAU 2000B bpn2xy : extract CIP X,Y from the BPN matrix s00 : the CIO locator s, given X,Y, IAU 2000A References Capitaine, N., Chapront, J., Lambert, S. and Wallace, P.,   \"Expressions for the Celestial Intermediate Pole and Celestial   Ephemeris Origin consistent with the IAU 2000A precession-   nutation model\", Astron.Astrophys. 400, 1145-1154 (2003) n.b. The celestial ephemeris origin (CEO) was renamed \"celestial   intermediate origin\" (CIO) by IAU 2006 Resolution 2. McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":360,"pagetitle":"Functions","title":"ERFA.s06","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.s06","content":" ERFA.s06  —  Function s06(date1, date2, x, y) The CIO locator s, positioning the Celestial Intermediate Origin on the equator of the Celestial Intermediate Pole, given the CIP's X,Y coordinates.  Compatible with IAU 2006/2000A precession-nutation. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) x ,  y : CIP coordinates (Note 3) Returned The CIO locator s in radians (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The CIO locator s is the difference between the right ascensions of the same point in two systems:  the two systems are the GCRS and the CIP,CIO, and the point is the ascending node of the CIP equator.  The quantity s remains below 0.1 arcsecond throughout 1900-2100. The series used to compute s is in fact for s+XY/2, where X and Y are the x and y components of the CIP unit vector;  this series is more compact than a direct series for s would be.  This function requires X,Y to be supplied by the caller, who is responsible for providing values that are consistent with the supplied date. The model is consistent with the \"P03\" precession (Capitaine et al. 2003), adopted by IAU 2006 Resolution 1, 2006, and the IAU 2000A nutation (with P03 adjustments). Called fal03 : mean anomaly of the Moon falp03 : mean anomaly of the Sun faf03 : mean argument of the latitude of the Moon fad03 : mean elongation of the Moon from the Sun faom03 : mean longitude of the Moon's ascending node fave03 : mean longitude of Venus fae03 : mean longitude of Earth fapa03 : general accumulated precession in longitude References Capitaine, N., Wallace, P.T. & Chapront, J., 2003, Astron.   Astrophys. 432, 355 McCarthy, D.D., Petit, G. (eds.) 2004, IERS Conventions (2003),   IERS Technical Note No. 32, BKG source"},{"id":361,"pagetitle":"Functions","title":"ERFA.s06a","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.s06a","content":" ERFA.s06a  —  Function s06a(date1, date2) The CIO locator s, positioning the Celestial Intermediate Origin on the equator of the Celestial Intermediate Pole, using the IAU 2006 precession and IAU 2000A nutation models. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned The CIO locator s in radians (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The CIO locator s is the difference between the right ascensions of the same point in two systems.  The two systems are the GCRS and the CIP,CIO, and the point is the ascending node of the CIP equator.  The CIO locator s remains a small fraction of 1 arcsecond throughout 1900-2100. The series used to compute s is in fact for s+XY/2, where X and Y are the x and y components of the CIP unit vector;  this series is more compact than a direct series for s would be.  The present function uses the full IAU 2000A nutation model when predicting the CIP position. Called pnm06a : classical NPB matrix, IAU 2006/2000A bpn2xy : extract CIP X,Y coordinates from NPB matrix s06 : the CIO locator s, given X,Y, IAU 2006 References Capitaine, N., Chapront, J., Lambert, S. and Wallace, P.,   \"Expressions for the Celestial Intermediate Pole and Celestial   Ephemeris Origin consistent with the IAU 2000A precession-   nutation model\", Astron.Astrophys. 400, 1145-1154 (2003) n.b. The celestial ephemeris origin (CEO) was renamed \"celestial   intermediate origin\" (CIO) by IAU 2006 Resolution 2. Capitaine, N. & Wallace, P.T., 2006, Astron.Astrophys. 450, 855 McCarthy, D. D., Petit, G. (eds.), 2004, IERS Conventions (2003),   IERS Technical Note No. 32, BKG Wallace, P.T. & Capitaine, N., 2006, Astron.Astrophys. 459, 981 source"},{"id":362,"pagetitle":"Functions","title":"ERFA.s2c","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.s2c-Tuple{Any, Any}","content":" ERFA.s2c  —  Method s2c(theta, phi) Convert spherical coordinates to Cartesian. Given theta : Longitude angle (radians) phi : Latitude angle (radians) Returned c : Direction cosines source"},{"id":363,"pagetitle":"Functions","title":"ERFA.s2p","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.s2p-Tuple{Any, Any, Any}","content":" ERFA.s2p  —  Method s2p(theta, phi, r) Convert spherical polar coordinates to p-vector. Given theta : Longitude angle (radians) phi : Latitude angle (radians) r : Radial distance Returned p : Cartesian coordinates Called s2c : spherical coordinates to unit vector sxp : multiply p-vector by scalar source"},{"id":364,"pagetitle":"Functions","title":"ERFA.s2pv","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.s2pv-NTuple{6, Any}","content":" ERFA.s2pv  —  Method s2pv(theta, phi, r, td, pd, rd) Convert position/velocity from spherical to Cartesian coordinates. Given theta : Longitude angle (radians) phi : Latitude angle (radians) r : Radial distance td : Rate of change of theta pd : Rate of change of phi rd : Rate of change of r Returned pv : Pv-vector source"},{"id":365,"pagetitle":"Functions","title":"ERFA.s2xpv","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.s2xpv","content":" ERFA.s2xpv  —  Function s2xpv(s1, s2, pv) Multiply a pv-vector by two scalars. Deprecated Use  [s1 .* pv[1], s2 .* pv[2]]  instead. Given s1 : Scalar to multiply position component by s2 : Scalar to multiply velocity component by pv : Pv-vector Returned spv : Pv-vector: p scaled by s1, v scaled by s2 Note It is permissible for pv and spv to be the same array. Called sxp : multiply p-vector by scalar source"},{"id":366,"pagetitle":"Functions","title":"ERFA.sepp","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.sepp-Tuple{Any, Any}","content":" ERFA.sepp  —  Method sepp(a, b) Angular separation between two p-vectors. Given a : First p-vector (not necessarily unit length) b : Second p-vector (not necessarily unit length) Returned Angular separation (radians, always positive) Notes If either vector is null, a zero result is returned. The angular separation is most simply formulated in terms of scalar product.  However, this gives poor accuracy for angles near zero and pi.  The present algorithm uses both cross product and dot product, to deliver full accuracy whatever the size of the angle. Called pxp : vector product of two p-vectors pm : modulus of p-vector pdp : scalar product of two p-vectors source"},{"id":367,"pagetitle":"Functions","title":"ERFA.seps","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.seps-NTuple{4, Any}","content":" ERFA.seps  —  Method seps(al, ap, bl, bp) Angular separation between two sets of spherical coordinates. Given al : First longitude (radians) ap : First latitude (radians) bl : Second longitude (radians) bp : Second latitude (radians) Returned Angular separation (radians) Called s2c : spherical coordinates to unit vector sepp : angular separation between two p-vectors source"},{"id":368,"pagetitle":"Functions","title":"ERFA.sp00","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.sp00","content":" ERFA.sp00  —  Function sp00(date1, date2) The TIO locator s', positioning the Terrestrial Intermediate Origin on the equator of the Celestial Intermediate Pole. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned The TIO locator s' in radians (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The TIO locator s' is obtained from polar motion observations by numerical integration, and so is in essence unpredictable. However, it is dominated by a secular drift of about 47 microarcseconds per century, which is the approximation evaluated by the present function. Reference McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":369,"pagetitle":"Functions","title":"ERFA.starpm","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.starpm-NTuple{10, Any}","content":" ERFA.starpm  —  Method starpm(ra1, dec1, pmr1, pmd1, px1, rv1, ep1a, ep1b, ep2a, ep2b) Star proper motion:  update star catalog data for space motion. Given ra1 : Right ascension (radians), before dec1 : Declination (radians), before pmr1 : RA proper motion (radians/year), before pmd1 : Dec proper motion (radians/year), before px1 : Parallax (arcseconds), before rv1 : Radial velocity (km/s, +ve = receding), before ep1a : \"before\" epoch, part A (Note 1) ep1b : \"before\" epoch, part B (Note 1) ep2a : \"after\" epoch, part A (Note 1) ep2b : \"after\" epoch, part B (Note 1) Returned ra2 : Right ascension (radians), after dec2 : Declination (radians), after pmr2 : RA proper motion (radians/year), after pmd2 : Dec proper motion (radians/year), after px2 : Parallax (arcseconds), after rv2 : Radial velocity (km/s, +ve = receding), after Notes The starting and ending TDB dates ep1a+ep1b and ep2a+ep2b are Julian Dates, apportioned in any convenient way between the two parts (A and B).  For example, JD(TDB)=2450123.7 could be expressed in any of these ways, among others: epna epnb Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. In accordance with normal star-catalog conventions, the object's right ascension and declination are freed from the effects of secular aberration.  The frame, which is aligned to the catalog equator and equinox, is Lorentzian and centered on the SSB. The proper motions are the rate of change of the right ascension and declination at the catalog epoch and are in radians per TDB Julian year. The parallax and radial velocity are in the same frame. Care is needed with units.  The star coordinates are in radians and the proper motions in radians per Julian year, but the parallax is in arcseconds. The RA proper motion is in terms of coordinate angle, not true angle.  If the catalog uses arcseconds for both RA and Dec proper motions, the RA proper motion will need to be divided by cos(Dec) before use. Straight-line motion at constant speed, in the inertial frame, is assumed. An extremely small (or zero or negative) parallax is interpreted to mean that the object is on the \"celestial sphere\", the radius of which is an arbitrary (large) value (see the  starpv  function for the value used).  When the distance is overridden in this way, the status, initially zero, has 1 added to it. If the space velocity is a significant fraction of c (see the constant VMAX in the function  starpv ), it is arbitrarily set to zero.  When this action occurs, 2 is added to the status. The relativistic adjustment carried out in the  starpv  function involves an iterative calculation.  If the process fails to converge within a set number of iterations, 4 is added to the status. Called starpv : star catalog data to space motion pv-vector pvu : update a pv-vector pdp : scalar product of two p-vectors pvstar : space motion pv-vector to star catalog data source"},{"id":370,"pagetitle":"Functions","title":"ERFA.starpv","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.starpv-NTuple{6, Any}","content":" ERFA.starpv  —  Method starpv(ra, dec, pmr, pmd, px, rv) Convert star catalog coordinates to position+velocity vector. Given (Note 1) ra : Right ascension (radians) dec : Declination (radians) pmr : RA proper motion (radians/year) pmd : Dec proper motion (radians/year) px : Parallax (arcseconds) rv : Radial velocity (km/s, positive = receding) Returned (Note 2) pv : pv-vector (au, au/day) Notes The star data accepted by this function are \"observables\" for an imaginary observer at the solar-system barycenter.  Proper motion and radial velocity are, strictly, in terms of barycentric coordinate time, TCB.  For most practical applications, it is permissible to neglect the distinction between TCB and ordinary \"proper\" time on Earth (TT/TAI).  The result will, as a rule, be limited by the intrinsic accuracy of the proper-motion and radial-velocity data;  moreover, the pv-vector is likely to be merely an intermediate result, so that a change of time unit would cancel out overall. In accordance with normal star-catalog conventions, the object's right ascension and declination are freed from the effects of secular aberration.  The frame, which is aligned to the catalog equator and equinox, is Lorentzian and centered on the SSB. The resulting position and velocity pv-vector is with respect to the same frame and, like the catalog coordinates, is freed from the effects of secular aberration.  Should the \"coordinate direction\", where the object was located at the catalog epoch, be required, it may be obtained by calculating the magnitude of the position vector pv[0][0-2] dividing by the speed of light in au/day to give the light-time, and then multiplying the space velocity pv[1][0-2] by this light-time and adding the result to pv[0][0-2]. Summarizing, the pv-vector returned is for most stars almost identical to the result of applying the standard geometrical \"space motion\" transformation.  The differences, which are the subject of the Stumpff paper referenced below, are: In stars with significant radial velocity and proper motion, the constantly changing light-time distorts the apparent proper motion.  Note that this is a classical, not a relativistic, effect. The transformation complies with special relativity. Care is needed with units.  The star coordinates are in radians and the proper motions in radians per Julian year, but the parallax is in arcseconds; the radial velocity is in km/s, but the pv-vector result is in au and au/day. The RA proper motion is in terms of coordinate angle, not true angle.  If the catalog uses arcseconds for both RA and Dec proper motions, the RA proper motion will need to be divided by cos(Dec) before use. Straight-line motion at constant speed, in the inertial frame, is assumed. An extremely small (or zero or negative) parallax is interpreted to mean that the object is on the \"celestial sphere\", the radius of which is an arbitrary (large) value (see the constant PXMIN). When the distance is overridden in this way, the status, initially zero, has 1 added to it. If the space velocity is a significant fraction of c (see the constant VMAX), it is arbitrarily set to zero.  When this action occurs, 2 is added to the status. The relativistic adjustment involves an iterative calculation. If the process fails to converge within a set number (IMAX) of iterations, 4 is added to the status. The inverse transformation is performed by the function  pvstar . Called s2pv : spherical coordinates to pv-vector pm : modulus of p-vector zp : zero p-vector pn : decompose p-vector into modulus and direction pdp : scalar product of two p-vectors sxp : multiply p-vector by scalar pmp : p-vector minus p-vector ppp : p-vector plus p-vector Reference Stumpff, P., 1985, Astron.Astrophys. 144, 232-240. source"},{"id":371,"pagetitle":"Functions","title":"ERFA.sxp","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.sxp","content":" ERFA.sxp  —  Function sxp(s, p) Multiply a p-vector by a scalar. Deprecated Use  s .* p  instead. Given s : Scalar p : P-vector Returned sp : S * p Note It is permissible for p and sp to be the same array. source"},{"id":372,"pagetitle":"Functions","title":"ERFA.sxpv","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.sxpv","content":" ERFA.sxpv  —  Function sxpv(s, pv) Multiply a pv-vector by a scalar. Deprecated Use  s .* pv  instead. Given s : Scalar pv : Pv-vector Returned spv : s * pv Note It is permissible for pv and spv to be the same array Called s2xpv : multiply pv-vector by two scalars source"},{"id":373,"pagetitle":"Functions","title":"ERFA.taitt","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.taitt","content":" ERFA.taitt  —  Function taitt(tai1, tai2) Time scale transformation:  International Atomic Time, TAI, to Terrestrial Time, TT. Given tai1 ,  tai2 : TAI as a 2-part Julian Date Returned tt1 ,  tt2 : TT as a 2-part Julian Date Note tai1+tai2 is Julian Date, apportioned in any convenient way    between the two arguments, for example where tai1 is the Julian    Day Number and tai2 is the fraction of a day.  The returned    tt1,tt2 follow suit. References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992) source"},{"id":374,"pagetitle":"Functions","title":"ERFA.taiut1","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.taiut1","content":" ERFA.taiut1  —  Function taiut1(tai1, tai2, dta) Time scale transformation:  International Atomic Time, TAI, to Universal Time, UT1. Given tai1 ,  tai2 : TAI as a 2-part Julian Date dta : UT1-TAI in seconds Returned ut11 ,  ut12 : UT1 as a 2-part Julian Date Notes tai1+tai2 is Julian Date, apportioned in any convenient way between the two arguments, for example where tai1 is the Julian Day Number and tai2 is the fraction of a day.  The returned UT11,UT12 follow suit. The argument dta, i.e. UT1-TAI, is an observed quantity, and is available from IERS tabulations. Reference Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992) source"},{"id":375,"pagetitle":"Functions","title":"ERFA.taiutc","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.taiutc","content":" ERFA.taiutc  —  Function taiutc(tai1, tai2) Time scale transformation:  International Atomic Time, TAI, to Coordinated Universal Time, UTC. Given tai1 ,  tai2 : TAI as a 2-part Julian Date (Note 1) Returned utc1 ,  utc2 : UTC as a 2-part quasi Julian Date (Notes 1-3) Notes tai1+tai2 is Julian Date, apportioned in any convenient way between the two arguments, for example where tai1 is the Julian Day Number and tai2 is the fraction of a day.  The returned utc1 and utc2 form an analogous pair, except that a special convention is used, to deal with the problem of leap seconds - see the next note. JD cannot unambiguously represent UTC during a leap second unless special measures are taken.  The convention in the present function is that the JD day represents UTC days whether the length is 86399, 86400 or 86401 SI seconds.  In the 1960-1972 era there were smaller jumps (in either direction) each time the linear UTC(TAI) expression was changed, and these \"mini-leaps\" are also included in the ERFA convention. The function  d2dtf  can be used to transform the UTC quasi-JD into calendar date and clock time, including UTC leap second handling. The warning status \"dubious year\" flags UTCs that predate the introduction of the time scale or that are too far in the future to be trusted.  See  dat  for further details. Called utctai : UTC to TAI References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992) source"},{"id":376,"pagetitle":"Functions","title":"ERFA.tcbtdb","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.tcbtdb","content":" ERFA.tcbtdb  —  Function tcbtdb(tcb1, tcb2) Time scale transformation:  Barycentric Coordinate Time, TCB, to Barycentric Dynamical Time, TDB. Given tcb1 ,  tcb2 : TCB as a 2-part Julian Date Returned tdb1 ,  tdb2 : TDB as a 2-part Julian Date Notes tcb1+tcb2 is Julian Date, apportioned in any convenient way between the two arguments, for example where tcb1 is the Julian Day Number and tcb2 is the fraction of a day.  The returned tdb1,tdb2 follow suit. The 2006 IAU General Assembly introduced a conventional linear transformation between TDB and TCB.  This transformation compensates for the drift between TCB and terrestrial time TT, and keeps TDB approximately centered on TT.  Because the relationship between TT and TCB depends on the adopted solar system ephemeris, the degree of alignment between TDB and TT over long intervals will vary according to which ephemeris is used. Former definitions of TDB attempted to avoid this problem by stipulating that TDB and TT should differ only by periodic effects.  This is a good description of the nature of the relationship but eluded precise mathematical formulation.  The conventional linear relationship adopted in 2006 sidestepped these difficulties whilst delivering a TDB that in practice was consistent with values before that date. TDB is essentially the same as Teph, the time argument for the JPL solar system ephemerides. Reference IAU 2006 Resolution B3 source"},{"id":377,"pagetitle":"Functions","title":"ERFA.tcgtt","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.tcgtt","content":" ERFA.tcgtt  —  Function tcgtt(tcg1, tcg2) Time scale transformation:  Geocentric Coordinate Time, TCG, to Terrestrial Time, TT. Given tcg1 ,  tcg2 : TCG as a 2-part Julian Date Returned tt1 ,  tt2 : TT as a 2-part Julian Date Note tcg1+tcg2 is Julian Date, apportioned in any convenient way    between the two arguments, for example where tcg1 is the Julian    Day Number and tcg22 is the fraction of a day.  The returned    tt1,tt2 follow suit. References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),.   IERS Technical Note No. 32, BKG (2004) IAU 2000 Resolution B1.9 source"},{"id":378,"pagetitle":"Functions","title":"ERFA.tdbtcb","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.tdbtcb","content":" ERFA.tdbtcb  —  Function tdbtcb(tdb1, tdb2) Time scale transformation:  Barycentric Dynamical Time, TDB, to Barycentric Coordinate Time, TCB. Given tdb1 ,  tdb2 : TDB as a 2-part Julian Date Returned tcb1 ,  tcb2 : TCB as a 2-part Julian Date Notes tdb1+tdb2 is Julian Date, apportioned in any convenient way between the two arguments, for example where tdb1 is the Julian Day Number and tdb2 is the fraction of a day.  The returned tcb1,tcb2 follow suit. The 2006 IAU General Assembly introduced a conventional linear transformation between TDB and TCB.  This transformation compensates for the drift between TCB and terrestrial time TT, and keeps TDB approximately centered on TT.  Because the relationship between TT and TCB depends on the adopted solar system ephemeris, the degree of alignment between TDB and TT over long intervals will vary according to which ephemeris is used. Former definitions of TDB attempted to avoid this problem by stipulating that TDB and TT should differ only by periodic effects.  This is a good description of the nature of the relationship but eluded precise mathematical formulation.  The conventional linear relationship adopted in 2006 sidestepped these difficulties whilst delivering a TDB that in practice was consistent with values before that date. TDB is essentially the same as Teph, the time argument for the JPL solar system ephemerides. Reference IAU 2006 Resolution B3 source"},{"id":379,"pagetitle":"Functions","title":"ERFA.tdbtt","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.tdbtt","content":" ERFA.tdbtt  —  Function tdbtt(tdb1, tdb2, dtr) Time scale transformation:  Barycentric Dynamical Time, TDB, to Terrestrial Time, TT. Given tdb1 ,  tdb2 : TDB as a 2-part Julian Date dtr : TDB-TT in seconds Returned tt1 ,  tt2 : TT as a 2-part Julian Date Notes tdb1+tdb2 is Julian Date, apportioned in any convenient way between the two arguments, for example where tdb1 is the Julian Day Number and tdb2 is the fraction of a day.  The returned tt1,tt2 follow suit. The argument dtr represents the quasi-periodic component of the GR transformation between TT and TCB.  It is dependent upon the adopted solar-system ephemeris, and can be obtained by numerical integration, by interrogating a precomputed time ephemeris or by evaluating a model such as that implemented in the ERFA function  dtdb .   The quantity is dominated by an annual term of 1.7 ms amplitude. TDB is essentially the same as Teph, the time argument for the JPL solar system ephemerides. References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) IAU 2006 Resolution 3 source"},{"id":380,"pagetitle":"Functions","title":"ERFA.tf2a","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.tf2a","content":" ERFA.tf2a  —  Function tf2a(s, ihour, imin, sec) Convert hours, minutes, seconds to radians. Given s : Sign:  '-' = negative, otherwise positive ihour : Hours imin : Minutes sec : Seconds Returned rad : Angle in radians Notes The result is computed even if any of the range checks fail. Negative ihour, imin and/or sec produce a warning status, but  the absolute value is used in the conversion. If there are multiple errors, the status value reflects only the  first, the smallest taking precedence. source"},{"id":381,"pagetitle":"Functions","title":"ERFA.tf2d","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.tf2d","content":" ERFA.tf2d  —  Function tf2d(s, ihour, imin, sec) Convert hours, minutes, seconds to days. Given s : Sign:  '-' = negative, otherwise positive ihour : Hours imin : Minutes sec : Seconds Returned days : Interval in days Notes The result is computed even if any of the range checks fail. Negative ihour, imin and/or sec produce a warning status, but  the absolute value is used in the conversion. If there are multiple errors, the status value reflects only the  first, the smallest taking precedence. source"},{"id":382,"pagetitle":"Functions","title":"ERFA.tpors","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.tpors-NTuple{4, Any}","content":" ERFA.tpors  —  Method tpors(xi, eta, ra, dec) In the tangent plane projection, given the rectangular coordinates of a star and its spherical coordinates, determine the spherical coordinates of the tangent point. Given xi ,  eta : rectangular coordinates of star image (Note 2) a ,  b : star's spherical coordinates (Note 3) Returned status : number of solutions: 0 = no solutions returned (Note 5) 1 = only the first solution is useful (Note 6) 2 = both solutions are useful (Note 6) a01 ,  b01 : tangent point's spherical coordinates, Soln. 1 a02 ,  b02 : tangent point's spherical coordinates, Soln. 2 Notes The tangent plane projection is also called the \"gnomonic projection\" and the \"central projection\". The eta axis points due north in the adopted coordinate system. If the spherical coordinates are observed (RA,Dec), the tangent plane coordinates (xi,eta) are conventionally called the \"standard coordinates\".  If the spherical coordinates are with respect to a right-handed triad, (xi,eta) are also right-handed. The units of (xi,eta) are, effectively, radians at the tangent point. All angular arguments are in radians. The angles a01 and a02 are returned in the range 0-2pi.  The angles b01 and b02 are returned in the range +/-pi, but in the usual, non-pole-crossing, case, the range is +/-pi/2. Cases where there is no solution can arise only near the poles. For example, it is clearly impossible for a star at the pole itself to have a non-zero xi value, and hence it is meaningless to ask where the tangent point would have to be to bring about this combination of xi and dec. Also near the poles, cases can arise where there are two useful solutions.  The return value indicates whether the second of the two solutions returned is useful;  1 indicates only one useful solution, the usual case. The basis of the algorithm is to solve the spherical triangle PSC, where P is the north celestial pole, S is the star and C is the tangent point.  The spherical coordinates of the tangent point are [a0,b0];  writing rho^2 = (xi^2+eta^2) and r^2 = (1+rho^2), side c is then (pi/2-b), side p is sqrt(xi^2+eta^2) and side s (to be found) is (pi/2-b0).  Angle C is given by sin(C) = xi/rho and cos(C) = eta/rho.  Angle P (to be found) is the longitude difference between star and tangent point (a-a0). This function is a member of the following set: spherical vector solve for tpxes tpxev xi,eta tpsts tpstv star tpors tporv origin Called anp : normalize angle into range 0 to 2pi References Calabretta M.R. & Greisen, E.W., 2002, \"Representations of celestial coordinates in FITS\", Astron.Astrophys. 395, 1077 Green, R.M., \"Spherical Astronomy\", Cambridge University Press, 1987, Chapter 13. source"},{"id":383,"pagetitle":"Functions","title":"ERFA.tporv","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.tporv-Tuple{Any, Any, Any}","content":" ERFA.tporv  —  Method tporv(xi, eta, v) In the tangent plane projection, given the rectangular coordinates of a star and its direction cosines, determine the direction cosines of the tangent point. Given xi ,  eta : rectangular coordinates of star image (Note 2) v : star's direction cosines (Note 3) Returned status : number of solutions: 0 = no solutions returned (Note 4) 1 = only the first solution is useful (Note 5) 2 = both solutions are useful (Note 5) v01 : tangent point's direction cosines, Solution 1 v02 : tangent point's direction cosines, Solution 2 Notes The tangent plane projection is also called the \"gnomonic projection\" and the \"central projection\". The eta axis points due north in the adopted coordinate system. If the direction cosines represent observed (RA,Dec., the tangent plane coordinates (xi,eta. are conventionally called the \"standard coordinates\".  If the direction cosines are with respect to a right-handed triad, (xi,eta. are also right-handed. The units of (xi,eta. are, effectively, radians at the tangent point. The vector v must be of unit length or the result will be wrong. Cases where there is no solution can arise only near the poles. For example, it is clearly impossible for a star at the pole itself to have a non-zero xi value, and hence it is meaningless to ask where the tangent point would have to be. Also near the poles, cases can arise where there are two useful solutions.  The return value indicates whether the second of the two solutions returned is useful;  1 indicates only one useful solution, the usual case. The basis of the algorithm is to solve the spherical triangle PSC, where P is the north celestial pole, S is the star and C is the tangent point.  Calling the celestial spherical coordinates of the star and tangent point (a,b. and (a0,b0) respectively, and writing rho^2 = (xi^2+eta^2. and r^2 = (1+rho^2), and transforming the vector v into (a,b. in the normal way, side c is then (pi/2-b., side p is sqrt(xi^2+eta^2) and side s (to be found. is (pi/2-b0), while angle C is given by sin(C) = xi/rho and cos(C. = eta/rho;  angle P (to be found) is (a-a0).  After solving the spherical triangle, the result (a0,b0. can be expressed in vector form as v0. This function is a member of the following set: spherical vector solve for tpxes tpxev xi,eta tpsts tpstv star tpors tporv origin References Calabretta M.R. & Greisen, E.W., 2002, \"Representations of celestial coordinates in FITS\", Astron.Astrophys. 395, 1077 Green, R.M., \"Spherical Astronomy\", Cambridge University Press, 1987, Chapter 13. source"},{"id":384,"pagetitle":"Functions","title":"ERFA.tpsts","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.tpsts-NTuple{4, Any}","content":" ERFA.tpsts  —  Method tpsts(xi, eta, raz, decz) In the tangent plane projection, given the star's rectangular coordinates and the spherical coordinates of the tangent point, solve for the spherical coordinates of the star. Given xi ,  eta : rectangular coordinates of star image (Note 2) a0 ,  b0 : tangent point's spherical coordinates Returned a ,  b : star's spherical coordinates Notes The tangent plane projection is also called the \"gnomonic projection\" and the \"central projection\". The eta axis points due north in the adopted coordinate system. If the spherical coordinates are observed (RA,Dec), the tangent plane coordinates (xi,eta) are conventionally called the \"standard coordinates\".  If the spherical coordinates are with respect to a right-handed triad, (xi,eta) are also right-handed. The units of (xi,eta) are, effectively, radians at the tangent point. All angular arguments are in radians. This function is a member of the following set: spherical vector solve for tpxes tpxev xi,eta tpsts tpstv star tpors tporv origin Called anp  normalize angle into range 0 to 2pi References Calabretta M.R. & Greisen, E.W., 2002, \"Representations of celestial coordinates in FITS\", Astron.Astrophys. 395, 1077 Green, R.M., \"Spherical Astronomy\", Cambridge University Press, 1987, Chapter 13. source"},{"id":385,"pagetitle":"Functions","title":"ERFA.tpstv","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.tpstv-Tuple{Any, Any, Any}","content":" ERFA.tpstv  —  Method tpstv(xi, eta, vz) In the tangent plane projection, given the star's rectangular coordinates and the direction cosines of the tangent point, solve for the direction cosines of the star. Given xi ,  eta : rectangular coordinates of star image (Note 2) v0 : tangent point's direction cosines Returned v : star's direction cosines Notes The tangent plane projection is also called the \"gnomonic projection\" and the \"central projection\". The eta axis points due north in the adopted coordinate system. If the direction cosines represent observed (RA,Dec), the tangent plane coordinates (xi,eta) are conventionally called the \"standard coordinates\".  If the direction cosines are with respect to a right-handed triad, (xi,eta) are also right-handed. The units of (xi,eta) are, effectively, radians at the tangent point. The method used is to complete the star vector in the (xi,eta) based triad and normalize it, then rotate the triad to put the tangent point at the pole with the x-axis aligned to zero longitude.  Writing (a0,b0) for the celestial spherical coordinates of the tangent point, the sequence of rotations is (b-pi/2) around the x-axis followed by (-a-pi/2) around the z-axis. If vector v0 is not of unit length, the returned vector v will be wrong. If vector v0 points at a pole, the returned vector v will be based on the arbitrary assumption that the longitude coordinate of the tangent point is zero. This function is a member of the following set: spherical vector solve for tpxes tpxev xi,eta tpsts tpstv star tpors tporv origin References Calabretta M.R. & Greisen, E.W., 2002, \"Representations of celestial coordinates in FITS\", Astron.Astrophys. 395, 1077 Green, R.M., \"Spherical Astronomy\", Cambridge University Press, 1987, Chapter 13. source"},{"id":386,"pagetitle":"Functions","title":"ERFA.tpxes","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.tpxes-NTuple{4, Any}","content":" ERFA.tpxes  —  Method tpxes(ra, dec, raz, decz) In the tangent plane projection, given celestial spherical coordinates for a star and the tangent point, solve for the star's rectangular coordinates in the tangent plane. Given a ,  b : star's spherical coordinates a0 ,  b0 : tangent point's spherical coordinates Returned status : 0 = OK 1 = star too far from axis 2 = antistar on tangent plane 3 = antistar too far from axis xi ,  eta : rectangular coordinates of star image (Note 2) Notes The tangent plane projection is also called the \"gnomonic projection\" and the \"central projection\". The eta axis points due north in the adopted coordinate system. If the spherical coordinates are observed (RA,Dec), the tangent plane coordinates (xi,eta) are conventionally called the \"standard coordinates\".  For right-handed spherical coordinates, (xi,eta) are also right-handed.  The units of (xi,eta) are, effectively, radians at the tangent point. All angular arguments are in radians. This function is a member of the following set: spherical vector solve for tpxes tpxev xi,eta tpsts tpstv star tpors tporv origin References Calabretta M.R. & Greisen, E.W., 2002, \"Representations of celestial coordinates in FITS\", Astron.Astrophys. 395, 1077 Green, R.M., \"Spherical Astronomy\", Cambridge University Press, 1987, Chapter 13. source"},{"id":387,"pagetitle":"Functions","title":"ERFA.tpxev","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.tpxev-Tuple{Any, Any}","content":" ERFA.tpxev  —  Method tpxev(v, vz) In the tangent plane projection, given celestial direction cosines for a star and the tangent point, solve for the star's rectangular coordinates in the tangent plane. Given v : direction cosines of star (Note 4) v0 : direction cosines of tangent point (Note 4) Returned status : 0 = OK 1 = star too far from axis 2 = antistar on tangent plane 3 = antistar too far from axis xi ,  eta : tangent plane coordinates of star Notes The tangent plane projection is also called the \"gnomonic projection\" and the \"central projection\". The eta axis points due north in the adopted coordinate system. If the direction cosines represent observed (RA,Dec), the tangent plane coordinates (xi,eta) are conventionally called the \"standard coordinates\".  If the direction cosines are with respect to a right-handed triad, (xi,eta) are also right-handed. The units of (xi,eta) are, effectively, radians at the tangent point. The method used is to extend the star vector to the tangent plane and then rotate the triad so that (x,y) becomes (xi,eta). Writing (a,b) for the celestial spherical coordinates of the star, the sequence of rotations is (a+pi/2) around the z-axis followed by (pi/2-b) around the x-axis. If vector v0 is not of unit length, or if vector v is of zero length, the results will be wrong. If v0 points at a pole, the returned (xi,eta) will be based on the arbitrary assumption that the longitude coordinate of the tangent point is zero. This function is a member of the following set: spherical vector solve for tpxes tpxev xi,eta tpsts tpstv star tpors tporv origin References Calabretta M.R. & Greisen, E.W., 2002, \"Representations of celestial coordinates in FITS\", Astron.Astrophys. 395, 1077 Green, R.M., \"Spherical Astronomy\", Cambridge University Press, 1987, Chapter 13. source"},{"id":388,"pagetitle":"Functions","title":"ERFA.tr","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.tr","content":" ERFA.tr  —  Function tr(r) Transpose an r-matrix. Deprecated Use  r'  instead. Given r : R-matrix Returned rt : Transpose Note It is permissible for r and rt to be the same array. Called cr : copy r-matrix source"},{"id":389,"pagetitle":"Functions","title":"ERFA.trxp","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.trxp","content":" ERFA.trxp  —  Function trxp(r, p) Multiply a p-vector by the transpose of an r-matrix. Deprecated Use  r' * p  instead. Given r : R-matrix p : P-vector Returned trp : R * p Note It is permissible for p and trp to be the same array. Called tr : transpose r-matrix rxp : product of r-matrix and p-vector source"},{"id":390,"pagetitle":"Functions","title":"ERFA.trxpv","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.trxpv","content":" ERFA.trxpv  —  Function trxpv(r, pv) Multiply a pv-vector by the transpose of an r-matrix. Deprecated Use  [r' * pv[1], r' * pv[2]]  instead. Given r : R-matrix pv : Pv-vector Returned trpv : R * pv Note It is permissible for pv and trpv to be the same array. Called tr : transpose r-matrix rxpv : product of r-matrix and pv-vector source"},{"id":391,"pagetitle":"Functions","title":"ERFA.tttai","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.tttai","content":" ERFA.tttai  —  Function tttai(tt1, tt2) Time scale transformation:  Terrestrial Time, TT, to International Atomic Time, TAI. Given tt1 ,  tt2 : TT as a 2-part Julian Date Returned tai1 ,  tai2 : TAI as a 2-part Julian Date Note tt1+tt2 is Julian Date, apportioned in any convenient way between    the two arguments, for example where tt1 is the Julian Day Number    and tt2 is the fraction of a day.  The returned tai1,tai2 follow    suit. References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992) source"},{"id":392,"pagetitle":"Functions","title":"ERFA.tttcg","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.tttcg","content":" ERFA.tttcg  —  Function tttcg(tt1, tt2) Time scale transformation:  Terrestrial Time, TT, to Geocentric Coordinate Time, TCG. Given tt1 ,  tt2 : TT as a 2-part Julian Date Returned tcg1 ,  tcg2 : TCG as a 2-part Julian Date Note tt1+tt2 is Julian Date, apportioned in any convenient way between    the two arguments, for example where tt1 is the Julian Day Number    and tt2 is the fraction of a day.  The returned tcg1,tcg2 follow    suit. References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) IAU 2000 Resolution B1.9 source"},{"id":393,"pagetitle":"Functions","title":"ERFA.tttdb","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.tttdb","content":" ERFA.tttdb  —  Function tttdb(tt1, tt2, dtr) Time scale transformation:  Terrestrial Time, TT, to Barycentric Dynamical Time, TDB. Given tt1 ,  tt2 : TT as a 2-part Julian Date dtr : TDB-TT in seconds Returned tdb1 ,  tdb2 : TDB as a 2-part Julian Date Notes tt1+tt2 is Julian Date, apportioned in any convenient way between the two arguments, for example where tt1 is the Julian Day Number and tt2 is the fraction of a day.  The returned tdb1,tdb2 follow suit. The argument dtr represents the quasi-periodic component of the GR transformation between TT and TCB.  It is dependent upon the adopted solar-system ephemeris, and can be obtained by numerical integration, by interrogating a precomputed time ephemeris or by evaluating a model such as that implemented in the ERFA function  dtdb .   The quantity is dominated by an annual term of 1.7 ms amplitude. TDB is essentially the same as Teph, the time argument for the JPL solar system ephemerides. References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) IAU 2006 Resolution 3 source"},{"id":394,"pagetitle":"Functions","title":"ERFA.ttut1","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.ttut1","content":" ERFA.ttut1  —  Function ttut1(tt1, tt2, dt) Time scale transformation:  Terrestrial Time, TT, to Universal Time, UT1. Given tt1 ,  tt2 : TT as a 2-part Julian Date dt : TT-UT1 in seconds Returned ut11 ,  ut12 : UT1 as a 2-part Julian Date Notes tt1+tt2 is Julian Date, apportioned in any convenient way between the two arguments, for example where tt1 is the Julian Day Number and tt2 is the fraction of a day.  The returned ut11,ut12 follow suit. The argument dt is classical Delta T. Reference Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992) source"},{"id":395,"pagetitle":"Functions","title":"ERFA.ut1tai","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.ut1tai","content":" ERFA.ut1tai  —  Function ut1tai(ut11, ut12, dta) Time scale transformation:  Universal Time, UT1, to International Atomic Time, TAI. Given ut11 ,  ut12 : UT1 as a 2-part Julian Date dta : UT1-TAI in seconds Returned tai1 ,  tai2 : TAI as a 2-part Julian Date Notes ut11+ut12 is Julian Date, apportioned in any convenient way between the two arguments, for example where ut11 is the Julian Day Number and ut12 is the fraction of a day.  The returned tai1,tai2 follow suit. The argument dta, i.e. UT1-TAI, is an observed quantity, and is available from IERS tabulations. Reference Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992) source"},{"id":396,"pagetitle":"Functions","title":"ERFA.ut1tt","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.ut1tt","content":" ERFA.ut1tt  —  Function ut1tt(ut11, ut12, dt) Time scale transformation:  Universal Time, UT1, to Terrestrial Time, TT. Given ut11 ,  ut12 : UT1 as a 2-part Julian Date dt : TT-UT1 in seconds Returned tt1 ,  tt2 : TT as a 2-part Julian Date Notes ut11+ut12 is Julian Date, apportioned in any convenient way between the two arguments, for example where ut11 is the Julian Day Number and ut12 is the fraction of a day.  The returned tt1,tt2 follow suit. The argument dt is classical Delta T. Reference Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992) source"},{"id":397,"pagetitle":"Functions","title":"ERFA.ut1utc","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.ut1utc","content":" ERFA.ut1utc  —  Function ut1utc(ut11, ut12, dut1) Time scale transformation:  Universal Time, UT1, to Coordinated Universal Time, UTC. Given ut11 ,  ut12 : UT1 as a 2-part Julian Date (Note 1) dut1 : Delta UT1: UT1-UTC in seconds (Note 2) Returned utc1 ,  utc2 : UTC as a 2-part quasi Julian Date (Notes 3,4) Notes ut11+ut12 is Julian Date, apportioned in any convenient way between the two arguments, for example where ut11 is the Julian Day Number and ut12 is the fraction of a day.  The returned utc1 and utc2 form an analogous pair, except that a special convention is used, to deal with the problem of leap seconds - see Note 3. Delta UT1 can be obtained from tabulations provided by the International Earth Rotation and Reference Systems Service.  The value changes abruptly by 1s at a leap second;  however, close to a leap second the algorithm used here is tolerant of the \"wrong\" choice of value being made. JD cannot unambiguously represent UTC during a leap second unless special measures are taken.  The convention in the present function is that the returned quasi JD day UTC1+UTC2 represents UTC days whether the length is 86399, 86400 or 86401 SI seconds. The function  d2dtf  can be used to transform the UTC quasi-JD into calendar date and clock time, including UTC leap second handling. The warning status \"dubious year\" flags UTCs that predate the introduction of the time scale or that are too far in the future to be trusted.  See  dat  for further details. Called jd2cal : JD to Gregorian calendar dat : delta(AT) = TAI-UTC cal2jd : Gregorian calendar to JD References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992) source"},{"id":398,"pagetitle":"Functions","title":"ERFA.utctai","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.utctai-Tuple{Any, Any}","content":" ERFA.utctai  —  Method utctai(utc1, utc2) Time scale transformation:  Coordinated Universal Time, UTC, to International Atomic Time, TAI. Given utc1 ,  utc2 : UTC as a 2-part quasi Julian Date (Notes 1-4) Returned tai1 ,  tai2 : TAI as a 2-part Julian Date (Note 5) Notes utc1+utc2 is quasi Julian Date (see Note 2), apportioned in any convenient way between the two arguments, for example where utc1 is the Julian Day Number and utc2 is the fraction of a day. JD cannot unambiguously represent UTC during a leap second unless special measures are taken.  The convention in the present function is that the JD day represents UTC days whether the length is 86399, 86400 or 86401 SI seconds.  In the 1960-1972 era there were smaller jumps (in either direction) each time the linear UTC(TAI) expression was changed, and these \"mini-leaps\" are also included in the ERFA convention. The warning status \"dubious year\" flags UTCs that predate the introduction of the time scale or that are too far in the future to be trusted.  See  dat  for further details. The function  dtf2d  converts from calendar date and time of day into 2-part Julian Date, and in the case of UTC implements the leap-second-ambiguity convention described above. The returned TAI1,TAI2 are such that their sum is the TAI Julian Date. Called jd2cal : JD to Gregorian calendar dat : delta(AT) = TAI-UTC cal2jd : Gregorian calendar to JD References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992) source"},{"id":399,"pagetitle":"Functions","title":"ERFA.utcut1","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.utcut1","content":" ERFA.utcut1  —  Function utcut1(utc1, utc2, dut1) Time scale transformation:  Coordinated Universal Time, UTC, to Universal Time, UT1. Given utc1 ,  utc2 : UTC as a 2-part quasi Julian Date (Notes 1-4) dut1 : Delta UT1 = UT1-UTC in seconds (Note 5) Returned ut11 ,  ut12 : UT1 as a 2-part Julian Date (Note 6) Notes utc1+utc2 is quasi Julian Date (see Note 2), apportioned in any convenient way between the two arguments, for example where utc1 is the Julian Day Number and utc2 is the fraction of a day. JD cannot unambiguously represent UTC during a leap second unless special measures are taken.  The convention in the present function is that the JD day represents UTC days whether the length is 86399, 86400 or 86401 SI seconds. The warning status \"dubious year\" flags UTCs that predate the introduction of the time scale or that are too far in the future to be trusted.  See  dat  for further details. The function  dtf2d  converts from calendar date and time of day into 2-part Julian Date, and in the case of UTC implements the leap-second-ambiguity convention described above. Delta UT1 can be obtained from tabulations provided by the International Earth Rotation and Reference Systems Service. It is the caller's responsibility to supply a dut1 argument containing the UT1-UTC value that matches the given UTC. The returned ut11,ut12 are such that their sum is the UT1 Julian Date. References McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) Explanatory Supplement to the Astronomical Almanac,   P. Kenneth Seidelmann (ed), University Science Books (1992) Called jd2cal : JD to Gregorian calendar dat : delta(AT) = TAI-UTC utctai : UTC to TAI taiut1 : TAI to UT1 source"},{"id":400,"pagetitle":"Functions","title":"ERFA.xy06","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.xy06-Tuple{Any, Any}","content":" ERFA.xy06  —  Method xy06(date1, date2) X,Y coordinates of celestial intermediate pole from series based on IAU 2006 precession and IAU 2000A nutation. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned x ,  y : CIP X,Y coordinates (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The X,Y coordinates are those of the unit vector towards the celestial intermediate pole.  They represent the combined effects of frame bias, precession and nutation. The fundamental arguments used are as adopted in IERS Conventions (2003) and are from Simon et al. (1994) and Souchay et al. (1999). This is an alternative to the angles-based method, via the ERFA function  fw2xy  and as used in  xys06a  for example.  The two methods agree at the 1 microarcsecond level (at present), a negligible amount compared with the intrinsic accuracy of the models.  However, it would be unwise to mix the two methods (angles-based and series-based) in a single application. Called fal03 : mean anomaly of the Moon falp03 : mean anomaly of the Sun faf03 : mean argument of the latitude of the Moon fad03 : mean elongation of the Moon from the Sun faom03 : mean longitude of the Moon's ascending node fame03 : mean longitude of Mercury fave03 : mean longitude of Venus fae03 : mean longitude of Earth fama03 : mean longitude of Mars faju03 : mean longitude of Jupiter fasa03 : mean longitude of Saturn faur03 : mean longitude of Uranus fane03 : mean longitude of Neptune fapa03 : general accumulated precession in longitude References Capitaine, N., Wallace, P.T. & Chapront, J., 2003,   Astron.Astrophys., 412, 567 Capitaine, N. & Wallace, P.T., 2006, Astron.Astrophys. 450, 855 McCarthy, D. D., Petit, G. (eds.), 2004, IERS Conventions (2003),   IERS Technical Note No. 32, BKG Simon, J.L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,   Francou, G. & Laskar, J., Astron.Astrophys., 1994, 282, 663 Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M., 1999,   Astron.Astrophys.Supp.Ser. 135, 111 Wallace, P.T. & Capitaine, N., 2006, Astron.Astrophys. 459, 981 source"},{"id":401,"pagetitle":"Functions","title":"ERFA.xys00a","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.xys00a","content":" ERFA.xys00a  —  Function xys00a(date1, date2) For a given TT date, compute the X,Y coordinates of the Celestial Intermediate Pole and the CIO locator s, using the IAU 2000A precession-nutation model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned x ,  y : Celestial Intermediate Pole (Note 2) s : The CIO locator s (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The Celestial Intermediate Pole coordinates are the x,y components of the unit vector in the Geocentric Celestial Reference System. The CIO locator s (in radians) positions the Celestial Intermediate Origin on the equator of the CIP. A faster, but slightly less accurate result (about 1 mas for X,Y), can be obtained by using instead the  xys00b  function. Called pnm00a : classical NPB matrix, IAU 2000A bpn2xy : extract CIP X,Y coordinates from NPB matrix s00 : the CIO locator s, given X,Y, IAU 2000A Reference McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":402,"pagetitle":"Functions","title":"ERFA.xys00b","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.xys00b","content":" ERFA.xys00b  —  Function xys00b(date1, date2) For a given TT date, compute the X,Y coordinates of the Celestial Intermediate Pole and the CIO locator s, using the IAU 2000B precession-nutation model. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned x ,  y : Celestial Intermediate Pole (Note 2) s : The CIO locator s (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The Celestial Intermediate Pole coordinates are the x,y components of the unit vector in the Geocentric Celestial Reference System. The CIO locator s (in radians) positions the Celestial Intermediate Origin on the equator of the CIP. The present function is faster, but slightly less accurate (about 1 mas in X,Y), than the  xys00a  function. Called pnm00b : classical NPB matrix, IAU 2000B bpn2xy : extract CIP X,Y coordinates from NPB matrix s00 : the CIO locator s, given X,Y, IAU 2000A Reference McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) source"},{"id":403,"pagetitle":"Functions","title":"ERFA.xys06a","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.xys06a","content":" ERFA.xys06a  —  Function xys06a(date1, date2) For a given TT date, compute the X,Y coordinates of the Celestial Intermediate Pole and the CIO locator s, using the IAU 2006 precession and IAU 2000A nutation models. Given date1 ,  date2 : TT as a 2-part Julian Date (Note 1) Returned x ,  y : Celestial Intermediate Pole (Note 2) s : The CIO locator s (Note 2) Notes The TT date date1+date2 is a Julian Date, apportioned in any convenient way between the two arguments.  For example, JD(TT)=2450123.7 could be expressed in any of these ways, among others: date1 date2 Method 2450123.7 0.0 JD 2451545.0 -1421.3 J2000 2400000.5 50123.2 MJD 2450123.5 0.2 date & time The JD method is the most natural and convenient to use in cases where the loss of several decimal digits of resolution is acceptable.  The J2000 method is best matched to the way the argument is handled internally and will deliver the optimum resolution.  The MJD method and the date & time methods are both good compromises between resolution and convenience. The Celestial Intermediate Pole coordinates are the x,y components of the unit vector in the Geocentric Celestial Reference System. The CIO locator s (in radians) positions the Celestial Intermediate Origin on the equator of the CIP. Series-based solutions for generating X and Y are also available: see Capitaine & Wallace (2006) and  xy06 . Called pnm06a : classical NPB matrix, IAU 2006/2000A bpn2xy : extract CIP X,Y coordinates from NPB matrix s06 : the CIO locator s, given X,Y, IAU 2006 References Capitaine, N. & Wallace, P.T., 2006, Astron.Astrophys. 450, 855 Wallace, P.T. & Capitaine, N., 2006, Astron.Astrophys. 459, 981 source"},{"id":404,"pagetitle":"Functions","title":"ERFA.zp","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.zp","content":" ERFA.zp  —  Function zp(p) Zero a p-vector. Deprecated Use  fill!(p, 0.0)  instead. Returned p : zero p-vector source"},{"id":405,"pagetitle":"Functions","title":"ERFA.zpv","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.zpv","content":" ERFA.zpv  —  Function zpv(pv) Zero a pv-vector. Deprecated Use  fill!.(pv, 0.0)  instead. Returned p : zero pv-vector source"},{"id":406,"pagetitle":"Functions","title":"ERFA.zr","ref":"/previews/PR43/ERFA/stable/api/functions/#ERFA.zr","content":" ERFA.zr  —  Function zr(r) Initialize an r-matrix to the null matrix. Deprecated Use  fill!(r, 0.0)  instead. Returned r : r-matrix source"},{"id":409,"pagetitle":"Index","title":"API Index","ref":"/previews/PR43/ERFA/stable/api/name_index/#API-Index","content":" API Index"},{"id":410,"pagetitle":"Index","title":"Types","ref":"/previews/PR43/ERFA/stable/api/name_index/#Types","content":" Types ERFA.Ellipsoid"},{"id":411,"pagetitle":"Index","title":"Constants","ref":"/previews/PR43/ERFA/stable/api/name_index/#Constants","content":" Constants ERFA.AULT ERFA.CMPS ERFA.D2PI ERFA.DAS2R ERFA.DAU ERFA.DAYSEC ERFA.DC ERFA.DD2R ERFA.DJ00 ERFA.DJC ERFA.DJM ERFA.DJM0 ERFA.DJM00 ERFA.DJM77 ERFA.DJY ERFA.DMAS2R ERFA.DPI ERFA.DR2AS ERFA.DR2D ERFA.DS2R ERFA.DTY ERFA.ELB ERFA.ELG ERFA.GRS80 ERFA.SRS ERFA.TDB0 ERFA.TTMTAI ERFA.TURNAS ERFA.WGS72 ERFA.WGS84"},{"id":412,"pagetitle":"Index","title":"Functions","ref":"/previews/PR43/ERFA/stable/api/name_index/#Functions","content":" Functions ERFA.a2af ERFA.a2tf ERFA.ab ERFA.ae2hd ERFA.af2a ERFA.anp ERFA.anpm ERFA.apcg ERFA.apcg13 ERFA.apci ERFA.apci13 ERFA.apco ERFA.apco13 ERFA.apcs ERFA.apcs13 ERFA.aper ERFA.aper13 ERFA.apio ERFA.apio13 ERFA.atcc13 ERFA.atccq ERFA.atci13 ERFA.atciq ERFA.atciqn ERFA.atciqz ERFA.atco13 ERFA.atic13 ERFA.aticq ERFA.aticqn ERFA.atio13 ERFA.atioq ERFA.atoc13 ERFA.atoi13 ERFA.atoiq ERFA.bi00 ERFA.bp00 ERFA.bp06 ERFA.bpn2xy ERFA.c2i00a ERFA.c2i00b ERFA.c2i06a ERFA.c2ibpn ERFA.c2ixy ERFA.c2ixys ERFA.c2s ERFA.c2t00a ERFA.c2t00b ERFA.c2t06a ERFA.c2tcio ERFA.c2teqx ERFA.c2tpe ERFA.c2txy ERFA.cal2jd ERFA.cpv ERFA.cr ERFA.d2dtf ERFA.d2tf ERFA.dat ERFA.dtdb ERFA.dtf2d ERFA.eceq06 ERFA.ecm06 ERFA.ee00 ERFA.ee00a ERFA.ee00b ERFA.ee06a ERFA.eect00 ERFA.eform ERFA.eo06a ERFA.eors ERFA.epb ERFA.epb2jd ERFA.epj ERFA.epj2jd ERFA.epv00 ERFA.eqec06 ERFA.eqeq94 ERFA.era00 ERFA.erfa_cp ERFA.fad03 ERFA.fae03 ERFA.faf03 ERFA.faju03 ERFA.fal03 ERFA.falp03 ERFA.fama03 ERFA.fame03 ERFA.fane03 ERFA.faom03 ERFA.fapa03 ERFA.fasa03 ERFA.faur03 ERFA.fave03 ERFA.fk425 ERFA.fk45z ERFA.fk524 ERFA.fk52h ERFA.fk54z ERFA.fk5hip ERFA.fk5hz ERFA.fw2m ERFA.fw2xy ERFA.g2icrs ERFA.gc2gd ERFA.gc2gde ERFA.gd2gc ERFA.gd2gce ERFA.gmst00 ERFA.gmst06 ERFA.gmst82 ERFA.gst00a ERFA.gst00b ERFA.gst06 ERFA.gst06a ERFA.gst94 ERFA.h2fk5 ERFA.hd2ae ERFA.hd2pa ERFA.hfk5z ERFA.icrs2g ERFA.ir ERFA.jd2cal ERFA.jdcalf ERFA.ld ERFA.ldn ERFA.ldsun ERFA.lteceq ERFA.ltecm ERFA.lteqec ERFA.ltp ERFA.ltpb ERFA.ltpecl ERFA.ltpequ ERFA.moon98 ERFA.num00a ERFA.num00b ERFA.num06a ERFA.numat ERFA.nut00a ERFA.nut00b ERFA.nut06a ERFA.nut80 ERFA.nutm80 ERFA.obl06 ERFA.obl80 ERFA.p06e ERFA.p2pv ERFA.p2s ERFA.pap ERFA.pas ERFA.pb06 ERFA.pdp ERFA.pfw06 ERFA.plan94 ERFA.pm ERFA.pmat00 ERFA.pmat06 ERFA.pmat76 ERFA.pmp ERFA.pmpx ERFA.pmsafe ERFA.pn ERFA.pn00 ERFA.pn00a ERFA.pn00b ERFA.pn06 ERFA.pn06a ERFA.pnm00a ERFA.pnm00b ERFA.pnm06a ERFA.pnm80 ERFA.pom00 ERFA.ppp ERFA.ppsp ERFA.pr00 ERFA.prec76 ERFA.pv2p ERFA.pv2s ERFA.pvdpv ERFA.pvm ERFA.pvmpv ERFA.pvppv ERFA.pvstar ERFA.pvtob ERFA.pvu ERFA.pvup ERFA.pvxpv ERFA.pxp ERFA.refco ERFA.rm2v ERFA.rv2m ERFA.rx ERFA.rxp ERFA.rxpv ERFA.rxr ERFA.ry ERFA.rz ERFA.s00 ERFA.s00a ERFA.s00b ERFA.s06 ERFA.s06a ERFA.s2c ERFA.s2p ERFA.s2pv ERFA.s2xpv ERFA.sepp ERFA.seps ERFA.sp00 ERFA.starpm ERFA.starpv ERFA.sxp ERFA.sxpv ERFA.taitt ERFA.taiut1 ERFA.taiutc ERFA.tcbtdb ERFA.tcgtt ERFA.tdbtcb ERFA.tdbtt ERFA.tf2a ERFA.tf2d ERFA.tpors ERFA.tporv ERFA.tpsts ERFA.tpstv ERFA.tpxes ERFA.tpxev ERFA.tr ERFA.trxp ERFA.trxpv ERFA.tttai ERFA.tttcg ERFA.tttdb ERFA.ttut1 ERFA.ut1tai ERFA.ut1tt ERFA.ut1utc ERFA.utctai ERFA.utcut1 ERFA.xy06 ERFA.xys00a ERFA.xys00b ERFA.xys06a ERFA.zp ERFA.zpv ERFA.zr"},{"id":415,"pagetitle":"Types & Constants","title":"Types and constants","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#Types-and-constants","content":" Types and constants"},{"id":416,"pagetitle":"Types & Constants","title":"Types","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#Types","content":" Types"},{"id":417,"pagetitle":"Types & Constants","title":"ERFA.Ellipsoid","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#ERFA.Ellipsoid","content":" ERFA.Ellipsoid  —  Type Ellipsoid Reference ellipsoids WGS84 GRS80 WGS72 source"},{"id":418,"pagetitle":"Types & Constants","title":"Constants","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#Constants","content":" Constants"},{"id":419,"pagetitle":"Types & Constants","title":"ERFA.AULT","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#ERFA.AULT","content":" ERFA.AULT  —  Constant AULT Light time for 1 au (s) source"},{"id":420,"pagetitle":"Types & Constants","title":"ERFA.CMPS","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#ERFA.CMPS","content":" ERFA.CMPS  —  Constant CMPS Speed of light (m/s) source"},{"id":421,"pagetitle":"Types & Constants","title":"ERFA.D2PI","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#ERFA.D2PI","content":" ERFA.D2PI  —  Constant D2PI 2Pi source"},{"id":422,"pagetitle":"Types & Constants","title":"ERFA.DAS2R","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#ERFA.DAS2R","content":" ERFA.DAS2R  —  Constant DAS2R Arcseconds to radians source"},{"id":423,"pagetitle":"Types & Constants","title":"ERFA.DAU","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#ERFA.DAU","content":" ERFA.DAU  —  Constant DAU Astronomical unit (m, IAU 2012) source"},{"id":424,"pagetitle":"Types & Constants","title":"ERFA.DAYSEC","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#ERFA.DAYSEC","content":" ERFA.DAYSEC  —  Constant DAYSEC Seconds per day source"},{"id":425,"pagetitle":"Types & Constants","title":"ERFA.DC","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#ERFA.DC","content":" ERFA.DC  —  Constant DC Speed of light (au per day) source"},{"id":426,"pagetitle":"Types & Constants","title":"ERFA.DD2R","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#ERFA.DD2R","content":" ERFA.DD2R  —  Constant DD2R Degrees to radians source"},{"id":427,"pagetitle":"Types & Constants","title":"ERFA.DJ00","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#ERFA.DJ00","content":" ERFA.DJ00  —  Constant DJ00 Reference epoch (J2000.0), Julian Date source"},{"id":428,"pagetitle":"Types & Constants","title":"ERFA.DJC","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#ERFA.DJC","content":" ERFA.DJC  —  Constant DJC Days per Julian century source"},{"id":429,"pagetitle":"Types & Constants","title":"ERFA.DJM","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#ERFA.DJM","content":" ERFA.DJM  —  Constant DJM Days per Julian millennium source"},{"id":430,"pagetitle":"Types & Constants","title":"ERFA.DJM0","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#ERFA.DJM0","content":" ERFA.DJM0  —  Constant DJM0 Julian Date of Modified Julian Date zero source"},{"id":431,"pagetitle":"Types & Constants","title":"ERFA.DJM00","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#ERFA.DJM00","content":" ERFA.DJM00  —  Constant DJM00 Reference epoch (J2000.0), Modified Julian Date source"},{"id":432,"pagetitle":"Types & Constants","title":"ERFA.DJM77","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#ERFA.DJM77","content":" ERFA.DJM77  —  Constant DJM77 1977 Jan 1.0 as MJD source"},{"id":433,"pagetitle":"Types & Constants","title":"ERFA.DJY","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#ERFA.DJY","content":" ERFA.DJY  —  Constant DJY Days per Julian year source"},{"id":434,"pagetitle":"Types & Constants","title":"ERFA.DMAS2R","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#ERFA.DMAS2R","content":" ERFA.DMAS2R  —  Constant DMAS2R Milliarcseconds to radians source"},{"id":435,"pagetitle":"Types & Constants","title":"ERFA.DPI","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#ERFA.DPI","content":" ERFA.DPI  —  Constant DPI Pi source"},{"id":436,"pagetitle":"Types & Constants","title":"ERFA.DR2AS","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#ERFA.DR2AS","content":" ERFA.DR2AS  —  Constant DR2AS Radians to arcseconds source"},{"id":437,"pagetitle":"Types & Constants","title":"ERFA.DR2D","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#ERFA.DR2D","content":" ERFA.DR2D  —  Constant DR2D Radians to degrees source"},{"id":438,"pagetitle":"Types & Constants","title":"ERFA.DS2R","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#ERFA.DS2R","content":" ERFA.DS2R  —  Constant DS2R Seconds of time to radians source"},{"id":439,"pagetitle":"Types & Constants","title":"ERFA.DTY","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#ERFA.DTY","content":" ERFA.DTY  —  Constant DTY Length of tropical year B1900 (days) source"},{"id":440,"pagetitle":"Types & Constants","title":"ERFA.ELB","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#ERFA.ELB","content":" ERFA.ELB  —  Constant L_B L_B = 1 - d(TDB)/d(TCB) source"},{"id":441,"pagetitle":"Types & Constants","title":"ERFA.ELG","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#ERFA.ELG","content":" ERFA.ELG  —  Constant ELG L_G = 1 - d(TT)/d(TCG) source"},{"id":442,"pagetitle":"Types & Constants","title":"ERFA.GRS80","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#ERFA.GRS80","content":" ERFA.GRS80  —  Constant GRS80 Enum constant for the GRS80 reference ellipsoid source"},{"id":443,"pagetitle":"Types & Constants","title":"ERFA.SRS","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#ERFA.SRS","content":" ERFA.SRS  —  Constant SRS Schwarzschild radius of the Sun (au) = 2 * 1.32712440041e20 / (2.99792458e8)^2 / 1.49597870700e11 source"},{"id":444,"pagetitle":"Types & Constants","title":"ERFA.TDB0","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#ERFA.TDB0","content":" ERFA.TDB0  —  Constant TDB0 TDB (s) at TAI 1977/1/1.0 source"},{"id":445,"pagetitle":"Types & Constants","title":"ERFA.TTMTAI","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#ERFA.TTMTAI","content":" ERFA.TTMTAI  —  Constant TTMTAI TT minus TAI (s) source"},{"id":446,"pagetitle":"Types & Constants","title":"ERFA.TURNAS","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#ERFA.TURNAS","content":" ERFA.TURNAS  —  Constant TURNAS Arcseconds in a full circle source"},{"id":447,"pagetitle":"Types & Constants","title":"ERFA.WGS72","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#ERFA.WGS72","content":" ERFA.WGS72  —  Constant WGS72 Enum constant for the WGS72 reference ellipsoid source"},{"id":448,"pagetitle":"Types & Constants","title":"ERFA.WGS84","ref":"/previews/PR43/ERFA/stable/api/types_and_constants/#ERFA.WGS84","content":" ERFA.WGS84  —  Constant WGS84 Enum constant for the WGS84 reference ellipsoid source"},{"id":451,"pagetitle":"Home","title":"SkyCoords.jl","ref":"/previews/PR43/SkyCoords/stable/#SkyCoords.jl","content":" SkyCoords.jl SkyCoords.jl provides a type system for astronomical coordinate systems with appropriate conversions between them."},{"id":452,"pagetitle":"Home","title":"Installation","ref":"/previews/PR43/SkyCoords/stable/#Installation","content":" Installation From the Julia REPL (v1.6) pkg> add SkyCoords\n\njulia> using SkyCoords"},{"id":453,"pagetitle":"Home","title":"Usage","ref":"/previews/PR43/SkyCoords/stable/#Usage","content":" Usage There are currently three supported coordinate systems. The following immutable types are used to represent coordinates in each system: ICRSCoords : ICRS coordinates system GalCoords : Galactic coordinates system FK5Coords : FK5 coordinates system (with arbitrary equinox) EclipticCoords : Ecliptic coordinates system Each type holds a longitude and latitude, and each is a subtype of  AbstractSkyCoords . julia> c1 = ICRSCoords(0.0, 0.0)  # inputs are ra, dec in radians\nICRSCoords{Float64}(0.0, 0.0)\n\njulia> c1.ra # access ra, dec individually\n0.0\n\njulia> c2 = convert(GalCoords, c1) # convert to a different system\nGalCoords{Float64}(1.6814027872278692, -1.0504884034813007)\n\njulia> c2.l # Note that galactic coordinate fields are l, b\n1.6814027872278692\n\njulia> c1 |> FK5Coords{2000} # Can use piping syntax for conversion\nFK5Coords{2000, Float64}(1.1102233723050067e-7, 4.411803426976326e-8)"},{"id":454,"pagetitle":"Home","title":"Units","ref":"/previews/PR43/SkyCoords/stable/#Units","content":" Units There is built-in support for units via  Unitful.jl julia> using Unitful\n\njulia> c = ICRSCoords(0.11255u\"°\", 0.00091u\"rad\")\nICRSCoords{Float64}(0.0019643680731196178, 0.00091)\n\njulia> c2 = FK5Coords{2000}(0.1u\"rad\", 0.5)\nFK5Coords{2000, Float64}(0.1, 0.5)\n\njulia> SkyCoords.lat(u\"μrad\", c)\n910.0 μrad"},{"id":455,"pagetitle":"Home","title":"Parsing from strings","ref":"/previews/PR43/SkyCoords/stable/#Parsing-from-strings","content":" Parsing from strings The  AstroAngles.jl  package provides convenient string parsing utilities julia> using AstroAngles\n\njulia> c3 = ICRSCoords(hms\"05:34:31.94\", dms\"+22:00:52.2\")\nICRSCoords{Float64}(1.4596726677614607, 0.3842255081802917) for example, to load coordinates from a target list julia> using CSV, DataFrames\n\njulia> table = CSV.File(\"target_list.csv\") |> DataFrame;\n\njulia> [table.ra table.dec]\n203×2 Matrix{String}:\n \"00 05 01.42\"  \"40 03 35.82\"\n \"00 05 07.52\"  \"73 13 11.34\"\n \"00 36 01.40\"  \"-11 12 13.00\"\n[...]\n\njulia> coords = @. ICRSCoords(hms2rad(table.ra), dms2rad(table.dec))\n203-element Vector{ICRSCoords{Float64}}:\n ICRSCoords{Float64}(0.021919880964005448, 0.6991780256843024)\n ICRSCoords{Float64}(0.022363485482220672, 1.277926878539953)\n ICRSCoords{Float64}(0.15718144355252264, -0.19553990200190915)\n[...]"},{"id":456,"pagetitle":"Home","title":"Angular Separation between Coordinates","ref":"/previews/PR43/SkyCoords/stable/#Angular-Separation-between-Coordinates","content":" Angular Separation between Coordinates The  separation  function allows you to compute the angular (great-circle) distance between two coordinates, in radians, using the  Vincenty formula .  The coordinates can be also given in different systems.  For example, according to SIMBAD the  FK5Coords{2000}  coordinates of  Mizar  are julia> mizar = FK5Coords{2000}(3.507787, 0.958628)\nFK5Coords{2000, Float64}(3.507787, 0.958628) while the  GalCoords  coordinates of Alcor are julia> alcor = GalCoords(1.968189, 1.072829)\nGalCoords{Float64}(1.968189, 1.072829) Their angular separation is given by julia> separation(mizar, alcor) # Radians\n0.003435309169452965\n\njulia> rad2deg(separation(mizar, alcor)) * 60 # Arcminutes\n11.809723003934822 with an angle julia> position_angle(mizar, alcor) # radians\n1.2446024012417884\n\njulia> position_angle(mizar, alcor) |> rad2deg # degrees\n71.31046476300233\n"},{"id":457,"pagetitle":"Home","title":"Accuracy","ref":"/previews/PR43/SkyCoords/stable/#Accuracy","content":" Accuracy All the supported conversions have been compared to the results of  astropy.coordinates  (to better than 0.0001 arcsec agreement for  Float64 ). In turn,  astropy.coordinates  has been tested against many other tools."},{"id":458,"pagetitle":"Home","title":"Performance","ref":"/previews/PR43/SkyCoords/stable/#Performance","content":" Performance For small and moderate numbers of coordinates, conversions are much faster than  astropy.coordinates  in Python. The following plot shows the performance for converting ICRS coordinates to various other systems (Galactic, FK5J2000 and FK5J1975), using  astropy.coordinates  ( py_*  labels) and SkyCoords.jl ( jl_*  labels). The x axis denotes the number of coordinates being simultaneously converted, with 1 corresponding to scalar coordinates. Specs CPU Intel core i5-8259U @ 2.3GHz (4 cores) RAM 16GB Julia Version 1.2 Python Version 3.7 Astropy Version 3.1.2 For scalar coordinates, SkyCoords.jl is up to 100,000 times faster. For very large vectors of one million coordinates or more, SkyCoords.jl is 2-4 times faster.  The source code for these benchmarks can be found in  bench/ ."},{"id":459,"pagetitle":"Home","title":"Contributing","ref":"/previews/PR43/SkyCoords/stable/#Contributing","content":" Contributing If you would like to contribute to SkyCoords please head over to the  GitHub page  and file an issue or open a pull request!"},{"id":462,"pagetitle":"API/Reference","title":"API/Reference","ref":"/previews/PR43/SkyCoords/stable/api/#API/Reference","content":" API/Reference"},{"id":463,"pagetitle":"API/Reference","title":"Index","ref":"/previews/PR43/SkyCoords/stable/api/#Index","content":" Index SkyCoords.AbstractSkyCoords SkyCoords.EclipticCoords SkyCoords.FK5Coords SkyCoords.GalCoords SkyCoords.ICRSCoords SkyCoords.SuperGalCoords SkyCoords.offset SkyCoords.position_angle SkyCoords.separation"},{"id":464,"pagetitle":"API/Reference","title":"Types","ref":"/previews/PR43/SkyCoords/stable/api/#Types","content":" Types"},{"id":465,"pagetitle":"API/Reference","title":"SkyCoords.AbstractSkyCoords","ref":"/previews/PR43/SkyCoords/stable/api/#SkyCoords.AbstractSkyCoords","content":" SkyCoords.AbstractSkyCoords  —  Type The supertype for all sky coordinate systems. source"},{"id":466,"pagetitle":"API/Reference","title":"SkyCoords.ICRSCoords","ref":"/previews/PR43/SkyCoords/stable/api/#SkyCoords.ICRSCoords","content":" SkyCoords.ICRSCoords  —  Type ICRSCoords(ra, dec) International Celestial Reference System This is the current standard adopted by the International Astronomical Union notably due to its high level of accuracy compared to standard equatorial coordinate systems. What sets this apart from  FK5Coords  is that it is completely defined using extragalactic radio sources rather than a geocentric frame, which means the reference frame will not change due to Earth's motion. Coordinates ra  - Right ascension in radians (0, 2π) dec  - Declination in radians (-π/2, π/2) source"},{"id":467,"pagetitle":"API/Reference","title":"SkyCoords.GalCoords","ref":"/previews/PR43/SkyCoords/stable/api/#SkyCoords.GalCoords","content":" SkyCoords.GalCoords  —  Type GalCoords(l, b) Galactic Coordinate System This coordinate system is defined based on the projection of the Milky Way galaxy onto our celestial sphere, with (0, 0) being approximately the center of our galaxy. Coordinates l  - Galactic longitude in radians (-π, π) b  - Galactic latitude in radians (-π/2, π/2) source"},{"id":468,"pagetitle":"API/Reference","title":"SkyCoords.SuperGalCoords","ref":"/previews/PR43/SkyCoords/stable/api/#SkyCoords.SuperGalCoords","content":" SkyCoords.SuperGalCoords  —  Type SuperGalCoords(l, b) Supergalactic Coordinate System The supergalactic plane is part of a reference frame for the supercluster of galaxies that contains the Milky Way galaxy. The supergalactic plane as so-far observed is more or less perpendicular to the plane of the Milky Way, the angle is 84.5 degrees. Viewed from the Earth, the plane traces a great circle across the sky through the constellations  Coordinates l  - SuperGalCoords longitude in radians (-π, π) b  - SuperGalCoords latitude in radians (-π/2, π/2) source"},{"id":469,"pagetitle":"API/Reference","title":"SkyCoords.FK5Coords","ref":"/previews/PR43/SkyCoords/stable/api/#SkyCoords.FK5Coords","content":" SkyCoords.FK5Coords  —  Type FK5Coords{equinox}(ra, dec) Equatorial Coordinate System This coordinate system maps the celestial sphere based on a geocentric observer. Historically the oldest, this coordinate system has been shown to be inaccurate due to its definitions based on the Earth, which has long-scale precession causing the reference frame to change. Because of this, an equinox must be provided (typically 2000, commonly known as J2000) which defines the reference frame. Coordinates ra  - Right ascension in radians (0, 2π) dec  - Declination in radians (-π/2, π/2) source"},{"id":470,"pagetitle":"API/Reference","title":"SkyCoords.EclipticCoords","ref":"/previews/PR43/SkyCoords/stable/api/#SkyCoords.EclipticCoords","content":" SkyCoords.EclipticCoords  —  Type EclipticCoords{equinox}(lon, lat) Ecliptic Coordinate System This coordinate system is geocentric with the ecliptic plane as the xy-plane with x oriented according to the equinox specified by  equinox . Coordinates lon  - Longitude in radians (0, 2π) lat  - Latitude in radians (-π/2, π/2) source"},{"id":471,"pagetitle":"API/Reference","title":"Conversion","ref":"/previews/PR43/SkyCoords/stable/api/#Conversion","content":" Conversion To convert between types, there are three (equivalent) methods of doing so. julia> c1 = ICRSCoords(0., 0.)\nICRSCoords{Float64}(0.0, 0.0) using  convert julia> convert(GalCoords, c1)\nGalCoords{Float64}(1.6814027872278692, -1.0504884034813007) using constructors julia> GalCoords(c1)\nGalCoords{Float64}(1.6814027872278692, -1.0504884034813007) using  |> julia> c1 |> GalCoords\nGalCoords{Float64}(1.6814027872278692, -1.0504884034813007)"},{"id":472,"pagetitle":"API/Reference","title":"Functions","ref":"/previews/PR43/SkyCoords/stable/api/#Functions","content":" Functions"},{"id":473,"pagetitle":"API/Reference","title":"SkyCoords.separation","ref":"/previews/PR43/SkyCoords/stable/api/#SkyCoords.separation","content":" SkyCoords.separation  —  Function separation(c1::AbstractSkyCoords, c2::AbstractSkyCoords) -> distance Return angular separation between two sky coordinates, in radians. The angular separation is calculated using the  Vincenty formula , which is slightly more complex and computationally expensive than some alternatives, but is stable at at all distances, including the poles and antipodes. source"},{"id":474,"pagetitle":"API/Reference","title":"SkyCoords.position_angle","ref":"/previews/PR43/SkyCoords/stable/api/#SkyCoords.position_angle","content":" SkyCoords.position_angle  —  Function position_angle(c1::AbstractSkyCoords, c2::AbstractSkyCoords) -> angle Return position angle between two sky coordinates, in positive radians. Examples julia> c1 = ICRSCoords(0, 0); c2 = ICRSCoords(deg2rad(1), 0);\n\njulia> position_angle(c1, c2) |> rad2deg\n90.0 source"},{"id":475,"pagetitle":"API/Reference","title":"SkyCoords.offset","ref":"/previews/PR43/SkyCoords/stable/api/#SkyCoords.offset","content":" SkyCoords.offset  —  Function offset(::AbstractSkyCoords, separation, pa) -> coordinate Offset a coordinate by a given angular separation,  separation , in radians and position angle,  pa , in radians. Uses the sine and cosine rules in spherical coordinates with corrections for the antipodes. Returns a sky coordinate of the same type as input. Examples julia> c1 = ICRSCoords(0, 0);\n\njulia> c2 = offset(c1, deg2rad(1), deg2rad(90))\nICRSCoords{Float64}(0.017453292519943295, 1.0686516840418957e-18)\n\njulia> offset(c1, c2) .|> rad2deg\n(1.0, 90.0) See Also separation ,  position_angle source offset(::AbstractSkyCoords, AbstractSkyCoords) -> angle, angle Return the separation and position angle in radians between two sky coordinates. Examples julia> c1 = ICRSCoords(0, 0); c2 = ICRSCoords(deg2rad(1), 0);\n\njulia> offset(c1, c2) .|> rad2deg\n(1.0, 90.0) See Also separation ,  position_angle source"},{"id":478,"pagetitle":"Home","title":"UnitfulAstro.jl Documentation","ref":"/previews/PR43/UnitfulAstro/stable/#UnitfulAstro.jl-Documentation","content":" UnitfulAstro.jl Documentation UnitfulAstro.jl is an extension of  Unitful.jl  to include units commonly encountered in astronomy."},{"id":479,"pagetitle":"Home","title":"Table of Units","ref":"/previews/PR43/UnitfulAstro/stable/#Table-of-Units","content":" Table of Units The list of additional units is given below: Name Binding Value Erg UnitfulAstro.erg 1//10000000 J Dyne UnitfulAstro.dyn 1//100000 N Arcminute UnitfulAstro.arcminute 1//60 ° Arcsecond UnitfulAstro.arcsecond 1//3600 ° Julian year UnitfulAstro.yr 1461//4 d Astronomical unit UnitfulAstro.AU 1.495978707e13 cm Light year UnitfulAstro.ly 946073047258080000 cm Parsec UnitfulAstro.pc 3.0856775814913674e18 cm Jansky UnitfulAstro.Jy 1.0e-23 erg Hz^-1 cm^-2 s^-1 Solar radius UnitfulAstro.Rsun 6.957e10 cm Solar irradiance UnitfulAstro.Ssun 1.361e6 erg cm^-2 s^-1 Solar luminosity UnitfulAstro.Lsun 3.828e33 erg s^-1 G × Solar mass UnitfulAstro.GMsun 1.3271244e20 m^3 s^-2 Solar mass UnitfulAstro.Msun 1.988409870698051e33 g Earth radius (equatorial) UnitfulAstro.Rearth_e 6.3781e8 cm Earth radius (polar) UnitfulAstro.Rearth_p 6.3568e8 cm Earth radius UnitfulAstro.Rearth 6.3781e8 cm G × Earth mass UnitfulAstro.GMearth 3.986004e14 m^3 s^-2 Earth mass UnitfulAstro.Mearth 5.972167867791379e27 g Jupiter radius (equatorial) UnitfulAstro.Rjup_e 7.1492e9 cm Jupiter radius (polar) UnitfulAstro.Rjup_p 6.6854e9 cm Jupiter radius UnitfulAstro.Rjup 7.1492e9 cm G × Jupiter mass UnitfulAstro.GMjup 1.2668653e17 m^3 s^-2 Jupiter mass UnitfulAstro.Mjup 1.8981245973360504e30 g Fifty-one ergs UnitfulAstro.foe 1.0e51 erg Solar flux unit UnitfulAstro.SFU 10 kJy Total electron content unit UnitfulAstro.TECU 1.0e12 cm^-2"},{"id":480,"pagetitle":"Home","title":"Examples","ref":"/previews/PR43/UnitfulAstro/stable/#Examples","content":" Examples julia> using Unitful, UnitfulAstro\n\njulia> uconvert(u\"erg\", 1 * Unitful.kg * Unitful.gn * Unitful.m)\n9.80665e7 erg\n\njulia> uconvert(u\"Jy\", 1.23e-20 * u\"erg/s/cm^2/Hz\")\n1230.0000000000002 Jy\n\njulia> uconvert(u\"ly\", 1u\"pc\")\n3.2615637771674333 ly"},{"id":481,"pagetitle":"Home","title":"Magnitudes","ref":"/previews/PR43/UnitfulAstro/stable/#Magnitudes","content":" Magnitudes Name Binding Zero Point absolute bolometric Magnitude UnitfulAstro.bol_Mag 3.0128e28 W apparent bolometric magnitude UnitfulAstro.bol_mag 2.518021002e-8 W m^-2 AB magnitude UnitfulAstro.AB_mag 3631 Jy Johnson U magnitude UnitfulAstro.U_mag 1810 Jy Johnson B magnitude UnitfulAstro.B_mag 4260 Jy Johnson V magnitude UnitfulAstro.V_mag 3640 Jy Johnson R magnitude UnitfulAstro.R_mag 3080 Jy Johnson I magnitude UnitfulAstro.I_mag 2550 Jy Johnson J magnitude UnitfulAstro.J_mag 1600 Jy Johnson H magnitude UnitfulAstro.H_mag 1080 Jy Johnson K magnitude UnitfulAstro.K_mag 670 Jy Gunn g magnitude UnitfulAstro.g_mag 3730 Jy Gunn r magnitude UnitfulAstro.r_mag 4490 Jy Gunn i magnitude UnitfulAstro.i_mag 4760 Jy Gunn z magnitude UnitfulAstro.z_mag 4810 Jy Warn Support for magnitudes is experimental. Please use care and report any issues you experience on the  UnitfulAstro.jl GitHub issue tracker . Currently only AB, bolometric, Johnson, and Gunn magnitudes are supported. For example julia> 5u\"AB_mag\" + 5u\"AB_mag\"\n4.247425010840047 AB mag\n\njulia> 5u\"U_mag\"/100\n10.0 Johnson U mag\n\njulia> 5u\"g_mag\" + 10u\"Jy\" # magnitudes can be mixed with ordinary linear units\n47.300000000000004 Jy\n\njulia> uconvert(u\"AB_mag\", 1u\"μJy\") # converting one μJy to AB magnitudes\n23.90006562228223 AB mag\n\njulia> uconvert(u\"bol_mag\", 1u\"Ssun\") # apparent bolometric magnitude of the Sun\n-26.83199694276591 bol mag\n\njulia> uconvert(u\"bol_Mag\", 1u\"Lsun\") # absolute bolometric magnitude of the Sun\n4.7399959339194595 bol Mag"},{"id":482,"pagetitle":"Home","title":"Color","ref":"/previews/PR43/UnitfulAstro/stable/#Color","content":" Color Color index  is also supported julia> 1u\"B_mag\" - 0.5u\"V_mag\"\n0.4999999999999999 Note:  that the only operation that can happen between different bands is subtraction julia> 1u\"B_mag\" + 0.5u\"V_mag\"\nERROR: MagnitudeError: an invalid operation was attempted with magnitudes: 0.9999999999999999 Johnson B mag, 0.5 Johnson V mag and  that  +  and  -  work on individual bands julia> 1u\"B_mag\" - 1.5u\"B_mag\"\n2.0823085833406205 Johnson B mag\n\njulia> 1u\"B_mag\" + 1.5u\"B_mag\"\n0.46889349301415084 Johnson B mag"},{"id":483,"pagetitle":"Home","title":"IAU Resolutions","ref":"/previews/PR43/UnitfulAstro/stable/#IAU-Resolutions","content":" IAU Resolutions Copies of recent IAU resolutions which formalize the definitions of some units used in this package are linked below. IAU 2012 (pdf) IAU 2015 (pdf)"},{"id":486,"pagetitle":"API Reference","title":"API Reference","ref":"/previews/PR43/UnitfulAstro/stable/api/#API-Reference","content":" API Reference"},{"id":487,"pagetitle":"API Reference","title":"Lengths and Distances","ref":"/previews/PR43/UnitfulAstro/stable/api/#Lengths-and-Distances","content":" Lengths and Distances"},{"id":488,"pagetitle":"API Reference","title":"UnitfulAstro.AU","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.AU","content":" UnitfulAstro.AU  —  Constant UnitfulAstro.AU The astronomical unit, an IAU unit of distance, defined as 149 597 870 700 m, in IAU 2012. It is intended to represent the mean distance between the Earth and the Sun. Dimension:  𝐋 Reference:  IAU 2012 Resolution B2 source"},{"id":489,"pagetitle":"API Reference","title":"UnitfulAstro.ly","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.ly","content":" UnitfulAstro.ly  —  Constant UnitfulAstro.ly The light-year, a unit of distance, defined as 1 c⋅yr (speed of light times year). It is intended to represent the amount of distance traveled by an object traveling at the speed of light (e.g., a photon) in a year. Dimesion:  𝐋 See also:  c  (speed of light) ,  yr source"},{"id":490,"pagetitle":"API Reference","title":"UnitfulAstro.pc","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.pc","content":" UnitfulAstro.pc  —  Constant UnitfulAstro.pc The parsec, a unit of distance, defined as 1 AU/arcsecond, in IAU 2015. The exact conversion is 648000/π AU. It is intended to represent the distance to an object whose apparent parallax is 1 arcsecond when viewed from two distances 1 AU apart. Dimension:  𝐋 See also:  AU ,  arcsecond References:  Binney & Tremaine (2008) ,  Cox (2002) ,  IAU 2015 Resolution B2 source"},{"id":491,"pagetitle":"API Reference","title":"UnitfulAstro.Rsun","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.Rsun","content":" UnitfulAstro.Rsun  —  Constant UnitfulAstro.Rsun The solar radius, a unit of length. It is defined as 6.957 × 10^8 m in IAU 2015. It is intended to represent the radius of the sun. Dimension:  𝐋 Reference:  IAU 2015 Resolution B3 source"},{"id":492,"pagetitle":"API Reference","title":"UnitfulAstro.Rearth","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.Rearth","content":" UnitfulAstro.Rearth  —  Constant UnitfulAstro.Rearth The terrestrial radius, a unit of length. It is defined as 1 equatorial Earth radius. Dimension:  𝐋 See also:  Rearth_e ,  Rearth_p source"},{"id":493,"pagetitle":"API Reference","title":"UnitfulAstro.Rearth_e","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.Rearth_e","content":" UnitfulAstro.Rearth_e  —  Constant UnitfulAstro.Rearth_e The equatorial Earth radius, a unit of length. It is defined as 6.3781 × 10^6 m. It is intended to represent the distance from the Earth's center to its equator. Dimension:  𝐋 See also:  Rearth_p Reference:  IAU 2015 Resolution B3 source"},{"id":494,"pagetitle":"API Reference","title":"UnitfulAstro.Rearth_p","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.Rearth_p","content":" UnitfulAstro.Rearth_p  —  Constant UnitfulAstro.Rearth_p The polar Earth radius, a unit of length. It is defined as 6.3568 × 10^6 m. It is intended to represent the distance from the Earth's center to its poles. Dimension:  𝐋 See also:  Rearth_e Reference:  IAU 2015 Resolution B3 source"},{"id":495,"pagetitle":"API Reference","title":"UnitfulAstro.Rjup","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.Rjup","content":" UnitfulAstro.Rjup  —  Constant UnitfulAstro.Rjup The jovian radius, a unit of length. It is defined as 1 equatorial Jupiter radius. Dimension:  𝐋 See also:  Rjup_e ,  Rjup_p source"},{"id":496,"pagetitle":"API Reference","title":"UnitfulAstro.Rjup_e","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.Rjup_e","content":" UnitfulAstro.Rjup_e  —  Constant UnitfulAstro.Rjup_e The equatorial Jupiter radius, a unit of length. It is defined as 7.1492 × 10^7 m. It is intended to represent the distance from Jupiter's center to its equator. Dimension:  𝐋 See also:  Rjup_p Reference:  IAU 2015 Resolution B3 source"},{"id":497,"pagetitle":"API Reference","title":"UnitfulAstro.Rjup_p","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.Rjup_p","content":" UnitfulAstro.Rjup_p  —  Constant UnitfulAstro.Rjup_p The polar Jupiter radius, a unit of length. It is defined as 6.6854 × 10^7 m. It is intended to represent the distance from Jupiter's center to its equator. Dimension:  𝐋 See also:  Rjup_e Reference:  IAU 2015 Resolution B3 source"},{"id":498,"pagetitle":"API Reference","title":"Masses and mass parameters","ref":"/previews/PR43/UnitfulAstro/stable/api/#Masses-and-mass-parameters","content":" Masses and mass parameters"},{"id":499,"pagetitle":"API Reference","title":"UnitfulAstro.GMsun","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.GMsun","content":" UnitfulAstro.GMsun  —  Constant UnitfulAstro.GMSun The solar mass parameter. It is defined as 1.3271244 × 10^20 m^3 s^-2. It is intended to represent the product of G (the universal gravitational constant) and Msun (the solar mass). Dimension:  𝐋^3 𝐓^-2 See also:  G ,  Msun Reference:  IAU 2015 Resolution B3 source"},{"id":500,"pagetitle":"API Reference","title":"UnitfulAstro.Msun","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.Msun","content":" UnitfulAstro.Msun  —  Constant UnitfulAstro.Msun The solar mass, a unit of mass. It is defined as 1 GMsun/G. It is approximately equal to 1.988 × 10^30 kg. It is intended to represent the entire mass of the Sun. Dimension:  𝐌 See also:  G ,  GMsun Reference:  IAU 2015 Resolution B3 source"},{"id":501,"pagetitle":"API Reference","title":"UnitfulAstro.GMearth","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.GMearth","content":" UnitfulAstro.GMearth  —  Constant UnitfulAstro.GMearth The terrestrial mass parameter. It is defined as 3.986 004 × 10^14 m^3 s^-2. It is intended to represent the product of G (the universal gravitational constant) and Mearth (the terrestrial mass). Dimension:  𝐋^3 𝐓^-2 See also:  G ,  Mearth Reference:  IAU 2015 Resolution B3 source"},{"id":502,"pagetitle":"API Reference","title":"UnitfulAstro.Mearth","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.Mearth","content":" UnitfulAstro.Mearth  —  Constant UnitfulAstro.Mearth The terrestrial mass, a unit of mass. It is defined as 1 GMearth/G. It is approximately 5.972 × 10^24 kg. It is intended to represent the total mass of the Earth. Dimension:  𝐌 See also:  G ,  GMearth source"},{"id":503,"pagetitle":"API Reference","title":"UnitfulAstro.GMjup","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.GMjup","content":" UnitfulAstro.GMjup  —  Constant UnitfulAstro.GMjup The jovian mass parameter. It is defined as 1.266 8653 × 10^17 m^3 s^-2. It is intended to represent the product of G (the universal gravitational constant) and Mjup (the jovian mass). Dimension:  𝐋^3 𝐓^-2 See also:  G ,  Mjup Reference:  IAU 2015 Resolution B3 source"},{"id":504,"pagetitle":"API Reference","title":"UnitfulAstro.Mjup","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.Mjup","content":" UnitfulAstro.Mjup  —  Constant UnitfulAstro.Mjup The jovian mass, a unit of mass. It is defined as 1 GMjup/G. It is approximately 1.898 × 10^27 kg. It is intended to represent the total mass of Jupiter . Dimension:  𝐌 See also:  G ,  GMjup source"},{"id":505,"pagetitle":"API Reference","title":"Energy and fluxes","ref":"/previews/PR43/UnitfulAstro/stable/api/#Energy-and-fluxes","content":" Energy and fluxes"},{"id":506,"pagetitle":"API Reference","title":"UnitfulAstro.Jy","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.Jy","content":" UnitfulAstro.Jy  —  Constant UnitfulAstro.Jy The jansky, a unit of spectral flux density, or spectral irradiance. It is defined as 10^-26 W m^-2 Hz^-1, or 10^-23 erg/s cm^-2 Hz^-1. Dimension:  𝐌 𝐓^-2 source"},{"id":507,"pagetitle":"API Reference","title":"UnitfulAstro.Lsun","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.Lsun","content":" UnitfulAstro.Lsun  —  Constant UnitfulAstro.Lsun The solar luminosity, a unit of power. It is defined as 3.828 × 10^26 W in IAU 2015. It is intended to represent the total power emitted by the sun. Dimension:  𝐌 𝐋^2 𝐓^-3 Reference:  IAU 2015 Resolution B3 source"},{"id":508,"pagetitle":"API Reference","title":"UnitfulAstro.foe","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.foe","content":" UnitfulAstro.foe  —  Constant UnitfulAstro.foe The foe, a unit of energy. It is defined as 10^51 erg (ten to the Fifty-One Ergs), or 10^44 J. It is intended to represent the approximate energy released in a supernova explosion. Dimension:  𝐌 𝐋^-2 𝐓^-2 References:  Herant et al. (1997) ,  Hartmann (1999) source"},{"id":509,"pagetitle":"API Reference","title":"UnitfulAstro.SFU","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.SFU","content":" UnitfulAstro.SFU  —  Constant UnitfulAstro.SFU The solar flux unit, a unit of spectral flux density, or spectral irradiance. It is defined as 10 kJy, or 10^4 Jy. Dimension:  𝐌 𝐓^-2 See also:  Jy Reference:  Tapping (2013) source"},{"id":510,"pagetitle":"API Reference","title":"UnitfulAstro.TECU","ref":"/previews/PR43/UnitfulAstro/stable/api/#UnitfulAstro.TECU","content":" UnitfulAstro.TECU  —  Constant UnitfulAstro.TECU The total electron content unit, a unit of areal number density. It is defined as 10^16 m^-2. TODO cite Hofmann-Wellenhof (2001). Dimension:  𝐋^-2 Reference:  Hofmann-Wellenhof (2001) source"},{"id":513,"pagetitle":"Bibliography","title":"Bibliography","ref":"/previews/PR43/UnitfulAstro/stable/bibliography/#Bibliography","content":" Bibliography [1] IAU Division I Working Group Numerical Standards.  Resolution B2 on the Re-Definition of the Astronomical Unit of Length  (2012). [2] J. Binney and S. Tremaine.  Galactic Dynamics . 2nd Edition,  Princeton Series in Astrophysics  (Princeton University Press, Princeton, 2008). [3] Allen's Astrophysical Quantities  (Springer New York, New York, NY, 2002). [4] IAU Inter-Division A-G Working Group on Nominal Units for Stellar & Planetary Astronomy.  Resolution B2 on Recommended Zero Points for the Absolute and Apparent Bolometric Magnitude Scales  (2015). [5] IAU Inter-Division A-G Working Group on Nominal Units for Stellar & Planetary Astronomy.  Resolution B3 on Recommended Nominal Conversion Constants for Selected Solar and Planetary Properties  (2015). [6] M. Herant, S. Colgate, W. Benz and C. Fryer.  Neutrinos and Supernovae . Los Alamos Science, 164―178 (1997). [7] D. H. Hartmann.  Afterglows From the Largest Explosions in the Universe .  Proceedings of the National Academy of Science  96 , 4752–4755  (1999). [8] K. F. Tapping.  The 10.7 cm solar radio flux (F10.7) .  Space Weather  11 , 394–406  (2013). [9] B. Hofmann-Wellenhof.  Global Positioning System: Theory and Practice . 5th Edition (Springer Wien, Vienna, 2001)."},{"id":516,"pagetitle":"Home","title":"WCS.jl","ref":"/previews/PR43/WCS/stable/#WCS.jl","content":" WCS.jl Astronomical  World Coordinate System  library for Julia. This package wraps the WCSLIB C library. This is a tool made for users who are already familiar with WCS transformations. If you are not, please reference the following manuscripts Representation of world coordinates in FITS Representations of celestial coordinates in FITS Representations of spectral coordinates in FITS Representations of distortions in FITS world coordinate systems"},{"id":517,"pagetitle":"Home","title":"Table of Contents","ref":"/previews/PR43/WCS/stable/#Table-of-Contents","content":" Table of Contents WCS.jl Table of Contents Installation Usage API/Reference Index"},{"id":518,"pagetitle":"Home","title":"Installation","ref":"/previews/PR43/WCS/stable/#Installation","content":" Installation From the REPL, press  ]  to enter Pkg mode (v 1.2) pkg> add WCS"},{"id":519,"pagetitle":"Home","title":"Usage","ref":"/previews/PR43/WCS/stable/#Usage","content":" Usage Import the library julia> using WCS There are many ways to utilize WCS transformations. Let's make one for a 2-dimensional array (like an image) from scratch. julia> wcs = WCSTransform(2;\n                          cdelt = [-0.066667, 0.066667],\n                          ctype = [\"RA---AIR\", \"DEC--AIR\"],\n                          crpix = [-234.75, 8.3393],\n                          crval = [0., -90],\n                          pv    = [(2, 1, 45.0)])\nWCSTransform(naxis=2,cdelt=[-0.066667, 0.066667],crval=[0.0, -90.0],crpix=[-234.75, 8.3393]) We can also create one from a FITS header if it contains the appropriate keywords # Or from a FITS header with appropriate keywords\njulia> wcs_array = WCS.from_header(header)\n\njulia> wcs = wcs_array[1]\n Now we can do conversions between pixel and world coordinates. Note that WCS transforms use pixel  (0, 0)  as the top-left corner (not 1-indexed!!!) # convert pixel -> world coordinates\njulia> pixcoords = [0.0  24.0  45.0;  # x coordinates\n                    0.0  38.0  98.0]  # y coordinates\n2×3 Matrix{Float64}:\n 0.0  24.0  45.0\n 0.0  38.0  98.0\n\njulia> worldcoords = pix_to_world(wcs, pixcoords)\n2×3 Matrix{Float64}:\n 267.965   276.539   287.771\n -73.7366  -71.9741  -69.6781\njulia> pixcoords = world_to_pix(wcs, worldcoords)\n2×3 Matrix{Float64}:\n  1.16529e-12  24.0  45.0\n -7.10543e-14  38.0  98.0\n"},{"id":520,"pagetitle":"Home","title":"API/Reference","ref":"/previews/PR43/WCS/stable/#API/Reference","content":" API/Reference"},{"id":521,"pagetitle":"Home","title":"WCS.WCSTransform","ref":"/previews/PR43/WCS/stable/#WCS.WCSTransform","content":" WCS.WCSTransform  —  Type WCSTransform(naxis; kwds...) Construct a WCS transformation with the given number of axes  naxis . Keyword arguments can be passed to set various attributes of the transform. Specifying keyword arguments is equivalent to setting them after construction: julia> wcs = WCSTransform(2; crpix=[1000., 1000.]) is equilvalent to: julia> wcs = WCSTransform(2)\n\njulia> wcs.crpix = [1000., 1000.] Properties Below is the entire list of public properties for a  WCSTransform Keyword Type Description naxis Int Number of dimensions crval Vector{Float}[naxis] coordinate value at reference point crpix Vector{Float}[naxis] array location of the reference point in pixels cdelt Vector{Float}[naxis] coordinate increment at reference point crder Vector{Float}[naxis] random error in coordinate csyer Vector{Float}[naxis] systematic error in coordinate ctype Vector{String}[naxis] axis type (8 characters) crota Vector{Float}[naxis] rotation from stated coordinate type cunit Vector{String}[naxis] units of axes cunit Vector{String}[naxis] names of axes pc Matrix{Float}[naxis, naxis] linear transformation matrix cd Matrix{Float}[naxis, naxis] linear transformation matrix (with scale) equinox Float the equinox associated with dynamical equatorial or ecliptic coordinate systems latpole Float the native latitude of the celestial pole lonpole Float the native longitude of the celestial pole mjdavg Float Modified Julian Date corresponding to  DATE-AVG mjdobs Float Modified Julian Date corresponding to  DATE-OBS restfrq Float rest frequency (Hz) restwav Float rest wavelength (m) velangl Float velocity angle velosys Float relative radial velocity zsource Float the redshift of the source colnum Int column of FITS binary table associated with this WCS dateavg String representative mid-point of the date of observation dateobs String start of the date of observation radesys String the equatorial or ecliptic coordinate system type specsys String spectral reference frame (standard of rest) ssysobs String spectral reference frame ssyssrc String spectral reference frame for redshift wcsname String name of this coordinate representation obsgeo Vector{Float}[3]  or  Vector{Float}[6] location of the observer in a standard terrestrial reference frame alt String character code for alternate coordinate descriptions source"},{"id":522,"pagetitle":"Home","title":"WCS.from_header","ref":"/previews/PR43/WCS/stable/#WCS.from_header-Tuple{String}","content":" WCS.from_header  —  Method from_header(header[; relax=WCS.HDR_ALL, ctrl=0, ignore_rejected=false, table=false]) Parse the FITS image header in the String  header , returning a  Vector{WCSTransform}  giving all the transforms defined in the header. The  relax  determines the treatment of non-standard keywords. The default is to accept all known non-standard keywords. Use  relax=WCS.HDR_NONE  to ignore all non-standard keywords. Use, e.g.,  relax=(WCS.HDR_RADECSYS & WCS.HDR_CROTAia)  to only accept selected non-standard keywords. source"},{"id":523,"pagetitle":"Home","title":"WCS.obsfix","ref":"/previews/PR43/WCS/stable/#WCS.obsfix-Tuple{Integer, WCSTransform}","content":" WCS.obsfix  —  Method obsfix(ctrl::Integer, wcs::WCSTransform) Complete the  obsgeo  field  wcs  of observatory coordinates.  That is, if only the (x,y,z) Cartesian coordinate triplet or the (l,b,h) geodetic coordinate triplet are set, then it derives the other triplet from it. If both triplets are set, then it checks for consistency at the level of 1 metre. Parameters ctrl : flag that controls behaviour if one triplet is defined and the other is only partially defined: 0: Reset only the undefined elements of an incomplete coordinate triplet. 1: Reset all elements of an incomplete triplet. 2: Don't make any changes, check for consistency only. Returns an error if either of the two triplets is incomplete. wcs : Coordinate transformation parameters. Its  obsgeo  field may be changed. Returns -1: No change required (not an error). 0: Success. 1: Null wcsprm pointer passed. 5: Invalid parameter value. source"},{"id":524,"pagetitle":"Home","title":"WCS.pix_to_world!","ref":"/previews/PR43/WCS/stable/#WCS.pix_to_world!-Tuple{WCSTransform, VecOrMat{Float64}, VecOrMat{Float64}}","content":" WCS.pix_to_world!  —  Method pix_to_world!(wcs, pixcoords, worldcoords[; stat=, imcoords=, phi=, theta=]) Convert the array of pixel coordinates  pixcoords  to world coordinates according to the WCSTransform  wcs , storing the result in the  worldcoords  and  stat  arrays.  pixcoords  should be a 2-d array where \"pixcoords[:, i]\" is the i-th set of coordinates, or a 1-d array representing a single set of coordinates.  worldcoords  must be the same size and type as  pixcoords . If given, the arrays  stat ,  imcoords ,  phi ,  theta  will be used to store intermediate results. Their sizes and types must all match  pixcoords , except for  stat  which should be the same size but of type Cint (typically Int32). source"},{"id":525,"pagetitle":"Home","title":"WCS.pix_to_world","ref":"/previews/PR43/WCS/stable/#WCS.pix_to_world-Tuple{WCSTransform, VecOrMat{Float64}}","content":" WCS.pix_to_world  —  Method pix_to_world(wcs, pixcoords) Convert the array of pixel coordinates  pixcoords  to world coordinates according to the WCSTransform  wcs .  pixcoords  should be a 2-d array where \"pixcoords[:, i]\" is the i-th set of coordinates, or a 1-d array representing a single set of coordinates. The return value is the same shape as  pixcoords . source"},{"id":526,"pagetitle":"Home","title":"WCS.to_header","ref":"/previews/PR43/WCS/stable/#WCS.to_header-Tuple{WCSTransform}","content":" WCS.to_header  —  Method to_header(wcs[; relax=WCS.HDR_NONE]) Encode the WCSTransform  wcs  as a FITS header string. The  relax  keyword controls how non-standard extensions to the WCS standard are handled. source"},{"id":527,"pagetitle":"Home","title":"WCS.world_to_pix!","ref":"/previews/PR43/WCS/stable/#WCS.world_to_pix!-Tuple{WCSTransform, VecOrMat{Float64}, VecOrMat{Float64}}","content":" WCS.world_to_pix!  —  Method world_to_pix!(wcs, worldcoords, pixcoords[; stat=, phi=, theta=, imcoords=]) Convert the array of pixel coordinates  worldcoords  to pixel coordinates according to the WCSTransform  wcs , storing the result in the  pixcoords  array.  worldcoords  should be a 2-d array where \"worldcoords[:, i]\" is the i-th set of coordinates, or a 1-d array representing a single set of coordinates.  pixcoords  must be the same size and type as  worldcoords . If given, the arrays  stat ,  imcoords ,  phi ,  theta  will be used to store intermediate results. Their sizes and types must all match  worldcoords , except for  stat  which should be the same size but of type Cint (typically Int32). source"},{"id":528,"pagetitle":"Home","title":"WCS.world_to_pix","ref":"/previews/PR43/WCS/stable/#WCS.world_to_pix-Tuple{WCSTransform, VecOrMat{Float64}}","content":" WCS.world_to_pix  —  Method world_to_pix(wcs, worldcoords) Convert the array of world coordinates  worldcoords  to pixel coordinates according to the WCSTransform  wcs .  worldcoords  is a 2-d array where \"worldcoords[:, i]\" is the i-th set of coordinates, or a 1-d array representing a single set of coordinates. The return value is the same size as  worldcoords . source"},{"id":529,"pagetitle":"Home","title":"Index","ref":"/previews/PR43/WCS/stable/#Index","content":" Index WCS.WCSTransform WCS.from_header WCS.obsfix WCS.pix_to_world WCS.pix_to_world! WCS.to_header WCS.world_to_pix WCS.world_to_pix!"},{"id":534,"pagetitle":"Home","title":"Home","ref":"/previews/PR43/AstroImages/stable/#Home","content":" Home GitHub link AstroImage.jl  allows you to plot images from an astronomical  FITS  file using the popular  Images.jl  and  Plots.jl  Julia packages.  AstroImage.jl  uses  FITSIO.jl  to read FITS files."},{"id":537,"pagetitle":"API","title":"API Documentation","ref":"/previews/PR43/AstroImages/stable/api/#API-Documentation","content":" API Documentation"},{"id":538,"pagetitle":"API","title":"FileIO.load","ref":"/previews/PR43/AstroImages/stable/api/#FileIO.load","content":" FileIO.load  —  Function load(filename)  loads the contents of a formatted file, trying to infer the format from  filename  and/or magic bytes in the file (see  query ). load(strm)  loads from an  IOStream  or similar object. In this case, there is no filename extension, so we rely on the magic bytes for format identification. load(File{format\"PNG\"}(filename))  specifies the format directly, and bypasses the format  query . load(Stream{format\"PNG\"}(io))  specifies the format directly, and bypasses the format  query . load(f; options...)  passes keyword arguments on to the loader."},{"id":539,"pagetitle":"API","title":"FileIO.save","ref":"/previews/PR43/AstroImages/stable/api/#FileIO.save","content":" FileIO.save  —  Function save(filename, data...)  saves the contents of a formatted file, trying to infer the format from  filename . save(Stream{format\"PNG\"}(io), data...)  specifies the format directly, and bypasses the format  query . save(File{format\"PNG\"}(filename), data...)  specifies the format directly, and bypasses the format  query . save(f, data...; options...)  passes keyword arguments on to the saver."},{"id":540,"pagetitle":"API","title":"AstroImages.AstroImage","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.AstroImage","content":" AstroImages.AstroImage  —  Type Provides access to a FITS image along with its accompanying  header and WCS information, if applicable. source"},{"id":541,"pagetitle":"API","title":"AstroImages.imview","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.imview","content":" AstroImages.imview  —  Function imview(img; clims=Percent(99.5), stretch=identity, cmap=:magma, contrast=1.0, bias=0.5) Create a read only view of an array or AstroImageMat mapping its data values to Colors according to  clims ,  stretch , and  cmap . The data is first clamped to  clims , which can either be a tuple of (min, max) values or a function accepting an iterator of pixel values that returns (min, max). By default,  clims=extrema  i.e. the minimum and maximum of  img . Convenient functions to use for  clims  are:  extrema ,  zscale , and  percent(p) Next, the data is rescaled to [0,1] and remapped according to the function  stretch . Stretch can be any monotonic fuction mapping values in the range [0,1] to some range [a,b]. Note that  log(0)  is not defined so is not directly supported. For a list of convenient stretch functions, see:  logstretch ,  powstretch ,  squarestretch ,  asinhstretch ,  sinhstretch ,  powerdiststretch Finally the data is mapped to RGB values according to  cmap . If cmap is  nothing , grayscale is used. ColorSchemes.jl defines hundreds of colormaps. A few nice ones for images include:  :viridis ,  :magma ,  :plasma ,  :thermal , and  :turbo . Crucially, this function returns a view over the underlying data. If  img  is updated then those changes will be reflected by this view with the exception of  clims  which is not recalculated. Note: if clims or stretch is a function, the pixel values passed in are first filtered to remove non-finite or missing values. Defaults The default values of  clims ,  stretch , and  cmap  are  extrema ,  identity , and  nothing  respectively. You may alter these defaults using  AstroImages.set_clims! ,   AstroImages.set_stretch! , and  AstroImages.set_cmap! . Automatic Display Arrays wrapped by  AstroImageMat()  get displayed as images automatically by calling   imview  on them with the default settings when using displays that support showing PNG images. Missing data Pixels that are  NaN  or  missing  will be displayed as transparent when  cmap  is set or black if. +/- Inf will be displayed as black or white respectively. Exporting Images The view returned by  imview  can be saved using general  FileIO.save  methods. Example: v = imview(data, cmap=:magma, stretch=asinhstretch, clims=percent(95))\nsave(\"output.png\", v) source imview(img::AbstractArray{<:Complex}; ...) When applied to an image with complex values, display the magnitude of the pixels using  imview  and display the phase angle as a panel below using a cyclical color map. For more customatization, you can create a view like this yourself: vcat(\n    imview(abs.(img)),\n    imview(angle.(img)),\n) source"},{"id":542,"pagetitle":"API","title":"AstroImages.implot","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.implot","content":" AstroImages.implot  —  Function implot(\n    img::AbstractArray;\n    clims=Percent(99.5),\n    stretch=identity,\n    cmap=:magma,\n    bias=0.5,\n    contrast=1,\n    wcsticks=true,\n    grid=true,\n    platescale=1\n) Create a read only view of an array or AstroImageMat mapping its data values to an array of Colors. Equivalent to: implot(\n    imview(\n        img::AbstractArray;\n        clims=Percent(99.5),\n        stretch=identity,\n        cmap=:magma,\n        bias=0.5,\n        contrast=1,\n    ),\n    wcsn=1,\n    wcsticks=true,\n    wcstitle=true,\n    grid=true,\n    platescale=1\n) Image Rendering See  imview  for how data is mapped to RGBA pixel values. WCS & Image Coordinates If provided with an AstroImage that has WCS headers set, the tick marks and plot grid are calculated using WCS.jl. By default, use the first WCS coordinate system. The underlying pixel coordinates are those returned by  dims(img)  multiplied by  platescale . This allows you to overplot lines, regions, etc. using pixel coordinates. If you wish to compute the pixel coordinate of a point in world coordinates, see  world_to_pix . wcsn  (default  1 ) select which WCS transform in the headers to use for ticks & grid wcsticks  (default  true  if WCS headers present) display ticks and labels, and title using world coordinates wcstitle  (default  true  if WCS headers present and  length(refdims(img))>0 ). When slicing a cube, display the location along unseen axes in world coordinates instead of pixel coordinates. grid  (default  true ) show a grid over the plot. Uses WCS coordinates if  wcsticks  is true, otherwise pixel coordinates multiplied by  platescale . platescale  (default  1 ). Scales the underlying pixel coordinates to ease overplotting, etc. If  wcsticks  is false, the displayed pixel coordinates are also scaled. Defaults The default values of  clims ,  stretch , and  cmap  are  extrema ,  identity , and  nothing  respectively. You may alter these defaults using  AstroImages.set_clims! ,   AstroImages.set_stretch! , and  AstroImages.set_cmap! . source"},{"id":543,"pagetitle":"API","title":"DimensionalData.Dimensions.dims","ref":"/previews/PR43/AstroImages/stable/api/#DimensionalData.Dimensions.dims","content":" DimensionalData.Dimensions.dims  —  Function dims(x, [dims::Tuple]) => Tuple{Vararg{<:Dimension}}\ndims(x, dim) => Dimension Return a tuple of  Dimension s for an object, in the order that matches the axes or columns of the underlying data. dims  can be  Dimension ,  Dimension  types, or  Symbols  for  Dim{Symbol} . The default is to return  nothing ."},{"id":544,"pagetitle":"API","title":"DimensionalData.Dimensions.refdims","ref":"/previews/PR43/AstroImages/stable/api/#DimensionalData.Dimensions.refdims","content":" DimensionalData.Dimensions.refdims  —  Function refdims(x, [dims::Tuple]) => Tuple{Vararg{<:Dimension}}\nrefdims(x, dim) => Dimension Reference dimensions for an array that is a slice or view of another array with more dimensions. slicedims(a, dims)  returns a tuple containing the current new dimensions and the new reference dimensions. Refdims can be stored in a field or disgarded, as it is mostly to give context to plots. Ignoring refdims will simply leave some captions empty. The default is to return an empty  Tuple () ."},{"id":545,"pagetitle":"API","title":"AstroImages.Comment","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.Comment","content":" AstroImages.Comment  —  Type Index for accessing a comment associated with a header keyword or COMMENT entry. Example: img = AstroImage(randn(10,10))\nimg[\"ABC\"] = 1\nimg[\"ABC\", Comment] = \"A comment describing this key\"\n\npush!(img, Comment, \"The purpose of this file is to demonstrate comments\")\nimg[Comment] # [\"The purpose of this file is to demonstrate comments\")] source"},{"id":546,"pagetitle":"API","title":"AstroImages.History","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.History","content":" AstroImages.History  —  Type Allows accessing and setting HISTORY header entries img = AstroImage(randn(10,10)) push!(img, History, \"2023-04-19: Added history entry.\") img[History] # [\"2023-04-19: Added history entry.\"] source"},{"id":547,"pagetitle":"API","title":"WCS.pix_to_world","ref":"/previews/PR43/AstroImages/stable/api/#WCS.pix_to_world","content":" WCS.pix_to_world  —  Function pix_to_world(wcs, pixcoords) Convert the array of pixel coordinates  pixcoords  to world coordinates according to the WCSTransform  wcs .  pixcoords  should be a 2-d array where \"pixcoords[:, i]\" is the i-th set of coordinates, or a 1-d array representing a single set of coordinates. The return value is the same shape as  pixcoords . pix_to_world(img::AstroImage, pixcoords; all=false) Given an astro image, look up the world coordinates of the pixels given  by  pixcoords . World coordinates are resolved using WCS.jl and a WCSTransform calculated from any FITS header present in  img . If no WCS information is in the header, or the axes are all linear, this will just return pixel coordinates. pixcoords  should be the coordinates in your current selection of the image. For example, if you select a slice like this: julia> cube = load(\"some-3d-cube.fits\")\njulia> slice = cube[10:20, 30:40, 5] Then to look up the coordinates of the pixel in the bottom left corner of  slice , run: julia> world_coords = pix_to_world(img, [1, 1])\n[10, 30] If WCS information was present in the header of  cube , then those coordinates would be resolved using axis 1, 2, and 3 respectively. To include world coordinates in all axes, pass  all=true julia> world_coords = pix_to_world(img, [1, 1], all=true)\n[10, 30, 5] !! Coordinates must be provided in the order of  dims(img) . If you transpose  an image, the order you pass the coordinates should not change. source"},{"id":548,"pagetitle":"API","title":"WCS.world_to_pix","ref":"/previews/PR43/AstroImages/stable/api/#WCS.world_to_pix","content":" WCS.world_to_pix  —  Function world_to_pix(wcs, worldcoords) Convert the array of world coordinates  worldcoords  to pixel coordinates according to the WCSTransform  wcs .  worldcoords  is a 2-d array where \"worldcoords[:, i]\" is the i-th set of coordinates, or a 1-d array representing a single set of coordinates. The return value is the same size as  worldcoords ."},{"id":549,"pagetitle":"API","title":"DimensionalData.Dimensions.X","ref":"/previews/PR43/AstroImages/stable/api/#DimensionalData.Dimensions.X","content":" DimensionalData.Dimensions.X  —  Type X <: XDim\n\nX(val=:) X  Dimension .  X <: XDim <: IndependentDim Example: xdim = X(2:2:10)\n# Or\nval = A[X(1)]\n# Or\nmean(A; dims=X)"},{"id":550,"pagetitle":"API","title":"DimensionalData.Dimensions.Y","ref":"/previews/PR43/AstroImages/stable/api/#DimensionalData.Dimensions.Y","content":" DimensionalData.Dimensions.Y  —  Type Y <: YDim\n\nY(val=:) Y  Dimension .  Y <: YDim <: DependentDim Example: ydim = Y(['a', 'b', 'c'])\n# Or\nval = A[Y(1)]\n# Or\nmean(A; dims=Y)"},{"id":551,"pagetitle":"API","title":"DimensionalData.Dimensions.Z","ref":"/previews/PR43/AstroImages/stable/api/#DimensionalData.Dimensions.Z","content":" DimensionalData.Dimensions.Z  —  Type Z <: ZDim\n\nZ(val=:) Z  Dimension .  Z <: ZDim <: Dimension Example: zdim = Z(10:10:100)\n# Or\nval = A[Z(1)]\n# Or\nmean(A; dims=Z)"},{"id":552,"pagetitle":"API","title":"DimensionalData.Dimensions.Dim","ref":"/previews/PR43/AstroImages/stable/api/#DimensionalData.Dimensions.Dim","content":" DimensionalData.Dimensions.Dim  —  Type Dim{S}(val=:) A generic dimension. For use when custom dims are required when loading data from a file. Can be used as keyword arguments for indexing. Dimension types take precedence over same named  Dim  types when indexing with symbols, or e.g. creating Tables.jl keys. using DimensionalData\n\ndim = Dim{:custom}(['a', 'b', 'c'])\n\n# output\n\nDim{:custom} Char[a, b, c]"},{"id":553,"pagetitle":"API","title":"DimensionalData.Dimensions.LookupArrays.At","ref":"/previews/PR43/AstroImages/stable/api/#DimensionalData.Dimensions.LookupArrays.At","content":" DimensionalData.Dimensions.LookupArrays.At  —  Type At <: Selector\n\nAt(x, atol, rtol)\nAt(x; atol=nothing, rtol=nothing) Selector that exactly matches the value on the passed-in dimensions, or throws an error. For ranges and arrays, every intermediate value must match an existing value - not just the end points. x  can be any value or  Vector  of values. atol  and  rtol  are passed to  isapprox . For  Number rtol  will be set to  Base.rtoldefault , otherwise  nothing , and wont be used. Example using DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))\nA[X(At(20)), Y(At(6))]\n\n# output\n\n5"},{"id":554,"pagetitle":"API","title":"DimensionalData.Dimensions.LookupArrays.Near","ref":"/previews/PR43/AstroImages/stable/api/#DimensionalData.Dimensions.LookupArrays.Near","content":" DimensionalData.Dimensions.LookupArrays.Near  —  Type Near <: Selector\n\nNear(x) Selector that selects the nearest index to  x . With  Points  this is simply the index values nearest to the  x , however with  Intervals  it is the interval  center  nearest to  x . This will be offset from the index value for  Start  and  End  loci. Example using DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))\nA[X(Near(23)), Y(Near(5.1))]\n\n# output\n4"},{"id":555,"pagetitle":"API","title":"AstroImages.header","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.header","content":" AstroImages.header  —  Function header(img::AstroImage) Return the underlying FITSIO.FITSHeader object wrapped by an AstroImage. Note that this object has less flexible getindex and setindex methods. Indexing by symbol, Comment, History, etc are not supported. source header(array::AbstractArray) Returns an empty FITSIO.FITSHeader object when called with a non-AstroImage abstract array. source"},{"id":556,"pagetitle":"API","title":"AstroImages.wcs","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.wcs","content":" AstroImages.wcs  —  Function wcs(img) Computes and returns a list of World Coordinate System WCSTransform objects from WCS.jl. The resultss are cached after the first call, so subsequent calls are fast. Modifying a WCS header invalidates this cache automatically, so users should call  wcs(...)  each time rather than keeping the WCSTransform object around. source wcs(img, index) Computes and returns a World Coordinate System WCSTransform objects from WCS.jl by index. This is to support files with multiple WCS transforms specified.  wcs(img,1)  is useful for selecting selecting the first WCSTranform object. The resultss are cached after the first call, so subsequent calls are fast. Modifying a WCS header invalidates this cache automatically, so users should call  wcs(...)  each time rather than keeping the WCSTransform object around. source wcs(array) Returns a list with a single basic WCSTransform object when called with a non-AstroImage abstract array. source"},{"id":557,"pagetitle":"API","title":"AstroImages.WCSGrid","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.WCSGrid","content":" AstroImages.WCSGrid  —  Type WCSGrid(img::AstroImageMat, ax=(1,2), coords=(first(axes(img,ax[1])),first(axes(img,ax[2])))) Given an AstroImageMat, return information necessary to plot WCS gridlines in physical coordinates against the image's pixel coordinates. This function has to work on both plotted axes at once to handle rotation and general curvature of the WCS grid projected on the image coordinates. source"},{"id":558,"pagetitle":"API","title":"AstroImages.composecolors","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.composecolors","content":" AstroImages.composecolors  —  Function composecolors(\n    images,\n    cmap=[\"#F00\", \"#0F0\", \"#00F\"];\n    clims,\n    stretch,\n    contrast,\n    bias,\n    multiplier\n) Create a color composite of multiple images by applying  imview  and blending  the results. This function can be used to create RGB composites using any number of channels (e.g. red, green, blue, and hydrogen alpha) as well as more exotic images like blending radio and optical data using two different colormaps. cmap  should be a list of colorants, named colors (see Colors.jl), or colorschemes (see ColorSchemes.jl).  clims ,  stretch ,  contrast , and  bias  are passed on to  imview . They can be a single value or a list of different values for each image. Examples: # Basic RGB\ncomposecolors([redimage, greenimage, blueimage])\n# Non-linear stretch before blending\ncomposecolors([redimage, greenimage, blueimage], stretch=asinhstretch)\n# More than three channels are allowed (H alpha in pink)\ncomposecolors(\n    [antred, antgreen, antblue, anthalp],\n    [\"red\", \"green\", \"blue\", \"maroon1\"],\n    multiplier=[1,2,1,1]\n)\n# Can mix \ncomposecolors([radioimage, xrayimage], [:ice, :magma], clims=extrema)\ncomposecolors([radioimage, xrayimage], [:magma, :viridis], clims=[Percent(99), Zscale()]) source"},{"id":559,"pagetitle":"API","title":"AstroImages.Zscale","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.Zscale","content":" AstroImages.Zscale  —  Type Zscale(options)(data) Wraps PlotUtils.zscale in a callable with default parameters. This is a common algorithm for agressively stretching astronomical data to see faint structure that originated in IRAF: https://iraf.net/forum/viewtopic.php?showtopic=134139 but is now seen in many other applications/libraries (DS9, Astropy, etc.) Usage: imview(img, clims=Zscale())\nimplot(img, clims=Zscale(contrast=0.1)) Default parameters: nsamples::Int=1000\ncontrast::Float64=0.25\nmax_reject::Float64=0.5\nmin_npixels::Float64=5\nk_rej::Float64=2.5\nmax_iterations::Int=5 source"},{"id":560,"pagetitle":"API","title":"AstroImages.Percent","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.Percent","content":" AstroImages.Percent  —  Type Percent(99.5) Returns a callable that calculates display limits that include the given  percent of the image data. Reproduces the behaviour of the SAO DS9 scale menu. Example: julia> imview(img, clims=Percent(90)) This will set the limits to be the 5th percentile to the 95th percentile. source"},{"id":561,"pagetitle":"API","title":"AstroImages.logstretch","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.logstretch","content":" AstroImages.logstretch  —  Function logstretch(num,a=1000) A log-stretch as defined by the SAO DS9 application: http://ds9.si.edu/doc/ref/how.html source"},{"id":562,"pagetitle":"API","title":"AstroImages.powstretch","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.powstretch","content":" AstroImages.powstretch  —  Function powstretch(num, a=1000) A power-stretch as defined by the SAO DS9 application: http://ds9.si.edu/doc/ref/how.html source"},{"id":563,"pagetitle":"API","title":"AstroImages.sqrtstretch","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.sqrtstretch","content":" AstroImages.sqrtstretch  —  Function sqrtstretch(num) A square root stretch (simply defined as Base.sqrt) source"},{"id":564,"pagetitle":"API","title":"AstroImages.squarestretch","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.squarestretch","content":" AstroImages.squarestretch  —  Function squarestretch(num) A squarestretch-stretch as defined by the SAO DS9 application: http://ds9.si.edu/doc/ref/how.html source"},{"id":565,"pagetitle":"API","title":"AstroImages.asinhstretch","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.asinhstretch","content":" AstroImages.asinhstretch  —  Function asinhstretch(num) A hyperbolic arcsin stretch as defined by the SAO DS9 application: http://ds9.si.edu/doc/ref/how.html. source"},{"id":566,"pagetitle":"API","title":"AstroImages.sinhstretch","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.sinhstretch","content":" AstroImages.sinhstretch  —  Function sinhstretch(num) A hyperbolic sin stretch as defined by the SAO DS9 application: http://ds9.si.edu/doc/ref/how.html source"},{"id":567,"pagetitle":"API","title":"AstroImages.powerdiststretch","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.powerdiststretch","content":" AstroImages.powerdiststretch  —  Function logstretch(num,a=1000) A power distance stretch as defined by astropy. source"},{"id":568,"pagetitle":"API","title":"AstroImages.copyheader","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.copyheader","content":" AstroImages.copyheader  —  Function copyheader(img::AstroImage, data) -> imgnew Create a new image copying the header of  img  but using the data of the AbstractArray  data . Note that changing the header of  imgnew  does not affect the header of  img . See also:  shareheader . source"},{"id":569,"pagetitle":"API","title":"AstroImages.shareheader","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.shareheader","content":" AstroImages.shareheader  —  Function shareheader(img::AstroImage, data) -> imgnew Create a new image reusing the header dictionary of  img  but using the data of the AbstractArray  data . The two images have synchronized header; modifying one also affects the other. See also:  copyheader . source"},{"id":572,"pagetitle":"Contours","title":"Contours","ref":"/previews/PR43/AstroImages/stable/guide/contours/#Contours","content":" Contours This guide shows a few different ways to measure and visualize contours of images."},{"id":573,"pagetitle":"Contours","title":"Using Plots","ref":"/previews/PR43/AstroImages/stable/guide/contours/#Using-Plots","content":" Using Plots The most basic way to create a contour plot is simply to use Plots.jl  contour  and  contourf  functions on your image. Let's see how that works: using AstroImages, Plots\n\n\n# First load a FITS file of interest\nfname = download(\n    \"http://www.astro.uvic.ca/~wthompson/astroimages/fits/herca/herca_radio.fits\",\n    \"herca-radio.fits\"\n)\n\nherca = load(\"herca-radio.fits\") Create a contour plot contour(herca)"},{"id":576,"pagetitle":"Blurring & Filtering Images","title":"Image Filtering","ref":"/previews/PR43/AstroImages/stable/guide/image-filtering/#Image-Filtering","content":" Image Filtering The package  ImageFiltering.jl  makes it easy to apply arbitrary filters to images."},{"id":577,"pagetitle":"Blurring & Filtering Images","title":"Gaussian Blurs","ref":"/previews/PR43/AstroImages/stable/guide/image-filtering/#Gaussian-Blurs","content":" Gaussian Blurs Let's start by downloading a radio image of Hercules A: using AstroImages\nusing ImageFiltering\n\nfname = download(\n    \"http://www.astro.uvic.ca/~wthompson/astroimages/fits/herca/herca_radio.fits\",\n    \"herca-radio.fits\"\n)\n\nherca = load(\"herca-radio.fits\") Let's now apply a Gaussian blur (aka a low pass filter) using the  imfilter  function: herca_blur_20 = imfilter(herca, Kernel.gaussian(20.0)) The image has been smoothed out by convolving it with a wide Gaussian. Let's now do the opposite and perform a high-pass filter. This will bring out faint variations in structure. We can do this by subtracting a blurred image from the original: herca_blur_4 = imfilter(herca, Kernel.gaussian(4.0))\nherca_highpass = herca .- herca_blur_4 We now see lots of faint structure inside the jets! Finally, let's adjust how the image is displayed and apply a non-linear stretch: imview(\n    herca_highpass,\n    cmap=:seaborn_rocket_gradient,\n    clims=(-50,1500),\n    stretch=asinhstretch\n) If you have Plots loaded, we can add a colorbar and coordinate axes by switching to  implot : using Plots\nimplot(\n    herca_highpass,\n    cmap=:seaborn_rocket_gradient,\n    clims=(-50,1500),\n    stretch=asinhstretch\n)"},{"id":578,"pagetitle":"Blurring & Filtering Images","title":"Median Filtering","ref":"/previews/PR43/AstroImages/stable/guide/image-filtering/#Median-Filtering","content":" Median Filtering In addition to linear filters using  imfilter , ImageFiltering.jl also includes a great function called  mapwindow . This functions allows you to map an arbitrary function over a patch of an image.  Let's use  mapwindow  to perform a median filter. This is a great way to suppress salt and pepper noise, or remove stars from some images. We'll use a Hubble picture of the Eagle nebula: using AstroImages\nusing ImageFiltering\n\nfname = download(\n    \"http://www.astro.uvic.ca/~wthompson/astroimages/fits/eagle/673nmos.fits\",\n    \"eagle-673nmos.fits\"\n)\n\neagle673 = load(\"eagle-673nmos.fits\") The data is originally from https://esahubble.org/projects/fits_liberator/eagledata/. We can apply a median filter using  mapwindow . Make sure the patch size is an odd number in each direction! using Statistics\nmedfilt = copyheader(eagle673, mapwindow(median, eagle673, (11,11))) We use  copyheader  here since  mapwindow  returns a plain array and drops the image meta data. We can put this side by side with the original to see how some of the faint stars have been removed from the image: imview([eagle673[1:800,1:800]; medfilt[1:800,1:800]])"},{"id":581,"pagetitle":"Transforming Images","title":"Image Transformations","ref":"/previews/PR43/AstroImages/stable/guide/image-transformations/#Image-Transformations","content":" Image Transformations The  ImageTransformations.jl  package contains many useful functions for manipulating astronomical images. Note however that many of these functions drop the AstroImage wrapper and return plain arrays or OffsetArrays. They can be re-wrapped using  copyheader  or  shareheader  if you'd like to preserve the FITS header, dimension labels, WCS information, etc. You can install ImageTransformations by running  ] add ImageTransformations  at the REPL. For these examples, we'll download an image of the Antenae galaxies from Hubble: using AstroImages\nusing ImageTransformations\n\nfname = download(\n    \"http://www.astro.uvic.ca/~wthompson/astroimages/fits/antenae/blue.fits\",\n    \"ant-blue.fits\"\n)\n\nantblue = load(\"ant-blue.fits\")\n\n# We'll change the defaults to avoid setting them each time\nAstroImages.set_clims!(Percent(99))\nAstroImages.set_cmap!(:ice)\nAstroImages.set_stretch!(asinhstretch)\n\nimview(antblue)"},{"id":582,"pagetitle":"Transforming Images","title":"Rotations","ref":"/previews/PR43/AstroImages/stable/guide/image-transformations/#Rotations","content":" Rotations We can rotate images using the  imrotate  function. imrotate(antblue, 3π/4) |> imview The rotation angle is in radians, but you can use the function  rad2deg  to convert from degrees."},{"id":583,"pagetitle":"Transforming Images","title":"Resizing","ref":"/previews/PR43/AstroImages/stable/guide/image-transformations/#Resizing","content":" Resizing We can resize images using the  imresize  function: imresize(antblue, ratio=0.2) |> imview"},{"id":584,"pagetitle":"Transforming Images","title":"Arbitrary Transformations","ref":"/previews/PR43/AstroImages/stable/guide/image-transformations/#Arbitrary-Transformations","content":" Arbitrary Transformations Arbitrary transformations can be performed using ImageTransformation's  warp  function. See the documentation linked above for more details."},{"id":585,"pagetitle":"Transforming Images","title":"Mapping from One Coordinate System to Another","ref":"/previews/PR43/AstroImages/stable/guide/image-transformations/#Mapping-from-One-Coordinate-System-to-Another","content":" Mapping from One Coordinate System to Another For transforming an image from one coordiante system (say, RA & DEC) to another (e.g., galactic lattitude & logitude), see  Reprojecting Images ."},{"id":588,"pagetitle":"Extracting Photometry","title":"Photometry","ref":"/previews/PR43/AstroImages/stable/guide/photometry/#Photometry","content":" Photometry The following examples are adapted from  Photometry.jl  to show the same examples combined with AstroImages.jl. To learn how to measure background levels, perform aperture photometry, etc see the  Photometry.jl documentation ."},{"id":589,"pagetitle":"Extracting Photometry","title":"Background Estimation","ref":"/previews/PR43/AstroImages/stable/guide/photometry/#Background-Estimation","content":" Background Estimation From Photometry.jl: Estimating backgrounds is an important step in performing photometry. Ideally, we could perfectly describe the background with a scalar value or with some distribution. Unfortunately, it's impossible for us to precisely separate the background and foreground signals. Here, we use mixture of robust statistical estimators and meshing to let us get the spatially varying background from an astronomical photo. Let's show an example Now let's try and estimate the background using estimate_background. First, we'll si gma-clip to try and remove the signals from the stars. Then, the background is broken down into boxes, in this case of size (50, 50). Within each box, the given statistical estimators get the background value and RMS. By default, we use SourceExtractorBackground and StdRMS. This creates a low-resolution image, which we then need to resize. We can accomplish this using an interpolator, by default a cubic-spline interpolator via ZoomInterpolator. The end result is a smooth estimate of the spatially varying background and background RMS. using Photometry\nusing AstroImages\nusing Plots # optional, for implot functionality\n\n# Download our image, courtesy of astropy\nimage = AstroImage(download(\"https://rawcdn.githack.com/astropy/photutils-datasets/8c97b4fa3a6c9e6ea072faeed2d49a20585658ba/data/M6707HH.fits\"))\n\n# sigma-clip\nclipped = sigma_clip(image, 1, fill=NaN)\n\n# get background and background rms with box-size (50, 50)\nbkg, bkg_rms = estimate_background(clipped, 50)\n\nimview(image)\nimview(clipped)\nimview(bkg)\nimview(bkg_rms) Or, if you have Plots loaded: using Plots\n\n    AstroImages.set_clims!(Percent(99.5))\n    AstroImages.set_cmap!(:magma)\n    AstroImages.set_stretch!(identity)\nplot(\n    implot(image, title=\"Original\"),\n    implot(clipped, title=\"Sigma-Clipped\"),\n    implot(bkg, title=\"Background\"),\n    implot(bkg_rms, title=\"Background RMS\"),\n    layout=(2, 2)\n) We could apply a median filter, too, by specifying filter_size # get background and background rms with box-size (50, 50) and filter_size (5, 5)\nbkg_f, bkg_rms_f = estimate_background(clipped, 50, filter_size=5)\n\n# plot\nplot(\n    implot(bkg, title=\"Unfiltered\", ylabel=\"Background\"),\n    implot(bkg_f, title=\"Filtered\"),\n    implot(bkg_rms, ylabel=\"RMS\"),\n    implot(bkg_rms_f);\n    layout=(2, 2),) Now we can see our image after subtracting the filtered background and ready for Aperture Photometry! subt = image .- bkg_f[axes(image)...]\nclims = extrema(vcat(vec(image), vec(subt)))\nplot(\n    implot(image; title=\"Original\", clims),\n    implot(subt; title=\"Subtracted\", clims),\n    size=(1600,1000)\n)"},{"id":590,"pagetitle":"Extracting Photometry","title":"Source Extraction","ref":"/previews/PR43/AstroImages/stable/guide/photometry/#Source-Extraction","content":" Source Extraction From the background-subtracted image, we can detect all sources in the image: # We specify the uncertainty in the pixel data. We'll set it equal to zero.\nerrs = zeros(axes(subt))\nsources = extract_sources(PeakMesh(), subt, errs, true) # sort from brightest to darkest Table with 3 columns and 60924 rows:\n      x     y     value\n    ┌────────────────────\n 1  │ 255   226   9762.42\n 2  │ 940   681   9661.5\n 3  │ 219   924   9653.78\n 4  │ 38    678   9647.93\n 5  │ 245   85    9637.55\n 6  │ 44    1001  9633.13\n 7  │ 503   904   9627.34\n 8  │ 819   775   9625.92\n 9  │ 610   62    9617.79\n 10 │ 133   110   9616.88\n 11 │ 592   123   9614.86\n 12 │ 1055  248   9612.46\n 13 │ 424   86    9611.86\n 14 │ 558   125   9585.93\n 15 │ 125   1021  9582.11\n 16 │ 112   637   9579.71\n 17 │ 196   2     9579.49\n ⋮  │  ⋮     ⋮       ⋮ There's over 60,000 sources! We'll define a circular apperture for each source: aps = CircularAperture.(sources.x, sources.y, 6)[1:1000] # just brightest thousand point sources 1000-element Vector{CircularAperture{Int64}}:\n CircularAperture(255, 226, r=6)\n CircularAperture(940, 681, r=6)\n CircularAperture(219, 924, r=6)\n CircularAperture(38, 678, r=6)\n CircularAperture(245, 85, r=6)\n CircularAperture(44, 1001, r=6)\n CircularAperture(503, 904, r=6)\n CircularAperture(819, 775, r=6)\n CircularAperture(610, 62, r=6)\n CircularAperture(133, 110, r=6)\n ⋮\n CircularAperture(697, 975, r=6)\n CircularAperture(703, 599, r=6)\n CircularAperture(893, 878, r=6)\n CircularAperture(291, 457, r=6)\n CircularAperture(660, 855, r=6)\n CircularAperture(711, 920, r=6)\n CircularAperture(708, 271, r=6)\n CircularAperture(701, 273, r=6)\n CircularAperture(710, 273, r=6) We can overplot them on our original image. The coordinate sytem used by the Photometry.jl plot recipes (but not the actual return values) doesn't match AstroImages, so we must transpose our image: implot(subt', colorbar=false)\nplot!(aps)"},{"id":591,"pagetitle":"Extracting Photometry","title":"Measuring Photometry","ref":"/previews/PR43/AstroImages/stable/guide/photometry/#Measuring-Photometry","content":" Measuring Photometry Finally we can extract the source photometry  table = photometry(aps, subt) Table with 3 columns and 1000 rows:\n      xcenter  ycenter  aperture_sum\n    ┌───────────────────────────────\n 1  │ 255      226      20542.4\n 2  │ 940      681      7125.3\n 3  │ 219      924      14741.0\n 4  │ 38       678      31056.4\n 5  │ 245      85       -910.308\n 6  │ 44       1001     2792.62\n 7  │ 503      904      6954.07\n 8  │ 819      775      -3136.61\n 9  │ 610      62       4338.13\n 10 │ 133      110      22219.0\n 11 │ 592      123      18562.2\n 12 │ 1055     248      3277.33\n 13 │ 424      86       255299.0\n 14 │ 558      125      6659.03\n 15 │ 125      1021     11524.1\n 16 │ 112      637      1349.78\n 17 │ 196      2        -797.491\n ⋮  │    ⋮        ⋮          ⋮ And plot them:  scatter(\n    table.xcenter,\n    table.ycenter,\n    aspectratio=1,\n    marker_z=table.aperture_sum,\n    markerstrokewidth=0,\n    label=\"\",\n    framestyle=:box,\n    background_inside=:black,\n    color=:white\n)"},{"id":594,"pagetitle":"Reprojecting Images","title":"Reprojecting Images","ref":"/previews/PR43/AstroImages/stable/guide/reproject/#Reprojecting-Images","content":" Reprojecting Images Integration with the  Reproject.jl  package is not yet complete."},{"id":597,"pagetitle":"Conventions","title":"Conventions","ref":"/previews/PR43/AstroImages/stable/manual/conventions/#Conventions","content":" Conventions In the Julia Astro ecosystem, images follow the following conventions."},{"id":598,"pagetitle":"Conventions","title":"Axes","ref":"/previews/PR43/AstroImages/stable/manual/conventions/#Axes","content":" Axes For simple 2D images, the first axis is the horizontal axis and the second axis is the vertical axis. So images are indexed by  img[xi, yi] . The origin is at the bottom left of the image, so  img[1,1]  refers to the bottom left corner as does  img[begin,begin] .  img[end,end]  is the top right corner,  img[begin,end]  is the top left, etc. Note that this is transposed and flipped from how how Julia prints arrays at the REPL, "},{"id":599,"pagetitle":"Conventions","title":"Pixels","ref":"/previews/PR43/AstroImages/stable/manual/conventions/#Pixels","content":" Pixels This library considers the exact location of  img[1,1]  to be the center of the pixel in the bottom left corner. This means that plot limits should have the  1  tick slightly away from the left/bottom spines of the image. The default plot limits for  implot  are  -0.5  to  end+0.5  along both axes.  There is a  known bug  with the Plots.jl GR backend that leads ticks to be slightly offset. PyPlot and Plotly backends show the correct tick locations."},{"id":602,"pagetitle":"Converting from RGB","title":"Converting From RGB Images","ref":"/previews/PR43/AstroImages/stable/manual/converting-from-rgb/#Converting-From-RGB-Images","content":" Converting From RGB Images If you encouter an image in a standard graphics format (e.g. PNG, JPG) that you want to analyze or store in an AstroImage, it will likely contain RGB (or similar) pixels.  It is possible to store RGB data in an AstroImage. Let's see how that works: using AstroImages\ndownload(\"http://www.astro.uvic.ca/~wthompson/astroimages/fits/mw-crop2-small.png\",\"mw-crop2-small.png\")\n\n# First we load it from the PNG file\nmw_png = load(\"mw-crop2-small.png\") You will need the Images.jl package installed to load formats like PNG. Once the RGB image is loaded, we can store it in an AstroImage if we'd like: mw_ai = AstroImage(mw_png) However, we may want to extract the RGB channels first. We can do this using  Images.channelview . Images.channelview  returns a view into the RGB data as a 3 × X × Y dimension cube. Unfortunately, we will have to permute the dimensions slightly. using Images\nmw_png = load(\"mw-crop2-small.png\")\nmw_chan_view = channelview(mw_png)\nmw_rgb_cube = AstroImage(\n    permutedims(mw_chan_view, (3, 2, 1))[:,end:-1:begin,:],\n    # Optional:\n    (X=:, Y=:, Spec=[:R,:G,:B])\n) 2596×1440×3 AstroImage{N0f8,3} with dimensions: \n  X ,\n  Y ,\n  Dim{:Spec} Categorical Symbol[R, G, B] ReverseOrdered\n[:, :, 1]\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n ⋮                        ⋮              ⋱            ⋮                   \n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n[and 2 more slices...] Here we chose to mark the third axis as a spectral axis with keys  :R ,  :G , and  :B . We can now visualize each channel: mw_rgb_cube[Spec=At(:R)] # Or just: mw_rgb_cube[:,:,1] imview(\n    mw_rgb_cube[Spec=At(:R)],\n    cmap=nothing # Grayscale mode\n) using Plots\nimplot(mw_rgb_cube[Spec=At(:B)])"},{"id":605,"pagetitle":"Converting to RGB","title":"Converting to RGB","ref":"/previews/PR43/AstroImages/stable/manual/converting-to-rgb/#Converting-to-RGB","content":" Converting to RGB If you have two or more images of the same scene taken at different wavelengths, you may wish to combine them to create a colour composite. For ultimate control, you can do this manually using  imview . Simply map your channels to  RGB  values using  imview  and then sum the results. For convenience, AstroImages.jl provides the function  composecolors ."},{"id":606,"pagetitle":"Converting to RGB","title":"Using composecolors","ref":"/previews/PR43/AstroImages/stable/manual/converting-to-rgb/#Using-composecolors","content":" Using  composecolors We'll demonstrate  composecolors  using Hubble images of the Antenae colliding galaxies. One can be very scientific about this process, but often the goal of producing color composites is aesthetic or about highlighting certain features for public consumption.  I'll set the default color map to grayscale to avoid confusion. using AstroImages\n\nAstroImages.set_cmap!(nothing) Let's start by downloading the separate color channel FITS files: antred = AstroImage(download(\"http://www.astro.uvic.ca/~wthompson/astroimages/fits/antenae/red.fits\")) antgreen = AstroImage(download(\"http://www.astro.uvic.ca/~wthompson/astroimages/fits/antenae/green.fits\")) antblue = AstroImage(download(\"http://www.astro.uvic.ca/~wthompson/astroimages/fits/antenae/blue.fits\")) anthalph = AstroImage(download(\"http://www.astro.uvic.ca/~wthompson/astroimages/fits/antenae/hydrogen.fits\")); # Hydrogen-Alpha; we'll revisit later The images will have to be aligned and cropped to the same size before making a color composite. In order to compose these images, we'll have to match the relative intensity scales and clip outlying values. Thankfully,  composecolors  handles most of these details automatically. rgb1 = composecolors([antred, antgreen, antblue]) It's a start! By default, if you provide three images these are mapped to the color channels red, green, and blue. The intensities are limited to  Percent(99.5) . We can now tweak these defaults to our tastes. We could try clamping the intensities more agressively to bring out more of the galaxy structure: rgb2 = composecolors(\n    [antred, antgreen, antblue],\n    clims=Percent(97)\n) This looks okay but saturates the galaxy cores. Let's take care of that gash through the image by just blanking it out. mask = antgreen .== antgreen[end,begin]\n# remove holes in the mask\nusing ImageFiltering, Statistics\nmask = BitMatrix(mapwindow(median, mask, (3,3)))\nimview(mask) antred[mask] .= NaN\nantgreen[mask] .= NaN\nantblue[mask] .= NaN\nanthalph[mask] .= NaN; 92228-element view(::Vector{Float32}, [39, 40, 41, 42, 43, 44, 45, 46, 47, 48  …  1119338, 1119339, 1119340, 1119341, 1119342, 1119343, 1119344, 1119345, 1119346, 1119347]) with eltype Float32:\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN\n   ⋮\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN Typically we need to perform a \"gamma correction\" aka non-lienar stretch to map the wide dynamic range of astronomical images into a narrower human visible range. We can do this using the  stretch  keyword. An  asinhstretch  is typically recommended when preparing RGB images: rgb3 = composecolors(\n    [antred, antgreen, antblue],\n    stretch=asinhstretch\n) Keywords like  strech ,  clims , etc can be either a single value for all channels or a list of separate values/functions per channel. The green channel appears to be quite faint compared to the red and blue channels. We can modify that by adjusting the relative intensities of the channels.  We could also do this using a combination of the  contrast  and  bias  keywords. rgb4 = composecolors(\n    [antred, antgreen, antblue],\n    stretch=asinhstretch,\n    multiplier=[1,1.7,1]\n) That's better! Let's go one step further, and incorporate a fourth chanel: Hydrogen Alpha. Hydrogen Alpha is a narrow filter centered around one of the emission lines of Hydrogen atoms. It traces locations with hot gas; mostly star-formation regions in this case. imview(anthalph, cmap=:magma, clims=Zscale()) We'll now need to specify the color channels we want to use for each wavelength since we can't use just the default three RGB. We can use any named color or julia ColorScheme. rgb5 = composecolors(\n    [antred, antgreen, antblue, anthalph],\n    [\"red\", \"green\", \"blue\", \"maroon1\"],\n    stretch=asinhstretch,\n    multiplier=[1,1.7,1,0.8]\n) Additionally, I'd like to just show the brightest areas of Hydrogen alpha emission rather than adding a diffuse pink glow. We can turn off the stretch for this one channel: rgb6 = composecolors(\n    [antred, antgreen, antblue, anthalph],\n    [\"red\", \"green\", \"blue\", \"maroon1\"],\n    stretch=[\n        asinhstretch,\n        asinhstretch,\n        asinhstretch,\n        identity,\n    ],\n    multiplier=[1,1.7,1,0.8]\n) Finally, we can crop the image and save it as a PNG. crop = rgb6[200:end-100,50:end-50] save(\"antenae-composite.png\", crop) If you want to save it in a format like  JPG  that doesn't support transparent pixels, you could replace the masked area with zeros instead of  NaN ."},{"id":609,"pagetitle":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","ref":"/previews/PR43/AstroImages/stable/manual/dimensions-and-world-coordinates/#Dimensions-and-World-Coordinates","content":" Dimensions and World Coordinates AstroImages are based on  Dimensional Data . Each axis is assigned a dimension name and the indices are tracked."},{"id":610,"pagetitle":"Dimensions and World Coordinates","title":"World Coordinates","ref":"/previews/PR43/AstroImages/stable/manual/dimensions-and-world-coordinates/#World-Coordinates","content":" World Coordinates FITS files with world coordinate system (WCS) headers contain all the information necessary to map a pixel location into celestial coordinates & back. Let's see how this works with a 2D image with RA & DEC coordinates. using AstroImages\nusing Plots\n\n# Download a Hubble image of the Eagle nebula\ndownload(\n    \"http://www.astro.uvic.ca/~wthompson/astroimages/fits/656nmos.fits\",\n    \"eagle-656nmos.fits\"\n);\neagle = AstroImage(\"eagle-656nmos.fits\") This image contains world coordinate system headers. AstroImages.jl uses WCS.jl (and wcslib under the hood) to parse these headers. We can generate a WCSTransform object to inspect: wcs(eagle, 1) # specify which coordinate system WCSTransform(naxis=2,cdelt=[1.0, 1.0],crval=[274.71149247724, -13.816384007184],crpix=[386.5, 396.0]) Note that we specify with an index which coordinate system we'd like to use. Most images just contain one, but some contain multiple systems. We can lookup a coordinate from the image: world = pix_to_world(eagle, [1, 1]) # Bottom left corner 2-element Vector{Float64}:\n 274.712299241082\n -13.801135972688115 Or convert back from world coordinates to pixel coordinates: We can lookup a coordinate from the image: world_to_pix(eagle, world) # Bottom left corner 2-element Vector{Float64}:\n 1.000000000336172\n 0.9999999992196535 These pixel coordinates do not necessarily have to lie within the bounds of the original image, and in general lie at a fractional pixel position. If an image contains WCS headers, we can visualize them using  implot : implot(eagle) We can adjust the color of the grid: implot(eagle, gridcolor=:cyan) If these aren't desired, we can turn off the grid or the WCS tick marks: plot(\n  implot(eagle, grid=false),\n  implot(eagle, wcsticks=false),\n  size=(900,300),\n  bottommargin=10Plots.mm\n) Since AstroImages are based on DimensionalData's AbstractDimArray, the mapping between pixel coordinates and world coordinates are preserved when slicing an AstroImage: slice1 = eagle[1:800,1:800]\nslice2 = eagle[800:1600,1:800]\nplot(\n  implot(slice1),\n  implot(slice2),\n  size=(900,300),\n  bottommargin=10Plots.mm\n) World coordinate queries from that slice are aware of their position in the parent image: @show pix_to_world(slice1, [1,1])\n@show pix_to_world(slice2, [1,1]) 2-element Vector{Float64}:\n 274.7277517847315\n -13.817350009028138 Note  that you can query the dimensions of an image using the  dims  function from DimensionalData: dims(slice2) X Sampled 800:1600 ForwardOrdered Regular Points,\nY Sampled 1:800 ForwardOrdered Regular Points"},{"id":611,"pagetitle":"Dimensions and World Coordinates","title":"Named Dimensions","ref":"/previews/PR43/AstroImages/stable/manual/dimensions-and-world-coordinates/#Named-Dimensions","content":" Named Dimensions Each dimension of an AstroImage is named. The automatic dimension names are  X ,  Y ,  Z ,  Dim{4} ,  Dim{5} , and so on; however you can pass in other names or orders to the load function and/or AstroImage contructor: julia> img = load(\"eagle-656nmos.fits\",1,(Y,Z))\n1600×1600 AstroImage{Float32,2} with dimensions:\n  Y Sampled 1:1600 ForwardOrdered Regular Points,\n  Z Sampled 1:1600 ForwardOrdered Regular Points Other useful dimension names are  Spec  for spectral axes,  Pol  for polarization data, and  Ti  for time axes. These are tracked the same was as the automatic dimension names and interact smoothly with any WCS headers. You can give an arbitrary name using as a  Dim{Symbol} , e.g.  Dim{:Velocity} . You can access AstroImages using dimension names: eagle[X=100] 1600-element AstroImage{Float32,1} with dimensions: \n  Y Sampled Base.OneTo(1600) ForwardOrdered Regular Points\nand reference dimensions: \n  X Sampled 100:100 ForwardOrdered Regular Points\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n ⋮\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0 When indexing into a slice out of a larger parent image or cube, this named access refers to the  parent  dimensions: slice1 = eagle[600:800,600:800]\nslice1[X=At(700),Y=At(700)] == eagle[X=At(700),Y=At(700)] == eagle[700,700] true"},{"id":612,"pagetitle":"Dimensions and World Coordinates","title":"Cubes","ref":"/previews/PR43/AstroImages/stable/manual/dimensions-and-world-coordinates/#Cubes","content":" Cubes Let's see how this works with a 3D cube. using AstroImages\n\nHIcube = AstroImage(download(\"http://www.astro.uvic.ca/~wthompson/astroimages/fits/HIdat.fits\")) 150×150×450 AstroImage{Float32,3} with dimensions: \n  X Sampled Base.OneTo(150) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(150) ForwardOrdered Regular Points,\n  Z Sampled Base.OneTo(450) ForwardOrdered Regular Points\n[:, :, 1]\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN  …  NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN  …  NaN  NaN  NaN  NaN  NaN  NaN  NaN\n   ⋮                        ⋮            ⋱              ⋮                 \n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN  …  NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n[and 449 more slices...] Notice how the cube is not displayed automatically. We have to pick a specific slice: HIcube[Z=228] Using  implot , the world coordinates are displayed automatically: implot(HIcube[Z=228], cmap=:turbo) The plot automatically reflects the world coordinates embeded in the file. It displays the x axis in galactic longitude, the y-axis in galactic latitude, and even shows the curved projection from pixel coordinates to galactic coordinates. The title is automatically set to the world coordinate along the Z axis in units of velocity. It also picks up the unit of the data (Kelvins) to display on the colorbar. If we pick another slice, the title updates accordingly: implot(HIcube[Z=308], cmap=:turbo) This works for other slices through the cube as well: implot(HIcube[Y=45],  cmap=:turbo, aspectratio=0.3)"},{"id":613,"pagetitle":"Dimensions and World Coordinates","title":"Custom Dimensions","ref":"/previews/PR43/AstroImages/stable/manual/dimensions-and-world-coordinates/#Custom-Dimensions","content":" Custom Dimensions julia> img = load(\"img.fits\",1,(Y=1:1600,Z=1:1600))\n1600×1600 AstroImage{Float32,2} with dimensions:\n  Y Sampled 1:1600 ForwardOrdered Regular Points,\n  Z Sampled 1:1600 ForwardOrdered Regular Points Other useful dimension names are  Spec  for spectral axes,  Pol  for polarization data, and  Ti  for time axes. These are tracked the same was as the automatic dimension names and interact smoothly with any WCS headers. Often times we have images or cubes that we want to index with physical coordinates where setting up a full WCS transform is overkill. In these cases, it's easier to leverage custom dimensions. For example, one may wish to  julia> img = load(\"img.fits\",1,(X=801:2400,Y=1:2:3200))\n1600×1600 AstroImage{Float32,2} with dimensions:\n  X Sampled 801:2400 ForwardOrdered Regular Points,\n  Y Sampled 1:2:3199 ForwardOrdered Regular Points\n... Unlike OffsetArrays, the usual indexing remains so  img[1,1]  is still the bottom left of the image; however, data can be looked up according to the offset dimensions using specifiers: julia> img[X=Near(2000),Y=1..100]\n50-element AstroImage{Float32,1} with dimensions:\n  Y Sampled 1:2:99 ForwardOrdered Regular Points\nand reference dimensions:\n  X Sampled 2000:2000 ForwardOrdered Regular Points\n  0.0 You can adjust the center of an image's dimensions using  recenter : eagle_cen = recenter(eagle, 801, 801); Unlike an OffsetArray,  eagle_cen[1,1]  still refers to the bottom left of the image. This also has no effect on broadcasting,  eagle_cen .+ ones(1600,1600)  is perfectly valid. However, we see the new centered dimensions when we go to plot the image: implot(eagle_cen, wcsticks=false) And we can query positions using the offset dimensions: implot(eagle_cen[X=-300..300, Y=-300..300], wcsticks=false)"},{"id":616,"pagetitle":"Displaying Images","title":"Displaying Images","ref":"/previews/PR43/AstroImages/stable/manual/displaying-images/#Displaying-Images","content":" Displaying Images The  imview  and  implot  functions are very similar.  Both allow any abstract array of numbers to be rendered into an image or a Plots.jl image series.  implot  is largely a superset of  imview  because it also supports colorbars, tick marks, WCS grid lines, overplotting other data & shapes, and automatic axis and title naming (from the FITS header if available)."},{"id":617,"pagetitle":"Displaying Images","title":"imview","ref":"/previews/PR43/AstroImages/stable/manual/displaying-images/#imview","content":" imview Any AbstractArray (including an AstroImage) can be displayed using  imview . This function renders an arbitrary array into an array of  RGBA  values using a number of parameters. If the input is an AstroImage{<:Number}, an AstroImage{RGBA} will be returned that retains headers, WCS information, etc. The defaults for the  imview  function are: img = randn(50,50);\nimview(img; clims=Percent(99.5), cmap=:magma, stretch=identity, contrast=1.0, bias=0.5) We can adjust the color limits explicitly: imview(img; clims=(-1, 1)) Or pass a function/callable object to calculate them for us: imview(img; clims=Zscale()) We can turn off the colormap and use it in grayscale mode: imview(img; cmap=nothing) Pass any color scheme from ColorSchemes.jl: imview(img; cmap=:ice) imview(img; cmap=:seaborn_rocket_gradient) Or an RGB or named color value: imview(img; cmap=\"#F00\")\nimview(img; cmap=\"red\") Let's now switch to an astronomical image: fname = download(\n    \"http://www.astro.uvic.ca/~wthompson/astroimages/fits/656nmos.fits\",\n    \"eagle-656nmos.fits\"\n);\neagle = AstroImage(\"eagle-656nmos.fits\") We can apply a non-linear stretch like a log-scale, power-scale, or asinh stretch: imview(eagle, stretch=asinhstretch) Once rendered, we can also tweak the bias and contrast: imview(eagle, stretch=asinhstretch, contrast=1.5) imview(eagle, stretch=asinhstretch, contrast=1.5, bias=0.6) These are the parameters that change when you click and drag in some applications like DS9. Once rendered via  imview , the resulting image can be saved in traditional image formats like PNG, JPG, GIF, etc: save(\"out.png\", imview(eagle, cmap=:viridis)) Very large Images are automatically downscaled to ensure consistent performance using  restrict  from Images.jl. This function filters the data before downscaling to prevent aliasing, so it may take a moment for truly huge images. In these cases, a faster method that doesn't prevent aliasing would be  imview(img[begin:10:end, begin:10:end])  or similar. imview  is called automatically on  AstroImage{<:Number}  when using a Julia environment with rich graphical IO capabilities (e.g. VSCode, Jupyter, Pluto, etc.). The defaults for this case can be modified using  AstroImages.set_clims!(...) ,  AstroImages.set_cmap!(...) , and  AstroImages.set_stretch!(...) ."},{"id":618,"pagetitle":"Displaying Images","title":"Note on Views","ref":"/previews/PR43/AstroImages/stable/manual/displaying-images/#Note-on-Views","content":" Note on Views The function  imview  has its name because it produces a \"view\" into the image. The result from calling  imview  is an object that lazily maps data values into RGBA colors on the fly. This means that if you change the underlying data array, the view will update (the next time it is shown). If you have many data files to render, you may find it faster to create a single  imview  and then mutate the data in the underlying array. This is faster since  imview  only has to resolve colormaps and compute limits once. For example: data = randn(100,100)\niv = imview(data)\ndisplay(iv)\ndata[1:50,1:50] .= 0\ndisplay(iv) iv  will reflect the changes to  data  when it is displayed the second time."},{"id":619,"pagetitle":"Displaying Images","title":"implot","ref":"/previews/PR43/AstroImages/stable/manual/displaying-images/#implot","content":" implot implot   is a Plots.jl recipe, which means before you can use it you first have to load  Plots.jl : using Plots implot  accepts all the arguments  imview  does for controlling how data is rendered to the screen. implot(img; clims=Percent(99.5), cmap=:magma, stretch=identity, contrast=1.0, bias=0.5)"},{"id":622,"pagetitle":"Getting Started","title":"Getting Started","ref":"/previews/PR43/AstroImages/stable/manual/getting-started/#Getting-Started","content":" Getting Started To get started, you will first need to install AstroImages. After starting Julia, enter package-mode by typing  ]  and then pkg> add AstroImages To display images and save them in traditional graphics formats like PNG, JPG, GIF, etc., you will also need to add the  ImageIO  package. Once installed, this package doesn't need to be loaded explicitly. For some of the more advanced visualizations you may also want  Plots : pkg> add Plots To load the package, run: using AstroImages\n# And if desired:\nusing Plots"},{"id":625,"pagetitle":"Headers","title":"Headers","ref":"/previews/PR43/AstroImages/stable/manual/headers/#Headers","content":" Headers FITS files consist of one or more HDUs (header data units), and each HDU can contain an N-dimensional image or table. Before the data is a  header . Headers contain (key, value, comment) groups as well as dedicated long-form COMMENT and HISTORY sections used to document, for example, the series of post-processing steps applied to an image."},{"id":626,"pagetitle":"Headers","title":"Accessing Headers","ref":"/previews/PR43/AstroImages/stable/manual/headers/#Accessing-Headers","content":" Accessing Headers Here are some examples of how to set and read keys, comments, and history. Well start by making a blank image. img = AstroImage(zeros(10,10))\n# Set keys to values with different data types\nimg[\"KEY1\"] = 2   # Integer\nimg[\"KEY2\"] = 2.0 # Float\nimg[\"KEY3\"] = \"STRING\"\nimg[\"KEY4\"] = true\nimg[\"KEY5\"] = false\nimg[\"KEY6\"] = nothing\n\n# Set comments\nimg[\"KEY1\", Comment] = \"A key with an integer value\"\n\n# Read keys\na = img[\"KEY3\"]\n\n# Read comment\ncom = img[\"KEY1\", Comment]\n\n# Add long-form COMMENT\npush!(img, Comment, \"\"\"\nWe now describe how to add a long form comment to the end of a header.\n\"\"\")\n\n# Add HISTORY entry\npush!(img, History, \"\"\"\nWe now describe how to add a long form history to the end of a header.\n\"\"\")\n\n# Retrieve long form comments/ history\ncomment_strings = img[Comment]\nhistory_strings = img[History] Note that floating point values are formatted as ASCII strings when written to the FITS files, so the precision may be limited.  AstroImage  objects wrap a FITSIO.jl  FITSHeader . If necessary, you can recover it using  header(img) ; however, in most cases you can access header keywords directly from the image. API docs:  Comment History header"},{"id":629,"pagetitle":"Loading & Saving Images","title":"Loading Images","ref":"/previews/PR43/AstroImages/stable/manual/loading-images/#Loading-Images","content":" Loading Images FITS (Flexible Image Transport System) files can be loaded and saved using AstroImages thanks to the FITSIO package. AstroImages is registered with  FileIO , so if you have FileIO and AstroImages installed you can get started with the  load  function. When you pass a file name with the appropriate file extension (\".fits\", \".fit\", etc.) FileIO will import AstroImages automatically. Alternatively, you can use the  AstroImage  contructor instead of load. This will work on fits files with any file extension, including compressed files (e.g. \".fits.gz\"). julia> img = load(\"myfitsimg.fits\")\n1600×1600 AstroImage{Float32,2} with dimensions:\n  X Sampled Base.OneTo(1600) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(1600) ForwardOrdered Regular Points\n 0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n ⋮                        ⋱\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0 Note: if you are in an interactive environment like VSCode, Jupyter, or Pluto, instead of a REPL, AstroImages are automatically rendered to images and displayed. You can see this plain text output by explicitly calling:  show(stdout, MIME(\"text/plain\"), img) . Or:  julia> img = AstroImage(\"myfitsimg.fits.gz\")\n1600×1600 AstroImage{Float32,2} with dimensions:\n  X Sampled Base.OneTo(1600) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(1600) ForwardOrdered Regular Points\n 0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n ⋮                        ⋱\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0 A FITS file can contain multiple N-dimensional images and tables. When you call load or AstroImage with a file name and no other arguments, the package will search through the file and return the first image HDU. That is, it will skip any FITS tables or empty HDUs with only headers. You can also specify an HDU number explicitly: julia> img = load(\"myfitsimg.fits\",1)\n1600×1600 AstroImage{Float32,2} with dimensions:\n  X Sampled Base.OneTo(1600) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(1600) ForwardOrdered Regular Points\n... This way, you can load specific images from multi-extension files. You can load all HDUs simultaneously by passing  : : julia> hdus = load(\"multiext.fits\", :);\njulia> hdus[2] # Second HDU as an AstroImage\n10×10 AstroImage{Float64,2} with dimensions:\n  X Sampled Base.OneTo(10) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(10) ForwardOrdered Regular Points\n -0.777315  -1.36683   -0.580179     1.39629      …  -2.14298     0.450059   0.432065\n -1.09619    0.789249   0.938415     0.959903        -0.88995    -1.29406   -0.4291\n  0.47427   -1.41855    0.814823    -1.15975          0.0427149  -1.20116   -0.0920709\n -0.179858  -1.60228    1.09648     -0.497927        -1.31824    -0.156529  -0.0223846\n  2.64162    0.131437   0.320476     0.331197        -0.914713   -1.55162   -0.18862\n  0.209669  -1.17923   -0.656512     0.000775311  …   0.377461   -0.24278    0.967202\n  1.01442   -0.762895  -2.13238     -0.456932        -0.415733   -1.21416   -1.6108\n  0.385626   0.389335  -0.00726015   0.309936        -0.533175    0.157878   0.100876\n -1.24799    0.461216  -0.868826    -0.255654        -0.37151     0.49479   -1.87129\n  1.39356    2.29254    0.0548325    1.50674         -0.0880865   0.580978  -1.81629\njulia> # Or:\njulia> hdu1, hdu2, hdu3 = load(\"multiext.fits\", :); There is also limited support for table HDUs. In this case, a bare-bones Tables.jl compatible  object is returned."},{"id":630,"pagetitle":"Loading & Saving Images","title":"Dimension Names","ref":"/previews/PR43/AstroImages/stable/manual/loading-images/#Dimension-Names","content":" Dimension Names You may have noticed the entries above the image array: 10×10 AstroImage{Float64,2} with dimensions:\n  X Sampled Base.OneTo(10) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(10) ForwardOrdered Regular Points AstroImages are based on  Dimensional Data . Each axis is assigned a dimension name and the indices are tracked. The automatic dimension names are  X ,  Y ,  Z ,  Dim{4} ,  Dim{5} , and so on; however you can pass in other names or orders to the load function and/or AstroImage contructor: julia> img = load(\"img.fits\",1,(Y=1:1600,Z=1:1600))\n1600×1600 AstroImage{Float32,2} with dimensions:\n  Y Sampled 1:1600 ForwardOrdered Regular Points,\n  Z Sampled 1:1600 ForwardOrdered Regular Points Other useful dimension names are  Spec  for spectral axes,  Pol  for polarization data, and  Ti  for time axes. These will be further discussed in Dimensions and World Coordinates."},{"id":631,"pagetitle":"Loading & Saving Images","title":"Saving Images","ref":"/previews/PR43/AstroImages/stable/manual/loading-images/#Saving-Images","content":" Saving Images You can save one or more AstroImages and tables to a FITS file using the  save  function: julia> save(\"abc.fits\", astroimage1, astroimage2, table1) You can also save individual images to traditional graphics formats by first rendering them with  imview  (for more on imview, see Displaying Images). julia> save(\"abc.png\", imview(astroimage1)) You can save animated GIFs by saving a 3D datacube that has been rendered with imview: julia> cube =  imview(AstroImage(randn(100,100,10)));\njulia> save(\"abc.gif\", cube, fps=10)\n\njulia> # Or a more complex example (changing color schemes each frame)\njulia> img = randn(10,10)\njulia> cube2 = [imview(img1, cmap=:magma) ;;; imview(img2, cmap=:plasma) ;;; imview(img3, cmap=:viridis)]\njulia> # Alternative syntax:\njulia> cube2 = cat(imview(img1, cmap=:magma), imview(img2, cmap=:plasma), imview(img3, cmap=:viridis), dims=3)\njulia> save(\"abc.gif\", cube, fps=10)"},{"id":636,"pagetitle":"Preserving Wrapper","title":"Preserving the AstroImage Wrapper","ref":"/previews/PR43/AstroImages/stable/manual/preserving-wrapper/#Preserving-the-AstroImage-Wrapper","content":" Preserving the AstroImage Wrapper Wherever possible, overloads have been added to DimensionalData and AstroImages so that common operations retain the  AstroImage  wrapper with associated dimensions, FITS header, and WCS information. Most of the time this works automatically if libraries follow good patterns like allocating outputs using  Base.similar . However, some other library functions may follow patterns like allocating a plain  Array  of the correct size and then filling it.  To make it easier to work with these libraries, AstroImages exports two functions  copyheader  and  shareheader .  These functions wrap an AbstractArray in an AstroImage while copying over the header, dimensions, and WCS info. Consider the function: function badfunc(arr)\n    out = zeros(size(arr)) # instead of similar(arr)\n    out .= arr.^2\n    return out\nend Calling  badfunc(astroimg)  will return a plain  Array  . We can use  copyheader  to retain the  AstroImage  wrapper: copyheader(astroimg, badfunc(astroimg)) For particularly incompatible functions that require an Array (not subtype of AbstractArray) we can go one step further: copyheader(astroimg, worsefunc(parent(astroimg)))\n# Or:\ncopyheader(astroimg, worsefunc(collect(astroimg)))"},{"id":653,"pagetitle":"Package library","title":"SAOImageDS9.get","ref":"/previews/PR43/SAOImagesDS9/stable/library/#SAOImageDS9.get","content":" SAOImageDS9.get  —  Function . SAOImageDS9.get([T, [dims,]] args...) sends a \"get\" request to the SAOImage/DS9 server.  The request is made of arguments  args...  converted into strings and merged with separating spaces. An exception is thrown in case of error. The returned value depends on the optional arguments  T  and  dims : If neither  T  nor  dims  are specified, an instance of  XPA.Reply  is returned with at most one answer (see documentation for  XPA.get  for more details). If only  T  is specified, it can be: String  to return the answer as a single string; Vector{String}}  or  Tuple{Vararg{String}}  to return the answer split in words as a vector or as a tuple of strings; T  where  T<:Real  to return a value of type  T  obtained by parsing the textual answer. Tuple{Vararg{T}}  where  T<:Real  to return a value of type  T  obtained by parsing the textual answer; Vector{T}  where  T  is not  String  to return the binary contents of the answer as a vector of type  T ; If both  T  and  dims  are specified,  T  can be an array type like  Array{S}  or  Array{S,N}  and  dims  a list of  N  dimensions to retrieve the binary contents of the answer as an array of type  Array{S,N} . As a special case: SAOImageDS9.get(Array; endian=:native) -> arr yields the contents of current SAOImage/DS9 frame as an array (or as  nothing  if the frame is empty). Keyword  endian  can be used to specify the byte order of the received values (see  SAOImageDS9.byte_order ). To retrieve the version of the SAOImage/DS9 program: SAOImageDS9.get(VersionNumber) See also  SAOImageDS9.connect ,  SAOImageDS9.set  and  XPA.get . source"},{"id":654,"pagetitle":"Package library","title":"SAOImageDS9.set","ref":"/previews/PR43/SAOImagesDS9/stable/library/#SAOImageDS9.set","content":" SAOImageDS9.set  —  Function . SAOImageDS9.set(args...; data=nothing) sends command and/or data to the SAOImage/DS9 server.  The command is made of arguments  args...  converted into strings and merged with a separating spaces. Keyword  data  can be used to specify the data to send.  An exception is thrown in case of error. As a special case: SAOImageDS9.set(arr; mask=false, new=false, endian=:native) set the contents of the current SAOImage/DS9 frame to be array  arr .  Keyword  new  can be set true to create a new frame for displyaing the array.  Keyword  endian  can be used to specify the byte order of the values in  arr  (see  SAOImageDS9.byte_order . See also  SAOImageDS9.connect ,  SAOImageDS9.get  and  XPA.set . source Connection"},{"id":655,"pagetitle":"Package library","title":"SAOImageDS9.connect","ref":"/previews/PR43/SAOImagesDS9/stable/library/#SAOImageDS9.connect","content":" SAOImageDS9.connect  —  Function . SAOImageDS9.connect(ident=\"DS9:*\") -> apt set the access point for further SAOImage/DS9 commands.  Argument  ident  identifies the XPA access point, it can be a template string like  \"DS9:*\"  which is the default value or a regular expression.  The returned value is the name of the access point. To retrieve the name of the current SAOImage/DS9 access point, call the  SAOImageDS9.accesspoint  method. source"},{"id":656,"pagetitle":"Package library","title":"SAOImageDS9.accesspoint","ref":"/previews/PR43/SAOImagesDS9/stable/library/#SAOImageDS9.accesspoint","content":" SAOImageDS9.accesspoint  —  Function . SAOImageDS9.accesspoint() yields the XPA access point which identifies the SAOImage/DS9 server.  This access point can be set by calling the  SAOImageDS9.connect  method. An empty string is returned if no access point has been chosen.  To automatically connect to SAOImage/DS9 if not yet done, you can do: if SAOImageDS9.accesspoint() == \"\"; SAOImageDS9.connect(); end See also  SAOImageDS9.connect  and  SAOImageDS9.accesspoint . source Drawing"},{"id":657,"pagetitle":"Package library","title":"SAOImageDS9.draw","ref":"/previews/PR43/SAOImagesDS9/stable/library/#SAOImageDS9.draw","content":" SAOImageDS9.draw  —  Function . SAOImageDS9.draw(args...; kwds...) draws something in SAOImage/DS9 application.  The operation depends on the type of the arguments. SAOImageDS9.draw(img; kwds...) displays image  img  (a 2-dimensional Julia array) in SAOImage/DS9. The following keywords are possible: Keyword  frame  can be used to specify the frame number. Keyword  cmap  can be used to specify the name of the colormap.  For instance,  cmap=\"gist_stern\" . Keyword  zoom  can be used to specify the zoom factor. Keywords  min  and/or  max  can be used to specify the scale limits. SAOImageDS9.draw(pnt; kwds...) draws  pnt  as point(s) in SAOImage/DS9,  pnt  is a  Point , an array or a tuple of  Point . SAOImageDS9.draw(box; kwds...) draws  box  as rectangle(s) in SAOImage/DS9,  box  is a  BoundingBox , an array or a tuple of  BoundingBox . source Utilities"},{"id":658,"pagetitle":"Package library","title":"SAOImageDS9.bitpix_of","ref":"/previews/PR43/SAOImagesDS9/stable/library/#SAOImageDS9.bitpix_of","content":" SAOImageDS9.bitpix_of  —  Function . SAOImageDS9.bitpix_of(x) -> bp yields FITS bits-per-pixel (BITPIX) value for  x  which can be an array or a type.  A value of 0 is returned if  x  is not of a supported type. See also  SAOImageDS9.bitpix_to_type . source"},{"id":659,"pagetitle":"Package library","title":"SAOImageDS9.bitpix_to_type","ref":"/previews/PR43/SAOImagesDS9/stable/library/#SAOImageDS9.bitpix_to_type","content":" SAOImageDS9.bitpix_to_type  —  Function . SAOImageDS9.bitpix_to_type(bp) -> T yields Julia type corresponding to FITS bits-per-pixel (BITPIX) value  bp . The value  Nothing  is returned if  bp  is unknown. See also  SAOImageDS9.bitpix_of . source"},{"id":660,"pagetitle":"Package library","title":"SAOImageDS9.byte_order","ref":"/previews/PR43/SAOImagesDS9/stable/library/#SAOImageDS9.byte_order","content":" SAOImageDS9.byte_order  —  Function . SAOImageDS9.byte_order(endian) yields the byte order for retrieving the elements of a SAOImage/DS9 array. Argument can be one of the strings (or the equivalent symbol):  \"big\"  for most significant byte first,  \"little\"  for least significant byte first or  \"native\"  to yield the byte order of the machine. See also  SAOImageDS9.get ,  SAOImageDS9.set . source Previous Examples"},{"id":669,"pagetitle":"Home","title":"Photometry.jl","ref":"/previews/PR43/Photometry/stable/#Photometry.jl","content":" Photometry.jl"},{"id":670,"pagetitle":"Home","title":"Installation","ref":"/previews/PR43/Photometry/stable/#Installation","content":" Installation To install from the REPL, enter Pkg-mode ( ] ) pkg> add Photometry"},{"id":671,"pagetitle":"Home","title":"Getting Started","ref":"/previews/PR43/Photometry/stable/#Getting-Started","content":" Getting Started Here is a basic example to do some aperture photometry using  CircularAperture . The  photometry  function performs the photometry using a given method. using Photometry\ndata = ones(100, 100)\nerr = ones(100, 100)\n\nap1 = CircularAperture(50, 50, 3)\n# partial overlap\nap2 = CircularAperture(0.5, 0.5, 5)\n\nresults = photometry([ap1, ap2], data, err)\n@assert results.aperture_sum[1] ≈ 9π\n@assert results.aperture_sum[2] ≈ 25π / 4\n\nresults Table with 4 columns and 2 rows:\n     xcenter  ycenter  aperture_sum  aperture_sum_err\n   ┌─────────────────────────────────────────────────\n 1 │ 50.0     50.0     28.2743       5.31736\n 2 │ 0.5      0.5      19.635        4.43113"},{"id":672,"pagetitle":"Home","title":"Contributing","ref":"/previews/PR43/Photometry/stable/#Contributing","content":" Contributing If you're interested in contributing, go ahead and check out the  issues  or make a  pull request . If you add a new feature, please write appropriate unit tests for it and bump the package's minor version."},{"id":673,"pagetitle":"Home","title":"License","ref":"/previews/PR43/Photometry/stable/#License","content":" License The work derived from  astropy/photutils  is BSD 3-clause and the work derived from  kbarbary/sep  is BSD 3-clause. All other work is considered MIT expat. Therefore this work as a whole is BSD 3-clause.  LICENSE  contains all licenses and any files using derived work are noted at the top of the file."},{"id":676,"pagetitle":"Getting Started","title":"Aperture Photometry","ref":"/previews/PR43/Photometry/stable/apertures/#Aperture-Photometry","content":" Aperture Photometry"},{"id":677,"pagetitle":"Getting Started","title":"Introduction","ref":"/previews/PR43/Photometry/stable/apertures/#Introduction","content":" Introduction Aperture photometry uses  Apertures  to cut out and sum values in an image. A very basic mask might be a square of pixels at a certain position. We can model this as a matrix of ones and zeros like ⎡0 0 0 0 0⎤\n⎢0 1 1 1 0⎥\n⎢0 1 1 1 0⎥\n⎢0 1 1 1 0⎥\n⎣0 0 0 0 0⎦ If we have some data like ⎡7 9 6 0 8⎤\n⎢8 5 8 7 9⎥\n⎢5 6 2 2 7⎥\n⎢9 7 3 4 1⎥\n⎣7 8 0 9 8⎦ then the result of our aperture photometry looks like ⎡0 0 0 0 0⎤    ⎡7 9 6 0 8⎤     ⎡0 0 0 0 0⎤\n⎢0 1 1 1 0⎥    ⎢8 5 8 7 9⎥     ⎢0 5 8 7 0⎥\n⎢0 1 1 1 0⎥ .* ⎢5 6 2 2 7⎥  =  ⎢0 6 2 2 0⎥\n⎢0 1 1 1 0⎥    ⎢9 7 3 4 1⎥     ⎢0 7 3 4 0⎥\n⎣0 0 0 0 0⎦    ⎣7 8 0 9 8⎦     ⎣0 0 0 0 0⎦\n\nsum(result) = 44 This module uses the above principal with common aperture shapes in a fast and precise manner, including exact overlaps between apertures and pixels. The majority of the lifting is done with the  photometry  function with common shapes being described in  Apertures . It is possible to create a custom aperture by sub-typing the  Aperture.AbstractAperture  class, although it may be easier to perform PSF photometry instead."},{"id":678,"pagetitle":"Getting Started","title":"Pixel Convention","ref":"/previews/PR43/Photometry/stable/apertures/#Pixel-Convention","content":" Pixel Convention Photometry.jl  follows the same convention as FITS, WCS, IRAF, DS9, and SourceExtractor with  (1, 1)  being the  center  on the bottom-left pixel. This means the exact bottom-left corner is at  (0.5, 0.5) . Pixels increase up and to the right until  axis_length + 0.5 ."},{"id":679,"pagetitle":"Getting Started","title":"API/Reference","ref":"/previews/PR43/Photometry/stable/apertures/#API/Reference","content":" API/Reference"},{"id":680,"pagetitle":"Getting Started","title":"Photometry.Aperture.photometry","ref":"/previews/PR43/Photometry/stable/apertures/#Photometry.Aperture.photometry","content":" Photometry.Aperture.photometry  —  Function photometry(::AbstractAperture, data::AbstractMatrix, [error])\nphotometry(::AbstractVector{<:AbstractAperture}, data::AbstractMatrix, [error]) Perform aperture photometry on  data  given aperture(s). If  error  (the pixel-wise standard deviation) is provided, will calculate sum error. If a list of apertures is provided the output will be a  TypedTables.Table , otherwise a  NamedTuple . Tip This code is automatically multi-threaded. To take advantage of this please make sure  JULIA_NUM_THREADS  is set before starting your runtime. source"},{"id":681,"pagetitle":"Getting Started","title":"Performance","ref":"/previews/PR43/Photometry/stable/apertures/#Performance","content":" Performance Below are some benchmarks comparing the aperture photometry capabilities of  Photometry.jl  with the  photutils  asropy package. The benchmark code can be found in the  bench  folder . Note that for the multi-threaded examples my machine has 4 physical cores with 8 threads. julia> versioninfo()\nJulia Version 1.5.0\nCommit 96786e22cc (2020-08-01 23:44 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin18.7.0)\n  CPU: Intel(R) Core(TM) i5-8259U CPU @ 2.30GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-9.0.1 (ORCJIT, skylake)"},{"id":682,"pagetitle":"Getting Started","title":"Number of Apertures","ref":"/previews/PR43/Photometry/stable/apertures/#Number-of-Apertures","content":" Number of Apertures This benchmark shows how performance scales as we increase the number of apertures. The apertures are distributed randomly across the image with a fixed radius of 10. The image size is (512, 512). We see an improvement of ~10-100x (depending on multithreading) over photutils."},{"id":683,"pagetitle":"Getting Started","title":"Size of Apertures","ref":"/previews/PR43/Photometry/stable/apertures/#Size-of-Apertures","content":" Size of Apertures This benchmark analyzes how the aperture size affects performance. Theoretically it should increase with  O(n^2)  complexity. For aperture sizes increasing from 1 to 200,  located in the center of a an image of size (512, 512)."},{"id":686,"pagetitle":"Apertures","title":"Apertures","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Apertures","content":" Apertures All apertures will rely on a position and the shape parameters. aperture = Aperture(x0, y0, shape_params...) The position can be pixels or sky coordinates. The sky coordinate positions utilize  SkyCoords.jl  and  WCS.jl  for conversion. Warning Sky coordinates are not supported yet. Note See  Pixel Convention  - The origin is the bottom-left with  (1, 1)  being the center of the pixel."},{"id":687,"pagetitle":"Apertures","title":"API/Reference","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#API/Reference","content":" API/Reference"},{"id":688,"pagetitle":"Apertures","title":"Photometry.Aperture.AbstractAperture","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.AbstractAperture","content":" Photometry.Aperture.AbstractAperture  —  Type AbstractAperture{T} <: AbstractMatrix{T} The abstract super-type for Apertures. Apertures can be thought of as a cutout or stamp of a geometric shape with shading applied. For example, a circular aperture with a diameter of 3 pixels will require a 5x5 pixel grid (when perfectly on-grid) to represent. julia> ap = CircularAperture(3, 3, 2.5)\n5×5 CircularAperture{Float64} with indices 1:5×1:5:\n 0.136857  0.769325  0.983232  0.769325  0.136857\n 0.769325  1.0       1.0       1.0       0.769325\n 0.983232  1.0       1.0       1.0       0.983232\n 0.769325  1.0       1.0       1.0       0.769325\n 0.136857  0.769325  0.983232  0.769325  0.136857 This is a useful way of thinking about apertures: if we have some data, we can weight the data with the aperture. julia> data = fill(2, 5, 5);\n\njulia> idxs = map(intersect, axes(ap), axes(data)) |> CartesianIndices;\n\njulia> weighted_cutout = data[idxs] .* ap[idxs]\n5×5 Matrix{Float64}:\n 0.273713  1.53865  1.96646  1.53865  0.273713\n 1.53865   2.0      2.0      2.0      1.53865\n 1.96646   2.0      2.0      2.0      1.96646\n 1.53865   2.0      2.0      2.0      1.53865\n 0.273713  1.53865  1.96646  1.53865  0.273713 Performing aperture photometry is merely summing the weighted cutout shown above. julia> flux = sum(weighted_cutout)\n39.269908169872416\n\njulia> flux ≈ (π * 2.5^2) * 2 # area of circle times intensity of 2\ntrue What's interesting about the implementation of apertures, though, is they are lazy. This means there is no stored matrix of aperture values; rather, they are calculated on the fly as needed. julia> axes(ap)\n(1:5, 1:5)\n\njulia> ap[-10, -10] # out-of-bounds, but calculated on the fly\n0.0\n\njulia> ap .* ones(5, 7) # broadcasts to eachindex(data), regardless of ap bound\n5×7 Matrix{Float64}:\n 0.136857  0.769325  0.983232  0.769325  0.136857  0.0  0.0\n 0.769325  1.0       1.0       1.0       0.769325  0.0  0.0\n 0.983232  1.0       1.0       1.0       0.983232  0.0  0.0\n 0.769325  1.0       1.0       1.0       0.769325  0.0  0.0\n 0.136857  0.769325  0.983232  0.769325  0.136857  0.0  0.0 This allows extremely efficient computation of aperture photometry from small to medium sized apertures. julia> using BenchmarkTools\n\njulia> @btime sum(idx -> $ap[idx] * $data[idx], $idxs)\n  1.097 μs (0 allocations: 0 bytes)\n39.26990816987243 This is essentially the full implementation of  photometry , save for the packing of additional information into a tabular form. source"},{"id":689,"pagetitle":"Apertures","title":"Photometry.Aperture.Subpixel","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.Subpixel","content":" Photometry.Aperture.Subpixel  —  Type Subpixel(ap, N=1) <: AbstractAperture Use a subpixel quadrature approximation for pixel shading instead of exact geometric methods. For any pixel laying on the border of  ap , this alters the shading algorithm by breaking the border pixel up into  (N, N)  subpixels. The shading value is the fraction of these subpixels within the geometric border of  ap . Using a subpixel shading method is sometimes faster than exact methods at the cost of accuracy. For  CircularAperture  the subpixel method is only faster than the exact method for  N  ~ 7. for  EllipticalAperture  the cutoff is  N  ~ 12, and for  RectangularAperture  the cutoff is  N  ~ 20. Examples julia> ap = CircularAperture(3, 3, 2.5)\n5×5 CircularAperture{Float64} with indices 1:5×1:5:\n 0.136857  0.769325  0.983232  0.769325  0.136857\n 0.769325  1.0       1.0       1.0       0.769325\n 0.983232  1.0       1.0       1.0       0.983232\n 0.769325  1.0       1.0       1.0       0.769325\n 0.136857  0.769325  0.983232  0.769325  0.136857\n\njulia> sub_ap = Subpixel(ap, 5)\n5×5 Subpixel{Float64, CircularAperture{Float64}} with indices 1:5×1:5:\n 0.12  0.76  1.0  0.76  0.12\n 0.76  1.0   1.0  1.0   0.76\n 1.0   1.0   1.0  1.0   1.0\n 0.76  1.0   1.0  1.0   0.76\n 0.12  0.76  1.0  0.76  0.12 Note photutils  offers a  center  shading method which is equivalent to using the  Subpixel  method with 1 subpixel. To avoid unneccessary namespace cluttering, we simply instruct users to use  Subpixel(ap)  instead. source"},{"id":690,"pagetitle":"Apertures","title":"Photometry.Aperture.area_arc","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.area_arc","content":" Photometry.Aperture.area_arc  —  Function Area of a circular segment above a chord between two points with circle radius  r Reference source"},{"id":691,"pagetitle":"Apertures","title":"Photometry.Aperture.circular_overlap_core","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.circular_overlap_core","content":" Photometry.Aperture.circular_overlap_core  —  Function Core of circular overlap routine source"},{"id":692,"pagetitle":"Apertures","title":"Photometry.Aperture.circular_overlap_single_exact","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.circular_overlap_single_exact","content":" Photometry.Aperture.circular_overlap_single_exact  —  Function Area of overlap between a rectangle and a circle source"},{"id":693,"pagetitle":"Apertures","title":"Photometry.Aperture.inside_ellipse","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.inside_ellipse","content":" Photometry.Aperture.inside_ellipse  —  Function inside_ellipse(x, y, h, k, cxx, cyy, cxy) x: x coordinate of the test point y: y coordinate of the test point h: x coordinate of the center of ellipse k: y coordinate of the center of ellipse cxx, cyy, cxy: coefficients of equation of ellipse Utility function to find whether a point is inside ellipse or not. If point inside ellipse: Returns true else returns false General equation of ellipse:     cxx * (x - h)^2 + cxy * (x - h) * (y - k) + cyy * (y - k)^2 = 1 source"},{"id":694,"pagetitle":"Apertures","title":"Base.size","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Base.size-Tuple{Photometry.Aperture.AbstractAperture}","content":" Base.size  —  Method size(::AbstractAperture) Return ( ny ,  nx ) of the aperture. source"},{"id":695,"pagetitle":"Apertures","title":"Photometry.Aperture.area_triangle","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.area_triangle","content":" Photometry.Aperture.area_triangle  —  Function Area of a triangle defined by three vertices source"},{"id":696,"pagetitle":"Apertures","title":"Photometry.Aperture.inside_rectangle","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.inside_rectangle","content":" Photometry.Aperture.inside_rectangle  —  Function intersection with rectangular using implicit Lamé curve source"},{"id":697,"pagetitle":"Apertures","title":"Photometry.Aperture.bounds","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.bounds","content":" Photometry.Aperture.bounds  —  Function bounds(::AbstractAperture) Return the ( xlow ,  xhigh ,  ylow ,  yhigh ) bounds for a given Aperture. source"},{"id":698,"pagetitle":"Apertures","title":"Circular Apertures","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Circular-Apertures","content":" Circular Apertures These apertures are parameterized by radius."},{"id":699,"pagetitle":"Apertures","title":"Photometry.Aperture.CircularAperture","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.CircularAperture","content":" Photometry.Aperture.CircularAperture  —  Type CircularAperture(x, y, r)\nCircularAperture(position, r) A circular aperture. A circular aperture with radius  r .  r  must be greater than or equal to 0. Examples julia> ap = CircularAperture(0, 0, 10)\n21×21 CircularAperture{Int64} with indices -10:10×-10:10:\n 0          0         0           …  0           0         0\n 0          0         0              0           0         0\n 0          0         0              0           0         0\n 0          0         0.00571026     0.00571026  0         0\n 0          0         0.491844       0.491844    0         0\n 0          0.170878  0.982952    …  0.982952    0.170878  0\n 0          0.659735  1              1           0.659735  0\n 0.0590655  0.975524  1              1           0.975524  0.0590655\n 0.293527   1         1              1           1         0.293527\n 0.445643   1         1              1           1         0.445643\n ⋮                                ⋱                        ⋮\n 0.293527   1         1              1           1         0.293527\n 0.0590655  0.975524  1              1           0.975524  0.0590655\n 0          0.659735  1              1           0.659735  0\n 0          0.170878  0.982952    …  0.982952    0.170878  0\n 0          0         0.491844       0.491844    0         0\n 0          0         0.00571026     0.00571026  0         0\n 0          0         0              0           0         0\n 0          0         0              0           0         0\n 0          0         0           …  0           0         0 source"},{"id":700,"pagetitle":"Apertures","title":"Photometry.Aperture.CircularAnnulus","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.CircularAnnulus","content":" Photometry.Aperture.CircularAnnulus  —  Type CircularAnnulus(x, y, r_in, r_out)\nCircularAnnulus(position, r_in, r_out) A circular annulus with inner radius  r_in  and outer radius  r_out . 0 ≤  r_in  ≤  r_out . Examples julia> ap = CircularAnnulus(0, 0, 5, 10)\n21×21 CircularAnnulus{Int64} with indices -10:10×-10:10:\n 0          0         0           …  0           0         0\n 0          0         0              0           0         0\n 0          0         0              0           0         0\n 0          0         0.00571026     0.00571026  0         0\n 0          0         0.491844       0.491844    0         0\n 0          0.170878  0.982952    …  0.982952    0.170878  0\n 0          0.659735  1              1           0.659735  0\n 0.0590655  0.975524  1              1           0.975524  0.0590655\n 0.293527   1         1              1           1         0.293527\n 0.445643   1         1              1           1         0.445643\n ⋮                                ⋱                        ⋮\n 0.293527   1         1              1           1         0.293527\n 0.0590655  0.975524  1              1           0.975524  0.0590655\n 0          0.659735  1              1           0.659735  0\n 0          0.170878  0.982952    …  0.982952    0.170878  0\n 0          0         0.491844       0.491844    0         0\n 0          0         0.00571026     0.00571026  0         0\n 0          0         0              0           0         0\n 0          0         0              0           0         0\n 0          0         0           …  0           0         0 source"},{"id":701,"pagetitle":"Apertures","title":"Elliptical Apertures","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Elliptical-Apertures","content":" Elliptical Apertures These apertures are parameterized by the semi-major axis  a , semi-minor axis  b  and position angle in degrees counter-clockwise from the positive x-axis  θ"},{"id":702,"pagetitle":"Apertures","title":"Photometry.Aperture.EllipticalAperture","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.EllipticalAperture","content":" Photometry.Aperture.EllipticalAperture  —  Type EllipticalAperture(x, y, a, b, θ=0)\nEllipticalAperture(position, a, b, θ=0) An elliptical aperture with semi-major axis  a , semi-minor axis  b , and position angle  θ .  a  and  b  must be ≥ 0,  θ  is measured in degrees counter-clockwise the standard x-axis. Examples julia> ap = EllipticalAperture(0, 0, 4, 2, 35)\n7×5 EllipticalAperture{Int64} with indices -3:3×-2:2:\n 0.873382  0.844185  0.324917  0         0\n 1         1         0.997821  0.435284  0\n 1         1         1         0.990119  0.23968\n 0.796137  1         1         1         0.796137\n 0.23968   0.990119  1         1         1\n 0         0.435284  0.997821  1         1\n 0         0         0.324917  0.844185  0.873382 source"},{"id":703,"pagetitle":"Apertures","title":"Photometry.Aperture.EllipticalAnnulus","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.EllipticalAnnulus","content":" Photometry.Aperture.EllipticalAnnulus  —  Type EllipticalAnnulus(x, y, a_in, a_out, b_out, θ=0)\nEllipticalAnnulus(position, a_in, a_out, b_out, θ=0) An elliptical annulus with inner semi-major axis  a_in , outer semi-major axis  a_out , outer semi-minor axis  b_out , and position angle  θ .  a_out  ≥  a_in  ≥ 0 and  b_out  must be ≥ 0,  θ  is measured in degrees counter-clockwise the standard x-axis. b_in  will automatically be calculated from  (a_in / a_out) * b_out . Note this may cause a type instability. Examples julia> ap = EllipticalAnnulus(0, 0, 4, 10, 5, 45)\n15×15 EllipticalAnnulus{Float64} with indices -7:7×-7:7:\n 0.594853   1.0       1.0       1.0         …  0.0       0.0       0.0\n 1.0        1.0       1.0       1.0            0.0       0.0       0.0\n 1.0        1.0       1.0       1.0            0.0       0.0       0.0\n 1.0        1.0       1.0       1.0            0.0       0.0       0.0\n 1.0        1.0       1.0       1.0            0.0       0.0       0.0\n 0.814163   1.0       1.0       1.0         …  0.414163  0.0       0.0\n 0.369432   1.0       1.0       1.0            0.975704  0.193728  0.0\n 0.0112571  0.809079  1.0       1.0            1.0       0.809079  0.0112571\n 0.0        0.193728  0.975704  1.0            1.0       1.0       0.369432\n 0.0        0.0       0.414163  1.0            1.0       1.0       0.814163\n 0.0        0.0       0.0       0.546165    …  1.0       1.0       1.0\n 0.0        0.0       0.0       0.00252321     1.0       1.0       1.0\n 0.0        0.0       0.0       0.0            1.0       1.0       1.0\n 0.0        0.0       0.0       0.0            1.0       1.0       1.0\n 0.0        0.0       0.0       0.0            1.0       1.0       0.594853 source"},{"id":704,"pagetitle":"Apertures","title":"Rectangular Apertures","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Rectangular-Apertures","content":" Rectangular Apertures These apertures are parameterized by width  w , height  h , and position angle in degrees counter-clockwise from the positive x-axis  θ ."},{"id":705,"pagetitle":"Apertures","title":"Photometry.Aperture.RectangularAperture","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.RectangularAperture","content":" Photometry.Aperture.RectangularAperture  —  Type RectangularAperture(x, y, w, h, θ=0)\nRectangularAperture(position, w, h, θ=0) A rectangular aperture. A rectangular aperture with width  w , height  h , and position angle  θ  in degrees. Examples julia> ap = RectangularAperture(0, 0, 10, 4, 0)\n11×5 RectangularAperture{Int64} with indices -5:5×-2:2:\n 0.25  0.5  0.5  0.5  0.25\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.25  0.5  0.5  0.5  0.25 source"},{"id":706,"pagetitle":"Apertures","title":"Photometry.Aperture.RectangularAnnulus","ref":"/previews/PR43/Photometry/stable/apertures/apertures/#Photometry.Aperture.RectangularAnnulus","content":" Photometry.Aperture.RectangularAnnulus  —  Type RectangularAnnulus(x, y, w_in, w_out, h_out, θ=0)\nRectangularAnnulus(position, w_in, w_out, h_out, θ=0) A rectangular annulus with inner width  w_in , outer width  w_out , outer height  h_out , and position angle  θ  in degrees.  h_in  is automatically calculated from  w_in / w_out * h_out . Note that  w_out ≥ w_in > 0 . Examples julia> ap = RectangularAnnulus(0, 0, 5, 10, 8, 45)\n13×13 RectangularAnnulus{Float64} with indices -6:6×-6:6:\n 0.0       0.0       0.0         …  0.0         0.0       0.0\n 0.0       0.0       0.0            0.0         0.0       0.0\n 0.0       0.0       0.00252532     0.0         0.0       0.0\n 0.0       0.0       0.568542       0.0         0.0       0.0\n 0.0       0.568542  1.0            0.215729    0.0       0.0\n 0.528175  1.0       1.0         …  1.0         0.215729  0.0\n 0.215729  1.0       1.0            1.0         1.0       0.215729\n 0.0       0.215729  1.0            1.0         1.0       0.528175\n 0.0       0.0       0.215729       1.0         0.568542  0.0\n 0.0       0.0       0.0            0.568542    0.0       0.0\n 0.0       0.0       0.0         …  0.00252532  0.0       0.0\n 0.0       0.0       0.0            0.0         0.0       0.0\n 0.0       0.0       0.0            0.0         0.0       0.0 source"},{"id":709,"pagetitle":"Examples","title":"Examples","ref":"/previews/PR43/Photometry/stable/apertures/examples/#Examples","content":" Examples"},{"id":710,"pagetitle":"Examples","title":"Plotting","ref":"/previews/PR43/Photometry/stable/apertures/examples/#Plotting","content":" Plotting We have recipes for all our aperture types, so you can easily create overlays on your images. using Photometry\nusing Plots\n\nplot(CircularAperture(2, 3, 4), c=1, xlims=(-1, 12), ylims=(0, 9))\nplot!(CircularAnnulus(5, 5, 2.1, 3), c=2)\nplot!(EllipticalAperture(0, 0, 10, 1, 32), c=3)\nplot!(EllipticalAnnulus(5, 5, 4, 5, 2, -32), c=4)\nplot!(RectangularAperture(0, 0, 4, 4, 4), c=5)\nplot!(RectangularAnnulus(5, 1, 3, 4, 4, 4), c=6)"},{"id":711,"pagetitle":"Examples","title":"Simple Stars","ref":"/previews/PR43/Photometry/stable/apertures/examples/#Simple-Stars","content":" Simple Stars Here is an example where we will find aperture fluxes for stars from M67. The dataset is provided as part of the  astropy/photutils-datasets  repository. Let's start by downloading and showing our image using Photometry\nusing Plots\nusing FITSIO\n\n# Load data in\nurl = \"https://rawcdn.githack.com/astropy/photutils-datasets/8c97b4fa3a6c9e6ea072faeed2d49a20585658ba/data/M6707HH.fits\"\nhdu = FITS(download(url))\nchunk = read(hdu[1], 81:155, 71:150)\n\n# Plot\nfunction imshow(image; kwargs...)\n    xs, ys = axes(image)\n    data = transpose(image)\n    heatmap(xs, ys, data; aspect_ratio=1, xlim=extrema(xs), ylim=extrema(ys), kwargs...)\nend\n\nimshow(chunk) Now let's add some apertures! positions = [\n    [47.5 , 67.5],\n    [29.5 , 62.5],\n    [23.5 , 48.5],\n    [17.5 , 29.5],\n    [13.25, 10.5],\n    [65.5 , 14.0]\n]\n\nradii = [3, 3, 2.7, 2, 2.7, 3]\n\naps = CircularAperture.(positions, radii) 6-element Vector{CircularAperture{Float64}}:\n CircularAperture(47.5, 67.5, r=3.0)\n CircularAperture(29.5, 62.5, r=3.0)\n CircularAperture(23.5, 48.5, r=2.7)\n CircularAperture(17.5, 29.5, r=2.0)\n CircularAperture(13.25, 10.5, r=2.7)\n CircularAperture(65.5, 14.0, r=3.0) now let's plot them up imshow(chunk)\nplot!(aps, c=:white) and finally let's get our output table for the photometry table = photometry(aps, chunk) Table with 3 columns and 6 rows:\n     xcenter  ycenter  aperture_sum\n   ┌───────────────────────────────\n 1 │ 47.5     67.5     2.48267e5\n 2 │ 29.5     62.5     2.25989e5\n 3 │ 23.5     48.5     1.49979e5\n 4 │ 17.5     29.5     72189.4\n 5 │ 13.25    10.5     1.48118e5\n 6 │ 65.5     14.0     2.02803e5"},{"id":712,"pagetitle":"Examples","title":"Stars with Spatial Background Subtraction","ref":"/previews/PR43/Photometry/stable/apertures/examples/#Stars-with-Spatial-Background-Subtraction","content":" Stars with Spatial Background Subtraction This example will be the same as  Simple Stars  but will add background estimation using the tools in  Background Estimation clipped = sigma_clip(chunk, 1, fill=NaN)\n# Estimate 2D spatial background using boxes of size (5, 5)\nbkg, bkg_rms = estimate_background(clipped, 5)\n\nplot(\n    imshow(chunk, title=\"Original\"),\n    imshow(clipped, title=\"Sigma-Clipped\"),\n    imshow(bkg, title=\"Background\"),\n    imshow(bkg_rms, title=\"Background RMS\");\n    layout=(2, 2), size=(600, 600), ticks=false\n) Now, using the same apertures, let's find the output using the background-subtracted image plot(\n    imshow(chunk, title=\"Original\"),\n    imshow(chunk .- bkg, title=\"Subtracted\");\n    layout=2, size=(600, 260), ticks=false, colorbar=false\n)\nplot!(aps, c=:white, subplot=1)\nplot!(aps, c=:white, subplot=2) table = photometry(aps, chunk .- bkg, bkg_rms) Table with 4 columns and 6 rows:\n     xcenter  ycenter  aperture_sum  aperture_sum_err\n   ┌─────────────────────────────────────────────────\n 1 │ 47.5     67.5     2.13534e5     431.48\n 2 │ 29.5     62.5     114217.0      887.37\n 3 │ 23.5     48.5     59230.7       1061.28\n 4 │ 17.5     29.5     23159.6       697.556\n 5 │ 13.25    10.5     54638.1       1048.67\n 6 │ 65.5     14.0     91179.1       1168.71"},{"id":715,"pagetitle":"Getting Started","title":"Background Estimation","ref":"/previews/PR43/Photometry/stable/background/#Background-Estimation","content":" Background Estimation The module provides tools and algorithms for estimating the background of astronomical data."},{"id":716,"pagetitle":"Getting Started","title":"Usage","ref":"/previews/PR43/Photometry/stable/background/#Usage","content":" Usage Estimating backgrounds is an important step in performing photometry. Ideally, we could perfectly describe the background with a scalar value or with some distribution. Unfortunately, it's impossible for us to precisely separate the background and foreground signals. Here, we use mixture of robust statistical estimators and meshing to let us get the spatially varying background from an astronomical photo. Let's show an example using Photometry\nusing FITSIO\nusing Plots\n\n# Download our image, courtesy of astropy\nurl = \"https://rawcdn.githack.com/astropy/photutils-datasets/8c97b4fa3a6c9e6ea072faeed2d49a20585658ba/data/M6707HH.fits\"\nhdu = FITS(download(url))\nimage = read(hdu[1])\n\n# Plot\nfunction imshow(image; kwargs...)\n    xs, ys = axes(image)\n    data = transpose(image)\n    heatmap(xs, ys, data;\n            aspect_ratio=1,\n            xlim=extrema(xs), ylim=extrema(ys),\n            kwargs...)\nend\n\nimshow(image) Now let's try and estimate the background using  estimate_background . First, we'll sigma-clip to try and remove the signals from the stars. Then, the background is broken down into boxes, in this case of size  (50, 50) . Within each box, the given statistical estimators get the background value and RMS. By default, we use  SourceExtractorBackground  and  StdRMS . This creates a low-resolution image, which we then need to resize. We can accomplish this using an interpolator, by default a cubic-spline interpolator via  ZoomInterpolator . The end result is a smooth estimate of the spatially varying background and background RMS. # sigma-clip\nclipped = sigma_clip(image, 1, fill=NaN)\n\n# get background and background rms with box-size (50, 50)\nbkg, bkg_rms = estimate_background(clipped, 50)\n\n# plot\nplot(\n    imshow(image, title=\"Original\"),\n    imshow(clipped, title=\"Sigma-Clipped\"),\n    imshow(bkg, title=\"Background\"),\n    imshow(bkg_rms, title=\"Background RMS\"),\n    layout=(2, 2), ticks=false,\n) We could apply a median filter, too, by specifying  filter_size # get background and background rms with box-size (50, 50) and filter_size (5, 5)\nbkg_f, bkg_rms_f = estimate_background(clipped, 50, filter_size=5)\n\n# plot\nplot(\n    imshow(bkg, title=\"Unfiltered\", ylabel=\"Background\"),\n    imshow(bkg_f, title=\"Filtered\"),\n    imshow(bkg_rms, ylabel=\"RMS\"),\n    imshow(bkg_rms_f);\n    layout=(2, 2), ticks=false,\n) Now we can see our image after subtracting the filtered background and ready for  Aperture Photometry ! subt = image .- bkg_f[axes(image)...]\nplot(\n    imshow(image, title=\"Original\", colorbar=false),\n    imshow(subt, title=\"Subtracted\");\n    layout=(1, 2), size=(600, 260),\n    xlims=(400, 800), ylims=(400, 800),\n    clims=(minimum(subt), maximum(image)),\n    ticks=false, aspect_ratio=1,\n)"},{"id":717,"pagetitle":"Getting Started","title":"IDW Interpolator","ref":"/previews/PR43/Photometry/stable/background/#IDW-Interpolator","content":" IDW Interpolator Here is a quick example using the  IDWInterpolator b1, r1 = estimate_background(clipped, 50, filter_size=5)\nb2, r2 = estimate_background(clipped, 50, itp=IDWInterpolator(50), filter_size=5)\n\nplot(\n    imshow(b1, title=\"ZoomInterpolator\", ylabel=\"Background\"),\n    imshow(b2, title=\"IDWInterpolator\"),\n    imshow(r1, ylabel=\"RMS\"),\n    imshow(r2);\n    layout=(2, 2), ticks=false,\n)"},{"id":718,"pagetitle":"Getting Started","title":"API/Reference","ref":"/previews/PR43/Photometry/stable/background/#API/Reference","content":" API/Reference"},{"id":719,"pagetitle":"Getting Started","title":"Photometry.Background.estimate_background","ref":"/previews/PR43/Photometry/stable/background/#Photometry.Background.estimate_background","content":" Photometry.Background.estimate_background  —  Function estimate_background(data;\n    location=SourceExtractorBackground(),\n    rms=StdRMS(),\n    dims=:) Perform scalar background estimation using the given estimators. The value returned will be two values corresponding to the estimated background and the estimated background RMS. The dimensionality will depend on the  dims  keyword. location  and  rms  can be anything that is callable, for example  median , or one of the estimators we provide in  Background Estimators . Examples julia> data = ones(3, 5);\n\njulia> bkg, bkg_rms = estimate_background(data)\n(1.0, 0.0)\n\njulia> using Statistics: median\n\njulia> bkg, bkg_rms = estimate_background(data; location=median, rms=MADStdRMS())\n(1.0, 0.0) See Also Location Estimators ,  RMS Estimators source estimate_background(data, box_size;\n    location=SourceExtractorBackground(),\n    rms=StdRMS(),\n    itp=ZoomInterpolator(box_size),\n    edge_method=:pad,\n    [filter_size]) Perform 2D background estimation using the given estimators mapped over windows of the data. This function will estimate backgrounds in boxes of size  box_size . When  size(data)  is not an integer multiple of the box size, there are two edge methods:  :pad  and  :crop . The default is to pad (and is recommend to avoid losing image data). If  box_size  is an integer, the implicit shape will be square (eg.  box_size=4  is equivalent to  box_size=(4,4) ). For evaluating the meshes, each box will be passed into  location  to estimate the background and then into  rms  to estimate the background root-mean-square value. These can be anything that is callable, like  median  or one of our  Background Estimators . Once the meshes are created they will be median filtered if  filter_size  is given.  filter_size  can be either an integer or a tuple, with the integer being converted to a tuple the same way  box_size  is. Filtering is done via  ImageFiltering.MapWindow.mapwindow .  filter_size  must be odd. After filtering (if applicable), the meshes are passed to the  itp  to recreate a low-order estimate of the background at the same resolution as the input. Note If your  box_size  is not an integer multiple of the input size, the output background and rms arrays will not have the same size. See Also Location Estimators ,  RMS Estimators ,  Interpolators source"},{"id":720,"pagetitle":"Getting Started","title":"Photometry.Background.sigma_clip","ref":"/previews/PR43/Photometry/stable/background/#Photometry.Background.sigma_clip","content":" Photometry.Background.sigma_clip  —  Function sigma_clip(x, sigma; fill=:clamp, center=median(x), std=std(x, corrected=false))\nsigma_clip(x, sigma_low, sigma_high; fill=:clamp, center=median(x), std=std(x, corrected=false)) This function returns sigma-clipped values of the input  x . Specify the upper and lower bounds with  sigma_low  and  sigma_high , otherwise assume they are equal.  center  and  std  are optional keyword arguments which are functions for finding central element and standard deviation. If  fill === :clamp , this will clamp values in  x  lower than  center - sigma_low * std  and values higher than  center + sigma_high * std . Otherwise, they will be replaced with  fill . Examples julia> x = randn(100_000);\n\njulia> extrema(x)\n(-4.496308951466683, 4.080724496910187)\n\njulia> x_clip = sigma_clip(x, 1);\n\njulia> extrema(x_clip) # should be close to (-1, 1)\n(-1.0042721545326967, 0.9957463910682249) source"},{"id":721,"pagetitle":"Getting Started","title":"Photometry.Background.sigma_clip!","ref":"/previews/PR43/Photometry/stable/background/#Photometry.Background.sigma_clip!","content":" Photometry.Background.sigma_clip!  —  Function sigma_clip!(x, sigma; fill=:clamp, center=median(x), std=std(x))\nsigma_clip!(x, sigma_low, sigma_high; fill=:clamp, center=median(x), std=std(x)) In-place version of  sigma_clip Warning sigma_clip!  mutates the element in place and mutation cannot lead to change in type. Please be considerate of your input type, because if you are using  Int64  and we try to clip it to  0.5  an  InexactError  will be thrown. To avoid this, we recommend converting to float before clipping, or using  sigma_clip  which does this internally. source"},{"id":722,"pagetitle":"Getting Started","title":"Photometry.Background.validate_SE","ref":"/previews/PR43/Photometry/stable/background/#Photometry.Background.validate_SE","content":" Photometry.Background.validate_SE  —  Function Utility function for SourceExtractorBackground algorithm source"},{"id":725,"pagetitle":"Background Estimators","title":"Background Estimators","ref":"/previews/PR43/Photometry/stable/background/estimators/#Background-Estimators","content":" Background Estimators All of these estimators are subtypes of  Background.LocationEstimator  or  Background.RMSEstimator  and are derived using various statistical and image processing methods."},{"id":726,"pagetitle":"Background Estimators","title":"Location Estimators","ref":"/previews/PR43/Photometry/stable/background/estimators/#Location-Estimators","content":" Location Estimators These estimators are used for estimating the background using some form of a central statistic."},{"id":727,"pagetitle":"Background Estimators","title":"Photometry.Background.LocationEstimator","ref":"/previews/PR43/Photometry/stable/background/estimators/#Photometry.Background.LocationEstimator","content":" Photometry.Background.LocationEstimator  —  Type Background.LocationEstimator This abstract type embodies the possible background estimation algorithms for dispatch with  estimate_background . To implement a new estimator, you must define the struct and define a method like  (::MyEstimator)(data::AbstractArray; dims=:) . See Also Location Estimators source"},{"id":728,"pagetitle":"Background Estimators","title":"Photometry.Background.MMMBackground","ref":"/previews/PR43/Photometry/stable/background/estimators/#Photometry.Background.MMMBackground","content":" Photometry.Background.MMMBackground  —  Type MMMBackground(median_factor=3, mean_factor=2) Estimate the background using a mode estimator of the form  median_factor * median - mean_factor * mean . This algorithm is based on the  MMMBackground  routine originally implemented in DAOPHOT.  MMMBackground  uses factors of  median_factor=3  and  mean_factor=2  by default. This estimator assumes that contaminated sky pixel values overwhelmingly display positive departures from the true value. Examples julia> x = ones(3, 5);\n\njulia> MMMBackground()(x)\n1.0\n\njulia> MMMBackground(median_factor=4, mean_factor=3)(x, dims = 1)\n1×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0 See Also SourceExtractorBackground source"},{"id":729,"pagetitle":"Background Estimators","title":"Photometry.Background.SourceExtractorBackground","ref":"/previews/PR43/Photometry/stable/background/estimators/#Photometry.Background.SourceExtractorBackground","content":" Photometry.Background.SourceExtractorBackground  —  Type SourceExtractorBackground() This estimator returns the background of the input using the SourceExtractorBackground algorithm. The background is calculated using a mode estimator of the form  (2.5 * median) - (1.5 * mean) . If  (mean - median) / std > 0.3  then the median is used and if  std = 0  then the mean is used. Examples julia> data = ones(3, 5);\n\njulia> SourceExtractorBackground()(data)\n1.0\n\njulia> SourceExtractorBackground()(data, dims=1)\n1×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0 source"},{"id":730,"pagetitle":"Background Estimators","title":"Photometry.Background.BiweightLocationBackground","ref":"/previews/PR43/Photometry/stable/background/estimators/#Photometry.Background.BiweightLocationBackground","content":" Photometry.Background.BiweightLocationBackground  —  Type BiweightLocationBackground(c = 6.0, M = nothing) Estimate the background using the robust biweight location statistic. \\[ξ_{biloc} = M + \\frac{∑_{|uᵢ|<1}{(xᵢ - M)(1 - uᵢ²)²}}{∑_{|uᵢ|<1}{(1-uᵢ²)²}}\\] \\[u_i = \\frac{(x_i - M)}{c⋅\\mathrm{MAD}(x)}\\] Where  $\\mathrm{MAD}(x)$  is median absolute deviation of  x . Examples julia> x = ones(3,5);\n\njulia> BiweightLocationBackground()(x)\n1.0\n\njulia> BiweightLocationBackground(c=5.5)(x; dims = 1)\n1×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0 source"},{"id":731,"pagetitle":"Background Estimators","title":"RMS Estimators","ref":"/previews/PR43/Photometry/stable/background/estimators/#RMS-Estimators","content":" RMS Estimators These estimators are used for estimating the root-mean-square (RMS) of the background using some form of a deviation statistic."},{"id":732,"pagetitle":"Background Estimators","title":"Photometry.Background.RMSEstimator","ref":"/previews/PR43/Photometry/stable/background/estimators/#Photometry.Background.RMSEstimator","content":" Photometry.Background.RMSEstimator  —  Type Background.RMSEstimator This abstract type embodies the possible background RMS estimation algorithms for dispatch with  estimate_background . To implement a new estimator, you must define the struct and define a method like  (::MyRMSEstimator)(data::AbstractArray; dims=:) . See Also RMS Estimators source"},{"id":733,"pagetitle":"Background Estimators","title":"Photometry.Background.StdRMS","ref":"/previews/PR43/Photometry/stable/background/estimators/#Photometry.Background.StdRMS","content":" Photometry.Background.StdRMS  —  Type StdRMS() Uses the standard deviation statistic for background RMS estimation. Examples julia> data = ones(3, 5);\n\njulia> StdRMS()(data)\n0.0\n\njulia> StdRMS()(data, dims=1)\n1×5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0 source"},{"id":734,"pagetitle":"Background Estimators","title":"Photometry.Background.MADStdRMS","ref":"/previews/PR43/Photometry/stable/background/estimators/#Photometry.Background.MADStdRMS","content":" Photometry.Background.MADStdRMS  —  Type MADStdRMS() Uses the standard median absolute deviation (MAD) statistic for background RMS estimation. This is typically given as $σ ≈ 1.4826 ⋅ \\mathrm{MAD}$ Examples julia> data = ones(3, 5);\n\njulia> MADStdRMS()(data)\n0.0\n\njulia> MADStdRMS()(data, dims=1)\n1×5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0 source"},{"id":735,"pagetitle":"Background Estimators","title":"Photometry.Background.BiweightScaleRMS","ref":"/previews/PR43/Photometry/stable/background/estimators/#Photometry.Background.BiweightScaleRMS","content":" Photometry.Background.BiweightScaleRMS  —  Type BiweightScaleRMS(c=9.0, M=nothing) Uses the robust biweight scale statistic for background RMS estimation. The biweight scale is the square root of the biweight midvariance. The biweight midvariance uses a tuning constant,  c , and an optional initial guess of the central value  M . \\[ζ²_{biscl} = \\frac{n ∑_{|uᵢ|<1}{(xᵢ - M)²(1 - uᵢ²)⁴}}{\\left[∑_{|uᵢ|<1}{(1-uᵢ²)(1-5uᵢ²)}\\right]²}\\] \\[uᵢ = \\frac{(xᵢ - M)}{c⋅\\mathrm{MAD}(x)}\\] Where  $\\mathrm{MAD}(x)$  is median absolute deviation of  x . Examples julia> data = ones(3, 5);\n\njulia> BiweightScaleRMS()(data)\n0.0\n\njulia> BiweightScaleRMS(c=3.0)(data, dims=1)\n1×5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0 source"},{"id":738,"pagetitle":"Background Interpolators","title":"Background Interpolators","ref":"/previews/PR43/Photometry/stable/background/interpolators/#Background-Interpolators","content":" Background Interpolators Background interpolators provide a method for converting a low-resolution mesh into a low-order high-resolution image."},{"id":739,"pagetitle":"Background Interpolators","title":"Photometry.Background.BackgroundInterpolator","ref":"/previews/PR43/Photometry/stable/background/interpolators/#Photometry.Background.BackgroundInterpolator","content":" Photometry.Background.BackgroundInterpolator  —  Type Background.BackgroundInterpolator This abstract type embodies the different ways of converting a low-resolution mesh into a high-resolution image, especially for dispatch with  estimate_background To implement a new interpolation scheme, you must define the struct and define a method like  (::MyInterpolator)(mesh) See Also Interpolators source"},{"id":740,"pagetitle":"Background Interpolators","title":"Interpolators","ref":"/previews/PR43/Photometry/stable/background/interpolators/#Interpolators","content":" Interpolators"},{"id":741,"pagetitle":"Background Interpolators","title":"Photometry.Background.ZoomInterpolator","ref":"/previews/PR43/Photometry/stable/background/interpolators/#Photometry.Background.ZoomInterpolator","content":" Photometry.Background.ZoomInterpolator  —  Type ZoomInterpolator(factors) Use a cubic-spline interpolation scheme to increase resolution of a mesh. factors  represents the level of \"zoom\", so an input mesh of size  (10, 10)  with factors  (2, 2)  will have an output size of  (20, 20) . If only an integer is provided, it will be used as the factor for every axis. Examples julia> ZoomInterpolator(2)([1 0; 0 1])\n4×4 Matrix{Float64}:\n  1.0          0.75   0.25   -2.77556e-17\n  0.75         0.625  0.375   0.25\n  0.25         0.375  0.625   0.75\n -5.55112e-17  0.25   0.75    1.0\n\njulia> ZoomInterpolator(3, 1)([1 0; 0 1])\n6×2 Matrix{Float64}:\n  1.0          -2.77556e-17\n  1.0          -2.77556e-17\n  0.666667      0.333333\n  0.333333      0.666667\n -5.55112e-17   1.0\n -5.55112e-17   1.0\n source"},{"id":742,"pagetitle":"Background Interpolators","title":"Photometry.Background.IDWInterpolator","ref":"/previews/PR43/Photometry/stable/background/interpolators/#Photometry.Background.IDWInterpolator","content":" Photometry.Background.IDWInterpolator  —  Type IDWInterpolator(factors; leafsize=10, k=8, power=1, reg=0, conf_dist=1e-12) Use Shepard Inverse Distance Weighing interpolation scheme to increase resolution of a mesh. factors  represents the level of \"zoom\", so an input mesh of size  (10, 10)  with factors  (2, 2)  will have an output size of  (20, 20) . If only an integer is provided, it will be used as the factor for every axis. The interpolator can be called with some additional parameters: leaf_size  determines at what number of points to stop splitting the tree further, k  which is the number of nearest neighbors to be considered, power  is the exponent for distance in the weighing factor, reg  is the offset for the weighing factor in denominator, conf_dist  is the distance below which two points would be considered as the same point. Examples julia> IDWInterpolator(2, k=2)([1 0; 0 1])\n4×4 Matrix{Float64}:\n 1.0   0.75      0.25      0.0\n 0.75  0.690983  0.309017  0.25\n 0.25  0.309017  0.690983  0.75\n 0.0   0.25      0.75      1.0\n\njulia> IDWInterpolator(3, 1; k=2, power=4)([1 0; 0 1])\n6×2 Matrix{Float64}:\n 1.0        0.0\n 1.0        0.0\n 0.941176   0.0588235\n 0.0588235  0.941176\n 0.0        1.0\n 0.0        1.0 source"},{"id":745,"pagetitle":"Getting Started","title":"Source Detection","ref":"/previews/PR43/Photometry/stable/detection/#Source-Detection","content":" Source Detection The module provides tools and algorithms for detecting and extracting point-like sources."},{"id":746,"pagetitle":"Getting Started","title":"API/Reference","ref":"/previews/PR43/Photometry/stable/detection/#API/Reference","content":" API/Reference"},{"id":747,"pagetitle":"Getting Started","title":"Photometry.Detection.extract_sources","ref":"/previews/PR43/Photometry/stable/detection/#Photometry.Detection.extract_sources","content":" Photometry.Detection.extract_sources  —  Function extract_sources(::SourceFinder, data, [error]; sorted=true) Uses  method  to find and extract point-like sources. Returns a  TypedTables.Table  with positions and information related to the  method . For instance, using  PeakMesh  returns a table a column for the peak values. data  is assumed to be background-subtracted. If  error  is provided it will be propagated into the detection algorithm. If  sorted  is  true  the sources will be sorted by their amplitude. See Also Source Detection Algorithms source"},{"id":750,"pagetitle":"Algorithms","title":"Source Detection Algorithms","ref":"/previews/PR43/Photometry/stable/detection/algs/#Source-Detection-Algorithms","content":" Source Detection Algorithms"},{"id":751,"pagetitle":"Algorithms","title":"Photometry.Detection.SourceFinder","ref":"/previews/PR43/Photometry/stable/detection/algs/#Photometry.Detection.SourceFinder","content":" Photometry.Detection.SourceFinder  —  Type Detection.SourceFinder Abstract super type for source detection algorithms used with  extract_sources . source"},{"id":752,"pagetitle":"Algorithms","title":"API/Reference","ref":"/previews/PR43/Photometry/stable/detection/algs/#API/Reference","content":" API/Reference"},{"id":753,"pagetitle":"Algorithms","title":"Photometry.Detection.PeakMesh","ref":"/previews/PR43/Photometry/stable/detection/algs/#Photometry.Detection.PeakMesh","content":" Photometry.Detection.PeakMesh  —  Type PeakMesh(box_size=(3, 3), nsigma=3.0) Detect sources by finding peaks above a threshold in grids across the image. This creates a pixel-wise threshold for sources by calculating  error * nsigma  when used with  extract_sources . The peaks are found by searching the image in boxes of size  box_size . If the maximum value in that box is greater than the threshold set above, the point is extracted. source"},{"id":756,"pagetitle":"Home","title":"PSFModels.jl","ref":"/previews/PR43/PSFModels/stable/#PSFModels.jl","content":" PSFModels.jl"},{"id":757,"pagetitle":"Home","title":"Installation","ref":"/previews/PR43/PSFModels/stable/#Installation","content":" Installation PSFModels can be added from the Julia package manager julia> ] # pressing ']' should drop you into pkg-mode\npkg> add PSFModels"},{"id":758,"pagetitle":"Home","title":"Getting Started","ref":"/previews/PR43/PSFModels/stable/#Getting-Started","content":" Getting Started To import the library julia> using PSFModels None of the models are exported to avoid namespace clashes, but it can be verbose to continuously rewrite  PSFModels . You can either import names directly julia> using PSFModels: gaussian\n\njulia> model = gaussian(x=0, y=0, fwhm=8) or you can create an alias for  PSFModels # julia version 1.5 or below\nusing PSFModels\nconst M = PSFModels\n# julia version 1.6 or above\nimport PSFModels as M\n\nmodel = M.gaussian(x=0, y=0, fwhm=10)"},{"id":759,"pagetitle":"Home","title":"Contributing and Support","ref":"/previews/PR43/PSFModels/stable/#Contributing-and-Support","content":" Contributing and Support If you would like to contribute, feel free to open a  pull request . If you want to discuss something before contributing, head over to  discussions  and join or open a new topic. If you're having problems with something, please open an  issue ."},{"id":762,"pagetitle":"API/Reference","title":"API/Reference","ref":"/previews/PR43/PSFModels/stable/api/#API/Reference","content":" API/Reference PSFModels.airydisk PSFModels.fit PSFModels.gaussian PSFModels.moffat PSFModels.normal"},{"id":763,"pagetitle":"API/Reference","title":"Gaussian","ref":"/previews/PR43/PSFModels/stable/api/#Gaussian","content":" Gaussian"},{"id":764,"pagetitle":"API/Reference","title":"PSFModels.gaussian","ref":"/previews/PR43/PSFModels/stable/api/#PSFModels.gaussian","content":" PSFModels.gaussian  —  Function gaussian([T=Float64], point; x, y, fwhm, amp=1, theta=0, bkg=0)\ngaussian([T=Float64], px, py; x, y, fwhm, amp=1, theta=0, bkg=0) An unnormalized bivariate Gaussian distribution. The position can be specified in  (x, y)  coordinates as a  Tuple ,  AbstractVector , or as separate arguments. If  theta  is given, the PSF will be rotated by  theta  degrees counter-clockwise from the x-axis. If  bkg  is given it will be added as a scalar to the PSF. The  fwhm  can be a scalar (isotropic) or a vector/tuple (diagonal). Keep in mind that  theta  has no effect for isotropic distributions and is degenerate with the  fwhm  parameters (i.e., theta=90 is the same as reversing the  fwhm  tuple) Functional form \\[f(x | x̂, \\mathrm{FWHM}) = \\exp[-4 \\ln(2) ⋅ ||x - x̂|| / \\mathrm{FWHM}^2]\\] where  x̂  and  x  are position vectors (indices)  ||⋅||  represents the square-distance, and  FWHM  is the full width at half-maximum. If  FWHM  is a scalar, the Gaussian distribution will be isotropic. If  FWHM  is a vector or tuple, the weighting is applied along each axis (diagonal). source"},{"id":765,"pagetitle":"API/Reference","title":"PSFModels.normal","ref":"/previews/PR43/PSFModels/stable/api/#PSFModels.normal","content":" PSFModels.normal  —  Function normal An alias for  gaussian source gauss = gaussian(x=0, y=0, fwhm=10)\npsfplot(gauss, -50:50, -50:50; title=\"gaussian(fwhm=10)\",\n        colorbar_scale=:log10, clims=(1e-5, 1))"},{"id":766,"pagetitle":"API/Reference","title":"Airy Disk","ref":"/previews/PR43/PSFModels/stable/api/#Airy-Disk","content":" Airy Disk"},{"id":767,"pagetitle":"API/Reference","title":"PSFModels.airydisk","ref":"/previews/PR43/PSFModels/stable/api/#PSFModels.airydisk","content":" PSFModels.airydisk  —  Function airydisk([T=Float64], point; x, y, fwhm, ratio=0, amp=1, theta=0, bkg=0)\nairydisk([T=Float64], px, py; x, y, fwhm, ratio=0, amp=1, theta=0, bkg=0) An unnormalized Airy disk. The position can be specified in  (x, y)  coordinates as a  Tuple ,  AbstractVector , or as separate arguments. If  theta  is given, the PSF will be rotated by  theta  degrees counter-clockwise from the x-axis. If  bkg  is given it will be added as a scalar to the PSF. The  fwhm  can be a scalar (isotropic) or a vector/tuple (diagonal). Keep in mind that  theta  has no effect for isotropic distributions and is degenerate with the  fwhm  parameters (i.e., theta=90 is the same as reversing the  fwhm  tuple) If  ratio  is supplied, this will be the Airy pattern for a centrally-obscured aperture (e.g., a Newtonian telescope). This has a slightly expanded functional form, and in general the central Airy disk will be smaller and the first Airy ring will be brighter. Functional form The Airy disk is a distribution over the radius  r  (the square-Euclidean distance) \\[f(x | x̂, \\mathrm{FWHM}) = [ 2J₁(q) / q ]^2\\] where  J₁  is the first-order Bessel function of the first kind and \\[q ≈ π r D / λ ≈ π r / (0.973 × \\mathrm{FWHM})\\] If user a non-zero central obscuration via  ratio , the functional form becomes \\[f(x | x̂, \\mathrm{FWHM}, ϵ) = [ 2J₁(q) / q - 2ϵJ₁(ϵq) / q ]^2 / (1 - ϵ^2)^2\\] where  $ϵ$  is the ratio ( $0 ≤ ϵ < 1$ ). source airy = airydisk(x=0, y=0, fwhm=10)\npsfplot(airy, -50:50, -50:50; title=\"airydisk(fwhm=10)\",\n        colorbar_scale=:log10, clims=(1e-5, 1)) airy_obscured = airydisk(x=0, y=0, fwhm=10, ratio=0.3)\npsfplot(airy_obscured, -50:50, -50:50; title=\"airydisk(fwhm=10, ratio=0.3)\",\n        colorbar_scale=:log10, clims=(1e-5, 1))"},{"id":768,"pagetitle":"API/Reference","title":"Moffat","ref":"/previews/PR43/PSFModels/stable/api/#Moffat","content":" Moffat"},{"id":769,"pagetitle":"API/Reference","title":"PSFModels.moffat","ref":"/previews/PR43/PSFModels/stable/api/#PSFModels.moffat","content":" PSFModels.moffat  —  Function moffat([T=Float64], point; x, y, fwhm, alpha=1, amp=1, theta=0, bkg=0)\nmoffat([T=Float64], px, py; x, y, fwhm, alpha=1, amp=1, theta=0, bkg=0) Two dimensional Moffat model. The position can be specified in  (x, y)  coordinates as a  Tuple ,  AbstractVector , or as separate arguments. If  theta  is given, the PSF will be rotated by  theta  degrees counter-clockwise from the x-axis. If  bkg  is given it will be added as a scalar to the PSF. The  fwhm  can be a scalar (isotropic) or a vector/tuple (diagonal). Keep in mind that  theta  has no effect for isotropic distributions and is degenerate with the  fwhm  parameters (i.e., theta=90 is the same as reversing the  fwhm  tuple) Functional form \\[f(x | x̂, \\mathrm{FWHM}, α) = A (1 + (||x - x̂|| / \\mathrm{FWHM} / 2)^2)^{-α}\\] where  x̂  and  x  are position vectors (indices)  ||⋅||  represents the distance, and  FWHM  is the full width at half-maximum. If  fwhm  is a vector or tuple, the weighting is applied along each axis. Note that this function technically uses the half width at half-maximum, defined as  $\\mathrm{HWHM} = \\mathrm{FWHM}/2$ , but for compatibility with the other models,  fwhm  is used as an input parameter instead. source moff = moffat(x=0, y=0, fwhm=10)\npsfplot(moff, -50:50, -50:50; title=\"moffat(fwhm=10)\",\n        colorbar_scale=:log10, clims=(1e-5, 1)) moff2 = moffat(x=0, y=0, fwhm=10, alpha=2)\npsfplot(moff2, -50:50, -50:50; title=\"moffat(fwhm=10, alpha=2)\",\n        colorbar_scale=:log10, clims=(1e-5, 1))"},{"id":770,"pagetitle":"API/Reference","title":"Comparison","ref":"/previews/PR43/PSFModels/stable/api/#Comparison","content":" Comparison xs = range(0, 50, length=1000)\nplot(\n    xs, [gauss.(xs, 0) airy.(xs, 0) moff.(xs, 0)],\n    label=[\"gaussian\" \"airydisk\" \"moffat\"], yscale=:log10,\n    xlabel=\"x\", ylabel=\"I\", ylims=(1e-5, 1)\n)"},{"id":771,"pagetitle":"API/Reference","title":"Fitting","ref":"/previews/PR43/PSFModels/stable/api/#Fitting","content":" Fitting"},{"id":772,"pagetitle":"API/Reference","title":"PSFModels.fit","ref":"/previews/PR43/PSFModels/stable/api/#PSFModels.fit","content":" PSFModels.fit  —  Function PSFModels.fit(model, params, image, inds=axes(image);\n              func_kwargs=(;), loss=abs2, maxfwhm=Inf, alg=LBFGS(),\n              kwargs...) Fit a PSF model ( model ) defined by the given  params  as a named tuple of the parameters to fit and their default values. This model is fit to the data in  image  at the specified  inds  (by default, the entire array). To pass extra keyword arguments to the  model  (i.e., to \"freeze\" a parameter), pass them in a named tuple to  func_kwargs . The default loss function is the chi-squared loss, which uses the the square of the difference (i.e., the L2 norm). You can change this to the L1 norm, for example, by passing  loss=abs . The maximum FWHM can be set with  maxfwhm  as a number or tuple. Additional keyword arguments, as well as the fitting algorithm  alg , are passed to  Optim.optimize . By default we use forward-mode auto-differentiation (AD) to derive Jacobians for the  Newton with Trust Region  optimization algorithm. Refer to the  Optim.jl documentation  for more information. Choosing parameters The  fit  function is very powerful because it gives you a great amount of flexibility in the way you fit your models. To demonstrate this, let's start with a simple isotropic  gaussian . model = gaussian\n# match params to arguments of PSF\nparams = (x=20, y=20, fwhm=3, amp=1) Note that  params  can follow any order params = (amp=1, x=20, y=20, fwhm=3) Now, to extend this interface to the bivariate PSF case, where  fwhm  is two values, all you need to do is use a tuple or vector params = (x=20, y=20, fwhm=(3, 3)) and, again, the order does not matter model = moffat\nparams = (alpha=1, x=20, y=20, fwhm=3, amp=10) Fitting a PSF After selecting your model and parameters, fitting data is easy P = (x=12, y=13, fwhm=13.2, amp=0.1)\npsf = gaussian.(CartesianIndicies(1:25, 1:15); P...)\n\nparams, synthpsf = PSFModels.fit(gaussian, P, psf) here  params  is a named tuple of the best fitting parameters. It will not include any fixed parameters. synthpsf  is the best-fitting model, for direct comparison with the input data. psf_fit = synthpsf.(CartesianIndicies(psf)) To alter parameters without fitting them (i.e., \"freeze\" them) use  func_kwargs P = (x=12, y=13, fwhm=(12.4, 13.2), amp=0.1)\nfunc_kwargs = (alpha=2)\nparams, synthpsf = PSFModels.fit(moffat, P, psf; func_kwargs) source"},{"id":775,"pagetitle":"Benchmarks","title":"Benchmarks","ref":"/previews/PR43/PSFModels/stable/bench/#Benchmarks","content":" Benchmarks The benchmarks can be found in the  bench/  folder. To run them, first instantiate the environment $ julia --project=bench -e \"using Pkg; Pkg.instantiate()\" then execute the  bench/bench.jl  file $ julia --project=bench bench/bench.jl System Information Julia Version 1.10.4\nCommit 48d4fd48430 (2024-06-04 10:41 UTC)\nBuild Info:\n  Official https://julialang.org/ release\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 16 × 13th Gen Intel(R) Core(TM) i5-1340P\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-15.0.7 (ORCJIT, goldmont)\nThreads: 1 default, 0 interactive, 1 GC (on 16 virtual cores)"},{"id":776,"pagetitle":"Benchmarks","title":"Evaluation benchmark","ref":"/previews/PR43/PSFModels/stable/bench/#Evaluation-benchmark","content":" Evaluation benchmark This benchmark tests how long it takes to evaluate a single point in the PSF model. This may seem contrived, but we expect performance to scale directly from this measure: if it takes 1 microsecond to evaluate a single point, it should take ~1 second to evaluate a 1000×1000 image, with speedups potentially from multithreading or SIMD loop evaluation. table = CSV.read(benchdir(\"evaluation_results.csv\"), DataFrame) 3×3 DataFrame\n Row │ name      psfmodels   astropy\n     │ String15  Float64     Float64\n─────┼─────────────────────────────────\n   1 │ Gaussian  2.33112e-8  7.1579e-5\n   2 │ AiryDisk  1.9672e-8   5.7172e-5\n   3 │ Moffat    2.33253e-8  5.3287e-5 @df table groupedbar(\n    :name, [:psfmodels :astropy];\n    ylabel=\"time (s)\", yscale=:log10, legend=:outertopright,\n    label=[\"PSFModels.jl\" \"Astropy\"], size=(500, 300),\n)"},{"id":777,"pagetitle":"Benchmarks","title":"Fitting benchmark","ref":"/previews/PR43/PSFModels/stable/bench/#Fitting-benchmark","content":" Fitting benchmark This benchmark tests how long it takes to fit a PSF Model to a stamp with size (39, 39). In all cases, we use equivalently complex models, the default fitters for PSFModels.jl, and the default  LevMarLSQFit  fitter for astropy. table = CSV.read(benchdir(\"fitting_results.csv\"), DataFrame) 3×3 DataFrame\n Row │ name      psfmodels   astropy\n     │ String15  Float64     Float64\n─────┼──────────────────────────────────\n   1 │ Gaussian  0.00349649  0.00731791\n   2 │ AiryDisk  0.00849787  0.00952454\n   3 │ Moffat    0.00393968  0.00754826 @df table groupedbar(\n    :name, [:psfmodels :astropy];\n    ylabel=\"time (s)\", yscale=:log10, legend=:outertopright,\n    label=[\"PSFModels.jl\" \"Astropy\"], size=(500, 300),\n)"},{"id":780,"pagetitle":"Examples","title":"Examples","ref":"/previews/PR43/PSFModels/stable/examples/#Examples","content":" Examples"},{"id":781,"pagetitle":"Examples","title":"Fitting a PSF","ref":"/previews/PR43/PSFModels/stable/examples/#Fitting-a-PSF","content":" Fitting a PSF Here is a brief example which shows how to construct a loss function for fitting a  PSFModel  to some data. using PSFModels\nusing PSFModels: fit\nusing HCIDatasets: BetaPictoris\nusing Plots\nusing Statistics\n\n# convenience function for plotting\nfunction imshow(data; kwargs...)\n    xlim = extrema(axes(data, 1))\n    ylim = extrema(axes(data, 2))\n    heatmap(transpose(data); xlim=xlim, ylim=ylim,\n            aspect_ratio=1, clims=(1e-5, Inf), kwargs...)\nend\n\n# get a PSF from HCIDatasets.jl;\n# you may be prompted to download the file\npsf = BetaPictoris[:psf]\ninds = CartesianIndices(psf)\n\nimshow(psf) We can fit this data with a variety of models, here showcasing the flexible  PSFModels.fit  function."},{"id":782,"pagetitle":"Examples","title":"Gaussian","ref":"/previews/PR43/PSFModels/stable/examples/#Gaussian","content":" Gaussian Using  gaussian params = (x=20, y=20, fwhm=5, amp=0.1)\nP_gauss, mod_gauss = fit(gaussian, params, psf)\npairs(P_gauss) pairs(::NamedTuple) with 4 entries:\n  :x    => 20.0191\n  :y    => 20.01\n  :fwhm => 4.80293\n  :amp  => 0.100216 plot(\n    imshow(psf, title=\"Data\"),\n    imshow(mod_gauss.(inds), title=\"Model\"),\n    cbar=false,\n    ticks=false,\n    layout=2,\n    size=(600, 300)\n) and now using a rotated, elliptical Gaussian params = (x=20, y=20, fwhm=(5, 5), amp=0.1, theta=0)\nP_ellip, mod_ellip = fit(gaussian, params, psf)\npairs(P_ellip) pairs(::NamedTuple) with 5 entries:\n  :x     => 20.0183\n  :y     => 20.01\n  :fwhm  => (4.76706, 4.83663)\n  :amp   => 0.100243\n  :theta => 0.0 plot(\n    imshow(psf, title=\"Data\"),\n    imshow(mod_ellip.(inds), title=\"Model\"),\n    cbar=false,\n    ticks=false,\n    layout=2,\n    size=(600, 300)\n)"},{"id":783,"pagetitle":"Examples","title":"Airy disk","ref":"/previews/PR43/PSFModels/stable/examples/#Airy-disk","content":" Airy disk Now with  airydisk params = (x=20, y=20, fwhm=5, amp=0.1, ratio=0.3)\nP_airy, mod_airy = fit(airydisk, params, psf)\npairs(P_airy) pairs(::NamedTuple) with 5 entries:\n  :x     => 19.9891\n  :y     => 20.0062\n  :fwhm  => 5.05739\n  :amp   => 0.139425\n  :ratio => 0.375189 plot(\n    imshow(psf, title=\"Data\"),\n    imshow(mod_airy.(inds), title=\"Model\"),\n    cbar=false,\n    ticks=false,\n    layout=2,\n    size=(600, 300)\n)"},{"id":784,"pagetitle":"Examples","title":"Moffat","ref":"/previews/PR43/PSFModels/stable/examples/#Moffat","content":" Moffat And finally, with  moffat params = (x=20, y=20, fwhm=(5, 5), amp=0.1, theta=0, alpha=2)\nP_moff, mod_moff = fit(moffat, params, psf)\npairs(P_moff) pairs(::NamedTuple) with 6 entries:\n  :x     => 20.0366\n  :y     => 20.0154\n  :fwhm  => (3.95567, 3.78329)\n  :amp   => 0.11638\n  :theta => 42.3939\n  :alpha => 1.46268 plot(\n    imshow(psf, title=\"Data\"),\n    imshow(mod_moff.(inds), title=\"Model\"),\n    cbar=false,\n    ticks=false,\n    layout=2,\n    size=(600, 300)\n)"},{"id":785,"pagetitle":"Examples","title":"Changing optimization parameters","ref":"/previews/PR43/PSFModels/stable/examples/#Changing-optimization-parameters","content":" Changing optimization parameters Any keyword arguments get passed on to  Optim.optimize , and you can change the algorithm used with the  alg  keyword # load Optim.jl to use the Newton method\nusing Optim\n\nparams = (x=20, y=20, fwhm=(5, 5), amp=0.1, theta=0, alpha=2)\nP_moff, mod_moff = fit(moffat, params, psf; alg=Newton())\npairs(P_moff) pairs(::NamedTuple) with 6 entries:\n  :x     => 20.0359\n  :y     => 20.0151\n  :fwhm  => (3.87008, 3.8665)\n  :amp   => 0.116352\n  :theta => 0.0\n  :alpha => 1.46154 We can also \"freeze\" parameters by creating a named tuple and passing it to  func_kwargs params = (;x=10, y=20, fwhm=(5, 5), amp=0.1)\nfunc_kwargs = (;alpha=2)\nP_moff2, mod_moff2 = fit(moffat, params, psf; func_kwargs)\npairs(P_moff2) pairs(::NamedTuple) with 4 entries:\n  :x    => 20.0349\n  :y    => 20.0144\n  :fwhm => (4.19137, 4.19478)\n  :amp  => 0.110515 plot(\n    imshow(psf, title=\"Data\"),\n    imshow(mod_moff2.(inds), title=\"Model\"),\n    cbar=false,\n    ticks=false,\n    layout=2,\n    size=(600, 300)\n)"},{"id":788,"pagetitle":"Introduction","title":"Introduction","ref":"/previews/PR43/PSFModels/stable/introduction/#Introduction","content":" Introduction Statistical models for constructing point-spread functions (PSFs)."},{"id":789,"pagetitle":"Introduction","title":"Models","ref":"/previews/PR43/PSFModels/stable/introduction/#Models","content":" Models The following models are currently implemented gaussian / normal airydisk moffat"},{"id":790,"pagetitle":"Introduction","title":"Parameters","ref":"/previews/PR43/PSFModels/stable/introduction/#Parameters","content":" Parameters In general, the PSFs have a position, a full-width at half-maximum (FWHM) measure, and an amplitude. The position follows a 1-based pixel coordinate system, where  (1, 1)  represents the  center  of the bottom left pixel. This matches the indexing style of Julia as well as DS9, IRAF, SourceExtractor, and WCS. The FWHM is a consistent scale parameter for the models. That means a  gaussian  with a FWHM of 5 will be visually similar to an  airydisk  with a FWHM of 5. All models support a scalar (isotropic) FWHM and a FWHM for each axis (diagonal), as well as arbitrarily rotating the PSF. Pixel-convention The pixel convention adopted here is that the bottom-left pixel  center  is  (1, 1) . The column-major memory layout of julia puts the  x  axis as the rows of a matrix and the  y  axis as the columns. In other words, the axes unpack like xs, ys = axes(image)"},{"id":791,"pagetitle":"Introduction","title":"Usage","ref":"/previews/PR43/PSFModels/stable/introduction/#Usage","content":" Usage"},{"id":792,"pagetitle":"Introduction","title":"Evaluating models","ref":"/previews/PR43/PSFModels/stable/introduction/#Evaluating-models","content":" Evaluating models Directly evaluating the functions is the most straightforward way to use this package julia> gaussian(0, 0; x=0, y=0, fwhm=3)\n1.0\n\njulia> gaussian(BigFloat, 0, 0; x=0, y=0, fwhm=3, amp=0.1, bkg=1)\n1.100000000000000088817841970012523233890533447265625 We also provide \"curried\" versions of the functions, which allow you to specify the parameters and evaluate the PSF later julia> model = gaussian(x=0, y=0, fwhm=3);\n\njulia> model(0, 0)\n1.0 If we want to collect the model into a dense matrix, simply iterate over indices julia> inds = CartesianIndices((-2:2, -2:2));\n\njulia> model.(inds) # broadcasting\n5×5 Matrix{Float64}:\n 0.0850494  0.214311  0.291632  0.214311  0.0850494\n 0.214311   0.54003   0.734867  0.54003   0.214311\n 0.291632   0.734867  1.0       0.734867  0.291632\n 0.214311   0.54003   0.734867  0.54003   0.214311\n 0.0850494  0.214311  0.291632  0.214311  0.0850494 This makes it very easy to evaluate the PSF on the same axes as an image (array) julia> img = randn(5, 5);\n\njulia> model.(CartesianIndices(img))\n5×5 Matrix{Float64}:\n 0.54003      0.214311     0.0459292    0.00531559   0.000332224\n 0.214311     0.0850494    0.018227     0.00210949   0.000131843\n 0.0459292    0.018227     0.00390625   0.000452087  2.82555e-5\n 0.00531559   0.00210949   0.000452087  5.2322e-5    3.27013e-6\n 0.000332224  0.000131843  2.82555e-5   3.27013e-6   2.04383e-7 this is trivially expanded to fit \"stamps\" in images julia> big_img = randn(1000, 1000);\n\njulia> stamp_inds = (750:830, 400:485);\n\njulia> stamp = @view big_img[stamp_inds...];\n\njulia> stamp_model = model.(CartesianIndices(stamp_inds)); or we can create a loss function for fitting PSFs without allocating any memory. We are simply iterating over the image array! julia> using Statistics\n\njulia> mse = mean(I -> (big_img[I] - model(I))^2, CartesianIndices(stamp_inds));"},{"id":793,"pagetitle":"Introduction","title":"Fitting data","ref":"/previews/PR43/PSFModels/stable/introduction/#Fitting-data","content":" Fitting data There exists a simple, yet powerful, API for fitting data with  PSFModels.fit . # `fit` is not exported to avoid namespace clashes\nusing PSFModels: fit\n\ndata = # load data\nstamp_inds = # optionally choose indices to \"cutout\"\n\n# use an isotropic Gaussian\nparams, synthpsf = fit(gaussian, (x=12, y=13, fwhm=3.2, amp=0.1),\n                       data, stamp_inds)\n\n# elliptical, rotated Gaussian\nparams, synthpsf = fit(gaussian, (x=12, y=13, fwhm=(3.2, 3.2), amp=0.1, theta=0)\n                       data, stamp_inds)\n\n# obscured Airy disk\nparams, synthpsf = fit(airydisk, (x=12, y=13, fwhm=3.2, amp=0.1, ratio=0.3),\n                       data, stamp_inds)\n\n# bivariate Moffat with arbitrary alpha\nparams, synthpsf = fit(moffat, (x=12, y=13, fwhm=(3.2, 3.2), amp=0.1, alpha=1),\n                       data, stamp_inds)"},{"id":794,"pagetitle":"Introduction","title":"Plotting","ref":"/previews/PR43/PSFModels/stable/introduction/#Plotting","content":" Plotting Finally, we provide plotting recipes ( psfplot / psfplot! ) from  RecipesBase.jl , which can be seen in use in the  API/Reference  section. using PSFModels # hide\nusing Plots\n\nmodel = gaussian(x=0, y=0, fwhm=(8, 10), theta=12)\npsfplot(model, -30:30, -30:30, colorbar_scale=:log10)"},{"id":797,"pagetitle":"Home","title":"LACosmic.jl","ref":"/previews/PR43/LACosmic/stable/#LACosmic.jl","content":" LACosmic.jl Laplacian cosmic-ray detection (L.A.Cosmic) in pure Julia."},{"id":798,"pagetitle":"Home","title":"Installation","ref":"/previews/PR43/LACosmic/stable/#Installation","content":" Installation To use the LACosmic library, first install it using  Pkg julia> ]add LACosmic"},{"id":799,"pagetitle":"Home","title":"Usage","ref":"/previews/PR43/LACosmic/stable/#Usage","content":" Usage To import the library using LACosmic there is one exported function:  lacosmic clean_image, mask = lacosmic(image)"},{"id":800,"pagetitle":"Home","title":"Contributing and Support","ref":"/previews/PR43/LACosmic/stable/#Contributing-and-Support","content":" Contributing and Support If you would like to contribute, feel free to open a  pull request . If you want to discuss something before contributing, head over to  discussions  and join or open a new topic. If you're having problems with something, please open an  issue ."},{"id":803,"pagetitle":"API/Reference","title":"API/Reference","ref":"/previews/PR43/LACosmic/stable/api/#API/Reference","content":" API/Reference LACosmic.lacosmic LACosmic.subsample"},{"id":804,"pagetitle":"API/Reference","title":"LACosmic.lacosmic","ref":"/previews/PR43/LACosmic/stable/api/#LACosmic.lacosmic-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","content":" LACosmic.lacosmic  —  Method lacosmic(data::AbstractMatrix; \n    noise=nothing,\n    gain=1,\n    background=0,\n    readnoise=0,\n    mask=falses(size(data)),\n    sigma_clip=4.5,\n    contrast=5,\n    neighbor_thresh=0.3,\n    maxiter=4,\n    saturation_level=2^16,\n    block_size=2) Laplacian cosmic ray detection (LACosmic). This algorithm implements the algorithm presented in  lacosmicx . The return values are the cleaned image and the bad pixel mask. The image cleaning is done via median interpolation. Parameters noise  is the pre-determined estimate of the data noise (square root of variance), if any gain  is the image gain in electrons per data number background  is pre-determined image background, if any readnoise  is the read noise of the image in electrons mask  is an input bad pixel mask, where  true  represents a bad pixel sigma_clip  is the Laplacian signal-to-noise ratio for flagging bad pixels contrast  is the minimum contrast required to flag a bad pixel in the ratio of the Laplacian image to the fine-structure image neighbor_thresh  is the fractional detection limit for cosmic rays surrounding other cosmic rays. Should be a number between 0 and 1. maxiter  is the maximum number of iterations used for detecting bad pixels saturation_level  is the saturation value in electrons block_size  is the subsampling factor for the Laplacian filter image. Examples julia> image = 100 .* randn(1001, 1001) .+ 1000;\n\njulia> clean_image, mask = lacosmic(image, gain=4); References van Dokkum, P.G. (2001)  - \"Cosmic-Ray Rejection by Laplacian Edge Detection\" source"},{"id":805,"pagetitle":"API/Reference","title":"LACosmic.subsample","ref":"/previews/PR43/LACosmic/stable/api/#LACosmic.subsample","content":" LACosmic.subsample  —  Function LACosmic.subsample(array, block_size=2) Subsample  array  by the given factor without copying or allocating. This effectively treats each pixel as  block_size  x  block_size  pixels. The value of each pixel is not normalized or averaged. This is a view into the parent array, and if the data was changed this view would change subsequently. Examples julia> arr = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> sub = LACosmic.subsample(arr)\n4×4 LACosmic.SubsampledArray{Int64, 2, Matrix{Int64}}:\n 1  1  2  2\n 1  1  2  2\n 3  3  4  4\n 3  3  4  4\n\njulia> all(sub[1:2, 1:2] .=== arr[1, 1])\ntrue\n\njulia> sub[3, 3] = 5;\n\njulia> sub\n4×4 LACosmic.SubsampledArray{Int64, 2, Matrix{Int64}}:\n 1  1  2  2\n 1  1  2  2\n 3  3  5  5\n 3  3  5  5 source"},{"id":808,"pagetitle":"Examples","title":"Examples","ref":"/previews/PR43/LACosmic/stable/examples/#Examples","content":" Examples"},{"id":809,"pagetitle":"Examples","title":"Setup","ref":"/previews/PR43/LACosmic/stable/examples/#Setup","content":" Setup You will need the following packages installed to replicate this tutorial julia> ]add Distributions LACosmic Plots PSFModels"},{"id":810,"pagetitle":"Examples","title":"Removing bad pixels with LACosmic.jl","ref":"/previews/PR43/LACosmic/stable/examples/#Removing-bad-pixels-with-LACosmic.jl","content":" Removing bad pixels with LACosmic.jl First, let's create some fake data with Gaussian sources using Distributions\nusing PSFModels: Gaussian\nusing Random\n\nfunction make_data(rng, N; N_sources=20, N_cosmics=20)\n    imdata = fill(200.0, (N, N))\n\n    # Add some fake sources\n    for _ in 1:N_sources\n        x = rand(rng, Uniform(1, N + 1))\n        y = rand(rng, Uniform(1, N + 1))\n        brightness = rand(rng, Uniform(1000, 30000)) / (2π * 3.5^2)\n\t\tmodel = Gaussian(;x, y, fwhm=3.5, amp=brightness)\n        imdata .+= model[axes(imdata)...]\n\tend\n\n    # Add the poisson noise\n    imdata .= rand.(rng, Poisson.(imdata))\n\n    # Add readnoise\n    imdata .+= rand(rng, Normal(0, 10), (N, N))\n\n    clean_image = copy(imdata)\n\n    # Add Nc fake cosmic rays\n    crmask = falses((N, N))\n\tfor i in 1:N_cosmics\n    \tcr_x = round(Int, rand(rng, Uniform(6, N - 5)))\n    \tcr_y = round(Int, rand(rng, Uniform(6, N - 5)))\n    \tcr_brightnesses = rand(rng, Uniform(1000, 30000))\n    \timdata[cr_y, cr_x] += cr_brightnesses\n    \tcrmask[cr_y, cr_x] = true\n\tend\n\n    # Make a mask where the detected cosmic rays should be\n    return (image=imdata, clean_image, mask=crmask)\nend\n\nrng = MersenneTwister(808)\ndata = make_data(rng, 201) (image = [188.58170768150052 214.09362006840362 … 204.15202016042792 174.58109503250085; 202.09914267128877 183.6972497338309 … 203.6666879254898 204.72346481491394; … ; 193.09513217045617 166.82428246193842 … 163.70511533689998 183.12325388575027; 228.6225661704681 189.5528435387213 … 202.46161451180063 199.53550046618867], clean_image = [188.58170768150052 214.09362006840362 … 204.15202016042792 174.58109503250085; 202.09914267128877 183.6972497338309 … 203.6666879254898 204.72346481491394; … ; 193.09513217045617 166.82428246193842 … 163.70511533689998 183.12325388575027; 228.6225661704681 189.5528435387213 … 202.46161451180063 199.53550046618867], mask = Bool[0 0 … 0 0; 0 0 … 0 0; … ; 0 0 … 0 0; 0 0 … 0 0]) let's inspect it using Plots\n\nfunction imshow(image; kwargs...)\n\taxy, axx = axes(image)\n\theatmap(axy, axx, image;\n        aspect_ratio=1,\n        ticks=false,\n        xlim=extrema(axx),\n        ylim=extrema(axy),\n        kwargs...)\nend\n\nplot(\n    imshow(log10.(data.clean_image), title=\"original image\"),\n    imshow(log10.(data.image), title=\"image w/cosmics\"),\n    size=(775, 350)\n) now we can clean it using  lacosmic using LACosmic\n\nclean_image, mask = lacosmic(data.image, sigma_clip=6, contrast=5, neighbor_thresh=1)\n\nplot(\n    imshow(log10.(data.clean_image), title=\"original image\"),\n    imshow(log10.(clean_image), title=\"cleaned image\"),\n    size=(775, 350)\n) plot(\n    imshow(data.mask, title=\"true cosmics\", cbar=false),\n    imshow(mask, title=\"detected cosmics\", cbar=false),\n    size=(700, 400)\n) data.mask == mask true"},{"id":815,"pagetitle":"Home","title":"Home","ref":"/previews/PR43/AstroImages/stable/#Home","content":" Home GitHub link AstroImage.jl  allows you to plot images from an astronomical  FITS  file using the popular  Images.jl  and  Plots.jl  Julia packages.  AstroImage.jl  uses  FITSIO.jl  to read FITS files."},{"id":818,"pagetitle":"API","title":"API Documentation","ref":"/previews/PR43/AstroImages/stable/api/#API-Documentation","content":" API Documentation"},{"id":819,"pagetitle":"API","title":"FileIO.load","ref":"/previews/PR43/AstroImages/stable/api/#FileIO.load","content":" FileIO.load  —  Function load(filename)  loads the contents of a formatted file, trying to infer the format from  filename  and/or magic bytes in the file (see  query ). load(strm)  loads from an  IOStream  or similar object. In this case, there is no filename extension, so we rely on the magic bytes for format identification. load(File{format\"PNG\"}(filename))  specifies the format directly, and bypasses the format  query . load(Stream{format\"PNG\"}(io))  specifies the format directly, and bypasses the format  query . load(f; options...)  passes keyword arguments on to the loader."},{"id":820,"pagetitle":"API","title":"FileIO.save","ref":"/previews/PR43/AstroImages/stable/api/#FileIO.save","content":" FileIO.save  —  Function save(filename, data...)  saves the contents of a formatted file, trying to infer the format from  filename . save(Stream{format\"PNG\"}(io), data...)  specifies the format directly, and bypasses the format  query . save(File{format\"PNG\"}(filename), data...)  specifies the format directly, and bypasses the format  query . save(f, data...; options...)  passes keyword arguments on to the saver."},{"id":821,"pagetitle":"API","title":"AstroImages.AstroImage","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.AstroImage","content":" AstroImages.AstroImage  —  Type Provides access to a FITS image along with its accompanying  header and WCS information, if applicable. source"},{"id":822,"pagetitle":"API","title":"AstroImages.imview","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.imview","content":" AstroImages.imview  —  Function imview(img; clims=Percent(99.5), stretch=identity, cmap=:magma, contrast=1.0, bias=0.5) Create a read only view of an array or AstroImageMat mapping its data values to Colors according to  clims ,  stretch , and  cmap . The data is first clamped to  clims , which can either be a tuple of (min, max) values or a function accepting an iterator of pixel values that returns (min, max). By default,  clims=extrema  i.e. the minimum and maximum of  img . Convenient functions to use for  clims  are:  extrema ,  zscale , and  percent(p) Next, the data is rescaled to [0,1] and remapped according to the function  stretch . Stretch can be any monotonic fuction mapping values in the range [0,1] to some range [a,b]. Note that  log(0)  is not defined so is not directly supported. For a list of convenient stretch functions, see:  logstretch ,  powstretch ,  squarestretch ,  asinhstretch ,  sinhstretch ,  powerdiststretch Finally the data is mapped to RGB values according to  cmap . If cmap is  nothing , grayscale is used. ColorSchemes.jl defines hundreds of colormaps. A few nice ones for images include:  :viridis ,  :magma ,  :plasma ,  :thermal , and  :turbo . Crucially, this function returns a view over the underlying data. If  img  is updated then those changes will be reflected by this view with the exception of  clims  which is not recalculated. Note: if clims or stretch is a function, the pixel values passed in are first filtered to remove non-finite or missing values. Defaults The default values of  clims ,  stretch , and  cmap  are  extrema ,  identity , and  nothing  respectively. You may alter these defaults using  AstroImages.set_clims! ,   AstroImages.set_stretch! , and  AstroImages.set_cmap! . Automatic Display Arrays wrapped by  AstroImageMat()  get displayed as images automatically by calling   imview  on them with the default settings when using displays that support showing PNG images. Missing data Pixels that are  NaN  or  missing  will be displayed as transparent when  cmap  is set or black if. +/- Inf will be displayed as black or white respectively. Exporting Images The view returned by  imview  can be saved using general  FileIO.save  methods. Example: v = imview(data, cmap=:magma, stretch=asinhstretch, clims=percent(95))\nsave(\"output.png\", v) source imview(img::AbstractArray{<:Complex}; ...) When applied to an image with complex values, display the magnitude of the pixels using  imview  and display the phase angle as a panel below using a cyclical color map. For more customatization, you can create a view like this yourself: vcat(\n    imview(abs.(img)),\n    imview(angle.(img)),\n) source"},{"id":823,"pagetitle":"API","title":"AstroImages.implot","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.implot","content":" AstroImages.implot  —  Function implot(\n    img::AbstractArray;\n    clims=Percent(99.5),\n    stretch=identity,\n    cmap=:magma,\n    bias=0.5,\n    contrast=1,\n    wcsticks=true,\n    grid=true,\n    platescale=1\n) Create a read only view of an array or AstroImageMat mapping its data values to an array of Colors. Equivalent to: implot(\n    imview(\n        img::AbstractArray;\n        clims=Percent(99.5),\n        stretch=identity,\n        cmap=:magma,\n        bias=0.5,\n        contrast=1,\n    ),\n    wcsn=1,\n    wcsticks=true,\n    wcstitle=true,\n    grid=true,\n    platescale=1\n) Image Rendering See  imview  for how data is mapped to RGBA pixel values. WCS & Image Coordinates If provided with an AstroImage that has WCS headers set, the tick marks and plot grid are calculated using WCS.jl. By default, use the first WCS coordinate system. The underlying pixel coordinates are those returned by  dims(img)  multiplied by  platescale . This allows you to overplot lines, regions, etc. using pixel coordinates. If you wish to compute the pixel coordinate of a point in world coordinates, see  world_to_pix . wcsn  (default  1 ) select which WCS transform in the headers to use for ticks & grid wcsticks  (default  true  if WCS headers present) display ticks and labels, and title using world coordinates wcstitle  (default  true  if WCS headers present and  length(refdims(img))>0 ). When slicing a cube, display the location along unseen axes in world coordinates instead of pixel coordinates. grid  (default  true ) show a grid over the plot. Uses WCS coordinates if  wcsticks  is true, otherwise pixel coordinates multiplied by  platescale . platescale  (default  1 ). Scales the underlying pixel coordinates to ease overplotting, etc. If  wcsticks  is false, the displayed pixel coordinates are also scaled. Defaults The default values of  clims ,  stretch , and  cmap  are  extrema ,  identity , and  nothing  respectively. You may alter these defaults using  AstroImages.set_clims! ,   AstroImages.set_stretch! , and  AstroImages.set_cmap! . source"},{"id":824,"pagetitle":"API","title":"DimensionalData.Dimensions.dims","ref":"/previews/PR43/AstroImages/stable/api/#DimensionalData.Dimensions.dims","content":" DimensionalData.Dimensions.dims  —  Function dims(x, [dims::Tuple]) => Tuple{Vararg{<:Dimension}}\ndims(x, dim) => Dimension Return a tuple of  Dimension s for an object, in the order that matches the axes or columns of the underlying data. dims  can be  Dimension ,  Dimension  types, or  Symbols  for  Dim{Symbol} . The default is to return  nothing ."},{"id":825,"pagetitle":"API","title":"DimensionalData.Dimensions.refdims","ref":"/previews/PR43/AstroImages/stable/api/#DimensionalData.Dimensions.refdims","content":" DimensionalData.Dimensions.refdims  —  Function refdims(x, [dims::Tuple]) => Tuple{Vararg{<:Dimension}}\nrefdims(x, dim) => Dimension Reference dimensions for an array that is a slice or view of another array with more dimensions. slicedims(a, dims)  returns a tuple containing the current new dimensions and the new reference dimensions. Refdims can be stored in a field or disgarded, as it is mostly to give context to plots. Ignoring refdims will simply leave some captions empty. The default is to return an empty  Tuple () ."},{"id":826,"pagetitle":"API","title":"AstroImages.Comment","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.Comment","content":" AstroImages.Comment  —  Type Index for accessing a comment associated with a header keyword or COMMENT entry. Example: img = AstroImage(randn(10,10))\nimg[\"ABC\"] = 1\nimg[\"ABC\", Comment] = \"A comment describing this key\"\n\npush!(img, Comment, \"The purpose of this file is to demonstrate comments\")\nimg[Comment] # [\"The purpose of this file is to demonstrate comments\")] source"},{"id":827,"pagetitle":"API","title":"AstroImages.History","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.History","content":" AstroImages.History  —  Type Allows accessing and setting HISTORY header entries img = AstroImage(randn(10,10)) push!(img, History, \"2023-04-19: Added history entry.\") img[History] # [\"2023-04-19: Added history entry.\"] source"},{"id":828,"pagetitle":"API","title":"WCS.pix_to_world","ref":"/previews/PR43/AstroImages/stable/api/#WCS.pix_to_world","content":" WCS.pix_to_world  —  Function pix_to_world(wcs, pixcoords) Convert the array of pixel coordinates  pixcoords  to world coordinates according to the WCSTransform  wcs .  pixcoords  should be a 2-d array where \"pixcoords[:, i]\" is the i-th set of coordinates, or a 1-d array representing a single set of coordinates. The return value is the same shape as  pixcoords . pix_to_world(img::AstroImage, pixcoords; all=false) Given an astro image, look up the world coordinates of the pixels given  by  pixcoords . World coordinates are resolved using WCS.jl and a WCSTransform calculated from any FITS header present in  img . If no WCS information is in the header, or the axes are all linear, this will just return pixel coordinates. pixcoords  should be the coordinates in your current selection of the image. For example, if you select a slice like this: julia> cube = load(\"some-3d-cube.fits\")\njulia> slice = cube[10:20, 30:40, 5] Then to look up the coordinates of the pixel in the bottom left corner of  slice , run: julia> world_coords = pix_to_world(img, [1, 1])\n[10, 30] If WCS information was present in the header of  cube , then those coordinates would be resolved using axis 1, 2, and 3 respectively. To include world coordinates in all axes, pass  all=true julia> world_coords = pix_to_world(img, [1, 1], all=true)\n[10, 30, 5] !! Coordinates must be provided in the order of  dims(img) . If you transpose  an image, the order you pass the coordinates should not change. source"},{"id":829,"pagetitle":"API","title":"WCS.world_to_pix","ref":"/previews/PR43/AstroImages/stable/api/#WCS.world_to_pix","content":" WCS.world_to_pix  —  Function world_to_pix(wcs, worldcoords) Convert the array of world coordinates  worldcoords  to pixel coordinates according to the WCSTransform  wcs .  worldcoords  is a 2-d array where \"worldcoords[:, i]\" is the i-th set of coordinates, or a 1-d array representing a single set of coordinates. The return value is the same size as  worldcoords ."},{"id":830,"pagetitle":"API","title":"DimensionalData.Dimensions.X","ref":"/previews/PR43/AstroImages/stable/api/#DimensionalData.Dimensions.X","content":" DimensionalData.Dimensions.X  —  Type X <: XDim\n\nX(val=:) X  Dimension .  X <: XDim <: IndependentDim Example: xdim = X(2:2:10)\n# Or\nval = A[X(1)]\n# Or\nmean(A; dims=X)"},{"id":831,"pagetitle":"API","title":"DimensionalData.Dimensions.Y","ref":"/previews/PR43/AstroImages/stable/api/#DimensionalData.Dimensions.Y","content":" DimensionalData.Dimensions.Y  —  Type Y <: YDim\n\nY(val=:) Y  Dimension .  Y <: YDim <: DependentDim Example: ydim = Y(['a', 'b', 'c'])\n# Or\nval = A[Y(1)]\n# Or\nmean(A; dims=Y)"},{"id":832,"pagetitle":"API","title":"DimensionalData.Dimensions.Z","ref":"/previews/PR43/AstroImages/stable/api/#DimensionalData.Dimensions.Z","content":" DimensionalData.Dimensions.Z  —  Type Z <: ZDim\n\nZ(val=:) Z  Dimension .  Z <: ZDim <: Dimension Example: zdim = Z(10:10:100)\n# Or\nval = A[Z(1)]\n# Or\nmean(A; dims=Z)"},{"id":833,"pagetitle":"API","title":"DimensionalData.Dimensions.Dim","ref":"/previews/PR43/AstroImages/stable/api/#DimensionalData.Dimensions.Dim","content":" DimensionalData.Dimensions.Dim  —  Type Dim{S}(val=:) A generic dimension. For use when custom dims are required when loading data from a file. Can be used as keyword arguments for indexing. Dimension types take precedence over same named  Dim  types when indexing with symbols, or e.g. creating Tables.jl keys. using DimensionalData\n\ndim = Dim{:custom}(['a', 'b', 'c'])\n\n# output\n\nDim{:custom} Char[a, b, c]"},{"id":834,"pagetitle":"API","title":"DimensionalData.Dimensions.LookupArrays.At","ref":"/previews/PR43/AstroImages/stable/api/#DimensionalData.Dimensions.LookupArrays.At","content":" DimensionalData.Dimensions.LookupArrays.At  —  Type At <: Selector\n\nAt(x, atol, rtol)\nAt(x; atol=nothing, rtol=nothing) Selector that exactly matches the value on the passed-in dimensions, or throws an error. For ranges and arrays, every intermediate value must match an existing value - not just the end points. x  can be any value or  Vector  of values. atol  and  rtol  are passed to  isapprox . For  Number rtol  will be set to  Base.rtoldefault , otherwise  nothing , and wont be used. Example using DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))\nA[X(At(20)), Y(At(6))]\n\n# output\n\n5"},{"id":835,"pagetitle":"API","title":"DimensionalData.Dimensions.LookupArrays.Near","ref":"/previews/PR43/AstroImages/stable/api/#DimensionalData.Dimensions.LookupArrays.Near","content":" DimensionalData.Dimensions.LookupArrays.Near  —  Type Near <: Selector\n\nNear(x) Selector that selects the nearest index to  x . With  Points  this is simply the index values nearest to the  x , however with  Intervals  it is the interval  center  nearest to  x . This will be offset from the index value for  Start  and  End  loci. Example using DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))\nA[X(Near(23)), Y(Near(5.1))]\n\n# output\n4"},{"id":836,"pagetitle":"API","title":"AstroImages.header","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.header","content":" AstroImages.header  —  Function header(img::AstroImage) Return the underlying FITSIO.FITSHeader object wrapped by an AstroImage. Note that this object has less flexible getindex and setindex methods. Indexing by symbol, Comment, History, etc are not supported. source header(array::AbstractArray) Returns an empty FITSIO.FITSHeader object when called with a non-AstroImage abstract array. source"},{"id":837,"pagetitle":"API","title":"AstroImages.wcs","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.wcs","content":" AstroImages.wcs  —  Function wcs(img) Computes and returns a list of World Coordinate System WCSTransform objects from WCS.jl. The resultss are cached after the first call, so subsequent calls are fast. Modifying a WCS header invalidates this cache automatically, so users should call  wcs(...)  each time rather than keeping the WCSTransform object around. source wcs(img, index) Computes and returns a World Coordinate System WCSTransform objects from WCS.jl by index. This is to support files with multiple WCS transforms specified.  wcs(img,1)  is useful for selecting selecting the first WCSTranform object. The resultss are cached after the first call, so subsequent calls are fast. Modifying a WCS header invalidates this cache automatically, so users should call  wcs(...)  each time rather than keeping the WCSTransform object around. source wcs(array) Returns a list with a single basic WCSTransform object when called with a non-AstroImage abstract array. source"},{"id":838,"pagetitle":"API","title":"AstroImages.WCSGrid","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.WCSGrid","content":" AstroImages.WCSGrid  —  Type WCSGrid(img::AstroImageMat, ax=(1,2), coords=(first(axes(img,ax[1])),first(axes(img,ax[2])))) Given an AstroImageMat, return information necessary to plot WCS gridlines in physical coordinates against the image's pixel coordinates. This function has to work on both plotted axes at once to handle rotation and general curvature of the WCS grid projected on the image coordinates. source"},{"id":839,"pagetitle":"API","title":"AstroImages.composecolors","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.composecolors","content":" AstroImages.composecolors  —  Function composecolors(\n    images,\n    cmap=[\"#F00\", \"#0F0\", \"#00F\"];\n    clims,\n    stretch,\n    contrast,\n    bias,\n    multiplier\n) Create a color composite of multiple images by applying  imview  and blending  the results. This function can be used to create RGB composites using any number of channels (e.g. red, green, blue, and hydrogen alpha) as well as more exotic images like blending radio and optical data using two different colormaps. cmap  should be a list of colorants, named colors (see Colors.jl), or colorschemes (see ColorSchemes.jl).  clims ,  stretch ,  contrast , and  bias  are passed on to  imview . They can be a single value or a list of different values for each image. Examples: # Basic RGB\ncomposecolors([redimage, greenimage, blueimage])\n# Non-linear stretch before blending\ncomposecolors([redimage, greenimage, blueimage], stretch=asinhstretch)\n# More than three channels are allowed (H alpha in pink)\ncomposecolors(\n    [antred, antgreen, antblue, anthalp],\n    [\"red\", \"green\", \"blue\", \"maroon1\"],\n    multiplier=[1,2,1,1]\n)\n# Can mix \ncomposecolors([radioimage, xrayimage], [:ice, :magma], clims=extrema)\ncomposecolors([radioimage, xrayimage], [:magma, :viridis], clims=[Percent(99), Zscale()]) source"},{"id":840,"pagetitle":"API","title":"AstroImages.Zscale","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.Zscale","content":" AstroImages.Zscale  —  Type Zscale(options)(data) Wraps PlotUtils.zscale in a callable with default parameters. This is a common algorithm for agressively stretching astronomical data to see faint structure that originated in IRAF: https://iraf.net/forum/viewtopic.php?showtopic=134139 but is now seen in many other applications/libraries (DS9, Astropy, etc.) Usage: imview(img, clims=Zscale())\nimplot(img, clims=Zscale(contrast=0.1)) Default parameters: nsamples::Int=1000\ncontrast::Float64=0.25\nmax_reject::Float64=0.5\nmin_npixels::Float64=5\nk_rej::Float64=2.5\nmax_iterations::Int=5 source"},{"id":841,"pagetitle":"API","title":"AstroImages.Percent","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.Percent","content":" AstroImages.Percent  —  Type Percent(99.5) Returns a callable that calculates display limits that include the given  percent of the image data. Reproduces the behaviour of the SAO DS9 scale menu. Example: julia> imview(img, clims=Percent(90)) This will set the limits to be the 5th percentile to the 95th percentile. source"},{"id":842,"pagetitle":"API","title":"AstroImages.logstretch","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.logstretch","content":" AstroImages.logstretch  —  Function logstretch(num,a=1000) A log-stretch as defined by the SAO DS9 application: http://ds9.si.edu/doc/ref/how.html source"},{"id":843,"pagetitle":"API","title":"AstroImages.powstretch","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.powstretch","content":" AstroImages.powstretch  —  Function powstretch(num, a=1000) A power-stretch as defined by the SAO DS9 application: http://ds9.si.edu/doc/ref/how.html source"},{"id":844,"pagetitle":"API","title":"AstroImages.sqrtstretch","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.sqrtstretch","content":" AstroImages.sqrtstretch  —  Function sqrtstretch(num) A square root stretch (simply defined as Base.sqrt) source"},{"id":845,"pagetitle":"API","title":"AstroImages.squarestretch","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.squarestretch","content":" AstroImages.squarestretch  —  Function squarestretch(num) A squarestretch-stretch as defined by the SAO DS9 application: http://ds9.si.edu/doc/ref/how.html source"},{"id":846,"pagetitle":"API","title":"AstroImages.asinhstretch","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.asinhstretch","content":" AstroImages.asinhstretch  —  Function asinhstretch(num) A hyperbolic arcsin stretch as defined by the SAO DS9 application: http://ds9.si.edu/doc/ref/how.html. source"},{"id":847,"pagetitle":"API","title":"AstroImages.sinhstretch","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.sinhstretch","content":" AstroImages.sinhstretch  —  Function sinhstretch(num) A hyperbolic sin stretch as defined by the SAO DS9 application: http://ds9.si.edu/doc/ref/how.html source"},{"id":848,"pagetitle":"API","title":"AstroImages.powerdiststretch","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.powerdiststretch","content":" AstroImages.powerdiststretch  —  Function logstretch(num,a=1000) A power distance stretch as defined by astropy. source"},{"id":849,"pagetitle":"API","title":"AstroImages.copyheader","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.copyheader","content":" AstroImages.copyheader  —  Function copyheader(img::AstroImage, data) -> imgnew Create a new image copying the header of  img  but using the data of the AbstractArray  data . Note that changing the header of  imgnew  does not affect the header of  img . See also:  shareheader . source"},{"id":850,"pagetitle":"API","title":"AstroImages.shareheader","ref":"/previews/PR43/AstroImages/stable/api/#AstroImages.shareheader","content":" AstroImages.shareheader  —  Function shareheader(img::AstroImage, data) -> imgnew Create a new image reusing the header dictionary of  img  but using the data of the AbstractArray  data . The two images have synchronized header; modifying one also affects the other. See also:  copyheader . source"},{"id":853,"pagetitle":"Contours","title":"Contours","ref":"/previews/PR43/AstroImages/stable/guide/contours/#Contours","content":" Contours This guide shows a few different ways to measure and visualize contours of images."},{"id":854,"pagetitle":"Contours","title":"Using Plots","ref":"/previews/PR43/AstroImages/stable/guide/contours/#Using-Plots","content":" Using Plots The most basic way to create a contour plot is simply to use Plots.jl  contour  and  contourf  functions on your image. Let's see how that works: using AstroImages, Plots\n\n\n# First load a FITS file of interest\nfname = download(\n    \"http://www.astro.uvic.ca/~wthompson/astroimages/fits/herca/herca_radio.fits\",\n    \"herca-radio.fits\"\n)\n\nherca = load(\"herca-radio.fits\") Create a contour plot contour(herca)"},{"id":857,"pagetitle":"Blurring & Filtering Images","title":"Image Filtering","ref":"/previews/PR43/AstroImages/stable/guide/image-filtering/#Image-Filtering","content":" Image Filtering The package  ImageFiltering.jl  makes it easy to apply arbitrary filters to images."},{"id":858,"pagetitle":"Blurring & Filtering Images","title":"Gaussian Blurs","ref":"/previews/PR43/AstroImages/stable/guide/image-filtering/#Gaussian-Blurs","content":" Gaussian Blurs Let's start by downloading a radio image of Hercules A: using AstroImages\nusing ImageFiltering\n\nfname = download(\n    \"http://www.astro.uvic.ca/~wthompson/astroimages/fits/herca/herca_radio.fits\",\n    \"herca-radio.fits\"\n)\n\nherca = load(\"herca-radio.fits\") Let's now apply a Gaussian blur (aka a low pass filter) using the  imfilter  function: herca_blur_20 = imfilter(herca, Kernel.gaussian(20.0)) The image has been smoothed out by convolving it with a wide Gaussian. Let's now do the opposite and perform a high-pass filter. This will bring out faint variations in structure. We can do this by subtracting a blurred image from the original: herca_blur_4 = imfilter(herca, Kernel.gaussian(4.0))\nherca_highpass = herca .- herca_blur_4 We now see lots of faint structure inside the jets! Finally, let's adjust how the image is displayed and apply a non-linear stretch: imview(\n    herca_highpass,\n    cmap=:seaborn_rocket_gradient,\n    clims=(-50,1500),\n    stretch=asinhstretch\n) If you have Plots loaded, we can add a colorbar and coordinate axes by switching to  implot : using Plots\nimplot(\n    herca_highpass,\n    cmap=:seaborn_rocket_gradient,\n    clims=(-50,1500),\n    stretch=asinhstretch\n)"},{"id":859,"pagetitle":"Blurring & Filtering Images","title":"Median Filtering","ref":"/previews/PR43/AstroImages/stable/guide/image-filtering/#Median-Filtering","content":" Median Filtering In addition to linear filters using  imfilter , ImageFiltering.jl also includes a great function called  mapwindow . This functions allows you to map an arbitrary function over a patch of an image.  Let's use  mapwindow  to perform a median filter. This is a great way to suppress salt and pepper noise, or remove stars from some images. We'll use a Hubble picture of the Eagle nebula: using AstroImages\nusing ImageFiltering\n\nfname = download(\n    \"http://www.astro.uvic.ca/~wthompson/astroimages/fits/eagle/673nmos.fits\",\n    \"eagle-673nmos.fits\"\n)\n\neagle673 = load(\"eagle-673nmos.fits\") The data is originally from https://esahubble.org/projects/fits_liberator/eagledata/. We can apply a median filter using  mapwindow . Make sure the patch size is an odd number in each direction! using Statistics\nmedfilt = copyheader(eagle673, mapwindow(median, eagle673, (11,11))) We use  copyheader  here since  mapwindow  returns a plain array and drops the image meta data. We can put this side by side with the original to see how some of the faint stars have been removed from the image: imview([eagle673[1:800,1:800]; medfilt[1:800,1:800]])"},{"id":862,"pagetitle":"Transforming Images","title":"Image Transformations","ref":"/previews/PR43/AstroImages/stable/guide/image-transformations/#Image-Transformations","content":" Image Transformations The  ImageTransformations.jl  package contains many useful functions for manipulating astronomical images. Note however that many of these functions drop the AstroImage wrapper and return plain arrays or OffsetArrays. They can be re-wrapped using  copyheader  or  shareheader  if you'd like to preserve the FITS header, dimension labels, WCS information, etc. You can install ImageTransformations by running  ] add ImageTransformations  at the REPL. For these examples, we'll download an image of the Antenae galaxies from Hubble: using AstroImages\nusing ImageTransformations\n\nfname = download(\n    \"http://www.astro.uvic.ca/~wthompson/astroimages/fits/antenae/blue.fits\",\n    \"ant-blue.fits\"\n)\n\nantblue = load(\"ant-blue.fits\")\n\n# We'll change the defaults to avoid setting them each time\nAstroImages.set_clims!(Percent(99))\nAstroImages.set_cmap!(:ice)\nAstroImages.set_stretch!(asinhstretch)\n\nimview(antblue)"},{"id":863,"pagetitle":"Transforming Images","title":"Rotations","ref":"/previews/PR43/AstroImages/stable/guide/image-transformations/#Rotations","content":" Rotations We can rotate images using the  imrotate  function. imrotate(antblue, 3π/4) |> imview The rotation angle is in radians, but you can use the function  rad2deg  to convert from degrees."},{"id":864,"pagetitle":"Transforming Images","title":"Resizing","ref":"/previews/PR43/AstroImages/stable/guide/image-transformations/#Resizing","content":" Resizing We can resize images using the  imresize  function: imresize(antblue, ratio=0.2) |> imview"},{"id":865,"pagetitle":"Transforming Images","title":"Arbitrary Transformations","ref":"/previews/PR43/AstroImages/stable/guide/image-transformations/#Arbitrary-Transformations","content":" Arbitrary Transformations Arbitrary transformations can be performed using ImageTransformation's  warp  function. See the documentation linked above for more details."},{"id":866,"pagetitle":"Transforming Images","title":"Mapping from One Coordinate System to Another","ref":"/previews/PR43/AstroImages/stable/guide/image-transformations/#Mapping-from-One-Coordinate-System-to-Another","content":" Mapping from One Coordinate System to Another For transforming an image from one coordiante system (say, RA & DEC) to another (e.g., galactic lattitude & logitude), see  Reprojecting Images ."},{"id":869,"pagetitle":"Extracting Photometry","title":"Photometry","ref":"/previews/PR43/AstroImages/stable/guide/photometry/#Photometry","content":" Photometry The following examples are adapted from  Photometry.jl  to show the same examples combined with AstroImages.jl. To learn how to measure background levels, perform aperture photometry, etc see the  Photometry.jl documentation ."},{"id":870,"pagetitle":"Extracting Photometry","title":"Background Estimation","ref":"/previews/PR43/AstroImages/stable/guide/photometry/#Background-Estimation","content":" Background Estimation From Photometry.jl: Estimating backgrounds is an important step in performing photometry. Ideally, we could perfectly describe the background with a scalar value or with some distribution. Unfortunately, it's impossible for us to precisely separate the background and foreground signals. Here, we use mixture of robust statistical estimators and meshing to let us get the spatially varying background from an astronomical photo. Let's show an example Now let's try and estimate the background using estimate_background. First, we'll si gma-clip to try and remove the signals from the stars. Then, the background is broken down into boxes, in this case of size (50, 50). Within each box, the given statistical estimators get the background value and RMS. By default, we use SourceExtractorBackground and StdRMS. This creates a low-resolution image, which we then need to resize. We can accomplish this using an interpolator, by default a cubic-spline interpolator via ZoomInterpolator. The end result is a smooth estimate of the spatially varying background and background RMS. using Photometry\nusing AstroImages\nusing Plots # optional, for implot functionality\n\n# Download our image, courtesy of astropy\nimage = AstroImage(download(\"https://rawcdn.githack.com/astropy/photutils-datasets/8c97b4fa3a6c9e6ea072faeed2d49a20585658ba/data/M6707HH.fits\"))\n\n# sigma-clip\nclipped = sigma_clip(image, 1, fill=NaN)\n\n# get background and background rms with box-size (50, 50)\nbkg, bkg_rms = estimate_background(clipped, 50)\n\nimview(image)\nimview(clipped)\nimview(bkg)\nimview(bkg_rms) Or, if you have Plots loaded: using Plots\n\n    AstroImages.set_clims!(Percent(99.5))\n    AstroImages.set_cmap!(:magma)\n    AstroImages.set_stretch!(identity)\nplot(\n    implot(image, title=\"Original\"),\n    implot(clipped, title=\"Sigma-Clipped\"),\n    implot(bkg, title=\"Background\"),\n    implot(bkg_rms, title=\"Background RMS\"),\n    layout=(2, 2)\n) We could apply a median filter, too, by specifying filter_size # get background and background rms with box-size (50, 50) and filter_size (5, 5)\nbkg_f, bkg_rms_f = estimate_background(clipped, 50, filter_size=5)\n\n# plot\nplot(\n    implot(bkg, title=\"Unfiltered\", ylabel=\"Background\"),\n    implot(bkg_f, title=\"Filtered\"),\n    implot(bkg_rms, ylabel=\"RMS\"),\n    implot(bkg_rms_f);\n    layout=(2, 2),) Now we can see our image after subtracting the filtered background and ready for Aperture Photometry! subt = image .- bkg_f[axes(image)...]\nclims = extrema(vcat(vec(image), vec(subt)))\nplot(\n    implot(image; title=\"Original\", clims),\n    implot(subt; title=\"Subtracted\", clims),\n    size=(1600,1000)\n)"},{"id":871,"pagetitle":"Extracting Photometry","title":"Source Extraction","ref":"/previews/PR43/AstroImages/stable/guide/photometry/#Source-Extraction","content":" Source Extraction From the background-subtracted image, we can detect all sources in the image: # We specify the uncertainty in the pixel data. We'll set it equal to zero.\nerrs = zeros(axes(subt))\nsources = extract_sources(PeakMesh(), subt, errs, true) # sort from brightest to darkest Table with 3 columns and 60924 rows:\n      x     y     value\n    ┌────────────────────\n 1  │ 255   226   9762.42\n 2  │ 940   681   9661.5\n 3  │ 219   924   9653.78\n 4  │ 38    678   9647.93\n 5  │ 245   85    9637.55\n 6  │ 44    1001  9633.13\n 7  │ 503   904   9627.34\n 8  │ 819   775   9625.92\n 9  │ 610   62    9617.79\n 10 │ 133   110   9616.88\n 11 │ 592   123   9614.86\n 12 │ 1055  248   9612.46\n 13 │ 424   86    9611.86\n 14 │ 558   125   9585.93\n 15 │ 125   1021  9582.11\n 16 │ 112   637   9579.71\n 17 │ 196   2     9579.49\n ⋮  │  ⋮     ⋮       ⋮ There's over 60,000 sources! We'll define a circular apperture for each source: aps = CircularAperture.(sources.x, sources.y, 6)[1:1000] # just brightest thousand point sources 1000-element Vector{CircularAperture{Int64}}:\n CircularAperture(255, 226, r=6)\n CircularAperture(940, 681, r=6)\n CircularAperture(219, 924, r=6)\n CircularAperture(38, 678, r=6)\n CircularAperture(245, 85, r=6)\n CircularAperture(44, 1001, r=6)\n CircularAperture(503, 904, r=6)\n CircularAperture(819, 775, r=6)\n CircularAperture(610, 62, r=6)\n CircularAperture(133, 110, r=6)\n ⋮\n CircularAperture(697, 975, r=6)\n CircularAperture(703, 599, r=6)\n CircularAperture(893, 878, r=6)\n CircularAperture(291, 457, r=6)\n CircularAperture(660, 855, r=6)\n CircularAperture(711, 920, r=6)\n CircularAperture(708, 271, r=6)\n CircularAperture(701, 273, r=6)\n CircularAperture(710, 273, r=6) We can overplot them on our original image. The coordinate sytem used by the Photometry.jl plot recipes (but not the actual return values) doesn't match AstroImages, so we must transpose our image: implot(subt', colorbar=false)\nplot!(aps)"},{"id":872,"pagetitle":"Extracting Photometry","title":"Measuring Photometry","ref":"/previews/PR43/AstroImages/stable/guide/photometry/#Measuring-Photometry","content":" Measuring Photometry Finally we can extract the source photometry  table = photometry(aps, subt) Table with 3 columns and 1000 rows:\n      xcenter  ycenter  aperture_sum\n    ┌───────────────────────────────\n 1  │ 255      226      20542.4\n 2  │ 940      681      7125.3\n 3  │ 219      924      14741.0\n 4  │ 38       678      31056.4\n 5  │ 245      85       -910.308\n 6  │ 44       1001     2792.62\n 7  │ 503      904      6954.07\n 8  │ 819      775      -3136.61\n 9  │ 610      62       4338.13\n 10 │ 133      110      22219.0\n 11 │ 592      123      18562.2\n 12 │ 1055     248      3277.33\n 13 │ 424      86       255299.0\n 14 │ 558      125      6659.03\n 15 │ 125      1021     11524.1\n 16 │ 112      637      1349.78\n 17 │ 196      2        -797.491\n ⋮  │    ⋮        ⋮          ⋮ And plot them:  scatter(\n    table.xcenter,\n    table.ycenter,\n    aspectratio=1,\n    marker_z=table.aperture_sum,\n    markerstrokewidth=0,\n    label=\"\",\n    framestyle=:box,\n    background_inside=:black,\n    color=:white\n)"},{"id":875,"pagetitle":"Reprojecting Images","title":"Reprojecting Images","ref":"/previews/PR43/AstroImages/stable/guide/reproject/#Reprojecting-Images","content":" Reprojecting Images Integration with the  Reproject.jl  package is not yet complete."},{"id":878,"pagetitle":"Conventions","title":"Conventions","ref":"/previews/PR43/AstroImages/stable/manual/conventions/#Conventions","content":" Conventions In the Julia Astro ecosystem, images follow the following conventions."},{"id":879,"pagetitle":"Conventions","title":"Axes","ref":"/previews/PR43/AstroImages/stable/manual/conventions/#Axes","content":" Axes For simple 2D images, the first axis is the horizontal axis and the second axis is the vertical axis. So images are indexed by  img[xi, yi] . The origin is at the bottom left of the image, so  img[1,1]  refers to the bottom left corner as does  img[begin,begin] .  img[end,end]  is the top right corner,  img[begin,end]  is the top left, etc. Note that this is transposed and flipped from how how Julia prints arrays at the REPL, "},{"id":880,"pagetitle":"Conventions","title":"Pixels","ref":"/previews/PR43/AstroImages/stable/manual/conventions/#Pixels","content":" Pixels This library considers the exact location of  img[1,1]  to be the center of the pixel in the bottom left corner. This means that plot limits should have the  1  tick slightly away from the left/bottom spines of the image. The default plot limits for  implot  are  -0.5  to  end+0.5  along both axes.  There is a  known bug  with the Plots.jl GR backend that leads ticks to be slightly offset. PyPlot and Plotly backends show the correct tick locations."},{"id":883,"pagetitle":"Converting from RGB","title":"Converting From RGB Images","ref":"/previews/PR43/AstroImages/stable/manual/converting-from-rgb/#Converting-From-RGB-Images","content":" Converting From RGB Images If you encouter an image in a standard graphics format (e.g. PNG, JPG) that you want to analyze or store in an AstroImage, it will likely contain RGB (or similar) pixels.  It is possible to store RGB data in an AstroImage. Let's see how that works: using AstroImages\ndownload(\"http://www.astro.uvic.ca/~wthompson/astroimages/fits/mw-crop2-small.png\",\"mw-crop2-small.png\")\n\n# First we load it from the PNG file\nmw_png = load(\"mw-crop2-small.png\") You will need the Images.jl package installed to load formats like PNG. Once the RGB image is loaded, we can store it in an AstroImage if we'd like: mw_ai = AstroImage(mw_png) However, we may want to extract the RGB channels first. We can do this using  Images.channelview . Images.channelview  returns a view into the RGB data as a 3 × X × Y dimension cube. Unfortunately, we will have to permute the dimensions slightly. using Images\nmw_png = load(\"mw-crop2-small.png\")\nmw_chan_view = channelview(mw_png)\nmw_rgb_cube = AstroImage(\n    permutedims(mw_chan_view, (3, 2, 1))[:,end:-1:begin,:],\n    # Optional:\n    (X=:, Y=:, Spec=[:R,:G,:B])\n) 2596×1440×3 AstroImage{N0f8,3} with dimensions: \n  X ,\n  Y ,\n  Dim{:Spec} Categorical Symbol[R, G, B] ReverseOrdered\n[:, :, 1]\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n ⋮                        ⋮              ⋱            ⋮                   \n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n[and 2 more slices...] Here we chose to mark the third axis as a spectral axis with keys  :R ,  :G , and  :B . We can now visualize each channel: mw_rgb_cube[Spec=At(:R)] # Or just: mw_rgb_cube[:,:,1] imview(\n    mw_rgb_cube[Spec=At(:R)],\n    cmap=nothing # Grayscale mode\n) using Plots\nimplot(mw_rgb_cube[Spec=At(:B)])"},{"id":886,"pagetitle":"Converting to RGB","title":"Converting to RGB","ref":"/previews/PR43/AstroImages/stable/manual/converting-to-rgb/#Converting-to-RGB","content":" Converting to RGB If you have two or more images of the same scene taken at different wavelengths, you may wish to combine them to create a colour composite. For ultimate control, you can do this manually using  imview . Simply map your channels to  RGB  values using  imview  and then sum the results. For convenience, AstroImages.jl provides the function  composecolors ."},{"id":887,"pagetitle":"Converting to RGB","title":"Using composecolors","ref":"/previews/PR43/AstroImages/stable/manual/converting-to-rgb/#Using-composecolors","content":" Using  composecolors We'll demonstrate  composecolors  using Hubble images of the Antenae colliding galaxies. One can be very scientific about this process, but often the goal of producing color composites is aesthetic or about highlighting certain features for public consumption.  I'll set the default color map to grayscale to avoid confusion. using AstroImages\n\nAstroImages.set_cmap!(nothing) Let's start by downloading the separate color channel FITS files: antred = AstroImage(download(\"http://www.astro.uvic.ca/~wthompson/astroimages/fits/antenae/red.fits\")) antgreen = AstroImage(download(\"http://www.astro.uvic.ca/~wthompson/astroimages/fits/antenae/green.fits\")) antblue = AstroImage(download(\"http://www.astro.uvic.ca/~wthompson/astroimages/fits/antenae/blue.fits\")) anthalph = AstroImage(download(\"http://www.astro.uvic.ca/~wthompson/astroimages/fits/antenae/hydrogen.fits\")); # Hydrogen-Alpha; we'll revisit later The images will have to be aligned and cropped to the same size before making a color composite. In order to compose these images, we'll have to match the relative intensity scales and clip outlying values. Thankfully,  composecolors  handles most of these details automatically. rgb1 = composecolors([antred, antgreen, antblue]) It's a start! By default, if you provide three images these are mapped to the color channels red, green, and blue. The intensities are limited to  Percent(99.5) . We can now tweak these defaults to our tastes. We could try clamping the intensities more agressively to bring out more of the galaxy structure: rgb2 = composecolors(\n    [antred, antgreen, antblue],\n    clims=Percent(97)\n) This looks okay but saturates the galaxy cores. Let's take care of that gash through the image by just blanking it out. mask = antgreen .== antgreen[end,begin]\n# remove holes in the mask\nusing ImageFiltering, Statistics\nmask = BitMatrix(mapwindow(median, mask, (3,3)))\nimview(mask) antred[mask] .= NaN\nantgreen[mask] .= NaN\nantblue[mask] .= NaN\nanthalph[mask] .= NaN; 92228-element view(::Vector{Float32}, [39, 40, 41, 42, 43, 44, 45, 46, 47, 48  …  1119338, 1119339, 1119340, 1119341, 1119342, 1119343, 1119344, 1119345, 1119346, 1119347]) with eltype Float32:\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN\n   ⋮\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN\n NaN Typically we need to perform a \"gamma correction\" aka non-lienar stretch to map the wide dynamic range of astronomical images into a narrower human visible range. We can do this using the  stretch  keyword. An  asinhstretch  is typically recommended when preparing RGB images: rgb3 = composecolors(\n    [antred, antgreen, antblue],\n    stretch=asinhstretch\n) Keywords like  strech ,  clims , etc can be either a single value for all channels or a list of separate values/functions per channel. The green channel appears to be quite faint compared to the red and blue channels. We can modify that by adjusting the relative intensities of the channels.  We could also do this using a combination of the  contrast  and  bias  keywords. rgb4 = composecolors(\n    [antred, antgreen, antblue],\n    stretch=asinhstretch,\n    multiplier=[1,1.7,1]\n) That's better! Let's go one step further, and incorporate a fourth chanel: Hydrogen Alpha. Hydrogen Alpha is a narrow filter centered around one of the emission lines of Hydrogen atoms. It traces locations with hot gas; mostly star-formation regions in this case. imview(anthalph, cmap=:magma, clims=Zscale()) We'll now need to specify the color channels we want to use for each wavelength since we can't use just the default three RGB. We can use any named color or julia ColorScheme. rgb5 = composecolors(\n    [antred, antgreen, antblue, anthalph],\n    [\"red\", \"green\", \"blue\", \"maroon1\"],\n    stretch=asinhstretch,\n    multiplier=[1,1.7,1,0.8]\n) Additionally, I'd like to just show the brightest areas of Hydrogen alpha emission rather than adding a diffuse pink glow. We can turn off the stretch for this one channel: rgb6 = composecolors(\n    [antred, antgreen, antblue, anthalph],\n    [\"red\", \"green\", \"blue\", \"maroon1\"],\n    stretch=[\n        asinhstretch,\n        asinhstretch,\n        asinhstretch,\n        identity,\n    ],\n    multiplier=[1,1.7,1,0.8]\n) Finally, we can crop the image and save it as a PNG. crop = rgb6[200:end-100,50:end-50] save(\"antenae-composite.png\", crop) If you want to save it in a format like  JPG  that doesn't support transparent pixels, you could replace the masked area with zeros instead of  NaN ."},{"id":890,"pagetitle":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","ref":"/previews/PR43/AstroImages/stable/manual/dimensions-and-world-coordinates/#Dimensions-and-World-Coordinates","content":" Dimensions and World Coordinates AstroImages are based on  Dimensional Data . Each axis is assigned a dimension name and the indices are tracked."},{"id":891,"pagetitle":"Dimensions and World Coordinates","title":"World Coordinates","ref":"/previews/PR43/AstroImages/stable/manual/dimensions-and-world-coordinates/#World-Coordinates","content":" World Coordinates FITS files with world coordinate system (WCS) headers contain all the information necessary to map a pixel location into celestial coordinates & back. Let's see how this works with a 2D image with RA & DEC coordinates. using AstroImages\nusing Plots\n\n# Download a Hubble image of the Eagle nebula\ndownload(\n    \"http://www.astro.uvic.ca/~wthompson/astroimages/fits/656nmos.fits\",\n    \"eagle-656nmos.fits\"\n);\neagle = AstroImage(\"eagle-656nmos.fits\") This image contains world coordinate system headers. AstroImages.jl uses WCS.jl (and wcslib under the hood) to parse these headers. We can generate a WCSTransform object to inspect: wcs(eagle, 1) # specify which coordinate system WCSTransform(naxis=2,cdelt=[1.0, 1.0],crval=[274.71149247724, -13.816384007184],crpix=[386.5, 396.0]) Note that we specify with an index which coordinate system we'd like to use. Most images just contain one, but some contain multiple systems. We can lookup a coordinate from the image: world = pix_to_world(eagle, [1, 1]) # Bottom left corner 2-element Vector{Float64}:\n 274.712299241082\n -13.801135972688115 Or convert back from world coordinates to pixel coordinates: We can lookup a coordinate from the image: world_to_pix(eagle, world) # Bottom left corner 2-element Vector{Float64}:\n 1.000000000336172\n 0.9999999992196535 These pixel coordinates do not necessarily have to lie within the bounds of the original image, and in general lie at a fractional pixel position. If an image contains WCS headers, we can visualize them using  implot : implot(eagle) We can adjust the color of the grid: implot(eagle, gridcolor=:cyan) If these aren't desired, we can turn off the grid or the WCS tick marks: plot(\n  implot(eagle, grid=false),\n  implot(eagle, wcsticks=false),\n  size=(900,300),\n  bottommargin=10Plots.mm\n) Since AstroImages are based on DimensionalData's AbstractDimArray, the mapping between pixel coordinates and world coordinates are preserved when slicing an AstroImage: slice1 = eagle[1:800,1:800]\nslice2 = eagle[800:1600,1:800]\nplot(\n  implot(slice1),\n  implot(slice2),\n  size=(900,300),\n  bottommargin=10Plots.mm\n) World coordinate queries from that slice are aware of their position in the parent image: @show pix_to_world(slice1, [1,1])\n@show pix_to_world(slice2, [1,1]) 2-element Vector{Float64}:\n 274.7277517847315\n -13.817350009028138 Note  that you can query the dimensions of an image using the  dims  function from DimensionalData: dims(slice2) X Sampled 800:1600 ForwardOrdered Regular Points,\nY Sampled 1:800 ForwardOrdered Regular Points"},{"id":892,"pagetitle":"Dimensions and World Coordinates","title":"Named Dimensions","ref":"/previews/PR43/AstroImages/stable/manual/dimensions-and-world-coordinates/#Named-Dimensions","content":" Named Dimensions Each dimension of an AstroImage is named. The automatic dimension names are  X ,  Y ,  Z ,  Dim{4} ,  Dim{5} , and so on; however you can pass in other names or orders to the load function and/or AstroImage contructor: julia> img = load(\"eagle-656nmos.fits\",1,(Y,Z))\n1600×1600 AstroImage{Float32,2} with dimensions:\n  Y Sampled 1:1600 ForwardOrdered Regular Points,\n  Z Sampled 1:1600 ForwardOrdered Regular Points Other useful dimension names are  Spec  for spectral axes,  Pol  for polarization data, and  Ti  for time axes. These are tracked the same was as the automatic dimension names and interact smoothly with any WCS headers. You can give an arbitrary name using as a  Dim{Symbol} , e.g.  Dim{:Velocity} . You can access AstroImages using dimension names: eagle[X=100] 1600-element AstroImage{Float32,1} with dimensions: \n  Y Sampled Base.OneTo(1600) ForwardOrdered Regular Points\nand reference dimensions: \n  X Sampled 100:100 ForwardOrdered Regular Points\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n ⋮\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0 When indexing into a slice out of a larger parent image or cube, this named access refers to the  parent  dimensions: slice1 = eagle[600:800,600:800]\nslice1[X=At(700),Y=At(700)] == eagle[X=At(700),Y=At(700)] == eagle[700,700] true"},{"id":893,"pagetitle":"Dimensions and World Coordinates","title":"Cubes","ref":"/previews/PR43/AstroImages/stable/manual/dimensions-and-world-coordinates/#Cubes","content":" Cubes Let's see how this works with a 3D cube. using AstroImages\n\nHIcube = AstroImage(download(\"http://www.astro.uvic.ca/~wthompson/astroimages/fits/HIdat.fits\")) 150×150×450 AstroImage{Float32,3} with dimensions: \n  X Sampled Base.OneTo(150) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(150) ForwardOrdered Regular Points,\n  Z Sampled Base.OneTo(450) ForwardOrdered Regular Points\n[:, :, 1]\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN  …  NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN  …  NaN  NaN  NaN  NaN  NaN  NaN  NaN\n   ⋮                        ⋮            ⋱              ⋮                 \n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN  …  NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN     NaN  NaN  NaN  NaN  NaN  NaN  NaN\n[and 449 more slices...] Notice how the cube is not displayed automatically. We have to pick a specific slice: HIcube[Z=228] Using  implot , the world coordinates are displayed automatically: implot(HIcube[Z=228], cmap=:turbo) The plot automatically reflects the world coordinates embeded in the file. It displays the x axis in galactic longitude, the y-axis in galactic latitude, and even shows the curved projection from pixel coordinates to galactic coordinates. The title is automatically set to the world coordinate along the Z axis in units of velocity. It also picks up the unit of the data (Kelvins) to display on the colorbar. If we pick another slice, the title updates accordingly: implot(HIcube[Z=308], cmap=:turbo) This works for other slices through the cube as well: implot(HIcube[Y=45],  cmap=:turbo, aspectratio=0.3)"},{"id":894,"pagetitle":"Dimensions and World Coordinates","title":"Custom Dimensions","ref":"/previews/PR43/AstroImages/stable/manual/dimensions-and-world-coordinates/#Custom-Dimensions","content":" Custom Dimensions julia> img = load(\"img.fits\",1,(Y=1:1600,Z=1:1600))\n1600×1600 AstroImage{Float32,2} with dimensions:\n  Y Sampled 1:1600 ForwardOrdered Regular Points,\n  Z Sampled 1:1600 ForwardOrdered Regular Points Other useful dimension names are  Spec  for spectral axes,  Pol  for polarization data, and  Ti  for time axes. These are tracked the same was as the automatic dimension names and interact smoothly with any WCS headers. Often times we have images or cubes that we want to index with physical coordinates where setting up a full WCS transform is overkill. In these cases, it's easier to leverage custom dimensions. For example, one may wish to  julia> img = load(\"img.fits\",1,(X=801:2400,Y=1:2:3200))\n1600×1600 AstroImage{Float32,2} with dimensions:\n  X Sampled 801:2400 ForwardOrdered Regular Points,\n  Y Sampled 1:2:3199 ForwardOrdered Regular Points\n... Unlike OffsetArrays, the usual indexing remains so  img[1,1]  is still the bottom left of the image; however, data can be looked up according to the offset dimensions using specifiers: julia> img[X=Near(2000),Y=1..100]\n50-element AstroImage{Float32,1} with dimensions:\n  Y Sampled 1:2:99 ForwardOrdered Regular Points\nand reference dimensions:\n  X Sampled 2000:2000 ForwardOrdered Regular Points\n  0.0 You can adjust the center of an image's dimensions using  recenter : eagle_cen = recenter(eagle, 801, 801); Unlike an OffsetArray,  eagle_cen[1,1]  still refers to the bottom left of the image. This also has no effect on broadcasting,  eagle_cen .+ ones(1600,1600)  is perfectly valid. However, we see the new centered dimensions when we go to plot the image: implot(eagle_cen, wcsticks=false) And we can query positions using the offset dimensions: implot(eagle_cen[X=-300..300, Y=-300..300], wcsticks=false)"},{"id":897,"pagetitle":"Displaying Images","title":"Displaying Images","ref":"/previews/PR43/AstroImages/stable/manual/displaying-images/#Displaying-Images","content":" Displaying Images The  imview  and  implot  functions are very similar.  Both allow any abstract array of numbers to be rendered into an image or a Plots.jl image series.  implot  is largely a superset of  imview  because it also supports colorbars, tick marks, WCS grid lines, overplotting other data & shapes, and automatic axis and title naming (from the FITS header if available)."},{"id":898,"pagetitle":"Displaying Images","title":"imview","ref":"/previews/PR43/AstroImages/stable/manual/displaying-images/#imview","content":" imview Any AbstractArray (including an AstroImage) can be displayed using  imview . This function renders an arbitrary array into an array of  RGBA  values using a number of parameters. If the input is an AstroImage{<:Number}, an AstroImage{RGBA} will be returned that retains headers, WCS information, etc. The defaults for the  imview  function are: img = randn(50,50);\nimview(img; clims=Percent(99.5), cmap=:magma, stretch=identity, contrast=1.0, bias=0.5) We can adjust the color limits explicitly: imview(img; clims=(-1, 1)) Or pass a function/callable object to calculate them for us: imview(img; clims=Zscale()) We can turn off the colormap and use it in grayscale mode: imview(img; cmap=nothing) Pass any color scheme from ColorSchemes.jl: imview(img; cmap=:ice) imview(img; cmap=:seaborn_rocket_gradient) Or an RGB or named color value: imview(img; cmap=\"#F00\")\nimview(img; cmap=\"red\") Let's now switch to an astronomical image: fname = download(\n    \"http://www.astro.uvic.ca/~wthompson/astroimages/fits/656nmos.fits\",\n    \"eagle-656nmos.fits\"\n);\neagle = AstroImage(\"eagle-656nmos.fits\") We can apply a non-linear stretch like a log-scale, power-scale, or asinh stretch: imview(eagle, stretch=asinhstretch) Once rendered, we can also tweak the bias and contrast: imview(eagle, stretch=asinhstretch, contrast=1.5) imview(eagle, stretch=asinhstretch, contrast=1.5, bias=0.6) These are the parameters that change when you click and drag in some applications like DS9. Once rendered via  imview , the resulting image can be saved in traditional image formats like PNG, JPG, GIF, etc: save(\"out.png\", imview(eagle, cmap=:viridis)) Very large Images are automatically downscaled to ensure consistent performance using  restrict  from Images.jl. This function filters the data before downscaling to prevent aliasing, so it may take a moment for truly huge images. In these cases, a faster method that doesn't prevent aliasing would be  imview(img[begin:10:end, begin:10:end])  or similar. imview  is called automatically on  AstroImage{<:Number}  when using a Julia environment with rich graphical IO capabilities (e.g. VSCode, Jupyter, Pluto, etc.). The defaults for this case can be modified using  AstroImages.set_clims!(...) ,  AstroImages.set_cmap!(...) , and  AstroImages.set_stretch!(...) ."},{"id":899,"pagetitle":"Displaying Images","title":"Note on Views","ref":"/previews/PR43/AstroImages/stable/manual/displaying-images/#Note-on-Views","content":" Note on Views The function  imview  has its name because it produces a \"view\" into the image. The result from calling  imview  is an object that lazily maps data values into RGBA colors on the fly. This means that if you change the underlying data array, the view will update (the next time it is shown). If you have many data files to render, you may find it faster to create a single  imview  and then mutate the data in the underlying array. This is faster since  imview  only has to resolve colormaps and compute limits once. For example: data = randn(100,100)\niv = imview(data)\ndisplay(iv)\ndata[1:50,1:50] .= 0\ndisplay(iv) iv  will reflect the changes to  data  when it is displayed the second time."},{"id":900,"pagetitle":"Displaying Images","title":"implot","ref":"/previews/PR43/AstroImages/stable/manual/displaying-images/#implot","content":" implot implot   is a Plots.jl recipe, which means before you can use it you first have to load  Plots.jl : using Plots implot  accepts all the arguments  imview  does for controlling how data is rendered to the screen. implot(img; clims=Percent(99.5), cmap=:magma, stretch=identity, contrast=1.0, bias=0.5)"},{"id":903,"pagetitle":"Getting Started","title":"Getting Started","ref":"/previews/PR43/AstroImages/stable/manual/getting-started/#Getting-Started","content":" Getting Started To get started, you will first need to install AstroImages. After starting Julia, enter package-mode by typing  ]  and then pkg> add AstroImages To display images and save them in traditional graphics formats like PNG, JPG, GIF, etc., you will also need to add the  ImageIO  package. Once installed, this package doesn't need to be loaded explicitly. For some of the more advanced visualizations you may also want  Plots : pkg> add Plots To load the package, run: using AstroImages\n# And if desired:\nusing Plots"},{"id":906,"pagetitle":"Headers","title":"Headers","ref":"/previews/PR43/AstroImages/stable/manual/headers/#Headers","content":" Headers FITS files consist of one or more HDUs (header data units), and each HDU can contain an N-dimensional image or table. Before the data is a  header . Headers contain (key, value, comment) groups as well as dedicated long-form COMMENT and HISTORY sections used to document, for example, the series of post-processing steps applied to an image."},{"id":907,"pagetitle":"Headers","title":"Accessing Headers","ref":"/previews/PR43/AstroImages/stable/manual/headers/#Accessing-Headers","content":" Accessing Headers Here are some examples of how to set and read keys, comments, and history. Well start by making a blank image. img = AstroImage(zeros(10,10))\n# Set keys to values with different data types\nimg[\"KEY1\"] = 2   # Integer\nimg[\"KEY2\"] = 2.0 # Float\nimg[\"KEY3\"] = \"STRING\"\nimg[\"KEY4\"] = true\nimg[\"KEY5\"] = false\nimg[\"KEY6\"] = nothing\n\n# Set comments\nimg[\"KEY1\", Comment] = \"A key with an integer value\"\n\n# Read keys\na = img[\"KEY3\"]\n\n# Read comment\ncom = img[\"KEY1\", Comment]\n\n# Add long-form COMMENT\npush!(img, Comment, \"\"\"\nWe now describe how to add a long form comment to the end of a header.\n\"\"\")\n\n# Add HISTORY entry\npush!(img, History, \"\"\"\nWe now describe how to add a long form history to the end of a header.\n\"\"\")\n\n# Retrieve long form comments/ history\ncomment_strings = img[Comment]\nhistory_strings = img[History] Note that floating point values are formatted as ASCII strings when written to the FITS files, so the precision may be limited.  AstroImage  objects wrap a FITSIO.jl  FITSHeader . If necessary, you can recover it using  header(img) ; however, in most cases you can access header keywords directly from the image. API docs:  Comment History header"},{"id":910,"pagetitle":"Loading & Saving Images","title":"Loading Images","ref":"/previews/PR43/AstroImages/stable/manual/loading-images/#Loading-Images","content":" Loading Images FITS (Flexible Image Transport System) files can be loaded and saved using AstroImages thanks to the FITSIO package. AstroImages is registered with  FileIO , so if you have FileIO and AstroImages installed you can get started with the  load  function. When you pass a file name with the appropriate file extension (\".fits\", \".fit\", etc.) FileIO will import AstroImages automatically. Alternatively, you can use the  AstroImage  contructor instead of load. This will work on fits files with any file extension, including compressed files (e.g. \".fits.gz\"). julia> img = load(\"myfitsimg.fits\")\n1600×1600 AstroImage{Float32,2} with dimensions:\n  X Sampled Base.OneTo(1600) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(1600) ForwardOrdered Regular Points\n 0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n ⋮                        ⋱\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0 Note: if you are in an interactive environment like VSCode, Jupyter, or Pluto, instead of a REPL, AstroImages are automatically rendered to images and displayed. You can see this plain text output by explicitly calling:  show(stdout, MIME(\"text/plain\"), img) . Or:  julia> img = AstroImage(\"myfitsimg.fits.gz\")\n1600×1600 AstroImage{Float32,2} with dimensions:\n  X Sampled Base.OneTo(1600) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(1600) ForwardOrdered Regular Points\n 0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n ⋮                        ⋱\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0 A FITS file can contain multiple N-dimensional images and tables. When you call load or AstroImage with a file name and no other arguments, the package will search through the file and return the first image HDU. That is, it will skip any FITS tables or empty HDUs with only headers. You can also specify an HDU number explicitly: julia> img = load(\"myfitsimg.fits\",1)\n1600×1600 AstroImage{Float32,2} with dimensions:\n  X Sampled Base.OneTo(1600) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(1600) ForwardOrdered Regular Points\n... This way, you can load specific images from multi-extension files. You can load all HDUs simultaneously by passing  : : julia> hdus = load(\"multiext.fits\", :);\njulia> hdus[2] # Second HDU as an AstroImage\n10×10 AstroImage{Float64,2} with dimensions:\n  X Sampled Base.OneTo(10) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(10) ForwardOrdered Regular Points\n -0.777315  -1.36683   -0.580179     1.39629      …  -2.14298     0.450059   0.432065\n -1.09619    0.789249   0.938415     0.959903        -0.88995    -1.29406   -0.4291\n  0.47427   -1.41855    0.814823    -1.15975          0.0427149  -1.20116   -0.0920709\n -0.179858  -1.60228    1.09648     -0.497927        -1.31824    -0.156529  -0.0223846\n  2.64162    0.131437   0.320476     0.331197        -0.914713   -1.55162   -0.18862\n  0.209669  -1.17923   -0.656512     0.000775311  …   0.377461   -0.24278    0.967202\n  1.01442   -0.762895  -2.13238     -0.456932        -0.415733   -1.21416   -1.6108\n  0.385626   0.389335  -0.00726015   0.309936        -0.533175    0.157878   0.100876\n -1.24799    0.461216  -0.868826    -0.255654        -0.37151     0.49479   -1.87129\n  1.39356    2.29254    0.0548325    1.50674         -0.0880865   0.580978  -1.81629\njulia> # Or:\njulia> hdu1, hdu2, hdu3 = load(\"multiext.fits\", :); There is also limited support for table HDUs. In this case, a bare-bones Tables.jl compatible  object is returned."},{"id":911,"pagetitle":"Loading & Saving Images","title":"Dimension Names","ref":"/previews/PR43/AstroImages/stable/manual/loading-images/#Dimension-Names","content":" Dimension Names You may have noticed the entries above the image array: 10×10 AstroImage{Float64,2} with dimensions:\n  X Sampled Base.OneTo(10) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(10) ForwardOrdered Regular Points AstroImages are based on  Dimensional Data . Each axis is assigned a dimension name and the indices are tracked. The automatic dimension names are  X ,  Y ,  Z ,  Dim{4} ,  Dim{5} , and so on; however you can pass in other names or orders to the load function and/or AstroImage contructor: julia> img = load(\"img.fits\",1,(Y=1:1600,Z=1:1600))\n1600×1600 AstroImage{Float32,2} with dimensions:\n  Y Sampled 1:1600 ForwardOrdered Regular Points,\n  Z Sampled 1:1600 ForwardOrdered Regular Points Other useful dimension names are  Spec  for spectral axes,  Pol  for polarization data, and  Ti  for time axes. These will be further discussed in Dimensions and World Coordinates."},{"id":912,"pagetitle":"Loading & Saving Images","title":"Saving Images","ref":"/previews/PR43/AstroImages/stable/manual/loading-images/#Saving-Images","content":" Saving Images You can save one or more AstroImages and tables to a FITS file using the  save  function: julia> save(\"abc.fits\", astroimage1, astroimage2, table1) You can also save individual images to traditional graphics formats by first rendering them with  imview  (for more on imview, see Displaying Images). julia> save(\"abc.png\", imview(astroimage1)) You can save animated GIFs by saving a 3D datacube that has been rendered with imview: julia> cube =  imview(AstroImage(randn(100,100,10)));\njulia> save(\"abc.gif\", cube, fps=10)\n\njulia> # Or a more complex example (changing color schemes each frame)\njulia> img = randn(10,10)\njulia> cube2 = [imview(img1, cmap=:magma) ;;; imview(img2, cmap=:plasma) ;;; imview(img3, cmap=:viridis)]\njulia> # Alternative syntax:\njulia> cube2 = cat(imview(img1, cmap=:magma), imview(img2, cmap=:plasma), imview(img3, cmap=:viridis), dims=3)\njulia> save(\"abc.gif\", cube, fps=10)"},{"id":917,"pagetitle":"Preserving Wrapper","title":"Preserving the AstroImage Wrapper","ref":"/previews/PR43/AstroImages/stable/manual/preserving-wrapper/#Preserving-the-AstroImage-Wrapper","content":" Preserving the AstroImage Wrapper Wherever possible, overloads have been added to DimensionalData and AstroImages so that common operations retain the  AstroImage  wrapper with associated dimensions, FITS header, and WCS information. Most of the time this works automatically if libraries follow good patterns like allocating outputs using  Base.similar . However, some other library functions may follow patterns like allocating a plain  Array  of the correct size and then filling it.  To make it easier to work with these libraries, AstroImages exports two functions  copyheader  and  shareheader .  These functions wrap an AbstractArray in an AstroImage while copying over the header, dimensions, and WCS info. Consider the function: function badfunc(arr)\n    out = zeros(size(arr)) # instead of similar(arr)\n    out .= arr.^2\n    return out\nend Calling  badfunc(astroimg)  will return a plain  Array  . We can use  copyheader  to retain the  AstroImage  wrapper: copyheader(astroimg, badfunc(astroimg)) For particularly incompatible functions that require an Array (not subtype of AbstractArray) we can go one step further: copyheader(astroimg, worsefunc(parent(astroimg)))\n# Or:\ncopyheader(astroimg, worsefunc(collect(astroimg)))"},{"id":924,"pagetitle":"Introduction","title":"FITSIO.jl","ref":"/previews/PR43/FITSIO/stable/#FITSIO.jl","content":" FITSIO.jl A  Julia  package for reading and writing Flexible Image Transport System (FITS) files, based on the  cfitsio  library. The interface is inspired by Erin Sheldon's  fitsio  Python package. Warning The  Libcfitsio  submodule has been moved to  CFITSIO.jl  and will be deprecated in a future release."},{"id":925,"pagetitle":"Introduction","title":"Installation","ref":"/previews/PR43/FITSIO/stable/#Installation","content":" Installation FITSIO.jl  can be installed using the built-in package manager pkg> add FITSIO"},{"id":926,"pagetitle":"Introduction","title":"Usage","ref":"/previews/PR43/FITSIO/stable/#Usage","content":" Usage To open an existing file for reading: julia> using FITSIO\n\njulia> f = FITS(\"file.fits\")\nFile: file.fits\nMode: \"w\" (read-write)\nHDUs: Num  Name  Type\n      1          Image\n      2          Table (At the REPL, information about the file contents is shown.) A FITS file consists of one or more header-data units (HDUs), concatenated one after the other. The  FITS  object therefore is represented as a collection of these HDUs. Get information about the first HDU: julia> f[1]\nFile: file.fits\nHDU: 1\nType: Image\nDatatype: Float64\nDatasize: (800, 800) Iterate over HDUs in the file: julia> for hdu in f; println(typeof(hdu)); end\nFITSIO.ImageHDU\nFITSIO.TableHDU Each HDU can contain image data, or table data (either binary or ASCII-formatted). For image extensions, get the size of the image without reading it: julia> ndims(f[1])\n    2\n\njulia> size(f[1])\n(800,800)\n\njulia> size(f[1], 2)\n800 Read an image from disk: julia> data = read(f[1]);  # read an image from disk\n\njulia> data = read(f[1], :, 790:end);  # read just a subset of image Show info about a binary table: julia> f[2]\nFile: file.fits\nHDU: 2\nType: Table\nRows: 20\nColumns: Name  Size  Type    TFORM\n         col2        String  5A\n         col1        Int64   1K Read a column from the table: julia> data = read(f[2], \"col1\") Table HDUs implement the  Tables.jl  interface, so you can load them into other table types, like  DataFrames . julia> df = DataFrame(f[2]) Variable length columns are not supported by the Tables.jl interface, and  Tables  methods will ignore them. Read the entire header into memory and get values from it: julia> header = read_header(f[1]);  # read the entire header from disk\n\njulia> length(header)  # total number of records in header\n17\n\njulia> haskey(header, \"NAXIS1\")  # check if a key exists\ntrue\n\njulia> header[\"NAXIS1\"]  # get value by keyword\n800\n\njulia> header[4]  # get value by position\n800\n\njulia> get_comment(header, \"NAXIS\")  # get comment for a given keyword\n\"length of data axis 1\" Read just a single header record without reading the entire header: julia> read_key(f[1], 4)  # by position\n(\"NAXIS1\",800,\"length of data axis 1\")\n\njulia> read_key(f[1], \"NAXIS1\")  # read by keyword\n(800,\"length of data axis 1\") Manipulate a header in memory: julia> header[\"NEWKEY\"] = 10  # change or add a keyword\n\njulia> set_comment!(header, \"NEWKEY\", \"this is a comment\") Close the file: julia> close(f) ( FITS  objects are also closed automatically when garbage collected.) Open a new file for writing: julia> f = FITS(\"newfile.fits\", \"w\"); The second argument can be  \"r\"  (read-only; default),  \"r+\"  (read-write) or  \"w\"  (write). In \"write\" mode, any existing file of the same name is overwritten. Write an image to the file: julia> data = reshape([1:100;], 5, 20)\n\njulia> write(f, data)  # Write a new image extension with the data\njulia> close(f) To write some header keywords in the new extension, pass a  FITSHeader  instance as a keyword:  write(f, data; header=header) Overwrite image data in an existing file: julia> f = FITS(\"newfile.fits\", \"r+\")  # Reopen the file in read-write mode\njulia> data = reshape([101:200;], 5, 20)  # Prepare new image data\njulia> image_hdu = f[1]\njulia> write(image_hdu, data)  # Overwrite the image Write a table to the file: julia> data = Dict(\"col1\"=>[1., 2., 3.], \"col2\"=>[1, 2, 3]);\n\njulia> write(f, data)  # write a new binary table to a new extension Compressed storage Setting the file extension to  .gz  will automatically use GZIP compression and save on storage space. julia> FITS(\"abc.fits\", \"w\") do f # save the image uncompressed\n           write(f, ones(200,200))\n       end\n\njulia> filesize(\"abc.fits\")\n325440\n\njulia> FITS(\"abc.fits.gz\", \"w\") do f # save the image compressed\n            write(f, ones(200,200))\n       end\n\njulia> filesize(\"abc.fits.gz\")\n2117 Alternately the compression algorithm might be specified in square brackets after the filename. Check the  CFITSIO website  for the details of this usage. julia> FITS(\"abc.fits[compress R 100,100]\", \"w\") do f # Rice algorithm with a 100 x 100 pixel tile size\n           write(f, ones(200,200))\n       end\n\njulia> filesize(\"abc.fits\")\n8640 Warn Compression is \"loss-less\" for images with integer pixel values, and might be lossy for floating-point images."},{"id":929,"pagetitle":"API Reference","title":"API Reference","ref":"/previews/PR43/FITSIO/stable/api/#API-Reference","content":" API Reference"},{"id":930,"pagetitle":"API Reference","title":"File operations","ref":"/previews/PR43/FITSIO/stable/api/#File-operations","content":" File operations"},{"id":931,"pagetitle":"API Reference","title":"FITSIO.FITS","ref":"/previews/PR43/FITSIO/stable/api/#FITSIO.FITS","content":" FITSIO.FITS  —  Type FITS(filename::String[, mode::String = \"r\"]; extendedparser = true) Open or create a FITS file.  mode  can be one of  \"r\"  (read-only),  \"r+\"  (read-write) or  \"w\"  (write). In \"write\" mode, any existing file of the same name is overwritten. A  FITS  object is a collection of \"Header-Data Units\" (HDUs) and supports the following operations: f[i] : Return the  i -th HDU. f[name]  or  f[name, ver] : Return the HDU containing the given the given EXTNAME (or HDUNAME) keyword (a String), and optionally the given EXTVER (or HDUVER) number (an Integer). Iteration: for hdu in f\n    ...\nend The keyword argument  extendedparser  may be used to enable or disable the  extended filename parser . If disabled,  filename  is treated exactly as the name of the file and is not tokenized into parameters. source"},{"id":932,"pagetitle":"API Reference","title":"Base.length","ref":"/previews/PR43/FITSIO/stable/api/#Base.length","content":" Base.length  —  Function length(f::FITS) Number of HDUs in the file. source length(hdr::FITSHeader) Number of records in header of HDU. source length(hdu::ImageHDU) Get total number of pixels in image (product of  size(hdu) ). source"},{"id":933,"pagetitle":"API Reference","title":"Base.close","ref":"/previews/PR43/FITSIO/stable/api/#Base.close","content":" Base.close  —  Function close(f::FITS) Close the file. Subsequent attempts to operate on  f  will result in an error.  FITS  objects are also automatically closed when they are garbage collected. source"},{"id":934,"pagetitle":"API Reference","title":"Base.deleteat!","ref":"/previews/PR43/FITSIO/stable/api/#Base.deleteat!","content":" Base.deleteat!  —  Function deleteat!(f::FITS, i::Integer) Delete the HDU at index  i  in the FITS file. If  i == 1 , this deletes the primary HDU and replaces it with a bare HDU with no data and a minimal header. If  i > 1 , this removes the HDU at index  i  and moves the following HDUs forward. source"},{"id":935,"pagetitle":"API Reference","title":"Header operations","ref":"/previews/PR43/FITSIO/stable/api/#Header-operations","content":" Header operations"},{"id":936,"pagetitle":"API Reference","title":"FITSIO.read_key","ref":"/previews/PR43/FITSIO/stable/api/#FITSIO.read_key","content":" FITSIO.read_key  —  Function read_key(hdu::HDU, key::String) -> (value, comment) Read the HDU header record specified by keyword and return a tuple where  value  is the keyword parsed value (of type  String ,  Bool ,  Int ,  Float64  or  Nothing ),  comment  is the keyword comment (as a string). Throw an error if  key  is not found. source read_key(hdu::HDU, key::Integer) -> (keyname, value, comment) Same as  above  but FITS card is specified by its position and returns a 3 element tuple where  keyname  is the keyword name (a string). source"},{"id":937,"pagetitle":"API Reference","title":"FITSIO.write_key","ref":"/previews/PR43/FITSIO/stable/api/#FITSIO.write_key","content":" FITSIO.write_key  —  Function write_key(hdu::HDU, key::String, value[, comment]) Write a keyword value the HDU's header.  value  can be a standard header type ( String ,  Bool ,  Integer ,  AbstractFloat ) or  nothing , in which case the value part of the record will be empty. If the keyword already exists, the value will be overwritten. The comment will only be overwritten if given. If the keyword does not already exist, a new record will be appended at the end of the header. source"},{"id":938,"pagetitle":"API Reference","title":"FITSIO.read_header","ref":"/previews/PR43/FITSIO/stable/api/#FITSIO.read_header","content":" FITSIO.read_header  —  Function read_header(filename::AbstractString, hduindex = 1) -> FITSHeader Convenience function to read the entire header corresponding to the HDU at index  hduindex  contained in the FITS file named  filename . Functionally  read_header(filename, hduindex)  is equivalent to FITS(filename, \"r\") do f\n    read_header(f[hduindex])\nend source read_header(hdu::HDU) -> FITSHeader Read the entire header from the given HDU and return a  FITSHeader  object. The value of each header record is parsed as  Int ,  Float64 ,  String ,  Bool  or  nothing  according to the FITS standard. If the value cannot be parsed according to the FITS standard, the value is stored as the raw unparsed  String . source read_header(hdu::HDU, String) -> String Read the entire header from the given HDU as a single string. source"},{"id":939,"pagetitle":"API Reference","title":"FITSIO.FITSHeader","ref":"/previews/PR43/FITSIO/stable/api/#FITSIO.FITSHeader","content":" FITSIO.FITSHeader  —  Type FITSHeader(keys::Vector{String}, values::Vector, comments::Vector{String}) An in-memory representation of the header of an HDU. It stores the (key, value, comment) information for each 80-character \"card\" in a header. Note that this structure is not linked to a FITS file in any way; it is just a convenient structure for storing the header contents after reading from a file. (This is similar to how an  Array  returned by  read(f[1])  is not linked to the FITS file  f .)  Manipulating a  FITSHeader  will therefore have no immediate impact on any file, even if it was created by  read_header(::HDU) .  You can, however, write a  FITSHeader  to a file using the  write(::FITS, ...)  methods that append a new HDU to a file. source"},{"id":940,"pagetitle":"API Reference","title":"Base.length","ref":"/previews/PR43/FITSIO/stable/api/#Base.length-Tuple{FITSHeader}","content":" Base.length  —  Method length(hdr::FITSHeader) Number of records in header of HDU. source"},{"id":941,"pagetitle":"API Reference","title":"Base.haskey","ref":"/previews/PR43/FITSIO/stable/api/#Base.haskey-Tuple{FITSHeader, String}","content":" Base.haskey  —  Method haskey(hdr::FITSHeader, key::String) Returns true if  key  exists in header, otherwise false. source"},{"id":942,"pagetitle":"API Reference","title":"Base.keys","ref":"/previews/PR43/FITSIO/stable/api/#Base.keys-Tuple{FITSHeader}","content":" Base.keys  —  Method keys(hdr::FITSHeader) Array of keywords in header of HDU (not a copy). source"},{"id":943,"pagetitle":"API Reference","title":"Base.values","ref":"/previews/PR43/FITSIO/stable/api/#Base.values-Tuple{FITSHeader}","content":" Base.values  —  Method values(hdr::FITSHeader) Array of values in header of HDU (not a copy). source"},{"id":944,"pagetitle":"API Reference","title":"FITSIO.get_comment","ref":"/previews/PR43/FITSIO/stable/api/#FITSIO.get_comment","content":" FITSIO.get_comment  —  Function get_comment(hdr::FITSHeader, key_or_index::Union{String,Integer}) Get the comment based on keyword or index. source"},{"id":945,"pagetitle":"API Reference","title":"FITSIO.set_comment!","ref":"/previews/PR43/FITSIO/stable/api/#FITSIO.set_comment!","content":" FITSIO.set_comment!  —  Function set_comment!(hdr::FITSHeader, key_or_index::Union{String,Integer}, comment::String) Set the comment based on keyword or index. source"},{"id":946,"pagetitle":"API Reference","title":"FITSIO.default_header","ref":"/previews/PR43/FITSIO/stable/api/#FITSIO.default_header","content":" FITSIO.default_header  —  Function default_header(data::AbstractArray) Creates a default header for the given array with the  SIMPLE ,  BITPIX ,  NAXIS ,  NAXIS* , and  EXTEND  entries. source"},{"id":947,"pagetitle":"API Reference","title":"Image operations","ref":"/previews/PR43/FITSIO/stable/api/#Image-operations","content":" Image operations"},{"id":948,"pagetitle":"API Reference","title":"Base.read","ref":"/previews/PR43/FITSIO/stable/api/#Base.read-Tuple{ImageHDU}","content":" Base.read  —  Method read(hdu::ImageHDU)\nread(hdu::ImageHDU, range...) Read the data array or a subset thereof from disk. The first form reads the entire data array. The second form reads a slice of the array given by the specified ranges or integers. Dimensions specified by integers will be dropped in the returned array, while those specified by ranges will be retained. Note Julia follows a column-major array indexing convention, so the indices provided must account for this. In particular this means that FITS files created externally following a row-major convention (eg. using astropy) will have the sequence of axes flipped when read in using FITSIO. source"},{"id":949,"pagetitle":"API Reference","title":"Base.read!","ref":"/previews/PR43/FITSIO/stable/api/#Base.read!","content":" Base.read!  —  Function read!(hdu::ImageHDU, A::StridedArray)\nread!(hdu::ImageHDU, A::StridedArray, range...) Read the data or a subset thereof from disk, and save it in a pre-allocated output array  A . The first form reads the entire data from disk. The second form reads a slice of the array given by the specified ranges or integers. The array  A  needs to have the same length as the number of elements to be read in. Additionally  A  needs to be stored contiguously in memory. Note Julia follows a column-major array indexing convention, so the indices provided must account for this. In particular this means that FITS files created externally following a row-major convention (eg. using astropy) will have the sequence of the axes flipped when read in using FITSIO. source"},{"id":950,"pagetitle":"API Reference","title":"FITSIO.fitsread","ref":"/previews/PR43/FITSIO/stable/api/#FITSIO.fitsread","content":" FITSIO.fitsread  —  Function fitsread(filename::AbstractString[, hduindex = 1[, arrayindices...]]; extendedparser = true) Convenience function to read in an image corresponding to the HDU at index  hduindex  contained in the FITS file named  filename . If  arrayindices  are provided, only a slice of the image corresponding to the indices is read in. Functionally  fitsread(filename, hduindex, arrayindices...; extendedparser)  is equivalent to FITS(filename, \"r\"; extendedparser = extendedparser) do f\n    read(f[hduindex], arrayindices...)\nend The keyword argument  extendedparser  may be used to enable or disable the  extended filename parser . If disabled,  filename  is treated exactly as the name of the file and is not tokenized into parameters. Note Julia follows a column-major array indexing convention, so the indices provided must account for this. In particular this means that FITS files created externally following a row-major convention (eg. using astropy) will have the sequence of axes flipped when read in using FITSIO. See also:  read source"},{"id":951,"pagetitle":"API Reference","title":"Base.write","ref":"/previews/PR43/FITSIO/stable/api/#Base.write-Tuple{FITS, StridedArray{<:Real}}","content":" Base.write  —  Method write(f::FITS, data::StridedArray{<:Real}; header=nothing, name=nothing, ver=nothing) Add a new image HDU to FITS file  f  with contents  data . The following array element types are supported:  UInt8 ,  Int8 ,  UInt16 ,  Int16 ,  UInt32 ,  Int32 ,  Int64 ,  Float32 ,  Float64 . If a  FITSHeader  object is passed as the  header  keyword argument, the header will also be added to the new HDU. The data to be written out must be stored contiguously in memory. Unsupported element types It might be possible to write out an array with an element type other than those mentioned above by  reinterpret ing it as one that is supported. For example, to write out a  Complex  array and read it back in, we may use julia> a = rand(ComplexF64, 2)\n2-element Array{Complex{Float64},1}:\n 0.4943325325752195 + 0.2034650017475852im\n 0.2495752009567498 + 0.819163869249041im\n\n# We may write this out as Float64\njulia> FITSIO.fitswrite(\"temp.fits\", reinterpret(Float64, a))\n\n# reinterpret it back as a complex one while reading it in\njulia> reinterpret(ComplexF64, FITSIO.fitsread(\"temp.fits\"))\n2-element reinterpret(Complex{Float64}, ::Array{Float64,1}):\n 0.4943325325752195 + 0.2034650017475852im\n 0.2495752009567498 + 0.819163869249041im While this often works in practice, such a workaround is not officially supported by FITSIO, and care must be taken to ensure the correctness of data. source"},{"id":952,"pagetitle":"API Reference","title":"Base.write","ref":"/previews/PR43/FITSIO/stable/api/#Base.write-Tuple{ImageHDU, StridedArray{<:Real}}","content":" Base.write  —  Method write(hdu::ImageHDU, data::StridedArray{<:Real}) Write data to an existing image HDU. The data to be written out must be stored contiguously in memory. source"},{"id":953,"pagetitle":"API Reference","title":"FITSIO.fitswrite","ref":"/previews/PR43/FITSIO/stable/api/#FITSIO.fitswrite","content":" FITSIO.fitswrite  —  Function fitswrite(filename::AbstractString, data; extendedparser = true, kwargs...) Convenience function to write the image array  data  to a file named  filename . Functionally  fitswrite(filename, data; extendedparser, kwargs...)  is equivalent to FITS(filename, \"w\"; extendedparser = extendedparser) do f\n    write(f, data; kwargs...)\nend The keyword argument  extendedparser  may be used to enable or disable the  extended filename parser . If disabled,  filename  is treated exactly as the name of the file and is not tokenized into parameters. Warning Existing files with the same name will be overwritten. See also:  write source"},{"id":954,"pagetitle":"API Reference","title":"Base.eltype","ref":"/previews/PR43/FITSIO/stable/api/#Base.eltype-Tuple{ImageHDU}","content":" Base.eltype  —  Method eltype(hdu::ImageHDU) Return the element type of the image in  hdu . source"},{"id":955,"pagetitle":"API Reference","title":"Base.ndims","ref":"/previews/PR43/FITSIO/stable/api/#Base.ndims-Tuple{ImageHDU}","content":" Base.ndims  —  Method ndims(hdu::ImageHDU) Get number of image dimensions, without reading the image into memory. source"},{"id":956,"pagetitle":"API Reference","title":"Base.size","ref":"/previews/PR43/FITSIO/stable/api/#Base.size-Tuple{ImageHDU}","content":" Base.size  —  Method size(hdu::ImageHDU)\nsize(hdu::ImageHDU, i) Get image dimensions (or  i th dimension), without reading the image into memory. source"},{"id":957,"pagetitle":"API Reference","title":"Base.length","ref":"/previews/PR43/FITSIO/stable/api/#Base.length-Tuple{ImageHDU}","content":" Base.length  —  Method length(hdu::ImageHDU) Get total number of pixels in image (product of  size(hdu) ). source"},{"id":958,"pagetitle":"API Reference","title":"FITSIO.copy_section","ref":"/previews/PR43/FITSIO/stable/api/#FITSIO.copy_section","content":" FITSIO.copy_section  —  Function copy_section(hdu, dest, r...) Copy a rectangular section of an image and write it to a new FITS primary image or image extension in  FITS  object  dest . The new image HDU is appended to the end of  dest . All the keywords in the input image will be copied to the output image. The common WCS keywords will be updated if necessary to correspond to the coordinates of the section. Examples Copy the lower-left 200 x 200 pixel section of the image in  hdu  to an open file,  f copy_section(hdu, f, 1:200, 1:200) Same as above but only copy odd columns in y: copy_section(hdu, f, 1:200, 1:2:200) source"},{"id":959,"pagetitle":"API Reference","title":"Table operations","ref":"/previews/PR43/FITSIO/stable/api/#Table-operations","content":" Table operations"},{"id":960,"pagetitle":"API Reference","title":"FITSIO.colnames","ref":"/previews/PR43/FITSIO/stable/api/#FITSIO.colnames","content":" FITSIO.colnames  —  Function colnames(hdu) -> Vector{String} Return the names of columns in a table HDU. source"},{"id":961,"pagetitle":"API Reference","title":"Base.write","ref":"/previews/PR43/FITSIO/stable/api/#Base.write-Tuple{FITS, Dict{String}}","content":" Base.write  —  Method write(f::FITS, data::Dict;\n      hdutype=TableHDU, name=nothing, ver=nothing,\n      header=nothing, units=nothing, varcols=nothing) Create a new table extension and write data to it. If the FITS file is currently empty then a dummy primary array will be created before appending the table extension to it.  data  should be a dictionary with String keys (giving the column names) and Array values (giving data to write to each column). The following types are supported in binary tables:  UInt8 ,  Int8 ,  UInt16 ,  Int16 ,  UInt32 ,  Int32 ,  UInt64 ,  Int64 ,  Float32 ,  Float64 ,  Complex{Float32} ,  Complex{Float64} ,  String ,  Bool . Optional inputs: hdutype : Type of table extension to create. Can be either  TableHDU  (binary table) or  ASCIITableHDU  (ASCII table). name : Name of extension. ver : Version of extension (Int). header : FITSHeader instance to write to new extension. units : Dictionary mapping column name to units (as a string). varcols : An array giving the column names or column indicies to write as \"variable-length columns\". Variable length columns Variable length columns allow a column's row entries to contain arrays of different lengths. They can potentially save diskspace when the rows of a column vary greatly in length, as the column data is all written to a contiguous heap area at the end of the table. Only column data of type  Vector{String}  or types such as  Vector{Vector{UInt8}}  can be written as variable length columns. In the second case, ensure that the column data type is a  leaf type . That is, the type cannot be  Vector{Vector{T}} , which would be an array of arrays having potentially non-uniform element types (which would not be writable as a FITS table column). source"},{"id":962,"pagetitle":"API Reference","title":"Base.write","ref":"/previews/PR43/FITSIO/stable/api/#Base.write-Tuple{FITS, Vector{String}, Vector}","content":" Base.write  —  Method write(f::FITS, colnames, coldata;\n      hdutype=TableHDU, name=nothing, ver=nothing,\n      header=nothing, units=nothing, varcols=nothing) Same as  write(f::FITS, data::Dict; ...)  but providing column names and column data as a separate arrays. This is useful for specifying the order of the columns. Column names must be  Vector{String}  and column data must be a vector of arrays. source"},{"id":963,"pagetitle":"API Reference","title":"Base.read","ref":"/previews/PR43/FITSIO/stable/api/#Base.read-Tuple{TableHDU, String}","content":" Base.read  —  Method read(hdu::TableHDU, colname; case_sensitive=true) Read a column as an array from the given table HDU. The column name may contain wild card characters ( * ,  ? , or  # ). The  *  wild card character matches any sequence of characters (including zero characters) and the  ?  character matches any single character. The  #  wildcard will match any consecutive string of decimal digits (0-9). The string must match a unique column.  The optional boolean keyword  case_sensitive ,  true  by default, specifies whether the column name is to be considered case sensitive. Array order Julia arrays are column-major (like Fortran), not row-major (like C and numpy), so elements of multi-dimensional columns will be the transpose of what you get with astropy. source"},{"id":966,"pagetitle":"Home","title":"CFITSIO.jl","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.jl","content":" CFITSIO.jl This module provides an interface familiar to users of the  CFITSIO  C library. It can be used with using CFITSIO The functions exported by this module operate on  FITSFile  objects, which is a thin wrapper around a pointer to a CFITSIO  fitsfile .  For the most part, the functions are thin wrappers around the CFITSIO routines of the same names. Typically, they: Convert from Julia types to C types as necessary. Check the returned status value and raise an appropriate exception if non-zero. The following tables give the correspondances between CFITSIO \"types\", the BITPIX keyword and Julia types."},{"id":967,"pagetitle":"Home","title":"Type Conversions","ref":"/previews/PR43/CFITSIO/stable/#Type-Conversions","content":" Type Conversions"},{"id":968,"pagetitle":"Home","title":"CFITSIO Types","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO-Types","content":" CFITSIO Types CODE CFITSIO Julia int Cint long Clong LONGLONG Int64"},{"id":969,"pagetitle":"Home","title":"FITS BITPIX","ref":"/previews/PR43/CFITSIO/stable/#FITS-BITPIX","content":" FITS BITPIX CODE CFITSIO Julia 8 BYTE_IMG Uint8 16 SHORT_IMG Int16 32 LONG_IMG Int32 64 LONGLONG_IMG Int64 -32 FLOAT_IMG Float32 -64 DOUBLE_IMG Float64"},{"id":970,"pagetitle":"Home","title":"CFITSIO Aliases","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO-Aliases","content":" CFITSIO Aliases CODE CFITSIO Julia Comments 10 SBYTE_IMG Int8 written as: BITPIX = 8, BSCALE = 1, BZERO = -128 20 USHORT_IMG Uint16 written as: BITPIX = 16, BSCALE = 1, BZERO = 32768 40 LONG_IMG Uint32 written as: BITPIX = 32, BSCALE = 1, BZERO = 2147483648"},{"id":971,"pagetitle":"Home","title":"FITS Table Data Types","ref":"/previews/PR43/CFITSIO/stable/#FITS-Table-Data-Types","content":" FITS Table Data Types CODE CFITSIO Julia 1 TBIT 11 TBYTE Cuchar ,  Uint8 12 TSBYTE Cchar ,  Int8 14 TLOGICAL Bool 16 TSTRING String 20 TUSHORT Cushort 21 TSHORT Cshort 30 TUINT Cuint 31 TINT Cint 40 TULONG Culong 41 TLONG Clong 42 TFLOAT Cfloat 81 TLONGLONG Int64 82 TDOUBLE Cdouble 83 TCOMPLEX Complex{Cfloat} 163 TDBLCOMPLEX Complex{Cdouble}"},{"id":972,"pagetitle":"Home","title":"CFITSIO.bitpix_from_type","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.bitpix_from_type","content":" CFITSIO.bitpix_from_type  —  Function bitpix_from_type(::Type) -> Cint Return the FITS BITPIX code for the given Julia type source"},{"id":973,"pagetitle":"Home","title":"CFITSIO.type_from_bitpix","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.type_from_bitpix","content":" CFITSIO.type_from_bitpix  —  Function type_from_bitpix(::Integer) -> Type Return the Julia type from the FITS BITPIX code source"},{"id":974,"pagetitle":"Home","title":"CFITSIO.cfitsio_typecode","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.cfitsio_typecode","content":" CFITSIO.cfitsio_typecode  —  Function cfitsio_typecode(::Type) -> Cint Return the CFITSIO type code for the given Julia type source"},{"id":975,"pagetitle":"Home","title":"File access","ref":"/previews/PR43/CFITSIO/stable/#File-access","content":" File access"},{"id":976,"pagetitle":"Home","title":"CFITSIO.fits_create_file","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_create_file","content":" CFITSIO.fits_create_file  —  Function fits_create_file(filename::AbstractString) Create and open a new empty output  FITSFile . This methods uses the  extended file name syntax  to create the file. See also  fits_create_diskfile  which does not use the extended filename parser. source"},{"id":977,"pagetitle":"Home","title":"CFITSIO.fits_create_diskfile","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_create_diskfile","content":" CFITSIO.fits_create_diskfile  —  Function fits_create_diskfile(filename::AbstractString) Create and open a new empty output  FITSFile . Unlike  fits_create_file , this function does not use an extended filename parser and treats the string as is as the filename. source"},{"id":978,"pagetitle":"Home","title":"CFITSIO.fits_clobber_file","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_clobber_file","content":" CFITSIO.fits_clobber_file  —  Function fits_clobber_file(filename::AbstractString) Like  fits_create_file , but overwrites  filename  if it exists. source"},{"id":979,"pagetitle":"Home","title":"CFITSIO.fits_open_file","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_open_file","content":" CFITSIO.fits_open_file  —  Function fits_open_file(filename::String, [mode = 0]) Open an existing data file. Modes: 0 : Read only (equivalently denoted by  CFITSIO.R ) 1 : Read-write (equivalently denoted by  CFITSIO.RW ) This function uses the extended filename syntax to open the file. See also  fits_open_diskfile  that does not use the extended filename parser and uses  filename  as is as the name of the file. source"},{"id":980,"pagetitle":"Home","title":"CFITSIO.fits_open_diskfile","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_open_diskfile","content":" CFITSIO.fits_open_diskfile  —  Function fits_open_diskfile(filename::String, [mode = 0]) Open an existing data file. Modes: 0 : Read only (equivalently denoted by  CFITSIO.R ) 1 : Read-write (equivalently denoted by  CFITSIO.RW ) This function does not use the extended filename parser, and uses  filename  as is as the name of the file that is to be opened. See also  fits_open_file  which uses the extended filename syntax. source"},{"id":981,"pagetitle":"Home","title":"CFITSIO.fits_open_table","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_open_table","content":" CFITSIO.fits_open_table  —  Function fits_open_table(filename::String, [mode = 0]) Open an existing data file (like  fits_open_file ) and move to the first HDU containing either an ASCII or a binary table. Modes: 0 : Read only (equivalently denoted by  CFITSIO.R ) 1 : Read-write (equivalently denoted by  CFITSIO.RW ) source"},{"id":982,"pagetitle":"Home","title":"CFITSIO.fits_open_image","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_open_image","content":" CFITSIO.fits_open_image  —  Function fits_open_image(filename::String, [mode = 0]) Open an existing data file (like  fits_open_file ) and move to the first HDU containing an image. Modes: 0 : Read only (equivalently denoted by  CFITSIO.R ) 1 : Read-write (equivalently denoted by  CFITSIO.RW ) source"},{"id":983,"pagetitle":"Home","title":"CFITSIO.fits_open_data","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_open_data","content":" CFITSIO.fits_open_data  —  Function fits_open_data(filename::String, [mode = 0]) Open an existing data file (like  fits_open_file ) and move to the first HDU containing either an image or a table. Modes: 0 : Read only (equivalently denoted by  CFITSIO.R ) 1 : Read-write (equivalently denoted by  CFITSIO.RW ) source"},{"id":984,"pagetitle":"Home","title":"CFITSIO.fits_close_file","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_close_file","content":" CFITSIO.fits_close_file  —  Function fits_close_file(f::FITSFile) Close a previously opened FITS file. source"},{"id":985,"pagetitle":"Home","title":"CFITSIO.fits_delete_file","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_delete_file","content":" CFITSIO.fits_delete_file  —  Function fits_delete_file(f::FITSFile) Close an opened FITS file (like  fits_close_file ) and removes it from the disk. source"},{"id":986,"pagetitle":"Home","title":"CFITSIO.fits_file_name","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_file_name","content":" CFITSIO.fits_file_name  —  Function fits_file_name(f::FITSFile) Return the name of the file associated with object  f . source"},{"id":987,"pagetitle":"Home","title":"CFITSIO.fits_file_mode","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_file_mode","content":" CFITSIO.fits_file_mode  —  Function fits_file_mode(f::FITSFile) Return the I/O mode of the FITS file, where 0 indicates a read-only mode and 1 indicates a read-write mode. source"},{"id":988,"pagetitle":"Home","title":"HDU Routines","ref":"/previews/PR43/CFITSIO/stable/#HDU-Routines","content":" HDU Routines The functions described in this section change the current HDU and to find their number and type. The following is a short example which shows how to use them: num = fits_get_num_hdus(f)\nprintln(\"Number of HDUs in the file: \", num)\n\nfor i = 1:num\n    hdu_type = fits_movabs_hdu(f, i)\n    println(i, \") hdu_type = \", hdu_type)\nend"},{"id":989,"pagetitle":"Home","title":"CFITSIO.fits_get_num_hdus","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_get_num_hdus","content":" CFITSIO.fits_get_num_hdus  —  Function fits_get_num_hdus(f::FITSFile) Return the number of HDUs in the file. source"},{"id":990,"pagetitle":"Home","title":"CFITSIO.fits_movabs_hdu","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_movabs_hdu","content":" CFITSIO.fits_movabs_hdu  —  Function fits_movabs_hdu(f::FITSFile, hduNum::Integer) Change the current HDU to the value specified by  hduNum , and return a symbol describing the type of the HDU. Possible symbols are:  image_hdu ,  ascii_table , or  binary_table . The value of  hduNum  must range between 1 and the value returned by  fits_get_num_hdus . source"},{"id":991,"pagetitle":"Home","title":"CFITSIO.fits_movrel_hdu","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_movrel_hdu","content":" CFITSIO.fits_movrel_hdu  —  Function fits_movrel_hdu(f::FITSFile, hduNum::Integer) Change the current HDU by moving forward or backward by  hduNum  HDUs (positive means forward), and return the same as  fits_movabs_hdu . source"},{"id":992,"pagetitle":"Home","title":"CFITSIO.fits_movnam_hdu","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_movnam_hdu","content":" CFITSIO.fits_movnam_hdu  —  Function fits_movnam_hdu(f::FITSFile, extname::String, extver::Integer=0,\n      hdu_type_int::Integer=-1) Change the current HDU by moving to the (first) HDU which has the specified extension type and EXTNAME and EXTVER keyword values (or HDUNAME and HDUVER keywords). If  extver  is 0 (the default) then the EXTVER keyword is ignored and the first HDU with a matching EXTNAME (or HDUNAME) keyword will be found. If  hdu_type_int  is -1 (the default) only the extname and extver values will be used to locate the correct extension. If no matching HDU is found in the file, the current HDU will remain unchanged. source"},{"id":993,"pagetitle":"Home","title":"CFITSIO.fits_delete_hdu","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_delete_hdu","content":" CFITSIO.fits_delete_hdu  —  Function fits_delete_hdu(f::FITSFile) Delete the HDU from the FITS file and shift the following HDUs forward. If  f  is the primary HDU in the file then it'll be replaced by a null primary HDU with no data and minimal header information. Return a symbol to indicate the type of the new current HDU. Possible symbols are:  image_hdu ,  ascii_table , or  binary_table . The value of  hduNum  must range between 1 and the value returned by  fits_get_num_hdus . source"},{"id":994,"pagetitle":"Home","title":"Header Keyword Routines","ref":"/previews/PR43/CFITSIO/stable/#Header-Keyword-Routines","content":" Header Keyword Routines"},{"id":995,"pagetitle":"Home","title":"CFITSIO.fits_get_hdrspace","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_get_hdrspace","content":" CFITSIO.fits_get_hdrspace  —  Function fits_get_hdrspace(f::FITSFile) -> (keysexist, morekeys) Return the number of existing keywords (not counting the END keyword) and the amount of space currently available for more keywords. source"},{"id":996,"pagetitle":"Home","title":"CFITSIO.fits_read_keyword","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_read_keyword","content":" CFITSIO.fits_read_keyword  —  Function fits_read_keyword(f::FITSFile, keyname::String) -> (value, comment) yields the specified keyword value and commend (as a tuple of strings), throws and error if the keyword is not found. source"},{"id":997,"pagetitle":"Home","title":"CFITSIO.fits_read_record","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_read_record","content":" CFITSIO.fits_read_record  —  Function fits_read_record(f::FITSFile, keynum::Int) -> String Return the nth header record in the CHU. The first keyword in the header is at  keynum = 1 . source"},{"id":998,"pagetitle":"Home","title":"CFITSIO.fits_read_keyn","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_read_keyn","content":" CFITSIO.fits_read_keyn  —  Function fits_read_keyn(f::FITSFile, keynum::Int) -> (name, value, comment) Return the nth header record in the CHU. The first keyword in the header is at  keynum = 1 . source"},{"id":999,"pagetitle":"Home","title":"CFITSIO.fits_write_key","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_write_key","content":" CFITSIO.fits_write_key  —  Function fits_write_key(f::FITSFile, keyname::String, value, comment::String) Write a keyword of the appropriate data type into the CHU. source"},{"id":1000,"pagetitle":"Home","title":"CFITSIO.fits_write_record","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_write_record","content":" CFITSIO.fits_write_record  —  Function fits_write_record(f::FITSFile, card::String) Write a user specified keyword record into the CHU. source"},{"id":1001,"pagetitle":"Home","title":"CFITSIO.fits_delete_record","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_delete_record","content":" CFITSIO.fits_delete_record  —  Function fits_delete_record(f::FITSFile, keynum::Int) Delete the keyword record at the specified index. source"},{"id":1002,"pagetitle":"Home","title":"CFITSIO.fits_delete_key","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_delete_key","content":" CFITSIO.fits_delete_key  —  Function fits_delete_key(f::FITSFile, keyname::String) Delete the keyword named  keyname . source"},{"id":1003,"pagetitle":"Home","title":"CFITSIO.fits_hdr2str","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_hdr2str","content":" CFITSIO.fits_hdr2str  —  Function fits_hdr2str(f::FITSFile, nocomments::Bool=false) Return the header of the CHDU as a string. If  nocomments  is  true , comment cards are stripped from the output. source"},{"id":1004,"pagetitle":"Home","title":"Image HDU Routines","ref":"/previews/PR43/CFITSIO/stable/#Image-HDU-Routines","content":" Image HDU Routines"},{"id":1005,"pagetitle":"Home","title":"CFITSIO.fits_get_img_size","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_get_img_size","content":" CFITSIO.fits_get_img_size  —  Function fits_get_img_size(f::FITSFile) Get the dimensions of the image. source"},{"id":1006,"pagetitle":"Home","title":"CFITSIO.fits_create_img","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_create_img","content":" CFITSIO.fits_create_img  —  Function fits_create_img(f::FITSFile, T::Type, naxes::Vector{<:Integer}) Create a new primary array or IMAGE extension with the specified data type  T  and size  naxes . source fits_create_img(f::FITSFile, A::AbstractArray) Create a new primary array or IMAGE extension with the element type and size of  A , that is capable of storing the entire array  A . source"},{"id":1007,"pagetitle":"Home","title":"CFITSIO.fits_insert_img","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_insert_img","content":" CFITSIO.fits_insert_img  —  Function fits_insert_img(f::FITSFile, T::Type, naxes::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}) Insert a new image extension immediately following the CHDU, or insert a new Primary Array at the beginning of the file. source"},{"id":1008,"pagetitle":"Home","title":"CFITSIO.fits_write_pix","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_write_pix","content":" CFITSIO.fits_write_pix  —  Function fits_write_pix(f::FITSFile, fpixel::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}, nelements::Integer, data::StridedArray) Write  nelements  pixels from  data  into the FITS file starting from the pixel  fpixel . Note data  needs to be stored contiguously in memory. See also:  fits_write_pixnull source fits_write_pix(f::FITSFile, data::StridedArray) Write the entire array  data  into the FITS file. Note data  needs to be stored contiguously in memory. See also:  fits_write_pixnull ,  fits_write_subset source"},{"id":1009,"pagetitle":"Home","title":"CFITSIO.fits_write_pixnull","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_write_pixnull","content":" CFITSIO.fits_write_pixnull  —  Function fits_write_pixnull(f::FITSFile, fpixel::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}, nelements::Integer, data::StridedArray, nulval) Write  nelements  pixels from  data  into the FITS file starting from the pixel  fpixel . The argument  nulval  specifies the values that are to be considered as \"null values\", and replaced by appropriate numbers corresponding to the element type of  data . Note data  needs to be stored contiguously in memory. See also:  fits_write_pix source fits_write_pixnull(f::FITSFile, data::StridedArray, nulval) Write the entire array  data  into the FITS file. The argument  nulval  specifies the values that are to be considered as \"null values\", and replaced by appropriate numbers corresponding to the element type of  data . Note data  needs to be stored contiguously in memory. See also:  fits_write_pix source"},{"id":1010,"pagetitle":"Home","title":"CFITSIO.fits_write_subset","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_write_subset","content":" CFITSIO.fits_write_subset  —  Function fits_write_subset(f::FITSFile, fpixel::V, lpixel::V, data::StridedArray) where {V<:Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}} Write a rectangular section of the FITS image. The number of pixels to be written will be computed from the first and last pixels (specified as the  fpixel  and  lpixel  arguments respectively). Note The section to be written out must be contiguous in memory, so all the dimensions aside from the last one must span the entire axis range. The arguments  fpixel  and  lpixel  must account for this. See also:  fits_write_pix source"},{"id":1011,"pagetitle":"Home","title":"CFITSIO.fits_read_pix","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_read_pix","content":" CFITSIO.fits_read_pix  —  Function fits_read_pix(f::FITSFile, fpixel::NTuple{Vector{<:Integer}, Tuple{Vararg{Integer}}}, nelements::Integer, [nulval], data::StridedArray) Read  nelements  pixels from the FITS file into  data  starting from the pixel  fpixel . If the optional argument  nulval  is specified and is non-zero, any null value present in the array will be replaced by it. Note data  needs to be stored contiguously in memory. See also:  fits_read_pixnull ,  fits_read_subset source fits_read_pix(f::FITSFile, data::StridedArray, [nulval]) Read  length(data)  pixels from the FITS file into  data  starting from the first pixel. The optional argument  nulval , if specified and non-zero, is used to replace any null value present in the array. Note data  needs to be stored contiguously in memory. See also:  fits_read_pixnull source"},{"id":1012,"pagetitle":"Home","title":"CFITSIO.fits_read_pixnull","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_read_pixnull","content":" CFITSIO.fits_read_pixnull  —  Function fits_read_pixnull(f::FITSFile, fpixel::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}, nelements::Integer, data::StridedArray, nullarray::Array{UInt8}) Read  nelements  pixels from the FITS file into  data  starting from the pixel  fpixel . At output, the indices of  nullarray  where  data  has a corresponding null value are set to  1 . Note data  needs to be stored contiguously in memory. See also:  fits_read_pix source fits_read_pixnull(f::FITSFile, data::StridedArray, nullarray::Array{UInt8}) Read  length(data)  pixels from the FITS file into  data  starting from the first pixel. At output, the indices of  nullarray  where  data  has a corresponding null value are set to  1 . Note data  needs to be stored contiguously in memory. See also:  fits_read_pix source"},{"id":1013,"pagetitle":"Home","title":"CFITSIO.fits_read_subset","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_read_subset","content":" CFITSIO.fits_read_subset  —  Function fits_read_subset(f::FITSFile, fpixel::V, lpixel::V, inc::V, [nulval], data::StridedArray) where {V<:Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}} Read a rectangular section of the FITS image. The number of pixels to be read will be computed from the first and last pixels (specified as the  fpixel  and  lpixel  arguments respectively). The argument  inc  specifies the step-size in pixels along each dimension. If the optional argument  nulval  is specified and is non-zero, null values in  data  will be replaced by it. Note data  needs to be stored contiguously in memory, and will be populated contiguously with the pixels that are read in. See also:  fits_read_pix source"},{"id":1014,"pagetitle":"Home","title":"CFITSIO.fits_copy_image_section","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_copy_image_section","content":" CFITSIO.fits_copy_image_section  —  Function fits_copy_image_section(fin::FITSFile, fout::FITSFile, section::String) Copy a rectangular section of an image from  fin  and write it to a new FITS primary image or image extension in  fout . The section specifier is described on the  CFITSIO website . source"},{"id":1015,"pagetitle":"Home","title":"CFITSIO.fits_write_null_img","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_write_null_img","content":" CFITSIO.fits_write_null_img  —  Function fits_write_null_img(f::FITSFile, firstelem::Integer, nelements::Integer) Set a stretch of elements to the appropriate null value, starting from the pixel number  firstelem  and extending over  nelements  pixels. source"},{"id":1016,"pagetitle":"Home","title":"CFITSIO.fits_resize_img","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_resize_img","content":" CFITSIO.fits_resize_img  —  Function fits_resize_img(f::FITSFile, T::Type, naxis::Integer, sz::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}) Modify the size, dimensions and optionally the element type of the image in  f . The new image will have an element type  T , be a  naxis -dimensional image with size  sz . If the new image is larger than the existing one, it will be zero-padded at the end. If the new image is smaller, existing image data will be truncated. fits_resize_img(f::FITSFile, sz::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}) Resize the image to the new size  sz . The element type is preserved, and the number of dimensions is set equal to  length(sz) . fits_resize_img(f::FITSFile, T::Type) Change the element type of the image to  T , leaving the size unchanged. Note This method reinterprets the data instead of coercing the elements. Example julia> f = fits_clobber_file(tempname());\n\njulia> a = [1 2; 3 4];\n\njulia> fits_create_img(f, a);\n\njulia> fits_write_pix(f, a);\n\njulia> fits_get_img_size(f)\n2-element Vector{Int64}:\n 2\n 2\n\njulia> fits_resize_img(f, [3,3]);\n\njulia> fits_get_img_size(f)\n2-element Vector{Int64}:\n 3\n 3\n\njulia> b = similar(a, (3,3));\n\njulia> fits_read_pix(f, b); b\n3×3 Matrix{Int64}:\n 1  4  0\n 3  0  0\n 2  0  0\n\njulia> fits_resize_img(f, [4]);\n\njulia> b = similar(a, (4,));\n\njulia> fits_read_pix(f, b); b\n4-element Vector{Int64}:\n 1\n 3\n 2\n 4 source"},{"id":1017,"pagetitle":"Home","title":"Table Routines","ref":"/previews/PR43/CFITSIO/stable/#Table-Routines","content":" Table Routines There are two functions to create a new HDU table extension:  fits_create_ascii_table  and  fits_create_binary_table . In general, one should pick the second as binary tables require less space on the disk and are more efficient to read and write. (Moreover, a few datatypes are not supported in ASCII tables). In order to create a table, the programmer must specify the characteristics of each column by passing an array of tuples. Here is an example: f = fits_create_file(\"!new.fits\")\ncoldefs = [(\"SPEED\", \"1D\", \"m/s\"),\n           (\"MASS\", \"1E\", \"kg\"),\n           (\"PARTICLE\", \"20A\", \"Name\")]\nfits_create_binary_tbl(f, 10, coldefs, \"PARTICLE\") This example creates a table with room for 10 entries, each of them describing the characteristics of a particle: its speed, its mass, and its name (codified as a 20-character string). See the documentation of  fits_create_ascii_tbl  for more details."},{"id":1018,"pagetitle":"Home","title":"CFITSIO.fits_create_ascii_tbl","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_create_ascii_tbl","content":" CFITSIO.fits_create_ascii_tbl  —  Function fits_create_ascii_tbl(f::FITSFile, numrows::Integer, coldefs::Array{CFITSIO.ColumnDef},\n            extname::String) Append a new HDU containing an ASCII table. The table will have  numrows  rows (this parameter can be set to zero), each initialized with the default value. In order to create a table, the programmer must specify the characteristics of each column. The columns are specified by the  coldefs  variable, which is an array of tuples. Each tuple must have three string fields: The name of the column. The data type and the repetition count. It must be a string made by a number (the repetition count) followed by a letter specifying the type (in the example above,  D  stands for  Float64 ,  E  stands for  Float32 ,  A  stands for  Char ). Refer to the CFITSIO documentation for more information about the syntax of this parameter. The measure unit of this field. This is used only as a comment. The value of  extname  sets the \"extended name\" of the table, i.e., a string that in some situations can be used to refer to the HDU itself. Note that, unlike for binary tables, CFITSIO puts some limitations to the types that can be used in an ASCII table column. Refer to the CFITSIO manual for further information. See also  fits_create_binary_tbl  for a similar function which creates binary tables. source"},{"id":1019,"pagetitle":"Home","title":"CFITSIO.fits_create_binary_tbl","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_create_binary_tbl","content":" CFITSIO.fits_create_binary_tbl  —  Function fits_create_binary_tbl(f::FITSFile, numrows::Integer, coldefs::Array{ColumnDef},\n             extname::String) Append a new HDU containing a binary table. The meaning of the parameters is the same as in a call to  fits_create_ascii_tbl . In general, one should pick this function for creating tables in a new HDU, as binary tables require less space on the disk and are more efficient to read and write. (Moreover, a few datatypes are not supported in ASCII tables). source"},{"id":1020,"pagetitle":"Home","title":"CFITSIO.fits_get_coltype","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_get_coltype","content":" CFITSIO.fits_get_coltype  —  Function fits_get_coltype(f::FITSFile, colnum::Integer) Provided that the current HDU contains either an ASCII or binary table, return information about the column at position  colnum  (counting from 1). Return is a tuple containing typecode : CFITSIO integer type code of the column. repcount : Repetition count for the column. width : Width of an individual element. source"},{"id":1021,"pagetitle":"Home","title":"CFITSIO.fits_insert_rows","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_insert_rows","content":" CFITSIO.fits_insert_rows  —  Function fits_insert_rows(f::FITSFile, firstrow::Integer, nrows::Integer) Insert a number of rows equal to  nrows  after the row number  firstrow . The elements in each row are initialized to their default value: you can modify them later using  fits_write_col . Since the first row is at position 1, in order to insert rows  before  the first one  firstrow  must be equal to zero. source"},{"id":1022,"pagetitle":"Home","title":"CFITSIO.fits_delete_rows","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_delete_rows","content":" CFITSIO.fits_delete_rows  —  Function fits_delete_rows(f::FITSFile, firstrow::integer, nrows::Integer) Delete  nrows  rows, starting from the one at position  firstrow . The index of the first row is 1. source"},{"id":1023,"pagetitle":"Home","title":"CFITSIO.fits_read_col","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_read_col","content":" CFITSIO.fits_read_col  —  Function fits_read_col(f, colnum, firstrow, firstelem, data) Read data from one column of an ASCII/binary table and convert the data into the specified type  T . Arguments f::FITSFile : the file to be read. colnum::Integer : the column number, where the value of the first column is  1 . firstrow::Integer : the elements to be read start from this row. firstelem::Integer : specifies which is the first element to be read, when each cell contains more than one element (i.e., the \"repetition count\" of the field is greater than one). data::Array : at the end of the call, this will be filled with the elements read from the column. The length of the array gives the overall number of elements. source"},{"id":1024,"pagetitle":"Home","title":"CFITSIO.fits_write_col","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.fits_write_col","content":" CFITSIO.fits_write_col  —  Function fits_write_col(f, colnum, firstrow, firstelem, data) Write some data in one column of a ASCII/binary table. If there is no room for the elements, new rows will be created. (It is therefore useless to call  fits_insert_rows  if you only need to  append  elements to the end of a table.) f::FITSFile : the file in which data will be written. colnum::Integer : the column number, where the value of the first column is  1 . firstrow::Integer : the data wil be written from this row onwards. firstelem::Integer : specifies the position in the row where the first element will be written. data::Array : contains the elements that are to be written to the column of the table. source"},{"id":1025,"pagetitle":"Home","title":"Miscellaneous","ref":"/previews/PR43/CFITSIO/stable/#Miscellaneous","content":" Miscellaneous"},{"id":1026,"pagetitle":"Home","title":"CFITSIO.libcfitsio_version","ref":"/previews/PR43/CFITSIO/stable/#CFITSIO.libcfitsio_version","content":" CFITSIO.libcfitsio_version  —  Function libcfitsio_version() -> VersionNumber Return the version of the underlying CFITSIO library Example julia> libcfitsio_version()\nv\"3.37.0\" source"},{"id":1031,"pagetitle":"Home","title":"Cosmology.jl","ref":"/previews/PR43/Cosmology/stable/#Cosmology.jl-1","content":" Cosmology.jl Cosmology.jl  provides functions for quick cosmological calculations, written in pure Julia. "},{"id":1032,"pagetitle":"Home","title":"Installation","ref":"/previews/PR43/Cosmology/stable/#Installation-1","content":" Installation To install the package, enter  pkg  mode ( ] ) pkg> add Cosmology Then, to load the package julia> using Cosmology"},{"id":1033,"pagetitle":"Home","title":"Contributing","ref":"/previews/PR43/Cosmology/stable/#Contributing-1","content":" Contributing If you would like to contribute to  Cosmology.jl , head over to our  GitHub page  and open an issue or pull request! For any new features, we ask the contributors to add any relevant unit tests and bump the package version by one minor version."},{"id":1036,"pagetitle":"API/Reference","title":"API/Reference","ref":"/previews/PR43/Cosmology/stable/api/#API/Reference-1","content":" API/Reference Unitful Unitful.jl  works seamlessly with Cosmology.jl. In order to use its features, make sure it is installed and imported, along with  UnitfulAstro . pkg> add Unitful UnitfulAstro\njulia> using Unitful, UnitfulAstro"},{"id":1037,"pagetitle":"API/Reference","title":"Cosmological Models","ref":"/previews/PR43/Cosmology/stable/api/#Cosmological-Models-1","content":" Cosmological Models"},{"id":1038,"pagetitle":"API/Reference","title":"Cosmology.cosmology","ref":"/previews/PR43/Cosmology/stable/api/#Cosmology.cosmology","content":" Cosmology.cosmology  —  Function cosmology(;h = 0.69,\n           Neff = 3.04,\n           OmegaK = 0,\n           OmegaM = 0.29,\n           OmegaR = nothing,\n           Tcmb = 2.7255,\n           w0 = -1,\n           wa = 0) Parameters h  - Dimensionless Hubble constant OmegaK  - Curvature density (Ω_k) OmegaM  - Matter density (Ω_m) OmegaR  - Radiation density (Ω_r) Tcmb  - CMB temperature in Kelvin; used to compute Ω_γ Neff  - Effective number of massless neutrino species; used to compute Ω_ν w0  - CPL dark energy equation of state;  w = w0 + wa(1-a) wa  - CPL dark energy equation of state;  w = w0 + wa(1-a) Examples julia> c = cosmology()\nCosmology.FlatLCDM{Float64}(0.69, 0.7099122024007928, 0.29, 8.77975992071536e-5)\n\njulia> c = cosmology(OmegaK=0.1)\nCosmology.OpenLCDM{Float64}(0.69, 0.1, 0.6099122024007929, 0.29, 8.77975992071536e-5)\n\njulia> c = cosmology(w0=-0.9, OmegaK=-0.1)\nCosmology.ClosedWCDM{Float64}(0.69, -0.1, 0.8099122024007929, 0.29, 8.77975992071536e-5, -0.9, 0.0) source"},{"id":1039,"pagetitle":"API/Reference","title":"Distances","ref":"/previews/PR43/Cosmology/stable/api/#Distances-1","content":" Distances"},{"id":1040,"pagetitle":"API/Reference","title":"Cosmology.angular_diameter_dist","ref":"/previews/PR43/Cosmology/stable/api/#Cosmology.angular_diameter_dist","content":" Cosmology.angular_diameter_dist  —  Function angular_diameter_dist([u::Unitlike,] c::AbstractCosmology, [z₁,] z₂) Ratio of the proper transverse size in Mpc of an object at redshift  z₂  to its angular size in radians, as seen by an observer at  z₁ .  Redshift  z₁  defaults to 0 if omitted.  Will convert to compatible unit  u  if provided. source"},{"id":1041,"pagetitle":"API/Reference","title":"Cosmology.comoving_radial_dist","ref":"/previews/PR43/Cosmology/stable/api/#Cosmology.comoving_radial_dist","content":" Cosmology.comoving_radial_dist  —  Function comoving_radial_dist([u::Unitlike,] c::AbstractCosmology, [z₁,] z₂) Comoving radial distance in Mpc at redshift  z₂  as seen by an observer at  z₁ .  Redshift  z₁  defaults to 0 if omitted.  Will convert to compatible unit  u  if provided. source"},{"id":1042,"pagetitle":"API/Reference","title":"Cosmology.luminosity_dist","ref":"/previews/PR43/Cosmology/stable/api/#Cosmology.luminosity_dist","content":" Cosmology.luminosity_dist  —  Function luminosity_dist([u::Unitlike,] c::AbstractCosmology, z) Bolometric luminosity distance in Mpc at redshift  z . Will convert to compatible unit  u  if provided. source"},{"id":1043,"pagetitle":"API/Reference","title":"Cosmology.distmod","ref":"/previews/PR43/Cosmology/stable/api/#Cosmology.distmod","content":" Cosmology.distmod  —  Function distmod(c::AbstractCosmology, z) Distance modulus in magnitudes at redshift  z . source"},{"id":1044,"pagetitle":"API/Reference","title":"Examples","ref":"/previews/PR43/Cosmology/stable/api/#Examples-1","content":" Examples julia> c = cosmology(OmegaM=0.26)\nCosmology.FlatLCDM{Float64}(0.69, 0.7399122024007928, 0.26, 8.77975992071536e-5)\n\njulia> angular_diameter_dist(c, 1.2)\n1784.0089227105113 Mpc\n\njulia> angular_diameter_dist(c, 0.7, 1.2)\n606.6521737365097 Mpc\n\njulia> luminosity_dist(c, 1.5)\n11420.338287150073 Mpc\n\njulia> luminosity_dist(u\"Gpc\", c, 1.5) # Can convert to appropriate unit\n11.420338287150074 Gpc"},{"id":1045,"pagetitle":"API/Reference","title":"Volumes","ref":"/previews/PR43/Cosmology/stable/api/#Volumes-1","content":" Volumes"},{"id":1046,"pagetitle":"API/Reference","title":"Cosmology.comoving_volume_element","ref":"/previews/PR43/Cosmology/stable/api/#Cosmology.comoving_volume_element","content":" Cosmology.comoving_volume_element  —  Function comoving_volume_element([u::Unitlike,] c::AbstractCosmology, z) Comoving volume element in Gpc out to redshift  z . Will convert to compatible unit  u  if provided. source"},{"id":1047,"pagetitle":"API/Reference","title":"Cosmology.comoving_volume","ref":"/previews/PR43/Cosmology/stable/api/#Cosmology.comoving_volume","content":" Cosmology.comoving_volume  —  Function comoving_volume([u::Unitlike,] c::AbstractCosmology, z) Comoving volume in cubic Gpc out to redshift  z . Will convert to compatible unit  u  if provided. source"},{"id":1048,"pagetitle":"API/Reference","title":"Examples","ref":"/previews/PR43/Cosmology/stable/api/#Examples-2","content":" Examples julia> c = cosmology(OmegaM=0.26)\nCosmology.FlatLCDM{Float64}(0.69, 0.7399122024007928, 0.26, 8.77975992071536e-5)\n\njulia> comoving_volume_element(c, 2.1)\n46.74459228888612 Gpc^3\n\njulia> comoving_volume(c, 0.6)\n49.3633436631307 Gpc^3\n\njulia> comoving_volume(u\"ly^3\", c, 0.6)\n1.7127035381753e30 ly^3"},{"id":1049,"pagetitle":"API/Reference","title":"Times","ref":"/previews/PR43/Cosmology/stable/api/#Times-1","content":" Times"},{"id":1050,"pagetitle":"API/Reference","title":"Cosmology.age","ref":"/previews/PR43/Cosmology/stable/api/#Cosmology.age","content":" Cosmology.age  —  Function age([u::Unitlike,] c::AbstractCosmology, z) Age of the universe in Gyr at redshift  z . Will convert to compatible unit  u  if provided. source"},{"id":1051,"pagetitle":"API/Reference","title":"Cosmology.lookback_time","ref":"/previews/PR43/Cosmology/stable/api/#Cosmology.lookback_time","content":" Cosmology.lookback_time  —  Function lookback_time([u::Unitlike,] c::AbstractCosmology, z) Difference between age at redshift 0 and age at redshift  z  in Gyr. Will convert to compatible unit  u  if provided. source"},{"id":1052,"pagetitle":"API/Reference","title":"Examples","ref":"/previews/PR43/Cosmology/stable/api/#Examples-3","content":" Examples julia> c = cosmology(OmegaM=0.26)\nCosmology.FlatLCDM{Float64}(0.69, 0.7399122024007928, 0.26, 8.77975992071536e-5)\n\njulia> age(c, 1.2)\n5.445600787626434 Gyr\n\njulia> lookback_time(u\"yr\", c, 1.2)\n8.761660748088268e9 yr"},{"id":1057,"pagetitle":"Home","title":"Transits.jl","ref":"/previews/PR43/Transits/stable/#Transits.jl","content":" Transits.jl Transits.jl provides flexible and powerful occultation curves with limb darkening. The goals of this package are, in this order have a simple interface with high  composability be flexible with respect to numeric types and application be fully compatible with  ChainRules.jl  automatic differentiation (AD) system to leverage the derived analytical gradients provide a codebase that is well-organized, instructive, and easy to extend maintain high performance: at least as fast as similar tools In particular,  PolynomialLimbDark  implements the \"starry\" limb darkening method, which solves the flux integral analytically. This provides floating-point errors and runtimes that are best in class."},{"id":1058,"pagetitle":"Home","title":"Installation","ref":"/previews/PR43/Transits/stable/#Installation","content":" Installation To install use  Pkg . From the REPL, press  ]  to enter Pkg-mode pkg> add Transits If you want to use the most up-to-date version of the code, check it out from  main pkg> add Transits#main"},{"id":1059,"pagetitle":"Home","title":"Citations","ref":"/previews/PR43/Transits/stable/#Citations","content":" Citations If you use Transits.jl or a derivative of it in your work please consider citing it at the  Zenodo DOI . If you use  PolynomialLimbDark  or  QuadLimbDark  please also cite  Agol et al. (2020)  and  Luger et al. (2019) . If you use  Kipping13  please cite  Kipping (2013) . BibTeX for all those citations can be found in  CITATIONS.bib ."},{"id":1062,"pagetitle":"API/Reference","title":"API/Reference","ref":"/previews/PR43/Transits/stable/api/#API/Reference","content":" API/Reference"},{"id":1063,"pagetitle":"API/Reference","title":"Index","ref":"/previews/PR43/Transits/stable/api/#Index","content":" Index Transits.AbstractLimbDark Transits.AbstractLimbDark Transits.IntegratedLimbDark Transits.Kipping13 Transits.PolynomialLimbDark Transits.QuadLimbDark Transits.SecondaryLimbDark Transits.compute Transits.compute"},{"id":1064,"pagetitle":"API/Reference","title":"Light Curves","ref":"/previews/PR43/Transits/stable/api/#Light-Curves","content":" Light Curves"},{"id":1065,"pagetitle":"API/Reference","title":"Transits.AbstractLimbDark","ref":"/previews/PR43/Transits/stable/api/#Transits.AbstractLimbDark","content":" Transits.AbstractLimbDark  —  Type AbstractLimbDark A limb dark law need only need to implement  compute(::Law, b, r)  to extend the limb darkening interface. See also compute source"},{"id":1066,"pagetitle":"API/Reference","title":"Transits.AbstractLimbDark","ref":"/previews/PR43/Transits/stable/api/#Transits.AbstractLimbDark-Tuple","content":" Transits.AbstractLimbDark  —  Method (::AbstractLimbDark)(b, r) An alias for calling  compute Examples julia> ld = PolynomialLimbDark([0.4, 0.26]);\n\njulia> ld(0, 0.01)\n0.9998785437247428 source"},{"id":1067,"pagetitle":"API/Reference","title":"Transits.PolynomialLimbDark","ref":"/previews/PR43/Transits/stable/api/#Transits.PolynomialLimbDark","content":" Transits.PolynomialLimbDark  —  Type PolynomialLimbDark(u::AbstractVector) Polynomial limb darkening using analytical integrals. The length of the  u  vector is equivalent to the order of polynomial used; e.g.,  [0.2, 0.3]  corresponds to quadratic limb darkening. Mathematical form \\[I(\\mu) \\propto 1 - u_1(1-\\mu) - u_2(1-\\mu)^2 - \\dots - u_N(1-\\mu)^N\\] which is equivalent to the series \\[I(\\mu) \\propto -\\sum_{i=0}^N{u_i(1-\\mu)^i}\\] with the definition  $u_0 \\equiv -1$ . Examples u = [0.4, 0.26] # quadratic and below is 100% analytical\nld = PolynomialLimbDark(u)\nld(0.1, 0.01)\n\n# output\n0.9998787880717668 u2 = vcat(u, ones(12) ./ 12)\nld2 = PolynomialLimbDark(u2)\nld2(0.1, 0.01)\n\n# output\n0.9998740059086433 References Agol, Luger, Foreman-Mackey (2020) \"Analytic Planetary Transit Light Curves and Derivatives for Stars with Polynomial Limb Darkening\" Luger et al. (2019) \"starry: Analytic Occultation Light Curves\" source"},{"id":1068,"pagetitle":"API/Reference","title":"Transits.QuadLimbDark","ref":"/previews/PR43/Transits/stable/api/#Transits.QuadLimbDark","content":" Transits.QuadLimbDark  —  Type QuadLimbDark(u::AbstractVector) A specialized implementation of  PolynomialLimbDark  with a maximum of two terms (quadratic form). This has a completely closed-form solution without any numerical integration. This means there are no intermediate allocations and reduced numerical error. Mathematical form \\[I(\\mu) \\propto 1 - u_1(1-\\mu) - u_2(1-\\mu)^2\\] Higher-order terms Higher-order terms will be  ignored ; no error will be thrown Examples ld = QuadLimbDark(Float64[]) # constant term only\n\nb = [0, 1, 2] # impact parameter\nr = 0.01 # radius ratio\nld.(b, r)\n\n# output\n3-element Vector{Float64}:\n 0.9999\n 0.9999501061035608\n 1.0 ld = QuadLimbDark([0.4, 0.26]) # max two terms\nld.(b, r)\n\n# output\n3-element Vector{Float64}:\n 0.9998785437247428\n 0.999974726693709\n 1.0 References See references for  PolynomialLimbDark source"},{"id":1069,"pagetitle":"API/Reference","title":"Transits.IntegratedLimbDark","ref":"/previews/PR43/Transits/stable/api/#Transits.IntegratedLimbDark","content":" Transits.IntegratedLimbDark  —  Type IntegratedLimbDark(limbdark; N=21, basis=:legendre)\nIntegratedLimbDark(u; kwargs...) Computes the time-averaged flux in the middle of an exposure by wrapping a limb darkening law  limbdark  with a quadrature scheme. For each time step  t ,  N  extra points are  super-sampled  from  t-texp/2  to  t+texp/2 and the time-averaged flux is calculated via quadrature. If a set of limb darkening coefficients,  u , is provided, a  PolynomialLimbDark  law will be used by default. Mathematical form \\[\\bar{F}(t) = \\frac{1}{\\Delta t}\\int_{t-\\Delta t / 2}^{t+\\Delta t / 2}{F(t')dt'}\\] where  $F$  is the wrapped limb darkening law and  $\\Delta t$  is the exposure time. Quadrature The integration is approximated via  Guassian quadrature \\[\\frac{1}{\\Delta t} \\int{F(t')dt'} \\approx \\frac12\\sum_i^N{w_i * F(\\frac{\\Delta t}{2}\\xi_i + t)}\\] where the weights  w_i  and nodes  ξ_i  are defined by the given quadrature rule. The nodes are defined by evaluating orthogonal polynomials  N  times between -1 and 1. Notice the change of interval required to go from the natural bounds of the orthogonal polynomial basis,  -1, 1 , to the range defined by the exposure time. The following bases are available from  FastGaussQuadrature.jl . In addition, a function can be passed which calculates  nodes, weights = f(N) . :legendre  - Legendre polynomial base on the open  (-1, 1) :radau  - Legendre polynomial base on the semi-open  [-1, 1)  interval :lobatto  - Legendre polynomial base on the closed  [-1, 1]  interval source"},{"id":1070,"pagetitle":"API/Reference","title":"Transits.SecondaryLimbDark","ref":"/previews/PR43/Transits/stable/api/#Transits.SecondaryLimbDark","content":" Transits.SecondaryLimbDark  —  Type SecondaryLimbDark(primary::AbstractLimbDark,\n                  secondary::AbstractLimbDark; \n                  brightness_ratio=1)\nSecondaryLimbDark(u_p::AbstractVector, u_s=u_p; kwargs...) Compose two limb darkening laws together to add a secondary eclipse. If vectors of coefficients are provided, laws will automatically be constructed using  PolynomialLimbDark . The surface brightness ratio is given in terms of the host; e.g., if the companion is half as bright as the host, the ratio would be 0.5. Interface SecondaryLimbDark  only works with an orbit, since the companion's reference frame needs to be calculated. This means you can't call it using an impact parameter like  ld(b, r)  directly. Mathematical form \\[f(t, r) = \\frac{2f_p(t, r) + \\eta r^2 f_s(t', r')}{1 + f_p(t, r) + \\eta r^2 f_s(t', r')}\\] where  $f_p$  is to the primary flux,  $f_s$  is to the secondary flux, and  $\\eta$  is the surface brightness ratio.  $t'$  and  $r'$  correspond to the time and radius ratio from the companion's reference frame. Examples using Orbits\n# equal size and limb darkening\nr = 1.0\nu = [0.4, 0.26]\n# companion is 1/10 as bright\nbrightness_ratio = 0.1\nld = SecondaryLimbDark(u; brightness_ratio)\norbit = SimpleOrbit(period=2, duration=0.5)\nfp = ld(orbit, 0, r) # primary egress\nfs = ld(orbit, 1, r) # secondary egress\n\nfp ≈ brightness_ratio * fs\n\n# output\ntrue source"},{"id":1071,"pagetitle":"API/Reference","title":"Transits.compute","ref":"/previews/PR43/Transits/stable/api/#Transits.compute","content":" Transits.compute  —  Function compute(::AbstractLimbDark, b, r; kwargs...) Compute the relative flux for the given impact parameter  b  and radius ratio  r . The impact parameter is unitless. The radius ratio is given in terms of the host; e.g., if the companion is half the size of the host, r=0.5. source"},{"id":1072,"pagetitle":"API/Reference","title":"Transits.compute","ref":"/previews/PR43/Transits/stable/api/#Transits.compute-Tuple{AbstractLimbDark, Orbits.AbstractOrbit, Any, Any}","content":" Transits.compute  —  Method compute(::AbstractLimbDark, orbit::AbstractOrbit, t, r) Compute the relative flux by calculating the impact parameter at time  t  from the given orbit. The time needs to be compatible with the period of the orbit, nominally in days. Examples julia> using Orbits\n\njulia> ld = PolynomialLimbDark([0.4, 0.26]);\n\njulia> orbit = SimpleOrbit(period=3, duration=1);\n\njulia> ld(orbit, 0, 0.1) # primary egress\n0.9878664434953113\n\njulia> ld(orbit, 0.1, 0.1) # 0.1 d\n0.9879670695533511 this works effortlessly with libraries like  Unitful.jl julia> using Unitful\n\njulia> orbit = SimpleOrbit(period=3u\"d\", duration=3u\"hr\");\n\njulia> ld(orbit, 0u\"d\", 0.1)\n0.9878664434953113 source"},{"id":1073,"pagetitle":"API/Reference","title":"Gradients","ref":"/previews/PR43/Transits/stable/api/#Gradients","content":" Gradients Gradients and jacobians are integrated directly into  ChainRules.jl  via  frule s and  rrule s.  For most users, this just means using AD libraries like  ForwardDiff.jl  and  Zygote.jl  is effortless and fast . using Transits\nusing Zygote\n\nlightcurve(X) = compute(PolynomialLimbDark(X[3:end]), X[1], X[2])\ngrad(X) = lightcurve'(X) # Zygote gradient\ngrad([0.1, 0.1, 0.4, 0.26])\n\n# output\n4-element Vector{Float64}:\n  0.0004972185834858653\n -0.2419262730830416\n -0.0048107583897073185\n -0.0024501564976671724 To help demonstrate the logic behind these chain rules, here we derive a simple gradient function manually. using ChainRulesCore\n\nu_n = [0.4, 0.26]\nμ = 0.1\nror = 0.1\nX0 = [μ, ror, u_n...]\n\nfunction gradr(X)\n    ld, ld_pullback = rrule(PolynomialLimbDark, X[3:end])\n    f, f_pullback = rrule(compute, ld, X[1], X[2])\n\n    f̄ = one(eltype(X))\n    _, l̄d, b̄, r̄ = f_pullback(f̄)\n    _, ū_n = ld_pullback(l̄d)\n    return [b̄, r̄, ū_n...]\nend\n\ngradr([0.1, 0.1, 0.4, 0.26])\n\n# output\n4-element Vector{Float64}:\n  0.0004972185834858653\n -0.2419262730830416\n -0.0048107583897073185\n -0.0024501564976671724 For the most granular support for gradients and jacobians, peer into the depths of  polynomial/poly-grad.jl  and  polynomial/quad-grad.jl . These functions are not part of the public API and are not guaranteed any stability according to  semantic versioning ."},{"id":1074,"pagetitle":"API/Reference","title":"Distributions","ref":"/previews/PR43/Transits/stable/api/#Distributions","content":" Distributions"},{"id":1075,"pagetitle":"API/Reference","title":"Transits.Kipping13","ref":"/previews/PR43/Transits/stable/api/#Transits.Kipping13","content":" Transits.Kipping13  —  Type Kipping13() A non-informative prior for two-parameter limb-darkening coefficients using  triangular sampling  ( Kipping 2013 ). Examples julia> using StableRNGs; rng = StableRNG(10);\n\njulia> rand(rng, Kipping13())\n2-element Vector{Float64}:\n  0.3361047299132651\n -0.025681638815114587\n\njulia> rand(rng, Kipping13(), 5)\n2×5 Matrix{Float64}:\n 0.0621057   0.992689   1.77965    0.784055  0.186386\n 0.0659477  -0.236613  -0.795884  -0.187791  0.592194 References Kipping (2013) \"Efficient, uninformative sampling of limb darkening coefficients for two-parameter laws\" source"},{"id":1078,"pagetitle":"Benchmarks","title":"Benchmarks","ref":"/previews/PR43/Transits/stable/bench/#Benchmarks","content":" Benchmarks Transits.jl aims to be at least as fast as similar tools.  Limbdark.jl  is also written in Julia and  Agol  et al.  (2020)  showed it outperforms starry, PyTransit, and batman in both runtime speed and numerical accuracy. The following benchmarks are works in progress, but they already show a marginal improvement on the Limbdark.jl implementation."},{"id":1079,"pagetitle":"Benchmarks","title":"Setup","ref":"/previews/PR43/Transits/stable/bench/#Setup","content":" Setup Warning These benchmarks are works in progress The code can be found in  bench/ . You'll need to set up the environment yourself, including the installation of Limbdark.jl."},{"id":1080,"pagetitle":"Benchmarks","title":"Performance","ref":"/previews/PR43/Transits/stable/bench/#Performance","content":" Performance"},{"id":1081,"pagetitle":"Benchmarks","title":"Comparison with Limbdark.jl","ref":"/previews/PR43/Transits/stable/bench/#Comparison-with-Limbdark.jl","content":" Comparison with Limbdark.jl"},{"id":1082,"pagetitle":"Benchmarks","title":"References","ref":"/previews/PR43/Transits/stable/bench/#References","content":" References Agol, E.; Luger, R. and Foreman-Mackey, D. (2020).  Analytic Planetary Transit Light Curves and Derivatives for Stars with Polynomial Limb Darkening .  The Astronomical Journal  159 , 123 ,  arXiv:1908.03222 [astro-ph.EP] ."},{"id":1085,"pagetitle":"Getting Started","title":"Getting Started","ref":"/previews/PR43/Transits/stable/gettingstarted/#Getting-Started","content":" Getting Started"},{"id":1086,"pagetitle":"Getting Started","title":"Usage","ref":"/previews/PR43/Transits/stable/gettingstarted/#Usage","content":" Usage using Orbits\nusing Transits\n\norbit = SimpleOrbit(period=3, duration=1)\nu = [0.4, 0.26] # quad limb dark\nld = PolynomialLimbDark(u)\n\nt = range(-1, 1, length=1000) # days from t0\nrs = range(0, 0.2, length=10) # radius ratio\n\nfluxes = @. ld(orbit, t, rs')"},{"id":1087,"pagetitle":"Getting Started","title":"Integrated and Secondary Curves","ref":"/previews/PR43/Transits/stable/gettingstarted/#Integrated-and-Secondary-Curves","content":" Integrated and Secondary Curves IntegratedLimbDark  can be used to numerically integrate each light curve exposure in time ld = IntegratedLimbDark([0.4, 0.26])\norbit = SimpleOrbit(period=3, duration=1)\nt = range(-1, 1, length=1000)\ntexp = [0.1 0.2 0.3]\n# no extra calculations made\nflux = @. ld(orbit, t, 0.2)\n# use quadrature to find time-averaged flux for each t\nflux_int = @. ld(orbit, t, 0.2, texp) SecondaryLimbDark  can be used to generate secondary eclipses given a surface brightness ratio ld = SecondaryLimbDark([0.4, 0.26], brightness_ratio=0.1)\nld_int = IntegratedLimbDark(ld) # composition works flawlessly\n\norbit = SimpleOrbit(period=4, duration=1)\nt = range(-1.25, 2.75, length=1000)\nrs = range(0.01, 0.1, length=6)\n\nf = @. ld(orbit, t, rs')\nf_int = @. ld_int(orbit, t, rs', texp=0.3)"},{"id":1088,"pagetitle":"Getting Started","title":"Using Units","ref":"/previews/PR43/Transits/stable/gettingstarted/#Using-Units","content":" Using Units Units from  Unitful.jl  are a drop-in substitution for numbers using Unitful\norbit = SimpleOrbit(period=10u\"d\", duration=5u\"hr\")\nt = range(-6, 6, length=1000)u\"hr\"\nflux = @. ld(orbit, t, 0.1)"},{"id":1089,"pagetitle":"Getting Started","title":"Gradients","ref":"/previews/PR43/Transits/stable/gettingstarted/#Gradients","content":" Gradients Gradients are provided in the form of  chain rules . The easiest way to access them is using an automatic differentiation (AD) library like  ForwardDiff.jl  or  Zygote.jl . using Zygote\n\nts = range(-1, 1, length=1000) # days from t0\nror = 0.1\nu_n = [0.4, 0.26]\n\norbit = SimpleOrbit(period=3, duration=1)\nlightcurve(X) = compute(PolynomialLimbDark(X[3:end]), orbit, X[1], X[2])\n\n# use Zygote for gradient\nflux = [lightcurve([t, ror, u_n...]) for t in ts]\ngrads = mapreduce(hcat, ts) do t\n    grad = lightcurve'([t, ror, u_n...])\n    return grad === nothing ? zeros(4) : grad\nend"},{"id":1092,"pagetitle":"Introduction","title":"Introduction","ref":"/previews/PR43/Transits/stable/introduction/#Introduction","content":" Introduction"},{"id":1093,"pagetitle":"Introduction","title":"Historical overview","ref":"/previews/PR43/Transits/stable/introduction/#Historical-overview","content":" Historical overview Transit light curves are an essential tool used for the detection of  exoplanets . To date, there have been over 4,300 confirmed planets discovered in over 3,400 different star systems, with an additional 2,400 candidates currently awaiting follow-up analysis and validation. [1]  Since the first confirmed discovery of an exoplanet – as part of a multi-planetary system in 1992 ( Wolszczan and Frail, 1992 ), and the first exoplanet discovered around a Sun-like star shortly after in 1995 ( Mayor and Queloz, 1995 ) – there has been an explosion in new discoveries, thanks in large part to the successful  Kepler/K2  and  TESS  space missions. The large majority of these planets have been detected via the  transit method : Exoplanet Archive"},{"id":1094,"pagetitle":"Introduction","title":"Transit method","ref":"/previews/PR43/Transits/stable/introduction/#Transit-method","content":" Transit method This method works by observing the dimming in apparent brightness of a star as a planet passes in front of it from our point of view. The plot of the star's brightness as a function of time defines the  white light curve  as seen in the schematic below: \"How Do You Find an Exoplanet?\" by John Asher Johnson Even just starting with a simple single planet system in a circular orbit, there is already a wealth of information encoded in this diagram. These observations give us insight not only into the bulk properties of the planet, but into the architecture of its orbital system and characteristics of its host star as well. For example,  direct observables  from the light curve like the  transit duration $(T)$  and  ingress/egress  time  $(\\tau)$  give us information about how tilted its orbit is and how fast the planet is traveling, while the  transit depth $(\\delta)$  gives us a direct measure of the size of the planet relative to its star. For circular orbits, these are nicely summarized by: \\[\\begin{aligned}\n\\frac{R_\\text{p}}{R_*} &= \\delta^{1/2} \\\\\n\nb^2 &= 1 - \\delta^{1/2}\\frac{T}{t} \\\\\n\n\\frac{a}{R_*} &= \\frac{P\\delta^{1/4}}{2\\pi}\n\\left(\\frac{4}{T\\tau}\\right)^{1/2} \\\\\n\n\\rho_* &= \\frac{3P}{G\\pi^2}\\left(\\frac{\\delta^{1/4}}{\\sqrt{T\\tau}}\\right)^3 \\quad,\n\\end{aligned}\\] where  $P$  is the period of the planet's orbit and  $a$  its semi-major axis,  $b$  is the impact parameter,  $R_*$  is the radius of its star, and  $\\rho_*$  is the stellar density."},{"id":1095,"pagetitle":"Introduction","title":"Limb darkening","ref":"/previews/PR43/Transits/stable/introduction/#Limb-darkening","content":" Limb darkening Not shown above is an added dimension that  Transits.jl  excels in,  limb darkening , demonstrated in the schematic below: ASTR 236 class notes This effect is intimately related to the shape of the light curve, and allows us to constrain the brightness profile of the star itself. As we will see next, the method of transit light curves is not just useful for the detection of exoplanets, but also for taking it to the next step of characterizing its atmosphere."},{"id":1096,"pagetitle":"Introduction","title":"Transmission spectroscopy","ref":"/previews/PR43/Transits/stable/introduction/#Transmission-spectroscopy","content":" Transmission spectroscopy If we perform the technique of transit light curve modeling on a wavelength-by-wavelength basis, we can further probe the properties of the host star and begin to make predictions about the properties of the planet's atmosphere, such as its chemical composition and whether clouds/hazes are likely to be present at higher altitudes. This analysis begins in the same way as with the white light curve seen above, only now a  wavelength binned light curve  is measured at a range of different wavelengths:  Adapted from Weaver et al. (2021,  submitted ) Plotting these wavelength dependent transit depths then builds a  transmission spectrum , which is filled with information about the planet's atmosphere and its star, summarized below: Benneke and Seager (2012) Rackham  et al.  (2018) Performing forward modeling (see, e.g.,  Kempton  et al.  (2017) ,  Goyal  et al.  (2018) ) and retrievals (see, e.g.,  Barstow  et al.  (2020)  and references therein) using these frameworks then allows us to explore exoplanetary atmospheres in never before seen detail."},{"id":1097,"pagetitle":"Introduction","title":"Summary","ref":"/previews/PR43/Transits/stable/introduction/#Summary","content":" Summary The detection and characterization of exoplanets through their transit light curves is a relatively new technique in the field of astronomy, with recent advances only being made possible through novel uses of large, ground-based telescopes and soon in the future with planned  ELTs  and space based missions like  JWST . Studies using these observing facilities will require the fast and precise computation of transit light curves, which  Transits.jl  aims to provide."},{"id":1098,"pagetitle":"Introduction","title":"Footnotes and references","ref":"/previews/PR43/Transits/stable/introduction/#Footnotes-and-references","content":" Footnotes and references Barstow, J. K.; Changeat, Q.; Garland, R.; Line, M. R.; Rocchetto, M. and Waldmann, I. P. (2020).  A comparison of exoplanet spectroscopic retrieval tools .  Monthly Notices of the Royal Astronomical Society  493 , 4884–4909 ,  arXiv:2002.01063 [astro-ph.EP] . Benneke, B. and Seager, S. (2012).  Atmospheric Retrieval for Super-Earths: Uniquely Constraining the Atmospheric Composition with Transmission Spectroscopy .  The Astrophysical Journal  753 , 100 ,  arXiv:1203.4018 [astro-ph.EP] . Goyal, J. M.; Mayne, N.; Sing, D. K.; Drummond, B.; Tremblin, P.; Amundsen, D. S.; Evans, T.; Carter, A. L.; Spake, J.; Baraffe, I.; Nikolov, N.; Manners, J.; Chabrier, G. and Hebrard, E. (2018).  A library of ATMO forward model transmission spectra for hot Jupiter exoplanets .  Monthly Notices of the Royal Astronomical Society  474 , 5158–5185 ,  arXiv:1710.10269 [astro-ph.EP] . Johnson, J. (2015).  How Do You Find an Exoplanet? Princeton Frontiers in Physics  (Princeton University Press). Kempton, E. M.-R.; Lupu, R.; Owusu-Asare, A.; Slough, P. and Cale, B. (2017).  Exo-Transmit: An Open-Source Code for Calculating Transmission Spectra for Exoplanet Atmospheres of Varied Composition .  Publications of the Astronomical Society of the Pacific  129 , 044402 ,  arXiv:1611.03871 [astro-ph.EP] . Mayor, M. and Queloz, D. (1995).  A Jupiter-mass companion to a solar-type star .  Nature  378 , 355–359 . Rackham, B. V.; Apai, D. and Giampapa, M. S. (2018).  The Transit Light Source Effect: False Spectral Features and Incorrect Densities for M-dwarf Transiting Planets .  The Astrophysical Journal  853 , 122 ,  arXiv:1711.05691 [astro-ph.EP] . Wolszczan, A. and Frail, D. (1992).  A planetary system around the millisecond pulsar PSR1257 + 12 .  Nature  355 , 145–147 . 1 https://exoplanetarchive.ipac.caltech.edu/"},{"id":1101,"pagetitle":"Home","title":"EarthOrientation.jl","ref":"/previews/PR43/EarthOrientation/stable/#EarthOrientation.jl","content":" EarthOrientation.jl Calculate Earth orientation parameters from IERS tables in Julia."},{"id":1102,"pagetitle":"Home","title":"Installation","ref":"/previews/PR43/EarthOrientation/stable/#Installation","content":" Installation The package can be installed through Julia's package manager: Pkg.add(\"EarthOrientation\")"},{"id":1103,"pagetitle":"Home","title":"Quickstart","ref":"/previews/PR43/EarthOrientation/stable/#Quickstart","content":" Quickstart Fetch the latest [IERS][iers-link] tables: using EarthOrientation\nEarthOrientation.update() Get the current Earth orientation parameters, e.g. for polar motion: xp, yp = polarmotion(now()) # arcseconds Or the current difference between UT1 and UTC and the associated prediction error: ΔUT1 = getΔUT1(now()) # seconds\nΔUT1_err = getΔUT1_err(now()) # seconds"},{"id":1104,"pagetitle":"Home","title":"Available data","ref":"/previews/PR43/EarthOrientation/stable/#Available-data","content":" Available data Polar motion: x-coordinate of Earth's north pole:  getxp y-coordinate of Earth's north pole:  getyp both:  polarmotion Earth rotation Difference between UT1 and UTC:  getΔUT1 Difference between UT1 and TAI:  getΔUT1_TAI Excess length of day:  getlod Precession and nutation based on the 1980 IAU conventions Correction to the nutation of the ecliptic:  getdψ Correction to the obliquity of the ecliptic:  getdϵ both:  precession_nutation80 Precession and nutation based on the 2000 IAU conventions Correction to the celestial pole's x-coordinate:  getdx Correction to the celestial pole's y-coordinate:  getdy both:  precession_nutation00 There is an associated function that returns the prediction error for each data type, e.g.  getxp_err ."},{"id":1105,"pagetitle":"Home","title":"Manual Data Management","ref":"/previews/PR43/EarthOrientation/stable/#Manual-Data-Management","content":" Manual Data Management By default the files downloaded by  EarthOrientation.update()  will be used. It is also possible to pass different  finals.all  and  finals2000A.all  files in CSV format. using EarthOrientation\n\npush!(EOP_DATA, \"finals.csv\", \"finals2000A.csv\")"},{"id":1108,"pagetitle":"API","title":"API","ref":"/previews/PR43/EarthOrientation/stable/api/#API","content":" API"},{"id":1109,"pagetitle":"API","title":"EarthOrientation.EOParams","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.EOParams-Tuple{String,String}","content":" EarthOrientation.EOParams  —  Method EOParams(iau1980file::String, iau2000file::String) Parse IERS data files into a  EOParams  object.  iau1980file  and  iau2000file  are the paths to a 'finals.all' and a 'finals2000A.all' CSV file, respectively. source"},{"id":1110,"pagetitle":"API","title":"EarthOrientation.getdx","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getdx-Tuple{Any,Any}","content":" EarthOrientation.getdx  —  Method getdx(date; outside_range=:warn) Get the celestial pole x-coordinate correction for a certain  date  in milliarcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1111,"pagetitle":"API","title":"EarthOrientation.getdx_err","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getdx_err-Tuple{Any,Any}","content":" EarthOrientation.getdx_err  —  Method getdx_err(date; outside_range=:warn) Get the error in celestial pole x-coordinate correction for a certain  date  in milliarcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1112,"pagetitle":"API","title":"EarthOrientation.getdy","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getdy-Tuple{Any,Any}","content":" EarthOrientation.getdy  —  Method getdy(date; outside_range=:warn) Get the celestial pole y-coordinate correction for a certain  date  in milliarcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1113,"pagetitle":"API","title":"EarthOrientation.getdy_err","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getdy_err-Tuple{Any,Any}","content":" EarthOrientation.getdy_err  —  Method getdy_err(date; outside_range=:warn) Get the error in celestial pole y-coordinate correction for a certain  date  in milliarcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1114,"pagetitle":"API","title":"EarthOrientation.getdψ","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getdψ-Tuple{Any,Any}","content":" EarthOrientation.getdψ  —  Method getdψ(date; outside_range=:warn) Get the ecliptic nutation correction for a certain  date  in milliarcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1115,"pagetitle":"API","title":"EarthOrientation.getdψ_err","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getdψ_err-Tuple{Any,Any}","content":" EarthOrientation.getdψ_err  —  Method getdψ_err(date; outside_range=:warn) Get the error in the ecliptic nutation correction for a certain  date  in milliarcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1116,"pagetitle":"API","title":"EarthOrientation.getdϵ","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getdϵ-Tuple{Any,Any}","content":" EarthOrientation.getdϵ  —  Method getdϵ(date; outside_range=:warn) Get the ecliptic obliquity correction for a certain  date  in milliarcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1117,"pagetitle":"API","title":"EarthOrientation.getdϵ_err","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getdϵ_err-Tuple{Any,Any}","content":" EarthOrientation.getdϵ_err  —  Method getdϵ_err(date; outside_range=:warn) Get the error in the ecliptic obliquity correction for a certain  date  in milliarcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1118,"pagetitle":"API","title":"EarthOrientation.getlod","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getlod-Tuple{Any,Any}","content":" EarthOrientation.getlod  —  Method getlod(date; outside_range=:warn) Get the excess length of day for a certain  date  in milliseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1119,"pagetitle":"API","title":"EarthOrientation.getlod_err","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getlod_err-Tuple{Any,Any}","content":" EarthOrientation.getlod_err  —  Method getlod_err(date; outside_range=:warn) Get the error in the excess length of day for a certain  date  in milliseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1120,"pagetitle":"API","title":"EarthOrientation.getxp","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getxp-Tuple{Any,Any}","content":" EarthOrientation.getxp  —  Method getxp(date; outside_range=:warn) Get the x-coordinate of Earth's north pole w.r.t. the CIO for a certain  date  in arcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1121,"pagetitle":"API","title":"EarthOrientation.getxp_err","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getxp_err-Tuple{Any,Any}","content":" EarthOrientation.getxp_err  —  Method getxp_err(date; outside_range=:warn) Get the error for the x-coordinate of Earth's north pole w.r.t. the CIO for a certain  date  in arcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1122,"pagetitle":"API","title":"EarthOrientation.getyp","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getyp-Tuple{Any,Any}","content":" EarthOrientation.getyp  —  Method getyp(date; outside_range=:warn) Get the y-coordinate of Earth's north pole w.r.t. the CIO for a certain  date  in arcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1123,"pagetitle":"API","title":"EarthOrientation.getyp_err","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getyp_err-Tuple{Any,Any}","content":" EarthOrientation.getyp_err  —  Method getyp_err(date; outside_range=:warn) Get the error for the y-coordinate of Earth's north pole w.r.t. the CIO for a certain  date  in arcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1124,"pagetitle":"API","title":"EarthOrientation.getΔUT1","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getΔUT1-Tuple{Any,Any}","content":" EarthOrientation.getΔUT1  —  Method getΔUT1(date; outside_range=:warn) Get the difference between UTC and UT1 for a certain  date  in seconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1125,"pagetitle":"API","title":"EarthOrientation.getΔUT1_TAI","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getΔUT1_TAI-Tuple{Any,Any}","content":" EarthOrientation.getΔUT1_TAI  —  Method getΔUT1_TAI(date; outside_range=:warn) Get the difference between TAI and UT1 for a certain  date  in seconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1126,"pagetitle":"API","title":"EarthOrientation.getΔUT1_err","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.getΔUT1_err-Tuple{Any,Any}","content":" EarthOrientation.getΔUT1_err  —  Method getΔUT1_err(date; outside_range=:warn) Get the error in the difference between UTC and UT1 for a certain  date  in seconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1127,"pagetitle":"API","title":"EarthOrientation.polarmotion","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.polarmotion-Tuple{Any,Any}","content":" EarthOrientation.polarmotion  —  Method polarmotion(date; outside_range=:warn) Get the coordinates of Earth's north pole w.r.t. the CIO for a certain  date  in arcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1128,"pagetitle":"API","title":"EarthOrientation.precession_nutation00","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.precession_nutation00-Tuple{Any,Any}","content":" EarthOrientation.precession_nutation00  —  Method precession_nutation00(date; outside_range=:warn) Get the celestial pole coordinate corrections for a certain  date  in milliarcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1129,"pagetitle":"API","title":"EarthOrientation.precession_nutation80","ref":"/previews/PR43/EarthOrientation/stable/api/#EarthOrientation.precession_nutation80-Tuple{Any,Any}","content":" EarthOrientation.precession_nutation80  —  Method precession_nutation80(date; outside_range=:warn) Get the ecliptic corrections for a certain  date  in milliarcseconds. date  can either be a  DateTime  object or a Julian date represented by a number. The  outside_range  argument determines what to do if no data is available for  date : :warn : The last valid value is returned and a warning will be displayed. :nothing : The last valid value is returned. :error : An  OutOfRangeError  is thrown. source"},{"id":1132,"pagetitle":"Internals","title":"Internals","ref":"/previews/PR43/EarthOrientation/stable/internals/#Internals","content":" Internals"},{"id":1133,"pagetitle":"Internals","title":"EarthOrientation.getdate","ref":"/previews/PR43/EarthOrientation/stable/internals/#EarthOrientation.getdate-Tuple{Any}","content":" EarthOrientation.getdate  —  Method getdate(data) Determine the creation date of an IERS table by finding the last entry which is marked as \"final\". source"},{"id":1134,"pagetitle":"Internals","title":"EarthOrientation.update","ref":"/previews/PR43/EarthOrientation/stable/internals/#EarthOrientation.update-Tuple{}","content":" EarthOrientation.update  —  Method update(; force=false) Download weekly EOP data from the IERS servers if newer files are available or no data has been downloaded previously. If the keyword  force  is  true , then all the files will be downloaded again. source"},{"id":1139,"pagetitle":"Tutorial","title":"Tutorial","ref":"/previews/PR43/EarthOrientation/stable/tutorial/#Tutorial","content":" Tutorial EarthOrientation.jl  downloads, parses, and interpolates weekly-updated tables from the  IERS  that contain the following Earth Orientation Parameters (EOP): Polar motion: x-coordinate of Earth's north pole:  $x_p$ y-coordinate of Earth's north pole:  $y_p$ Earth rotation Difference between UT1 and UTC:  $\\Delta UT1$ Excess length of day:  $LOD$ Precession and nutation based on the 1980 IAU conventions Correction to the nutation of the ecliptic:  $d\\psi$ Correction to the obliquity of the ecliptic:  $d\\epsilon$ Precession and nutation based on the 2000 IAU conventions Correction to the celestial pole's x-coordinate:  $dx$ Correction to the celestial pole's y-coordinate:  $dy$ These parameters are required for precise transformations between quasi-inertial and rotating terrestrial reference frames."},{"id":1140,"pagetitle":"Tutorial","title":"Getting Earth Orientation Data","ref":"/previews/PR43/EarthOrientation/stable/tutorial/#Getting-Earth-Orientation-Data","content":" Getting Earth Orientation Data When the package is imported for the first time the required data will be automatically downloaded from the IERS servers. After that the data needs to be updated manually like shown below. using EarthOrientation\nEarthOrientation.update()"},{"id":1141,"pagetitle":"Tutorial","title":"Loading Earth Orientation Data","ref":"/previews/PR43/EarthOrientation/stable/tutorial/#Loading-Earth-Orientation-Data","content":" Loading Earth Orientation Data The downloaded data is parsed into an  EOParams  object: eop = EOParams() By default the files downloaded by  EarthOrientation.update()  will be used. It is also possible to manually pass the required  finals.all  and  finals2000A.all  files in CSV format. eop = EOParams(\"finals.csv\", \"finals2000A.csv\") This is useful if the data should not be managed by  EarthOrientation.jl  but by a different system instead."},{"id":1142,"pagetitle":"Tutorial","title":"Interpolating Earth Orientation Data","ref":"/previews/PR43/EarthOrientation/stable/tutorial/#Interpolating-Earth-Orientation-Data","content":" Interpolating Earth Orientation Data Get the current Earth orientation parameters, e.g. for polar motion: xp, yp = polarmotion(eop, now()) # arcseconds Or the current difference between UT1 and UTC and the associated prediction error: ΔUT1 = getΔUT1(eop, now()) # seconds\nΔUT1_err = getΔUT1_err(eop, now()) # milliseconds"},{"id":1145,"pagetitle":"Introduction","title":"AstroLib.jl","ref":"/previews/PR43/AstroLib/stable/#AstroLib.jl","content":" AstroLib.jl AstroLib  is a package of small generic routines useful above all in astronomical and astrophysical context, written in  Julia . Included are also translations of some  IDL Astronomy User’s Library  procedures, which are released under terms of  BSD-2-Clause License . AstroLib’s functions are not drop-in replacement of those procedures, Julia standard data types are often used (e.g.,  DateTime  type instead of generic string for dates) and the syntax may slightly differ. An extensive error testing suite ensures old fixed bugs will not be brought back by future changes."},{"id":1146,"pagetitle":"Introduction","title":"Installation","ref":"/previews/PR43/AstroLib/stable/#Installation","content":" Installation AstroLib is available for Julia 1.0 and later versions, and can be installed with  Julia 's built-in package manager. In a Julia session run the commands julia> import Pkg\njulia> Pkg.update()\njulia> Pkg.add(\"AstroLib\") Older versions are also available for Julia 0.4-0.6. Note that, in order to work, a few functions require external files, which are automatically downloaded when building the package. Should these files be missing for some reason, you will be able to load the package but some functions may not work properly. You can manually build the package with julia> Pkg.build(\"AstroLib\")"},{"id":1147,"pagetitle":"Introduction","title":"Usage","ref":"/previews/PR43/AstroLib/stable/#Usage","content":" Usage After installing the package, you can start using AstroLib with using AstroLib Many functions in  AstroLib.jl  are compatible with  Measurements.jl  package, which allows you to define quantities with uncertainty and propagate the error when performing calculations according to  propagation of uncertainty rules . For example: julia> using AstroLib, Measurements\n\njulia> mag2flux(12.54 ± 0.03)\n3.499e-14 ± 9.7e-16"},{"id":1148,"pagetitle":"Introduction","title":"How Can I Help?","ref":"/previews/PR43/AstroLib/stable/#How-Can-I-Help?","content":" How Can I Help? AstroLib.jl  is developed on  GitHub . You can contribute to the project in a number of ways: by translating more routines from IDL Astronomy User’s Library, or providing brand-new functions, or even improving existing ones (make them faster and more precise). Also bug reports are encouraged."},{"id":1149,"pagetitle":"Introduction","title":"License","ref":"/previews/PR43/AstroLib/stable/#License","content":" License The  AstroLib.jl  package is licensed under the MIT “Expat” License. The original author is Mosè Giordano."},{"id":1150,"pagetitle":"Introduction","title":"Notes","ref":"/previews/PR43/AstroLib/stable/#Notes","content":" Notes This project is a work-in-progress, only few procedures have been translated so far. In addition, function syntax may change from time to time. Check  TODO.md  out to see how you can help. Volunteers are welcome!"},{"id":1151,"pagetitle":"Introduction","title":"Documentation","ref":"/previews/PR43/AstroLib/stable/#Documentation","content":" Documentation Every function provided has detailed documentation that can be  accessed  at Julia REPL with julia> ?FunctionName or with julia> @doc FunctionName"},{"id":1152,"pagetitle":"Introduction","title":"Related Projects","ref":"/previews/PR43/AstroLib/stable/#Related-Projects","content":" Related Projects This is not the only effort to bundle astronomical functions written in Julia language. Other packages useful for more specific purposes are available at  JuliaAstro . Because of this, some of IDL AstroLib’s utilities are not provided in  AstroLib.jl  as they are already present in other Julia packages. Here is a list of such utilities: aper , see  Photometry.jl  package asinh , already present in Julia with the same name cirrange , it is equivalent to  mod(x, 360) .  To restrict a number to the   range  [0, 2pi)  use  mod2pi(x) cosmo_param , see  Cosmology.jl  package galage , see  Cosmology.jl  package glactc_pm , see  SkyCoords.jl  package glactc , see  SkyCoords.jl  package jplephinterp , see  JPLEphemeris.jl  package jplephread , see  JPLEphemeris.jl  package jplephtest , see  JPLEphemeris.jl  package lumdist , see  Cosmology.jl  package readcol , use  readdlm , part of Julia  Base.DataFmt  module. This is not a complete replacement for  readcol  but most of the time it does-the-right-thing even without using any option (it automatically identifies string and numerical columns) and you do not need to manually specify a variable for each column In addition, there are similar projects for Python ( Python AstroLib ) and R ( Astronomy Users Library )."},{"id":1155,"pagetitle":"Reference","title":"Reference","ref":"/previews/PR43/AstroLib/stable/ref/#Reference","content":" Reference"},{"id":1156,"pagetitle":"Reference","title":"Data types","ref":"/previews/PR43/AstroLib/stable/ref/#Data-types","content":" Data types"},{"id":1157,"pagetitle":"Reference","title":"Observatory","ref":"/previews/PR43/AstroLib/stable/ref/#Observatory","content":" Observatory AstroLib.jl  defines a new  Observatory  type. This can be used to define a new object holding information about an observing site. It is a  composite type  whose fields are name  ( String  type): the name of the site latitude  ( Float64  type): North-ward latitude of the site in degrees longitude  ( Float64  type): East-ward longitude of the site in degrees altitude  ( Float64  type): altitude of the site in meters tz  ( Float64  type): the number of hours of offset from UTC The type constructor  Observatory  can be used to create a new  Observatory  object. Its syntax is Observatory(name, lat, long, alt, tz) name  should be a string;  lat ,  long , and  tz  should be anything that can be converted to a floating number with  ten  function;  alt  should be a real number. A predefined list of some observing sites is provided with  AstroLib.observatories  constant. It is a dictionary whose keys are the abbreviated names of the observatories. For example, you can access information of the European Southern Observatory with julia> obs = AstroLib.observatories[\"eso\"]\nObservatory: European Southern Observatory\nlatitude:    -29.256666666666668°N\nlongitude:   -70.73°E\naltitude:    2347.0 m\ntime zone:   UTC-4\n\njulia> obs.longitude\n-70.73 You can list all keys of the dictionary with keys(AstroLib.observatories) Feel free to contribute new sites or adjust information of already present ones."},{"id":1158,"pagetitle":"Reference","title":"Planet","ref":"/previews/PR43/AstroLib/stable/ref/#Planet","content":" Planet The package provides  Planet  type to hold information about Solar System planets. Its fields are Designation: name : the name Physical characteristics: radius : mean radius in meters eqradius : equatorial radius in meters polradius : polar radius in meters mass : mass in kilogram Orbital characteristics (epoch J2000): ecc : eccentricity of the orbit axis : semi-major axis of the orbit in meters period : sidereal orbital period in seconds The constructor has this syntax: Planet(name, radius, eqradius, polradius, mass, ecc, axis, period) The list of Solar System planets, from Mercury to Pluto, is available with  AstroLib.planets  dictionary. The keys of this dictionary are the lowercase names of the planets. For example: julia> AstroLib.planets[\"mercury\"]\nPlanet:                      Mercury\nmean radius:                 2.4397e6 m\nequatorial radius:           2.4397e6 m\npolar radius:                2.4397e6 m\nmass:                        3.3011e23 kg\neccentricity:                0.20563593\nsemi-major axis:             5.790922654152439e10 m\nperiod:                      7.60053024e6 s\ninclination:                 7.00497902 °\nlongitude of ascending node: 48.33076593 °\nlongitude of perihelion:     77.45779628 °\nmean longitude:              252.2503235 °\n\njulia> AstroLib.planets[\"mars\"].eqradius\n3.3962e6\n\njulia> AstroLib.planets[\"saturn\"].mass\n5.6834e26"},{"id":1159,"pagetitle":"Reference","title":"Functions organized by category","ref":"/previews/PR43/AstroLib/stable/ref/#Functions-organized-by-category","content":" Functions organized by category"},{"id":1160,"pagetitle":"Reference","title":"Coordinates and positions","ref":"/previews/PR43/AstroLib/stable/ref/#Coordinates-and-positions","content":" Coordinates and positions adstring() aitoff() altaz2hadec() baryvel() bprecess() co_aberration() co_nutate() co_refract() eci2geo() eq2hor() eqpole() euler() gcirc() geo2eci() geo2geodetic() geo2mag() geodetic2geo() hadec2altaz() helio_rv() helio() hor2eq() jprecess() mag2geo() mean_obliquity() planet_coords() polrec() posang() precess() precess_cd() precess_xyz() premat() radec() recpol() true_obliquity() zenpos()"},{"id":1161,"pagetitle":"Reference","title":"Time and date","ref":"/previews/PR43/AstroLib/stable/ref/#Time-and-date","content":" Time and date ct2lst() daycnv() get_date() get_juldate() helio_jd() jdcnv() juldate() month_cnv() nutate() ydn2md() ymd2dn()"},{"id":1162,"pagetitle":"Reference","title":"Moon and sun","ref":"/previews/PR43/AstroLib/stable/ref/#Moon-and-sun","content":" Moon and sun moonpos() mphase() sunpos() xyz()"},{"id":1163,"pagetitle":"Reference","title":"Utilities","ref":"/previews/PR43/AstroLib/stable/ref/#Utilities","content":" Utilities airtovac() calz_unred() deredd() flux2mag() gal_uvw() imf() ismeuv() kepler_solver() lsf_rotate() mag2flux() paczynski() planck_freq() planck_wave() rad2sec() rhotheta() sec2rad() sixty() sphdist() ten() tic_one() ticpos() tics() trueanom() uvbybeta() vactoair()"},{"id":1164,"pagetitle":"Reference","title":"Miscellaneous (non-astronomy) functions","ref":"/previews/PR43/AstroLib/stable/ref/#Miscellaneous-(non-astronomy)-functions","content":" Miscellaneous (non-astronomy) functions ordinal()"},{"id":1165,"pagetitle":"Reference","title":"Types and functions organized alphabetically","ref":"/previews/PR43/AstroLib/stable/ref/#Types-and-functions-organized-alphabetically","content":" Types and functions organized alphabetically"},{"id":1166,"pagetitle":"Reference","title":"AstroLib.POLELATLONG","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.POLELATLONG","content":" AstroLib.POLELATLONG  —  Constant List of locations of North Magnetic Pole since 1590. This is provided by World Magnetic Model (https://www.ngdc.noaa.gov/geomag/data/poles/NP.xy). source"},{"id":1167,"pagetitle":"Reference","title":"AstroLib.observatories","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.observatories","content":" AstroLib.observatories  —  Constant List of observing sites.  The observatories have  Observatory  type. source"},{"id":1168,"pagetitle":"Reference","title":"AstroLib.planets","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.planets","content":" AstroLib.planets  —  Constant List of planets of the Solar System, from Mercury to Pluto.  The elements of the list have  Planet  type. Reference for most quantities is the Planetary Fact Sheet: http://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html and the Keplerian Elements for Approximate Positions of the Major Planets: https://ssd.jpl.nasa.gov/txt/p elem t1.txt source"},{"id":1169,"pagetitle":"Reference","title":"AstroLib.Observatory","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.Observatory","content":" AstroLib.Observatory  —  Type Type holding information about an observing site.  Its fields are: name : the name of the site latitude : North-ward latitude of the site in degrees longitude : East-ward longitude of the site in degrees altitude : altitude of the site in meters tz : the number of hours of offset from UTC source"},{"id":1170,"pagetitle":"Reference","title":"AstroLib.Planet","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.Planet","content":" AstroLib.Planet  —  Type Type holding information about a planet.  Its fields are: Designation: name : the name Physical characteristics: radius : mean radius in meters eqradius : equatorial radius in meters polradius : polar radius in meters mass : mass in kilogram Orbital characteristics (epoch J2000): ecc : eccentricity of the orbit axis : semi-major axis of the orbit in meters period : sidereal orbital period in seconds Position characteristics (epoch J2000): inc : inclination in degrees asc_long : longitude of the ascending node in degrees per_long : longitude of perihelion in degrees mean_long : mean longitude in degrees source"},{"id":1171,"pagetitle":"Reference","title":"AstroLib.adstring","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.adstring-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractFloat","content":" AstroLib.adstring  —  Method adstring(ra::Real, dec::Real[, precision::Int=2, truncate::Bool=true]) -> string\nadstring([ra, dec]) -> string\nadstring(dec) -> string\nadstring([ra], [dec]) -> [\"string1\", \"string2\", ...] Purpose Returns right ascension and declination as string(s) in sexagesimal format. Explanation Takes right ascension and declination expressed in decimal format, converts them to sexagesimal and return a formatted string.  The precision of right ascension and declination can be specified. Arguments Arguments of this function are: ra : right ascension in decimal degrees.  It is converted to hours before printing. dec : declination in decimal degrees. The function can be called in different ways: Two numeric arguments: first is  ra , the second is  dec . An iterable (array, tuple) of two elements:  (ra, dec) . One numeric argument: it is assumed only  dec  is provided. Optional keywords affecting the output format are always available: precision  (optional integer keyword): specifies the number of digits of declination seconds.  The number of digits for right ascension seconds is always assumed to be one more  precision .  If the function is called with only  dec  as input,  precision  default to 1, in any other case defaults to 0. truncate  (optional boolean keyword): if true, then the last displayed digit in the output is truncated in precision rather than rounded.  This option is useful if  adstring  is used to form an official IAU name (see http://vizier.u-strasbg.fr/Dic/iau-spec.htx) with coordinate specification. Output The function returns one string.  The format of strings can be specified with  precision  and  truncate  keywords, see above. Example julia> using AstroLib\n\njulia> adstring(30.4, -1.23, truncate=true)\n\" 02 01 35.9  -01 13 48\"\n\njulia> adstring.([30.4, -15.63], [-1.23, 48.41], precision=1)\n2-element Vector{String}:\n \" 02 01 36.00  -01 13 48.0\"\n \" 22 57 28.80  +48 24 36.0\" source"},{"id":1172,"pagetitle":"Reference","title":"AstroLib.airtovac","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.airtovac-Tuple{Real}","content":" AstroLib.airtovac  —  Method airtovac(wave_air) -> wave_vacuum Purpose Converts air wavelengths to vacuum wavelengths. Explanation Wavelengths are corrected for the index of refraction of air under standard conditions. Wavelength values below  $2000 Å$  will  not  be altered, take care within  $[1 Å, 2000 Å]$ .  Uses relation of Ciddor (1996). Arguments wave_air : the wavelength in air. Output Vacuum wavelength in angstroms. Method Uses relation of Ciddor (1996), Applied Optics 62, 958. Example If the air wavelength is  w = 6056.125  (a Krypton line), then  airtovac(w)  yields a vacuum wavelength of  6057.8019 . julia> using AstroLib\n\njulia> airtovac(6056.125)\n6057.801930991426 Notes vactoair  converts vacuum wavelengths to air wavelengths. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1173,"pagetitle":"Reference","title":"AstroLib.aitoff","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.aitoff-Tuple{Real, Real}","content":" AstroLib.aitoff  —  Method aitoff(l, b) -> x, y Purpose Convert longitude  l  and latitude  b  to  (x, y)  using an Aitoff projection. Explanation This function can be used to create an all-sky map in Galactic coordinates with an equal-area Aitoff projection.  Output map coordinates are zero longitude centered. Arguments l : longitude, scalar or vector, in degrees. b : latitude, number of elements as  l , in degrees. Coordinates can be given also as a 2-tuple  (l, b) . Output 2-tuple  (x, y) . x : x coordinate, same number of elements as  l .   x  is normalized to be in  $[-180, 180]$ . y : y coordinate, same number of elements as  l .   y  is normalized to be in  $[-90, 90]$ . Example Get  $(x ,y)$  Aitoff coordinates of Sirius, whose Galactic coordinates are  $(227.23, -8.890)$ . julia> using AstroLib\n\njulia> x, y = aitoff(227.23, -8.890)\n(-137.92196683723276, -11.772527357473054) Notes See  AIPS memo No. 46 , page 4, for details of the algorithm.  This version of  aitoff  assumes the projection is centered at  b=0  degrees. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1174,"pagetitle":"Reference","title":"AstroLib.altaz2hadec","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.altaz2hadec-Tuple{Real, Real, Real}","content":" AstroLib.altaz2hadec  —  Method altaz2hadec(alt, az, lat) -> ha, dec Purpose Convert Horizon (Alt-Az) coordinates to Hour Angle and Declination. Explanation Can deal with the NCP singularity.  Intended mainly to be used by program  hor2eq . Arguments Input coordinates may be either a scalar or an array, of the same dimension. alt : local apparent altitude, in degrees, scalar or array. az : the local apparent azimuth, in degrees, scalar or vector, measured  east  of  north !!!  If you have measured azimuth west-of-south (like the book Meeus does), convert it to east of north via:  az = (az + 180) % 360 . lat : the local geodetic latitude, in degrees, scalar or array. alt  and  az  can be given as a 2-tuple  (alt, az) . Output 2-tuple  (ha, dec) ha : the local apparent hour angle, in degrees.  The hour angle is the time that right ascension of 0 hours crosses the local meridian.  It is unambiguously defined. dec : the local apparent declination, in degrees. The output coordinates are always floating points and have the same type (scalar or array) as the input coordinates. Example Arcturus is observed at an apparent altitude of 59d,05m,10s and an azimuth (measured east of north) of 133d,18m,29s while at the latitude of +43.07833 degrees.  What are the local hour angle and declination of this object? julia> using AstroLib\n\njulia> ha, dec = altaz2hadec(ten(59,05,10), ten(133,18,29), 43.07833)\n(336.6828582472844, 19.182450965120402) The widely available XEPHEM code gets: Hour Angle = 336.683\nDeclination = 19.1824 Notes hadec2altaz  converts Hour Angle and Declination to Horizon (Alt-Az) coordinates. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1175,"pagetitle":"Reference","title":"AstroLib.baryvel","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.baryvel-Tuple{Real}","content":" AstroLib.baryvel  —  Method baryvel(dje, deq) -> dvelh, dvelb Purpose Calculates heliocentric and barycentric velocity components of Earth. Explanation Baryvel takes into account the Earth-Moon motion, and is useful for radial velocity work to an accuracy of ~1 m/s. Arguments dje : julian ephemeris date deq  (optional): epoch of mean equinox of  dvelh  and  dvelb . If  deq  is not provided, then it is assumed to be equal to  dje . Output dvelh : heliocentric velocity component. in km/s dvelb : barycentric velocity component. in km/s Example Compute the radial velocity of the Earth toward Altair on 15-Feb-1994 using both the original Stumpf algorithm. julia> using AstroLib\n\njulia> jd = jdcnv(1994, 2, 15, 0)\n2.4493985e6\n\njulia> baryvel(jd, 2000)\n([-17.0724258266945, -22.81120895274765, -9.889315408506354], [-17.080834081384847, -22.80470807516409, -9.886258269159352]) Notes The 3-vectors outputs  dvelh  and  dvelb  are given in a right-handed coordinate system with the +X axis toward the Vernal Equinox, and +Z axis toward the celestial pole. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1176,"pagetitle":"Reference","title":"AstroLib.bprecess","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.bprecess","content":" AstroLib.bprecess  —  Function bprecess(ra, dec[, epoch]) -> ra1950, dec1950\nbprecess(ra, dec, muradec[, parallax=parallax, radvel=radvel]) -> ra1950, dec1950 Purpose Precess positions from J2000.0 (FK5) to B1950.0 (FK4). Explanation Calculates the mean place of a star at B1950.0 on the FK4 system from the mean place at J2000.0 on the FK5 system. bprecess  function has two methods, one for each of the following cases: the proper motion is known and non-zero the proper motion is unknown or known to be exactly zero (i.e. extragalactic radio sources).  Better precision can be achieved in this case by inputting the epoch of the original observations. Arguments The function has 2 methods.  The common mandatory arguments are: ra : input J2000 right ascension, in degrees. dec : input J2000 declination, in degrees. The two methods have a different third argument (see \"Explanation\" section for more details).  It can be one of the following: muradec : 2-element vector containing the proper motion in seconds of arc per tropical  century  in right ascension and declination. epoch : scalar giving epoch of original observations. If none of these two arguments is provided (so  bprecess  is fed only with right ascension and declination), it is assumed that proper motion is exactly zero and  epoch = 2000 . If it is used the method involving  muradec  argument, the following keywords are available: parallax  (optional numerical keyword): stellar parallax, in seconds of arc. radvel  (optional numerical keyword): radial velocity in km/s. Right ascension and declination can be passed as the 2-tuple  (ra, dec) .  You can also pass  ra ,  dec ,  parallax , and  radvel  as arrays, all of the same length N.  In that case,  muradec  should be a matrix 2×N. Output The 2-tuple of right ascension and declination in 1950, in degrees, of input coordinates is returned.  If  ra  and  dec  (and other possible optional arguments) are arrays, the 2-tuple of arrays  (ra1950, dec1950)  of the same length as the input coordinates is returned. Method The algorithm is taken from the Explanatory Supplement to the Astronomical Almanac 1992, page 186.  See also Aoki et al (1983), A&A, 128, 263.  URL: http://adsabs.harvard.edu/abs/1983A%26A...128..263A. Example The SAO2000 catalogue gives the J2000 position and proper motion for the star HD 119288.  Find the B1950 position. RA(2000) = 13h 42m 12.740s Dec(2000) = 8d 23' 17.69'' Mu(RA) = -.0257 s/yr Mu(Dec) = -.090 ''/yr julia> using AstroLib\n\njulia> muradec = 100*[-15*0.0257, -0.090]; # convert to century proper motion\n\njulia> ra = ten(13, 42, 12.74)*15;\n\njulia> decl = ten(8, 23, 17.69);\n\njulia> adstring(bprecess(ra, decl, muradec), precision=2)\n\" 13 39 44.526  +08 38 28.63\" Notes \"When transferring individual observations, as opposed to catalog mean place, the safest method is to transform the observations back to the epoch of the observation, on the FK4 system (or in the system that was used to to produce the observed mean place), convert to the FK5 system, and transform to the the epoch and equinox of J2000.0\" – from the Explanatory Supplement (1992), p. 180 jprecess  performs the precession to J2000 coordinates. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1177,"pagetitle":"Reference","title":"AstroLib.calz_unred","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.calz_unred","content":" AstroLib.calz_unred  —  Function calz_unred(wave, flux, ebv[, r_v]) -> deredden_wave Purpose Deredden a galaxy spectrum using the Calzetti et al. (2000) recipe. Explanation Calzetti et al.  (2000, ApJ 533, 682; http://adsabs.harvard.edu/abs/2000ApJ...533..682C) developed a recipe for dereddening the spectra of galaxies where massive stars dominate the radiation output, valid between  $0.12$  to  $2.2$  microns.  ( calz_unred  extrapolates between  $0.12$  and  $0.0912$  microns.) Arguments wave : wavelength (Angstroms) flux : calibrated flux. ebv : color excess E(B-V).  If a negative  ebv  is supplied, then fluxes will be reddened rather than deredenned.  Note that the supplied color excess should be that derived for the stellar continuum, EBV(stars), which is related to the reddening derived from the gas, EBV(gas), via the Balmer decrement by EBV(stars) = 0.44*EBV(gas). r_v  (optional): ratio of total to selective extinction, default is 4.05.  Calzetti et al. (2000) estimate  $r_v = 4.05 ± 0.80$  from optical-IR observations of 4 starbursts. Output Unreddened flux, same units as  flux .  Flux values will be left unchanged outside valid domain ( $0.0912$  -  $2.2$  microns). Example Estimate how a flat galaxy spectrum (in wavelength) between  $1200 Å$  and  $3200 Å$  is altered by a reddening of E(B-V) = 0.1. wave = collect(1200:50:3150);\nflux = ones(size(wave));\nflux_new = calz_unred.(wave, flux, -0.1); Using a plotting tool you can visualize the unreddend flux.  For example, with  Plots.jl using Plots\nplot(wave, flux_new) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1178,"pagetitle":"Reference","title":"AstroLib.co_aberration","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.co_aberration","content":" AstroLib.co_aberration  —  Function co_aberration(jd, ra, dec[, eps=NaN]) -> d_ra, d_dec Purpose Calculate changes to right ascension and declination due to the effect of annual aberration Explanation With reference to Meeus, Chapter 23 Arguments jd : julian date, scalar or vector ra : right ascension in degrees, scalar or vector dec : declination in degrees, scalar or vector eps  (optional): true obliquity of the ecliptic (in radians). It will be calculated if no argument is specified. Output The 2-tuple  (d_ra, d_dec) : d_ra : correction to right ascension due to aberration, in arc seconds d_dec : correction to declination due to aberration, in arc seconds Example Compute the change in RA and Dec of Theta Persei (RA = 2h46m,11.331s, Dec = 49d20',54.5'') due to aberration on 2028 Nov 13.19 TD julia> using AstroLib\n\njulia> jd = jdcnv(2028,11,13,4, 56)\n2.4620887055555554e6\n\njulia> co_aberration(jd,ten(2,46,11.331)*15,ten(49,20,54.54))\n(30.04404628365077, 6.699400463119431) d_ra = 30.04404628365103'' (≈ 2.003s) d_dec = 6.699400463118504'' Notes Code of this function is based on IDL Astronomy User's Library. The output d ra is  not  multiplied by cos(dec), so that apparent ra = ra + d_ra/3600. These formula are from Meeus, Chapters 23.  Accuracy is much better than 1 arcsecond. The maximum deviation due to annual aberration is 20.49'' and occurs when the Earth's velocity is perpendicular to the direction of the star. This function calls  true_obliquity  and  sunpos . source"},{"id":1179,"pagetitle":"Reference","title":"AstroLib.co_nutate","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.co_nutate-Tuple{Real, Real, Real}","content":" AstroLib.co_nutate  —  Method co_nutate(jd, ra, dec) -> d_ra, d_dec, eps, d_psi, d_eps Purpose Calculate changes in RA and Dec due to nutation of the Earth's rotation Explanation Calculates necessary changes to ra and dec due to the nutation of the Earth's rotation axis, as described in Meeus, Chap 23. Uses formulae from Astronomical Almanac, 1984, and does the calculations in equatorial rectangular coordinates to avoid singularities at the celestial poles. Arguments jd : julian date, scalar or vector ra : right ascension in degrees, scalar or vector dec : declination in degrees, scalar or vector Output The 5-tuple  (d_ra, d_dec, eps, d_psi, d_eps) : d_ra : correction to right ascension due to nutation, in degrees d_dec : correction to declination due to nutation, in degrees eps : the true obliquity of the ecliptic d_psi : nutation in the longitude of the ecliptic d_eps : nutation in the obliquity of the ecliptic Example Example 23a in Meeus: On 2028 Nov 13.19 TD the mean position of Theta Persei is 2h 46m 11.331s 49d 20' 54.54''. Determine the shift in position due to the Earth's nutation. julia> using AstroLib\n\njulia> jd = jdcnv(2028,11,13,4,56)\n2.4620887055555554e6\n\njulia> co_nutate(jd,ten(2,46,11.331) * 15,ten(49,20,54.54))\n(0.004400660977140092, 0.00172668646508356, 0.40904016038217555, 14.859389427896472, 2.703809037235057) Notes Code of this function is based on IDL Astronomy User's Library. The output of  d_ra  and  d_dec  in IDL AstroLib is in arcseconds, however it is in degrees here. This function calls  mean_obliquity  and  nutate . source"},{"id":1180,"pagetitle":"Reference","title":"AstroLib.co_refract","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.co_refract","content":" AstroLib.co_refract  —  Function co_refract(old_alt[, altitude=0, pressure=NaN, temperature=NaN,\n           epsilon=0.25, to_observe=false]) -> aout Purpose Calculate correction to altitude due to atmospheric refraction. Explanation Because the index of refraction of air is not precisely 1.0, the atmosphere bends all incoming light, making a star or other celestial object appear at a slightly different altitude (or elevation) than it really is.  It is important to understand the following definitions: Observed Altitude: The altitude that a star is seen to be, with a telescope. This is where it appears in the sky. This is should be always greater than the apparent altitude. Apparent Altitude: The altitude that a star would be at, if ~there were no atmosphere~ (sometimes called the \"true\" altitude). This is usually calculated from an object's celestial coordinates. Apparent altitude should always be smaller than the observed altitude. Thus, for example, the Sun's apparent altitude when you see it right on the horizon is actually -34 arcminutes. This program uses a couple of simple formulae to estimate the effect for most optical and radio wavelengths. Typically, you know your observed altitude (from an observation), and want the apparent altitude. To go the other way, this program uses an iterative approach. Arguments old_alt : observed altitude in degrees. If  to_observe  is set to true, this should be apparent altitude altitude  (optional): the height of the observing location, in meters. This is only used to determine an approximate temperature and pressure, if these are not specified separately. Default is 0 i.e. sea level pressure  (optional): the pressure at the observing location, in millibars. Default is NaN temperature  (optional): the temperature at the observing location, in Kelvins. Default is NaN epsilon  (optional): the accuracy to obtain, in arcseconds. If  to_observe  is true, then it will be calculated. Default is 0.25 arcseconds to_observe  (optional boolean keyword): if set to true, it is assumed that  old_alt  has apparent altitude as its input and the observed altitude will be found Output aout : apparent altitude, in degrees. Observed altitude is returned if  to_observe  is set to true Example The lower limb of the Sun is observed to have altitude of 0d 30'. Calculate the the true (i.e. apparent) altitude of the Sun's lower limb using mean  conditions of air pressure and temperature. julia> using AstroLib\n\njulia> co_refract(0.5)\n0.02584736873098442 Notes If altitude is set but the temperature or pressure is not, the program will make an intelligent guess for the temperature and pressure. Wavelength Dependence This correction is 0 at zenith, about 1 arcminute at 45 degrees, and 34 arcminutes at the horizon for optical wavelengths. The correction is non-negligible at all wavelengths, but is not very easily calculable. These formulae assume a wavelength of 550 nm, and will be accurate to about 4 arcseconds for all visible wavelengths, for elevations of 10 degrees and higher. Amazingly, they are also accurate for radio frequencies less than ~ 100 GHz. References Meeus, Astronomical Algorithms, Chapter 15. Explanatory Supplement to the Astronomical Almanac, 1992. Methods of Experimental Physics, Vol 12 Part B, Astrophysics, Radio Telescopes, Chapter 2.5, \"Refraction Effects in the Neutral Atmosphere\", by R.K. Crane. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1181,"pagetitle":"Reference","title":"AstroLib.co_refract_forward","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.co_refract_forward-Tuple{Real, Real, Real}","content":" AstroLib.co_refract_forward  —  Method co_refract_forward(alt, pre, temp) -> ref Purpose A function used by  co_refract  to find apparent (or observed) altitude Arguments alt : the observed (or apparent) altitude, in degrees pre : pressure, in millibars temp : temperature, in Kelvins Output ref : the atmospheric refraction, in minutes of arc Notes The atmospheric refraction is calculated by Saemundsson's formula Code of this function is based on IDL Astronomy User's Library. source"},{"id":1182,"pagetitle":"Reference","title":"AstroLib.ct2lst","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.ct2lst","content":" AstroLib.ct2lst  —  Function ct2lst(longitude, jd) -> local_sidereal_time\nct2lst(longitude, tz, date) -> local_sidereal_time Purpose Convert from Local Civil Time to Local Mean Sidereal Time. Arguments The function can be called in two different ways.  The only argument common to both methods is  longitude : longitude : the longitude in degrees (east of Greenwich) of the place for which the local sidereal time is desired.  The Greenwich mean sidereal time (GMST) can be found by setting longitude =  0 . The civil date to be converted to mean sidereal time can be specified either by providing the Julian days: jd : this is number of Julian days for the date to be converted. or the time zone and the date: tz : the time zone of the site in hours, positive East of the Greenwich meridian (ahead of GMT).  Use this parameter to easily account for Daylight Savings time (e.g. -4=EDT, -5 = EST/CDT). date : this is the local civil time with type  DateTime . Output The local sidereal time for the date/time specified in hours. Method The Julian days of the day and time is question is used to determine the number of days to have passed since 2000-01-01.  This is used in conjunction with the GST of that date to extrapolate to the current GST; this is then used to get the LST.  See Astronomical Algorithms by Jean Meeus, p. 84 (Eq. 11-4) for the constants used. Example Find the Greenwich mean sidereal time (GMST) on 2008-07-30 at 15:53 in Baltimore, Maryland (longitude=-76.72 degrees).  The timezone is EDT or tz=-4 julia> using AstroLib, Dates\n\njulia> lst = ct2lst(-76.72, -4, DateTime(2008, 7, 30, 15, 53))\n11.356505172312609\n\njulia> sixty(lst)\n3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):\n 11.0\n 21.0\n 23.418620325392112 Find the Greenwich mean sidereal time (GMST) on 2015-11-24 at 13:21 in Heidelberg, Germany (longitude=08° 43' E).  The timezone is CET or tz=1. Provide  ct2lst  only with the longitude of the place and the number of Julian days. julia> using AstroLib, Dates\n\njulia> longitude = ten(8, 43); # Convert longitude to decimals.\n\njulia> # Get number of Julian days. Remember to subtract the time zone in\n       # order to convert local time to UTC.\n\njulia> jd = jdcnv(DateTime(2015, 11, 24, 13, 21) - Dates.Hour(1));\n\njulia> lst = ct2lst(longitude, jd) # Calculate Greenwich Mean Sidereal Time.\n17.140685171005316\n\njulia> sixty(lst)\n3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):\n 17.0\n  8.0\n 26.466615619137883 Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1183,"pagetitle":"Reference","title":"AstroLib.daycnv","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.daycnv","content":" AstroLib.daycnv  —  Function daycnv(julian_days) -> DateTime Purpose Converts Julian days number to Gregorian calendar dates. Explanation Takes the number of Julian calendar days since epoch  -4713-11-24T12:00:00  and returns the corresponding proleptic Gregorian Calendar date. Argument julian_days : Julian days number. Output Proleptic Gregorian Calendar date, of type  DateTime , corresponding to the given Julian days number. Example julia> using AstroLib\n\njulia> daycnv(2440000)\n1968-05-23T12:00:00 Notes jdcnv  is the inverse of this function. source"},{"id":1184,"pagetitle":"Reference","title":"AstroLib.deredd","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.deredd-NTuple{5, Real}","content":" AstroLib.deredd  —  Method deredd(Eby, by, m1, c1, ub) -> by0, m0, c0, ub0 Purpose Deredden stellar Stromgren parameters given for a value of E(b-y) Arguments Eby : color index E(b-y), scalar (E(b-y) = 0.73*E(B-V)) by : b-y color (observed) m1 : Stromgren line blanketing parameter (observed) c1 : Stromgren Balmer discontinuity parameter (observed) ub : u-b color (observed) All arguments can be either scalars or arrays all of the same length. Output The 4-tuple  (by0, m0, c0, ub0) . by0 : b-y color (dereddened) m0 : line blanketing index (dereddened) c0 : Balmer discontinuity parameter (dereddened) ub0 : u-b color (dereddened) These are scalars or arrays of the same length as the input arguments. Example julia> using AstroLib\n\njulia> deredd(0.5, 0.2, 1.0, 1.0, 0.1)\n(-0.3, 1.165, 0.905, -0.665) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1185,"pagetitle":"Reference","title":"AstroLib.eci2geo","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.eci2geo-NTuple{4, Real}","content":" AstroLib.eci2geo  —  Method eci2geo(x, y, z, jd) -> latitude, longitude, altitude Purpose Convert Earth-centered inertial coordinates to geographic spherical coordinates. Explanation Converts from ECI (Earth-Centered Inertial) (x, y, z) rectangular coordinates to geographic spherical coordinates (latitude, longitude, altitude).  Julian day is also needed as input. ECI coordinates are in km from Earth center at the supplied time (True of Date). Geographic coordinates assume the Earth is a perfect sphere, with radius equal to its equatorial radius. Arguments x : ECI x coordinate at  jd , in kilometers. y : ECI y coordinate at  jd , in kilometers. z : ECI z coordinate at  jd , in kilometers. jd : Julian days. The three coordinates can be passed as a 3-tuple  (x, y, z) .  In addition,  x ,  y ,  z , and  jd  can be given as arrays of the same length. Output The 3-tuple of geographical coordinate (latitude, longitude, altitude). latitude : latitude, in degrees. longitude : longitude, in degrees. altitude : altitude, in kilometers. If ECI coordinates are given as arrays, a 3-tuple of arrays of the same length is returned. Example Obtain the geographic direction of the vernal point on 2015-06-30T14:03:12.857, in geographic coordinates, at altitude 600 km.  Note: equatorial radii of Solar System planets in meters are stored into  AstroLib.planets  dictionary. julia> using AstroLib\n\njulia> x = AstroLib.planets[\"earth\"].eqradius*1e-3 + 600;\n\njulia> lat, long, alt = eci2geo(x, 0, 0, jdcnv(\"2015-06-30T14:03:12.857\"))\n(0.0, 230.87301833205856, 600.0) These coordinates can be further transformed into geodetic coordinates using  geo2geodetic  or into geomagnetic coordinates using  geo2mag . Notes geo2eci  converts geographic spherical coordinates to Earth-centered inertial coordinates. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1186,"pagetitle":"Reference","title":"AstroLib.eq2hor","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.eq2hor","content":" AstroLib.eq2hor  —  Function eq2hor(ra, dec, jd[, obsname; ws=false, B1950=false, precession=true, nutate=true,\n       aberration=true, refract=true, pressure=NaN, temperature=NaN]) -> alt, az, ha\n\neq2hor(ra, dec, jd, lat, lon[, altitude=0; ws=false, B1950=false,\n       precession=true, nutate=true, aberration=true, refract=true,\n       pressure=NaN, temperature=NaN]) -> alt, az, ha Purpose Convert celestial  (ra-dec) coords to local horizon coords (alt-az). Explanation This code calculates horizon (alt,az) coordinates from equatorial (ra,dec) coords. It performs precession, nutation, aberration, and refraction corrections. Arguments This function has two base methods.  With one you can specify the name of the observatory, if present in  AstroLib.observatories , with the other one you can provide the coordinates of the observing site and, optionally, the altitude. Common mandatory arguments: ra : right ascension of object, in degrees dec : declination of object, in degrees jd : julian date Other positional arguments: obsname : set this to a valid observatory name in  AstroLib.observatories . or lat : north geodetic latitude of location, in degrees. lon : AST longitude of location, in degrees. You can specify west longitude with a negative sign. altitude : the altitude of the observing location, in meters.  It is  0  by default Optional keyword arguments: ws  (optional boolean keyword): set this to  true  to get the azimuth measured westward from south (not East of North) B1950  (optional boolean keyword): set this to  true  if the ra and dec are specified in B1950 (FK4 coordinates) instead of J2000 (FK5). This is  false  by default precession  (optional boolean keyword): set this to  false  for no precession correction,  true  by default nutate  (optional boolean keyword): set this to  false  for no nutation,  true  by default aberration  (optional boolean keyword): set this to  false  for no aberration correction,  true  by default refract  (optional boolean keyword): set this to  false  for no refraction correction,  true  by default pressure  (optional keyword): the pressure at the observing location, in millibars. Default value is  NaN temperature  (optional keyword): the temperature at the observing location, in Kelvins. Default value is  NaN Output alt : altitude of horizon coords, in degrees az : azimuth angle measured East from North (unless ws is  true ), in degrees ha : hour angle, in degrees Example julia> using AstroLib\n\njulia> alt_o, az_o = eq2hor(ten(6,40,58.2)*15, ten(9,53,44), 2460107.25, ten(50,31,36),\n                            ten(6,51,18), 369, pressure = 980, temperature=283)\n(16.423991509721567, 265.60656932130564, 76.11502253130612)\n\njulia> adstring(az_o, alt_o)\n\" 17 42 25.6  +16 25 26\" Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1187,"pagetitle":"Reference","title":"AstroLib.eqpole","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.eqpole-Tuple{Real, Real}","content":" AstroLib.eqpole  —  Method eqpole(l, b[; southpole = false]) -> x, y Purpose Convert right ascension  $l$  and declination  $b$  to coordinate  $(x, y)$  using an equal-area polar projection. Explanation The output  $x$  and  $y$  coordinates are scaled to be in the range  $[-90, 90]$  and to go from equator to pole to equator.  Output map points can be centered on the north pole or south pole. Arguments l : longitude, scalar or vector, in degrees b : latitude, same number of elements as right ascension, in degrees southpole  (optional boolean keyword): keyword to indicate that the plot is to be centered on the south pole instead of the north pole.  Default is  false . Output The 2-tuple  $(x, y)$ : $x$  coordinate, same number of elements as right ascension, normalized to be in the range  $[-90, 90]$ . $y$  coordinate, same number of elements as declination, normalized to be in the range  $[-90, 90]$ . Example julia> using AstroLib\n\njulia> eqpole(100, 35, southpole=true)\n(-111.18287262822456, -19.604540237028665)\n\njulia> eqpole(80, 19)\n(72.78853915267848, 12.83458333897169) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1188,"pagetitle":"Reference","title":"AstroLib.euler","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.euler-Tuple{Real, Real, Integer}","content":" AstroLib.euler  —  Method euler(ai, bi, select[, FK4=true, radians=true]) Purpose Transform between Galactic, celestial, and ecliptic coordinates. Explanation The function is used by the astro procedure. Arguments ai : input longitude, scalar or vector. bi : input latitude, scalar or vector. select  : integer input specifying type of coordinate transformation. SELECT   From          To     | SELECT   From       To    1   RA-Dec (2000) Galactic |   4    Ecliptic   RA-Dec    2   Galactic      RA-DEC   |   5    Ecliptic   Galactic    3   RA-Dec        Ecliptic |   6    Galactic   Ecliptic FK4  (optional boolean keyword) : if this keyword is set to  true , then input and output celestial and ecliptic coordinates should be given in equinox B1950. When  false , by default, they should be given in equinox J2000. radians  (optional boolean keyword) : if this keyword is set to  true , all input and output angles are in radians rather than degrees. Output a 2-tuple  (ao, bo) : ao : output longitude in degrees. bo : output latitude in degrees. Example Find the Galactic coordinates of Cyg X-1 (ra=299.590315, dec=35.201604) julia> using AstroLib\n\njulia> euler(299.590315, 35.201604, 1)\n(71.33498957116959, 3.0668335310640984) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1189,"pagetitle":"Reference","title":"AstroLib.flux2mag","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.flux2mag","content":" AstroLib.flux2mag  —  Function flux2mag(flux[, zero_point, ABwave=number]) -> magnitude Purpose Convert from flux expressed in erg/(s cm² Å) to magnitudes. Explanation This is the reverse of  mag2flux . Arguments flux : the flux to be converted in magnitude, expressed in erg/(s cm² Å). zero_point : the zero point level of the magnitude.  If not supplied then defaults to 21.1 (Code et al 1976).  Ignored if the  ABwave  keyword is supplied ABwave  (optional numeric keyword): wavelength in Angstroms. If supplied, then returns Oke AB magnitudes (Oke & Gunn 1983, ApJ, 266, 713; http://adsabs.harvard.edu/abs/1983ApJ...266..713O). Output The magnitude. If the  ABwave  keyword is set then magnitude is given by the expression \\[\\text{ABmag} = -2.5\\log_{10}(f) - 5\\log_{10}(\\text{ABwave}) - 2.406\\] Otherwise, magnitude is given by the expression \\[\\text{mag} = -2.5\\log_{10}(\\text{flux}) - \\text{zero point}\\] Example julia> using AstroLib\n\njulia> flux2mag(5.2e-15)\n14.609991640913002\n\njulia> flux2mag(5.2e-15, 15)\n20.709991640913003\n\njulia> flux2mag(5.2e-15, ABwave=15)\n27.423535345634598 Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1190,"pagetitle":"Reference","title":"AstroLib.gal_uvw","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.gal_uvw-NTuple{6, Real}","content":" AstroLib.gal_uvw  —  Method gal_uvw(ra, dec, pmra, pmdec, vrad, plx[, lsr=true]) -> u, v, w Purpose Calculate the Galactic space velocity  $(u, v, w)$  of a star. Explanation Calculates the Galactic space velocity  $(u, v, w)$  of a star given its (1) coordinates, (2) proper motion, (3) parallax, and (4) radial velocity. Arguments User must supply a position, proper motion, radial velocity and parallax. Either scalars or arrays all of the same length can be supplied. Position: ra : right ascension, in degrees dec : declination, in degrees Proper Motion pmra : proper motion in right ascension in arc units (typically milli-arcseconds/yr).  If given  $μ_α$  – proper motion in seconds of time/year – then this is equal to  $15 μ_α \\cos(\\text{dec})$ . pmdec : proper motion in declination (typically mas/yr). Radial Velocity vrad : velocity in km/s Parallax plx : parallax with same distance units as proper motion measurements typically milliarcseconds (mas) If you know the distance in parsecs, then set  plx  to  $1000/\\text{distance}$ , if proper motion measurements are given in milli-arcseconds/yr. There is an additional optional keyword: lsr  (optional boolean keyword): if this keyword is set to  true , then the output velocities will be corrected for the solar motion  $(u, v, w)_⊙ = (-8.5, 13.38, 6.49)$  (Coşkunoǧlu et al. 2011 MNRAS, 412, 1237; DOI: 10.1111/j.1365-2966.2010.17983.x ) to the local standard of rest (LSR).  Note that the value of the solar motion through the LSR remains poorly determined. Output The 3-tuple  $(u, v, w)$ $u$ : velocity (km/s) positive toward the Galactic  anti center $v$ : velocity (km/s) positive in the direction of Galactic rotation $w$ : velocity (km/s) positive toward the North Galactic Pole Method Follows the general outline of Johnson & Soderblom (1987, AJ, 93, 864; DOI: 10.1086/114370 ) except that  $u$  is positive outward toward the Galactic  anti center, and the J2000 transformation matrix to Galactic coordinates is taken from the introduction to the Hipparcos catalog. Example Compute the U,V,W coordinates for the halo star HD 6755.  Use values from Hipparcos catalog, and correct to the LSR. julia> using AstroLib\n\njulia> ra = ten(1,9,42.3)*15.; dec = ten(61,32,49.5);\n\njulia> pmra = 627.89;  pmdec = 77.84; # mas/yr\n\njulia> vrad = -321.4; dis = 129; # distance in parsecs\n\njulia> u, v, w = gal_uvw(ra, dec, pmra, pmdec, vrad, 1e3/dis, lsr=true)\n(118.2110474553902, -466.4828898385057, 88.16573278565097) Notes This function does not take distance as input.  See \"Arguments\" section above for how to provide it using parallax argument. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1191,"pagetitle":"Reference","title":"AstroLib.gcirc","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.gcirc-Tuple{Integer, Vararg{Real, 4}}","content":" AstroLib.gcirc  —  Method gcirc(units, ra1, dec1, ra2, dec2) -> angular_distance Purpose Computes rigorous great circle arc distances. Explanation Input position can be either radians, sexagesimal right ascension and declination, or degrees. Arguments units : integer, can be either 0, or 1, or 2.  Describes units of inputs and output: 0: everything (input right ascensions and declinations, and output distance) is radians 1: right ascensions are in decimal hours, declinations in decimal degrees, output distance in arc seconds 2: right ascensions and declinations are in degrees, output distance in arc seconds ra1 :  right ascension or longitude of point 1 dec1 : declination or latitude of point 1 ra2 : right ascension or longitude of point 2 dec2 : declination or latitude of point 2 Both  ra1  and  dec1 , and  ra2  and  dec2  can be given as 2-tuples  (ra1, dec1)  and  (ra2, dec2) . Output Angular distance on the sky between points 1 and 2, as a  AbstractFloat .  See  units  argument above for the units. Method \"Haversine formula\" see http://en.wikipedia.org/wiki/Great-circle_distance. Example julia> using AstroLib\n\njulia> gcirc(0, 120, -43, 175, +22)\n1.590442261600714 Notes The function  sphdist  provides an alternate method of computing a spherical distance. The Haversine formula can give rounding errors for antipodal points. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1192,"pagetitle":"Reference","title":"AstroLib.geo2eci","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.geo2eci-NTuple{4, Real}","content":" AstroLib.geo2eci  —  Method geo2eci(latitude, longitude, altitude, jd) -> x, y, z Purpose Convert geographic spherical coordinates to Earth-centered inertial coordinates. Explanation Converts from geographic spherical coordinates (latitude, longitude, altitude) to ECI (Earth-Centered Inertial) (x, y, z) rectangular coordinates.  Julian days is also needed. Geographic coordinates assume the Earth is a perfect sphere, with radius equal to its equatorial radius.  ECI coordinates are in km from Earth center at epoch TOD (True of Date). Arguments latitude : geographic latitude, in degrees. longitude : geographic longitude, in degrees. altitude : geographic altitude, in kilometers. jd : Julian days. The three coordinates can be passed as a 3-tuple  (latitude, longitude, altitude) .  In addition,  latitude ,  longitude ,  altitude , and  jd  can be given as arrays of the same length. Output The 3-tuple of ECI (x, y, z) coordinates, in kilometers.  The TOD epoch is the supplied  jd  time. If geographical coordinates are given as arrays, a 3-tuple of arrays of the same length is returned. Example Obtain the ECI coordinates of the intersection of the equator and Greenwich's meridian on 2015-06-30T14:03:12.857 julia> using AstroLib\n\njulia> geo2eci(0, 0, 0, jdcnv(\"2015-06-30T14:03:12.857\"))\n(-4024.8671780315185, 4947.835465127513, 0.0) Notes eci2geo  converts Earth-centered inertial coordinates to geographic spherical coordinates. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1193,"pagetitle":"Reference","title":"AstroLib.geo2geodetic","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.geo2geodetic-NTuple{5, Real}","content":" AstroLib.geo2geodetic  —  Method geo2geodetic(latitude, longitude, altitude) -> latitude, longitude, altitude\ngeo2geodetic(latitude, longitude, altitude, planet) -> latitude, longitude, altitude\ngeo2geodetic(latitude, longitude, altitude, equatorial_radius, polar_radius) -> latitude, longitude, altitude Purpose Convert from geographic (or planetographic) to geodetic coordinates. Explanation Converts from geographic (latitude, longitude, altitude) to geodetic (latitude, longitude, altitude).  In geographic coordinates, the Earth is assumed a perfect sphere with a radius equal to its equatorial radius.  The geodetic (or ellipsoidal) coordinate system takes into account the Earth's oblateness. Geographic and geodetic longitudes are identical.  Geodetic latitude is the angle between local zenith and the equatorial plane.  Geographic and geodetic altitudes are both the closest distance between the satellite and the ground. Arguments The function has two base methods.  The arguments common to all methods and always mandatory are  latitude ,  longitude , and  altitude : latitude : geographic latitude, in degrees. longitude : geographic longitude, in degrees. altitude : geographic altitude, in kilometers. In order to convert to geodetic coordinates, you can either provide custom equatorial and polar radii of the planet or use the values of one of the planets of Solar System (Pluto included). If you want to use the method with explicit equatorial and polar radii the additional mandatory arguments are: equatorial_radius : value of the equatorial radius of the body, in kilometers. polar_radius : value of the polar radius of the body, in kilometers. Instead, if you want to use the method with the selection of a planet, the only additional argument is the planet name: planet  (optional string argument): string with the name of the Solar System planet, from \"Mercury\" to \"Pluto\".  If omitted (so, when only  latitude ,  longitude , and  altitude  are provided), the default is \"Earth\". In all cases, the three coordinates can be passed as a 3-tuple  (latitude, longitude, altitude) .  In addition, geographical  latitude ,  longitude , and  altitude  can be given as arrays of the same length. Output The 3-tuple  (latitude, longitude, altitude)  in geodetic coordinates, for the body with specified equatorial and polar radii (Earth by default). If geographical coordinates are given as arrays, a 3-tuple of arrays of the same length is returned. Method Stephen P.  Keeler and Yves Nievergelt, \"Computing geodetic coordinates\", SIAM Rev. Vol. 40, No. 2, pp. 300-309, June 1998 (DOI: 10.1137/S0036144597323921 ). Planetary constants are from Planetary Fact Sheet (http://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html). Example Locate the Earth geographic North pole (latitude: 90°, longitude: 0°, altitude 0 km), in geodetic coordinates: julia> using AstroLib\n\njulia> geo2geodetic(90, 0, 0)\n(90.0, 0.0, 21.38499999999931) The same for Jupiter: julia> using AstroLib\n\njulia> geo2geodetic(90, 0, 0, \"Jupiter\")\n(90.0, 0.0, 4638.0) Find geodetic coordinates for point of geographic coordinates (latitude, longitude, altitude) = (43.16°, -24.32°, 3.87 km) on a planet with equatorial radius 8724.32 km and polar radius 8619.19 km: julia> using AstroLib\n\njulia> geo2geodetic(43.16, -24.32, 3.87, 8724.32, 8619.19)\n(43.849399515234516, -24.32, 53.53354478670965) Notes Whereas the conversion from geodetic to geographic coordinates is given by an exact, analytical formula, the conversion from geographic to geodetic isn't. Approximative iterations (as used here) exist, but tend to become less good with increasing eccentricity and altitude.  The formula used in this routine should give correct results within six digits for all spatial locations, for an ellipsoid (planet) with an eccentricity similar to or less than Earth's.  More accurate results can be obtained via calculus, needing a non-determined amount of iterations. In any case, the function  geodetic2geo , which converts from geodetic (or planetodetic) to geographic coordinates, can be used to estimate the accuracy of  geo2geodetic . julia> using AstroLib\n\njulia> collect(geodetic2geo(geo2geodetic(67.2, 13.4, 1.2))) - [67.2, 13.4, 1.2]\n3-element Vector{Float64}:\n -3.5672513831741526e-9\n  0.0\n  9.484211194177306e-10 Code of this function is based on IDL Astronomy User's Library. source"},{"id":1194,"pagetitle":"Reference","title":"AstroLib.geo2mag","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.geo2mag","content":" AstroLib.geo2mag  —  Function geo2mag(latitude, longitude[, year]) -> geomagnetic_latitude, geomagnetic_longitude Purpose Convert from geographic to geomagnetic coordinates. Explanation Converts from geographic (latitude, longitude) to geomagnetic (latitude, longitude).  Altitude is not involved in this function. Arguments latitude : geographic latitude (North), in degrees. longitude : geographic longitude (East), in degrees. year  (optional numerical argument): the year in which to perform conversion. If omitted, defaults to current year. The coordinates can be passed as arrays of the same length. Output The 2-tuple of magnetic (latitude, longitude) coordinates, in degrees. If geographical coordinates are given as arrays, a 2-tuple of arrays of the same length is returned. Example Kyoto has geographic coordinates 35° 00' 42'' N, 135° 46' 06'' E, find its geomagnetic coordinates in 2016: julia> using AstroLib\n\njulia> geo2mag(ten(35,0,42), ten(135,46,6), 2016)\n(36.86579228937769, -60.1840605366516) Notes This function uses list of North Magnetic Pole positions provided by World Magnetic Model (https://www.ngdc.noaa.gov/geomag/data/poles/NP.xy). mag2geo  converts geomagnetical coordinates to geographic coordinates. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1195,"pagetitle":"Reference","title":"AstroLib.geodetic2geo","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.geodetic2geo-NTuple{5, Real}","content":" AstroLib.geodetic2geo  —  Method geodetic2geo(latitude, longitude, altitude) -> latitude, longitude, altitude\ngeodetic2geo(latitude, longitude, altitude, planet) -> latitude, longitude, altitude\ngeodetic2geo(latitude, longitude, altitude, equatorial_radius, polar_radius) -> latitude, longitude, altitude Purpose Convert from geodetic (or planetodetic) to geographic coordinates. Explanation Converts from geodetic (latitude, longitude, altitude) to geographic (latitude, longitude, altitude).  In geographic coordinates, the Earth is assumed a perfect sphere with a radius equal to its equatorial radius.  The geodetic (or ellipsoidal) coordinate system takes into account the Earth's oblateness. Geographic and geodetic longitudes are identical.  Geodetic latitude is the angle between local zenith and the equatorial plane.  Geographic and geodetic altitudes are both the closest distance between the satellite and the ground. Arguments The function has two base methods.  The arguments common to all methods and always mandatory are  latitude ,  longitude , and  altitude : latitude : geodetic latitude, in degrees. longitude : geodetic longitude, in degrees. altitude : geodetic altitude, in kilometers. In order to convert to geographic coordinates, you can either provide custom equatorial and polar radii of the planet or use the values of one of the planets of Solar System (Pluto included). If you want to use the method with explicit equatorial and polar radii the additional mandatory arguments are: equatorial_radius : value of the equatorial radius of the body, in kilometers. polar_radius : value of the polar radius of the body, in kilometers. Instead, if you want to use the method with the selection of a planet, the only additional argument is the planet name: planet  (optional string argument): string with the name of the Solar System planet, from \"Mercury\" to \"Pluto\".  If omitted (so, when only  latitude ,  longitude , and  altitude  are provided), the default is \"Earth\". In all cases, the three coordinates can be passed as a 3-tuple  (latitude, longitude, altitude) .  In addition, geodetic  latitude ,  longitude , and  altitude  can be given as arrays of the same length. Output The 3-tuple  (latitude, longitude, altitude)  in geographic coordinates, for the body with specified equatorial and polar radii (Earth by default). If geodetic coordinates are given as arrays, a 3-tuple of arrays of the same length is returned. Method Stephen P.  Keeler and Yves Nievergelt, \"Computing geodetic coordinates\", SIAM Rev. Vol. 40, No. 2, pp. 300-309, June 1998 (DOI: 10.1137/S0036144597323921 ). Planetary constants from \"Allen's Astrophysical Quantities\", Fourth Ed., (2000). Example Find geographic coordinates of geodetic North pole (latitude: 90°, longitude: 0°, altitude 0 km) of the Earth: julia> using AstroLib\n\njulia> geodetic2geo(90, 0, 0)\n(90.0, 0.0, -21.38499999999931) The same for Jupiter: julia> using AstroLib\n\njulia> geodetic2geo(90, 0, 0, \"Jupiter\")\n(90.0, 0.0, -4638.0) Find geographic coordinates for point of geodetic coordinates (latitude, longitude, altitude) = (43.16°, -24.32°, 3.87 km) on a planet with equatorial radius 8724.32 km and polar radius 8619.19 km: julia> using AstroLib\n\njulia> geodetic2geo(43.16, -24.32, 3.87, 8724.32, 8619.19)\n(42.46772711708433, -24.32, -44.52902080669082) Notes geo2geodetic  converts from geographic (or planetographic) to geodetic coordinates. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1196,"pagetitle":"Reference","title":"AstroLib.get_date","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.get_date-Tuple{Dates.DateTime, Bool, Bool}","content":" AstroLib.get_date  —  Method get_date([date, old=true, timetag=true]) -> string Purpose Returns the UTC date in  \"CCYY-MM-DD\"  format for FITS headers. Explanation This is the format required by the  DATE  and  DATE-OBS  keywords in a FITS header. Argument date  (optional): the date in UTC standard.  If omitted, defaults to the current UTC time.  Each element can be either a  DateTime  type or anything that can be converted to that type.  In the case of vectorial input, each element is considered as a date, so you cannot provide a date by parts. old  (optional boolean keyword): see below. timetag  (optional boolean keyword): see below. Output A string with the date formatted according to the given optional keywords. When no optional keywords ( timetag  and  old ) are supplied, the format of the output string is  \"CCYY-MM-DD\"  (year-month-day part of the date), where  CCYY  represents a 4-digit calendar year,  MM  the 2-digit ordinal number of a calendar month within the calendar year, and  DD  the 2-digit ordinal number of a day within the calendar month. If the boolean keyword  old  is true (default: false), the year-month-day part of date has  \"DD/MM/YY\"  format.  This is the formerly (pre-1997) recommended for FITS.  Note that this format is now deprecated because it uses only a 2-digit representation of the year. If the boolean keyword  timetag  is true (default: false),  \"Thh:mm:ss\"  is appended to the year-month-day part of the date, where <hh> represents the hour in the day, <mm> the minutes, <ss> the seconds, and the literal 'T' the ISO 8601 time designator. Note that  old  and  timetag  keywords can be used together, so that the output string will have  \"DD/MM/YYThh:mm:ss\"  format. Example julia> using AstroLib, Dates\n\njulia> get_date(DateTime(21937, 05, 30, 09, 59, 00), timetag=true)\n\"21937-05-30T09:59:00\" Notes A discussion of the DATExxx syntax in FITS headers can be found in http://www.cv.nrao.edu/fits/documents/standards/year2000.txt Those who wish to use need further flexibility in their date formats (e.g. to use TAI time) should look at Bill Thompson's time routines in http://sohowww.nascom.nasa.gov/solarsoft/gen/idl/time source"},{"id":1197,"pagetitle":"Reference","title":"AstroLib.get_juldate","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.get_juldate-Tuple{}","content":" AstroLib.get_juldate  —  Method get_juldate() -> julian_days Purpose Return the number of Julian days for current time. Explanation Return for current time the number of Julian calendar days since epoch  -4713-11-24T12:00:00  as a floating point. Example get_juldate()\ndaycnv(get_juldate()) Notes Use  jdcnv  to get the number of Julian days for a different date. source"},{"id":1198,"pagetitle":"Reference","title":"AstroLib.hadec2altaz","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.hadec2altaz-Tuple{Real, Real, Real}","content":" AstroLib.hadec2altaz  —  Method hadec2altaz(ha, dec, lat[, ws=true]) -> alt, az Purpose Convert Hour Angle and Declination to Horizon (Alt-Az) coordinates. Explanation Can deal with the NCP singularity.  Intended mainly to be used by program  eq2hor . Arguments Input coordinates may be either a scalar or an array, of the same dimension. ha : the local apparent hour angle, in degrees.  The hour angle is the time that right ascension of 0 hours crosses the local meridian.  It is unambiguously defined. dec : the local apparent declination, in degrees. lat : the local geodetic latitude, in degrees, scalar or array. ws  (optional boolean keyword): if true, the output azimuth is measured West from South.  The default is to measure azimuth East from North. ha  and  dec  can be given as a 2-tuple  (ha, dec) . Output 2-tuple  (alt, az) alt : local apparent altitude, in degrees. az : the local apparent azimuth, in degrees. The output coordinates are always floating points and have the same type (scalar or array) as the input coordinates. Example Arcturus is observed at an apparent hour angle of 336.6829 and a declination of 19.1825 while at the latitude of +43° 4' 42''.  What are the local altitude and azimuth of this object? julia> using AstroLib\n\njulia> alt, az = hadec2altaz(336.6829, 19.1825, ten(43, 4, 42))\n(59.08617155005685, 133.3080693440254) Notes altaz2hadec  converts Horizon (Alt-Az) coordinates to Hour Angle and Declination. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1199,"pagetitle":"Reference","title":"AstroLib.helio","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.helio","content":" AstroLib.helio  —  Function helio(jd, list[, radians=true]) -> hrad, hlong, hlat Purpose Compute heliocentric coordinates for the planets. Explanation The mean orbital elements for epoch J2000 are used. These are derived from a 250 yr least squares fit of the DE 200 planetary ephemeris to a Keplerian orbit where each element is allowed to vary linearly with time. Useful mainly for dates between 1800 and 2050, this solution fits the terrestrial planet orbits to ~25'' or better, but achieves only ~600'' for Saturn. Arguments jd : julian date, scalar or vector num : integer denoting planet number, scalar or vector 1 = Mercury, 2 = Venus, ... 9 = Pluto radians (optional): if this keyword is set to  true , then the longitude and latitude output are in radians rather than degrees. Output hrad : the heliocentric radii, in astronomical units. hlong : the heliocentric (ecliptic) longitudes, in degrees. hlat : the heliocentric latitudes in degrees. Example Find heliocentric position of Venus on August 23, 2000 julia> using AstroLib\n\njulia> helio(jdcnv(2000,08,23,0), 2)\n(0.7213758288364316, 198.39093251916148, 2.887355631705488) Find the current heliocentric positions of all the planets julia> using AstroLib\n\njulia> helio.([jdcnv(1900)], 1:9)\n9-element Vector{Tuple{Float64, Float64, Float64}}:\n (0.4207394142180803, 202.60972662618906, 3.0503005607270532)\n (0.7274605731764012, 344.5381482401048, -3.3924346961624785)\n (0.9832446886519147, 101.54969268801035, 0.012669354526696368)\n (1.4212659241051142, 287.8531100442217, -1.5754626002228043)\n (5.386813769590955, 235.91306092135062, 0.9131692817310215)\n (10.054339927304339, 268.04069870870387, 1.0851704598594278)\n (18.984683376211326, 250.0555468087738, 0.05297087029604253)\n (29.87722677219009, 87.07244903504716, -1.245060583142733)\n (46.9647515992327, 75.94692594417324, -9.576681044165511) Notes This program is based on the two-body model and thus neglects interactions between the planets. The coordinates are given for equinox 2000 and  not  the equinox of the supplied date. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1200,"pagetitle":"Reference","title":"AstroLib.helio_jd","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.helio_jd-Tuple{Real, Real, Real}","content":" AstroLib.helio_jd  —  Method helio_jd(date, ra, dec[, B1950=true, diff=false]) -> jd_helio\nhelio_jd(date, ra, dec[, B1950=true, diff=true]) -> time_diff Purpose Convert geocentric (reduced) Julian date to heliocentric Julian date. Explanation This procedure corrects for the extra light travel time between the Earth and the Sun. An online calculator for this quantity is available at http://www.physics.sfasu.edu/astro/javascript/hjd.html Users requiring more precise calculations and documentation should look at the IDL code available at http://astroutils.astronomy.ohio-state.edu/time/ Arguments date : reduced Julian date (= JD - 2400000).  You can use  juldate()  to calculate the reduced Julian date. ra  and  dec : right ascension and declination in degrees.  Default equinox is J2000. B1950  (optional boolean keyword): if set to  true , then input coordinates are assumed to be in equinox B1950 coordinates.  Default is  false . diff  (optional boolean keyword): if set to  true , the function returns the time difference (heliocentric JD - geocentric JD) in seconds.  Default is  false . Output The return value depends on the value of  diff  optional keywords: if  diff  is  false  (default), then the heliocentric reduced Julian date is returned. if  diff  is  true , then the time difference in seconds between the geocentric and heliocentric Julian date is returned. Example What is the heliocentric Julian date of an observation of V402 Cygni (J2000: RA = 20 9 7.8, Dec = 37 09 07) taken on June 15, 2016 at 11:40 UT? julia> using AstroLib\n\njulia> jd = juldate(2016, 6, 15, 11, 40);\n\njulia> helio_jd(jd, ten(20, 9, 7.8) * 15, ten(37, 9, 7))\n57554.98808289718 Notes Wayne Warren (Raytheon ITSS) has compared the results of this algorithm with the FORTRAN subroutines in the STARLINK SLALIB library (see http://star-www.rl.ac.uk/).                                                  Time Diff (sec)\n     Date               RA(2000)   Dec(2000)  STARLINK      IDL\n\n1999-10-29T00:00:00.0  21 08 25.  -67 22 00.  -59.0        -59.0\n1999-10-29T00:00:00.0  02 56 33.4 +00 26 55.  474.1        474.1\n1940-12-11T06:55:00.0  07 34 41.9 -00 30 42.  366.3        370.2\n1992-02-29T03:15:56.2  12 56 27.4 +42 10 17.  350.8        350.9\n2000-03-01T10:26:31.8  14 28 36.7 -20 42 11.  243.7        243.7\n2100-02-26T09:18:24.2  08 26 51.7 +85 47 28.  104.0        108.8 Code of this function is based on IDL Astronomy User's Library. source"},{"id":1201,"pagetitle":"Reference","title":"AstroLib.helio_rv","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.helio_rv","content":" AstroLib.helio_rv  —  Function helio_rv(jd, T, P, V_0, K[, e, ω]) -> rv Purpose Return the heliocentric radial velocity of a spectroscopic binary. Explanation This function will return the heliocentric radial velocity of a spectroscopic binary star at a given heliocentric date given its orbit. Arguments jd : time of observation, as number of Julian days. T : time of periastron passage (max. +ve velocity for circular orbits), same time system as  jd P : the orbital period in same units as  jd V_0 : systemic velocity K : velocity semi-amplitude in the same units as  V_0 e : eccentricity of the orbit.  It defaults to 0 if omitted ω : longitude of periastron in degrees.  It defaults to 0 if omitted Output The predicted heliocentric radial velocity in the same units as Gamma for the date(s) specified by  jd . Example What was the heliocentric radial velocity of the primary component of HU Tau at 1730 UT 25 Oct 1994? julia> using AstroLib\n\njulia> jd = juldate(94, 10, 25, 17, 30); # Obtain Geocentric Julian days\n\njulia> hjd = helio_jd(jd, ten(04, 38, 16) * 15, ten(20, 41, 05)); # Convert to HJD\n\njulia> helio_rv(hjd, 46487.5303, 2.0563056, -6, 59.3)\n-62.965570107789475 NB: the functions  juldate  and  helio_jd  return a reduced HJD (HJD - 2400000) and so T and P must be specified in the same fashion. Plot two cycles of an eccentric orbit,  $e = 0.6$ ,  $ω = 45°$  for both components of a binary star.  Use  Plots.jl  for plotting. using Plots\nφ = range(0, stop=2, length=1000); # Generate 1000 phase points\nplot(φ, helio_rv.(φ, 0, 1, 0, 100, 0.6, 45)) # Plot 1st component\nplot(φ, helio_rv.(φ, 0, 1, 0, 100, 0.6, 45+180)) # Plot 2nd component Notes The user should ensure consistency with all time systems being used (i.e.  jd  and  t  should be in the same units and time system).  Generally, users should reduce large time values by subtracting a large constant offset, which may improve numerical accuracy. If using the the function  juldate  and  helio_jd , the reduced HJD time system must be used throughtout. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1202,"pagetitle":"Reference","title":"AstroLib.hor2eq","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.hor2eq","content":" AstroLib.hor2eq  —  Function hor2eq(alt, az, jd[, obsname;\n       ws=false, B1950=false, precession=true, nutate=true,\n       aberration=true, refract=true,\n       lat=NaN, lon=NaN, altitude=0,\n       pressure=NaN, temperature=NaN]) -> ra, dec, ha\n\nhor2eq(alt, az, jd, lat, lon[, altitude=0;\n       ws=false, B1950=false, precession=true, nutate=true,\n       aberration=true, refract=true,\n       pressure=NaN, temperature=NaN]) -> ra, dec, ha Purpose Converts local horizon coordinates (alt-az) to equatorial (ra-dec) coordinates. Explanation This is a function to calculate equatorial (ra,dec) coordinates from horizon (alt,az) coords. It is accurate to about 1 arcsecond or better. It performs precession, nutation, aberration, and refraction corrections. Arguments This function has two base methods.  With one you can specify the name of the observatory, if present in  AstroLib.observatories , with the other one you can provide the coordinates of the observing site and, optionally, the altitude. Common mandatory arguments: alt : altitude of horizon coords, in degrees az : azimuth angle measured East from North (unless ws is  true ), in degrees jd : julian date Other positional arguments: obsname : set this to a valid observatory name in  AstroLib.observatories . or lat : north geodetic latitude of location, in degrees. lon : AST longitude of location, in degrees. You can specify west longitude with a negative sign. altitude : the altitude of the observing location, in meters.  It is  0  by default Optional keyword arguments: ws  (optional boolean keyword): set this to  true  to get the azimuth measured westward from south. This is  false  by default B1950  (optional boolean keyword): set this to  true  if the ra and dec are specified in B1950 (FK4 coordinates) instead of J2000 (FK5). This is  false  by default precession  (optional boolean keyword): set this to  false  for no precession,  true  by default nutate  (optional boolean keyword): set this to  false  for no nutation,  true  by default aberration  (optional boolean keyword): set this to  false  for no aberration correction,  true  by default refract  (optional boolean keyword): set this to  false  for no refraction correction,  true  by default pressure  (optional keyword): the pressure at the observing location, in millibars. Default value is  NaN temperature  (optional keyword): the temperature at the observing location, in Kelvins. Default value is  NaN Output ra : right ascension of object, in degrees (FK5) dec : declination of the object, in degrees (FK5) ha : hour angle, in degrees Example You are at Kitt Peak National Observatory, looking at a star at azimuth angle 264d 55m 06s and elevation 37d 54m 41s (in the visible). Today is Dec 25, 2041 and the local time is 10 PM precisely. What is the right ascension and declination (J2000) of the star you're looking at? The temperature here is about 0 Celsius, and the pressure is 781 millibars. The Julian date for this time is 2466879.7083333 julia> using AstroLib\n\njulia> ra_o, dec_o = hor2eq(ten(37,54,41), ten(264,55,06), 2466879.7083333,\n                            \"kpno\", pressure = 781, temperature = 273)\n(3.3224480269254713, 15.19061543702944, 54.61174536229464)\n\njulia> adstring(ra_o, dec_o)\n\" 00 13 17.4  +15 11 26\" Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1203,"pagetitle":"Reference","title":"AstroLib.imf","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.imf-Tuple{AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}}","content":" AstroLib.imf  —  Method imf(mass, expon, mass_range) -> psi Purpose Compute an N-component power-law logarithmic initial mass function (IMF). Explanation The function is normalized so that the total mass distribution equals one solar mass. Arguments mass : mass in units of solar mass, vector. expon : power law exponent, vector. The number of values in expon equals the number of different power-law components in the IMF. mass_range : vector containing the mass upper and lower limits of the IMF and masses where the IMF exponent changes. The number of values in mass range should be one more than in expon. The values in mass range should be monotonically increasing and positive. Output psi : mass function, number of stars per unit logarithmic mass interval evaluated for supplied masses. Example Show the number of stars per unit mass interval at 3 Msun for a Salpeter (expon = -1.35) IMF, with a mass range from 0.1 MSun to 110 Msun. julia> using AstroLib\n\njulia> imf([3], [-1.35], [0.1, 110]) / 3\n1-element Vector{Float64}:\n 0.01294143518151214 Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1204,"pagetitle":"Reference","title":"AstroLib.ismeuv","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.ismeuv","content":" AstroLib.ismeuv  —  Function ismeuv(wave, hcol[, he1col=hcol*0.1, he2col=0, fano=false]) -> tau Purpose Compute the continuum interstellar EUV optical depth Explanation The EUV optical depth is computed from the photoionization of hydrogen and helium. Arguments wave : wavelength value (in Angstroms). Useful range is 40 - 912 A; at shorter wavelength metal opacity should be considered, at longer wavelengths there is no photoionization. hcol : interstellar hydrogen column density in cm-2. he1col  (optional): neutral helium column density in cm-2. Default is 0.1*hcol (10% of hydrogen column) he2col  (optional): ionized helium column density in cm-2 Default is 0. fano  (optional boolean keyword): If this keyword is true, then the 4 strongest auto-ionizing resonances of He I are included. The shape of these resonances is given by a Fano profile - see Rumph, Bowyer, & Vennes 1994, AJ, 107, 2108. If these resonances are included then the input wavelength vector should have a fine (>~0.01 A) grid between 190 A and 210 A, since the resonances are very narrow. Output tau : Vector giving resulting optical depth, non-negative values. Example One has a model EUV spectrum with wavelength, w (in Angstroms). Find the EUV optical depth by 1e18 cm-2 of HI, with N(HeI)/N(HI) = N(HeII)/N(HI) = 0.05. julia> using AstroLib\n\njulia> ismeuv.([670, 910], 1e19, 5e17, 5e17)\n2-element Vector{Float64}:\n 27.35393320556168\n 62.683796028917286 Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1205,"pagetitle":"Reference","title":"AstroLib.jdcnv","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.jdcnv","content":" AstroLib.jdcnv  —  Function jdcnv(date) -> julian_days Purpose Convert proleptic Gregorian Calendar date in UTC standard to number of Julian days. Explanation Takes the given proleptic Gregorian date in UTC standard and returns the number of Julian calendar days since epoch  -4713-11-24T12:00:00 . Argument date : date in proleptic Gregorian Calendar.  Each element can be either a  DateTime  or anything that can be converted directly to  DateTime . Output Number of Julian days, as a floating point. Example Find the Julian days number at 2016 August 23, 03:39:06. julia> using AstroLib, Dates\n\njulia> jdcnv(DateTime(2016, 08, 23, 03, 39, 06))\n2.4576236521527776e6\n\njulia> jdcnv(2016, 08, 23, 03, 39, 06)\n2.4576236521527776e6\n\njulia> jdcnv(\"2016-08-23T03:39:06\")\n2.4576236521527776e6 Notes This is the inverse of  daycnv . get_juldate  returns the number of Julian days for current time.  It is equivalent to  jdcnv(now(Dates.UTC)) . For the conversion of Julian date to number of Julian days, use  juldate . source"},{"id":1206,"pagetitle":"Reference","title":"AstroLib.jprecess","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.jprecess","content":" AstroLib.jprecess  —  Function jprecess(ra, dec[, epoch]) -> ra2000, dec2000\njprecess(ra, dec, muradec[, parallax=parallax, radvel=radvel]) -> ra2000, dec2000 Purpose Precess positions from B1950.0 (FK4) to J2000.0 (FK5). Explanation Calculate the mean place of a star at J2000.0 on the FK5 system from the mean place at B1950.0 on the FK4 system. jprecess  function has two methods, one for each of the following cases: the proper motion is known and non-zero the proper motion is unknown or known to be exactly zero (i.e. extragalactic radio sources).  Better precision can be achieved in this case by inputting the epoch of the original observations. Arguments The function has 2 methods.  The common mandatory arguments are: ra : input B1950 right ascension, in degrees. dec : input B1950 declination, in degrees. The two methods have a different third argument (see \"Explanation\" section for more details).  It can be one of the following: muradec : 2-element vector containing the proper motion in seconds of arc per tropical  century  in right ascension and declination. epoch : scalar giving epoch of original observations. If none of these two arguments is provided (so  jprecess  is fed only with right ascension and declination), it is assumed that proper motion is exactly zero and  epoch = 1950 . If it is used the method involving  muradec  argument, the following keywords are available: parallax  (optional numerical keyword): stellar parallax, in seconds of arc. radvel  (optional numerical keyword): radial velocity in km/s. Right ascension and declination can be passed as the 2-tuple  (ra, dec) .  You can also pass  ra ,  dec ,  parallax , and  radvel  as arrays, all of the same length N.  In that case,  muradec  should be a matrix 2×N. Output The 2-tuple of right ascension and declination in 2000, in degrees, of input coordinates is returned.  If  ra  and  dec  (and other possible optional arguments) are arrays, the 2-tuple of arrays  (ra2000, dec2000)  of the same length as the input coordinates is returned. Method The algorithm is taken from the Explanatory Supplement to the Astronomical Almanac 1992, page 184.  See also Aoki et al (1983), A&A, 128, 263.  URL: http://adsabs.harvard.edu/abs/1983A%26A...128..263A. Example The SAO catalogue gives the B1950 position and proper motion for the star HD 119288.   Find the J2000 position. RA(1950) = 13h 39m 44.526s Dec(1950) = 8d 38' 28.63'' Mu(RA) = -.0259 s/yr Mu(Dec) = -.093 ''/yr julia> using AstroLib\n\njulia> muradec = 100 * [-15*0.0259, -0.093]; # convert to century proper motion\n\njulia> ra = ten(13, 39, 44.526)*15;\n\njulia> decl = ten(8, 38, 28.63);\n\njulia> adstring(jprecess(ra, decl, muradec), precision=2)\n\" 13 42 12.740  +08 23 17.69\" Notes \"When transferring individual observations, as opposed to catalog mean place, the safest method is to tranform the observations back to the epoch of the observation, on the FK4 system (or in the system that was used to to produce the observed mean place), convert to the FK5 system, and transform to the the epoch and equinox of J2000.0\" – from the Explanatory Supplement (1992), p. 180 bprecess  performs the precession to B1950 coordinates. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1207,"pagetitle":"Reference","title":"AstroLib.juldate","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.juldate-Tuple{Dates.DateTime}","content":" AstroLib.juldate  —  Method juldate(date::DateTime) -> reduced_julia_days Purpose Convert from calendar to Reduced Julian Days. Explanation Julian Day Number is a count of days elapsed since Greenwich mean noon on 1 January 4713 B.C.  Julian Days are the number of Julian days followed by the fraction of the day elapsed since the preceding noon. This function takes the given  date  and returns the number of Julian calendar days since epoch  1858-11-16T12:00:00  (Reduced Julian Days = Julian Days - 2400000). Argument date : date in Julian Calendar, UTC standard.  Each element can be given in  DateTime  type or anything that can be converted to that type. Output The number of Reduced Julian Days is returned. Example Get number of Reduced Julian Days at 2016-03-20T15:24:00. julia> using AstroLib, Dates\n\njulia> juldate(DateTime(2016, 03, 20, 15, 24))\n57468.14166666667\n\njulia> juldate(2016, 03, 20, 15, 24)\n57468.14166666667\n\njulia> juldate(\"2016-03-20T15:24\")\n57468.14166666667 Notes Julian Calendar is assumed, thus before  1582-10-15T00:00:00  this function is  not  the inverse of  daycnv .  For the conversion proleptic Gregorian date to number of Julian days, use  jdcnv , which is the inverse of  daycnv . Code of this function is based on IDL Astronomy User's Library. source"},{"id":1208,"pagetitle":"Reference","title":"AstroLib.kepler_solver","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.kepler_solver","content":" AstroLib.kepler_solver  —  Function kepler_solver(M, e) -> E Purpose Solve Kepler's equation in the elliptic motion regime ( $0 ≤ e ≤ 1$ ) and return eccentric anomaly  $E$ . Explanation In order to find the position of a body in elliptic motion (e.g., in the two-body problem) at a given time  $t$ , one has to solve the  Kepler's equation \\[M(t) = E(t) - e \\sin E(t)\\] where  $M(t) = (t - t_0)/P$  is the mean anomaly,  $E(t)$  the eccentric anomaly,  $e$  the eccentricity of the orbit,  $t_0$  is the time of periapsis passage, and  $P$  is the period of the orbit.  Usually the eccentricity is given and one wants to find the eccentric anomaly  $E(t)$  at a specific time  $t$ , so that also the mean anomaly  $M(t)$  is known. Arguments M : mean anomaly. e : eccentricity, in the elliptic motion regime ( $0 ≤ e ≤ 1$ ) Output The eccentric anomaly  $E$ , restricted to the range  $[-π, π]$ . Method Many different numerical methods exist to solve Kepler's equation.  This function implements the algorithm proposed in Markley (1995) Celestial Mechanics and Dynamical Astronomy, 63, 101 (DOI: 10.1007/BF00691917 ).  This method is not iterative, requires only four transcendental function evaluations, and has been proved to be fast and efficient over the entire range of elliptic motion  $0 ≤ e ≤ 1$ . Example Find the eccentric anomaly for an orbit with eccentricity  $e = 0.7$  and for  $M(t) = 8π/3$ . julia> using AstroLib\n\njulia> ecc = 0.7;\n\njulia> E = kepler_solver(8pi/3, ecc)\n2.5085279492864223 Plot the eccentric anomaly as a function of mean anomaly for eccentricity  $e = 0, 0.5, 0.9$ .  Recall that  kepler_solver  gives  $E ∈ [-π, π]$ , use  mod2pi  to have it in  $[0, 2π]$ .  Use  Plots.jl  for plotting. using AstroLib\nusing Plots\nM = range(0, stop=2pi, length=1001)[1:end-1];\nfor ecc in (0, 0.5, 0.9)\n    plot(M, mod2pi.(kepler_solver.(M, ecc)))\nend Notes The true anomaly can be calculated with  trueanom  function. source"},{"id":1209,"pagetitle":"Reference","title":"AstroLib.lsf_rotate","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.lsf_rotate","content":" AstroLib.lsf_rotate  —  Function lsf_rotate(delta_v, v_sin_i[, epsilon = 0.3]) -> velocity_grid, lsf Purpose Create a 1-d convolution kernel to broaden a spectrum from a rotating star. Explanation Can be used to derive the broadening effect (LSF, line spread function) due to rotation on a synthetic stellar spectrum.  Assumes constant limb darkening across the disk. Arguments delta_v : the step increment (in km/s) in the output rotation kernel v_sin_i : the rotational velocity projected along the line of sight (km/s) epsilon  (optional numeric argument): the limb-darkening coefficient, default = 0.6 which is typical for photospheric lines.  The specific intensity  $I$  at any angle  $θ$  from the specific intensity  $I_{\\text{cen}}$  at the center of the disk is given by: \\[I = I_{\\text{cen}} ⋅ (1 - ε ⋅ (1 - \\cos(θ)))\\] Output The 2-tuple ( velocity_grid ,  lsf ): velocity_grid : vector of velocity grid with the same number of elements as  lsf  (see below) lsf : the convolution kernel vector for the specified rotational velocity. The number of points in  lsf  will be always be odd (the kernel is symmetric) and equal to either  ceil(2*v_sin_i/delta_v)  or  ceil(2*v_sin_i/delta_v) + 1 , whichever number is odd.  Elements of  lsf  will always be of type  AbstractFloat .  To actually compute the broadening, the spectrum should be convolved with the rotational  lsf Example Plot the line spread function for a star rotating at 90 km/s in velocity space every 3 km/s.  Use  Plots.jl  for plotting. using Plots\nplot(lsf_rotate(3, 90)...) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1210,"pagetitle":"Reference","title":"AstroLib.mag2flux","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.mag2flux","content":" AstroLib.mag2flux  —  Function mag2flux(mag[, zero_point, ABwave=number]) -> flux Purpose Convert from magnitudes to flux expressed in erg/(s cm² Å). Explanation This is the reverse of  flux2mag . Arguments mag : the magnitude to be converted in flux. zero_point : the zero point level of the magnitude.  If not supplied then defaults to 21.1 (Code et al 1976).  Ignored if the  ABwave  keyword is supplied ABwave  (optional numeric keyword): wavelength, in Angstroms.  If supplied, then the input  mag  is assumed to contain Oke AB magnitudes (Oke & Gunn 1983, ApJ, 266, 713; http://adsabs.harvard.edu/abs/1983ApJ...266..713O). Output The flux. If the  ABwave  keyword is set, then the flux is given by the expression \\[\\text{flux} = 10^{-0.4(\\text{mag} +2.406 + 4\\log_{10}(\\text{ABwave}))}\\] Otherwise the flux is given by \\[\\text{flux} =  10^{-0.4(\\text{mag} + \\text{zero point})}\\] Example julia> using AstroLib\n\njulia> mag2flux(8.3)\n1.7378008287493692e-12\n\njulia> mag2flux(8.3, 12)\n7.58577575029182e-9\n\njulia> mag2flux(8.3, ABwave=12)\n3.624411568301719e-7 Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1211,"pagetitle":"Reference","title":"AstroLib.mag2geo","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.mag2geo","content":" AstroLib.mag2geo  —  Function mag2geo(latitude, longitude[, year]) -> geographic_latitude, geographic_longitude Purpose Convert from geomagnetic to geographic coordinates. Explanation Converts from geomagnetic (latitude, longitude) to geographic (latitude, longitude).  Altitude is not involved in this function. Arguments latitude : geomagnetic latitude (North), in degrees. longitude : geomagnetic longitude (East), in degrees. year  (optional numerical argument): the year in which to perform conversion. If omitted, defaults to current year. The coordinates can be passed as arrays of the same length. Output The 2-tuple of geographic (latitude, longitude) coordinates, in degrees. If geomagnetic coordinates are given as arrays, a 2-tuple of arrays of the same length is returned. Example Find position of North Magnetic Pole in 2016 julia> using AstroLib\n\njulia> mag2geo(90, 0, 2016)\n(86.395, -166.29000000000002) Notes This function uses list of North Magnetic Pole positions provided by World Magnetic Model (https://www.ngdc.noaa.gov/geomag/data/poles/NP.xy). geo2mag  converts geographic coordinates to geomagnetic coordinates. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1212,"pagetitle":"Reference","title":"AstroLib.mean_obliquity","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.mean_obliquity-Tuple{Real}","content":" AstroLib.mean_obliquity  —  Method mean_obliquity(jd) -> m_eps Purpose Return the mean obliquity of the ecliptic for a given Julian date Explanation The function is used by the  co_nutate  procedure. Arguments jd : julian date Output m_eps : mean obliquity of the ecliptic, in radians Example julia> using AstroLib\n\njulia> mean_obliquity(jdcnv(1978,01,7,11, 01))\n0.4091425159336512 Notes The algorithm used to find the mean obliquity( eps0 ) is mentioned in USNO Circular 179, but the canonical reference for the IAU adoption is apparently Hilton et al., 2006, Celest.Mech.Dyn.Astron. 94, 351. 2000 source"},{"id":1213,"pagetitle":"Reference","title":"AstroLib.month_cnv","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.month_cnv-Tuple{Integer}","content":" AstroLib.month_cnv  —  Method month_cnv(number[, shor=true, up=true, low=true]) -> month_name\nmonth_cnv(name) -> number Purpose Convert between a month English name and  the equivalent number. Explanation For example, converts from \"January\" to 1  or vice-versa. Arguments The functions has two methods, one with numeric input (and three possible boolean keywords) and the other one with string input. Numeric input arguments: number : the number of the month to be converted to month name. short  (optional boolean keyword): if true, the abbreviated (3-character) name of the month will be returned, e.g. \"Apr\" or \"Oct\".  Default is false. up  (optional boolean keyword): if true, the name of the month will be all in upper case, e.g. \"APRIL\" or \"OCTOBER\".  Default is false. low  (optional boolean keyword): if true, the name of the month will be all in lower case, e.g. \"april\" or \"october\".  Default is false. String input argument: name : month name to be converted to month number. Output The month name or month number, depending on the input.  For numeric input, the format of the month name is influenced by the optional keywords. Example julia> using AstroLib\n\njulia> month_cnv.([\"janua\", \"SEP\", \"aUgUsT\"])\n3-element Vector{Int64}:\n 1\n 9\n 8\n\njulia> month_cnv.([2, 12, 6], short=true, low=true)\n3-element Vector{String}:\n \"feb\"\n \"dec\"\n \"jun\" source"},{"id":1214,"pagetitle":"Reference","title":"AstroLib.moonpos","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.moonpos","content":" AstroLib.moonpos  —  Function moonpos(jd[, radians=true]) -> ra, dec, dis, geolong, geolat Purpose Compute the right ascension and declination of the Moon at specified Julian date. Arguments jd : the Julian ephemeris date.  It can be either a scalar or an array radians  (optional boolean keyword): if set to  true , then all output angular quantities are given in radians rather than degrees.  The default is  false Output The 5-tuple  (ra, dec, dis, geolong, geolat) : ra : apparent right ascension of the Moon in degrees, referred to the true equator of the specified date(s) dec : the declination of the Moon in degrees dis : the distance between the centre of the Earth and the centre of the Moon in kilometers geolong : apparent longitude of the moon in degrees, referred to the ecliptic of the specified date(s) geolat : apparent longitude of the moon in degrees, referred to the ecliptic of the specified date(s) If  jd  is an array, then all output quantities are arrays of the same length as  jd . Method Derived from the Chapront ELP2000/82 Lunar Theory (Chapront-Touze' and Chapront, 1983, 124, 50), as described by Jean Meeus in Chapter 47 of ``Astronomical Algorithms'' (Willmann-Bell, Richmond), 2nd edition, 1998.  Meeus quotes an approximate accuracy of 10\" in longitude and 4\" in latitude, but he does not give the time range for this accuracy. Comparison of the IDL procedure with the example in ``Astronomical Algorithms'' reveals a very small discrepancy (~1 km) in the distance computation, but no difference in the position calculation. Example Find the position of the moon on April 12, 1992 julia> using AstroLib\n\njulia> jd = jdcnv(1992, 4, 12);\n\njulia> adstring(moonpos(jd)[1:2],precision=1)\n\" 08 58 45.23  +13 46 06.1\" This is within 1\" from the position given in the Astronomical Almanac. Plot the Earth-moon distance during 2016 with sampling of 6 hours.  Use  Plots.jl  for plotting using Dates\nusing Plots\npoints = DateTime(2016):Dates.Hour(6):DateTime(2017);\nplot(points, moonpos(jdcnv.(points))[3]) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1215,"pagetitle":"Reference","title":"AstroLib.mphase","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.mphase-Tuple{Real}","content":" AstroLib.mphase  —  Method mphase(jd) -> k Purpose Return the illuminated fraction of the Moon at given Julian date(s). Arguments jd : the Julian ephemeris date. Output The illuminated fraction  $k$  of Moon's disk, with  $0 ≤ k ≤ 1$ .  $k = 0$  indicates a new moon, while  $k = 1$  stands for a full moon. Method Algorithm from Chapter 46 of \"Astronomical Algorithms\" by Jean Meeus (Willmann-Bell, Richmond) 1991.   sunpos  and  moonpos  are used to get positions of the Sun and the Moon, and the Moon distance.  The selenocentric elongation of the Earth from the Sun (phase angle) is then computed, and used to determine the illuminated fraction. Example Plot the illuminated fraction of the Moon for every day in January 2018 with a hourly sampling.  Use  Plots.jl  for plotting using Dates\nusing Plots\npoints = DateTime(2018,01,01):Dates.Hour(1):DateTime(2018,01,31,23,59,59);\nplot(points, mphase.(jdcnv.(points))) Note that in this calendar month there are two full moons, this event is called  blue moon . Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1216,"pagetitle":"Reference","title":"AstroLib.nutate","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.nutate-Tuple{Real}","content":" AstroLib.nutate  —  Method nutate(jd) -> long, obliq Purpose Return the nutation in longitude and obliquity for a given Julian date. Arguments jd : Julian ephemeris date, it can be either a scalar or a vector Output The 2-tuple  (long, obliq) , where long : the nutation in longitude obl : the nutation in latitude If  jd  is an array,  long  and  obl  are arrays of the same length. Method Uses the formula in Chapter 22 of \"Astronomical Algorithms\" by Jean Meeus (1998, 2nd ed.) which is based on the 1980 IAU Theory of Nutation and includes all terms larger than 0.0003\". Example Find the nutation in longitude and obliquity 1987 on Apr 10 at 0h.  This is example 22.a from Meeus julia> using AstroLib\n\njulia> jd = jdcnv(1987, 4, 10);\n\njulia> nutate(jd)\n(-3.787931077110494, 9.44252069864449) Plot the daily nutation in longitude and obliquity during the 21st century. Use  Plots.jl  for plotting. using Dates\nusing Plots\nyears = DateTime(2000):DateTime(2100);\nlong, obl = nutate(jdcnv.(years));\nplot(years, long); plot(years, obl) You can see both the dominant large scale period of nutation, of 18.6 years, and smaller oscillations with shorter periods. Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1217,"pagetitle":"Reference","title":"AstroLib.ordinal","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.ordinal-Tuple{Integer}","content":" AstroLib.ordinal  —  Method ordinal(num) -> result Purpose Convert an integer to a correct English ordinal string. Explanation The first four ordinal strings are \"1st\", \"2nd\", \"3rd\", \"4th\", .... Arguments num : number to be made ordinal. It should be of type  Integer . Output result : ordinal string, such as \"1st\", \"3rd\", \"164th\", \"87th\", etc. Example julia> using AstroLib\n\njulia> ordinal.(1:5)\n5-element Vector{String}:\n \"1st\"\n \"2nd\"\n \"3rd\"\n \"4th\"\n \"5th\" Notes This function does not support float arguments, unlike the IDL implementation. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1218,"pagetitle":"Reference","title":"AstroLib.paczynski","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.paczynski-Tuple{Real}","content":" AstroLib.paczynski  —  Method paczynski(u) -> amplification Purpose Calculate gravitational microlensing amplification of a point-like source by a single point-like lens. Explanation Return the  gravitational microlensing  amplification of a point-like source by a single point-like lens, using Paczyński formula \\[A(u) = \\frac{u^2 + 2}{u\\sqrt{u^2 + 4}}\\] where  $u$  is the projected distance between the lens and the source in units of  Einstein radii . In order to speed up calculations for extreme values of  $u$ , the following asyntotic expressions for  $A(u)$  are used: \\[A(u) =\n\\begin{cases}\n 1/u & |u| ≪ 1 \\\\\n \\text{sgn}(u) & |u| ≫ 1\n\\end{cases}\\] Arguments u : projected distance between the lens and the source, in units of Einstein radii Output The microlensing amplification for the given distance. Example Calculate the microlensing amplification for  $u = 10^{-10}, 10^{-1}, 1, 10, 10^{10}$ : julia> paczynski.([1e-10, 1e-1, 1, 10, 1e10])\n5-element Vector{Float64}:\n  1.0e10\n 10.037461005722337\n  1.3416407864998738\n  1.0001922892047386\n  1.0 Notes The expression of  $A(u)$  of microlensing amplification has been given by Bohdan Paczyński in Paczynski, B. 1986, ApJ, 304, 1. DOI: 10.1086/164140 , Bibcode: 1986ApJ...304....1P The same expression was actually found by Albert Einstein half a century earlier: Einstein, A. 1936, Science, 84, 506. DOI: 10.1126/science.84.2188.506 , Bibcode: 1936Sci....84..506E source"},{"id":1219,"pagetitle":"Reference","title":"AstroLib.planck_freq","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.planck_freq-Tuple{Real, Real}","content":" AstroLib.planck_freq  —  Method planck_freq(frequency, temperature) -> black_body_flux Purpose Calculate the flux of a black body per unit frequency. Explanation Return the spectral radiance of a black body per unit frequency using  Planck's law \\[B_\\nu(\\nu, T) = \\frac{2h\\nu^3}{c^2} \\frac{1}{e^\\frac{h\\nu}{k_\\mathrm{B}T} - 1}\\] Arguments frequency : frequency at which the flux is to be calculated, in Hertz. temperature : the equilibrium temperature of the black body, in Kelvin. Output The spectral radiance of the black body, in units of W/(sr·m²·Hz). Example Plot the spectrum of a black body in  $[10^{12}, 10^{15.4}]$  Hz at 8000 K. Use  Plots.jl  for plotting. using Plots\nfrequency = exp10.(range(12, stop=15.4, length=1000));\ntemperature = ones(size(frequency)) * 8000;\nflux = planck_freq.(frequency, temperature);\nplot(frequency, flux) Notes planck_wave  calculates the flux of a black body per unit wavelength. source"},{"id":1220,"pagetitle":"Reference","title":"AstroLib.planck_wave","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.planck_wave-Tuple{Real, Real}","content":" AstroLib.planck_wave  —  Method planck_wave(wavelength, temperature) -> black_body_flux Purpose Calculate the flux of a black body per unit wavelength. Explanation Return the spectral radiance of a black body per unit wavelength using  Planck's law \\[B_λ(λ, T) = \\frac{2hc^2}{λ^5} \\frac{1}{e^{\\frac{hc}{λ k_\\mathrm{B}T}} - 1}\\] Arguments wavelength : wavelength at which the flux is to be calculated, in meters. temperature : the equilibrium temperature of the black body, in Kelvin. Output The spectral radiance of the black body, in units of W/(sr·m³). Example Plot the spectrum of a black body in  $[0, 3]$  µm at  $5000$  K.  Use  Plots.jl  for plotting. using Plots\nwavelength = range(0, stop=3e-6, length=1000);\ntemperature = ones(wavelength)*5000;\nflux = planck_wave.(wavelength, temperature);\nplot(wavelength, flux) Notes planck_freq  calculates the flux of a black body per unit frequency. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1221,"pagetitle":"Reference","title":"AstroLib.planet_coords","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.planet_coords-Tuple{Real, Integer}","content":" AstroLib.planet_coords  —  Method planet_coords(date, num) Purpose Find right ascension and declination for the planets when provided a date as input. Explanation This function uses the  helio  to get the heliocentric ecliptic coordinates of the planets at the given date which it then converts these to geocentric ecliptic coordinates ala \"Astronomical Algorithms\" by Jean Meeus (1991, p 209). These are then converted to right ascension and declination using  euler . The accuracy between the years 1800 and 2050 is better than 1 arcminute for the terrestial planets, but reaches 10 arcminutes for Saturn. Before 1850 or after 2050 the accuracy can get much worse. Arguments date : Can be either a single date or an array of dates. Each element can be either a  DateTime  type or Julian Date. It can be a scalar or vector. num : integer denoting planet number, scalar or vector 1 = Mercury, 2 = Venus, ... 9 = Pluto. If not in that change, then the program will throw an error. Output ra : right ascension of planet(J2000), in degrees dec : declination of the planet(J2000), in degrees Example Find the RA, Dec of Venus on 1992 Dec 20 julia> using AstroLib, Dates\n\njulia> adstring(planet_coords(DateTime(1992,12,20),2))\n\" 21 05 02.8  -18 51 41\" Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1222,"pagetitle":"Reference","title":"AstroLib.polrec","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.polrec-Tuple{Real, Real}","content":" AstroLib.polrec  —  Method polrec(radius, angle[, degrees=true]) -> x, y Purpose Convert 2D polar coordinates to rectangular coordinates. Explanation This is the partial inverse function of  recpol . Arguments radius : radial coordinate of the point.  It may be a scalar or an array. angle : the angular coordinate of the point.  It may be a scalar or an array of the same lenth as  radius . degrees  (optional boolean keyword): if  true , the  angle  is assumed to be in degrees, otherwise in radians.  It defaults to  false . Mandatory arguments can also be passed as the 2-tuple  (radius, angle) , so that it is possible to execute  recpol(polrec(radius, angle)) . Output A 2-tuple  (x, y)  with the rectangular coordinate of the input.  If  radius  and  angle  are arrays,  x  and  y  are arrays of the same length as  radius  and  angle . Example Get rectangular coordinates  $(x, y)$  of the point with polar coordinates  $(r, φ) = (1.7, 227)$ , with angle  $φ$  expressed in degrees. julia> using AstroLib\n\njulia> x, y = polrec(1.7, 227, degrees=true)\n(-1.1593972121062475, -1.2433012927525897) source"},{"id":1223,"pagetitle":"Reference","title":"AstroLib.posang","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.posang-Tuple{Integer, Vararg{Real, 4}}","content":" AstroLib.posang  —  Method posang(units, ra1, dec1, ra2, dec2) -> angular_distance Purpose Compute rigorous position angle of point 2 relative to point 1. Explanation Computes the rigorous position angle of point 2 (with given right ascension and declination) using point 1 (with given right ascension and declination) as the center. Arguments units : integer, can be either 0, or 1, or 2.  Describes units of inputs and output: 0: everything (input right ascensions and declinations, and output distance) is radians 1: right ascensions are in decimal hours, declinations in decimal degrees, output distance in degrees 2: right ascensions and declinations are in degrees, output distance in degrees ra1 :  right ascension or longitude of point 1 dec1 : declination or latitude of point 1 ra2 : right ascension or longitude of point 2 dec2 : declination or latitude of point 2 Both  ra1  and  dec1 , and  ra2  and  dec2  can be given as 2-tuples  (ra1, dec1)  and  (ra2, dec2) . Output Angle of the great circle containing  [ra2, dec2]  from the meridian containing  [ra1, dec1] , in the sense north through east rotating about  [ra1, dec1] . See  units  argument above for units. Method The \"four-parts formula\" from spherical trigonometry (p. 12 of Smart's Spherical Astronomy or p. 12 of Green' Spherical Astronomy). Example Mizar has coordinates (ra, dec) = (13h 23m 55.5s, +54° 55' 31'').  Its companion, Alcor, has coordinates (ra, dec) = (13h 25m 13.5s, +54° 59' 17''). Find the position angle of Alcor with respect to Mizar. julia> using AstroLib\n\njulia> posang(1, ten(13, 25, 13.5), ten(54, 59, 17), ten(13, 23, 55.5), ten(54, 55, 31))\n-108.46011246802047 Notes The function  sphdist  provides an alternate method of computing a spherical distance. Note that  posang  is not commutative: the position angle between A and B is  $θ$ , then the position angle between B and A is  $180 + θ$ . Code of this function is based on IDL Astronomy User's Library. source"},{"id":1224,"pagetitle":"Reference","title":"AstroLib.precess","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.precess-NTuple{4, Real}","content":" AstroLib.precess  —  Method precess(ra, dec, equinox1, equinox2[, FK4=true, radians=true]) -> prec_ra, prec_dec Purpose Precess coordinates from  equinox1  to  equinox2 . Explanation The default  (ra, dec)  system is FK5 based on epoch J2000.0 but FK4 based on B1950.0 is available via the  FK4  boolean keyword. Arguments ra : input right ascension, scalar or vector, in degrees, unless the  radians  keyword is set to  true dec : input declination, scalar or vector, in degrees, unless the  radians  keyword is set to  true equinox1 : original equinox of coordinates, numeric scalar. equinox2 : equinox of precessed coordinates. FK4  (optional boolean keyword): if this keyword is set to  true , the FK4 (B1950.0) system precession angles are used to compute the precession matrix. When it is  false , the default, use FK5 (J2000.0) precession angles. radians  (optional boolean keyword): if this keyword is set to  true , then the input and output right ascension and declination vectors are in radians rather than degrees. Output The 2-tuple  (ra, dec)  of coordinates modified by precession. Example The Pole Star has J2000.0 coordinates (2h, 31m, 46.3s, 89d 15' 50.6\"); compute its coordinates at J1985.0 julia> using AstroLib\n\njulia> ra, dec = ten(2,31,46.3)*15, ten(89,15,50.6)\n(37.94291666666666, 89.26405555555556)\n\njulia> adstring(precess(ra, dec, 2000, 1985), precision=1)\n\" 02 16 22.73  +89 11 47.3\" Precess the B1950 coordinates of Eps Ind (RA = 21h 59m,33.053s, DEC = -56d, 59', 33.053\") to equinox B1975. julia> using AstroLib\n\njulia> ra, dec = ten(21, 59, 33.053) * 15, ten(-56, 59, 33.053)\n(329.88772083333333, -56.992514722222225)\n\njulia> adstring(precess(ra, dec, 1950, 1975, FK4=true), precision=1)\n\" 22 01 15.46  -56 52 18.7\" Method Algorithm from \"Computational Spherical Astronomy\" by Taff (1983), p. 24. (FK4). FK5 constants from \"Explanatory Supplement To The Astronomical Almanac\" 1992, page 104 Table 3.211.1 (https://archive.org/details/131123ExplanatorySupplementAstronomicalAlmanac). Notes Accuracy of precession decreases for declination values near 90 degrees.  precess  should not be used more than 2.5 centuries from 2000 on the FK5 system (1950.0 on the FK4 system).  If you need better accuracy, use  bprecess  or  jprecess  as needed. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1225,"pagetitle":"Reference","title":"AstroLib.precess_cd","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.precess_cd","content":" AstroLib.precess_cd  —  Function precess_cd(cd, epoch1, epoch2, crval_old, crval_new[, FK4=true]) -> cd Purpose Precess the coordinate description matrix. Explanation The coordinate matrix is precessed from epoch1 to epoch2. Arguments cd : 2×2 coordinate description matrix in degrees epoch1 : original equinox of coordinates, scalar epoch2 : equinox of precessed coordinates, scalar crval_old : 2 element vector containing right ascension and declination in degrees of the reference pixel in the original equinox crval_new : 2 element vector giving crval in the new equinox FK4  (optional boolean keyword): if this keyword is set to  true , then the precession constants are taken in the FK4 reference frame. When it is  false , the default is the FK5 frame Output cd : coordinate description containing precessed values Example julia> using AstroLib\n\njulia> precess_cd([20 60; 45 45], 1950, 2000, [34, 58], [12, 83])\n2×2 Matrix{Float64}:\n  48.8944  147.075\n 110.188   110.365 Notes Code of this function is based on IDL Astronomy User's Library. This function should not be used for values more than 2.5 centuries from the year 1900. This function calls  sec2rad ,  precess  and  bprecess . source"},{"id":1226,"pagetitle":"Reference","title":"AstroLib.precess_xyz","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.precess_xyz-NTuple{5, Real}","content":" AstroLib.precess_xyz  —  Method precess_xyz(x, y, z, equinox1, equinox2) -> prec_x, prec_y, prec_z Purpose Precess equatorial geocentric rectangular coordinates. Arguments x ,  y ,  z : scalars or vectors giving heliocentric rectangular coordinates. equinox1 : original equinox of coordinates, numeric scalar. equinox2 : equinox of precessed coordinates, numeric scalar. Input coordinates can be given also a 3-tuple  (x, y, z) . Output The 3-tuple  (x, y, z)  of coordinates modified by precession. Example Precess 2000 equinox coordinates  (1, 1, 1)  to 2050. julia> using AstroLib\n\njulia> precess_xyz(1, 1, 1, 2000, 2050)\n(0.9838854500981734, 1.0110925876508692, 1.0048189888146941) Method The equatorial geocentric rectangular coordinates are converted to right ascension and declination, precessed in the normal way, then changed back to  x ,  y  and  z  using unit vectors. Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1227,"pagetitle":"Reference","title":"AstroLib.premat","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.premat-Tuple{Real, Real}","content":" AstroLib.premat  —  Method premat(equinox1, equinox2[, FK4=true]) -> precession_matrix Purpose Return the precession matrix needed to go from  equinox1  to  equinox2 . Explanation This matrix is used by  precess  and  baryvel  to precess astronomical coordinates. Arguments equinox1 : original equinox of coordinates. equinox2 : equinox of precessed coordinates. FK4  (optional boolean keyword): if this keyword is set to  true , the FK4 (B1950.0) system precession angles are used to compute the precession matrix. When it is  false , the default, use FK5 (J2000.0) precession angles. Output A 3×3 matrix, used to precess equatorial rectangular coordinates. Example Return the precession matrix from 1950.0 to 1975.0 in the FK4 system julia> using AstroLib\n\njulia> premat(1950, 1975, FK4=true)\n3×3 StaticArraysCore.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n 0.999981    -0.00558775  -0.00242909\n 0.00558775   0.999984    -6.78691e-6\n 0.00242909  -6.78633e-6   0.999997 Method FK4 constants from \"Computational Spherical Astronomy\" by Taff (1983), p. 24. (FK4). FK5 constants from \"Explanatory Supplement To The Astronomical Almanac\" 1992, page 104 Table 3.211.1 (https://archive.org/details/131123ExplanatorySupplementAstronomicalAlmanac). Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1228,"pagetitle":"Reference","title":"AstroLib.rad2sec","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.rad2sec-Tuple{Real}","content":" AstroLib.rad2sec  —  Method rad2sec(rad) -> seconds Purpose Convert from radians to seconds. Argument rad : number of radians. Output The number of seconds corresponding to  rad . Example julia> using AstroLib\n\njulia> rad2sec(1)\n206264.80624709636 Notes Use  sec2rad  to convert seconds to radians. source"},{"id":1229,"pagetitle":"Reference","title":"AstroLib.radec","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.radec-Tuple{Real, Real}","content":" AstroLib.radec  —  Method radec(ra::Real, dec::Real[, hours=false]) -> ra_hours, ra_minutes, ra_seconds, dec_degrees, dec_minutes, dec_seconds Purpose Convert right ascension and declination from decimal to sexagesimal units. Explanation The conversion is to sexagesimal hours for right ascension, and sexagesimal degrees for declination. Arguments ra : decimal right ascension, scalar or array.  It is expressed in degrees, unless the optional keyword  hours  is set to  true . dec : declination in decimal degrees, scalar or array, same number of elements as  ra . hours  (optional boolean keyword): if  false  (the default),  ra  is assumed to be given in degrees, otherwise  ra  is assumed to be expressed in hours. Output A 6-tuple of  AbstractFloat : (ra_hours, ra_minutes, ra_seconds, dec_degrees, dec_minutes, dec_seconds) If  ra  and  dec  are arrays, also each element of the output 6-tuple are arrays of the same dimension. Example Position of Sirius in the sky is (ra, dec) = (6.7525, -16.7161), with right ascension expressed in hours.  Its sexagesimal representation is given by julia> using AstroLib\n\njulia> radec(6.7525, -16.7161, hours=true)\n(6.0, 45.0, 9.0, -16.0, 42.0, 57.9600000000064) source"},{"id":1230,"pagetitle":"Reference","title":"AstroLib.recpol","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.recpol-Tuple{Real, Real}","content":" AstroLib.recpol  —  Method recpol(x, y[, degrees=false]) -> radius, angle Purpose Convert 2D rectangular coordinates to polar coordinates. Explanation This is the partial inverse function of  polrec . Arguments x : the abscissa coordinate of the point.  It may be a scalar or an array. y : the ordinate coordinate of the point.  It may be a scalar or an array of the same lenth as  x . degrees  (optional boolean keyword): if  true , the output  angle  is given in degrees, otherwise in radians.  It defaults to  false . Mandatory arguments may also be passed as the 2-tuple  (x, y) , so that it is possible to execute  polrec(recpol(x, y)) . Output A 2-tuple  (radius, angle)  with the polar coordinates of the input.  The coordinate  angle  coordinate lies in the range  $[-π, π]$  if  degrees=false , or  $[-180, 180]$  when  degrees=true . If  x  and  y  are arrays,  radius  and  angle  are arrays of the same length as  radius  and  angle . Example Calculate polar coordinates  $(r, φ)$  of point with rectangular coordinates  $(x, y) = (2.24, -1.87)$ . julia> using AstroLib\n\njulia> r, phi = recpol(2.24, -1.87)\n(2.9179616172938263, -0.6956158538564537) Angle  $φ$  is given in radians. source"},{"id":1231,"pagetitle":"Reference","title":"AstroLib.rhotheta","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.rhotheta-NTuple{8, Real}","content":" AstroLib.rhotheta  —  Method rhotheta(period, periastron, eccentricity, semimajor_axis, inclination, omega, omega2, epoch) -> rho, theta Purpose Calculate the separation and position angle of a binary star. Explanation This function will return the separation  $ρ$  and position angle  $θ$  of a visual binary star derived from its orbital elements.  The algorithms described in the following book will be used: Meeus J., 1992, Astronomische Algorithmen, Barth.  Compared to the examples given at page 400 and no discrepancy found. Arguments period : period [year] periastro : time of periastron passage [year] eccentricity : eccentricity of the orbit semimajor_axis : semi-major axis [arc second] inclination : inclination angle [degree] omega : node [degree] omega2 : longitude of periastron [degree] epoch : epoch of observation [year] All input parameters have to be scalars. Output The 2-tuple  $(ρ, θ)$ , where $ρ$  is separation [arc second], and $θ$  is position angle (degree). Example Find the position of Eta Coronae Borealis at the epoch 2016 julia> using AstroLib\n\njulia> ρ, θ = rhotheta(41.623, 1934.008, 0.2763, 0.907, 59.025, 23.717, 219.907, 2016)\n(0.6351167848659552, 214.42513387396497) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1232,"pagetitle":"Reference","title":"AstroLib.sec2rad","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.sec2rad-Tuple{Real}","content":" AstroLib.sec2rad  —  Method sec2rad(sec) -> radians Purpose Convert from seconds to radians. Argument sec : number of seconds. Output The number of radians corresponding to  sec . Example julia> using AstroLib\n\njulia> sec2rad(3600 * 30)\n0.5235987755982988 Notes Use  rad2sec  to convert radians to seconds. source"},{"id":1233,"pagetitle":"Reference","title":"AstroLib.sixty","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.sixty-Tuple{Real}","content":" AstroLib.sixty  —  Method sixty(number) -> [deg, min, sec] Purpose Converts a decimal number to sexagesimal. Explanation The reverse of  ten  function. Argument number : decimal number to be converted to sexagesimal. Output An array of three  AbstractFloat , that are the sexagesimal counterpart (degrees, minutes, seconds) of  number . Example julia> using AstroLib\n\njulia> sixty(-0.615)\n3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):\n -0.0\n 36.0\n 54.0 Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1234,"pagetitle":"Reference","title":"AstroLib.sphdist","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.sphdist-NTuple{4, Real}","content":" AstroLib.sphdist  —  Method sphdist(long1, lat1, long2, lat2[, degrees=true]) -> angular_distance Purpose Angular distance between points on a sphere. Arguments long1 :  longitude of point 1 lat1 : latitude of point 1 long2 : longitude of point 2 lat2 : latitude of point 2 degrees  (optional boolean keyword): if  true , all angles, including the output distance, are assumed to be in degrees, otherwise they are all in radians.  It defaults to  false . Output Angular distance on a sphere between points 1 and 2, as an  AbstractFloat .  It is expressed in radians unless  degrees  keyword is set to  true . Example julia> using AstroLib\n\njulia> sphdist(120, -43, 175, +22)\n1.5904422616007134 Notes gcirc  function is similar to  sphdist , but may be more suitable for astronomical applications. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1235,"pagetitle":"Reference","title":"AstroLib.sunpos","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.sunpos","content":" AstroLib.sunpos  —  Function sunpos(jd[, radians=false]) -> ra, dec, elong, obliquity Purpose Compute the right ascension and declination of the Sun at a given date. Arguments jd : the Julian date of when you want to calculate Sun position.  It can be either a scalar or a vector.  Use  jdcnv  to get the Julian date for a given date and time. radians  (optional boolean keyword): if set to  true , all output quantities are given in radians.  The default is  false , so all quantities are given in degrees. Output The 4-tuple  (ra, dec, elong, obliquity) : ra : the right ascension of the Sun at that date dec : the declination of the Sun at that date elong : ecliptic longitude of the Sun at that date obliquity : the obliquity of the ecliptic All quantities are given in degrees, unless  radians  keyword is set to  true  (see \"Arguments\" section).  If  jd  is an array, arrays of the same given as  jd  are returned. Method Uses a truncated version of Newcomb's Sun.  Adapted from the IDL routine SUN_POS by CD Pike, which was adapted from a FORTRAN routine by B. Emerson (RGO). Example Find the apparent right ascension and declination of the Sun on May 1, 1982 julia> using AstroLib\n\njulia> adstring(sunpos(jdcnv(1982, 5, 1))[1:2], precision=2)\n\" 02 31 32.614  +14 54 34.92\" The Astronomical Almanac gives  02 31 32.58 +14 54 34.9  so the error for this case is < 0.5\". Plot the apparent right ascension, in hours, and declination of the Sun, in degrees, for every day in 2016.  Use  Plots.jl  for plotting. using Plots\nusing Dates\n\ndays = DateTime(2016):Day(1):DateTime(2016, 12, 31);\nra, declin = sunpos(jdcnv.(days));\nplot(days, ra/15); plot(days, declin) Notes Patrick Wallace (Rutherford Appleton Laboratory, UK) has tested the accuracy of a C adaptation of the present algorithm and found the following results.  From 1900-2100  sunpos  gave 7.3 arcsec maximum error, 2.6 arcsec RMS.  Over the shorter interval 1950-2050 the figures were 6.4 arcsec max, 2.2 arcsec RMS. The returned  ra  and  dec  are in the given date's equinox. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1236,"pagetitle":"Reference","title":"AstroLib.ten","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.ten","content":" AstroLib.ten  —  Function ten(deg[, min, sec]) -> decimal\nten(\"deg:min:sec\") -> decimal Purpose Converts a sexagesimal number or string to decimal. Explanation ten  is the inverse of the  sixty  function. Arguments ten  takes as argument either three scalars ( deg ,  min ,  sec ) or a string. The string should have the form  \"deg:min:sec\"  or  \"deg min sec\" .  Also any iterable like  (deg, min, sec)  or  [deg, min, sec]  is accepted as argument. If minutes and seconds are not specified they default to zero. Output The decimal conversion of the sexagesimal numbers provided is returned. Method The formula used for the conversion is \\[\\mathrm{sign}(\\mathrm{deg})·\\left(|\\mathrm{deg}| + \\frac{\\mathrm{min}}{60} + \\frac{\\mathrm{sec}}{3600}\\right)\\] Example julia> using AstroLib\n\njulia> ten(-0.0, 19, 47)\n-0.3297222222222222\n\njulia> ten(\"+5:14:58\")\n5.249444444444444\n\njulia> ten(\"-10 26\")\n-10.433333333333334\n\njulia> ten((-10, 26))\n-10.433333333333334 Notes These functions cannot deal with  -0  (negative integer zero) in numeric input. If it is important to give sense to negative zero, you can either make sure to pass a floating point negative zero  -0.0  (this is the best option), or use negative minutes and seconds, or non-integer negative degrees and minutes. source"},{"id":1237,"pagetitle":"Reference","title":"AstroLib.tic_one","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.tic_one","content":" AstroLib.tic_one  —  Function tic_one(zmin, pixx, incr[, ra=true]) -> min2, tic1 Purpose Determine the position of the first tic mark for astronomical images. Explanation For use in labelling images with right ascension and declination axes. This routine determines the position in pixels of the first tic. Arguments zmin : astronomical coordinate value at axis zero point (degrees  or hours). pixx : distance in pixels between tic marks (usually obtained from  tics ). incr  - increment in minutes for labels (usually an even number obtained  from the procedure  tics ). ra  (optional boolean keyword): if true, incremental value being entered  is in minutes of time, else it is assumed that value is in else it's in minutes of arc.  Default is false. Output The 2 tuple  (min2, tic1) : min2 : astronomical coordinate value at first tic mark tic1 : position in pixels of first tic mark Example Suppose a declination axis has a value of 30.2345 degrees at its zero point.  A tic mark is desired every 10 arc minutes, which corresponds to 12.74 pixels, with increment for labels being 10 minutes. Then julia> using AstroLib\n\njulia> tic_one(30.2345, 12.74, 10)\n(30.333333333333332, 7.554820000000081) yields values of min2 ≈ 30.333 and tic1 ≈ 7.55482, i.e. the first tic mark should be labeled 30 deg 20 minutes and be placed at pixel value 7.55482. Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1238,"pagetitle":"Reference","title":"AstroLib.ticpos","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.ticpos-Tuple{Real, Real, Real}","content":" AstroLib.ticpos  —  Method ticpos(deglen, pixlen, ticsize) -> ticsize, incr, units Purpose Specify distance between tic marks for astronomical coordinate overlays. Explanation User inputs number an approximate distance between tic marks, and the axis length in degrees.  ticpos  will return a distance between tic marks such that the separation is a round multiple in arc seconds, arc minutes, or degrees. Arguments deglen : length of axis in degrees, positive scalar pixlen : length of axis in plotting units (pixels), postive scalar ticsize : distance between tic marks (pixels).  This value will be  adjusted by  ticpos  such that the distance corresponds to a round  multiple in the astronomical coordinate. Output The 3-tuple  (ticsize, incr, units) : ticsize : distance between tic marks (pixels), positive scalar incr : incremental value for tic marks in round units given  by the  units  parameter units : string giving units of ticsize, either 'Arc Seconds', 'Arc Minutes', or 'Degrees' Example Suppose a 512 × 512 image array corresponds to 0.2 × 0.2 degrees on the sky. A tic mark is desired in round angular units, approximately every 75 pixels. Then julia> using AstroLib\n\njulia> ticpos(0.2, 512, 75)\n(85.33333333333333, 2.0, \"Arc Minutes\") i.e. a good tic mark spacing is every 2 arc minutes, corresponding to 85.333 pixels. Notes All the arguments taken as input are assumed to be positive in nature. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1239,"pagetitle":"Reference","title":"AstroLib.tics","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.tics","content":" AstroLib.tics  —  Function tics(radec_min, radec_max, numx, ticsize[, ra=true]) -> ticsize, incr Purpose Compute a nice increment between tic marks for astronomical images. Explanation For use in labelling a displayed image with right ascension or declination axes.  An approximate distance between tic marks is input, and a new value is computed such that the distance between tic marks is in simple increments of the tic label values. Arguements radec_min  : minimum axis value (degrees). radec_min  : maximum axis value (degrees). numx  : number of pixels in x direction. ticsize  : distance between tic marks (pixels). ra  (optional boolean keyword): if true, incremental value would be in minutes of time. Default is false. Output A 2-tuple  (ticsize, incr) : ticsize  : distance between tic marks (pixels). incr  : incremental value for tic labels.  The format is dependent on the optional keyword. If true (i.e for right ascension), it's in minutes of time, else it's in minutes of arc (for declination). Example julia> using AstroLib\n\njulia> tics(55, 60, 100.0, 1/2)\n(0.66, 2.0)\n\njulia> tics(30, 60, 12, 2, true)\n(2.75, 30.0) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1240,"pagetitle":"Reference","title":"AstroLib.true_obliquity","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.true_obliquity-Tuple{Real}","content":" AstroLib.true_obliquity  —  Method true_obliquity(jd) -> t_eps Purpose Return the true obliquity of the ecliptic for a given Julian date Explanation The function is used by the  co_aberration  procedure. Arguments jd : Julian date. Output t_eps : true obliquity of the ecliptic, in radians Example julia> using AstroLib\n\njulia> true_obliquity(jdcnv(1978,01,7,11, 01))\n0.4090953896211926 Notes The function calls  mean_obliquity . source"},{"id":1241,"pagetitle":"Reference","title":"AstroLib.trueanom","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.trueanom-Tuple{Real, Real}","content":" AstroLib.trueanom  —  Method trueanom(E, e) -> true anomaly Purpose Calculate true anomaly for a particle in elliptic orbit with eccentric anomaly  $E$  and eccentricity  $e$ . Explanation In the two-body problem, once that the  Kepler's equation  is solved and  $E(t)$  is determined, the polar coordinates  $(r(t), θ(t))$  of the body at time  $t$  in the elliptic orbit are given by \\[θ(t) = 2 \\arctan \\left( \\sqrt{\\frac{1 + e}{1 - e}} \\tan\\frac{E(t)}{2} \\right)\\] \\[r(t) = \\frac{a(1 - e^2)}{1 + e\\cos(θ(t) - θ_0)}\\] in which  $a$  is the semi-major axis of the orbit, and  $θ_0$  the value of angular coordinate at time  $t = t_0$ . Arguments E : eccentric anomaly. e : eccentricity, in the elliptic motion regime ( $0 ≤ e ≤ 1$ ) Output The true anomaly. Example Plot the true anomaly as a function of mean anomaly for eccentricity  $e = 0, 0.5, 0.9$ . Use  Plots.jl  for plotting. using Plots\nM = range(0, stop=2pi, length=1001)[1:end-1];\np = plot()\nfor ecc in (0, 0.5, 0.9)\n    plot!(p, M, mod2pi.(trueanom.(kepler_solver.(M, ecc), ecc)))\nend\np Notes The eccentric anomaly can be calculated with  kepler_solver  function. source"},{"id":1242,"pagetitle":"Reference","title":"AstroLib.uvbybeta","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.uvbybeta","content":" AstroLib.uvbybeta  —  Function uvbybeta(by, m1, c1, n[, hbeta=NaN, eby_in=NaN]) -> te, mv, eby, delm0, radius Purpose Derive dereddened colors, metallicity, and Teff from Stromgren colors. Arguments by : Stromgren b-y color m1 : Stromgren line-blanketing parameter c1 : Stromgren Balmer discontinuity parameter n : Integer which can be any value between 1 to 8, giving approximate stellar classification. B0 - A0, classes III - V, 2.59 < Hbeta < 2.88,-0.20 <   c0   < 1.00 B0 - A0, class   Ia     , 2.52 < Hbeta < 2.59,-0.15 <   c0   < 0.40 B0 - A0, class   Ib     , 2.56 < Hbeta < 2.61,-0.10 <   c0   < 0.50 B0 - A0, class   II     , 2.58 < Hbeta < 2.63,-0.10 <   c0   < 0.10 A0 - A3, classes III - V, 2.87 < Hbeta < 2.93,-0.01 < (b-y)o < 0.06 A3 - F0, classes III - V, 2.72 < Hbeta < 2.88, 0.05 < (b-y)o < 0.22 F1 - G2, classes III - V, 2.60 < Hbeta < 2.72, 0.22 < (b-y)o < 0.39 G2 - M2, classes  IV - V, 0.20 < m0    < 0.76, 0.39 < (b-y)o < 1.00 hbeta  (optional): H-beta line strength index. If it is not supplied, then by default its value will be  NaN  and the code will estimate a value based on by, m1,and c1. It is not used for stars in group 8. eby_in  (optional): specifies the E(b-y) color to use. If not supplied, then by default its value will be  NaN  and E(b-y) will be estimated from the Stromgren colors. Output te : approximate effective temperature mv : absolute visible magnitude eby : color excess E(b-y) delm0 : metallicity index, delta m0, may not be calculable for early B stars and so returns  NaN . radius : stellar radius (R/R(solar)) Example Determine the stellar parameters of 5 stars given their Stromgren parameters julia> using AstroLib\n\njulia> by = [-0.001, 0.403, 0.244, 0.216, 0.394];\n\njulia> m1 = [0.105, -0.074, -0.053, 0.167, 0.186];\n\njulia> c1 = [0.647, 0.215, 0.051, 0.785, 0.362];\n\njulia> hbeta = [2.75, 2.552, 2.568, 2.743, 0];\n\njulia> nn = [1, 2, 3, 7, 8];\n\njulia> uvbybeta.(by, m1, c1, nn, hbeta)\n5-element Vector{NTuple{5, Float64}}:\n (13057.535222326893, -0.27375469585031265, 0.04954396423248884, -0.008292894218734928, 2.7136529525371897)\n (14025.053834219656, -6.907050783073221, 0.4140562248995983, NaN, 73.50771722263974)\n (18423.76405400214, -5.935816553877892, 0.2828247876690783, NaN, 39.84106215808709)\n (7210.507090112837, 2.2180408083364167, 0.018404079180028038, 0.018750927360588615, 2.0459018065648165)\n (5755.671513413262, 3.9449408311022, -0.025062997393370458, 0.03241423718769865, 1.5339239690774464) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1243,"pagetitle":"Reference","title":"AstroLib.vactoair","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.vactoair-Tuple{Real}","content":" AstroLib.vactoair  —  Method vactoair(wave_vacuum) -> wave_air Purpose Converts vacuum wavelengths to air wavelengths. Explanation Corrects for the index of refraction of air under standard conditions. Wavelength values below  $2000 Å$  will not be altered.  Uses relation of Ciddor (1996). Arguments wave_vacuum : vacuum wavelength in angstroms.  Wavelengths are corrected for the index of refraction of air under standard conditions.  Wavelength values below  $2000 Å$  will  not  be altered, take care within  $[1 Å, 2000 Å]$ . Output Air wavelength in angstroms. Method Uses relation of Ciddor (1996), Applied Optics 35, 1566 ( http://adsabs.harvard.edu/abs/1996ApOpt..35.1566C ). Example If the vacuum wavelength is  w = 2000 , then  vactoair(w)  yields an air wavelength of  1999.353 . julia> using AstroLib\n\njulia> vactoair(2000)\n1999.3526230448367 Notes airtovac  converts air wavelengths to vacuum wavelengths. Code of this function is based on IDL Astronomy User's Library. source"},{"id":1244,"pagetitle":"Reference","title":"AstroLib.xyz","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.xyz","content":" AstroLib.xyz  —  Function xyz(jd[, equinox]) -> x, y, z, v_x, v_y, v_z Purpose Calculate geocentric  $x$ ,  $y$ , and  $z$  and velocity coordinates of the Sun. Explanation Calculates geocentric  $x$ ,  $y$ , and  $z$  vectors and velocity coordinates ( $dx$ ,  $dy$  and  $dz$ ) of the Sun.  (The positive  $x$  axis is directed towards the equinox, the  $y$ -axis, towards the point on the equator at right ascension 6h, and the  $z$  axis toward the north pole of the equator).  Typical position accuracy is  $<10^{-4}$  AU (15000 km). Arguments jd : number of Reduced Julian Days for the wanted date.  It can be either a scalar or a vector. equinox  (optional numeric argument): equinox of output. Default is 1950. You can use  juldate  to get the number of Reduced Julian Days for the selected dates. Output The 6-tuple  $(x, y, z, v_x, v_y, v_z)$ , where $x, y, z$ : scalars or vectors giving heliocentric rectangular coordinates (in AU) for each date supplied.  Note that  $\\sqrt{x^2 + y^2 + z^2}$  gives the Earth-Sun distance for the given date. $v_x, v_y, v_z$ : velocity vectors corresponding to  $x, y$ , and  $z$ . Example What were the rectangular coordinates and velocities of the Sun on 1999-01-22T00:00:00 (= JD 2451200.5) in J2000 coords?  Note: Astronomical Almanac (AA) is in TDT, so add 64 seconds to UT to convert. julia> using AstroLib, Dates\n\njulia> jd = juldate(DateTime(1999, 1, 22))\n51200.5\n\njulia> xyz(jd + 64/86400, 2000)\n(0.514568709240398, -0.7696326261820209, -0.33376880143023935, 0.014947267514079971, 0.008314838205477328, 0.003606857607575486) Compare to Astronomical Almanac (1999 page C20)             x  (AU)        y  (AU)     z (AU)\nxyz:      0.51456871   -0.76963263  -0.33376880\nAA:       0.51453130   -0.7697110   -0.3337152\nabs(err): 0.00003739    0.00007839   0.00005360\nabs(err)\n    (km):   5609          11759         8040 NOTE: Velocities in AA are for Earth/Moon barycenter       (a very minor offset) see AA 1999 page E3            x vel (AU/day) y vel (AU/day)   z vel (AU/day)\nxyz:      -0.014947268   -0.0083148382    -0.0036068576\nAA:       -0.01494574    -0.00831185      -0.00360365\nabs(err):  0.000001583    0.0000029886     0.0000032076\nabs(err)\n (km/sec): 0.00265        0.00519          0.00557 Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1245,"pagetitle":"Reference","title":"AstroLib.ydn2md","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.ydn2md-Tuple{Integer, Integer}","content":" AstroLib.ydn2md  —  Method ydn2md(year, day) -> date Purpose Convert from year and day number of year to a date. Explanation Returns the date corresponding to the  day  of  year . Arguments year : the year, as an integer. day : the day of  year , as an integer. Output The date, of  Date  type, of  $\\text{day} - 1$  days after January 1st of  year . Example Find the date of the 60th and 234th days of the year 2016. julia> using AstroLib\n\njulia> ydn2md.(2016, [60, 234])\n2-element Vector{Dates.Date}:\n 2016-02-29\n 2016-08-21 Note ymd2dn  converts from a date to day of the year. source"},{"id":1246,"pagetitle":"Reference","title":"AstroLib.ymd2dn","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.ymd2dn","content":" AstroLib.ymd2dn  —  Function ymd2dn(date) -> number_of_days Purpose Convert from a date to day of the year. Explanation Returns the day of the year for  date  with January 1st being day 1. Arguments date : the date with  Date  type.  Can be a single date or an array of dates. Output The day of the year for the given  date .  If  date  is an array, returns an array of days. Example Find the days of the year for March 5 in the years 2015 and 2016 (this is a leap year). julia> using AstroLib, Dates\n\njulia> ymd2dn.([Date(2015, 3, 5), Date(2016, 3, 5)])\n2-element Vector{Int64}:\n 64\n 65 Note ydn2md  converts from year and day number of year to a date. source"},{"id":1247,"pagetitle":"Reference","title":"AstroLib.zenpos","ref":"/previews/PR43/AstroLib/stable/ref/#AstroLib.zenpos","content":" AstroLib.zenpos  —  Function zenpos(jd, latitude, longitude) -> zenith_right_ascension, declination\nzenpos(date, latitude, longitude, tz) -> zenith_right_ascension, declination Purpose Return the zenith right ascension and declination in radians for a given Julian date or a local civil time and timezone. Explanation The local sidereal time is computed with the help of  ct2lst , which is the right ascension of the zenith. This and the observatories latitude (corresponding to the declination) are converted to radians and returned as the zenith direction. Arguments The function can be called in two different ways. The arguments common to both methods are  latitude  and  longitude : latitude  : latitude of the desired location. longitude  : longitude of the desired location. The zenith direction can be computed either by providing the Julian date: jd  : the Julian date of the date and time for which the zenith position is desired. or the time zone and the date: tz : the time zone (in hours) of the desired location (e.g. 4 = EDT, 5 = EST) date : the local civil time with type  DateTime . Output A 2-tuple  (ra, dec) : ra  : the right ascension (in radians) of the zenith. dec  : the declination (in radians) of the zenith. Example julia> using AstroLib, Dates\n\njulia> zenpos(DateTime(2017, 04, 25, 18, 59), 43.16, -24.32, 4)\n(0.946790432684706, 0.7532841051607526)\n\njulia> zenpos(jdcnv(2016, 05, 05, 13, 41), ten(35,0,42), ten(135,46,6))\n(3.5757821152779536, 0.6110688599440813) Notes Code of this function is based on IDL Astronomy User's Library. source"},{"id":1250,"pagetitle":"Home","title":"BoxLeastSquares.jl","ref":"/previews/PR43/BoxLeastSquares/stable/#BoxLeastSquares.jl","content":" BoxLeastSquares.jl"},{"id":1251,"pagetitle":"Home","title":"Installation","ref":"/previews/PR43/BoxLeastSquares/stable/#Installation","content":" Installation To install use  Pkg . From the REPL, press  ]  to enter Pkg-mode pkg> add BoxLeastSquares If you want to use the most up-to-date version of the code, check it out from  main pkg> add BoxLeastSquares#main"},{"id":1252,"pagetitle":"Home","title":"Usage","ref":"/previews/PR43/BoxLeastSquares/stable/#Usage","content":" Usage First, import the package julia> using BoxLeastSquares you can optionally alias the package name, too julia> import BoxLeastSquares as BLS now, load some data. If you don't have an estimate of the y error it will default to 1. julia> t, y, yerr = load_data(); # load data somehow The primary interface is through the  BLS  method julia> result = BLS(t, y, yerr; duration=0.16)\nBLSPeriodogram\n==============\ninput dim: 1000\noutput dim: 1820\nperiod range: 0.32 - 5.014724142709022\nduration range: 0.16 - 0.16\nobjective: likelihood\n\nparameters\n----------\nindex: 1633\nperiod: 1.99930396919953\nduration: 0.16\nt0: 0.5001330656464655\ndepth: 0.19594118110109113 ± 0.0008688097746093883\nsnr: 225.52828804117118\nlog-likelihood: 27396.365214805144 to extract the parameters in a convenient named tuple use  BoxLeastSquares.params julia> BoxLeastSquares.params(result)\n(index = 1633, power = 27396.365214805144, period = 1.99930396919953, duration = 0.16, t0 = 0.5001330656464655, depth = 0.19594118110109113, depth_err = 0.0008688097746093883, snr = 225.52828804117118, loglike = 27396.365214805144) The period grid was automatically determined using  autoperiod , but you can supply your own, too: julia> periods = exp.(range(log(2) - 0.1, log(2) + 0.1, length=1000));\n\njulia> result_fine = BLS(t, y, yerr; duration=0.12:0.01:0.20, periods=periods)\nBLSPeriodogram\n==============\ninput dim: 1000\noutput dim: 1000\nperiod range: 1.809674836071919 - 2.210341836151295\nduration range: 0.12 - 0.2\nobjective: likelihood\n\nparameters\n----------\nindex: 503\nperiod: 2.001001251543549\nduration: 0.168\nt0: 0.4961330656464656\ndepth: 0.19466955969052016 ± 0.0008627202098527317\nsnr: 225.64622628204188\nlog-likelihood: 27457.6383039924"},{"id":1253,"pagetitle":"Home","title":"Unitful.jl","ref":"/previews/PR43/BoxLeastSquares/stable/#Unitful.jl","content":" Unitful.jl BoxLeastSquares.jl is fully compatible with  Unitful.jl  (although it is not a dependency of the library). For example julia> using Unitful\n\njulia> tu = t * u\"d\";\n\njulia> results_units = BLS(tu, y, yerr; duration=(2:0.1:4)u\"hr\")\nBLSPeriodogram\n==============\ninput dim: 1000\noutput dim: 3343\nperiod range: 0.3333333333333333 d - 4.988348864592586 d\nduration range: 2.0 hr - 4.0 hr\nobjective: likelihood\n\nparameters\n----------\nindex: 2986\nperiod: 2.0019235780121827 d\nduration: 3.8000000000000003 hr\nt0: 0.4916330656464656 d\ndepth: 0.19445716575012517 ± 0.0008692454825826517\nsnr: 223.70799693127577\nlog-likelihood: 26953.643422397385"},{"id":1254,"pagetitle":"Home","title":"Plotting","ref":"/previews/PR43/BoxLeastSquares/stable/#Plotting","content":" Plotting BoxLeastSquares.BLSPeriodogram  has plotting shorthands built right in- by default it will plot the period grid and the computed power using Plots, UnitfulRecipes\n\nplot(results_units, label=\"\") now let's look at how the transit model compares to the data pars = BoxLeastSquares.params(results_units)\nwrap = 0.5 * pars.period\nphases = @. (mod(t - pars.t0 + wrap, pars.period) - wrap) / pars.period\ninds = sortperm(phases)\nmodel = BoxLeastSquares.model(results_units)\n\nscatter(phases[inds], y[inds], yerr=yerr[inds],\n    label=\"data\", xlabel=\"phase\", xlim=(-0.2, 0.2), leg=:bottomright)\nplot!(phases[inds], model[inds], lw=3, label=\"BLS model\")"},{"id":1255,"pagetitle":"Home","title":"Performance","ref":"/previews/PR43/BoxLeastSquares/stable/#Performance","content":" Performance This code has been benchmarked against the C implementation in  astropy.timeseries.bls . The C version uses OpenMP to multi-thread some parts of the core BLS algorithm, but BoxLeastSquares.jl has no threading support currently. For a fair comparison, we set  OMP_NUM_THREADS  to 1 for the following tests. This first benchmark is simply the time it takes to evaluate the BLS periodogram. Periods are pre-computed using  autoperiod . We simulate different sizes of data sets (x-axis) as well as different sizes of period grids (shape). This benchmark does not use units. The code can be found in  bench/benchmark.jl . Here is the information for my system- Julia Version 1.6.0\nCommit f9720dc2eb* (2021-03-24 12:55 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin20.3.0)\n  CPU: Intel(R) Core(TM) i5-8259U CPU @ 2.30GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, skylake)\nEnvironment:\n  OMP_NUM_THREADS = 1\n  JULIA_NUM_THREADS = 1"},{"id":1256,"pagetitle":"Home","title":"Contributing and Support","ref":"/previews/PR43/BoxLeastSquares/stable/#Contributing-and-Support","content":" Contributing and Support If you would like to contribute, feel free to open a  pull request . If you want to discuss something before contributing, head over to  discussions  and join or open a new topic. If you're having problems with something, open an  issue ."},{"id":1259,"pagetitle":"API/Reference","title":"API/Reference","ref":"/previews/PR43/BoxLeastSquares/stable/api/#API/Reference","content":" API/Reference BoxLeastSquares.BLSPeriodogram BoxLeastSquares.BLS BoxLeastSquares.autoperiod BoxLeastSquares.model BoxLeastSquares.model BoxLeastSquares.params BoxLeastSquares.periods BoxLeastSquares.power"},{"id":1260,"pagetitle":"API/Reference","title":"BoxLeastSquares.BLSPeriodogram","ref":"/previews/PR43/BoxLeastSquares/stable/api/#BoxLeastSquares.BLSPeriodogram","content":" BoxLeastSquares.BLSPeriodogram  —  Type BLSPeriodogram A convenient wrapper for outputs from  BLS . Methods BoxLeastSquares.params BoxLeastSquares.power BoxLeastSquares.periods Attributes t  - input time grid y  - input data yerr  - input data uncertainty periods  - the input periods duration_in  - the input durations objective  - the objective that was maximized power  - the power calculated at each period duration  - the best duration at each period t0  - the best transit time at each period depth  - the best transit depth at each period snr  - the signal-to-noise ratio at each period loglike  - the log-likeilhood at each period Plotting Plotting recipes are provided for  BLSPeriodogram  which automatically plots the period and the power source"},{"id":1261,"pagetitle":"API/Reference","title":"BoxLeastSquares.BLS","ref":"/previews/PR43/BoxLeastSquares/stable/api/#BoxLeastSquares.BLS","content":" BoxLeastSquares.BLS  —  Function BLS(t, y, [yerr];\n    duration, periods=autoperiod(t, duration, kwargs...), \n    objective=:likelihood, oversample=10, kwargs...) Compute the box-least-squares periodogram. Parameters t  - the time for each observation. Units are irrelevant, except that they must be consistent for all temporal parameters (e.g.,  duration ).  Unitful.jl  units work seamlessly without needing to convert. y  - the flux value for each observation yerr , optional - the uncertainty for each observation, if not provided, will default to ones duration  - The duration or durations to consider. Same units as  t periods , optional - The period grid to computer the BLS power over. If not provided,  autoperiod  will be called along with any extra keyword arguments (like  minimum_period ) objective , optional - Choose between maximizing the likeilhood ( :likeilhood , default) or the signal-to-noise ratio ( :snr ). oversample , optional - The number of bins per duration that should be used. Larger values of  oversample  will lead to a finer grid. The returned values are wrapped into a convenience type  BoxLeastSquares.BLSPeriodogram source"},{"id":1262,"pagetitle":"API/Reference","title":"BoxLeastSquares.autoperiod","ref":"/previews/PR43/BoxLeastSquares/stable/api/#BoxLeastSquares.autoperiod-Union{Tuple{T}, Tuple{AbstractVector{T}, Any}} where T","content":" BoxLeastSquares.autoperiod  —  Method autoperiod(t, duration;\n    minimum_n_transit=3, frequency_factor=1.0,\n    [minimum_period, maximum_period]) Automatically determine a period grid from the given times and duration(s). Periods are selected such that at least  minimum_n_trasnit  transits occur. The default minimum period is twice the maximum duration. The default maximum period is  (maximum(t) - minimum(t)) / (minimum_n_transit - 1) . The frequency factor changes the granularity in frequency space- a smaller frequency factor will create a finer period grid. source"},{"id":1263,"pagetitle":"API/Reference","title":"BoxLeastSquares.model","ref":"/previews/PR43/BoxLeastSquares/stable/api/#BoxLeastSquares.model","content":" BoxLeastSquares.model  —  Function BoxLeastSquares.model(t, y, [yerr]; period, duration, t0) Evaluate the transit model on the given time grid. If  yerr  is not provided, it will default to 1. The following transit parameters must be set: period  orbital period in the same units as  t duration  the transit duration in the same units as  t t0  the transit time (middle of transit) in the same units as  t If you are using  Unitful.jl , the unit conversions will be made automatically. source"},{"id":1264,"pagetitle":"API/Reference","title":"BoxLeastSquares.model","ref":"/previews/PR43/BoxLeastSquares/stable/api/#BoxLeastSquares.model-Tuple{BoxLeastSquares.BLSPeriodogram}","content":" BoxLeastSquares.model  —  Method BoxLeastSquares.model(::BLSPeriodogram; kwargs...) Create a transit model using the data and best-fitting parameters from the given BLS periodogram. Any keyword parameters can be overriden. source"},{"id":1265,"pagetitle":"API/Reference","title":"BoxLeastSquares.params","ref":"/previews/PR43/BoxLeastSquares/stable/api/#BoxLeastSquares.params-Tuple{BoxLeastSquares.BLSPeriodogram}","content":" BoxLeastSquares.params  —  Method BoxLeastSquares.params(::BLSPeriodogram) Return the transit parameters for the best fitting period. Returns period, duration, t0, and power as well as the index of the max-power period. source"},{"id":1266,"pagetitle":"API/Reference","title":"BoxLeastSquares.periods","ref":"/previews/PR43/BoxLeastSquares/stable/api/#BoxLeastSquares.periods-Tuple{BoxLeastSquares.BLSPeriodogram}","content":" BoxLeastSquares.periods  —  Method BoxLeastSquares.periods(::BLSPeriodogram) Return the period grid for the periodogram source"},{"id":1267,"pagetitle":"API/Reference","title":"BoxLeastSquares.power","ref":"/previews/PR43/BoxLeastSquares/stable/api/#BoxLeastSquares.power-Tuple{BoxLeastSquares.BLSPeriodogram}","content":" BoxLeastSquares.power  —  Method BoxLeastSquares.power(::BLSPeriodogram) Return the power calculated for each period for the periodogram source"},{"id":1272,"pagetitle":"LombScargle.jl","title":"LombScargle.jl","ref":"/previews/PR43/LombScargle/stable/#LombScargle.jl","content":" LombScargle.jl"},{"id":1273,"pagetitle":"LombScargle.jl","title":"Introduction","ref":"/previews/PR43/LombScargle/stable/#Introduction","content":" Introduction LombScargle.jl  is a package for a fast multi-threaded estimation of the  frequency spectrum  of a periodic signal with  the Lomb–Scargle periodogram .  This is written in  Julia , a modern high-level, high-performance dynamic programming language designed for technical computing. Another Julia package that provides tools to perform spectral analysis of signals is  DSP.jl , but its methods require that the signal has been sampled at equally spaced times. Instead, the Lomb–Scargle periodogram enables you to analyze unevenly sampled data as well, which is a fairly common case in astronomy, a field where this periodogram is widely used. The algorithms used in this package are reported in the following papers: [PR89] Press, W. H., Rybicki, G. B. 1989, ApJ, 338, 277 (URL:  http://dx.doi.org/10.1086/167197 , Bibcode:  http://adsabs.harvard.edu/abs/1989ApJ...338..277P ) [TOW10] Townsend, R. H. D. 2010, ApJS, 191, 247 (URL:  http://dx.doi.org/10.1088/0067-0049/191/2/247 , Bibcode:  http://adsabs.harvard.edu/abs/2010ApJS..191..247T ) [ZK09] Zechmeister, M., Kürster, M. 2009, A&A, 496, 577 (URL:  http://dx.doi.org/10.1051/0004-6361:200811296 , Bibcode:  http://adsabs.harvard.edu/abs/2009A%26A...496..577Z ) Other relevant papers are: [CMB99] Cumming, A., Marcy, G. W., & Butler, R. P. 1999, ApJ, 526, 890 (URL:  http://dx.doi.org/10.1086/308020 , Bibcode:  http://adsabs.harvard.edu/abs/1999ApJ...526..890C ) [CUM04] Cumming, A. 2004, MNRAS, 354, 1165 (URL:  http://dx.doi.org/10.1111/j.1365-2966.2004.08275.x , Bibcode:  http://adsabs.harvard.edu/abs/2004MNRAS.354.1165C ) [HB86] Horne, J. H., & Baliunas, S. L. 1986, ApJ, 302, 757 (URL:  http://dx.doi.org/10.1086/164037 , Bibcode:  http://adsabs.harvard.edu/abs/1986ApJ...302..757H ) [LOM76] Lomb, N. R. 1976, Ap&SS, 39, 447 (URL:  http://dx.doi.org/10.1007/BF00648343 , Bibcode:  http://adsabs.harvard.edu/abs/1976Ap%26SS..39..447L ) [MHC93] Murdoch, K. A., Hearnshaw, J. B., & Clark, M. 1993, ApJ, 413, 349 (URL:  http://dx.doi.org/10.1086/173003 , Bibcode:  http://adsabs.harvard.edu/abs/1993ApJ...413..349M ) [SCA82] Scargle, J. D. 1982, ApJ, 263, 835 (URL:  http://dx.doi.org/10.1086/160554 , Bibcode:  http://adsabs.harvard.edu/abs/1982ApJ...263..835S ) [SS10] Sturrock, P. A., & Scargle, J. D. 2010, ApJ, 718, 527 (URL:  http://dx.doi.org/10.1088/0004-637X/718/1/527 , Bibcode:  http://adsabs.harvard.edu/abs/2010ApJ...718..527S ) The package provides facilities to: compute the periodogram using different methods (with different speeds) and different normalizations. This is one of the fastest implementations of these methods available as free software. If Julia is run with more than one  thread , computation is automatically multi-threaded, further speeding up calculations; access the frequency and period grid of the resulting periodogram, together with the power spectrum; find the maximum power in the periodogram and the frequency and period corresponding to the peak. All these queries can be restricted to a specified region, in order to search a local maximum, instead of the global one; calculate the probability that a peak arises from noise only (false-alarm probability) using analytic formulas, in order to assess the significance of the peak; perform bootstrap resamplings in order to compute the false-alarm probability with a statistical method; determine the best-fitting Lomb–Scargle model for the given data set at the given frequency."},{"id":1274,"pagetitle":"LombScargle.jl","title":"Installation","ref":"/previews/PR43/LombScargle/stable/#Installation","content":" Installation LombScargle.jl  is available for Julia 0.7 and later versions, and can be installed with  Julia's built-in package manager . In a Julia session run the commands julia> using Pkg\njulia> Pkg.update()\njulia> Pkg.add(\"LombScargle\") Older versions are also available for Julia 0.4-0.6."},{"id":1275,"pagetitle":"LombScargle.jl","title":"Usage","ref":"/previews/PR43/LombScargle/stable/#Usage","content":" Usage After installing the package, you can start using it with using LombScargle The module defines a new  LombScargle.Periodogram  data type, which, however, is not exported because you will most probably not need to directly manipulate such objects. This data type holds both the frequency and the power vectors of the periodogram. The main function provided by the package is  lombscargle :"},{"id":1276,"pagetitle":"LombScargle.jl","title":"LombScargle.lombscargle","ref":"/previews/PR43/LombScargle/stable/#LombScargle.lombscargle-Tuple{AbstractVector{var\"#s1\"} where var\"#s1\"<:Real, Vararg{Any, N} where N}","content":" LombScargle.lombscargle  —  Method lombscargle(times::AbstractVector{<:Real}, signal::AbstractVector{<:Real},\n            [errors::AbstractVector{<:Real}]; keywords...) Compute the Lomb–Scargle periodogram of the  signal  vector, observed at  times .  You can also specify the uncertainties for each signal point with  errors  argument.  All these vectors must have the same length. All optional keywords are described in the docstring of  LombScargle.plan . If the signal has uncertainties, the  signal  vector can also be a vector of  Measurement  objects (from  Measurements.jl  package), in which case you don’t need to pass a separate  errors  vector for the uncertainties of the signal. source lombscargle  returns a  LombScargle.Periodogram . The only two mandatory arguments are: times : the vector of observation times signal : the vector of observations associated with  times The optional argument is: errors : the uncertainties associated to each  signal  point. All these vectors must have the same length. Tip You can pre-plan a periodogram with  LombScargle.plan  function, which has the same syntax as  lombscargle  described in this section. In this way the actual computation of the periodogram is faster and you will save memory. See the  Planning the Periodogram  section below. Tip LombScargle.jl  exploits Julia's native  multi-threading  for the non-fast methods (the methods used when you set the keyword  fast=false ). Run Julia with  $n$  threads (e.g.,  JULIA_NUM_THREADS=4 julia  for 4 threads, if your machine has 4 physical cores) in order to automatically gain an  $n$  -fold scaling. Please note that multi-threading is still an experimental feature in Julia, so you may encounter issues when running it with more than one thread. For example, bug  #17395  (if still open) may prevent the function, on some systems, from effectively scaling. If the signal has uncertainties, the  signal  vector can also be a vector of  Measurement  objects (from  Measurements.jl  package), in which case you need not to pass a separate  errors  vector for the uncertainties of the signal. You can create arrays of  Measurement  objects with the  measurement  function, see  Measurements.jl  manual at  https://juliaphysics.github.io/Measurements.jl/stable  for more details. The generalised Lomb–Scargle periodogram by [ZK09] is always used when the signal has uncertainties, because the original Lomb–Scargle algorithm cannot handle them. Tip The uncertainties are only used in the generalised Lomb–Scargle algorithm to build an  inverse-variance  weights vector (see [ZK09]), that gives more importance to datapoints with lower uncertainties. The case where all measurements have the same uncertainty (a condition known as  homoskedasticity ) results in a constant weights vector, like if there are no uncertainties at all. If you have homoskedastic errors, you do not need to provide them to  lombscargle ."},{"id":1277,"pagetitle":"LombScargle.jl","title":"Planning the Periodogram","ref":"/previews/PR43/LombScargle/stable/#Planning-the-Periodogram","content":" Planning the Periodogram In a manner similar to planning Fourier transforms with FFTW, it is possible to speed-up computation of the Lomb–Scargle periodogram by pre-planning it with  LombScargle.plan  function. It has the same syntax as  lombscargle , which in the base case is:"},{"id":1278,"pagetitle":"LombScargle.jl","title":"LombScargle.plan","ref":"/previews/PR43/LombScargle/stable/#LombScargle.plan","content":" LombScargle.plan  —  Function LombScargle.plan(times::AbstractVector{<:Real}, signal::AbstractVector{<:Real},\n                 [errors::AbstractVector{<:Real}];\n                 normalization::Symbol=:standard,\n                 noise_level::Real=1,\n                 center_data::Bool=true,\n                 fit_mean::Bool=true,\n                 fast::Bool=true,\n                 flags::Integer=FFTW.ESTIMATE,\n                 timelimit::Real=Inf,\n                 oversampling::Integer=5,\n                 padding_factors::Vector{Int}=[2],\n                 Mfft::Integer=4,\n                 samples_per_peak::Integer=5,\n                 nyquist_factor::Integer=5,\n                 minimum_frequency::Real=NaN,\n                 maximum_frequency::Real=NaN,\n                 frequencies::AbstractVector{Real}=\n                 autofrequency(times,\n                               samples_per_peak=samples_per_peak,\n                               nyquist_factor=nyquist_factor,\n                               minimum_frequency=minimum_frequency,\n                               maximum_frequency=maximum_frequency)) Pre-plan the Lomb–Scargle periodogram of the  signal  vector, observed at  times .  The periodogram can then be computed by passing the result of this function to  lombscargle . You can also specify the uncertainties for each signal point with  errors  argument.  All these vectors must have the same length. Optional keywords arguments are: normalization : how to normalize the periodogram.  Valid choices are:  :standard ,  :model ,  :log ,  :psd ,  :Scargle ,  :HorneBaliunas ,  :Cumming noise_level : the noise level used to normalize the periodogram when  normalization  is set to  :Scargle fit_mean : if  true , fit for the mean of the signal using the Generalised Lomb–Scargle algorithm (see Zechmeister & Kürster paper below).  If this is  false  and no uncertainty on the signal is provided, the original algorithm by Lomb and Scargle will be employed (see Townsend paper below) center_data : if  true , subtract the weighted mean of  signal  from  signal  itself before performing the periodogram.  This is especially important if  fit_mean  is  false frequencies : the frequecy grid (not angular frequencies) at which the periodogram will be computed, as a vector.  If not provided, it is an evenly spaced grid of type  Range , automatically determined with  LombScargle.autofrequency  function, which see.  See below for other available keywords that can be used to affect the frequency grid without directly setting  frequencies You can explicitely require to use or not the fast method by Press & Rybicki, overriding the default choice, by setting the  fast  keyword.  In any case,  frequencies  must be a  Range  object (this is the default) in order to actually use this method.  A few other keywords are available to adjust the settings of the periodogram when the fast method is used (otherwise they are ignored): fast : whether to use the fast method. flags : this integer keyword is a bitwise-or of FFTW planner flags, defaulting to  FFTW.ESTIMATE .  Passing  FFTW.MEASURE  or  FFTW.PATIENT  will instead spend several seconds (or more) benchmarking different possible FFT algorithms and picking the fastest one; see the FFTW manual for more information on planner flags. timelimit : specifies a rough upper bound on the allowed planning time, in seconds. oversampling : oversampling the frequency factor for the approximation; roughly the number of time samples across the highest-frequency sinusoid. This parameter contains the tradeoff between accuracy and speed. padding_factors : the FFT is performed on a vector with length equal to the smallest number larger than or equal to  N * oversampling  which is a product of all numbers in this vector.  E.g., use  padding_factors=[2]  to perform the FFT on a vector padded to a power of 2, or  padding_factors=[2, 3, 5, 7]  for the optimal size for the FFTW library. Mfft : the number of adjacent points to use in the FFT approximation. In addition, you can use all optional keyword arguments of  LombScargle.autofrequency  function in order to tune the  frequencies . If the signal has uncertainties, the  signal  vector can also be a vector of  Measurement  objects (from  Measurements.jl  package), in which case you don’t need to pass a separate  errors  vector for the uncertainties of the signal. source"},{"id":1279,"pagetitle":"LombScargle.jl","title":"LombScargle.autofrequency","ref":"/previews/PR43/LombScargle/stable/#LombScargle.autofrequency","content":" LombScargle.autofrequency  —  Function autofrequency(times::AbstractVector{Real};\n              samples_per_peak::Integer=5,\n              nyquist_factor::Integer=5,\n              minimum_frequency::Real=NaN,\n              maximum_frequency::Real=NaN) Determine a suitable frequency grid for the given vector of  times . Optional keyword arguments are: samples_per_peak : the approximate number of desired samples across the typical peak nyquist_factor : the multiple of the average Nyquist frequency used to choose the maximum frequency if  maximum_frequency  is not provided minimum_frequency : if specified, then use this minimum frequency rather than one chosen based on the size of the baseline maximum_frequency : if specified, then use this maximum frequency rather than one chosen based on the average Nyquist frequency This is based on prescription given at  https://jakevdp.github.io/blog/2015/06/13/lomb-scargle-in-python/  and uses the same keywords names adopted in Astropy. source LombScargle.plan  takes all the same argument as  lombscargle  shown above and returns a  LombScargle.PeriodogramPlan  object after having pre-computed certain quantities needed afterwards, and pre-allocated the memory for the periodogram. It is highly suggested to plan a periodogram before actually computing it, especially for the fast method. Once you plan a periodogram, you can pass the  LombScargle.PeriodogramPlan  to  lombscargle  as the only argument."},{"id":1280,"pagetitle":"LombScargle.jl","title":"LombScargle.lombscargle","ref":"/previews/PR43/LombScargle/stable/#LombScargle.lombscargle-Tuple{LombScargle.PeriodogramPlan}","content":" LombScargle.lombscargle  —  Method lombscargle(plan::PeriodogramPlan) Compute the Lomb–Scargle periodogram for the given  plan .  This method has no other arguments.  See documentation of  LombScargle.plan  for how to plan a Lomb–Scargle periodogram. source Planning the periodogram has a twofold advantage. First of all, the planning stage is  type-unstable , because the type of the plan depends on the value of input parameters, and not on their types. Thus, separating the planning (inherently inefficient) from the actual computation of the periodogram (completely type-stable) makes overall computation faster than directly calling  lombscargle . Secondly, the  LombScargle.PeriodogramPlan  bears the time vector, but the quantities that are pre-computed in planning stage do not actually depend on it. This is particularly useful if you want to calculate the  False-Alarm Probability  via bootstrapping with  LombScargle.bootstrap : the vector time is randomly shuffled, but pre-computed quantities will remain the same, saving both time and memory in each iteration. In addition, you ensure that you will use the same options you used to compute the periodogram."},{"id":1281,"pagetitle":"LombScargle.jl","title":"Fast Algorithm","ref":"/previews/PR43/LombScargle/stable/#Fast-Algorithm","content":" Fast Algorithm When the frequency grid is evenly spaced, you can compute an approximate generalised Lomb–Scargle periodogram using a fast algorithm proposed by [PR89] that greatly speeds up calculations, as it scales as  $O[N \\log(M)]$  for  $N$  data points and  $M$  frequencies. For comparison, the true Lomb–Scargle periodogram has complexity  $O[NM]$ .  The larger the number of datapoints, the more accurate the approximation. Note This method internally performs a  Fast Fourier Transform  (FFT) to compute some quantities, but it is in no way equivalent to conventional Fourier periodogram analysis. LombScargle.jl  uses  FFTW  functions to compute the FFT. You can speed-up this task by using multi-threading: call  FFTW.set_num_threads(n)  to use  $n$  threads. However, please note that the running time will not scale as  $n$  because computation of the FFT is only a part of the algorithm. The only prerequisite in order to be able to employ this fast method is to provide a  frequencies  vector as an  AbstractRange  object, which ensures that the frequency grid is perfectly evenly spaced. This is the default, since  LombScargle.autofrequency  returns an  AbstractRange  object. Tip In Julia, an  AbstractRange  object can be constructed for example with the  range  function (you specify the start of the range, and optionally the stop, the length and the step of the vector) or with the syntax  start:[step:]stop  (you specify the start and the end of the range, and optionally the linear step). Since this fast method is accurate only for large datasets, it is enabled by default only if the number of output frequencies is larger than 200. You can override the default choice of using this method by setting the  fast  keyword to  true  or  false . We recall that in any case, the  frequencies  vector must be a  Range  in order to use this method. To summarize, provided that  frequencies  vector is an  AbstractRange  object, you can use the fast method: by default if the length of the output frequency grid is larger than 200 points in any case with the  fast=true  keyword Setting  fast=false  always ensures you that this method will not be used, instead  fast=true  actually enables it only if  frequencies  is an  AbstractRange ."},{"id":1282,"pagetitle":"LombScargle.jl","title":"Normalization","ref":"/previews/PR43/LombScargle/stable/#Normalization","content":" Normalization By default, the periodogram  $p(f)$  is normalized so that it has values in the range  $0 \\leq p(f) \\leq 1$ , with  $p = 0$  indicating no improvement of the fit and  $p = 1$  a \"perfect\" fit (100% reduction of  $\\chi^2$  or  $\\chi^2 = 0$ ). This is the normalization suggested by [LOM76] and [ZK09], and corresponds to the  :standard  normalization in  lombscargle  function. [ZK09] wrote the formula for the power of the periodogram at frequency  $f$  as \\[p(f) = \\frac{1}{YY}\\left[\\frac{YC^2_{\\tau}}{CC_{\\tau}} +\n\\frac{YS^2_{\\tau}}{SS_{\\tau}}\\right]\\] See the paper for details. The other normalizations for periodograms  $P(f)$  are calculated from this one. In what follows,  $N$  is the number of observations. :model : \\[P(f) = \\frac{p(f)}{1 - p(f)}\\] :log : \\[P(f) = -\\log(1 - p(f))\\] :psd : \\[P(f) = \\frac{W}{2}\\left[\\frac{YC^2_{\\tau}}{CC_{\\tau}} +\n\\frac{YS^2_{\\tau}}{SS_{\\tau}}\\right] = p(f) \\frac{W*YY}{2}\\] where W is the sum of the inverse of the individual errors,  $W = \\sum \\frac{1}{\\sigma_{i}}$ , as given in [ZK09]. :Scargle : \\[P(f) = \\frac{p(f)}{\\text{noise level}}\\] This normalization can be used when you know the noise level (expected from the a priori known noise variance or population variance), but this isn't usually the case. See [SCA82] :HorneBaliunas : \\[P(f) = \\frac{N - 1}{2} p(f)\\] This is like the  :Scargle  normalization, where the noise has been estimated for Gaussian noise to be  $(N - 1)/2$ . See [HB86] If the data contains a signal or if errors are under- or overestimated or if intrinsic variability is present, then  $(N-1)/2$  may not be a good uncorrelated estimator for the noise level.  [CMB99] suggested to estimate the noise level a posteriori with the residuals of the best fit and normalised the periodogram as: \\[P(f) = \\frac{N - 3}{2} \\frac{p(f)}{1 - p(f_{\\text{best}})}\\] This is the  :Cumming  normalization option"},{"id":1283,"pagetitle":"LombScargle.jl","title":"Access Frequency Grid and Power Spectrum of the Periodogram","ref":"/previews/PR43/LombScargle/stable/#Access-Frequency-Grid-and-Power-Spectrum-of-the-Periodogram","content":" Access Frequency Grid and Power Spectrum of the Periodogram lombscargle  returns a  LombScargle.Periodogram  object, but you most probably want to use the frequency grid and the power spectrum. You can access these vectors with  freq  and  power  functions, just like in  DSP.jl  package. If you want to get the 2-tuple  (freq(p), power(p))  use the  freqpower  function."},{"id":1284,"pagetitle":"LombScargle.jl","title":"LombScargle.power","ref":"/previews/PR43/LombScargle/stable/#LombScargle.power","content":" LombScargle.power  —  Function power(p::Periodogram) Return the power vector of Lomb–Scargle periodogram  p . source"},{"id":1285,"pagetitle":"LombScargle.jl","title":"LombScargle.freq","ref":"/previews/PR43/LombScargle/stable/#LombScargle.freq","content":" LombScargle.freq  —  Function freq(p::Periodogram) Return the frequency vector of Lomb–Scargle periodogram  p . source"},{"id":1286,"pagetitle":"LombScargle.jl","title":"LombScargle.freqpower","ref":"/previews/PR43/LombScargle/stable/#LombScargle.freqpower","content":" LombScargle.freqpower  —  Function freqpower(p::Periodogram) Return the 2-tuple  (freq(p), power(p)) , where  freq(p)  and  power(p)  are the frequency vector and the power vector of Lomb–Scargle periodogram  p  respectively. source"},{"id":1287,"pagetitle":"LombScargle.jl","title":"Access Period Grid","ref":"/previews/PR43/LombScargle/stable/#Access-Period-Grid","content":" Access Period Grid The following utilities are the analogs of  freq  and  freqpower , but relative to the periods instead of the frequencies. Thus  period(p)  returns the vector of periods in the periodogram, that is  1./freq(p) , and  periodpower(p)  gives you the 2-tuple  (period(p), power(p)) ."},{"id":1288,"pagetitle":"LombScargle.jl","title":"LombScargle.period","ref":"/previews/PR43/LombScargle/stable/#LombScargle.period","content":" LombScargle.period  —  Function period(p::Periodogram) Return the period vector of Lomb–Scargle periodogram  p .  It is equal to  1 ./ freq(p) . source"},{"id":1289,"pagetitle":"LombScargle.jl","title":"LombScargle.periodpower","ref":"/previews/PR43/LombScargle/stable/#LombScargle.periodpower","content":" LombScargle.periodpower  —  Function periodpower(p::Periodogram) Return the 2-tuple  (period(p), power(p)) , where  period(p)  and  power(p)  are the period vector and the power vector of Lomb–Scargle periodogram  p  respectively. source"},{"id":1290,"pagetitle":"LombScargle.jl","title":"findmaxpower, findmaxfreq, and findmaxperiod Functions","ref":"/previews/PR43/LombScargle/stable/#findmaxpower,-findmaxfreq,-and-findmaxperiod-Functions","content":" findmaxpower ,  findmaxfreq , and  findmaxperiod  Functions Once you compute the periodogram, you usually want to know which are the frequencies or periods with highest power. To do this, you can use the  findmaxfreq  and  findmaxperiod  functions."},{"id":1291,"pagetitle":"LombScargle.jl","title":"LombScargle.findmaxpower","ref":"/previews/PR43/LombScargle/stable/#LombScargle.findmaxpower","content":" LombScargle.findmaxpower  —  Function findmaxpower(p::Periodogram) Return the highest power of the periodogram  p . source"},{"id":1292,"pagetitle":"LombScargle.jl","title":"LombScargle.findmaxfreq","ref":"/previews/PR43/LombScargle/stable/#LombScargle.findmaxfreq","content":" LombScargle.findmaxfreq  —  Function findmaxfreq(p::Periodogram, [interval::AbstractVector{Real}], threshold::Real=findmaxpower(p)) Return the array of frequencies with the highest power in the periodogram  p . If a scalar real argument  threshold  is provided, return the frequencies with power larger than or equal to  threshold .  If you want to limit the search to a narrower frequency range, pass as second argument a vector with the extrema of the interval. source"},{"id":1293,"pagetitle":"LombScargle.jl","title":"LombScargle.findmaxperiod","ref":"/previews/PR43/LombScargle/stable/#LombScargle.findmaxperiod","content":" LombScargle.findmaxperiod  —  Function findmaxperiod(p::Periodogram, [interval::AbstractVector{Real}], threshold::Real=findmaxpower(p)) Return the array of periods with the highest power in the periodogram  p .  If a scalar real argument  threshold  is provided, return the period with power larger than or equal to  threshold .  If you want to limit the search to a narrower period range, pass as second argument a vector with the extrema of the interval. source"},{"id":1294,"pagetitle":"LombScargle.jl","title":"False-Alarm Probability","ref":"/previews/PR43/LombScargle/stable/#False-Alarm-Probability","content":" False-Alarm Probability Noise in the data produce fluctuations in the periodogram that will present several local peaks, but not all of them related to real periodicities. The significance of the peaks can be tested by calculating the probability that its power can arise purely from noise.  The higher the value of the power, the lower will be this probability. Note [CMB99] showed that the different normalizations result in different probability functions.  LombScargle.jl  can calculate the probability (and the false-alarm probability) only for the normalizations reported by [ZK09], that are  :standard ,  :Scargle ,  :HorneBaliunas , and  :Cumming . The probability  $\\text{Prob}(p > p_{0})$  that the periodogram power  $p$  can exceed the value  $p_{0}$  can be calculated with the  prob  function, whose first argument is the periodogram and the second one is the  $p_{0}$  value. The function  probinv  is its inverse: it takes the probability as second argument and returns the corresponding  $p_{0}$  value."},{"id":1295,"pagetitle":"LombScargle.jl","title":"LombScargle.prob","ref":"/previews/PR43/LombScargle/stable/#LombScargle.prob-Tuple{LombScargle.Periodogram, Real}","content":" LombScargle.prob  —  Method prob(P::Periodogram, pow::Real) Return the probability that the periodogram power can exceed the value  pow . Its inverse is the  probinv  function. source"},{"id":1296,"pagetitle":"LombScargle.jl","title":"LombScargle.probinv","ref":"/previews/PR43/LombScargle/stable/#LombScargle.probinv-Tuple{LombScargle.Periodogram, Real}","content":" LombScargle.probinv  —  Method probinv(P::Periodogram, prob::Real) Return the power value of the periodogram power whose probability is  prob . This is the inverse of  prob  function. source"},{"id":1297,"pagetitle":"LombScargle.jl","title":"LombScargle.M","ref":"/previews/PR43/LombScargle/stable/#LombScargle.M","content":" LombScargle.M  —  Function LombScargle.M(P::Periodogram) Estimates the number of independent frequencies in the periodogram  P . source"},{"id":1298,"pagetitle":"LombScargle.jl","title":"LombScargle.fap","ref":"/previews/PR43/LombScargle/stable/#LombScargle.fap-Tuple{LombScargle.Periodogram, Real}","content":" LombScargle.fap  —  Method fap(P::Periodogram, pow::Real) Return the false-alarm probability for periodogram  P  and power value  pow . Its inverse is the  fapinv  function. source"},{"id":1299,"pagetitle":"LombScargle.jl","title":"LombScargle.fapinv","ref":"/previews/PR43/LombScargle/stable/#LombScargle.fapinv-Tuple{LombScargle.Periodogram, Real}","content":" LombScargle.fapinv  —  Method fapinv(P::Periodogram, prob::Real) Return the power value of the periodogram whose false-alarm probability is  prob . This is the inverse of  fap  function. source Here are the probability functions for each normalization supported by  LombScargle.jl : :standard  ( $p \\in [0, 1]$ ): \\[\\text{Prob}(p > p_{0}) = (1 - p_{0})^{(N - 3)/2}\\] :Scargle  ( $p \\in [0, \\infty)$ ): \\[\\text{Prob}(p > p_{0}) = \\exp(-p_{0})\\] :HorneBaliunas  ( $p \\in [0, (N - 1)/2]$ ): \\[\\text{Prob}(p > p_{0}) = \\left(1 - \\frac{2p_{0}}{N - 1}\\right)^{(N - 3)/2}\\] :Cumming  ( $p \\in [0, \\infty)$ ): \\[\\text{Prob}(p > p_{0}) = \\left(1 + \\frac{2p_{0}}{N - 3}\\right)^{-(N - 3)/2}\\] As explained by [SS10], «the term \"false-alarm probability denotes the probability that at least one out of  $M$  independent power values in a prescribed search band of a power spectrum computed from a white-noise time series is expected to be as large as or larger than a given value».  LombScargle.jl  provides the  fap  function to calculate the false-alarm probability (FAP) of a given power in a periodogram. Its first argument is the periodogram, the second one is the value  $p_{0}$  of the power of which you want to calculate the FAP. The function  fap  uses the formula \\[\\text{FAP} = 1 - (1 - \\text{Prob}(p > p_{0}))^M\\] where  $M$  is the number of independent frequencies estimated with  $M = T \\cdot \\Delta f$ , being  $T$  the duration of the observations and  $\\Delta f$  the width of the frequency range in which the periodogram has been calculated (see [CUM04]). The function  fapinv  is the inverse of  fap : it takes as second argument the value of the FAP and returns the corresponding value  $p_{0}$  of the power. The detection threshold  $p_{0}$  is the periodogram power corresponding to some (small) value of  $\\text{FAP}$ , i.e. the value of  $p$  exceeded due to noise alone in only a small fraction  $\\text{FAP}$  of trials. An observed power larger than  $p_{0}$  indicates that a signal is likely present (see [CUM04]). Warning Some authors stressed that this method to calculate the false-alarm probability is not completely reliable. A different approach to calculate the false-alarm probability is to perform Monte Carlo or bootstrap simulations in order to determine how often a certain power level  $p_{0}$  is exceeded just by chance (see [CMB99], [CUM04], and [ZK09]). See the  Bootstrapping  section."},{"id":1300,"pagetitle":"LombScargle.jl","title":"Bootstrapping","ref":"/previews/PR43/LombScargle/stable/#Bootstrapping","content":" Bootstrapping One of the possible and simplest statistical methods that you can use to measure the false-alarm probability and its inverse is  bootstrapping  (see section 4.2.2 of [MHC93]). Note We emphasize that you can use this method only if you know your data points are  independent and identically distributed , and they have  white uncorrelated noise . The recipe of the bootstrap method is very simple to implement: repeat the Lomb–Scargle analysis a large number  $N$  of times on the original data, but with the signal (and errors, if present) vector randomly shuffled. As an alternative, shuffle only the time vector; out of all these simulations, store the powers of the highest peaks; in order to estimate the false-alarm probability of a given power, count how many times the highest peak of the simulations exceeds that power, as a fraction of  $N$ . If you instead want to find the inverse of the false-alarm probability  $\\text{prob}$ , looks for the  $N\\cdot\\text{prob}$ -th element of the highest peaks vector sorted in descending order. Remember to pass to  lombscargle  function the same options, if any, you used to compute the Lomb–Scargle periodogram before. LombScargle.jl  provides simple methods to perform such analysis. The  LombScargle.bootstrap  function allows you to create a bootstrap sample with  N  permutations of the original data."},{"id":1301,"pagetitle":"LombScargle.jl","title":"LombScargle.bootstrap","ref":"/previews/PR43/LombScargle/stable/#LombScargle.bootstrap","content":" LombScargle.bootstrap  —  Function LombScargle.bootstrap(N::Integer,\n                      times::AbstractVector{Real},\n                      signal::AbstractVector{Real},\n                      errors::AbstractVector{Real}=ones(signal); ...) Create  N  bootstrap samples, perform the Lomb–Scargle analysis on them, and store all the highest peaks for each one in a  LombScargle.Bootstrap  object. All the arguments after  N  are passed around to  lombscargle . source LombScargle.bootstrap(N::Integer, plan::PeriodogramPlan) Create  N  bootstrap samples, perform the Lomb–Scargle analysis on them for the given  plan , and store all the highest peaks for each one in a  LombScargle.Bootstrap  object. See documentation of  LombScargle.plan  for how to plan a Lomb–Scargle periodogram. source The false-alarm probability and its inverse can be calculated with  fap  and  fapinv  functions respectively.  Their syntax is the same as the methods introduced above, but with a  LombScargle.Bootstrap  object as first argument, instead of the  LombScargle.Periodogram  one."},{"id":1302,"pagetitle":"LombScargle.jl","title":"LombScargle.fap","ref":"/previews/PR43/LombScargle/stable/#LombScargle.fap-Tuple{LombScargle.Bootstrap{var\"#s1\"} where var\"#s1\"<:AbstractFloat, Real}","content":" LombScargle.fap  —  Method fap(b::Bootstrap, power::Real) Return the false-alarm probability for  power  in the bootstrap sample  b . Its inverse is the  fapinv  function. source"},{"id":1303,"pagetitle":"LombScargle.jl","title":"LombScargle.fapinv","ref":"/previews/PR43/LombScargle/stable/#LombScargle.fapinv-Tuple{LombScargle.Bootstrap{var\"#s1\"} where var\"#s1\"<:AbstractFloat, Real}","content":" LombScargle.fapinv  —  Method fapinv(b::Bootstrap, prob::Real) Return the power value whose false-alarm probability is  prob  in the bootstrap sample  b . It returns  NaN  if the requested probability is too low and the power cannot be determined with the bootstrap sample  b .  In this case, you should enlarge your bootstrap sample so that  N*fap  can be rounded to an integer larger than or equal to 1. This is the inverse of  fap  function. source"},{"id":1304,"pagetitle":"LombScargle.jl","title":"LombScargle.model Function","ref":"/previews/PR43/LombScargle/stable/#LombScargle.model-Function","content":" LombScargle.model  Function For each frequency  $f$  (and hence for the corresponding angular frequency  $\\omega = 2\\pi f$ ) the Lomb–Scargle algorithm looks for the sinusoidal function of the type \\[a_f\\cos(\\omega t) + b_f\\sin(\\omega t) + c_f\\] that best fits the data. In the original Lomb–Scargle algorithm the offset  $c$  is null (see [LOM76]). In order to find the best-fitting coefficients  $a_f$ ,  $b_f$ , and  $c_f$  for the given frequency  $f$ , without actually performing the periodogram, you can solve the linear system  $\\mathbf{A}x = \\mathbf{y}$ , where  $\\mathbf{A}$  is the matrix \\[\\begin{aligned}\n\\begin{bmatrix}\n  \\cos(\\omega t) & \\sin(\\omega t) & 1\n\\end{bmatrix} =\n\\begin{bmatrix}\n  \\cos(\\omega t_{1}) & \\sin(\\omega t_{1}) & 1      \\\\\n  \\vdots             & \\vdots             & \\vdots \\\\\n  \\cos(\\omega t_{n}) & \\sin(\\omega t_{n}) & 1\n\\end{bmatrix}\n\\end{aligned}\\] $t = [t_1, \\dots, t_n]^\\text{T}$  is the column vector of observation times,  $x$  is the column vector with the unknown coefficients \\[\\begin{aligned}\n\\begin{bmatrix}\n  a_f \\\\\n  b_f \\\\\n  c_f\n\\end{bmatrix}\n\\end{aligned}\\] and  $\\textbf{y}$  is the column vector of the signal. The solution of the matrix gives the wanted coefficients. This is what the  LombScargle.model  function does in order to return the best fitting Lomb–Scargle model for the given signal at the given frequency."},{"id":1305,"pagetitle":"LombScargle.jl","title":"LombScargle.model","ref":"/previews/PR43/LombScargle/stable/#LombScargle.model","content":" LombScargle.model  —  Function LombScargle.model(times::AbstractVector{Real},\n                  signal::AbstractVector{R2},\n                  [errors::AbstractVector{R3},]\n                  frequency::Real,\n                  [times_fit::AbstractVector{R4}];\n                  center_data::Bool=true,\n                  fit_mean::Bool=true) Return the best fitting Lomb–Scargle model for the given signal at the given frequency. Mandatory arguments are: times : the observation times signal : the signal, sampled at  times  (must have the same length as  times ) frequency : the frequency at which to calculate the model Optional arguments are: errors : the vector of uncertainties of the signal.  If provided, it must have the same length as  signal  and  times , and be the third argument.  Like for  lombscargle , if the signal has uncertainties, the  signal  vector can also be a vector of  Measurement  objects, and this argument should be omitted times_fit : the vector of times at which the model will be calculated.  It defaults to  times .  If provided, it must come after  frequency Optional keyword arguments  center_data  and  fit_mean  have the same meaning as in  lombscargle : fit_mean : whether to fit for the mean. If this is  false , like in the original Lomb–Scargle periodogram,  $\\mathbf{A}$  does not have the third column of ones,  $c_f$  is set to  $0$  and the unknown vector to be determined becomes  $x = [a_f, b_f]^\\text{T}$ center_data : whether the data should be pre-centered before solving the linear system. This is particularly important if  fit_mean=false source"},{"id":1306,"pagetitle":"LombScargle.jl","title":"Examples","ref":"/previews/PR43/LombScargle/stable/#Examples","content":" Examples Here is an example of a noisy periodic signal ( $\\sin(\\pi t) + 1.5\\cos(2\\pi t)$ ) sampled at unevenly spaced times. julia> using LombScargle\n\njulia> ntimes = 1001\n1001\n\njulia> t = range(0.01, stop = 10pi, length = ntimes) # Observation times\n0.01:0.03140592653589793:31.41592653589793\n\njulia> t += step(t)*rand(ntimes) # Randomize times\n\njulia> s = sinpi.(t) .+ 1.5cospi.(2t) .+ rand(ntimes) # The signal\n\njulia> plan = LombScargle.plan(t, s); # Pre-plan the periodogram\n\njulia> pgram = lombscargle(plan) # Compute the periodogram\nLombScargle.Periodogram{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}},Array{Float64,1}}([0.000472346, 0.000461633, 0.000440906, 0.000412717, 0.000383552, 0.000355828, 0.000289723, 0.000154585, 3.44734e-5, 5.94437e-7  …  3.15125e-5, 0.000487391, 0.0018939, 0.00367003, 0.00484181, 0.00495189, 0.00453233, 0.00480968, 0.00619657, 0.0074052], 0.003185690706734265:0.00637138141346853:79.72190993602499, [0.0295785, 0.0540516, 0.0780093, 0.122759, 0.15685, 0.192366, 0.206601, 0.252829, 0.265771, 0.315443  …  31.1512, 31.1758, 31.2195, 31.2342, 31.2752, 31.293, 31.3517, 31.3761, 31.4148, 31.4199], :standard) You can plot the result, for example with  Plots  package. Use  freqpower  function to get the frequency grid and the power of the periodogram as a 2-tuple. using Plots\nplot(freqpower(pgram)...) You can also plot the power vs the period, instead of the frequency, with  periodpower : using Plots\nplot(periodpower(pgram)...) Warning If you do not fit for the mean of the signal ( fit_mean=false  keyword to  lombscargle  function) without centering the data ( center_data=false ) you can get inaccurate results. For example, spurious peaks at low frequencies can appear and the real peaks lose power: plot(freqpower(lombscargle(t, s, fit_mean=false, center_data=false))...) Tip You can tune the frequency grid with appropriate keywords to  lombscargle  function. For example, in order to increase the sampling increase  samples_per_peak , and set  maximum_frequency  to lower values in order to narrow the frequency range: plot(freqpower(lombscargle(t, s, samples_per_peak=20, maximum_frequency=1.5))...) If you simply want to use your own frequency grid, directly set the  frequencies  keyword: plot(freqpower(lombscargle(t, s, frequencies=0.001:1e-3:1.5))...)"},{"id":1307,"pagetitle":"LombScargle.jl","title":"Signal with Uncertainties","ref":"/previews/PR43/LombScargle/stable/#Signal-with-Uncertainties","content":" Signal with Uncertainties The generalised Lomb–Scargle periodogram is able to handle a signal with uncertainties, and they will be used as weights in the algorithm.  The uncertainties can be passed either as the third optional argument  errors  to  lombscargle  or by providing this function with a  signal  vector of type  Measurement  (from  Measurements.jl  package). using Measurements, Plots\nntimes = 1001\nt = range(0.01, stop = 10pi, length = ntimes)\ns = sinpi.(2t)\nerrors = rand(0.1:1e-3:4.0, ntimes)\n# Run one of the two following equivalent commands\nplot(freqpower(lombscargle(t, s, errors, maximum_frequency=1.5))...)\nplot(freqpower(lombscargle(t, measurement(s, errors), maximum_frequency=1.5))...) This is the plot of the power versus the period: # Run one of the two following equivalent commands\nplot(periodpower(lombscargle(t, s, errors, maximum_frequency=1.5))...)\nplot(periodpower(lombscargle(t, measurement(s, errors), maximum_frequency=1.5))...) We recall that the generalised Lomb–Scargle algorithm is used when the  fit_mean  optional keyword to  lombscargle  is  true  if no error is provided, instead it is always used if the signal has uncertainties."},{"id":1308,"pagetitle":"LombScargle.jl","title":"Find Highest Power and Associated Frequencies and Periods","ref":"/previews/PR43/LombScargle/stable/#Find-Highest-Power-and-Associated-Frequencies-and-Periods","content":" Find Highest Power and Associated Frequencies and Periods findmaxfreq  function tells you the frequencies with the highest power in the periodogram (and you can get the period by taking its inverse): julia> t = range(0, stop = 10, length = 1001);\n\njulia> s = sinpi.(t);\n\njulia> plan = LombScargle.plan(t, s); # Plan the periodogram\n\njulia> p = lombscargle(plan);\n\njulia> findmaxperiod(p) # Period with highest power\n1-element Array{Float64,1}:\n 0.004987779939149084\n\njulia> findmaxfreq(p) # Frequency with the highest power\n1-element Array{Float64,1}:\n 200.49 This peak is at high frequencies, very far from the expected value of the period of 2. In order to find the real peak, you can either narrow the ranges in order to exclude higher armonics julia> findmaxperiod(p, [1, 10]) # Limit the search to periods in [1, 10]\n1-element Array{Float64,1}:\n 2.04082\n\njulia> findmaxfreq(p, [0.1, 1]) # Limit the search to frequencies in [0.1, 1]\n1-element Array{Float64,1}:\n 0.49 or pass the  threshold  argument to  findmaxfreq  or  findmaxperiod . You can use  findmaxpower  to discover the highest power in the periodogram: julia> findmaxpower(p)\n0.9958310178312316\n\njulia> findmaxperiod(p, 0.95)\n10-element Array{Float64,1}:\n 2.04082\n 1.96078\n 0.0100513\n 0.0100492\n 0.00995124\n 0.00994926\n 0.00501278\n 0.00501228\n 0.00498778\n 0.00498728\n\njulia> findmaxfreq(p, 0.95)\n10-element Array{Float64,1}:\n   0.49\n   0.51\n  99.49\n  99.51\n 100.49\n 100.51\n 199.49\n 199.51\n 200.49\n 200.51 The first peak is the real one, the other double peaks appear at higher armonics. Tip Usually, plotting the periodogram can give you a clue of what's going on."},{"id":1309,"pagetitle":"LombScargle.jl","title":"Significance of the Peaks","ref":"/previews/PR43/LombScargle/stable/#Significance-of-the-Peaks","content":" Significance of the Peaks The significance of the peaks in the Lomb–Scargle periodogram can be assessed by measuring the  False-Alarm Probability . Analytic expressions of this quantity and its inverse can be obtained with the  fap  and  fapinv  functions, respectively. julia> t = linspace(0.01, 20, samples_per_peak = 10)\n\njulia> s = sinpi.(e.*t).^2 .- cos.(5t).^4\n\njulia> plan = LombScargle.plan(t, s);\n\njulia> p = lombscargle(plan)\n\n# Find the false-alarm probability for the highest peak.\njulia> fap(p, 0.3)\n0.028198095962262748 Thus, a peak with power  $0.3$  has a probability of  $0.028$  that it is due to noise only. A quantity that is often used is the inverse of the false-alarm probability as well: what is the minimum power whose false-alarm probability is lower than the given probability? For example, if you want to know the minimum power for which the false-alarm probability is at most  $0.01$  you can use: julia> fapinv(p, 0.01)\n0.3304696923786712 As we already noted, analytic expressions of the false-alarm probability and its inverse may not be reliable if your data does not satisfy specific assumptions. A better way to calculate this quantity is to use statistical methods. One of this is bootstrapping. In  LombScargle.jl , you can use the function  LombScargle.bootstrap  to create a bootstrap sample and then you can calculate the false-alarm probability and its inverse using this sample. Tip When applying the bootstrap method you should use the same options you used to perform the periodogram on your data. Using the same periodogram plan you used to compute the periodogram will ensure that you use the same options. However, note that the fast method gives approximate results that for some frequencies may not be reliable (they can go outside the range  $[0, 1]$  for the standard normalization). More robust results can be obtained with the  fast = false  option. # Create a bootstrap sample with 10000\n# resamplings of the original data, re-using the\n# same periodogram plan.  The larger the better.\n# This may take some minutes.\njulia> b = LombScargle.bootstrap(10000, plan)\n\n# Calculate the false-alarm probability of a peak\n# with power 0.3 using this bootstrap sample.\njulia> fap(b, 0.3)\n0.0209\n\n# Calculate the lowest power that has probability\n# less than 0.01 in this bootstrap sample.\njulia> fapinv(b, 0.01)\n0.3268290388848437 If you query  fapinv  with a too low probability, the corresponding power cannot be determined and you will get  NaN  as result. julia> fapinv(b, 1e-5)\nNaN If you want to find the power corresponding to a false-alarm probability of  $\\text{prob} = 10^{-5}$ , you have to create a new bootstrap sample with  $N$  resamplings so that  $N\\cdot\\text{prob}$  can be rounded to an integer larger than or equal to one (for example  $N = 10^{5}$ )."},{"id":1310,"pagetitle":"LombScargle.jl","title":"Find the Best-Fitting Model","ref":"/previews/PR43/LombScargle/stable/#Find-the-Best-Fitting-Model","content":" Find the Best-Fitting Model The  LombScargle.model  function can help you to test whether a certain frequency fits well your data. using Plots\nt = range(0.01, stop = 10pi, length = 1000) # Observation times\ns = sinpi.(t) .+ 1.2cospi.(t) .+ 0.3rand(length(t)) # The noisy signal\n# Pick-up the best frequency\nf = findmaxfreq(lombscargle(t, s, maximum_frequency=10, samples_per_peak=20))[1]\nt_fit = range(0, stop = 1, length = 50)\ns_fit = LombScargle.model(t, s, f, t_fit/f) # Determine the model\nscatter(mod.(t.*f, 1), s, lab=\"Phased data\", title=\"Best Lomb-Scargle frequency: $f\")\nplot!(t_fit, s_fit, lab=\"Best-fitting model\", linewidth=4) Tip If there are more than one dominant frequency you may need to consider more models. This task may require some work and patience. Plot the periodogram in order to find the best frequencies. using Plots\nt = range(0.01, stop = 5, length = 1000) # Observation times\ns = sinpi.(2t) .+ 1.2cospi.(4t) .+ 0.3rand(length(t)) # Noisy signal\nplan = LombScargle.plan(t, s, samples_per_peak=50)\np = lombscargle(plan)\n# After plotting the periodogram, you discover\n# that it has two prominent peaks around 1 and 2.\nf1 = findmaxfreq(p, [0.8, 1.2])[1] # Get peak frequency around 1\nf2 = findmaxfreq(p, [1.8, 2.2])[1] # Get peak frequency around 2\nfit1 = LombScargle.model(t, s, f1) # Determine the first model\nfit2 = LombScargle.model(t, s, f2) # Determine the second model\nscatter(t, s, lab=\"Data\", title=\"Best-fitting Lomb-Scargle model\")\nplot!(t, fit1 + fit2, lab=\"Best-fitting model\", linewidth=4)"},{"id":1311,"pagetitle":"LombScargle.jl","title":"Performance","ref":"/previews/PR43/LombScargle/stable/#Performance","content":" Performance A pre-planned periodogram in  LombScargle.jl  computed in single thread mode with the fast method is more than 2 times faster than the implementation of the same algorithm provided by AstroPy, and more than 4 times faster if 4 FFTW threads are used (on machines with at least 4 physical CPUs). The following plot shows a comparison between the times needed to compute a periodogram for a signal with N datapoints using  LombScargle.jl , with 1 or 4 FFTW threads (with  flags = FFTW.MEASURE  for better performance), and the single-threaded Astropy implementation.  (Julia version: 1.6.0;  LombScargle.jl  version: 1.0.0; Python version: 3.8.6; Astropy version: 4.1.  CPU: Intel(R) Core(TM) i7-4870HQ CPU @ 2.50GHz.) Note that this comparison is unfair, as Astropy doesn’t support pre-planning a periodogram nor multi-threading, and it pads vectors for FFT to a length which is a power of 2, while by default  LombScargle.jl  uses length which are multiples of 2, 3, 5, 7.  A non-planned periodogram in single thread mode in  LombScargle.jl  is still twice as fast as Astropy."},{"id":1312,"pagetitle":"LombScargle.jl","title":"Development","ref":"/previews/PR43/LombScargle/stable/#Development","content":" Development The package is developed at  https://github.com/JuliaAstro/LombScargle.jl . There you can submit bug reports, make suggestions, and propose pull requests."},{"id":1313,"pagetitle":"LombScargle.jl","title":"History","ref":"/previews/PR43/LombScargle/stable/#History","content":" History The ChangeLog of the package is available in  NEWS.md  file in top directory."},{"id":1314,"pagetitle":"LombScargle.jl","title":"License","ref":"/previews/PR43/LombScargle/stable/#License","content":" License The  LombScargle.jl  package is licensed under the BSD 3-clause \"New\" or \"Revised\" License. The original author is Mosè Giordano."},{"id":1315,"pagetitle":"LombScargle.jl","title":"Acknowledgements","ref":"/previews/PR43/LombScargle/stable/#Acknowledgements","content":" Acknowledgements This package adapts the implementation in Astropy of the the fast Lomb–Scargle method by [PR89]. We claim no endorsement nor promotion by the Astropy Team."}]