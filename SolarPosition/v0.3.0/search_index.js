var documenterSearchIndex = {"docs":
[{"location":"guides/benchmarking/#benchmarking","page":"Benchmarking","title":"Benchmarking","text":"This page provides comprehensive benchmarks of the solar position algorithms available in SolarPosition.jl, comparing their computational performance and accuracy. The SPA algorithm is used as the reference \"gold standard\" due to its high precision (±0.0003°).\n\nusing SolarPosition\nusing CairoMakie\nusing Dates\nusing DataFrames\nusing Statistics\nusing BenchmarkTools","category":"section"},{"location":"guides/benchmarking/#Algorithm-Overview","page":"Benchmarking","title":"Algorithm Overview","text":"SolarPosition.jl provides several solar positioning algorithms with different accuracy/performance trade-offs:\n\nAlgorithm Claimed Accuracy Complexity\nSPA ±0.0003° High\nPSA ±0.0083° Low\nNOAA ±0.0167° Low\nWalraven ±0.0100° Low\nUSNO ±0.0500° Low","category":"section"},{"location":"guides/benchmarking/#Accuracy-Analysis","page":"Benchmarking","title":"Accuracy Analysis","text":"To evaluate accuracy, we compare each algorithm against SPA across a full year of hourly timestamps at various geographic locations.\n\n# Test locations representing different latitudes\nlocations = [\n    (name = \"Equator\", obs = Observer(0.0, 0.0, 0.0)),\n    (name = \"Mid-latitude (London)\", obs = Observer(51.5074, -0.1278, 11.0)),\n    (name = \"High-latitude (Oslo)\", obs = Observer(59.9139, 10.7522, 23.0)),\n    (name = \"Southern hemisphere (Sydney)\", obs = Observer(-33.8688, 151.2093, 58.0)),\n]\n\n# Generate hourly timestamps for a full year\ntimes = collect(DateTime(2024, 1, 1):Hour(1):DateTime(2024, 12, 31, 23))\nprintln(\"Testing with $(length(times)) timestamps per location\")\n\ndetails: Accuracy comparison\nusing Statistics: quantile\n\n\"\"\"\nCompare algorithm accuracy against SPA reference.\nReturns DataFrame with error statistics including percentiles.\n\"\"\"\nfunction compare_accuracy(obs::Observer, times::Vector{DateTime}, algo)\n    # Get SPA reference positions\n    spa_pos = solar_position(obs, times, SPA())\n\n    # Get algorithm positions\n    algo_pos = solar_position(obs, times, algo)\n\n    # Calculate errors for all positions\n    elev_errors = abs.(algo_pos.elevation .- spa_pos.elevation)\n    azim_errors = abs.(algo_pos.azimuth .- spa_pos.azimuth)\n\n    # Handle azimuth wraparound (0° and 360° are the same)\n    azim_errors = min.(azim_errors, 360.0 .- azim_errors)\n\n    return (\n        elevation_mean = mean(elev_errors),\n        elevation_p2_5 = quantile(elev_errors, 0.025),\n        elevation_p97_5 = quantile(elev_errors, 0.975),\n        elevation_max = maximum(elev_errors),\n        azimuth_mean = mean(azim_errors),\n        azimuth_p2_5 = quantile(azim_errors, 0.025),\n        azimuth_p97_5 = quantile(azim_errors, 0.975),\n        azimuth_max = maximum(azim_errors),\n        n_samples = length(times),\n    )\nend\n\nnothing # hide\n\ndetails: Data collection\n# Algorithms to compare (excluding SPA which is the reference)\nalgorithms = [\n    (\"PSA\", PSA()),\n    (\"NOAA\", NOAA()),\n    (\"Walraven\", Walraven()),\n    (\"USNO\", USNO()),\n]\n\n# Collect accuracy data\naccuracy_results = DataFrame(\n    Algorithm = String[],\n    Location = String[],\n    Elevation_Mean_Error = Float64[],\n    Elevation_P2_5 = Float64[],\n    Elevation_P97_5 = Float64[],\n    Elevation_Max_Error = Float64[],\n    Azimuth_Mean_Error = Float64[],\n    Azimuth_P2_5 = Float64[],\n    Azimuth_P97_5 = Float64[],\n    Azimuth_Max_Error = Float64[],\n)\n\nfor (algo_name, algo) in algorithms\n    for loc in locations\n        stats = compare_accuracy(loc.obs, times, algo)\n        push!(accuracy_results, (\n            Algorithm = algo_name,\n            Location = loc.name,\n            Elevation_Mean_Error = stats.elevation_mean,\n            Elevation_P2_5 = stats.elevation_p2_5,\n            Elevation_P97_5 = stats.elevation_p97_5,\n            Elevation_Max_Error = stats.elevation_max,\n            Azimuth_Mean_Error = stats.azimuth_mean,\n            Azimuth_P2_5 = stats.azimuth_p2_5,\n            Azimuth_P97_5 = stats.azimuth_p97_5,\n            Azimuth_Max_Error = stats.azimuth_max,\n        ))\n    end\nend\n\naccuracy_results","category":"section"},{"location":"guides/benchmarking/#Accuracy-Visualization","page":"Benchmarking","title":"Accuracy Visualization","text":"The following plots show the mean error with 95% confidence intervals (2.5th to 97.5th percentile) for each algorithm compared to SPA.\n\ndetails: Accuracy visualization\n# Aggregate results by algorithm (mean across all locations)\nalgo_stats = combine(\n    groupby(accuracy_results, :Algorithm),\n    :Elevation_Mean_Error => mean => :Elev_Mean,\n    :Elevation_P2_5 => mean => :Elev_P2_5,\n    :Elevation_P97_5 => mean => :Elev_P97_5,\n    :Azimuth_Mean_Error => mean => :Azim_Mean,\n    :Azimuth_P2_5 => mean => :Azim_P2_5,\n    :Azimuth_P97_5 => mean => :Azim_P97_5,\n)\n\n# Sort by algorithm order\nalgo_order = [\"PSA\", \"NOAA\", \"Walraven\", \"USNO\"]\nalgo_stats = algo_stats[sortperm([findfirst(==(algo), algo_order) for algo in algo_stats.Algorithm]), :]\n\nfig = Figure(size = (900, 400), backgroundcolor = :transparent, fontsize = 12, textcolor = \"#f5ab35\")\n\n# Elevation error plot with error bars\nax1 = Axis(fig[1, 1],\n    title = \"Elevation Error vs SPA (95% CI)\",\n    xlabel = \"Algorithm\",\n    ylabel = \"Error (degrees)\",\n    xticks = (1:4, algo_stats.Algorithm),\n    backgroundcolor = :transparent,\n)\n\n# Error bars showing 95% interval\nerrorbars!(ax1, 1:4, algo_stats.Elev_Mean,\n    algo_stats.Elev_Mean .- algo_stats.Elev_P2_5,\n    algo_stats.Elev_P97_5 .- algo_stats.Elev_Mean,\n    color = :steelblue, linewidth = 2, whiskerwidth = 10)\nscatter!(ax1, 1:4, algo_stats.Elev_Mean, color = :steelblue, markersize = 12)\n\n# Azimuth error plot with error bars\nax2 = Axis(fig[1, 2],\n    title = \"Azimuth Error vs SPA (95% CI)\",\n    xlabel = \"Algorithm\",\n    ylabel = \"Error (degrees)\",\n    xticks = (1:4, algo_stats.Algorithm),\n    backgroundcolor = :transparent,\n)\n\nerrorbars!(ax2, 1:4, algo_stats.Azim_Mean,\n    algo_stats.Azim_Mean .- algo_stats.Azim_P2_5,\n    algo_stats.Azim_P97_5 .- algo_stats.Azim_Mean,\n    color = :coral, linewidth = 2, whiskerwidth = 10)\nscatter!(ax2, 1:4, algo_stats.Azim_Mean, color = :coral, markersize = 12)\n\nnothing # hide\n\nfig # hide","category":"section"},{"location":"guides/benchmarking/#PSA-Error-Over-Time","page":"Benchmarking","title":"PSA Error Over Time","text":"To better understand how errors vary throughout the year, we compare the PSA algorithm against SPA at hourly resolution for a full year at a single location.\n\n# Generate hourly timestamps for a full year (reduces memory usage vs minute resolution)\nhourly_times = collect(DateTime(2024, 1, 1):Hour(1):DateTime(2024, 12, 31, 23))\nobs_london = Observer(51.5074, -0.1278, 11.0)\n\n# Calculate positions\nspa_positions = solar_position(obs_london, hourly_times, SPA())\npsa_positions = solar_position(obs_london, hourly_times, PSA())\n\n# Calculate errors\nelev_errors = psa_positions.elevation .- spa_positions.elevation\nazim_errors = psa_positions.azimuth .- spa_positions.azimuth\n\n# Handle azimuth wraparound\nazim_errors = [abs(e) > 180 ? e - sign(e) * 360 : e for e in azim_errors]\n\nprintln(\"PSA vs SPA at hourly resolution ($(length(hourly_times)) samples):\")\nprintln(\"  Elevation: mean=$(round(mean(abs.(elev_errors)), digits=6))°, max=$(round(maximum(abs.(elev_errors)), digits=4))°\")\nprintln(\"  Azimuth: mean=$(round(mean(abs.(azim_errors)), digits=6))°, max=$(round(maximum(abs.(azim_errors)), digits=4))°\")\n\ndetails: PSA error visualization\nfig_err = Figure(size = (900, 500), backgroundcolor = :transparent, fontsize = 12, textcolor = \"#f5ab35\")\n\n# Convert to day of year for x-axis\nday_of_year = [Dates.dayofyear(t) for t in hourly_times]\n\nax1 = Axis(fig_err[1, 1],\n    title = \"PSA Elevation Error vs SPA (2024, London)\",\n    xlabel = \"Day of Year\",\n    ylabel = \"Error (degrees)\",\n    backgroundcolor = :transparent,\n)\nscatter!(ax1, day_of_year, elev_errors, markersize = 1.5, color = (:steelblue, 0.5))\nhlines!(ax1, [0.0], color = :gray, linestyle = :dash)\n\nax2 = Axis(fig_err[2, 1],\n    title = \"PSA Azimuth Error vs SPA (2024, London)\",\n    xlabel = \"Day of Year\",\n    ylabel = \"Error (degrees)\",\n    backgroundcolor = :transparent,\n)\nscatter!(ax2, day_of_year, azim_errors, markersize = 1.5, color = (:coral, 0.5))\nhlines!(ax2, [0.0], color = :gray, linestyle = :dash)\n\nnothing # hide\n\nfig_err # hide","category":"section"},{"location":"guides/benchmarking/#Error-Distribution-by-Location","page":"Benchmarking","title":"Error Distribution by Location","text":"details: Error distribution visualization\nfig2 = Figure(size = (900, 500), backgroundcolor = :transparent, fontsize = 11, textcolor = \"#f5ab35\")\n\nfor (i, loc) in enumerate(locations)\n    row = (i - 1) ÷ 2 + 1\n    col = (i - 1) % 2 + 1\n\n    ax = Axis(fig2[row, col],\n        title = loc.name,\n        xlabel = \"Algorithm\",\n        ylabel = \"Mean Elevation Error (°)\",\n        xticks = (1:4, [a[1] for a in algorithms]),\n        backgroundcolor = :transparent,\n    )\n\n    loc_data = filter(r -> r.Location == loc.name, accuracy_results)\n    barplot!(ax, 1:4, loc_data.Elevation_Mean_Error, color = :teal)\nend\n\nLabel(fig2[0, :], \"Elevation Error by Location\", fontsize = 14, font = :bold)\n\nnothing # hide\n\nfig2 # hide","category":"section"},{"location":"guides/benchmarking/#Performance-Benchmarks","page":"Benchmarking","title":"Performance Benchmarks","text":"We benchmark the computational performance of each algorithm across different input sizes, from single timestamp calculations to bulk operations with 100,000 timestamps.\n\ndetails: Single benchmark\n# Single position benchmarks\nobs = Observer(51.5074, -0.1278, 11.0)  # London\ndt = DateTime(2024, 6, 21, 12, 0, 0)\n\nsingle_benchmarks = DataFrame(\n    Algorithm = String[],\n    Time_ns = Float64[],\n    Allocations = Int[],\n)\n\nfor (name, algo) in [(\"PSA\", PSA()), (\"NOAA\", NOAA()), (\"Walraven\", Walraven()),\n                      (\"USNO\", USNO()), (\"SPA\", SPA())]\n    b = @benchmark solar_position($obs, $dt, $algo) samples=100 evals=10\n    push!(single_benchmarks, (\n        Algorithm = name,\n        Time_ns = median(b.times),\n        Allocations = b.allocs,\n    ))\nend\n\n# Add relative timing\nsingle_benchmarks.Time_μs = single_benchmarks.Time_ns ./ 1000\nspa_time = filter(row -> row.Algorithm == \"SPA\", single_benchmarks).Time_ns[1]\nsingle_benchmarks.Relative_to_SPA = single_benchmarks.Time_ns ./ spa_time\n\nsingle_benchmarks[:, [:Algorithm, :Time_μs, :Allocations, :Relative_to_SPA]]\n\ndetails: Vector benchmark\n# Vector benchmarks for different sizes\nsizes = [100, 1_000, 10_000, 100_000]\n\nvector_benchmarks = DataFrame(\n    Algorithm = String[],\n    N = Int[],\n    Time_ms = Float64[],\n    Throughput = Float64[],  # positions per second\n)\n\nfor n in sizes\n    times_vec = collect(DateTime(2024, 1, 1):Hour(1):(DateTime(2024, 1, 1) + Hour(n-1)))\n\n    for (name, algo) in [(\"PSA\", PSA()), (\"NOAA\", NOAA()), (\"Walraven\", Walraven()),\n                          (\"USNO\", USNO()), (\"SPA\", SPA())]\n        b = @benchmark solar_position($obs, $times_vec, $algo) samples=10 evals=1\n        time_ms = median(b.times) / 1e6\n        push!(vector_benchmarks, (\n            Algorithm = name,\n            N = n,\n            Time_ms = time_ms,\n            Throughput = n / (time_ms / 1000),\n        ))\n    end\nend\n\n# Pivot for display\nvector_pivot = unstack(vector_benchmarks, :Algorithm, :N, :Time_ms)\nvector_pivot","category":"section"},{"location":"guides/benchmarking/#Performance-Visualization","page":"Benchmarking","title":"Performance Visualization","text":"details: Performance visualization\nfig3 = Figure(size = (900, 400), backgroundcolor = :transparent, fontsize = 12, textcolor = \"#f5ab35\")\n\n# Scaling plot (log-log)\nax1 = Axis(fig3[1, 1],\n    title = \"Computation Time vs Input Size\",\n    xlabel = \"Number of Timestamps\",\n    ylabel = \"Time (ms)\",\n    xscale = log10,\n    yscale = log10,\n    backgroundcolor = :transparent,\n)\n\ncolors = [:blue, :orange, :green, :purple, :red]\nalgo_names = [\"PSA\", \"NOAA\", \"Walraven\", \"USNO\", \"SPA\"]\n\nfor (i, algo) in enumerate(algo_names)\n    data = filter(r -> r.Algorithm == algo, vector_benchmarks)\n    lines!(ax1, data.N, data.Time_ms, label = algo, color = colors[i], linewidth = 2)\n    scatter!(ax1, data.N, data.Time_ms, color = colors[i], markersize = 8)\nend\naxislegend(ax1, position = :rb, framevisible = false, labelsize = 10)\n\n# Throughput plot\nax2 = Axis(fig3[1, 2],\n    title = \"Throughput at N=100,000\",\n    xlabel = \"Algorithm\",\n    ylabel = \"Positions per Second\",\n    xticks = (1:5, algo_names),\n    backgroundcolor = :transparent,\n)\n\nthroughput_100k = filter(r -> r.N == 100_000, vector_benchmarks)\nbarplot!(ax2, 1:5, throughput_100k.Throughput ./ 1e6, color = colors)\nax2.ylabel = \"Million Positions / Second\"\n\nnothing # hide\n\nfig3 # hide","category":"section"},{"location":"guides/benchmarking/#Comparison-with-solposx-(Python)","page":"Benchmarking","title":"Comparison with solposx (Python)","text":"The solposx package is a Python library that implements the same solar position algorithms. This section compares the performance of SolarPosition.jl against solposx to demonstrate the benefits of using Julia.\n\nnote: Benchmarking Methodology\nThe benchmarks below use PythonCall.jl to call solposx from within Julia. We have also benchmarked solposx directly in a pure Python environment (without PythonCall.jl overhead) and found no significant difference in the results.","category":"section"},{"location":"guides/benchmarking/#Setup","page":"Benchmarking","title":"Setup","text":"First, we install and import solposx using PythonCall.jl and CondaPkg.jl:\n\nusing CondaPkg\nCondaPkg.add_pip(\"solposx\")\nCondaPkg.add_pip(\"pandas\")\n\nusing PythonCall\n\n# Import Python modules\nsp = pyimport(\"solposx.solarposition\")\npd = pyimport(\"pandas\")","category":"section"},{"location":"guides/benchmarking/#Benchmark-Configuration","page":"Benchmarking","title":"Benchmark Configuration","text":"For fair comparison, we use the same test conditions for both libraries:\n\nObserver: London (51.5074°N, 0.1278°W, 11m elevation)\nTimestamps: Hourly data from January 1, 2024\nAlgorithms: PSA, NOAA, Walraven, USNO, SPA\n\n# Helper function to create pandas DatetimeIndex\nfunction create_pandas_times(n::Int)\n    pd.date_range(start=\"2024-01-01 00:00:00\", periods=n, freq=\"h\", tz=\"UTC\")\nend\n\n# solposx algorithm mapping - use Symbol keys for kwargs\nsolposx_algorithms = Dict(\n    \"PSA\" => (sp.psa, (coefficients = 2020,)),\n    \"NOAA\" => (sp.noaa, NamedTuple()),\n    \"Walraven\" => (sp.walraven, NamedTuple()),\n    \"USNO\" => (sp.usno, NamedTuple()),\n    \"SPA\" => (sp.spa, NamedTuple()),\n)\n\nlat, lon = 51.5074, -0.1278","category":"section"},{"location":"guides/benchmarking/#Running-the-Benchmarks","page":"Benchmarking","title":"Running the Benchmarks","text":"We benchmark both libraries across different input sizes:\n\ndetails: Benchmark code\n# Benchmark sizes\nsizes = [100, 1_000, 10_000]\n\n# Results storage\ncomparison_results = DataFrame(\n    Algorithm = String[],\n    N = Int[],\n    Julia_ms = Float64[],\n    Python_ms = Float64[],\n    Speedup = Float64[],\n)\n\nfor n in sizes\n    # Create time vectors\n    julia_times_vec = collect(DateTime(2024, 1, 1):Hour(1):(DateTime(2024, 1, 1) + Hour(n-1)))\n    py_times_idx = create_pandas_times(n)\n\n    for (algo_name, algo) in [(\"PSA\", PSA()), (\"NOAA\", NOAA()), (\"Walraven\", Walraven()),\n                               (\"USNO\", USNO()), (\"SPA\", SPA())]\n        # Julia benchmark\n        julia_bench = @benchmark solar_position($obs, $julia_times_vec, $algo) samples=5 evals=1\n        julia_time_ms = median(julia_bench.times) / 1e6\n\n        # Python benchmark\n        py_func, py_kwargs = solposx_algorithms[algo_name]\n\n        # Benchmark Python function using BenchmarkTools\n        if isempty(py_kwargs)\n            py_bench = @benchmark $py_func($py_times_idx, $lat, $lon) samples=5 evals=1\n        else\n            py_bench = @benchmark $py_func($py_times_idx, $lat, $lon; $py_kwargs...) samples=5 evals=1\n        end\n        python_time_ms = median(py_bench.times) / 1e6\n\n        speedup = python_time_ms / julia_time_ms\n\n        push!(comparison_results, (\n            Algorithm = algo_name,\n            N = n,\n            Julia_ms = round(julia_time_ms, digits=3),\n            Python_ms = round(python_time_ms, digits=3),\n            Speedup = round(speedup, digits=1),\n        ))\n    end\nend\n\ncomparison_results\n\ndetails: Performance comparison visualization\nfig5 = Figure(size = (600, 750), backgroundcolor = :transparent, fontsize = 12, textcolor = \"#f5ab35\")\n\n# Group by algorithm for plotting\nalgo_names = [\"PSA\", \"NOAA\", \"Walraven\", \"USNO\", \"SPA\"]\ncolors_julia = [:blue, :green, :purple, :orange, :red]\n\nax1 = Axis(fig5[1, 1],\n    title = \"Computation Time: Julia vs Python\",\n    xlabel = \"Number of Timestamps\",\n    ylabel = \"Time (ms)\",\n    xscale = log10,\n    yscale = log10,\n    backgroundcolor = :transparent,\n)\n\n# Store line objects for legends\njulia_lines = []\npython_lines = []\n\nfor (i, algo) in enumerate(algo_names)\n    data = filter(r -> r.Algorithm == algo, comparison_results)\n\n    # Julia times (solid lines)\n    l1 = lines!(ax1, data.N, data.Julia_ms,\n        color = colors_julia[i],\n        linewidth = 2)\n    scatter!(ax1, data.N, data.Julia_ms, color = colors_julia[i], markersize = 6)\n    push!(julia_lines, l1)\n\n    # Python times (dashed lines)\n    l2 = lines!(ax1, data.N, data.Python_ms,\n        color = colors_julia[i],\n        linewidth = 2,\n        linestyle = :dash)\n    scatter!(ax1, data.N, data.Python_ms, color = colors_julia[i], markersize = 6,\n        marker = :utriangle)\n    push!(python_lines, l2)\nend\n\n# Algorithm legend (colors)\nleg1 = Legend(fig5[1, 2][1, 1], julia_lines, algo_names, \"Algorithm\",\n    framevisible = true, backgroundcolor = :transparent, labelsize = 10, titlesize = 11)\n\n# Line style legend (solid vs dashed)\nstyle_lines = [LineElement(color = :gray, linewidth = 2, linestyle = :solid),\n               LineElement(color = :gray, linewidth = 2, linestyle = :dash)]\nleg2 = Legend(fig5[1, 2][2, 1], style_lines, [\"Julia\", \"Python\"], \"Library\",\n    framevisible = true, backgroundcolor = :transparent, labelsize = 10, titlesize = 11)\n\n# Speedup bar chart\nax2 = Axis(fig5[2, 1:2],\n    title = \"Julia vs Python at N=1,000\",\n    xlabel = \"Algorithm\",\n    ylabel = \"Speedup Factor (×)\",\n    xticks = (1:5, algo_names),\n    backgroundcolor = :transparent,\n)\n\nspeedup_1k = filter(r -> r.N == 1_000, comparison_results)\nbarplot!(ax2, 1:5, speedup_1k.Speedup, color = colors_julia)\nhlines!(ax2, [1.0], color = :gray, linestyle = :dash)\n\nnothing # hide\n\nfig5 # hide","category":"section"},{"location":"guides/benchmarking/#Summary","page":"Benchmarking","title":"Summary","text":"The benchmarks demonstrate that SolarPosition.jl offers significant performance advantages over the solposx Python library across all tested algorithms and input sizes.\n\nnote: Multi-threading\nSolarPosition.jl can leverage Julia's native multi-threading capabilities (see Parallel Computing) for further performance improvements on large datasets. The benchmarks above were conducted using a single thread for fair comparison with solposx, but enabling multi-threading can yield even greater speedups in practical applications.\n\nspeedup_table = unstack(comparison_results[:, [:Algorithm, :N, :Speedup]], :Algorithm, :N, :Speedup)\nspeedup_table","category":"section"},{"location":"contributing/#contributing","page":"Contributing guidelines","title":"Contributing guidelines","text":"First of all, thanks for the interest!\n\nWe welcome all kinds of contribution, including, but not limited to code, documentation, examples, configuration, issue creating, etc.\n\nBe polite and respectful.","category":"section"},{"location":"contributing/#Bug-reports-and-discussions","page":"Contributing guidelines","title":"Bug reports and discussions","text":"If you think you found a bug, feel free to open an issue.\n\nFocused suggestions and requests can also be opened as issues.\n\ninfo: Info\nBefore opening a pull request, it can be productive to first start an issue or a discussion on the topic so that the maintainers and community can provide feedback.","category":"section"},{"location":"contributing/#Working-on-an-issue","page":"Contributing guidelines","title":"Working on an issue","text":"If you found an issue that interests you, comment on that issue what your plans are. If the solution to the issue is clear, you can immediately create a pull request (see below ). Otherwise, say what your proposed solution is and wait for a discussion around it.\n\ntip: Tip\nFeel free to ping us after a few days if there are no responses.","category":"section"},{"location":"contributing/#Adding-a-new-algorithm","page":"Contributing guidelines","title":"Adding a new algorithm","text":"If you want to contribute a new solar positioning or refraction algorithm, see the Adding a New Solar Position Algorithm tutorial for a step-by-step guide.","category":"section"},{"location":"guides/parallel/#parallel-computing","page":"Parallel Computing with OhMyThreads.jl","title":"Parallel Computing with OhMyThreads.jl","text":"SolarPosition.jl provides a parallel computing extension using OhMyThreads.jl for efficient multithreaded solar position calculations across large time series. This extension is particularly useful when processing thousands of timestamps, where parallelization can provide significant speedups.","category":"section"},{"location":"guides/parallel/#Installation","page":"Parallel Computing with OhMyThreads.jl","title":"Installation","text":"The OhMyThreads extension is loaded automatically when both SolarPosition.jl and OhMyThreads.jl are loaded:\n\nusing SolarPosition\nusing OhMyThreads\n\nnote: Thread Configuration\nJulia must be started with multiple threads to benefit from parallelization. Use julia --threads=auto or set the JULIA_NUM_THREADS environment variable. Check the number of available threads with Threads.nthreads().","category":"section"},{"location":"guides/parallel/#Quick-Start","page":"Parallel Computing with OhMyThreads.jl","title":"Quick Start","text":"The extension adds new methods to solar_position and solar_position! that accept an OhMyThreads.Scheduler as the last argument. These methods automatically parallelize computations across the provided timestamp vector.\n\nusing SolarPosition\nusing OhMyThreads\nusing Dates\nusing StructArrays\n\n# Create observer location\nobs = Observer(51.5, -0.18, 15.0)  # London\n\n# Generate a year of minute timestamps\ntimes = collect(DateTime(2024, 1, 1):Minute(1):DateTime(2025, 1, 1))\n\n# Parallel computation with DynamicScheduler\nt0 = time()\npositions = solar_position(obs, times, PSA(), NoRefraction(), DynamicScheduler())\ndt_parallel = time() - t0\nprintln(\"Time taken (parallel): $(round(dt_parallel, digits=5)) seconds\")\n\nNow we compare this to the serial version:\n\n# Serial computation (no scheduler argument)\nt0 = time()\npositions_serial = solar_position(obs, times, PSA(), NoRefraction())\ndt_serial = time() - t0\nprintln(\"Time taken (serial): $(round(dt_serial, digits=5)) seconds\")\n\nWe observe a speedup of:\n\nspeedup = dt_serial / dt_parallel\nprintln(\"Speedup: $(round(speedup, digits=2))×\")","category":"section"},{"location":"guides/parallel/#Simplified-Syntax","page":"Parallel Computing with OhMyThreads.jl","title":"Simplified Syntax","text":"You can also use the simplified syntax with the scheduler as the third argument, which uses the default algorithm (PSA) and no refraction correction:\n\n# Simplified syntax with default algorithm\npositions = solar_position(obs, times, DynamicScheduler())\n@show first(positions, 3)","category":"section"},{"location":"guides/parallel/#Available-Schedulers","page":"Parallel Computing with OhMyThreads.jl","title":"Available Schedulers","text":"OhMyThreads.jl provides different scheduling strategies optimized for various workload characteristics:","category":"section"},{"location":"guides/parallel/#DynamicScheduler","page":"Parallel Computing with OhMyThreads.jl","title":"DynamicScheduler","text":"The DynamicScheduler is the default and recommended scheduler for most workloads. It dynamically balances tasks among threads, making it suitable for non-uniform workloads where computation times may vary. Please visit the OhMyThreads.jl documentation for more details.\n\n# Dynamic scheduling (recommended)\npositions = solar_position(obs, times, PSA(), NoRefraction(), DynamicScheduler());\nnothing # hide","category":"section"},{"location":"guides/parallel/#StaticScheduler","page":"Parallel Computing with OhMyThreads.jl","title":"StaticScheduler","text":"The StaticScheduler partitions work statically among threads. This can be more efficient for uniform workloads where all computations take approximately the same time.\n\n# Static scheduling for uniform workloads\npositions = solar_position(obs, times, PSA(), NoRefraction(), StaticScheduler())\nnothing # hide","category":"section"},{"location":"guides/parallel/#In-Place-Computation","page":"Parallel Computing with OhMyThreads.jl","title":"In-Place Computation","text":"For maximum performance and minimal allocations, use the in-place version solar_position! with a pre-allocated StructVector:\n\nusing StructArrays\n\n# Pre-allocate output array\npositions = StructVector{SolPos{Float64}}(undef, length(times))\n\n# Compute in-place\nsolar_position!(positions, obs, times, PSA(), NoRefraction(), DynamicScheduler())\nnothing # hide\n\nThe in-place version avoids allocating the output array and minimizes intermediate allocations, making it ideal for repeated computations or memory-constrained environments.","category":"section"},{"location":"guides/parallel/#Performance-Comparison","page":"Parallel Computing with OhMyThreads.jl","title":"Performance Comparison","text":"Here's a typical performance comparison between serial and parallel execution:\n\nusing BenchmarkTools\n\n### Serial execution (no scheduler argument)\n@benchmark solar_position($obs, $times, PSA(), NoRefraction())\n# BenchmarkTools.Trial: 57 samples with 1 evaluation per sample.\n#  Range (min … max):  83.994 ms … 98.110 ms  ┊ GC (min … max): 0.00% … 12.50%\n#  Time  (median):     87.907 ms              ┊ GC (median):    0.66%\n#  Time  (mean ± σ):   88.194 ms ±  2.478 ms  ┊ GC (mean ± σ):  1.39% ±  2.23%\n\n#                ▁             █\n#   ▆▁▄▁▁▁▇▆▆▁▁▇▄█▄▁▇▆▇▇▄▄▁▄▄▆▆█▆▆▄▁▆▁▁▆▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▄ ▁\n#   84 ms           Histogram: frequency by time        95.8 ms <\n\n#  Memory estimate: 12.06 MiB, allocs estimate: 9.\n\n### Parallel execution with DynamicScheduler\n@benchmark solar_position($obs, $times, PSA(), NoRefraction(), DynamicScheduler())\n# BenchmarkTools.Trial: 312 samples with 1 evaluation per sample.\n#  Range (min … max):   7.588 ms … 35.575 ms  ┊ GC (min … max):  0.00% … 74.79%\n#  Time  (median):     14.718 ms              ┊ GC (median):     6.16%\n#  Time  (mean ± σ):   16.026 ms ±  6.387 ms  ┊ GC (mean ± σ):  23.51% ± 19.37%\n\n#     ▆▆█▁▃▂▅ ▁▁▁▄▁▃▅▁  ▁▄ ▁\n#   █▇███████▄████████▇▄██▆█▇▆▇█▅▆▅▆▄▄▁▅▄▁▁▄▃▄▅▄▃▃▄▃▄▆▃▃▁▄▄▁▃▁▃ ▄\n#   7.59 ms         Histogram: frequency by time        34.4 ms <\n\n#  Memory estimate: 66.59 MiB, allocs estimate: 468.\n\n### In-place parallel execution\npos = StructVector{SolPos{Float64}}(undef, length(times))\n@benchmark solar_position!($pos, $obs, $times, PSA(), NoRefraction(), DynamicScheduler())\n# BenchmarkTools.Trial: 908 samples with 1 evaluation per sample.\n#  Range (min … max):  4.061 ms …   7.846 ms  ┊ GC (min … max): 0.00% … 0.00%\n#  Time  (median):     5.532 ms               ┊ GC (median):    0.00%\n#  Time  (mean ± σ):   5.501 ms ± 644.881 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n#                                ▃▅█▄▂▂       ▁\n#   ▃▄▅▃▄▃▃▅▃▄▃▁▃▂▃▄▂▃▂▂▃▂▂▃▂▅▃▃████████▆▅▅▄▆▅██▅▅▆▄▅▄▃▂▃▃▃▃▃▂▂ ▃\n#   4.06 ms         Histogram: frequency by time        6.72 ms <\n\n#  Memory estimate: 20.47 KiB, allocs estimate: 284.\n\n### In-place parallel execution with StaticScheduler\n@benchmark solar_position!($pos, $obs, $times, PSA(), NoRefraction(), StaticScheduler())\n# BenchmarkTools.Trial: 902 samples with 1 evaluation per sample.\n#  Range (min … max):  4.027 ms …   7.228 ms  ┊ GC (min … max): 0.00% … 0.00%\n#  Time  (median):     5.842 ms               ┊ GC (median):    0.00%\n#  Time  (mean ± σ):   5.537 ms ± 802.636 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n#  ▃▁   ▁▄▃                       ▁      ▁▅▆█▂▄▇▇▅▁▃    ▁\n#  ██▃▃▅███▅▆▆▄▄▃▃▃▃▃▂▄▅▂▁▃▆▃▃▂▅▃▅█▇▆▂▃▅▅██████████████▇█▆▇▇▂▂ ▄\n#  4.03 ms         Histogram: frequency by time        6.72 ms <\n\n#  Memory estimate: 15.97 KiB, allocs estimate: 220.\n\nOn a system with 32 threads processing 527,041 timestamps (one year, minutely):\n\nMethod Time Speedup Allocations\nSerial 87.9 ms 1.0× 12.06 MiB\nParallel (DynamicScheduler) 14.7 ms 6.0× 66.59 MiB\nIn-place (DynamicScheduler) 5.53 ms 15.9× 20.47 KiB\nIn-place (StaticScheduler) 5.84 ms 15.0× 15.97 KiB\n\ntip: Performance Tips\nFor the best performance:Use solar_position! with pre-allocated output for minimal allocations\nUse DynamicScheduler() for most workloads\nEnsure Julia is running with multiple threads (e.g., --threads=auto)\nProcess larger batches of timestamps to amortize threading overhead","category":"section"},{"location":"guides/parallel/#Working-with-Different-Time-Types","page":"Parallel Computing with OhMyThreads.jl","title":"Working with Different Time Types","text":"The parallel methods work with both DateTime and ZonedDateTime:\n\nusing TimeZones\n\n# Using ZonedDateTime (avoiding DST transitions)\ntz = tz\"Europe/London\"\n# Use a subset of times to avoid DST transition issues in documentation\nsummer_times = collect(DateTime(2024, 6, 1):Hour(1):DateTime(2024, 7, 1))\nzoned_times = ZonedDateTime.(summer_times, tz)\n\n# Parallel computation with time zone aware timestamps\nzoned_positions = solar_position(obs, zoned_times, PSA(), NoRefraction(), DynamicScheduler())\n\nprintln(\"Computed $(length(zoned_positions)) positions with time zone awareness\")","category":"section"},{"location":"guides/parallel/#Algorithm-Comparison","page":"Parallel Computing with OhMyThreads.jl","title":"Algorithm Comparison","text":"The parallel interface works with all solar position algorithms:\n\n# Test different algorithms in parallel\nalgorithms = [PSA(), NOAA(), SPA()]\n\nfor alg in algorithms\n    pos = solar_position(obs, times[1:100], alg, NoRefraction(), DynamicScheduler())\n    println(\"$(typeof(alg).name.name): azimuth=$(round(pos.azimuth[50], digits=5))°\")\nend","category":"section"},{"location":"guides/parallel/#Refraction-Correction","page":"Parallel Computing with OhMyThreads.jl","title":"Refraction Correction","text":"Atmospheric refraction corrections can be applied in parallel computations:\n\n# Parallel computation with Bennett refraction correction\npositions_refracted = solar_position(\n    obs,\n    times,\n    PSA(),\n    BENNETT(),\n    DynamicScheduler()\n)\n\nprintln(\"First position with refraction:\")\nprintln(\"  Apparent elevation: $(round(positions_refracted.apparent_elevation[1], digits=2))°\")","category":"section"},{"location":"guides/parallel/#Implementation-Details","page":"Parallel Computing with OhMyThreads.jl","title":"Implementation Details","text":"The extension uses OhMyThreads' tmap and tmap! for task-based parallelism. Each timestamp is processed independently, making the computation embarrassingly parallel with no inter-thread communication required.\n\nThe results from tmap are automatically converted to a StructVector for efficient columnar storage compatible with the rest of SolarPosition.jl's API.","category":"section"},{"location":"guides/parallel/#See-Also","page":"Parallel Computing with OhMyThreads.jl","title":"See Also","text":"Solar Positioning - Available positioning algorithms\nRefraction Correction - Atmospheric refraction methods\nOhMyThreads.jl Documentation - Task-based parallelism framework\nJulia Threading Documentation - Julia's threading capabilities","category":"section"},{"location":"guides/modelingtoolkit/#Building-models-with-ModelingToolkit.jl","page":"Building models with ModelingToolkit.jl","title":"Building models with ModelingToolkit.jl","text":"SolarPosition.jl provides a ModelingToolkit.jl extension that enables integration of solar position calculations into symbolic modeling workflows. This allows you to compose solar position components with other physical systems for applications like solar energy modeling, building thermal analysis, and solar tracking systems.","category":"section"},{"location":"guides/modelingtoolkit/#Installation","page":"Building models with ModelingToolkit.jl","title":"Installation","text":"The ModelingToolkit extension is loaded automatically when both SolarPosition.jl and ModelingToolkit.jl are loaded:\n\nusing SolarPosition\nusing ModelingToolkit","category":"section"},{"location":"guides/modelingtoolkit/#Quick-Start","page":"Building models with ModelingToolkit.jl","title":"Quick Start","text":"The extension provides the SolarPositionBlock component, which outputs solar azimuth, elevation, and zenith angles as time-varying quantities.\n\nusing SolarPosition\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t\nusing Dates\nusing OrdinaryDiffEq\n\n# Create a solar position block\n@named sun = SolarPositionBlock()\n\n# Define observer location and reference time\nobs = Observer(51.50274937708521, -0.17782150375214803, 15.0)  # Natural History Museum\nt0 = DateTime(2024, 6, 21, 12, 0, 0)  # Summer solstice noon\n\n# Compile the system\nsys = mtkcompile(sun)\n\n# Set parameters using the compiled system's parameter references\npmap = [\n    sys.observer => obs,\n    sys.t0 => t0,\n    sys.algorithm => PSA(),\n    sys.refraction => NoRefraction(),\n]\n\n# Solve over 24 hours (time in seconds)\ntspan = (0.0, 86400.0)\nprob = ODEProblem(sys, pmap, tspan)\nsol = solve(prob; saveat = 3600.0)  # Save every hour\n\n# Show some results\nprintln(\"Solar position at noon (t=12 hours):\")\nprintln(\"  Azimuth: \", round(sol[sys.azimuth][1], digits=2), \"°\")\nprintln(\"  Elevation: \", round(sol[sys.elevation][1], digits=2), \"°\")\nprintln(\"  Zenith: \", round(sol[sys.zenith][1], digits=2), \"°\")","category":"section"},{"location":"guides/modelingtoolkit/#SolarPositionBlock","page":"Building models with ModelingToolkit.jl","title":"SolarPositionBlock","text":"The SolarPositionBlock is a ModelingToolkit.jl component that computes solar position angles based on time, observer location, and chosen positioning and refraction algorithms.","category":"section"},{"location":"guides/modelingtoolkit/#Composing-with-Other-Systems","page":"Building models with ModelingToolkit.jl","title":"Composing with Other Systems","text":"The real power of the ModelingToolkit extension comes from composing solar position with other physical systems.","category":"section"},{"location":"guides/modelingtoolkit/#Example:-Solar-Panel-Power-Model","page":"Building models with ModelingToolkit.jl","title":"Example: Solar Panel Power Model","text":"using CairoMakie: Figure, Axis, lines!\n\n# Create solar position block\n@named sun = SolarPositionBlock()\n\n# Create a simple solar panel model\n@parameters begin\n    area = 10.0           # Panel area (m²)\n    efficiency = 0.2      # Panel efficiency (20%)\n    dni_peak = 1000.0     # Peak direct normal irradiance (W/m²)\nend\n\n@variables begin\n    irradiance(t) = 0.0   # Effective irradiance on panel (W/m²)\n    power(t) = 0.0        # Power output (W)\nend\n\n# Simplified model: irradiance depends on sun elevation\n# In reality, you'd account for panel orientation, azimuth, etc.\neqs = [\n    irradiance ~ dni_peak * max(0, sind(sun.elevation)),\n    power ~ area * efficiency * irradiance,\n]\n\n# Compose the complete system\n@named model = System(eqs, t; systems = [sun])\nsys_model = mtkcompile(model)\n\n# Set up and solve\nobs = Observer(37.7749, -122.4194, 100.0)\nt0 = DateTime(2024, 6, 21, 0, 0, 0)\n\npmap = [\n    sys_model.sun.observer => obs,\n    sys_model.sun.t0 => t0,\n    sys_model.sun.algorithm => PSA(),\n    sys_model.sun.refraction => NoRefraction(),\n]\n\nprob = ODEProblem(sys_model, pmap, (0.0, 86400.0))\nsol = solve(prob; saveat = 600.0)  # Save every 10 minutes\n\n# Plot results\nfig = Figure(size = (1000, 400))\n\nax1 = Axis(fig[1, 1]; xlabel = \"Time (hours)\", ylabel = \"Elevation (°)\", title = \"Solar Elevation\")\nlines!(ax1, sol.t ./ 3600, sol[sys_model.sun.elevation])\n\nax2 = Axis(fig[1, 2]; xlabel = \"Time (hours)\", ylabel = \"Power (W)\", title = \"Solar Panel Power\")\nlines!(ax2, sol.t ./ 3600, sol[sys_model.power])\n\nfig","category":"section"},{"location":"guides/modelingtoolkit/#Example:-Building-Thermal-Model-with-Solar-Gain","page":"Building models with ModelingToolkit.jl","title":"Example: Building Thermal Model with Solar Gain","text":"using CairoMakie: Figure, Axis, lines!\nusing ModelingToolkit: D_nounits as D\n\n# Solar position component\n@named sun = SolarPositionBlock()\n\n# Building thermal model with solar gain\n@parameters begin\n    mass = 1000.0         # Thermal mass (kg)\n    cp = 1000.0           # Specific heat capacity (J/(kg·K))\n    U = 0.5               # Overall heat transfer coefficient (W/(m²·K))\n    wall_area = 50.0      # Wall area (m²)\n    window_area = 5.0     # Window area (m²)\n    window_trans = 0.7    # Window transmittance\n    T_outside = 20.0      # Outside temperature (°C)\n    dni_peak = 800.0      # Peak solar irradiance (W/m²)\nend\n\n@variables begin\n    T(t) = 20.0           # Room temperature (°C)\n    Q_loss(t)             # Heat loss through walls (W)\n    Q_solar(t)            # Solar heat gain (W)\n    irradiance(t)         # Solar irradiance (W/m²)\nend\n\neqs = [\n    # Solar irradiance based on sun elevation\n    irradiance ~ dni_peak * max(0, sind(sun.elevation)),\n    # Solar heat gain through windows\n    Q_solar ~ window_area * window_trans * irradiance,\n    # Heat loss through walls\n    Q_loss ~ U * wall_area * (T - T_outside),\n    # Energy balance\n    D(T) ~ (Q_solar - Q_loss) / (mass * cp),\n]\n\n@named building = System(eqs, t; systems = [sun])\nsys_building = mtkcompile(building)\n\n# Simulate\nobs = Observer(40.7128, -74.0060, 100.0)  # New York City\nt0 = DateTime(2024, 6, 21, 0, 0, 0)\n\npmap = [\n    sys_building.sun.observer => obs,\n    sys_building.sun.t0 => t0,\n    sys_building.sun.algorithm => PSA(),\n    sys_building.sun.refraction => NoRefraction(),\n]\n\nprob = ODEProblem(sys_building, pmap, (0.0, 86400.0))\nsol = solve(prob; saveat = 600.0)\n\n# Plot temperature evolution\nfig = Figure(size = (1200, 400))\n\nax1 = Axis(fig[1, 1]; xlabel = \"Time (hours)\", ylabel = \"Temperature (°C)\", title = \"Room Temperature\")\nlines!(ax1, sol.t ./ 3600, sol[sys_building.T])\n\nax2 = Axis(fig[1, 2]; xlabel = \"Time (hours)\", ylabel = \"Solar Gain (W)\", title = \"Solar Heat Gain\")\nlines!(ax2, sol.t ./ 3600, sol[sys_building.Q_solar])\n\nax3 = Axis(fig[1, 3]; xlabel = \"Time (hours)\", ylabel = \"Elevation (°)\", title = \"Sun Elevation\")\nlines!(ax3, sol.t ./ 3600, sol[sys_building.sun.elevation])\n\nfig","category":"section"},{"location":"guides/modelingtoolkit/#Implementation-Details","page":"Building models with ModelingToolkit.jl","title":"Implementation Details","text":"The extension works by registering the solar_position function and helper functions as symbolic operations in ModelingToolkit. The actual solar position calculation happens during ODE solving, with the simulation time t being converted to a DateTime relative to the reference time t0.","category":"section"},{"location":"guides/modelingtoolkit/#Limitations","page":"Building models with ModelingToolkit.jl","title":"Limitations","text":"The solar position calculation is treated as a black-box function by MTK's symbolic engine, so its internals cannot be symbolically simplified.","category":"section"},{"location":"guides/modelingtoolkit/#See-Also","page":"Building models with ModelingToolkit.jl","title":"See Also","text":"Solar Positioning - Available positioning algorithms\nRefraction Correction - Atmospheric refraction methods\nModelingToolkit.jl Documentation - MTK framework documentation","category":"section"},{"location":"guides/modelingtoolkit/#SolarPosition.SolarPositionBlock","page":"Building models with ModelingToolkit.jl","title":"SolarPosition.SolarPositionBlock","text":"Return a ModelingToolkit.jl component that computes solar position as a function of time and can be integrated into symbolic modeling workflows.\n\nThe SolarPositionBlock is a System which exposes azimuth, elevation, and zenith as output variables computed from the simulation time t (in seconds) relative to a reference time t0.\n\nnote: Note\nThis function requires ModelingToolkit.jl to be loaded. The extension is automatically loaded when both SolarPosition.jl and ModelingToolkit.jl are available.\n\nParameters\n\nobserver::Observer: location (latitude, longitude, altitude). See Observer\nt0::DateTime: Reference time (time when simulation time t = 0)\nalgorithm::SolarAlgorithm: Solar positioning algorithm (default: PSA)\nrefraction::RefractionAlgorithm: Atmospheric refraction correction (default: NoRefraction)\n\nVariables (Outputs)\n\nazimuth(t): Solar azimuth angle in degrees (0° = North, 90° = East, 180° = South, 270° = West)\nelevation(t): Solar elevation angle in degrees (angle above horizon, positive when sun is visible)\nzenith(t): Solar zenith angle in degrees (angle from vertical, complementary to elevation: zenith = 90° - elevation)\n\nTime Convention\n\nThe simulation time t (accessed via t_nounits) is in seconds from the reference time t0. For example:\n\nt = 0 corresponds to t0\nt = 3600 corresponds to t0 + 1 hour\nt = 86400 corresponds to t0 + 24 hours\n\nExample\n\nusing SolarPosition, ModelingToolkit\nusing ModelingToolkit: t_nounits as t, @named, mtkcompile\nusing Dates\nusing OrdinaryDiffEq: ODEProblem, solve\n\n@named sun = SolarPositionBlock()\nobs = Observer(51.5, -0.18, 15.0)\nt0 = DateTime(2024, 6, 21, 12, 0, 0)\n\nsys = mtkcompile(sun)\npmap = [\n    sys.observer => obs,\n    sys.t0 => t0,\n    sys.algorithm => PSA(),\n    sys.refraction => NoRefraction(),\n]\n\nprob = ODEProblem(sys, pmap, (0.0, 86400.0))\nsol = solve(prob; saveat = 3600.0)\n\n\n\n\n\n","category":"function"},{"location":"guides/new-algorithm/#new-algorithm","page":"Adding a New Solar Position Algorithm","title":"Adding a New Solar Position Algorithm","text":"This tutorial walks you through the process of adding a new solar positioning algorithm to SolarPosition.jl. We'll implement a simplified algorithm step by step, covering all the necessary components: the algorithm struct, core computation, refraction handling, exports, and tests.","category":"section"},{"location":"guides/new-algorithm/#Overview","page":"Adding a New Solar Position Algorithm","title":"Overview","text":"Adding a new algorithm involves these steps:\n\nCreate the algorithm struct - Define a type that subtypes SolarAlgorithm.\nImplement the core function - Write _solar_position for your algorithm.\nHandle refraction - Define how your algorithm interacts with DefaultRefraction.\nExport the algorithm - Make it available to users.\nWrite tests - Validate correctness against reference values.\nDocument - Add docstrings and update documentation.\nRun pre-commit checks - Ensure code quality and formatting.\n\ninfo: Underscore\nNote the underscore prefix in _solar_position. This function is internal and should not be called directly by users. Instead, they will use the public solar_position function, which dispatches to your implementation based on the algorithm type struct.","category":"section"},{"location":"guides/new-algorithm/#step-1-create-struct","page":"Adding a New Solar Position Algorithm","title":"Step 1: Create the Algorithm Struct","text":"Create a new file in src/Positioning/ for your algorithm. For this example, we'll create a simplified algorithm called SimpleAlgorithm.\n\nThe struct must:\n\nSubtype SolarAlgorithm\nInclude a docstring with TYPEDEF and TYPEDFIELDS macros\nDocument accuracy and provide literature references\n\n# src/Positioning/simple.jl\n\n\"\"\"\n    \\$(TYPEDEF)\n\nSimple solar position algorithm for demonstration purposes.\n\nThis algorithm uses basic spherical trigonometry to compute solar positions.\nIt is provided as a teaching example and is NOT suitable for production use.\n\n# Accuracy\nThis is a simplified algorithm with limited accuracy (±1°).\n\n# Literature\nBased on basic solar geometry principles.\n\n# Fields\n\\$(TYPEDFIELDS)\n\"\"\"\nstruct SimpleAlgorithm <: SolarAlgorithm\n    \"Optional configuration parameter\"\n    param::Float64\nend\n\n# Provide a default constructor\nSimpleAlgorithm() = SimpleAlgorithm(1.0)","category":"section"},{"location":"guides/new-algorithm/#step-2-implement-core","page":"Adding a New Solar Position Algorithm","title":"Step 2: Implement the Core Function","text":"The core of any algorithm is the _solar_position function. This function:\n\nTakes an Observer, DateTime, and your algorithm type\nReturns a SolPos{T} with azimuth, elevation, and zenith angles\nShould be type-stable and performant\n\nHere's the basic structure:\n\nfunction _solar_position(obs::Observer{T}, dt::DateTime, alg::SimpleAlgorithm) where {T}\n    # 1. Convert datetime to Julian date\n    jd = datetime2julian(dt)\n\n    # 2. Calculate days since J2000.0 epoch\n    n = jd - 2451545.0\n\n    # 3. Compute solar coordinates (declination, hour angle, etc.)\n    # ... your algorithm's calculations here ...\n\n    # 4. Calculate local horizontal coordinates\n    # ... azimuth and elevation calculations ...\n\n    # 5. Return the result\n    return SolPos{T}(azimuth_deg, elevation_deg, zenith_deg)\nend","category":"section"},{"location":"guides/new-algorithm/#Key-Implementation-Notes","page":"Adding a New Solar Position Algorithm","title":"Key Implementation Notes","text":"Use helper functions from utils.jl:\nfractional_hour(dt) - Convert time to decimal hours\ndeg2rad(x) / rad2deg(x) - Angle conversions\nObserver properties are pre-computed for efficiency:\nobs.latitude, obs.longitude, obs.altitude - Input values\nobs.latitude_rad, obs.longitude_rad - Radians versions\nobs.sin_lat, obs.cos_lat - Precomputed trigonometric values\nType parameter T ensures numerical precision is preserved from the Observer\nAngle conventions:\nAzimuth: 0° = North, positive clockwise, range [0°, 360°]\nElevation: angle above horizon, range [-90°, 90°]\nZenith: 90° - elevation, range [0°, 180°]","category":"section"},{"location":"guides/new-algorithm/#step-3-handle-refraction","page":"Adding a New Solar Position Algorithm","title":"Step 3: Handle Default Refraction","text":"Each algorithm must specify how it handles DefaultRefraction. There are two common patterns:","category":"section"},{"location":"guides/new-algorithm/#Pattern-A:-No-Refraction-by-Default-(like-[PSA](@ref-SolarPosition.Positioning.PSA))","page":"Adding a New Solar Position Algorithm","title":"Pattern A: No Refraction by Default (like PSA)","text":"If your algorithm should NOT apply refraction by default:\n\nfunction _solar_position(obs, dt, alg::SimpleAlgorithm, ::DefaultRefraction)\n    return _solar_position(obs, dt, alg, NoRefraction())\nend\n\n# Return type for DefaultRefraction\nresult_type(::Type{SimpleAlgorithm}, ::Type{DefaultRefraction}, ::Type{T}) where {T} =\n    SolPos{T}","category":"section"},{"location":"guides/new-algorithm/#Pattern-B:-Apply-Refraction-by-Default-(like-[NOAA](@ref-SolarPosition.Positioning.NOAA))","page":"Adding a New Solar Position Algorithm","title":"Pattern B: Apply Refraction by Default (like NOAA)","text":"If your algorithm should apply a specific refraction model by default:\n\nusing ..Refraction: HUGHES, DefaultRefraction\n\nfunction _solar_position(obs, dt, alg::SimpleAlgorithm, ::DefaultRefraction)\n    return _solar_position(obs, dt, alg, HUGHES())\nend\n\n# Return type for DefaultRefraction\nresult_type(::Type{SimpleAlgorithm}, ::Type{DefaultRefraction}, ::Type{T}) where {T} =\n    ApparentSolPos{T}\n\nThe result_type function tells the system what return type to expect, enabling type-stable code for vectorized operations.","category":"section"},{"location":"guides/new-algorithm/#step-4-export","page":"Adding a New Solar Position Algorithm","title":"Step 4: Export the Algorithm","text":"After implementing your algorithm, you need to export it so users can access it.","category":"section"},{"location":"guides/new-algorithm/#4.1-Include-in-Positioning-Module","page":"Adding a New Solar Position Algorithm","title":"4.1 Include in Positioning Module","text":"Edit src/Positioning/Positioning.jl to include your new file:\n\n# Near the bottom of the file, with other includes\ninclude(\"utils.jl\")\ninclude(\"deltat.jl\")\ninclude(\"psa.jl\")\ninclude(\"noaa.jl\")\ninclude(\"walraven.jl\")\ninclude(\"usno.jl\")\ninclude(\"spa.jl\")\ninclude(\"simple.jl\")  # Add your new file\n\n# Add to the export list\nexport Observer,\n    PSA,\n    NOAA,\n    Walraven,\n    USNO,\n    SPA,\n    SimpleAlgorithm,  # Add your algorithm\n    solar_position,\n    solar_position!,\n    SolPos,\n    ApparentSolPos,\n    SPASolPos","category":"section"},{"location":"guides/new-algorithm/#4.2-Export-from-Main-Module","page":"Adding a New Solar Position Algorithm","title":"4.2 Export from Main Module","text":"Edit src/SolarPosition.jl to re-export your algorithm:\n\nusing .Positioning:\n    Observer, PSA, NOAA, Walraven, USNO, SPA, SimpleAlgorithm, solar_position, solar_position!\n\n# ... later in exports ...\nexport PSA, NOAA, Walraven, USNO, SPA, SimpleAlgorithm","category":"section"},{"location":"guides/new-algorithm/#step-5-write-tests","page":"Adding a New Solar Position Algorithm","title":"Step 5: Write Tests","text":"Create a test file following the naming convention test/test-simple.jl.\n\nwarning: Generating Validation Data\nIt is required to validate your algorithm against known reference values. You can use a reference implementation of your algorithm (if available) or compare against trusted solar position calculators. Store these reference values in your test file and use @test statements to ensure your implementation matches them. See the existing test files like test/test-psa.jl for examples of how to structure these tests.","category":"section"},{"location":"guides/new-algorithm/#Running-Tests","page":"Adding a New Solar Position Algorithm","title":"Running Tests","text":"Tests are automatically discovered by runtests.jl. Run them with:\n\njulia --project=. -e 'using Pkg; Pkg.test()'\n\nOr from the Julia REPL:\n\nusing Pkg\nPkg.activate(\".\")\nPkg.test()","category":"section"},{"location":"guides/new-algorithm/#step-6-document","page":"Adding a New Solar Position Algorithm","title":"Step 6: Document Your Algorithm","text":"","category":"section"},{"location":"guides/new-algorithm/#Add-to-Documentation-Pages","page":"Adding a New Solar Position Algorithm","title":"Add to Documentation Pages","text":"Update docs/src/positioning.md to include your algorithm in the algorithm reference section.","category":"section"},{"location":"guides/new-algorithm/#Add-Literature-References","page":"Adding a New Solar Position Algorithm","title":"Add Literature References","text":"If your algorithm is based on published work, add the reference to docs/src/refs.bib:\n\n@article{YourReference,\n    author = {Author Name},\n    title = {Algorithm Title},\n    journal = {Journal Name},\n    year = {2024},\n    volume = {1},\n    pages = {1-10}\n}\n\nThen cite it in your docstring using [YourReference](@cite).","category":"section"},{"location":"guides/new-algorithm/#step-7-precommit","page":"Adding a New Solar Position Algorithm","title":"Step 7: Run Pre-commit Checks (Recommended)","text":"Before submitting a pull request, it's recommended to run pre-commit hooks locally to catch formatting and linting issues early. This saves time during code review and ensures your code meets the project's quality standards. The pre-commit configuration is defined in the .pre-commit-config.yaml file at the root of the repository.\n\ninfo: CI Runs Pre-commit\nEven if you skip this step locally, GitHub CI will automatically run pre-commit checks on your pull request. However, running them locally first helps you catch and fix issues before pushing.","category":"section"},{"location":"guides/new-algorithm/#Installing-Pre-commit","page":"Adding a New Solar Position Algorithm","title":"Installing Pre-commit","text":"# Install pre-commit (requires Python)\npip install pre-commit\n\n# Install the git hooks (run once per clone)\npre-commit install","category":"section"},{"location":"guides/new-algorithm/#Running-Pre-commit","page":"Adding a New Solar Position Algorithm","title":"Running Pre-commit","text":"# Run all hooks on all files\npre-commit run --all-files\n\n# Or run on staged files only\npre-commit run\n\nPre-commit runs several checks including:\n\nJuliaFormatter - Ensures consistent code formatting\nExplicitImports - Checks for explicit imports\nmarkdownlint - Lints markdown files\ntypos - Catches common spelling mistakes\n\nIf any checks fail, fix the issues and run pre-commit again until all checks pass.","category":"section"},{"location":"guides/new-algorithm/#Checklist","page":"Adding a New Solar Position Algorithm","title":"Checklist","text":"Before submitting your algorithm for review, ensure you've completed the following:\n\nTask Description\nAlgorithm struct Subtypes SolarAlgorithm\nDocstring Includes TYPEDEF, TYPEDFIELDS, accuracy, and references\n_solar_position Function implemented with correct signature\nDefault refraction Handling defined for DefaultRefraction\nresult_type Function defined for DefaultRefraction\nExport Algorithm exported from both modules\nTests Cover basic functionality, refraction, vectors, and edge cases\nTest coverage Ensure tests cover all new code paths\nPre-commit Checks pass (recommended locally, required in CI)\nDocumentation Update algorithm lists in positioning.md, README.md, and refraction.md\nLiterature References added to refs.bib and cited in docstrings","category":"section"},{"location":"guides/new-algorithm/#Additional-Resources","page":"Adding a New Solar Position Algorithm","title":"Additional Resources","text":"See existing implementations in src/Positioning/ for reference:\npsa.jl - Simple algorithm with no default refraction (PSA)\nnoaa.jl - Algorithm with default HUGHES refraction (NOAA)\nspa.jl - Complex algorithm with additional output fields (SPA)\nCheck the Contributing Guidelines for general contribution workflow\nReview the Solar Positioning Algorithms page for context","category":"section"},{"location":"refraction/#refraction-correction","page":"Refraction Correction","title":"Refraction Correction","text":"Atmospheric refraction causes the apparent position of the sun to differ from its true geometric position. This effect is most pronounced near the horizon and can be corrected using various atmospheric models.\n\nThe correction formula for elevation is:\n\ne_apparent = e_true + R\n\nWhere:\n\ne_apparent is the apparent solar elevation angle (degrees)\ne_true is the true solar elevation angle (degrees)\nR is the refraction correction (degrees), calculated based on the chosen refraction model\n\n(Image: Refraction correction comparison) Figure 1: Atmospheric refraction causes the sun to appear higher in the sky than its true position, especially near the horizon. Image source: Wikimedia Commons.\n\nSolarPosition.jl includes several refraction correction algorithms. Below is a summary of the available algorithms:\n\nAlgorithm Reference Atmospheric Parameters Status\nHUGHES [Hug85] Pressure, Temperature ✅\nARCHER [ABO80] None ✅\nBENNETT [Ben82] Pressure, Temperature ✅\nMICHALSKY [Mic88] None ✅\nSG2 [BW12] Pressure, Temperature ✅\nSPARefraction [RA04] Pressure, Temperature ✅\n\nTo calculate refraction, we can use the refraction function:\n\nThis function is typically used internally by the solar_position function when a refraction algorithm is specified, but is also a publicly available method.\n\ninfo: Info\nWhen using a refraction algorithm like HUGHES, the solar_position function returns an ApparentSolPos struct containing both true and apparent angles.\n\ninfo: Info\nWhen using NoRefraction (the default), the solar_position function returns a SolPos struct containing only the true geometric angles (azimuth, elevation, zenith). In this case, no refraction correction is applied.","category":"section"},{"location":"refraction/#Default-refraction-model","page":"Refraction Correction","title":"Default refraction model","text":"The DefaultRefraction type is a special marker that indicates to use the default refraction behavior for the selected solar position algorithm. For most algorithms, this means no refraction correction (i.e., equivalent to NoRefraction).","category":"section"},{"location":"refraction/#Comparison-of-Refraction-Models","page":"Refraction Correction","title":"Comparison of Refraction Models","text":"Several different refraction models have been proposed in the literature. SolarPosition.jl only implements a subset of them but PRs are always welcome! To compare the different refraction models, the refraction angle is calculated in the range -1 to 90 degree solar elevation in steps of 0.1 degrees.\n\nusing SolarPosition\nusing CairoMakie\n\n# Define models and elevation range\nmodels = [(\"Archer\", SolarPosition.Refraction.ARCHER()), (\"Bennett\", SolarPosition.Refraction.BENNETT()),\n          (\"Hughes\", SolarPosition.Refraction.HUGHES()), (\"Michalsky\", SolarPosition.Refraction.MICHALSKY()),\n          (\"SG2\", SolarPosition.Refraction.SG2()), (\"SPA\", SolarPosition.Refraction.SPARefraction())]\nelevation = -1.5:0.1:90.0\n\n# Create figure with two subplots\nfig = Figure(size = (800, 400), backgroundcolor = :transparent, textcolor = \"#f5ab35\")\nax1 = Axis(fig[1, 1], xlabel = \"True elevation [degrees]\",\n    ylabel = \"Refraction correction [degrees]\", title = \"Near Horizon\",\n    backgroundcolor = :transparent, xticks = -1:1:4)\nax2 = Axis(fig[1, 2], xlabel = \"True elevation [degrees]\",\n    ylabel = \"Refraction correction [degrees]\", title = \"Full Range (Log Scale)\", yscale = log10, backgroundcolor = :transparent)\n\n# Plot refraction for each model\nfor (name, model) in models\n    ref = [SolarPosition.Refraction.refraction(model, e) for e in elevation]\n    lines!(ax1, elevation, ref, label = name)\n    mask = ref .> 0\n    lines!(ax2, elevation[mask], ref[mask])\nend\n\nxlims!(ax1, -1.5, 4); ylims!(ax1, 0, 1.0)\nxlims!(ax2, -1.5, 90); ylims!(ax2, 1e-3, 1.0)\n\nLegend(fig[0, :], ax1, orientation = :horizontal, framevisible = false,\n    tellwidth = false, tellheight = true, nbanks = 1)\nfig\n\nA comparison of the refraction models is visualized above. The plot on the left shows refraction for solar elevation angles near sunrise/sunset, where refraction is most significant. The plot on the right shows the refraction angles for the entire range of solar elevation angles. Note that for the right plot, the y-axis is a log scale, which emphasizes the difference between the models.","category":"section"},{"location":"refraction/#hughes-refraction","page":"Refraction Correction","title":"Hughes","text":"The Hughes refraction model accounts for atmospheric pressure and temperature effects.\n\nThis model was developed by [Hug85] and is used in the SUNAEP software [Zim81]. It's also the basis for the refraction correction in NOAA's solar position calculator (using fixed pressure of 101325 Pa and temperature of 10°C).","category":"section"},{"location":"refraction/#archer-refraction","page":"Refraction Correction","title":"Archer","text":"The Archer refraction model is a cosine-based correction that does not require atmospheric parameters.\n\nThis simplified model from [ABO80] computes refraction based on the zenith angle using trigonometric relationships. It's useful when atmospheric data is not available.","category":"section"},{"location":"refraction/#bennett-refraction","page":"Refraction Correction","title":"Bennett","text":"The Bennett refraction model is widely used in marine navigation and accounts for atmospheric conditions.\n\nDeveloped by [Ben82], this model provides accurate refraction corrections with adjustments for atmospheric pressure and temperature. It's particularly effective for low elevation angles.","category":"section"},{"location":"refraction/#michalsky-refraction","page":"Refraction Correction","title":"Michalsky","text":"The Michalsky refraction model uses a rational polynomial approximation.\n\nFrom [Mic88], this algorithm is part of the Astronomical Almanac's method for approximate solar position calculations. It includes special handling for very low elevation angles.","category":"section"},{"location":"refraction/#sg2-refraction","page":"Refraction Correction","title":"SG2","text":"The SG2 (Second Generation) refraction algorithm is optimized for fast computation over multi-decadal periods.\n\nDeveloped by [BW12], this algorithm uses a two-regime approach with different formulas for elevations above and below a threshold. It accounts for atmospheric pressure and temperature.","category":"section"},{"location":"refraction/#spa-refraction","page":"Refraction Correction","title":"SPARefraction","text":"The SPARefraction (Solar Position Algorithm) refraction model is part of NREL's high-accuracy solar position algorithm.\n\nFrom [RA04], this is the refraction correction used in NREL's SPA algorithm, which is accurate to ±0.0003° over the years -2000 to 6000. It includes a configurable refraction limit for below-horizon calculations.","category":"section"},{"location":"refraction/#SolarPosition.Refraction.refraction","page":"Refraction Correction","title":"SolarPosition.Refraction.refraction","text":"refraction(model::RefractionAlgorithm, elevation::T) where {T<:AbstractFloat}\n\nApply atmospheric refraction correction to the given elevation angle(s).\n\nArguments\n\nmodel::RefractionAlgorithm: Refraction model to use (e.g., HUGHES())\nelevation::T: True (unrefracted) solar elevation angle in degrees\n\nReturns\n\nRefraction correction in degrees to be added to the elevation angle\n\nExamples\n\nusing SolarPosition\nhughes = HUGHES(101325.0, 15.0)  # 15°C temperature\nelevation = 30.0  # 30 degrees\ncorrection = refraction(hughes, elevation)\napparent_elevation = elevation + correction\n\n\n\n\n\n","category":"function"},{"location":"refraction/#SolarPosition.Refraction.NoRefraction","page":"Refraction Correction","title":"SolarPosition.Refraction.NoRefraction","text":"struct NoRefraction <: RefractionAlgorithm\n\nIndicates that no atmospheric refraction correction should be applied.\n\nThis is the default refraction setting for solar position calculations. When used, only basic solar position (azimuth, elevation, zenith) is computed.\n\n\n\n\n\n","category":"type"},{"location":"refraction/#SolarPosition.Refraction.DefaultRefraction","page":"Refraction Correction","title":"SolarPosition.Refraction.DefaultRefraction","text":"struct DefaultRefraction <: RefractionAlgorithm\n\nDefault refraction model used when no specific model is provided.\n\nThis will depend on the solar position algorithm being used.\n\n\n\n\n\n","category":"type"},{"location":"refraction/#SolarPosition.Refraction.HUGHES","page":"Refraction Correction","title":"SolarPosition.Refraction.HUGHES","text":"struct HUGHES{T} <: RefractionAlgorithm\n\nHughes refraction model.\n\nThis function was developed by G. Hughes [1] and was used in the SUNAEP software [2].\n\nIt is also used to calculate the refraction correction in the NOAA solar position algorithm using a fixed pressure of 101325 Pa and a temperature of 10 degrees Celsius.\n\nFields\n\npressure::Any: Annual average atmospheric pressure [Pascal]\ntemperature::Any: Annual average temperature [°C]\n\nConstructor\n\nHUGHES(): Uses default parameters: pressure = 101325 Pa, temperature = 12 °C\nHUGHES(pressure, temperature): Specify custom pressure [Pa] and temperature [°C]\n\nNotes\n\nThe equation to calculate the refraction correction is given by:\n\nFor 5° < elevation ≤ 90°:\n\nfrac581tan(el) - frac007tan(el)^3 + frac86 times 10^-5tan(el)^5\n\nFor -0.575° < elevation ≤ 5°:\n\nel cdot (-5182 + el cdot (1034 + el cdot (-1279 + el cdot 0711))) + 1735\n\nFor elevation ≤ -0.575°:\n\nfrac-20774tan(el)\n\nwhere el is the true (unrefracted) solar elevation angle.\n\nThe result is then corrected for temperature and pressure:\n\ntextRefract times frac283273 + T times fracP101325 times frac13600\n\nLiterature\n\nThis function was developed by [Hug85] and was used in the SUNAEP software [Zim81]. It is also used to calculate the refraction correction in the NOAA solar position algorithm using a fixed pressure of 101325 Pa and a temperature of 10 degrees Celsius.\n\nExample\n\nusing SolarPosition\n\n# Create Hughes refraction model with default parameters\nhughes = HUGHES()\n\n# Or specify custom atmospheric conditions\nhughes_custom = HUGHES(101325.0, 25.0)  # 25°C temperature\n\n# Apply refraction correction to elevation angle\nelevation = 30.0  # degrees\nrefraction_correction = refraction(hughes, elevation)\napparent_elevation = elevation + refraction_correction\n\n\n\n\n\n","category":"type"},{"location":"refraction/#SolarPosition.Refraction.ARCHER","page":"Refraction Correction","title":"SolarPosition.Refraction.ARCHER","text":"struct ARCHER <: RefractionAlgorithm\n\nArcher refraction model.\n\nAtmospheric refraction correction based on the Archer algorithm.\n\nThis function calculates the atmospheric refraction correction of the solar elevation angle using the method described by Archer [1]. The method was originally developed to be used with the Walraven solar position algorithm [2].\n\nFields\n\nConstructor\n\nARCHER(): Creates an Archer refraction model instance\n\nNotes\n\nThe equation to calculate the refraction correction is given by:\n\nbeginaligned\nC = cos(Z) + 00083 cdot left(frac10955 + (20267 cdot cos(Z)) - 0047121 right)\nZ_a = arccos(C)\ntextrefraction = Z - Z_a\nendaligned\n\nwhere Z is the true solar zenith angle and Z_a is the apparent zenith angle.\n\nLiterature\n\nThis method was described by [ABO80] and was originally developed to be used with the Walraven solar position algorithm [Wal78].\n\nExample\n\nusing SolarPosition\n\n# Create Archer refraction model\narcher = ARCHER()\n\n# Apply refraction correction to elevation angle\nelevation = 30.0  # degrees\nrefraction_correction = refraction(archer, elevation)\napparent_elevation = elevation + refraction_correction\n\n\n\n\n\n","category":"type"},{"location":"refraction/#SolarPosition.Refraction.BENNETT","page":"Refraction Correction","title":"SolarPosition.Refraction.BENNETT","text":"struct BENNETT{T} <: RefractionAlgorithm\n\nBennett refraction model.\n\nAtmospheric refraction correction based on the Bennett algorithm.\n\nCalculation of atmospheric refraction correction of the solar elevation angle using the method developed by Bennett [1].\n\nFields\n\npressure::Any: Annual average atmospheric pressure [Pascal]\ntemperature::Any: Annual average temperature [°C]\n\nConstructor\n\nBENNETT(): Uses default parameters: pressure = 101325 Pa, temperature = 12 °C\nBENNETT(pressure, temperature): Specify custom pressure [Pa] and temperature [°C]\n\nNotes\n\nThe equation to calculate the refraction correction is given by:\n\ntextref = frac028 cdot PT+273 cdot frac0016667tan(el + 731  (el+44))\n\nwhere P is the local air pressure in hPa, T is the local air temperature in °C, and el is the true (uncorrected) solar elevation angle.\n\nLiterature\n\nThis method was described by [Ben82].\n\nExample\n\nusing SolarPosition\n\n# Create Bennett refraction model with default parameters\nbennett = BENNETT()\n\n# Or specify custom atmospheric conditions\nbennett_custom = BENNETT(101325.0, 25.0)  # 25°C temperature\n\n# Apply refraction correction to elevation angle\nelevation = 30.0  # degrees\nrefraction_correction = refraction(bennett, elevation)\napparent_elevation = elevation + refraction_correction\n\n\n\n\n\n","category":"type"},{"location":"refraction/#SolarPosition.Refraction.MICHALSKY","page":"Refraction Correction","title":"SolarPosition.Refraction.MICHALSKY","text":"struct MICHALSKY <: RefractionAlgorithm\n\nMichalsky refraction model.\n\nAtmospheric refraction correction based on the Michalsky algorithm.\n\nThis function calculates the atmospheric refraction correction of the solar elevation angle using the method described by Michalsky [1].\n\nFields\n\nConstructor\n\nMICHALSKY(): Creates a Michalsky refraction model instance\n\nNotes\n\nThe equation to calculate the refraction correction is given by:\n\ntextref = frac351561 cdot (01594 + 00196 cdot el + 000002 cdot el^2)1 + 0505 cdot el + 00845 cdot el^2\n\nwhere el is the true (uncorrected) solar elevation angle.\n\nNote that 3.51561 = 1013.2 mb / 288.2 °C.\n\nFor elevation angles below -0.56°, the refraction correction is clamped to 0.56°.\n\nLiterature\n\nThis method was described by [Mic88].\n\nExample\n\nusing SolarPosition\n\n# Create Michalsky refraction model\nmichalsky = MICHALSKY()\n\n# Apply refraction correction to elevation angle\nelevation = 30.0  # degrees\nrefraction_correction = refraction(michalsky, elevation)\napparent_elevation = elevation + refraction_correction\n\n\n\n\n\n","category":"type"},{"location":"refraction/#SolarPosition.Refraction.SG2","page":"Refraction Correction","title":"SolarPosition.Refraction.SG2","text":"struct SG2{T} <: RefractionAlgorithm\n\nSG2 refraction model.\n\nAtmospheric refraction correction based on the algorithm in SG2.\n\nThis function calculates the atmospheric refraction correction of the solar elevation angle using the method developed by Ph. Blanc and L. Wald [1].\n\nFields\n\npressure::Any: Annual average atmospheric pressure [Pascal]\ntemperature::Any: Annual average temperature [°C]\n\nConstructor\n\nSG2(): Uses default parameters: pressure = 101325 Pa, temperature = 12 °C\nSG2(pressure, temperature): Specify custom pressure [Pa] and temperature [°C]\n\nNotes\n\nThe equation to calculate the refraction correction is given by:\n\nFor el  -001 radians:\n\nfracP1010 cdot frac283273+T cdot frac296706 times 10^-4tan(el+00031376 cdot (el+0089186)^-1)\n\nFor el leq -001 radians:\n\n-fracP1010 cdot frac283273+T cdot frac1005516 times 10^-4tan(el)\n\nwhere el is the true solar elevation angle, P is the local air pressure in hPa, and T is the local air temperature in °C.\n\nLiterature\n\nThis method was described by [BW12].\n\nExample\n\nusing SolarPosition\n\n# Create SG2 refraction model with default parameters\nsg2 = SG2()\n\n# Or specify custom atmospheric conditions\nsg2_custom = SG2(101325.0, 25.0)  # 25°C temperature\n\n# Apply refraction correction to elevation angle\nelevation = 30.0  # degrees\nrefraction_correction = refraction(sg2, elevation)\napparent_elevation = elevation + refraction_correction\n\n\n\n\n\n","category":"type"},{"location":"refraction/#SolarPosition.Refraction.SPARefraction","page":"Refraction Correction","title":"SolarPosition.Refraction.SPARefraction","text":"struct SPARefraction{T} <: RefractionAlgorithm\n\nSPARefraction - SPA (Solar Position Algorithm) refraction model.\n\nAtmospheric refraction correction from the SPA algorithm.\n\nThis function calculates the atmospheric refraction correction of the solar elevation angle using the method described in Reda and Andreas's [1] Solar Position Algorithm (SPA).\n\nFields\n\npressure::Any: Annual average atmospheric pressure [Pascal]\ntemperature::Any: Annual average temperature [°C]\nrefraction_limit::Any: Minimum elevation angle for refraction correction [degrees]\n\nConstructor\n\nSPARefraction(): Uses default parameters: pressure = 101325 Pa, temperature = 12 °C, refraction_limit = -0.5667°\nSPARefraction(pressure, temperature): Specify custom pressure [Pa] and temperature [°C], uses default refraction_limit\nSPARefraction(pressure, temperature, refraction_limit): Also specify refraction limit [degrees]\n\nNotes\n\nThe equation to calculate the refraction correction is given by:\n\ntextref = fracP1010 cdot frac283273 + T cdot frac10260 cdot tan(el + 103(el + 511))\n\nwhere el is the true solar elevation angle, P is the annual average local air pressure in hPa/mbar, and T is the annual average local air temperature in °C.\n\nThe refraction limit parameter determines the solar elevation angle below which refraction is not applied, as the sun is assumed to be below horizon. Note that the sun diameter (0.26667°) is added to this limit.\n\nLiterature\n\nThis method was described by [RA04].\n\nExample\n\nusing SolarPosition\n\n# Create SPARefraction model with default parameters\nspa = SPARefraction()\n\n# Or specify custom atmospheric conditions\nspa_custom = SPARefraction(101325.0, 25.0)  # 25°C temperature\n\n# With custom refraction limit\nspa_limit = SPARefraction(101325.0, 12.0, -1.0)  # Don't correct below -1°\n\n# Apply refraction correction to elevation angle\nelevation = 30.0  # degrees\nrefraction_correction = refraction(spa, elevation)\napparent_elevation = elevation + refraction_correction\n\n\n\n\n\n","category":"type"},{"location":"literature/#Literature","page":"Literature","title":"Literature","text":"C. B. Archer, W. E. Brockett and C. A. Oakes. Collector Control System Simulation. Solar Energy Technology Conference (1980). Conference paper.\n\n\n\nG. G. Bennett. The Calculation of Astronomical Refraction in Marine Navigation. Journal of Navigation 35, 255–259 (1982).\n\n\n\nP. Blanc and L. Wald. The SG2 algorithm for a fast and accurate computation of the position of the Sun for multi-decadal time period. Solar Energy 86, 3072–3083 (2012).\n\n\n\nM. J. Blanco, K. Milidonis and A. M. Bonanos. Updating the PSA sun position algorithm. Solar Energy 212, 339–341 (2020).\n\n\n\nM. Blanco-Muriel, D. C. Alarcón-Padilla, T. López-Moratalla and M. Lara-Coira. Computing the solar vector. Solar Energy 70, 431–441 (2001).\n\n\n\nD. Haputhanthri, D. De Silva, S. Sierla, D. Alahakoon, R. Nawaratne, A. Jennings and V. Vyatkin. Solar irradiance nowcasting for virtual power plants using multimodal long short-term memory networks. Frontiers in Energy Research 9, 722212 (2021).\n\n\n\nG. W. Hughes. Engineering Astronomy (Sandia Laboratories, 1985).\n\n\n\nJ. Meeus. Astronomical Algorithms. 1st Edition (Willmann-Bell, 1991).\n\n\n\nJ. J. Michalsky. The Astronomical Almanac's algorithm for approximate solar position (1950–2050). Solar Energy 40, 227–235 (1988).\n\n\n\nL. V. Morrison and F. R. Stephenson. Historical values of the Earth's clock error DeltaT and the calculation of eclipses. Journal for the History of Astronomy 35, 327–336 (2004).\n\n\n\nI. Reda and A. Andreas. Solar position algorithm for solar radiation applications. Solar Energy 76, 577–589 (2004). Revised 2008.\n\n\n\nJ. W. Spencer. Comments on The Astronomical Almanac's Algorithm for Approximate Solar Position (1950–2050). Solar Energy 42, 353 (1989).\n\n\n\nR. Walraven. Calculating the position of the sun. Solar Energy 20, 393–397 (1978).\n\n\n\nR. Walraven. Erratum. Solar Energy 22, 195 (1979).\n\n\n\nJ. C. Zimmerman. Sun-pointing programs and their accuracy. Technical Report SAND-81-0761 (Sandia National Laboratories, 1981).\n\n\n\nNASA Goddard Space Flight Center. Polynomial Expressions for Delta T (DeltaT) (2025). Accessed: 2025-10-15.\n\n\n\nNOAA Global Monitoring Laboratory. Solar Position Calculator (2025). Accessed: 2025-10-15.\n\n\n\nU.S. Naval Observatory. Computing Altitude and Azimuth from Greenwich Apparent Sidereal Time (2025). Accessed: 2025-10-19.\n\n\n\nWikimedia Commons contributors. Atmospheric refraction: sunset and sunrise, https://upload.wikimedia.org/wikipedia/commons/3/39/Atmospheric_refraction_-_sunset_and_sunrise.png (2016). Image retrieved from Wikimedia Commons.\n\n\n\n","category":"section"},{"location":"positioning/#solar-positioning-algorithms","page":"Solar Positioning","title":"Solar Positioning","text":"All solar position algorithms available in SolarPosition.jl  return solar zenith, elevation, and azimuth angles. Algorithms that include an atmospheric refraction model also return “apparent” (refraction-corrected) values by default. This behavior can be modified by specifying a different refraction algorithm or passing NoRefraction no refraction correction is desired. See the Refraction Correction page for more details on refraction models.\n\n(Image: Solar position visualization) Figure 1: Visualization of solar position angles: azimuth and zenith. Image source: Haputhanthri et al..\n\nThe solar azimuth angle is typically measured clockwise from true north. The solar zenith angle is the angle between the sun and the vertical direction directly overhead. The solar elevation angle is the complement of the zenith angle (i.e., elevation = 90°- zenith).\n\nTypically solar position algorithms can take the following set of inputs:\n\nObserver location: latitude, longitude, and altitude\nDate and time: in UTC or local time with timezone information\nOptional atmospheric parameters: pressure and temperature (for refraction correction)","category":"section"},{"location":"positioning/#Example:-Solar-Path-Plotting","page":"Solar Positioning","title":"Example: Solar Path Plotting","text":"Solar positions can be calculated using solar_position and the in-place version solar_position! functions.\n\nAs an example, we plot the longest day of the year solar path for an observer located at the Van Gogh museum in Amsterdam (52.35888°N, 4.88185°E) on June 21, 2023:\n\n\nusing SolarPosition, Dates, CairoMakie\n\n# define observer location (latitude, longitude, altitude in meters)\nobs = Observer(52.35888, 4.88185, 100.0)  # Van Gogh Museum, Amsterdam\ntimes = collect(DateTime(2023, 6, 21, 0):Minute(5):DateTime(2023, 6, 21, 23, 55));\npositions = solar_position(obs, times, PSA(), HUGHES());\n\n# plot elevation and azimuth over the day\nfig = Figure(backgroundcolor = :transparent, textcolor= \"#f5ab35\", size = (800, 400))\nax1 = Axis(fig[1, 1], xlabel = \"Time (hours)\", ylabel = \"Elevation (degrees)\",\n    title = \"Solar Elevation on June 21, 2023 - Amsterdam\", backgroundcolor = :transparent,\n    xticks = 0:3:24)\nax2 = Axis(fig[1, 2], xlabel = \"Time (hours)\", ylabel = \"Azimuth (degrees)\",\n    title = \"Solar Azimuth on June 21, 2023 - Amsterdam\", backgroundcolor = :transparent,\n    xticks = 0:3:24)\ntimes_hours = [Dates.hour(t) + Dates.minute(t)/60 for t in times]\nlines!(ax1, times_hours, positions.elevation, color = \"#f5ab35\")\nlines!(ax2, times_hours, positions.azimuth, color = \"#f5ab35\")\nfig","category":"section"},{"location":"positioning/#Available-Algorithms","page":"Solar Positioning","title":"Available Algorithms","text":"The following solar position algorithms are currently implemented in SolarPosition.jl:\n\nAlgorithm Reference Accuracy Default Refraction Status\nPSA [BALL01] ±0.0083° None ✅\nNOAA [NOA25] ±0.0167° HUGHES ✅\nWalraven [Wal78] ±0.0100° None ✅\nUSNO [U.S25] ±0.0500° None ✅\nSPA [RA04] ±0.0003° Built-in ✅","category":"section"},{"location":"positioning/#psa-algorithm","page":"Solar Positioning","title":"PSA","text":"The PSA (Plataforma Solar de Almería) algorithm is the default high-accuracy solar position algorithm.\n\nThe algorithm was originally published by [BALL01] and was later updated by [BMB20] with new coefficients for improved accuracy.","category":"section"},{"location":"positioning/#noaa-algorithm","page":"Solar Positioning","title":"NOAA","text":"The NOAA (National Oceanic and Atmospheric Administration) algorithm provides an alternative implementation based on [NOA25].","category":"section"},{"location":"positioning/#walraven-algorithm","page":"Solar Positioning","title":"Walraven","text":"The Walraven algorithm is a solar position algorithm published in 1978 with stated accuracy of ±0.0100°.\n\nThe algorithm was originally published by [Wal78] with corrections from the 1979 Erratum [Wal79] and azimuth quadrant correction from [Spe89].","category":"section"},{"location":"positioning/#usno-algorithm","page":"Solar Positioning","title":"USNO","text":"The USNO (U.S. Naval Observatory) algorithm provides solar position calculations based on formulas from the USNO's Astronomical Applications Department.\n\nThe algorithm offers two options for calculating Greenwich mean sidereal time, providing flexibility for different accuracy requirements.","category":"section"},{"location":"positioning/#spa-algorithm","page":"Solar Positioning","title":"SPA","text":"The SPA (Solar Position Algorithm) is the highest-accuracy algorithm available in this package, with uncertainty of ±0.0003° for years between -2000 and 6000.\n\nThe algorithm was published by the National Renewable Energy Laboratory (NREL) in [RA04] and implements a complete heliocentric, geocentric, and topocentric solar position calculation with periodic terms for Earth heliocentric longitude and latitude.","category":"section"},{"location":"positioning/#SolarPosition.Positioning.PSA","page":"Solar Positioning","title":"SolarPosition.Positioning.PSA","text":"struct PSA <: SolarAlgorithm\n\nPSA (Plataforma Solar de Almería) solar position algorithm. This algorithm computes the solar position with high accuracy using empirical coefficients. Two coefficient sets are available: 2001 (range 1999-2015) and 2020 (range 2020-2050).\n\nAccuracy\n\nClaimed accuracy: ±0.004° for 2020 coefficients, ±0.01° for 2001 coefficients.\n\nLiterature\n\nThis algorithm is based on the work by [BALL01] and was updated for 2020 coefficients in [BMB20].\n\nFields\n\ncoeffs::Int64: Coefficient set year (2001 or 2020)\n\n\n\n\n\n","category":"type"},{"location":"positioning/#SolarPosition.Positioning.NOAA","page":"Solar Positioning","title":"SolarPosition.Positioning.NOAA","text":"struct NOAA <: SolarAlgorithm\n\nNOAA (National Oceanic and Atmospheric Administration) solar position algorithm. This algorithm is based on NOAA's Solar Position Calculator implementation. The algorithm is from \"Astronomical Algorithms\" by Jean Meeus.\n\nBy default, the NOAA algorithm uses the HUGHES atmospheric refraction model which is in accordance with the NOAA solar position calculator.\n\nAccuracy\n\nClaimed accuracy: ±0.0167° from years -2000 to +3000 for latitudes within ±72°. For latitudes outside this range, the accuracy is ±0.167°.\n\nLiterature\n\nBased on the NOAA solar position calculator [NOA25] and the work by [Mee91].\n\nFields\n\ndelta_t::Union{Nothing, Float64}: Difference between terrestrial time and UT1 [seconds]. If nothing, uses automatic calculation.\n\n\n\n\n\n","category":"type"},{"location":"positioning/#SolarPosition.Positioning.Walraven","page":"Solar Positioning","title":"SolarPosition.Positioning.Walraven","text":"struct Walraven <: SolarAlgorithm\n\nWalraven solar position algorithm. The implementation accounts for the 1979 Erratum and correct azimuth quadrant selection.\n\nAccuracy\n\nClaimed accuracy is ±0.0100°.\n\nLiterature\n\nThis algorithm is based on [Wal78] with corrections from the 1979 Erratum [Wal79] and azimuth quadrant correction from [Spe89].\n\n\n\n\n\n","category":"type"},{"location":"positioning/#SolarPosition.Positioning.USNO","page":"Solar Positioning","title":"SolarPosition.Positioning.USNO","text":"struct USNO <: SolarAlgorithm\n\nUSNO (U.S. Naval Observatory) solar position algorithm. This algorithm provides solar position calculations based on the USNO's Astronomical Applications Department formulas.\n\nAccuracy\n\nThe accuracy is typically within a few arcminutes for most practical applications. This algorithm is suitable for general-purpose solar position calculations.\n\nLiterature\n\nThe U.S. Naval Observatory (USNO) algorithm is provided in [U.S25].\n\nFields\n\ndelta_t::Union{Nothing, Float64}: Difference between terrestrial time and UT1 [seconds]. If nothing, uses automatic calculation.\ngmst_option::Int64: Option for calculating Greenwich mean sidereal time (1 or 2)\n\n\n\n\n\n","category":"type"},{"location":"positioning/#SolarPosition.Positioning.SPA","page":"Solar Positioning","title":"SolarPosition.Positioning.SPA","text":"struct SPA <: SolarAlgorithm\n\nSPA (Solar Position Algorithm) from NREL. This is the most accurate algorithm for solar position calculation, suitable for high-precision applications.\n\nThe algorithm implements the complete NREL Solar Position Algorithm as described in Reda and Andreas (2004, 2007). It accounts for:\n\nHeliocentric position of Earth\nNutation and aberration\nGeocentric and topocentric corrections\nAtmospheric refraction\nParallax effects\n\nAccuracy\n\nClaimed accuracy: ±0.0003° (±1 arcsecond) for years -2000 to 6000.\n\nLiterature\n\nThis algorithm is based on [RA04] with corrections from the 2007 corrigendum.\n\nFields\n\ndelta_t::Union{Nothing, Float64}: Difference between terrestrial time and UT1 [seconds]. If nothing, uses automatic calculation.\npressure::Float64: Annual average air pressure [Pa]\ntemperature::Float64: Annual average air temperature [°C]\natmos_refract::Float64: Approximate atmospheric refraction at sunrise/sunset [degrees]\n\n\n\n\n\n","category":"type"},{"location":"guides/plotting/#plotting-examples","page":"Plotting with Makie.jl","title":"Plotting with Makie.jl","text":"SolarPosition.jl provides a plotting extension for Makie.jl.\n\nTo use it, simply import both the SolarPosition and Makie packages:\n\nusing SolarPosition\nusing CairoMakie\n\n# supporting packages\nusing Dates\nusing TimeZones\nusing DataFrames\n\nThis example notebook is based on the pvlib sun path example.","category":"section"},{"location":"guides/plotting/#Basic-Sun-Path-Plotting","page":"Plotting with Makie.jl","title":"Basic Sun Path Plotting","text":"Let's start by defining an observer location and calculating solar positions for a whole year:\n\n# Define observer location (New Delhi, India)\n# Parameters: latitude, longitude, altitude in meters\ntz = tz\"Asia/Kolkata\"\nobs = Observer(28.6, 77.2, 0.0)\n\n# Generate hourly timestamps for a whole year\ntimes = collect(ZonedDateTime(DateTime(2019), tz):Hour(1):ZonedDateTime(DateTime(2020), tz))\n\n# This returns a StructVector with solar position data\npositions = solar_position(obs, times)\n\n# For plotting, we need to create a DataFrame that includes the timestamps\ndf = DataFrame(positions)\ndf.datetime = times\n\n# We can inspect the first few entries\nfirst(df, 5)","category":"section"},{"location":"guides/plotting/#Simple-Sun-Path-Plot-in-Cartesian-Coordinates","page":"Plotting with Makie.jl","title":"Simple Sun Path Plot in Cartesian Coordinates","text":"We can visualize solar positions in cartesian coordinates using the sunpathplot function:\n\nfig = Figure(backgroundcolor = (:white, 0.0), textcolor= \"#f5ab35\")\nax = Axis(fig[1, 1], backgroundcolor = (:white, 0.0))\nsunpathplot!(ax, df, hour_labels = false)\nfig","category":"section"},{"location":"guides/plotting/#Polar-Coordinates-with-Hour-Labels","page":"Plotting with Makie.jl","title":"Polar Coordinates with Hour Labels","text":"We can also work directly with a DataFrame. Note that for plotting we need to include the datetime information, so we add it to the DataFrame.\n\nPlotting in polar coordinates with sunpathpolarplot may yield a more intuitive representation of the solar path. Here, we also enable hourly labels for better readability:\n\nfig2 = Figure(backgroundcolor = :transparent, textcolor= \"#f5ab35\", size = (800, 600))\nax2 = PolarAxis(fig2[1, 1], backgroundcolor = \"#1f2424\")\nsunpathpolarplot!(ax2, df, hour_labels = true)\n\n# Draw individual days\nline_objects = []\nfor (date, label) in [(Date(\"2019-03-21\"), \"Mar 21\"),\n                      (Date(\"2019-06-21\"), \"Jun 21\"),\n                      (Date(\"2019-12-21\"), \"Dec 21\")]\n    times = collect(ZonedDateTime(DateTime(date), tz):Minute(5):ZonedDateTime(DateTime(date) + Day(1), tz))\n    solpos = solar_position(obs, times)\n    above_horizon = solpos.elevation .> 0\n    day_df = DataFrame(solpos)\n    day_df.datetime = times\n    day_filtered = day_df[above_horizon, :]\n    line_obj = lines!(ax2, deg2rad.(day_filtered.azimuth), day_filtered.zenith,\n                      linewidth = 2, label = label)\n    push!(line_objects, line_obj)\nend\n\n# Add legend below the plot\nfig2[2, 1] = Legend(fig2, line_objects, [\"Mar 21\", \"Jun 21\", \"Dec 21\"],\n                    orientation = :horizontal, tellheight = true, backgroundcolor = :transparent)\nfig2\n\nThe figure-8 patterns are known as analemmas, which represent the sun's position at the same time of day throughout the year.\n\nNote that in polar coordinates, the radial distance from the center represents the zenith angle (90° - elevation). Thus, points closer to the center indicate higher elevations. Conversely, a zenith angle of more than 90° (negative elevation) indicates that the sun is below the horizon. Tracing a path from right to left corresponds to the sun's movement from east to west.\n\nIt tells us when the sun rises, reaches its highest point, and sets. And hence also the length of the day. From the figure we can also read that in June the days are longest, while in December they are shortest.","category":"section"},{"location":"guides/plotting/#Plotting-without-a-custom-axis","page":"Plotting with Makie.jl","title":"Plotting without a custom axis","text":"Finally, we can also create plots without explicitly defining an axis beforehand. This is a more concise way to create plots, but it offers less customization:\n\nsunpathpolarplot(df, hour_labels = true, colorbar = true)","category":"section"},{"location":"deltat/#deltat","page":"Delta T (ΔT)","title":"Delta T (ΔT)","text":"Delta T (ΔT) is the difference between Terrestrial Dynamical Time (TD) and Universal Time (UT):\n\nDelta T = TD - UT\n\nThis correction is essential for accurate astronomical calculations because Earth's rotation rate is not constant. It varies due to tidal braking from the Moon, changes in Earth's moment of inertia, and other geophysical factors.","category":"section"},{"location":"deltat/#Implementation","page":"Delta T (ΔT)","title":"Implementation","text":"SolarPosition.jl implements ΔT calculation using polynomial expressions fitted to historical observations and modern measurements from atomic clocks, based on [NAS25] and [MS04]:\n\nHistorical data (-500 to 1950): Based on eclipse observations\nModern era (1950-2005): Direct measurements from atomic clocks and radio observations\nFuture (2005-2050): Extrapolation based on recent trends\nFar past/future: Parabolic extrapolation formula","category":"section"},{"location":"deltat/#Usage","page":"Delta T (ΔT)","title":"Usage","text":"","category":"section"},{"location":"deltat/#Examples","page":"Delta T (ΔT)","title":"Examples","text":"","category":"section"},{"location":"deltat/#Basic-Usage","page":"Delta T (ΔT)","title":"Basic Usage","text":"Calculate ΔT for a specific year and month:\n\nusing SolarPosition.Positioning: calculate_deltat\n\n# Calculate ΔT for June 2020\ndt = calculate_deltat(2020, 6)\nprintln(\"ΔT ≈ $(round(dt, digits=2)) seconds\")","category":"section"},{"location":"deltat/#Using-Date-Objects","page":"Delta T (ΔT)","title":"Using Date Objects","text":"For more convenient usage with date objects:\n\nusing SolarPosition.Positioning: calculate_deltat\nusing Dates\n\n# Using Date\ndate = Date(2020, 6, 15)\ndt1 = calculate_deltat(date)\n\n# Using DateTime\ndatetime = DateTime(2020, 6, 15, 12, 30, 45)\ndt2 = calculate_deltat(datetime)\n\n# Using ZonedDateTime\nusing TimeZones\nzdt = ZonedDateTime(2020, 6, 15, 12, 30, 45, tz\"UTC\")\ndt3 = calculate_deltat(zdt)\n\nprintln(\"Date: ΔT ≈ $(round(dt1, digits=2)) seconds\")\nprintln(\"DateTime: ΔT ≈ $(round(dt2, digits=2)) seconds\")\nprintln(\"ZonedDateTime: ΔT ≈ $(round(dt3, digits=2)) seconds\")","category":"section"},{"location":"deltat/#Historical-Values","page":"Delta T (ΔT)","title":"Historical Values","text":"Calculate ΔT for historical dates:\n\nusing SolarPosition.Positioning: calculate_deltat\n\n# Ancient Rome (year 0)\ndt_ancient = calculate_deltat(0, 6)\nprintln(\"Year 0: ΔT ≈ $(round(dt_ancient, digits=0)) seconds\")\n\n# Early telescope era (1650)\ndt_1650 = calculate_deltat(1650, 6)\nprintln(\"Year 1650: ΔT ≈ $(round(dt_1650, digits=1)) seconds\")\n\n# Near zero around 1900\ndt_1900 = calculate_deltat(1900, 6)\nprintln(\"Year 1900: ΔT ≈ $(round(dt_1900, digits=1)) seconds\")","category":"section"},{"location":"deltat/#Plotting-Historical-Trend","page":"Delta T (ΔT)","title":"Plotting Historical Trend","text":"Visualize how ΔT has changed over time, similar to the measured values derived from telescopic observations:\n\nusing SolarPosition.Positioning: calculate_deltat\nusing CairoMakie\n\n# Calculate ΔT for years 1600-2000 (historical measurements)\nyears = 1600:1:2000\ndeltat_values = [calculate_deltat(year, 6) for year in years]\n\n# Create plot with transparent background\nfig = Figure(size=(800, 500), backgroundcolor=:transparent, textcolor=\"#f5ab35\")\nax = Axis(fig[1, 1],\n    xlabel = \"Year\",\n    ylabel = \"ΔT (seconds)\",\n    title = \"Historical Values of the Earth's Clock Error\",\n    backgroundcolor=:transparent,\n    xgridvisible = false,\n    ygridvisible = false,\n    xticks = 1500:100:2000,\n    xminorticks = IntervalsBetween(5),\n    xminorticksvisible = true,\n    yminorticks = IntervalsBetween(5),\n    yminorticksvisible = true\n)\n\n# Plot the measured/calculated values\nlines!(ax, years, deltat_values,\n    linewidth=2.5,\n    color=:steelblue,\n    label=\"calculated\"\n)\n\n# Add a very long-term parabolic trend line\n# Using the formula: ΔT ≈ -20 + 32 * ((year - 1820) / 100)^2\n# This represents the parabolic trend centered around 1820-1825\ntrend_years = 1560:10:2050\ntrend_values = [-20 + 32 * ((y - 1820) / 100)^2 for y in trend_years]\nlines!(ax, trend_years, trend_values,\n    linewidth=2,\n    color=:steelblue,\n    linestyle=:dash,\n    label=\"very long-term trend\"\n)\n\naxislegend(ax, position=:lb, backgroundcolor=:transparent)\nxlims!(ax, 1500, 2000)\nylims!(ax, -50, 200)\n\nfig\n\nThis plot is an attempt to reproduce the result of [MS04, Fig 1., page 329] and shows the measured values of ΔT derived from astronomical observations since 1600 CE.","category":"section"},{"location":"deltat/#Accuracy","page":"Delta T (ΔT)","title":"Accuracy","text":"The accuracy of ΔT calculations varies depending on the time period:\n\nModern era (1950-2025): Very accurate (< 1 second)\nHistorical (1600-1950): Accurate to a few seconds\nMedieval (500-1600): Accuracy decreases to ~10-30 seconds\nAncient (< 500): Accuracy decreases significantly (~50-500 seconds)\nFuture predictions: Uncertainty increases with time\n\nThe uncertainty in ΔT arises because Earth's rotation is affected by unpredictable factors like atmospheric circulation, ocean currents, and tectonic events. For more details on the polynomial expressions and methodology, see [NAS25] and [MS04].","category":"section"},{"location":"deltat/#SolarPosition.Positioning.calculate_deltat","page":"Delta T (ΔT)","title":"SolarPosition.Positioning.calculate_deltat","text":"calculate_deltat(year::Real, month::Real) -> Float64\n\n\nCompute ΔT (Delta T), the difference between Terrestrial Dynamical Time (TD) and Universal Time (UT).\n\nΔT = TD - UT\n\nThis value is needed to convert between civil time (UT) and the uniform time scale used in astronomical calculations (TD). The value changes over time due to variations in Earth's rotation rate caused by tidal braking and other factors.\n\nArguments\n\nyear::Real: Calendar year (supports -1999 to 3000, with warnings outside this range)\nmonth::Real: Month as a real number (1-12, fractional values supported for interpolation)\n\nReturns\n\nFloat64: ΔT in seconds\n\nExamples\n\njulia> using SolarPosition.Positioning: calculate_deltat\n\njulia> calculate_deltat(2020, 6)\n71.85030032812497\n\njulia> using Dates\n\njulia> calculate_deltat(Date(2020, 6, 15))\n71.87173085145835\n\njulia> calculate_deltat(DateTime(2020, 6, 15, 12, 30))\n71.87173085145835\n\nLiterature\n\nThe polynomial expressions for ΔT are from [NAS25], based on the work by [MS04].\n\n\n\n\n\n","category":"function"},{"location":"guides/getting-started/#getting-started","page":"Getting Started","title":"Getting Started","text":"In this tutorial, we introduduce the basics of using SolarPosition.jl to calculate solar positions.\n\nFirst, we need to import the SolarPosition.jl package along with some supporting packages which we need for handling dates and time zones. We also load DataFrames.jl because it makes it easy to work with tabular data.\n\ninfo: Info\nThe DateTime type in Julia's standard library does not contain time zone information. When using DateTime, it is assumed to be in UTC. Although not necessary, it is safer to work with time zone-aware ZonedDateTime from the TimeZones.jl package.\n\n# mandatory\nusing SolarPosition\nusing Dates\n\n# supporting packages\nusing TimeZones\nusing DataFrames","category":"section"},{"location":"guides/getting-started/#Defining-a-location","page":"Getting Started","title":"Defining a location","text":"We can observe the sun from anywhere on earth. To define an observer location, we use the Observer struct, which takes latitude, longitude, and optionally altitude (in meters) as arguments.\n\nobs = Observer(52.35888, 4.88185, 100.0)  # Van Gogh Museum, Amsterdam","category":"section"},{"location":"guides/getting-started/#Computing-the-solar-vector","page":"Getting Started","title":"Computing the solar vector","text":"Finally, we can calculate the solar position for a specific date and time using the solar_position function. The time should be provided as a ZonedDateTime to ensure correct handling of time zones.\n\ntz = TimeZone(\"Europe/Brussels\")\nzdt = ZonedDateTime(2023, 6, 21, 12, 0, 0, tz)  # Summer solstice noon\nposition = solar_position(obs, zdt)","category":"section"},{"location":"guides/getting-started/#Choosing-a-Solar-Position-Algorithm","page":"Getting Started","title":"Choosing a Solar Position Algorithm","text":"By default, solar_position uses the PSA (Plataforma Solar de Almería) algorithm, which has a decent tradeoff between complexity and accuracy. You can choose other algorithms as described in the Solar Positioning Algorithms section.\n\nFirst, we repeat the previous calculation using the default PSA algorithm:\n\nposition_psa = solar_position(obs, zdt, PSA())\n\nNext, we compute the solar position using the NOAA algorithm:\n\nposition_noaa = solar_position(obs, zdt, NOAA())\n\nAs you can see, the results are very similar. With a claimed accuracy of ±0.0083° for PSA and ±0.0167° for NOAA, the differences should be small:\n\ndelta_azimuth = abs(position_psa.azimuth - position_noaa.azimuth)\ndelta_elevation = abs(position_psa.elevation - position_noaa.elevation)\nprintln(\"Difference in Azimuth: $(round(delta_azimuth, digits=4))°\")\nprintln(\"Difference in Elevation: $(round(delta_elevation, digits=4))°\")\n\nWhether the differences are significant depends on your application and required accuracy.","category":"section"},{"location":"guides/getting-started/#Computing-multiple-timestamps-simultaneously","page":"Getting Started","title":"Computing multiple timestamps simultaneously","text":"For more demanding applications, it is often necessary to compute solar positions for multiple timestamps at once. SolarPosition.jl supports this by passing a vector of ZonedDateTime or DateTime objects to the solar_position function. Here, we demonstrate this by calculating solar positions for every hour of a full year.\n\n# generate hourly timestamps for a whole year\ndts = collect(ZonedDateTime(DateTime(2023), tz):Hour(1):ZonedDateTime(DateTime(2024), tz))\npositions = solar_position(obs, dts)\n\ninfo: Info\nThe returned datastructure is a StructArray from the StructArrays.jl package, which behaves similarly to a vector of SolPos  structs but is more convenient to work with.\n\nThe returned StructArray can be easily converted to a DataFrame for inspection:\n\ndf = DataFrame(positions)\ndf.datetime = dts  # add datetime information\nfirst(df, 5)  # show first 5 entries","category":"section"},{"location":"guides/getting-started/#Broadcasting-Over-Multiple-Locations","page":"Getting Started","title":"Broadcasting Over Multiple Locations","text":"Thanks to Julia's broadcasting syntax it is trivial to calculate solar positions for multiple locations simultaneously. This can be useful for example when analyzing solar irradiance over a geographic region with multiple measurement stations.\n\n# Create observers at different latitudes\nobservers = Observer.([10.0, 20.0, 30.0], 10.0)\n\n# Calculate solar position for all locations at a specific time\ndt = DateTime(2020)\npositions_broadcast = solar_position.(observers, dt)","category":"section"},{"location":"reference/#reference","page":"API reference","title":"API reference","text":"This page provides comprehensive documentation for all functions and types in SolarPosition.jl.","category":"section"},{"location":"reference/#Contents","page":"API reference","title":"Contents","text":"Pages = [\"reference.md\"]","category":"section"},{"location":"reference/#Index","page":"API reference","title":"Index","text":"Pages = [\"reference.md\"]","category":"section"},{"location":"reference/#Core-Functions","page":"API reference","title":"Core Functions","text":"","category":"section"},{"location":"reference/#Observer-and-Position-Types","page":"API reference","title":"Observer and Position Types","text":"","category":"section"},{"location":"reference/#Algorithm-Base-Types","page":"API reference","title":"Algorithm Base Types","text":"SolarPosition.jl uses a type hierarchy for algorithms:","category":"section"},{"location":"reference/#Modules","page":"API reference","title":"Modules","text":"","category":"section"},{"location":"reference/#SolarPosition.Positioning.solar_position","page":"API reference","title":"SolarPosition.Positioning.solar_position","text":"solar_position(obs::Observer, dt::DateTime, alg::SolarAlgorithm=PSA(), refraction::RefractionAlgorithm=NoRefraction())\nsolar_position(obs::Observer, dt::ZonedDateTime, alg::SolarAlgorithm=PSA(), refraction::RefractionAlgorithm=NoRefraction())\nsolar_position(obs::Observer, dts::AbstractVector{DateTime}, alg::SolarAlgorithm=PSA(), refraction::RefractionAlgorithm=NoRefraction())\nsolar_position(obs::Observer, dts::AbstractVector{ZonedDateTime}, alg::SolarAlgorithm=PSA(), refraction::RefractionAlgorithm=NoRefraction())\n\nCalculate solar position(s) for given observer location(s) and time(s).\n\nThis function computes the solar position (azimuth, elevation, and zenith angles) based on an observer's geographic location and timestamp(s). It supports multiple input formats and automatically handles time zone conversions.\n\nArguments\n\nobs::Observer: Observer location with latitude, longitude, and altitude\ndt::DateTime or dt::ZonedDateTime: Single timestamp\ndts::AbstractVector: Vector of timestamps (DateTime or ZonedDateTime)\nalg::SolarAlgorithm: Solar positioning algorithm (default: PSA())\nrefraction::RefractionAlgorithm: Atmospheric refraction correction (default: NoRefraction())\n\nReturns\n\nFor single timestamps:\nSolPos struct when refraction = DefaultRefraction() (default)\nApparentSolPos struct when a refraction algorithm is provided\nFor multiple timestamps: StructVector of solar position data\n\n\n\nAngles Convention\n\nAll returned angles are in degrees:\n\nAzimuth: 0° = North, positive clockwise, range [-180°, 180°]\nElevation: angle above horizon, range [-90°, 90°]\nZenith: angle from zenith (90° - elevation), range [0°, 180°]\nApparent Elevation/Zenith: Only in ApparentSolPos, includes atmospheric refraction\n\n\n\nExamples\n\nSingle timestamp calculation (basic position)\n\nusing SolarPosition, Dates, TimeZones\n\n# Define observer location (San Francisco)\nobs = Observer(37.7749, -122.4194, 100.0)\n\n# Calculate position at specific time\ndt = ZonedDateTime(2023, 6, 21, 12, 0, 0, tz\"America/Los_Angeles\")\npos = solar_position(obs, dt)\n\nprintln(\"Azimuth: $(pos.azimuth)°\")\nprintln(\"Elevation: $(pos.elevation)°\")\nprintln(\"Zenith: $(pos.zenith)°\")\n\nWith refraction correction\n\n# Use a refraction algorithm (when implemented)\n# pos_apparent = solar_position(obs, dt, PSA(), MyRefractionAlg())\n# println(\"Apparent Elevation: $(pos_apparent.apparent_elevation)°\")\n\nMultiple timestamps calculation\n\n# Generate hourly timestamps for a day\ntimes = collect(DateTime(2023, 6, 21):Hour(1):DateTime(2023, 6, 22))\npositions = solar_position(obs, times)\n\n# Access as StructVector (acts like array of structs)\nprintln(\"First position: \", positions[1])\nprintln(\"All azimuths: \", positions.azimuth)\n\nUsing different algorithms\n\n# Use NOAA algorithm instead of default PSA\npos_noaa = solar_position(obs, dt, NOAA())\n\nSupported Input Types\n\nObserver: Observer{T} struct with lat/lon/altitude\nSingle time: DateTime, ZonedDateTime\nMultiple times: Vector{DateTime}, Vector{ZonedDateTime}\nAlgorithm: Any SolarAlgorithm subtype\nRefraction: Any RefractionAlgorithm subtype (default: NoRefraction())\n\nTime Zone Handling\n\nDateTime inputs are assumed to be in UTC\nZonedDateTime inputs are automatically converted to UTC\nFor local solar time calculations, use appropriate time zones\n\nPerformance Notes\n\nVectorized operations are optimized for multiple timestamps\nType-stable implementations for both Float32 and Float64\nBroadcasting-friendly for large datasets\n\nSee also: solar_position!, Observer, PSA, NOAA\n\n\n\n\n\n","category":"function"},{"location":"reference/#SolarPosition.Positioning.solar_position!","page":"API reference","title":"SolarPosition.Positioning.solar_position!","text":"solar_position!(table, obs::Observer; dt_col::Symbol=:datetime, alg::SolarAlgorithm=PSA(), refraction::RefractionAlgorithm=NoRefraction(), kwargs...)\nsolar_position!(table; latitude::AbstractFloat, longitude::AbstractFloat,\n                altitude::AbstractFloat=0.0, alg::SolarAlgorithm=PSA(), refraction::RefractionAlgorithm=NoRefraction(), kwargs...)\n\nCompute solar positions for all times in a table and add the results as new columns.\n\nArguments\n\ntable : Table-like object with datetime column (must support Tables.jl interface).\nobs::Observer : Observer location (latitude, longitude, altitude).\nlatitude, longitude, altitude : Specify observer location directly.\ndt_col::Symbol : Name of the datetime column (default: :datetime).\nalg::SolarAlgorithm : Algorithm to use (default: PSA()).\nrefraction::RefractionAlgorithm : Refraction correction (default: NoRefraction()).\nkwargs... : Additional keyword arguments forwarded to the algorithm.\n\nReturns\n\nModified table with added columns: azimuth, elevation, zenith.\nIf refraction is applied: also adds apparent_elevation, apparent_zenith.\n\nNotes\n\nThe input table is modified in-place by adding new columns.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SolarPosition.Positioning.Observer","page":"API reference","title":"SolarPosition.Positioning.Observer","text":"struct Observer{T<:AbstractFloat}\n\nObserver location (deg  rees, meters). Accepts a type parameter T for the floating point type to use (e.g. Float32, Float64).\n\n\n\nFields\n\nlatitude::AbstractFloat: Geodetic latitude (+N)\nlongitude::AbstractFloat: Longitude (+E)\naltitude::AbstractFloat: Altitude above mean sea level (meters)\nlatitude_rad::AbstractFloat: Latitude in radians\nlongitude_rad::AbstractFloat: Longitude in radians\nsin_lat::AbstractFloat: sin(latitude)\ncos_lat::AbstractFloat: cos(latitude)\n\n\n\n\n\n","category":"type"},{"location":"reference/#SolarPosition.Positioning.SolPos","page":"API reference","title":"SolarPosition.Positioning.SolPos","text":"struct SolPos{T} <: AbstractSolPos\n\nRepresents a single solar position calculated for a given observer and time.\n\n\n\nFields\n\nazimuth::Any: Azimuth (degrees, 0=N, +clockwise, range [-180, 180])\nelevation::Any: Elevation (degrees, range [-90, 90])\nzenith::Any: Zenith = 90 - elevation (degrees, range [0, 180])\n\n\n\n\n\n","category":"type"},{"location":"reference/#SolarPosition.Positioning.ApparentSolPos","page":"API reference","title":"SolarPosition.Positioning.ApparentSolPos","text":"struct ApparentSolPos{T} <: AbstractApparentSolPos\n\nRepresents a single solar position calculated for a given observer and time. Also includes apparent elevation and zenith angles.\n\n\n\nFields\n\nazimuth::Any: Azimuth (degrees, 0=N, +clockwise, range [-180, 180])\nelevation::Any: Elevation (degrees, range [-90, 90])\nzenith::Any: Zenith = 90 - elevation (degrees, range [0, 180])\napparent_elevation::Any: Apparent elevation (degrees, range [-90, 90])\napparent_zenith::Any: Apparent zenith (degrees, range [0, 180])\n\n\n\n\n\n","category":"type"},{"location":"reference/#SolarPosition.Positioning.SPASolPos","page":"API reference","title":"SolarPosition.Positioning.SPASolPos","text":"struct SPASolPos{T} <: AbstractApparentSolPos\n\nSolar position result from SPA algorithm including equation of time.\n\n\n\nFields\n\nazimuth::Any: Azimuth (degrees, 0=N, +clockwise, range [-180, 180])\nelevation::Any: Elevation (degrees, range [-90, 90])\nzenith::Any: Zenith = 90 - elevation (degrees, range [0, 180])\napparent_elevation::Any: Apparent elevation (degrees, range [-90, 90])\napparent_zenith::Any: Apparent zenith (degrees, range [0, 180])\nequation_of_time::Any: Equation of time (minutes)\n\n\n\n\n\n","category":"type"},{"location":"reference/#SolarPosition.Positioning.SPAObserver","page":"API reference","title":"SolarPosition.Positioning.SPAObserver","text":"struct SPAObserver{T<:AbstractFloat}\n\nnote: Internal Implementation\nThis is an internal optimization type not exported to users. Use Observer instead.\n\nOptimized observer type for SPA algorithm with pre-computed location-dependent values. Will cache terms that depend only on observer location to speed up calculations for multiple times at the same location.\n\nInternal Fields\n\nlatitude::AbstractFloat: Geodetic latitude (+N)\nlongitude::AbstractFloat: Longitude (+E)\naltitude::AbstractFloat: Altitude above mean sea level (meters)\nlatitude_rad::AbstractFloat: Latitude in radians\nlongitude_rad::AbstractFloat: Longitude in radians\nsin_lat::AbstractFloat: sin(latitude)\ncos_lat::AbstractFloat: cos(latitude)\nu::AbstractFloat: Cached u term for parallax (reduced latitude)\nx::AbstractFloat: Cached x term for parallax correction\ny::AbstractFloat: Cached y term for parallax correction\n\n\n\n\n\n","category":"type"},{"location":"reference/#SolarPosition.Positioning.SolarAlgorithm","page":"API reference","title":"SolarPosition.Positioning.SolarAlgorithm","text":"abstract type SolarAlgorithm\n\nAbstract base type for all solar position algorithms.\n\nAll concrete solar position algorithm types must inherit from this type.\n\nExamples\n\nstruct MyAlgorithm <: SolarAlgorithm end\n\n\n\n\n\n","category":"type"},{"location":"reference/#SolarPosition.Refraction.RefractionAlgorithm","page":"API reference","title":"SolarPosition.Refraction.RefractionAlgorithm","text":"abstract type RefractionAlgorithm\n\nAbstract base type for atmospheric refraction correction algorithms.\n\nRefraction algorithms compute the apparent position of the sun by correcting for atmospheric refraction effects.\n\nExamples\n\nstruct MyRefraction <: RefractionAlgorithm end\n\n\n\n\n\n","category":"type"},{"location":"reference/#SolarPosition.Positioning","page":"API reference","title":"SolarPosition.Positioning","text":"Positioning\n\nThis module provides the core solar position calculation algorithms, observer location handling, and result types for SolarPosition.jl. It includes implementations of various solar position algorithms such as PSA and NOAA, with support for optional atmospheric refraction corrections.\n\nExported Types\n\nObserver: Geographic observer location\nSolPos: Basic solar position result\nApparentSolPos: Solar position with atmospheric corrections\nPSA: PSA algorithm implementation\nNOAA: NOAA algorithm implementation\nRefractionAlgorithm: Base type for refraction algorithms\nNoRefraction: No refraction correction (default)\n\nExported Functions\n\nsolar_position: Calculate solar positions\nsolar_position!: In-place solar position calculation\n\n\n\n\n\n","category":"module"},{"location":"reference/#SolarPosition.Refraction","page":"API reference","title":"SolarPosition.Refraction","text":"Refraction\n\nAtmospheric refraction models.\n\nExported Types\n\nHUGHES: Hughes atmospheric refraction model\nARCHER: Archer atmospheric refraction model\nBENNETT: Bennett atmospheric refraction model\nMICHALSKY: Michalsky atmospheric refraction model\nSG2: Saemundsson-Garfinkel atmospheric refraction model\nSPA: Solar Position Algorithm refraction model\n\nExported Functions\n\nrefraction: Apply refraction correction to elevation angle(s)\n\n\n\n\n\n","category":"module"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"#SolarPosition.jl","page":"Home","title":"SolarPosition.jl","text":"(Image: Test workflow status) (Image: Coverage) (Image: Lint workflow Status) (Image: Docs workflow Status) (Image: Aqua QA) (Image: tested with JET.jl)\n\nSolarPosition.jl provides a simple, unified interface to a collection of validated solar position algorithms written in pure, performant julia.\n\nSolar positioning algorithms are commonly used to calculate the solar zenith and azimuth angles, which are essential for various applications where the sun is important, such as:\n\nSolar energy systems\nBuilding design\nClimate studies\nAstronomy","category":"section"},{"location":"#Extensions","page":"Home","title":"Extensions","text":"SolarPosition.jl provides package extensions for advanced use cases:\n\nModelingToolkit Extension: Integrate solar position calculations into symbolic modeling workflows. Create composable solar energy system models with ModelingToolkit.jl. See the ModelingToolkit Extension guide for details.\nMakie Extension: Plotting recipes for solar position visualization.","category":"section"},{"location":"#Acknowledgement","page":"Home","title":"Acknowledgement","text":"This package is based on the work done by readers in the field of solar photovoltaics in the packages solposx and pvlib-python. In particular the positioning and refraction methods have been adapted from solposx, while the SPA algorithm and the deltat calculation are ported from pvlib-python. These packages also provide validation data necessary to ensure correctness of the algorithm implementations.","category":"section"},{"location":"#Example-Usage","page":"Home","title":"Example Usage","text":"using SolarPosition, Dates\n\n# define observer location (latitude, longitude, altitude in meters)\nobs = Observer(52.35888, 4.88185, 100.0)  # Van Gogh Museum, Amsterdam\n\n# a few hours of timestamps\ntimes = collect(DateTime(2023, 6, 21, 10):Hour(1):DateTime(2023, 6, 21, 15));\n\n# compute solar positions for all timestamps\npositions = solar_position(obs, times)","category":"section"},{"location":"#Solar-positioning-algorithms","page":"Home","title":"Solar positioning algorithms","text":"Here we provide an overview of the solar positioning algorithms currently implemented in SolarPosition.jl. Each algorithm is described with its reference paper, claimed accuracy and implementation status.\n\nAlgorithm Reference Accuracy Default Refraction Status\nPSA Blanco-Muriel et al. ±0.0083° None ✅\nNOAA Global Monitoring Laboratory ±0.0167° HUGHES ✅\nWalraven Walraven, 1978 ±0.0100° None ✅\nUSNO U.S. Naval Observatory ±0.0500° None ✅\nSPA Reda & Andreas, 2004 ±0.0003° Built-in ✅","category":"section"},{"location":"#Refraction-correction-algorithms","page":"Home","title":"Refraction correction algorithms","text":"Atmospheric refraction correction algorithms available in SolarPosition.jl.\n\nAlgorithm Reference Atmospheric Parameters Status\nHUGHES Hughes, 1985 Pressure, Temperature ✅\nARCHER Archer et al., 1980 None ✅\nBENNETT Bennett, 1982 Pressure, Temperature ✅\nMICHALSKY Michalsky, 1988 None ✅\nSG2 Blanc & Wald, 2012 Pressure, Temperature ✅\nSPARefraction Reda & Andreas, 2004 Pressure, Temperature ✅","category":"section"},{"location":"#How-to-Cite","page":"Home","title":"How to Cite","text":"If you use SolarPosition.jl in your work, please cite using the reference given in CITATION.cff.","category":"section"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"If you want to make contributions of any kind, please first that a look into our contributing guide directly on GitHub or the contributing page on the website","category":"section"}]
}
