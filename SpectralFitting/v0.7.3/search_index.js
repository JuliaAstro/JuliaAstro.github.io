var documenterSearchIndex = {"docs":
[{"location":"models/surrogate-models/#Surrogate-models","page":"Surrogate models","title":"Surrogate models","text":"Surrogate models allow you to create fast or memory efficient approximations of model components, or assist in optimizing some objective function directly. SpectralFitting uses the Surrogates.jl library of models, that yields pure-Julia surrogate models. Consequently, surrogate models also permit use of automatic differentiation in fitting, and are therefore powerful tools for improving fitting performance.","category":"section"},{"location":"models/surrogate-models/#Surrogates-overview","page":"Surrogate models","title":"Surrogates overview","text":"warning: Warning\nThe surrogate model optimization does not work well for most XSPEC models currently. This is being actively developed.\n\nAny function may be wrapped as a surrogate model using the SurrogateSpectralModel type.\n\nTo facilitate easy surrogate builds, SpectralFitting exports a number of utility functions.","category":"section"},{"location":"models/surrogate-models/#Creating-a-surrogate-for-XS_PhotoelectricAbsorption","page":"Surrogate models","title":"Creating a surrogate for XS_PhotoelectricAbsorption","text":"Before we start, let us discuss a number of benefits the use of surrogate models may bring us:\n\nSurrogateSpectralModel permit use of automatic differentiation.\nSurrogate models may be allocation-free depending on setup, whereas XSPEC wrappers will always have to allocate for type-conversions.\nSurrogate models may be considerably faster, especially for table models.\nSurrogate models are shareable (see Sharing surrogate models), and are tunable in size.\n\nXS_PhotoelectricAbsorption is an XSPEC model that is wrapped by a thin C-wrapper into Julia. The implementation of this model is a number of Fortran routines from the late 90s, including a tabulation of ~3000 lines of data that has been copied directly into the Fortran source code.\n\nThe performance of this model represents its complexity.\n\nusing SpectralFitting, XSPECModels\n\nenergy = collect(range(0.1, 20.0, 200))\nmodel = XS_PhotoelectricAbsorption()\n\nflux = similar(energy)[1:end-1]\n\nBenchmarking with BenchmarkTools.jl:\n\nusing BenchmarkTools\n@benchmark invokemodel!($flux, $energy, $model)\n\nThe surrogate we'll construct will have to be tailored a little to the data we wish to fit, as we need to specify the parameter ranges our surrogate should learn. For example, we might be interested in energies between 01 and 20 keV (expressed in our domain), with equivalent hydrogen column etaH anywhere between 10^-3 and 30. We specify the parameter bounds using tuples:\n\nlower_bounds = (1e-3,)\nupper_bounds = (30.0,)\nnothing # hide\n\nnote: Note\nThe first index is always the energy bounds, and the subsequent indices are the parameters in the same order they are defined in the model structure.\n\nNext, we use make_surrogate_harness to build and optimize a surrogate function for our model. By default, the surrogate uses linear radial basis functions, and seeds the coefficients with a number of seed points. This function then improves the accuracy of the model using optimize_accuracy!, until a maximal number of iterations has been reached.\n\nFor illustration purposes, we'll omit the accuracy improving step, and perform this ourselves. We can do this by setting optimization_samples = 0 in the keyword arguments:\n\nusing Surrogates\n\nharness = make_surrogate_harness(\n    (x, y) -> RadialBasis(x, y, lower_bounds, upper_bounds),\n    energy,\n    model,\n    lower_bounds,\n    upper_bounds;\n    # default is 50, but to illustrate the training behaviour we'll set this low\n    seed_samples = 2,\n)\n\n# number of points the surrogate has been trained on\nlength(harness.surrogate.x)\n\nWe can examine how well our surrogate reconstructs the model for a given test parameter:\n\nusing Plots\n# random test value\nηh_test = 22.9\n\nmodel.ηH.value = ηh_test\nf = invokemodel(energy, model)\n\nf̂ = harness.surrogate([ηh_test])\n\np = plot(energy[1:end-1], f, label=\"model\", legend=:bottomright, xlabel=\"E (keV)\") # hide\nplot!(energy[1:end-1], f̂, label=\"surr\") # hide\np # hide\n\nNow we'll use optimize_accuracy! to improve the faithfulness of our surrogate. This requires making use of wrap_model_as_objective as a little wrapper around our model:\n\noptimize_accuracy!(harness; maxiters=50)\n\nlength(harness.surrogate.x)\n\nWe can plot the surrogate model again and see the improvement.\n\nnew_f̂ = harness.surrogate([ηh_test])\nplot!(energy[1:end-1], new_f̂, label=\"surr+\") # hide\np # hide\n\nTight. We can also inspect the memory footprint of our model:\n\n# in bytes\nBase.summarysize(harness) \n\nThis may be reduced by lowering maxiters in optimize_accuracy! at the cost of decreasing faithfulness. However, compare this to the Fortran tabulated source file in the XSPEC source code, which is approximately 224 Kb. The surrogate model with all it's training data is of the same order.","category":"section"},{"location":"models/surrogate-models/#Using-a-surrogate-spectral-model","page":"Surrogate models","title":"Using a surrogate spectral model","text":"Now that we have the surrogate model, we use SurrogateSpectralModel to wrap it into an AbstractSpectralModel. The constructor also needs to know the model kind, have a copy of the model parameters, and know which symbols to represent the parameters with.\n\nsm = make_model(harness)\n\nWe can now use the familiar API and attempt to benchmark the performance:\n\n@benchmark invokemodel!($flux, $energy, $sm)\n\nComparing this to the initial benchmark of XS_PhotoelectricAbsorption, we see about a significant speedup, with no allocations, and this surrogate model is now automatic differentiation ready.","category":"section"},{"location":"models/surrogate-models/#Evaluating-the-model","page":"Surrogate models","title":"Evaluating the model","text":"p_range = collect(range(1.0, 30.0))\n\nfluxes_vecs = map(p_range) do p\n    model.ηH.value = p\n    f = invokemodel(energy, model)\nend\nfluxes_mat = reduce(hcat, fluxes_vecs)\n\nsurface(p_range, energy[1:end-1], fluxes_mat, xlabel = \"ηH\", ylabel = \"E\", zlabel = \"f\", title = \"Model\")\n\ns_fluxes_vecs = map(p_range) do p\n    sm.params[1].value = p\n    display(sm)\n    f = invokemodel(energy, sm)\nend\ns_fluxes_mat = reduce(hcat, s_fluxes_vecs)\n\nsurface(p_range, energy[1:end-1], s_fluxes_mat, xlabel = \"ηH\", ylabel = \"E\", zlabel = \"f\", title = \"Surrogate\")","category":"section"},{"location":"models/surrogate-models/#Sharing-surrogate-models","page":"Surrogate models","title":"Sharing surrogate models","text":"To export and import surrogate models, JLD2.jl is recommended.","category":"section"},{"location":"models/surrogate-models/#SpectralFitting.SurrogateSpectralModel","page":"Surrogate models","title":"SpectralFitting.SurrogateSpectralModel","text":"SurrogateSpectralModel <: AbstractSpectralModel\nSurrogateSpectralModel(modelkind, surrogate, params, params_symbols)\n\nUsed to wrap a surrogate function into an AbstractSpectralModel.\n\nExample\n\nCreating a surrogate function using make_surrogate_harness:\n\n# build and optimize a surrogate model\nsurrogate = make_surrogate_harness(model, lower_bounds, upper_bounds)\n\n# create surrogate spectral model\nsm = SurrogateSpectralModel(\n    Multiplicative(),\n    surrogate,\n    (FitParam(1.0),),\n    (:ηH,)\n)\n\nThe lower_bounds and upper_bounds must be tuples in the form (E, params...), where E denotes the bounds on the energy range to train over.\n\n\n\n\n\n","category":"type"},{"location":"models/surrogate-models/#SpectralFitting.make_surrogate_harness","page":"Surrogate models","title":"SpectralFitting.make_surrogate_harness","text":"make_surrogate_harness(\n    model::M,\n    lowerbounds::T,\n    upperbounds::T;\n    optimization_samples = 200,\n    seed_samples = 50,\n    S::Type = RadialBasis,\n    sample_type = SobolSample(),\n    verbose = false,\n)\n\nCreates and optimizes a surrogate model of type S for model, using wrap_model_as_objective and  optimize_accuracy! for optimization_samples iterations. Model is initially seeded with seed_samples points prior to optimization.\n\nwarning: Warning\nAdditive models integrate energies to calculate flux, which surrogate models are currently not capable of. Results for Additive models likely to be inaccurate. This will be patched in a future version.\n\n\n\n\n\n","category":"function"},{"location":"models/surrogate-models/#SpectralFitting.optimize_accuracy!","page":"Surrogate models","title":"SpectralFitting.optimize_accuracy!","text":"optimize_accuracy!(\n    surr::AbstractSurrogate,\n    obj::Function,\n    lb,\n    ub;\n    sample_type::SamplingAlgorithm = SobolSample(),\n    maxiters = 200,\n    N_truth = 5000,\n    verbose = false,\n)\n\nImprove accuracy (faithfullness) of the surrogate model in recreating the objective function.\n\nSamples a new space of N_truth points between lb and ub, and calculates the objective function obj at each. Finds the point with largest MSE between surrogate and objective, and adds the point to the surrogate pool. Repeats maxiters times, adding maxiters points to surrogate model.\n\nOptionally print to stdout the MSE and iteration count with verbose = true.\n\nNote that upper- and lower-bounds should be in the form (E, params...), where E is a single energy and params are the model parameters.\n\n\n\n\n\n","category":"function"},{"location":"models/models/#Model-index","page":"Model index","title":"Model index","text":"Models wrapped from XSPEC implementations are prefixed with XS_*, whereas pure-Julia models are simply named, e.g. XS_PowerLaw in XSPEC vs PowerLaw in Julia.\n\nThe available models are\n\nPages = [\"models.md\"]\nOrder = [:type]","category":"section"},{"location":"models/models/#Julia-models","page":"Model index","title":"Julia models","text":"","category":"section"},{"location":"models/models/#Additive","page":"Model index","title":"Additive","text":"","category":"section"},{"location":"models/models/#Multiplicative","page":"Model index","title":"Multiplicative","text":"","category":"section"},{"location":"models/models/#Convolutional","page":"Model index","title":"Convolutional","text":"","category":"section"},{"location":"models/models/#Utility","page":"Model index","title":"Utility","text":"","category":"section"},{"location":"models/models/#Generating-model-fingerprints","page":"Model index","title":"Generating model fingerprints","text":"To generate the unicode plot to add as a fingerprint, we use a simple function:\n\nusing SpectralFitting, UnicodePlots\n\nfunction plotmodel(energy, model)\n    flux = invokemodel(energy, model)\n    lineplot(\n        energy[1:end-1],\n        flux,\n        title=String(Base.typename(typeof(model)).name),\n        xlabel=\"E (keV)\",\n        canvas=DotCanvas\n    )\nend\n\n# e.g. for XS_PowerLaw()\nenergy = collect(range(0.1, 20.0, 100))\nplotmodel(energy, PowerLaw())","category":"section"},{"location":"models/models/#SpectralFitting.BlackBody","page":"Model index","title":"SpectralFitting.BlackBody","text":"BlackBody\n\nK: Normalisation.\nkT: Temperature (keV).\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, BlackBody())\n\n                        BlackBody\n       ┌────────────────────────────────────────┐\n   0.2 │                                        │\n       │                                        │\n       │                                        │\n       │                                        │\n       │                                        │\n       │                                        │\n       │      .:''':..                          │\n       │     :'      '':.                       │\n       │   .'           ':.                     │\n       │  .:               '..                  │\n       │  :                  ':.                │\n       │ .'                     ':..            │\n       │ :                         ''...        │\n       │:                              '''....  │\n     0 │:                                    '''│\n       └────────────────────────────────────────┘\n        0                                     20\n                         E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/models/#SpectralFitting.BremsStrahlung","page":"Model index","title":"SpectralFitting.BremsStrahlung","text":"BremsStrahlung\n\nK: Normalisation.\nkT: Temperature (keV).\nab: Helium to hydrogen ratio\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, BremsStrahlung())\n\n                   BremsStrahlung\n     ┌────────────────────────────────────────┐\n   3 │.                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │ :                                      │\n   0 │ ':.....................................│\n     └────────────────────────────────────────┘\n      0                                     20\n                       E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/models/#SpectralFitting.DeltaLine","page":"Model index","title":"SpectralFitting.DeltaLine","text":"DeltaLine\n\n_width\nK: Normalisation.\nE: Energy at which the delta function spikes.\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, DeltaLine())\n\n                        DeltaLine\n       ┌────────────────────────────────────────┐\n   0.4 │         .                              │\n       │         :                              │\n       │         :                              │\n       │         :                              │\n       │         :                              │\n       │         :                              │\n       │         ::                             │\n       │         ::                             │\n       │         ::                             │\n       │         ::                             │\n       │         ::                             │\n       │         ::                             │\n       │         ::                             │\n       │         ::                             │\n     0 │.........::.............................│\n       └────────────────────────────────────────┘\n        0                                     20\n                         E (keV)\n\nnote: Note\nThe DeltaLine model is not a true delta function, as this would be extremely difficult to define in a numerical model that needs to be able to propagate gradients. Instead, it is a very narrow GaussianLine model.\n\n\n\n\n\n","category":"type"},{"location":"models/models/#SpectralFitting.GaussianLine","page":"Model index","title":"SpectralFitting.GaussianLine","text":"GaussianLine\n\nK: Normalisation.\nμ: Mean\nσ: Standard deviation\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, GuassianLine())\n\n                       GaussianLine\n        ┌────────────────────────────────────────┐\n   0.09 │                                        │\n        │            ..                          │\n        │           .':                          │\n        │           : :                          │\n        │           : '.                         │\n        │          .'  :                         │\n        │          :   :                         │\n        │          :   :                         │\n        │          :   '.                        │\n        │         :     :                        │\n        │         :     :                        │\n        │         :     :                        │\n        │        .'      :                       │\n        │        :       '.                      │\n      0 │.......:         :......................│\n        └────────────────────────────────────────┘\n         0                                     20\n                          E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/models/#SpectralFitting.PowerLaw","page":"Model index","title":"SpectralFitting.PowerLaw","text":"PowerLaw\n\nK: Normalisation.\na: Photon index.\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, PowerLaw())\n\n                        PowerLaw\n       ┌────────────────────────────────────────┐\n   0.5 │                                        │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │ :                                      │\n       │ :                                      │\n       │  :                                     │\n       │   :.                                   │\n       │    ':..                                │\n       │        ''':......                      │\n       │                  ''''''''''''''........│\n     0 │                                        │\n       └────────────────────────────────────────┘\n        0                                     20\n                         E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/models/#SpectralFitting.PhotoelectricAbsorption","page":"Model index","title":"SpectralFitting.PhotoelectricAbsorption","text":"PhotoelectricAbsorption\n\ntable\nηH: Equivalent hydrogen column (units of 10²² atoms per cm⁻²).\n\n\n\n\n\n","category":"type"},{"location":"models/models/#SpectralFitting.Log10Flux","page":"Model index","title":"SpectralFitting.Log10Flux","text":"Log10Flux\n\nUsed to measure the (log) flux of the models it is applied to. Note that the additive components must have their normalisations frozen for this model to work properly.\n\nE_min\nE_max\nlog10Flux\n\nExample\n\nmodel = PowerLaw()\nmodel.K.frozen = true\n\nflux_model = Log10Flux()(model)\n\n\n\n\n\n","category":"type"},{"location":"models/models/#SpectralFitting.register_model_data","page":"Model index","title":"SpectralFitting.register_model_data","text":"SpectralFitting.register_model_data(M::Type{<:AbstractSpectralModel}, model_data::ModelDataInfo...)\nSpectralFitting.register_model_data(M::Type{<:AbstractSpectralModel}, remote_and_local::Tuple{String,String}...)\nSpectralFitting.register_model_data(M::Type{<:AbstractSpectralModel}, filenames::String...)\nSpectralFitting.register_model_data(s::Symbol, filenames::String...)\n\nRegister filenames as model data associated with the model given by type M or symbol s.  This function does not download any files, but rather adds the relevant filenames to a lookup which SpectralFitting.download_model_data consults when invoked, and consequently model data is only downloaded when needed.\n\nnote: Note\nIt is good practice to use this method immediately after defining a new model with @xspecmodel to register any required datafiles from the HEASoft source code, and therefore keep relevant information together.\n\nExample\n\n# by type\nregister_model_data(XS_Laor, \"ari.mod\")\n# by symbol\nregister_model_data(:XS_KyrLine, \"KBHline01.fits\")\n\n\n\n\n\n","category":"function"},{"location":"models/models/#SpectralFitting.finite_diff_kernel!","page":"Model index","title":"SpectralFitting.finite_diff_kernel!","text":"finite_diff_kernel!(f::Function, flux, energy)\n\nCalculates the finite difference of the function f over the energy bin between the high and low bin edges, via\n\nc_i = f(E_itexthigh) - f(E_itextlow)\n\nsimilar to evaluating the limits of the integral between E_itexthigh and E_itextlow.\n\nThis utility function is primarily used for Additive models to ensure the flux per bin is normalised for the energy over the bin.\n\n\n\n\n\n","category":"function"},{"location":"models/models/#SpectralFitting.wrap_model_as_objective","page":"Model index","title":"SpectralFitting.wrap_model_as_objective","text":"wrap_model_as_objective(model::AbstractSpectralModel; ΔE = 1e-1)\nwrap_model_as_objective(M::Type{<:AbstractSpectralModel}; ΔE = 1e-1)\n\nWrap a spectral model into an objective function for building/optimizing a surrogate model. Returns an anonymous function taking the tuple (E, params...) as the argument, and returning a single flux value.\n\n\n\n\n\n","category":"function"},{"location":"examples/examples/#Spectral-fitting-examples","page":"Diverse examples","title":"Spectral fitting examples","text":"Below are a number of examples illustrating how this package may be used.","category":"section"},{"location":"examples/examples/#Using-the-model-library","page":"Diverse examples","title":"Using the model library","text":"The model library details a model algebra (see AbstractSpectralModelKind) for composing models together. An example use of this may be to construct a complex model from a series of simpler models, and invoke the models on a given energy grid:\n\nusing SpectralFitting\nusing Plots \n\nmodel = PhotoelectricAbsorption() * (PowerLaw() + BlackBody()) \n\n# define energy grid\nenergy = collect(range(0.1, 12.0, 100))\n\nflux = invokemodel(energy, model)\n\nplot(energy[1:end-1], flux)\n\nNote this energy grid may be arbitrarily spaced, but, like XSPEC, assumes the bins are contiguous, i.e. that the high energy limit of one bin is the low energy limit of the next.\n\nThe full model library of available models is listed in Model index.","category":"section"},{"location":"parameters/#Parameters","page":"Parameters","title":"Parameters","text":"One of the core interface that SpectralFitting.jl provides are the model abstractions, and a method for controlling their parameters. Models are defined with a generic field type, so that they can be converted to primative types (e.g. Float64 or Float32) during evaluation. But whilst defining a model or a problem, the field type of all parameters is FitParam.","category":"section"},{"location":"parameters/#Parameter-binding","page":"Parameters","title":"Parameter binding","text":"When performing a fit, it is desireable to bind certain parameters together. This ensures that they will have the same value; for example, if you were fitting two simultaneous datasets with two PowerLaw models, you may want to have different normalisations of the model components, but enforce the power law index to be the same. To achieve this, SpectralFitting has the bind! function that applies to your FittingProblem.\n\nnote: Note\nBindings are treated not as specific to the model but specific to the FittingProblem. This is because you may want to use the same model for multiple different datasets, and have slightly different binding requirements for each one (e.g. depending on the instruments you are using). If you do need the same binding applied to two different problems, you can do that withappend!(prob1.bindings, prob2.bindings)Caution however, this will only make sense if you are using precisely the same model in both problems.\n\nLet's try it out. We'll generate some arbitrary powerlaw spectra with different normalisations and fit them simultaneously.\n\nusing SpectralFitting, Plots\n\nenergy = collect(range(0.1, 10.0, 100))\n\n# two different models with different normalisations\nmodel1 = PowerLaw(K = FitParam(100.0), a = FitParam(1.2))\nmodel2 = PowerLaw(K = FitParam(300.0), a = FitParam(2.0))\n\ndata1 = simulate(energy, model1, var = 1e-3, seed = 42)\ndata2 = simulate(energy, model2, var = 1e-3, seed = 42)\n\nplot(data1, xscale = :log10, yscale = :log10)\nplot!(data2, xscale = :log10, yscale = :log10)\n\nNow we want to fit a single powerlaw model to both of these spectra simultaneously, but with the powerlaw index fixed to be the same in both models.\n\nmodel = PowerLaw()\nprob = FittingProblem(model => data1, model => data2)\n\nbindall!(prob, :a)\nprob\n\nWe can get a better look at our model configuration by using the details method:\n\ndetails(prob)\n\nIn this printout we see that the a parameter of Model 2 is bound to the a parameter of Model 1.\n\nresult = fit(prob, LevenbergMarquadt())\n\nplot(data1, xscale = :log10, yscale = :log10)\nplot!(data2, xscale = :log10, yscale = :log10)\nplot!(result[1])\nplot!(result[2])\n\nNote that this fit is bad, because the underlying data have different power law indices, but our fit is required to enforce the models to have the same value. If we release this requirement, the fit will be much better, but the models will be entirely independent.\n\nprob = FittingProblem(model => data1, model => data2)\n\nresult = SpectralFitting.fit(prob, LevenbergMarquadt())\n\nplot(data1, xscale = :log10, yscale = :log10)\nplot!(data2, xscale = :log10, yscale = :log10)\nplot!(result[1])\nplot!(result[2])","category":"section"},{"location":"parameters/#Parameter-patching","page":"Parameters","title":"Parameter patching","text":"warning: Warning\nThe parameter patching interface is still experimental and will likely change in subsesquent versions of SpectralFitting.jl\n\nSometimes simply linking values is not sufficient, and you need to express a complex relationship between parameters. This is where ParameterPatch, a type of AbstractModelWrapper is useful.\n\nConsider the following\n\nusing SpectralFitting, Plots\n\nreal_model = GaussianLine(K = FitParam(2.0)) + GaussianLine(μ = FitParam(2.0), K = FitParam(4.0))\nenergy = collect(range(0.1, 10.0, 100))\n\ndata = simulate(energy, real_model; var = 4e-4, seed = 42)\nplot(data)\n\nWe can fit this simple dataset quite easily, but suppose we wanted to constrain the solution to have the normalisation of one model component be exactly twice that of the other. To achieve this, we can use a patch:\n\nfunction my_patch!(p)\n    p.a2.K = p.a1.K * 2\nend\n\n# reset the parameters so the fit starts \"fresh\"\nmodel = GaussianLine() + GaussianLine(μ = FitParam(3.0))\n\n# Wrap the model with a parameter patch\npatched_model = ParameterPatch(model; patch = my_patch!)\n# be sure to freeze any parameter you are planning to overwrite in a patch\npatched_model.a2.K.frozen = true\n\npatched_model\n\nThis can then be fit as usual:\n\nprob = FittingProblem(patched_model => data)\nresult = fit(prob, LevenbergMarquadt())\n\nplot!(result)\n\nTo apply the result with a parameter patch back on a model, use update_model! or apply_patch!\n\nupdate_model!(patched_model, result)\npatched_model","category":"section"},{"location":"parameters/#SpectralFitting.FitParam","page":"Parameters","title":"SpectralFitting.FitParam","text":"FitParam(\n    value;\n    # default error is 10%\n    error = 0.1 * value,\n    frozen = false,\n    lower_limit = 0,\n    upper_limit = Inf\n)\n\nA parameter of an AbstractSpectralModel. The fittable parameter can be used to control how a model will be invoked during fit, e.g. what rangers a parameter can take, whether they should be fronze, and so forth.\n\nnote: Note\nBe aware, not all fitting algorithms support \"boxed\" parameters, where the lower and upper limits are taken into account.\n\nTo link parameters together, see bind! or ParameterPatch.\n\nParameters can be modified in a model in the conventional way:\n\nmodel = PowerLaw()\n\n# set the value\nmodel.K = 2.0\n# set the error\nmodel.K.error = 0.3\n# set the lower bound\nmodel.K.lower_limit = 1.0\n\nAccessing the values in a generic function should use get_value.\n\nTo iterate over all parameters of a model, use parameter_vector.\n\nFields\n\nvalue: The value (i.e. mean) of the parameter.\nerror: The absolute (±, or standard deviation) error on the parameter.\nlower_limit: The lower limit the parameter can take.\nupper_limit: The upper limit the parameter can take.\nfrozen: Is this a frozen parameter during fits?\npatched: Is this parameter patched in some way?\n\nA FitParam is a fittable (or frozen) parameter of an AbstractSpectralModel. Every model will instantiate with FitParam as their parameter types so that they may be modified, bounded, frozen, or otherwise, as desired before a fit is attempted.\n\nThe following methods should be preferred over direct field access for a FitParam:\n\nset_value!\nget_value\nget_error\nget_lowerlimit\nget_upperlimit\nisfrozen\nisfree\n\n\n\n\n\n","category":"type"},{"location":"parameters/#SpectralFitting.bind!","page":"Parameters","title":"SpectralFitting.bind!","text":"bind!(prob::FittingProblem, pairs[, pairs...])\n\nBind parameters together within a FittingProblem. Parameters bound together will be mandated to have same value during the fit.\n\nThe binding must be specified in double or triple selector, which follow the format:\n\npair := (model_index, :component_name, :parameter_symbol)\n     := (model_index, :parameter_symbol)\n\nThe model_index is the index of the model in a multi-fit problem, i.e. 1, 2, and so on.\n\nThe component name is a CompositeModel model name, e.g. :a1, or :c3. This can be omitted if the model is not a CompositeModel.\n\nThe paramter symbol is a symbol representing the field of the parameter in the model. That is, :K or :log10Flux.\n\nBindings are specified using a chain of pairs (root) => (target) [=> (target)]. The root parameter is kept as is, and all subsequent paramters are bound to the root. Multiple chains of pairs may be specified in a single call to bind!, or, alternatively, multiple bindings may be specified with successive calls to bind!.\n\nBindings can be inspected with details.\n\nSee also bindall!.\n\nExamples\n\nBind model 1's K parameter to model 2's second additive model's K:\nbind!(prob, (1, :K) => (2, :a2, :K))\nBind model 3's :a2.K parameter to model4's :m3.L and model 6's :a1.a:\nbind!(prob, (3, :a2, :K) => (4, :m3, :K) => (6, :a1, :a))\n\nConsider the following two models\n\nmodel1 = PhotoelectricAbsorption() * (BlackBody() + PowerLaw())\nmodel2 = PhotoelectricAbsorption() * (PowerLaw() + PowerLaw())\n\nprob = FittingProblem(model1 => data1, model2 => data2)\n\n# Bind the power law indices in the two models\nbindall!(prob, :a)\n\n# Bind the normalisation of powerlaws in the 2nd model:\nbind!(prob, (2, :a1, :K) => (2, :a2, :K))\n\n# To inspect the overall bindings.\ndetails(prob)\n\nnote: Note\nOnly free parameters can be bound together.\n\n\n\n\n\n","category":"function"},{"location":"parameters/#SpectralFitting.bindall!","page":"Parameters","title":"SpectralFitting.bindall!","text":"bindall!(prob::FittingProblem, item[, item...])\n\nBind a common parameter across all models. The item is used to select the parameter to bind, and may either be a single symbol, or a model-symbol double.\n\nExamples\n\n# bind parameter `a` in all models\nbindall!(prob, :a)\n\n# bind parameter `K` in component `a3` in all models\nbindall!(prob, (:a3, :K))\n\n# multiple simultaneously\nbindall!(prob, :E, (:a2, :K))\n\n\n\n\n\n","category":"function"},{"location":"models/xspec-models/#XSPEC-models","page":"XSPEC models","title":"XSPEC models","text":"SpectralFitting can vendor the XSPEC model library through the utility package XSPECModels.jl. You can install this package directly from the University of Bristol's AstroRegistry:\n\npkg> registry add https://github.com/astro-group-bristol/AstroRegistry\npkg> add XSPECModels\n\nUsing the package is straight forward once installed:\n\nusing SpectralFitting, XSPECModels\n\nnote: Note\nThe convention is that models that have are imported from XSPEC or have XSPEC ABI are prefixed with XS_ in their name. For example, the XSPEC equivalent of PowerLaw is XS_PowerLaw.\n\nThe XSPEC models are wrapped into SpectralFitting models using the [@xspecmodel] macro. If a model you require is not already wrapped, this macro will make that easy to do. Please consider upstreaming your wrapper via a PR to the SpectralFitting GitHub repository.\n\nXSPEC models frequently have tabular data dependencies, without which the models fail to invoke (see Model data availability). If the data files are known but not present, the XSPEC models will throw an error with instructions for downloading the missing data. If the data files are unknown, Julia may crash catastrophically. If this is the case, often a single line will be printed with the LibXSPEC error, specifying the name of the missing source file. This can be registered as a data dependency of a model using SpectralFitting.register_model_data.\n\nThe first time any XSPEC model is invoked, SpectralFitting checks to see whether requisite data is needed, and whether the data is downloaded. Subsequent calls will hit a lookup cache instead to avoid run-time costs of performing this check.","category":"section"},{"location":"models/xspec-models/#Additive","page":"XSPEC models","title":"Additive","text":"","category":"section"},{"location":"models/xspec-models/#XSPECModels.@xspecmodel","page":"XSPEC models","title":"XSPECModels.@xspecmodel","text":"@xspecmodel [type=Float64] [ff_call_site] model\n\nUsed to wrap additional XSPEC models, generating the needed AbstractSpectralModel implementation.\n\nThe type keyword specifies the underlying type to coerce input and output arrays to, as different implementations may have incompatible number of bits. The ff_call_site is the foreign fuction call site, which is the first argument to ccall, and follows the same conventions. The model is a struct, which must subtype AbstractSpectralModel.\n\nIf the callsite is not specified, the user must implement _unsafe_ffi_invoke!.\n\nExamples\n\n@xspecmodel :C_powerlaw struct XS_PowerLaw{T} <: AbstractSpectralModel{T, Additive}\n    \"Normalisation.\"\n    K::T\n    \"Photon index.\"\n    a::T\nend\n\n# constructor has default values\nfunction XS_PowerLaw(; K = FitParam(1.0), a = FitParam(1.0))\n    XS_PowerLaw{typeof(K)}(K, a)\nend\n\nWe define a new structure XS_PowerLaw with two parameters, but since the model is Additive, only a single parameter (a) is passed to the XSPEC function. The function we bind to this model is :C_powerlaw from the XSPEC C wrappers.\n\nThe macro will then generate the following functions\n\nimplementation\ninvoke!\n_safe_ffi_invoke!\n\nIf a callsite was specified, it will also generate:\n\n_unsafe_ffi_invoke!\n\n\n\n\n\n","category":"macro"},{"location":"models/xspec-models/#XSPECModels.XS_PowerLaw","page":"XSPEC models","title":"XSPECModels.XS_PowerLaw","text":"XS_PowerLaw(K, a)\n\nK: Normalisation.\na: Photon index.\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_PowerLaw())\n\n                      XS_PowerLaw\n       ┌────────────────────────────────────────┐\n   0.5 │                                        │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │ :                                      │\n       │ :                                      │\n       │  :                                     │\n       │   :.                                   │\n       │    ':..                                │\n       │        ''':......                      │\n       │                  ''''''''''''''........│\n     0 │                                        │\n       └────────────────────────────────────────┘\n        0                                     20\n                         E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/xspec-models/#XSPECModels.XS_BlackBody","page":"XSPEC models","title":"XSPECModels.XS_BlackBody","text":"XS_BlackBody(K, T)\n\nK: Normalisation.\nT: Temperature (keV).\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_BlackBody())\n\n                      XS_BlackBody\n       ┌────────────────────────────────────────┐\n   0.2 │                                        │\n       │                                        │\n       │                                        │\n       │                                        │\n       │                                        │\n       │                                        │\n       │      .:''':..                          │\n       │    .:       ''.                        │\n       │   .'           ':.                     │\n       │   :              ''..                  │\n       │  :                  ':.                │\n       │ :                     '':.             │\n       │.:                         ''..         │\n       │:                              '':....  │\n     0 │'                                    '''│\n       └────────────────────────────────────────┘\n        0                                     20\n                         E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/xspec-models/#XSPECModels.XS_BremsStrahlung","page":"XSPEC models","title":"XSPECModels.XS_BremsStrahlung","text":"XS_BremsStrahlung(K, T)\n\nK: Normalisation.\nT: Plasma temperature (keV).\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_BremsStrahlung())\n\n                  XS_BremsStrahlung\n     ┌────────────────────────────────────────┐\n   2 │                                        │\n     │.                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │'.                                      │\n     │ :                                      │\n   0 │  ':....................................│\n     └────────────────────────────────────────┘\n      0                                     20\n                       E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/xspec-models/#XSPECModels.XS_Gaussian","page":"XSPEC models","title":"XSPECModels.XS_Gaussian","text":"XS_Gaussian(K, E, σ)\n\nK: Normalisation\nE: Line energy in keV.\nσ: Line width in keV.\n\nExample\n\nenergy = collect(range(4.0, 8.0, 100))\ninvokemodel(energy, XS_Gaussian())\n\n                        XS_Gaussian\n        ┌────────────────────────────────────────┐\n   0.09 │                                        │\n        │            .                           │\n        │           : :                          │\n        │           : :                          │\n        │           : '.                         │\n        │          .'  :                         │\n        │          :   :                         │\n        │          :   :                         │\n        │          :   '.                        │\n        │         :     :                        │\n        │         :     :                        │\n        │         :     :                        │\n        │        .'      :                       │\n        │        :       :                       │\n      0 │.......:         :......................│\n        └────────────────────────────────────────┘\n         0                                     20\n                          E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/xspec-models/#XSPECModels.XS_Laor","page":"XSPEC models","title":"XSPECModels.XS_Laor","text":"XS_Laor(K, lineE, a, inner_r, outer_r, incl)\n\nK: Normalisation.\nlineE: Rest frame line energy (keV).\na: Power law dependence of emissivity. Scales R⁻ᵅ.\ninner_r: Inner radius of the accretion disk (GM/c).\nouter_r: Outer radius of the accretion disk (GM/c).\nθ: Disk inclination angle to line of sight (degrees, 0 is pole on).\n\nExample\n\nenergy = collect(range(0.1, 10.0, 100))\ninvokemodel(energy, XS_Laor())\n\n                          XS_Laor\n        ┌────────────────────────────────────────┐\n   0.06 │                                        │\n        │                                        │\n        │                         ::             │\n        │                         ::             │\n        │                        : :             │\n        │                       :  :             │\n        │                      :   :             │\n        │                     :'   :             │\n        │                   .:     :             │\n        │                  :'      :             │\n        │                .'        :             │\n        │              .:'         :             │\n        │            ..'           :             │\n        │          .:'              :            │\n      0 │.......:''                 :............│\n        └────────────────────────────────────────┘\n         0                                     10\n                          E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/xspec-models/#XSPECModels.XS_DiskLine","page":"XSPEC models","title":"XSPECModels.XS_DiskLine","text":"XS_DiskLine(K, lineE, β, inner_r, outer_r, incl)\n\nK: Normalisation.\nlineE: Rest frame line energy (keV).\nβ: Power law dependence of emissivity. If < 10, scales Rᵅ.\ninner_r: Inner radius of the accretion disk (GM/c).\nouter_r: Outer radius of the accretion disk (GM/c).\nθ: Disk inclination angle to line of sight (degrees, 0 is pole on).\n\nExample\n\nenergy = collect(range(4.0, 8.0, 100))\ninvokemodel(energy, XS_DiskLine())\n\n                        XS_DiskLine\n        ┌────────────────────────────────────────┐\n   0.09 │                                        │\n        │                           .            │\n        │                           :            │\n        │                           ::           │\n        │                         . ::           │\n        │                         : ::           │\n        │                         :'':           │\n        │                        .'  :           │\n        │                        :    :          │\n        │                        :    :          │\n        │                       .'    :          │\n        │                       :     :          │\n        │                     .:      '.         │\n        │                   .:'        :         │\n      0 │...............:'''           :.........│\n        └────────────────────────────────────────┘\n         4                                      8\n                          E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/xspec-models/#XSPECModels.XS_PhotoelectricAbsorption","page":"XSPEC models","title":"XSPECModels.XS_PhotoelectricAbsorption","text":"XS_PhotoelectricAbsorption(ηH)\n\nηH: Equivalent hydrogen column (units of 10²² atoms per cm⁻²).\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_PhotoelectricAbsorption())\n\n             XS_PhotoelectricAbsorption\n     ┌────────────────────────────────────────┐\n   1 │       ...''''''''''''''''''''''''''''''│\n     │      .'                                │\n     │     :                                  │\n     │    :'                                  │\n     │    :                                   │\n     │   :                                    │\n     │   :                                    │\n     │   :                                    │\n     │  :                                     │\n     │  :                                     │\n     │  :                                     │\n     │  :                                     │\n     │  :                                     │\n     │ :                                      │\n   0 │.:                                      │\n     └────────────────────────────────────────┘\n      0                                     20\n                       E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/xspec-models/#XSPECModels.XS_WarmAbsorption","page":"XSPEC models","title":"XSPECModels.XS_WarmAbsorption","text":"XS_WarmAbsorption(ηH, Ew)\n\nηH: Equivalent hydrogen column (units of 10²² atoms per cm⁻²).\nEw: Window energy (keV).\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_WarmAbsorption())\n\n                    XS_WarmAbsorption\n       ┌────────────────────────────────────────┐\n     1 │':      ...''':'''''''''''''''''''''''''│\n       │ :    .:'                               │\n       │ :   .'                                 │\n       │ :  .:                                  │\n       │ :  :                                   │\n       │ :  :                                   │\n       │ : :                                    │\n       │ : :                                    │\n       │ : :                                    │\n       │ : :                                    │\n       │ ::                                     │\n       │ ::                                     │\n       │  :                                     │\n       │  :                                     │\n   0.2 │  :                                     │\n       └────────────────────────────────────────┘\n        0                                     20\n                         E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/xspec-models/#XSPECModels.XS_CalculateFlux","page":"XSPEC models","title":"XSPECModels.XS_CalculateFlux","text":"XS_CalculateFlux(E_min, E_max, lg10Flux)\n\nE_min: Minimum energy.\nE_max: Maximum energy.\nlog10Flux: log (base 10) flux in erg / cm^2 / s\n\n\n\n\n\n","category":"type"},{"location":"models/xspec-models/#XSPECModels.XS_KerrDisk","page":"XSPEC models","title":"XSPECModels.XS_KerrDisk","text":"XS_KerrDisk(K, lineE, index1, index2, break_r, a, θ, inner_r, outer_r)\n\nK: Normalisation.\nlineE: Rest frame line energy (keV).\nindex1: Emissivity index for inner disk.\nindex2: Emissivity index for outer disk.\nbreak_r: Break radius separating inner and outer disk (gᵣ).\na: Dimensionless black hole spin.\nθ: Disk inclination angle to line of sight (degrees).\ninner_r: Inner radius of the disk in units of rₘₛ.\nouter_r: Outer radius of the disk in units of rₘₛ.\nz: Redshift.\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_KerrDisk())\n\n                        XS_KerrDisk\n        ┌────────────────────────────────────────┐\n   0.05 │                                        │\n        │                                        │\n        │                                .       │\n        │                               .:       │\n        │                              :::       │\n        │                            .:' '.      │\n        │                           .:    :      │\n        │                         ..'     :      │\n        │                         :'      :      │\n        │                       .'        :      │\n        │                     .:'         :      │\n        │                  .:''           :      │\n        │               .::'              :      │\n        │            ..:'                 :      │\n      0 │.........:'''                    :......│\n        └────────────────────────────────────────┘\n         0                                      8\n                          E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/xspec-models/#XSPECModels.XS_KyrLine","page":"XSPEC models","title":"XSPECModels.XS_KyrLine","text":"XS_KyrLine(K, a, θ_obs, inner_r, ms_flag, outer_r, lineE, α, β, break_r, z, limb)\n\nK: Normalisation.\na: Dimensionless black hole spin.\nθ: Observer inclination (0 is on pole, degrees).\ninner_r: Inner radius of the disk in units of GM/c²\nms_flag: 0: integrate from rᵢₙ. 1: integrate from rₘₛ.\nouter_r: Outer radius of the disk in units of GM/c²\nlineE: Rest frame line energy (keV).\nα\nβ\nbreak_r: Break radius seperating inner and outer disk (GM/c²).\nz: Overall Doppler shift.\nlimb: 0: isotropic emission, 1: Laor's limb darkening, 2: Haard's limb brightening.\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_KyrLine())\n\n                        XS_KyrLine\n        ┌────────────────────────────────────────┐\n   0.05 │                                        │\n        │                                        │\n        │                                :       │\n        │                                :.      │\n        │                              :.':      │\n        │                             :'  :      │\n        │                            :    :      │\n        │                          .'     :      │\n        │                        .:'      :      │\n        │                       .'        :      │\n        │                     .:          :      │\n        │                   .'            :      │\n        │                .:'              :      │\n        │            ..:'                 :      │\n      0 │.........:'''                    :......│\n        └────────────────────────────────────────┘\n         0                                      8\n                          E (keV)\n\n\n\n\n\n","category":"type"},{"location":"transitioning-from-xspec/#Transitioning-from-XSPEC","page":"Transitioning from XSPEC","title":"Transitioning from XSPEC","text":"","category":"section"},{"location":"examples/optimizers/#Optimizer-galore","page":"Optimizer galore","title":"Optimizer galore","text":"Let's fit a spectrum:\n\nusing SpectralFitting, Plots\n\nDATADIR = \"...\"\nDATADIR = length(get(ENV, \"CI\", \"\")) > 0 ? @__DIR__() * \"/../../ex-datadir\" : \"/home/lilith/Developer/jl/datasets/xspec/walkthrough\" # hide\nspec1_path = joinpath(DATADIR, \"s54405.pha\")\ndata = OGIPDataset(spec1_path) \nnormalize!(data)\n\nmask_energies!(data, 1, 15)\n\n# a plotting utility\nmy_plot(data) = plot(\n    data, \n    xscale = :log10, \n    yscale = :log10,\n    ylims = (1e-3, 1.3)\n)\n\nmy_plot(data)","category":"section"},{"location":"examples/sherpa-example/#A-quick-guide-to-modelling-and-fitting-in-SpectralFitting.jl","page":"A quick guide","title":"A quick guide to modelling and fitting in SpectralFitting.jl","text":"This is SpectralFitting.jl version of A quick guide to modeling and fitting in Sherpa.\n\nusing SpectralFitting, Plots\nusing Random\nRandom.seed!(0)\n\nx = collect(range(-5, 5, 200))\n\nA_true = 3.0\npos_true = 1.3\nsigma_true = 0.8\nerr_true = 0.2\n\ny = @. A_true * exp(-(x - pos_true)^2 / (2 * sigma_true^2))\n\ny_noisy = y .+ (0.2 * randn(length(y)))\n\nscatter(x, y_noisy)\n\nTo make this into a fittable dataset, we observe that our layout is injective (i.e. length(x) == length(y)). This is subtly different from how the majority of spectral models are implemented, which usually assume some kind of binning (length(x) == length(y) + 1). Fortunately, SpectralFitting.jl can track this for us, and do various conversion to make the models work correctly for the data. We need only tell the package what our AbstractDataLayout is:\n\ndata = InjectiveData(x, y_noisy; name = \"example\")\n\nThe data prints the data card, which provides us some high level information about our data at a glance. We can plot the data trivially using one of the Plots.jl recipes\n\nplot(data, markersize = 3)\n\nNext we want to specify a model to fit to this data. Models that are prefixed with XS_ are models that are linked from the XSPEC model library, provided via LibXSPEC_jll. For a full list of the models, see Models index.\n\nwarning: Warning\nIt is advised to use the Julia implemented models. This allows various calculations to benefit from automatic differentiation, efficient multi-threading, GPU offloading, and various other useful things, see Why & how.\n\nmodel = GaussianLine(μ = FitParam(0.0))\n\nWe can plot our model over the same domain range quite easily too:\n\nplot(data.domain[1:end-1], invokemodel(data.domain, model))\n\nNote that we've had to adjust the domain here. As stated before, most models are implemented for binned data, and therefore return one fewer bin than given.\n\nSpectralFitting.jl adopts the SciML problem-solver abstraction, so to fit a model to data we specify a FittingProblem:\n\nprob = FittingProblem(model => data)\n\nWe fit problem then by calling fit:\n\nresult = fit(prob, LevenbergMarquadt())\n\nThe result card tells us a little bit about how successful the fit was. We further inspect the fit by overplotting result on the data:\n\nplot(data, markersize = 3)\nplot!(result)\n\nWe can create a contour plot of the fit statistic by evaluating the result everywhere on the grid and measuring the statistic:\n\namps = range(50, 200, 50)\ndevs = range(0.5, 1.2, 50)\n\nstats = [\n    measure(ChiSquared(), result, [a, result.u[2], d])\n    for d in devs, a in amps\n]\n\n# 1, 2, and 3 sigma contours\nlevels = [2.3, 4.61, 9.21]\ncontour(\n    amps, \n    devs, \n    stats .- sum(result.stats), \n    levels = levels, \n    xlabel = \"K\", \n    ylabel = \"σ\"\n)\nscatter!([result.u[1]], [result.u[3]])","category":"section"},{"location":"models/composite-models/#Composite-models","page":"Composite models","title":"Composite models","text":"The model algebra defined by the AbstractSpectralModelKind yields instances of CompositeModel, nested to various degrees. These composite models are designed to make as much information about the spectral model available at compile-time, such that rich and optimized generated functions may be assembled purely from the Julia types (see Why & how).","category":"section"},{"location":"models/composite-models/#SpectralFitting.CompositeModel","page":"Composite models","title":"SpectralFitting.CompositeModel","text":"CompositeModel{T,K,Op,M1,M2} <: AbstractSpectralModel{T,K}\nCompositeModel(left_model, right_model, op::AbstractCompositeOperator)\n\nType resulting from operations combining any number of AbstractSpectralModel via the model algebra defined from AbstractSpectralModelKind.\n\nmodel = PhotoelectricAbsorption() * (PowerLaw() + BlackBody())\ntypeof(model) <: CompositeModel # true\n\nEach operation binary operation in the model algebra is encoded in the parametric types of the CompositeModel, where the operation is given by an AbstractCompositeOperator.  Composite models adopt the model kind of the right model, i.e. M2, and obey the model algebra accordingly.\n\nComposite models very rarely need to be constructed directly, and are instead obtained by regular model operations.\n\nThe propertynames and getproperty methods for CompositeModel are overwritten to access all models in the model tree. For example:\n\njulia> propertynames(PowerLaw() + DeltaLine())\n(:a1, :a2)\n\nCompositeModel has destructure for working abstractly with model trees.\n\n\n\n\n\n","category":"type"},{"location":"models/composite-models/#SpectralFitting.AbstractCompositeOperator","page":"Composite models","title":"SpectralFitting.AbstractCompositeOperator","text":"abstract type AbstractCompositeOperator\n\nSuperype of all composition operators. Used to implement the model algebra of AbstractSpectralModelKind through a trait system.\n\nThe Julia symbol corresponding to a given AbstractCompositeOperator may be obtained through operation_symbol.\n\n\n\n\n\n","category":"type"},{"location":"models/composite-models/#SpectralFitting.AdditionOperator","page":"Composite models","title":"SpectralFitting.AdditionOperator","text":"AdditionOperator <: AbstractCompositeOperator\nAdditionOperator()\n\nCorresponds to the :(+) symbol.\n\n\n\n\n\n","category":"type"},{"location":"models/composite-models/#SpectralFitting.MultiplicationOperator","page":"Composite models","title":"SpectralFitting.MultiplicationOperator","text":"MultiplicationOperator <: AbstractCompositeOperator\nMultiplicationOperator()\n\nCorresponds to the :(*) symbol.\n\n\n\n\n\n","category":"type"},{"location":"models/composite-models/#SpectralFitting.ConvolutionOperator","page":"Composite models","title":"SpectralFitting.ConvolutionOperator","text":"ConvolutionOperator <: AbstractCompositeOperator\nConvolutionOperator()\n\nHas no corresponding symbol, since it invokes a function call C(A).\n\n\n\n\n\n","category":"type"},{"location":"models/composite-models/#SpectralFitting.operation_symbol","page":"Composite models","title":"SpectralFitting.operation_symbol","text":"operation_symbol(::AbstractCompositeOperator)\noperation_symbol(::Type{<:AbstractCompositeOperator})\n\nObtain the model symbol from a given AbstractCompositeOperator.\n\n\n\n\n\n","category":"function"},{"location":"datasets/datasets/#Datasets","page":"Using datasets","title":"Datasets","text":"SpectralFitting.jl supports a wide variety of datasets, and makes it easy to wrap your own.\n\nFor spectral fitting specifics, the main dataset type is","category":"section"},{"location":"datasets/datasets/#Dataset-abstraction","page":"Using datasets","title":"Dataset abstraction","text":"Datasets must define a small API to make fitting possible. The picture to have in mind when considering the different domains is as follows: the model is trying to predict the objective. It does so by taking in input domain and maps it to some output domain.\n\nThat means make_output_domain and make_objective_domain correspond to the (XY) values of the data that the model is trying to fit, whilst the model is evaluated on the make_model_domain, which need not be the same as the output domain.\n\nIn other cases, the objective_transformer acts to transform the output of the model onto the output domain. \n\nMathematically, expressing the output domain X, the model domain D, the model output M(D) and objective S, along with the transformer as T, then the relationship between the different domains is\n\nhatS = T times M(D)\n\nBoth hatS and S are defined over X. The various fitting operations try to find model paramters that make hatS and S as close as possible.","category":"section"},{"location":"datasets/datasets/#Underlying-data-layouts","page":"Using datasets","title":"Underlying data layouts","text":"","category":"section"},{"location":"datasets/datasets/#SpectralFitting.SpectralData","page":"Using datasets","title":"SpectralFitting.SpectralData","text":"SpectralData{T} <: AbstractDataset\n\nA general spectral data structure, minimally with a Spectrum and ResponseMatrix. Optionally also includes the AncillaryResponse and a background Spectrum.\n\nMethods\n\nThe following methods are made available through the SpectralData:\n\nregroup!\nrestrict_domain!\nmask_energies!\ndrop_channels!\ndrop_bad_channels!\ndrop_negative_channels!\nnormalize!\nobjective_units\nspectrum_energy\nbin_widths\nsubtract_background!\nset_domain!\nerror_statistic\n\nConstructors\n\nThe available constructors are:\n\nSpectralData(paths::SpectralDataPaths; kwargs...)\n\nUsing SpectralDataPaths.\n\nIf the spectrum and repsonse matrix have already been loaded seperately, use\n\nSpectralData(\n    spectrum::Spectrum,\n    response::ResponseMatrix;\n    # try to match the domains of the response matrix to the data\n    match_domains = true,\n    background = nothing,\n    ancillary = nothing,\n)\n\n\n\n\n\n","category":"type"},{"location":"datasets/datasets/#SpectralFitting.AbstractDataset","page":"Using datasets","title":"SpectralFitting.AbstractDataset","text":"abstract type AbstractDataset\n\nAbstract type for use in fitting routines. High level representation of some underlying data structures.\n\nFitting data is considered to have an objective and a domain. As the domain may be, for example, energy bins (high and low), or fourier frequencies (single value), the purpose of this abstraction is to provide some facility for translating between these representations for the models to fit with. This is done by checking that the AbstractDataLayout of the model and data are compatible, or at least have compatible translations.\n\nMust implement a minimal set of accessor methods. These are paired with objective and domain parlance. Note that these functions are prefixed with make_* and not get_* to represent that there may be allocations or work going into the translation. Usage of these functions should be sparse in the interest of performance.\n\nThe arrays returned by the make_* functions must correspond to the AbstractDataLayout specified by the caller.\n\nmake_objective_variance\nmake_objective\nmake_domain_variance\nmake_model_domain\nmake_ouput_domain\n\nAdditionally there is an objective transformer that transforms the output of the model onto the output domain:\n\nobjective_transformer\n\nFinally, to make all of the fitting for different statistical regimes work efficiently, datasets should inform which units are preferred to fit. They may also give the error statistics they prefer, and a label name primarily used to disambiguate:\n\npreferred_units\nerror_statistic\nmake_label\n\n\n\n\n\n","category":"type"},{"location":"datasets/datasets/#SpectralFitting.make_objective_variance","page":"Using datasets","title":"SpectralFitting.make_objective_variance","text":"make_objective_variance(layout::AbstractDataLayout, dataset::AbstractDataset)\n\nMake the variance vector associated with each objective point.\n\n\n\n\n\n","category":"function"},{"location":"datasets/datasets/#SpectralFitting.make_objective","page":"Using datasets","title":"SpectralFitting.make_objective","text":"make_objective(layout::AbstractDataLayout, dataset::AbstractDataset)\n\nReturns the array used as the target for model fitting. The array must correspond to the data AbstractDataLayout specified by the layout parameter.\n\nIn as far as it can be guarunteed, the memory in the returned array will not be mutated by any fitting procedures.\n\nDomain for this objective should be returned by make_model_domain.\n\n\n\n\n\n","category":"function"},{"location":"datasets/datasets/#SpectralFitting.make_domain_variance","page":"Using datasets","title":"SpectralFitting.make_domain_variance","text":"make_domain_variance(layout::AbstractDataLayout, dataset::AbstractDataset)\n\nMake the variance vector associated with the domain.\n\n\n\n\n\n","category":"function"},{"location":"datasets/datasets/#SpectralFitting.make_model_domain","page":"Using datasets","title":"SpectralFitting.make_model_domain","text":"make_model_domain(layout::AbstractDataLayout, dataset::AbstractDataset)\n\nReturns the array used as the domain for the modelling. This is paired with make_domain_variance\n\n\n\n\n\n","category":"function"},{"location":"datasets/datasets/#SpectralFitting.make_output_domain","page":"Using datasets","title":"SpectralFitting.make_output_domain","text":"make_output_domain(layout::AbstractDataLayout, dataset::AbstractDataset)\n\nReturns the array used as the output domain. That is, in cases where the model input and output map to different domains, the input domain is said to be the model domain, the input domain is said to be the model domain.\n\nThe distinction is mainly used for the purposes of simulating data and for visualising data.\n\n\n\n\n\n","category":"function"},{"location":"datasets/datasets/#SpectralFitting.AbstractDataLayout","page":"Using datasets","title":"SpectralFitting.AbstractDataLayout","text":"abstract type AbstractDataLayout end\n\nThe data layout primarily concerns the relationship between the objective and the domain. It is used to work out whether a model and a dataset are fittable, and if not, whether a translation in the output of the model to the domain of the model is possible.\n\nThe following methods may be used to interrogate support:\n\npreferred_support for inferring the preferred support of a model when multiple supports are possible.\ncommon_support to obtain the common support of two structures\n\nThe following method is also used to define the support of a model or dataset:\n\nsupports\n\nFor cases where unit information needs to be propagated, an AbstractDataLayout can also be used to ensure the units are compatible. To query the units of a layout, use\n\nsupport_units\n\n\n\n\n\n","category":"type"},{"location":"datasets/datasets/#SpectralFitting.OneToOne","page":"Using datasets","title":"SpectralFitting.OneToOne","text":"struct OneToOne <: AbstractDataLayout end\n\nIndicates there is a one-to-one (injective) correspondence between each input value and each output value. That is to say\n\nlength(objective) == length(domain)\n\n\n\n\n\n","category":"type"},{"location":"datasets/datasets/#SpectralFitting.ContiguouslyBinned","page":"Using datasets","title":"SpectralFitting.ContiguouslyBinned","text":"struct ContiguouslyBinned <: AbstractDataLayout end\n\nContiguously binned data layout means that the domain describes high and low bins, with the objective being the value in that bin. This means\n\nlength(objective) + 1== length(domain)\n\nNote that the contiguous qualifer is to mean there is no gaps in the bins, and that\n\nDelta E_i = E_i+1 - E_i\n\n\n\n\n\n","category":"type"},{"location":"datasets/datasets/#SpectralFitting.common_support","page":"Using datasets","title":"SpectralFitting.common_support","text":"common_support(x, y)\n\nFind the common AbstractDataLayout of x and y, following the ordering of preferred_support.\n\n\n\n\n\n","category":"function"},{"location":"datasets/datasets/#SpectralFitting.preferred_support","page":"Using datasets","title":"SpectralFitting.preferred_support","text":"preferred_support(x)\n\nGet the preferred AbstractDataLayout of x. If multiple supports are available, the DEFAULT_SUPPORT_ORDERING is followed:\n\nDEFAULT_SUPPORT_ORDERING = (ContiguouslyBinned{Nothing}(nothing), OneToOne{Nothing}(nothing))\n\n\n\n\n\n","category":"function"},{"location":"datasets/datasets/#SpectralFitting.supports","page":"Using datasets","title":"SpectralFitting.supports","text":"supports(x::Type)\n\nUsed to define whether a given type has support for a specific AbstractDataLayout. Should return a tuple of the supported layouts. This method should be implemented to express new support, not the query method.\n\nTo query, there is\n\nsupports(layout::AbstractDataLayout, x)::Bool\n\nExample\n\nsupports(::Type{typeof(x)}) = (OneToOne(),)\n@assert supports(ContiguouslyBinned(), x) == false\n\n\n\n\n\n","category":"function"},{"location":"models/wrapper-models/#Wrapper-models","page":"Wrapper models","title":"Wrapper models","text":"Wrapper models are a type of \"meta-model\" that can be used to change the behaviour of other models. Their constructors commonly take a model as an argument, and change the way this model is called.\n\nThe following wrapper models are available\n\nPages = [\"wrapper-models.md\"]\nOrder = [:type]","category":"section"},{"location":"models/wrapper-models/#SpectralFitting.ParameterPatch","page":"Wrapper models","title":"SpectralFitting.ParameterPatch","text":"ParameterPatch(model; patch::Function)\n\nAn AbstractModelWrapper that can be used to manipulate the parameters of the model it wraps. For example\n\nmodel = PowerLaw() + PowerLaw()\n\nfunction patcher!(p)\n    # any arbitrary function may be defined here\n    p.a1.K = 3 * p.a2.K + sqrt(p.a2.a)\nend\n\npatched_model = ParameterPatch(model; patch = patcher!)\n\n# set the patched parameter as frozen so it is not fitted\n# failing to do so may ruin a fit\npatched_model.a1.K.frozen = true\n\nWhen the model is invoked, it will call the patch function to manipulate the parameters as desired.\n\nwarning: Warning\nThis wrapper is relatively new and not extensively tested. It should be noted nothing is done to validate if a parameter that you are modifying is actually a frozen parameter. This will change in the future, and parameters patched this way will be labelled as bound.\n\n\n\n\n\n","category":"type"},{"location":"models/wrapper-models/#SpectralFitting.apply_patch!","page":"Wrapper models","title":"SpectralFitting.apply_patch!","text":"apply_patch!(model::ParameterPatch)\n\nApply a patch to the model (i.e. use the patch! function to update the model parameters).\n\n\n\n\n\n","category":"function"},{"location":"models/wrapper-models/#SpectralFitting.AsConvolution","page":"Wrapper models","title":"SpectralFitting.AsConvolution","text":"AsConvolution(model; domain = collect(range(0, 2, 100)))\n\nTurn an additive model into a convolutional model.\n\nExample\n\nconvolution_model = AsConvolution(GaussianLine())\n\nThe above model will now convolve the GaussianLine model onto whatever it is applied to.\n\nThe domain keyword can be used to pass the domain on which to evaluate the wrapped model before convolution. The domain is such that x = 1 corresponds to no domain shift in the convolution (e.g., if the domain is energy, this would be the rest energy of a line).\n\n\n\n\n\n","category":"type"},{"location":"models/wrapper-models/#SpectralFitting.AutoCache","page":"Wrapper models","title":"SpectralFitting.AutoCache","text":"AutoCache\n\nUsed to automatically create a cache of another model, to avoid re-evaluating the model if the next parameters are close to the previous parameters. The intended use is for fitting expensive models which.\n\nExample\n\nmodel = PhotoelectricAbsorption() * AutoCache(PowerLaw())\n\nIn the above model, the PowerLaw component will be augmented with the caching behaviour.\n\n\n\n\n\n","category":"type"},{"location":"models/wrapper-models/#SpectralFitting.AbstractModelWrapper","page":"Wrapper models","title":"SpectralFitting.AbstractModelWrapper","text":"abstract type AbstractModelWrapper{M,T,K} <: AbstractSpectralModel{T,K} end\n\nUsed to implement wrapper models that take existing models as their argument and modify their behaviour.\n\n\n\n\n\n","category":"type"},{"location":"why-and-how/#Why-and-how","page":"Why & How","title":"Why & how","text":"SpectralFitting.jl is a package for fitting models to spectral data, similar to XSPEC, Sherpa or ISIS.\n\nThe rationale for this package is to provide a unanimous interface for different model libraries, and to leverage advancements in the computional methods that are available in Julia, including the rich statistics ecosystem, with automatic-differentiation and speed.\n\nLonger term ambitions include\n\nMulti-wavelength fits\nRadiative transfer embedded into the package\nSpectral and timing fits\n\nSpectralFitting aims to provide highly optimised and flexible fitting algorithms, along with a library of spectral models, for use in any field of Astronomy that concerns itself with spectral data.","category":"section"},{"location":"fitting/#Fitting-spectral-models","page":"Fitting spectral models","title":"Fitting spectral models","text":"","category":"section"},{"location":"reference/#API-reference","page":"Reference","title":"API reference","text":"","category":"section"},{"location":"reference/#General-reference","page":"Reference","title":"General reference","text":"Modules = [SpectralFitting.Reflection]\nOrder   = [:function, :type]","category":"section"},{"location":"walkthrough/#Walkthrough","page":"Walkthrough","title":"Walkthrough","text":"warning: Warning\nThis walk through has not been fleshed out with the relevant astrophysical content yet (for example, whether a fit is good, what the different parameters mean, etc.), and so assumes some familarity with spectral fitting in general.It is also not yet complete, nor a faithful illustration of everything SpectralFitting.jl can do. It serves to illustrate similarities and differences in syntax between SpectralFitting.jl and XSPEC.\n\nThis example walkthrough is the SpectralFitting.jl equivalent of the Walk through XSPEC from the XSPEC manual. We will use the same dataset, available for download from this link to the data files.","category":"section"},{"location":"walkthrough/#Overview","page":"Walkthrough","title":"Overview","text":"The first thing we want to do is load our datasets. Unlike in XSPEC, we have no requirement of being in the same directory as the data, or even that all of the response, ancillary, and spectral files be in the same place. For simplicity, we'll assume they are:\n\nnote: Note\nBe sure to set DATADIR pointing to the directory where you keep the walkthrough data.\n\nusing SpectralFitting, XSPECModels, Plots\n\nDATADIR = \"...\"\nDATADIR = length(get(ENV, \"CI\", \"\")) > 0 ? @__DIR__() * \"/../../ex-datadir\" : expanduser(\"~/developer/jl/ex-datadir\") # hide\nspec1_path = joinpath(DATADIR, \"s54405.pha\")\ndata = OGIPDataset(spec1_path) \n\nThis will print a little card about our data, which shows us what else SpectralFitting.jl loaded. We can see the Primary Spectrum, the Response, but that the Background and Ancillary response files are missing. That's to be expected, since we don't have those files in the dataset. \n\nWe can check what paths it used by looking at\n\ndata.user_data.paths\n\nWe can load and alter any part of a dataset as we do our fitting. For example, if you have multiple different ancillary files at hand, switching them between fits is a one-liner.\n\nTo visualize our data, we can use some of the Plots.jl recipes included in SpectralFitting.jl:\n\nplot(data, xlims = (0.5, 70), xscale = :log10)\n\nNote that the units are currently not divided by the energy bin widths. We can either do that manually, or use the normalize! to convert whatever units the data is currently in to the defacto standard counts s⁻¹ keV⁻¹ for fitting. Whilst we're at it, we see in the model card that there are 40 bad quality bins still present in our data. We can drop those as well, and plot the data on log-log axes:\n\nnormalize!(data)\ndrop_bad_channels!(data)\nplot(data, ylims = (0.001, 2.0), yscale = :log10, xscale = :log10)\n\nNote that when there are no negative axes, the scale defaults to log on the plot unless otherwise specified.\n\nNext we want to specify a model to fit to this data. Models that are prefixed with XS_ are models that are linked from the XSPEC model library, provided via LibXSPEC_jll. For a full list of the models, see Models library.\n\nwarning: Warning\nIt is advised to use the Julia implemented models. This allows various calculations to benefit from automatic differentiation, efficient multi-threading, GPU offloading, and various other useful things, see Why & how.\n\nWe will start by fitting a photoelectric absorption model that acts on a power law model:\n\nnote: Note\nTo see information about a model, use the ? in the Julia REPL:julia> ?PowerLaw\nXS_PowerLaw(K, a)\n\n    •  K: Normalisation.\n\n    •  a: Photon index.\n\nExample\n≡≡≡≡≡≡≡\n...\n\nmodel = PhotoelectricAbsorption() * PowerLaw()\n\nIf we want to specify paramters of our model at instantiation, we can do that with\n\nmodel = PhotoelectricAbsorption() * PowerLaw(a = FitParam(3.0))\n\nAlternatively, we can modify the parameters by reaching into the corresponding model component:\n\nset_value!(model.a1.a, 4.0)\n\nSpectralFitting.jl adopts the SciML problem-solver abstraction, so to fit a model to data we specify a FittingProblem:\n\nprob = FittingProblem(model => data)\n\nSpectralFitting.jl makes a huge wealth of optimizers available from Optimizations.jl, and others from further afield. For consistency with XSPEC, we'll use here a delayed-gratification least-squares algorithm from LsqFit.jl:\n\nresult = fit(prob, LevenbergMarquadt())\n\nHere we can see the parameter vector, the estimated error on each parameter, and the measure of the fit statistic (here chi squared). We can overplot our result on our data easily:\n\nplot(data, \n    ylims = (0.001, 2.0), \n    xscale = :log10, \n    yscale = :log10\n)\nplot!(result)\n\nOur model does not account for the high energy range well. We can ignore that range for now, and select everything from 0 to 15 keV and refit:\n\nmask_energies!(data, 0, 15)\nresult = fit(prob, LevenbergMarquadt())\n\nplot(data, \n    ylims = (0.001, 2.0), \n    xscale = :log10, \n    yscale = :log10\n)\nplot!(result, label = \"PowerLaw\")\n\nThe result is not yet baked into our model, and represents just the outcome of the fit. To update the parameters and errors in the model, we can use update_model!\n\nupdate_model!(model, result)\n\nnote: Note\nSince fitting and updating a model is often done in tandem, SpectralFitting.jl has both a fit and fit! method, the latter automatically updates the model parameters after fit.\n\nTo estimate the goodness of our fit, we can mimic the goodness command from XSPEC. This will use the simulate function to simulate spectra for a dataset (here determined by the result), and fit the model to the simulated dataset. The fit statistic for each fit is then appended to an array, which we can use to plot a histogram:\n\npcent, spread = goodness(result; N = 1000, seed = 42, exposure_time = data.spectrum.exposure_time)\n@info \"%goodness = $pcent\"\nhistogram(spread, ylims = (0, 300), label = \"Simulated\")\nvline!([result[1].stats], label = \"Best fit\")\n\nNote we have set the random number generator seed with seed = 42 to allow our results to be strictly reproduced.\n\nThe goodness command will return the percent of simulations with a fit statistic better than the result, in addition to the statistics of each individual trial.\n\nNext we want to calculate the flux in an energy range observed by the detector. We can do this with LogFlux or XS_CalculateFlux, as they are both equivalent implementations.\n\nWe can modify our model by accessing properties from the model card and writing a new expression:\n\ncalc_flux = XS_CalculateFlux(\n    E_min = FitParam(0.2, frozen = true), \n    E_max = FitParam(2.0, frozen = true),\n    log10Flux = FitParam(-10.3, lower_limit = -100, upper_limit = 100),\n)\n\nflux_model = model.m1 * calc_flux(model.a1)\n\nSince we used the old model to define the new one, our best fit values are automatically copied into the new model. We can now freeze the normalization, as we are using the flux integrating model to scale the powerlaw component:\n\nflux_model.a1.K.frozen = true\nflux_model\n\nLooking at the data card, we see the fit domain does not include the full region that we want to integrate the flux over. We therefore need to extend the fitting domain:\n\nflux_problem = FittingProblem(flux_model => data)\n# TODO: domain extensions not fully implemented yet\n\nNow to fit we can repeat the above procedure, and even overplot the region of flux we integrated:\n\nflux_result = fit(flux_problem, LevenbergMarquadt())\n\nplot(data, \n    ylims = (0.001, 2.0), \n    xscale = :log10, \n    yscale = :log10\n)\nplot!(flux_result)\nvspan!([flux_model.c1.E_min.value, flux_model.c1.E_max.value], alpha = 0.5)\n\nLet's try alternative models to see how they fit the data. First, an absorbed black body:\n\nmodel2 = PhotoelectricAbsorption() * XS_BlackBody()\n\nWe fit in the same way as before:\n\nprob2 = FittingProblem(model2 => data)\nresult2 = fit!(prob2, LevenbergMarquadt())\n\nLet's overplot this result against our power law result:\n\ndp = plot(data, \n    ylims = (0.001, 2.0), \n    xscale = :log10, \n    yscale = :log10,\n    legend = :bottomleft,\n)\nplot!(dp, result, label = \"PowerLaw $(round(sum(result.stats)))\")\nplot!(dp, result2, label = \"BlackBody $(round(sum(result2.stats)))\")\n\nOr a bremsstrahlung model:\n\nmodel3 = PhotoelectricAbsorption() * XS_BremsStrahlung()\nprob3 = FittingProblem(model3 => data)\nresult3 = fit(prob3, LevenbergMarquadt())\n\nplot!(dp, result3, label = \"Brems $(round(sum(result3.stats)))\")\n\nLet's take a look at the residuals of these three models. There are utility methods for this in SpectralFitting.jl, but we can easily just interact with the result directly:\n\nfunction calc_residuals(result)\n    # select which result we want (only have one, but for generalisation to multi-model fits)\n    r = result[1] \n    y = calculate_objective!(r, r.u)\n    obj, var = get_objective(r), get_objective_variance(r)\n    @. (obj - y) / sqrt(var)\nend\n\ndomain = SpectralFitting.plotting_domain(data)\n\nrp = hline([0], linestyle = :dash, legend = false)\nplot!(rp,domain, calc_residuals(result), seriestype = :stepmid)\nplot!(rp, domain, calc_residuals(result2), seriestype = :stepmid)\nplot!(rp, domain, calc_residuals(result3), seriestype = :stepmid)\nrp\n\nWe can compose this figure with our previous one, and change to a linear x scale:\n\nplot(dp, rp, layout = grid(2, 1, heights = [0.7, 0.3]), link = :x, xscale = :linear)\n\nWe can do all that plotting work with some of the builtin recipes:\n\nfunction plot_result(data, results...)\n    p1 = plot(data, \n        ylims = (0.001, 2.0), \n        xscale = :log10, \n        yscale = :log10,\n        legend = :bottomleft,\n    )\n    p2 = plot(xscale = :log10)\n    for r in results\n        plot!(p1, r)\n        residualplot!(p2, r)\n    end\n    plot(p1, p2, link = :x, layout = @layout [top{0.75h} ; bottom{0.25h}])\nend\n\nplot_result(data, result, result2, result3)\n\nLet's modify the black body model with a continuum component\n\nbbpl_model = model2.m1 * (PowerLaw() + model2.a1) |> deepcopy\n\nnote: Note\nWe pipe the model to deepcopy to create a copy of all the model parameters. Not doing this means the parameters in bbpl_model will be aliased to the parameters in model2, and changing one with change the other.\n\nWe'll freeze the hydrogen column density parameter to the galactic value and refit:\n\nbbpl_model.m1.ηH.value = 4\nbbpl_model.m1.ηH.frozen = true\nbbpl_model\n\nAnd fitting:\n\nbbpl_result = fit(\n    FittingProblem(bbpl_model => data), \n    LevenbergMarquadt()\n)\n\nLet's plot the result:\n\nplot_result(data, bbpl_result)\n\nUpdate the model and fix the black body temperature to 2 keV:\n\nupdate_model!(bbpl_model, bbpl_result)\n\nbbpl_model.a2.T.value = 2.0\nbbpl_model.a2.T.frozen = true\nbbpl_model\n\nFitting:\n\nbbpl_result2 = fit(\n    FittingProblem(bbpl_model => data), \n    LevenbergMarquadt()\n)\n\nOverplotting this new result:\n\nplot!(bbpl_result2)","category":"section"},{"location":"walkthrough/#MCMC","page":"Walkthrough","title":"MCMC","text":"We can use libraries like Pidgeons.jl or Turing.jl to perform Bayesian inference on our paramters. SpectralFitting.jl is designed with BYOO (Bring Your Own Optimizer) in mind, and so makes it relatively easy to get at the core fitting functions to be used with other packages.\n\nLet's use Turing.jl here, which means we'll also want to use StatsPlots.jl to plot our walker chains.\n\nusing StatsPlots\nusing Turing\n\nTuring.jl provides enormous control over the definition of the model, and this is not control SpectralFitting.jl wants to take away from you. Although we will provide utility scripts to do the basics, here we'll show you everything step by step to give you an overview of what you can do.\n\nLet's go back to our first model:\n\nmodel\n\nThis gave a pretty good fit but the errors on our paramters are not well defined, being estimated only from a convariance matrix in the least-squares solver. MCMC can give us better confidence regions, and even help us uncover dependencies between paramters. Here we'll take all of our parameters and convert them into a Turing.jl model with use of their macro:\n\n@model function mcmc_model(objective, stddev, f)\n    K ~ Normal(20.0, 1.0)\n    a ~ Normal(2.2, 0.3)\n    ηH ~ truncated(Normal(0.5, 0.1); lower = 0)\n    pred = f(K, a, ηH)\n    return objective ~ MvNormal(pred, stddev)\nend\n\nA few things to note here: we use the Turing.jl sampling syntax ~ to say that a variable is sampled from a certain type of prior distribution. There are no fixed criteria for what a distribution can be, and we encourage you to consult the Turing.jl documentation to learn how to define your own custom probability distributions. In this case, we will use Gaussians for all our parameters, and for the means and standard deviations use the best fit and estimated errors.\n\nAt the moment we haven't explicitly used our model, but f in this case takes the roll of invoking our model, and folding through instrument responses. We call it in much the same way as invokemodel, despite it going the extra step to fold our model. To instantiate this, we can use the SpectralFitting.jl helper functions:\n\nconfig = FittingConfig(FittingProblem(model => data))\n\nmm = mcmc_model(\n    get_objective_single(config),\n    sqrt.(get_objective_variance_single(config)),\n    get_invoke_wrapper_single(config),\n)\nnothing # hide\n\nThat's it! We're now ready to sample our model. Since all our models are implemented in Julia, we can use gradient-boosted samplers with automatic differentiation, such as NUTS. We'll walk 5000 itterations, just as a small example:\n\nchain = sample(mm, NUTS(), 5_000)\n\nIn the printout we see summary statistics about or model, in this case that it has converged well (rhat close to 1 for all parameters), better estimates of the standard deviation, and various quantiles. We can plot our chains to make sure the caterpillers are healthy and fuzzy, making use of StatsPlots.jl recipes:\n\nplot(chain)\n\nUsing PairPlots.jl to create corner plots:\n\nimport PairPlots, Makie, CairoMakie\n\ntable = (; # named tuple syntax\n    K = vec(chain[\"K\"]),\n    a = vec(chain[\"a\"]),\n    ηH = vec(chain[\"ηH\"])\n)\n\nPairPlots.pairplot(table)","category":"section"},{"location":"models/using-models/#Using-spectral-models","page":"Using models","title":"Using spectral models","text":"In this page you'll find how to use the spectral model library and how to define your own models. Using the model library is as easy as invoking or composing models from the Model Index. For example:\n\nmodel = PowerLaw()\n\nIn the output of the REPL we see the model name, and it's two parameters, with information about those parameters, such as the current value, the associated error (10% by defaul), the minimum and maximum values, and whether the parameter is frozen or not.\n\nnote: Note\nSee FitParam for full details about fitable parameters.\n\nThe parameters can be tweaked by accessing the fields\n\nmodel.K.value = 2.0\nmodel.K.frozen = true\nmodel\n\nWe can invoke the model on a domain in the following way\n\ndomain = collect(range(0.1, 10.0, 100))\ninvokemodel(domain, model)\n\nnote: Note\nBy default, models are implemented to accept a single input vector with all of the low and high bin edges, and return a flux array with the flux in each energy bin. As such, it is here the case that:length(flux) == length(energy) - 1Models need not be defined as such, however. See AbstractDataLayout for more.\n\nModels can be composed together following the Model algebra. That means to expressive a photoelectric absorption component acting on the power law we can write\n\nmodel2 = PhotoelectricAbsorption() * model\n\nThe parameters of this CompositeModel are are copied from the expression. This means we can modify the K_1 parameter in model2 without having to worry that we are changing model.K:\n\nmodel2.a1.K.frozen = false\nmodel2\n\nmodel\n\nComposite models have the same methods as single models. This means we can invoke a model in the same way\n\ninvokemodel(domain, model2)","category":"section"},{"location":"models/using-models/#Defining-new-models","page":"Using models","title":"Defining new models","text":"To define your own model, you need to tell the package what the model parameters are and how to invoke the model. This is all done by creating a struct which subtypes AbstractSpectralModel.\n\nLet's create a new Additive spectral model:\n\nBase.@kwdef struct MyModel{T} <: AbstractSpectralModel{T,Additive}\n    K::T = FitParam(2.0)\n    p::T = FitParam(3.0)\nend\n\n# implementing a dummy add operation this function can do anything it likes, but\n# must write the output into `output` and ideally should be thread safe\nfunction SpectralFitting.invoke!(output, input, model::MyModel)\n    SpectralFitting.finite_diff_kernel!(output, input) do E\n        E + model.p\n    end\nend\n\nHere we used the utility method SpectralFitting.finite_diff_kernel! to ensure the additive model is appropriately scaled across the bin width.\n\nNote that Additive models do not need to use the normalization parameter K themselves. This is because when we use invokemodel these sorts of translations are automatically applied, for compatability with external models.\n\nOur model is now ready to use\n\nmodel = MyModel()\n\ndomain = collect(range(0.1, 10.0, 100))\ninvokemodel(domain, model)\n\nnote: Note\nTo add new XSPEC or foreign function models, see Wrapping new XSPEC models.","category":"section"},{"location":"models/using-models/#Model-abstraction","page":"Using models","title":"Model abstraction","text":"All spectral models are a sub-type of AbstractSpectralModel.","category":"section"},{"location":"models/using-models/#Model-methods","page":"Using models","title":"Model methods","text":"","category":"section"},{"location":"models/using-models/#Model-algebra","page":"Using models","title":"Model algebra","text":"Models exist as three different kinds, defined by an AbstractSpectralModelKind trait.","category":"section"},{"location":"models/using-models/#Model-data-availability","page":"Using models","title":"Model data availability","text":"Many of the XSPEC implemented models use tabular data, such as FITS, and return results interpolated from these pre-calculated tables. In some cases, these table models have data files that are multiple gigabytes in size, and would be very unwieldy to ship indiscriminantly. SpectralFitting attempts to circumnavigate this bloat by downloading the model data on an ut opus basis.\n\nSpecial care must be taken if new XSPEC models are wrapped to ensure the data is available. For more on this, see Wrapping new XSPEC models.\n\nModel data may also alternatively be copied in by-hand from a HEASoft XSPEC source directory. In this case, the location to copy the data to may be determined via joinpath(SpectralFitting.LibXSPEC_jll.artifact_dir, \"spectral\", \"modelData\").","category":"section"},{"location":"models/using-models/#SpectralFitting.AbstractSpectralModel","page":"Using models","title":"SpectralFitting.AbstractSpectralModel","text":"abstract type AbstractSpectralModel{T,K<:AbstractSpectralModelKind} end\n\nSupertype of all spectral models, tracking the number type T and AbstractSpectralModelKind denoted K.\n\nImplementation\n\nSub-types must implement the following interface (see the function's documentation for examples):\n\nSpectralFitting.invoke!\n\nThe parameters of the model must be of types FitParam when default initialised, as this is used to perform introspection. The boiler plate for a new model is as follows:\n\nstruct MyNewModel{T} <: AbstractSpectralModel{T,Additive}\n    \"Normalisation (required by Additive kinds)\n    K::T\n    \"First parameter\"\n    p1::T\n    \"Second parameter\"\n    p2::T\nend\n\n# add a default keyword constructor\nfunction MyNewModel(;K = FitParam(1.0), p1 = FitParam(2.0), p2 = FitParam(0.1))\n    MyNewModel(K, p1, p2)\nend\n\nfunction SpectralFitting.invoke!(output, domain, model::MyNewModel)\n    # implementation must overwrite `output`\n    output .= 0\nend\n\nUsage\n\nThe available API for a spectral model is detailed below:\n\ninvokemodel / invokemodel!: the primary way to invoke a model.\nallocate_model_output: allocate the output matrix for the model.\n\nThe following query functions exist:\n\nmodelkind for obtaining K\nimplementation used to ascertain whether we can do things like automatic differentiation through this model.\nparameter_count to return a compile-time integer representing the total number of parameters in the model.\nparameter_vector to obtain a vector where every element is a FitParam in the same order as the struct fields.\nparameter_names to obtain a vector of symbols for each parameter.\nobjective_cache_count how many output arrays this model needs to be invoked (only used for CompositeModel).\nsupports what AbstractDataLayout are supported by this model.\n\nConversion functions include:\n\nremake_with_parameters for converting a model from FitParam type parameters to a primitive type (e.g. Float64), or for rebuilding models with new values.\n\nThe parametric type parameter T is the number type of the model and K defines the AbstractSpectralModelKind.\n\n\n\n\n\n","category":"type"},{"location":"models/using-models/#SpectralFitting.invoke!","page":"Using models","title":"SpectralFitting.invoke!","text":"SpectralFitting.invoke!(output, domain, M::Type{<:AbstractSpectralModel}, params...)\n\nUsed to define the behaviour of models. Should calculate the output of the model and write in-place into output. The model parameters are passed in the model structure.\n\nwarning: Warning\nThis function should not be called directly. Use invokemodel instead. invoke! is only to define the model, not to use it. Users should always call models using invokemodel or invokemodel! to ensure normalisations and closures are accounted for.\n\nExample\n\nBase.@kwdef struct MyModel{T} <: AbstractSpectralModel{T,Multiplicative}\n    p1::T = FitParam(1.0)\n    p2::T = FitParam(2.0)\n    p3::T = FitParam(3.0)\nend\n\nwould have the arguments passed to invoke! as\n\nfunction SpectralFitting.invoke!(output, domain, model::MyModel)\n    # ...\nend\n\n\n\n\n\n","category":"function"},{"location":"models/using-models/#SpectralFitting.implementation","page":"Using models","title":"SpectralFitting.implementation","text":"implementation(model::AbstractSpectralModel)\nimplementation(::Type{<:AbstractSpectralModel})\n\nGet the AbstractSpectralModelImplementation for a given AbstractSpectralModel or model type.\n\nThis is used primarily to learn what optimizations we can do with a model, for example propagating auto-diff gradients through a model or arbitrary precision numbers.\n\n\n\n\n\n","category":"function"},{"location":"models/using-models/#SpectralFitting.invokemodel","page":"Using models","title":"SpectralFitting.invokemodel","text":"invokemodel(domain, model::AbstractSpectralModel)\n\nInvoke the AbstractSpectralModel given by model over the domain domain.\n\nThis function will perform any normalisation or post-processing tasks that a specific model kind may require, e.g. multiplying by a normalisation constant for Additive models.\n\nnote: Note\n\n\ninvokemodel allocates the needed output arrays based on the element type of free_params to allow automatic differentation libraries to calculate parameter gradients.\n\nIn-place non-allocating variants are the invokemodel! functions.\n\nExample\n\nmodel = PowerLaw()\ndomain = collect(range(0.1, 20.0, 100))\n\ninvokemodel(domain, model)\n\n\n\n\n\n","category":"function"},{"location":"models/using-models/#SpectralFitting.invokemodel!","page":"Using models","title":"SpectralFitting.invokemodel!","text":"invokemodel!(output, domain, model)\ninvokemodel!(output, domain, model, params::AbstractVector)\ninvokemodel!(output, domain, model, params::ParameterCache)\n\nIn-place variant of invokemodel, calculating the output of an AbstractSpectralModel given by model, optionally overriding the parameters using a ParameterCache or an AbstractVector.\n\nThe output may not necessarily be a single vector, and one should use allocate_model_output to allocate the output structure.\n\nExample\n\nmodel = PowerLaw()\ndomain = collect(range(0.1, 20.0, 100))\noutput = allocate_model_output(model, domain)\ninvokemodel!(output, domain, model)\n\n\n\n\n\n","category":"function"},{"location":"models/using-models/#SpectralFitting.AbstractSpectralModelKind","page":"Using models","title":"SpectralFitting.AbstractSpectralModelKind","text":"abstract type AbstractSpectralModelKind\n\nAbstract type of all model kinds. The algebra of models is as follows\n\nA + A = A\nM * M = M\nM * A = A\nC(A)  = A\n\nwhere A is Additive, M is Multiplicative, and C is Convolutional. All other operations are prohibited, e.g. C(M) or M * C. To obtain M * C there must be an additive component, e.g. M * C(A).\n\n\n\n\n\n","category":"type"},{"location":"models/using-models/#SpectralFitting.Additive","page":"Using models","title":"SpectralFitting.Additive","text":"Additive <: AbstractSpectralModelKind\nAdditive()\n\nAdditive models are effectively the sources of photons, and are the principle building blocks of composite models. Every additive model has a normalisation parameter which re-scales the output by a constant factor K.\n\nnote: Note\nDefining custom additive models requires special care. See Defining new models.\n\n\n\n\n\n","category":"type"},{"location":"models/using-models/#SpectralFitting.Multiplicative","page":"Using models","title":"SpectralFitting.Multiplicative","text":"Multiplicative <: AbstractSpectralModelKind\nMultiplicative()\n\nMultiplicative models act on Additive models, by element-wise multiplying the output in each domain bin of the additive model by a different factor.\n\n\n\n\n\n","category":"type"},{"location":"models/using-models/#SpectralFitting.Convolutional","page":"Using models","title":"SpectralFitting.Convolutional","text":"Convolutional <: AbstractSpectralModelKind\nConvolutional()\n\nConvolutional models act on the output generated by Additive models, similar to Multiplicative models, however may convolve kernels through the output also.\n\n\n\n\n\n","category":"type"},{"location":"models/using-models/#SpectralFitting.download_model_data","page":"Using models","title":"SpectralFitting.download_model_data","text":"SpectralFitting.download_model_data(model::AbstractSpectralModel; kwargs...)\nSpectralFitting.download_model_data(M::Type{<:AbstractSpectralModel}; kwargs...)\nSpectralFitting.download_model_data(s::Symbol; kwargs...)\n\nDownloads the model data for a model specified either by model, type M, or symbol s. Datafiles associated with a specific model may be registered using SpectralFitting.register_model_data. The download is currently unconfigurable, but permits slight control via a number of keyword arguments:\n\nprogress::Bool = true\nDisplay a progress bar for the download.\nmodel_source_url::String = \"http://www.star.bris.ac.uk/fbaker/XSPEC-model-data\"\nThe source URL used to download the model data.\n\nAll standard XSPEC spectral model data is currently being hosted on the University of Bristol astrophysics servers, and should be persistently available to anyone.\n\n\n\n\n\n","category":"function"},{"location":"models/using-models/#SpectralFitting.download_all_model_data","page":"Using models","title":"SpectralFitting.download_all_model_data","text":"SpectralFitting.download_all_model_data()\n\nDownloads all model data for the models currently registered with SpectralFitting.register_model_data. Calls SpectralFitting.download_model_data to perform the download.\n\n\n\n\n\n","category":"function"},{"location":"#SpectralFitting.jl-Documentation","page":"Home","title":"SpectralFitting.jl Documentation","text":"Fast and flexible spectral fitting in Julia.\n\nSpectralFitting.jl is a package for defining and fitting spectral models, with a number of utilities to make model composition easy and invocation fast. SpectralFitting can be extended with LibXSPEC_jll.jl via XSPECModels.jl to expose the library of models from HEASoft XSPEC, and provides helper functions for operating with spectral data from a number of different missions. The package natively uses LsqFit.jl to fit parameters using the Levenberg-Marquardt algorithm, but makes it easy to use Optim.jl for more specialized fitting algorithms, or Turing.jl for Bayesian inference and MCMC.\n\nSpectralFitting is designed to be extended, such that new models are simple to create, and new dataset processing pipelines for different missions are brief to define. Where performance is key, SpectralFitting helps you define fast and AD-compatible surrogates of spectral models using Surrogates.jl, and embed them in the model composition algebra.\n\nTo get started, add the AstroRegistry from the University of Bristol and then install:\n\njulia>]\npkg> registry add https://github.com/astro-group-bristol/AstroRegistry\npkg> add SpectralFitting\n\nThen use\n\nusing SpectralFitting\n# ....\n\nSee Walkthrough for an example walkthrough the package.\n\nFor more University of Bristol Astrophysics Group codes, see our GitHub organisation.","category":"section"}]
}
