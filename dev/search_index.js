var documenterSearchIndex = {"docs":
[{"location":"tutorials/tabular-data/#tabular-data","page":"Working with tabular data","title":"Working with tabular data","text":"","category":"section"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"Tables are a common way to represent various forms of catalogs. One common format for storing this data in astronomy is as a FITS file.","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"In these examples, we will fetch and load the Hipparcos-GAIA Catalog of Accelerations [(HGCA, Brandt et al 2021])](https://iopscience.iop.org/article/10.3847/1538-4365/abf93c). This catalog cross matches stars from the Hipparcos and GAIA catalogs in order to calculate the long term astrometric proper motion anomaly; that is, the star's deviation from straight line motion in the plane of the sky over the ~20 baseline between the two missions.","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"A wide range of tabular data formats are supported in Julia under a common Tables.jl interface. For example,  CSV, Excel, Arrow, CASA Tables, and various SQL formats to name a few.","category":"page"},{"location":"tutorials/tabular-data/#Packages","page":"Working with tabular data","title":"Packages","text":"","category":"section"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"FITSIO: we'll use this package to load a table stored in a FITS file\nDataFrames: we'll use this package to examine and manipulate the table\nPlots: we'll use this package to visualize the contents of the table\nAstroLib: general utility package. We'll use a helper function to compute a map projection.","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"You can install the necessary packages by running Julia, and typing ] to enter Pkg-mode. Then: add FITSIO DataFrames Plots AstroLib. Alternatively, you can run using Pkg; Pkg.add([\"FITSIO\", \"DataFrames\", \"Plots\", \"AstroLib\"]).","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"If you will be using these tools as part of a larger project, it's strongly recommended to create a Julia Project to record package versions.  If you're just experimenting, you can create a temporary project by running ] activate --temp.","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"If you're using Pluto notebooks, installing and recording package versions in a project are handled for you automatically.","category":"page"},{"location":"tutorials/tabular-data/#Downloading-the-data","page":"Working with tabular data","title":"Downloading the data","text":"","category":"section"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"The table in question is hosted alongside the article. Go to Table 4 and click the link at the bottom to download it in FITS format. You'll need to uncompress the archive to see the HGCA_vEDR3.fits file.","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"FITS tables can be loaded using the FITSIO package or the AstroImages package which wraps it.","category":"page"},{"location":"tutorials/tabular-data/#Loading-the-table","page":"Working with tabular data","title":"Loading the table","text":"","category":"section"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"julia> using FITSIO\njulia> fits = FITS(\"HGCA_vEDR3.fits\")\n\nFile: HGCA_vEDR3.fits\nMode: \"r\" (read-only)\nHDUs: Num  Name  Type   \n      1          Image  \n      2          Table\njulia> table_fits = fits[2]\nFile: HGCA_vEDR3.fits\nHDU: 2\nType: Table\nRows: 115346\nColumns: Name                    Size  Type     TFORM  \n         hip_id                        Int32    J\n         gaia_source_id                Int64    K\n         gaia_ra                       Float64  D\n         gaia_dec                      Float64  D\n         radial_velocity               Float32  E\n...\n         chisq                         Float32  E","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"If we choose to use the AstroImages package, this code could be substituted for:","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"julia> using AstroImages\njulia> table_fits = load(\"HGCA_vEDR3.fits\", 2);","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"Since this table conforms to the Tables.jl interface we can already pass it to a wide range of analysis and plotting tools; however, for interactive work it's useful to wrap this data in a DataFrame from DataFrames.jl.","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"julia> using DataFrames\njulia> df = DataFrame(table_fits)\n115346×35 DataFrame\n    Row │ hip_id  gaia_source_id       gaia_ra        gaia_dec ⋯\n        │ Int32   Int64                Float64        Float64  ⋯\n────────┼───────────────────────────────────────────────────────\n      1 │      1  2738327528519591936    0.000871957    1.0889 ⋯\n      2 │      2  2341871673090078592    0.00511158   -19.4988  \n      3 │      3  2881742980523997824    0.00506023    38.8593  \n      4 │      4  4973386040722654336    0.00907157   -51.8935  \n      5 │      5  2305974989264598272    0.00997423   -40.5912 ⋯\n   ⋮    │   ⋮              ⋮                 ⋮            ⋮    ⋱\n 115343 │ 120401  5290738562888564736  119.382        -60.6309  \n 115344 │ 120402  5290832364972775808  119.449        -60.6097  \n 115345 │ 120403  5290725643625189504  119.455        -60.6836  \n 115346 │ 120404  5290820682661822848  119.512        -60.6147 ⋯\n                              32 columns and 115337 rows omitted\n","category":"page"},{"location":"tutorials/tabular-data/#Examining-the-table","page":"Working with tabular data","title":"Examining the table","text":"","category":"section"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"As a first step, let's summarize the contents of the data frame using describe:","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"julia> describe(df)\n35×7 DataFrame\n Row │ variable                mean         min            median       max                  nmissing  eltype   \n     │ Symbol                  Union…       Any            Union…       Any                  Int64     DataType \n─────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────\n   1 │ hip_id                  59162.8      1              59133.5      120404                      0  Int32\n   2 │ gaia_source_id          3.5587e18    7632157690368  3.58418e18   6917489002841762304         0  Int64\n   3 │ gaia_ra                 181.445      0.000871957    181.843      359.982                     0  Float64\n   4 │ gaia_dec                -2.13495     -89.7824       -1.96568     89.5695                     0  Float64\n   5 │ radial_velocity         NaN          NaN                         NaN                         0  Float32\n   6 │ radial_velocity_error   NaN          NaN                         NaN                         0  Float32\n   7 │ radial_velocity_source               Gaia_DR2                    None                        0  String\n   8 │ parallax_gaia           6.98091      0.1            4.29612      768.067                     0  Float32\n   9 │ parallax_gaia_error     0.0450278    0.00802848     0.023354     1.52339                     0  Float32\n  10 │ pmra_gaia               -1.43563     -4406.47       -1.73408     6766.0                      0  Float32\n  11 │ pmdec_gaia              -16.3946     -5817.8        -5.53577     10362.4                     0  Float32\n  12 │ pmra_gaia_error         0.062217     0.00743185     0.0326008    2.03418                     0  Float32\n  13 │ pmdec_gaia_error        0.0574897    0.00869586     0.029098     1.99573                     0  Float32\n  14 │ pmra_pmdec_gaia         -0.0142746   -0.971819      -0.0116653   0.891564                    0  Float32\n  15 │ pmra_hg                 -1.43057     -4406.68       -1.69382     6765.91                     0  Float32\n  ⋮  │           ⋮                  ⋮             ⋮             ⋮                ⋮              ⋮         ⋮\n  22 │ pmra_hip_error          1.22346      0.290212       0.93546      2269.23                     0  Float32\n  23 │ pmdec_hip_error         1.00177      0.289527       0.794942     113.61                      0  Float32\n  24 │ pmra_pmdec_hip          0.00441718   -0.94068       0.000400515  0.986897                    0  Float32\n  25 │ epoch_ra_gaia           2016.07      2015.11        2016.07      2017.05                     0  Float64\n  26 │ epoch_dec_gaia          2016.09      2014.95        2016.1       2017.2                      0  Float64\n  27 │ epoch_ra_hip            1991.25      1990.4         1991.25      1992.43                     0  Float64\n  28 │ epoch_dec_hip           1991.28      1990.34        1991.28      1992.41                     0  Float64\n  29 │ crosscal_pmra_hip       -0.0578266   -1.36874       -0.0648208   1.50959                     0  Float32\n  30 │ crosscal_pmdec_hip      0.00226569   -1.15742       0.00306844   1.59232                     0  Float32\n  31 │ crosscal_pmra_hg        -0.0013262   -0.0511373     -0.00269026  0.0619938                   0  Float32\n  32 │ crosscal_pmdec_hg       0.000217839  -0.0598967     0.00025581   0.0564424                   0  Float32\n  33 │ nonlinear_dpmra         -9.0424e-5   -7.98001       3.44128e-8   2.64822                     0  Float32\n  34 │ nonlinear_dpmdec        0.000311498  -4.1194        1.92019e-7   16.0394                     0  Float32\n  35 │ chisq                   566.555      3.11559e-5     3.35103      3.67633e5                   0  Float32\n                                                                                                  6 rows omitted\n","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"This lists all the columns of the table along with their min, max, median, and means. It also specifies how many entries are missing and the element type of the column.","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"We can access a specific column from the table using two different syntaxes: df[:,\"epoch_ra_gaia\"], or simply df.epoch_ra_gaia.","category":"page"},{"location":"tutorials/tabular-data/#Filtering","page":"Working with tabular data","title":"Filtering","text":"","category":"section"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"Let's apply a cut to the parallax column to only include nearby stars:","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"julia> nearby = filter(:parallax_gaia => >(50.0), df)\n799×35 DataFrame\n Row │ hip_id  gaia_source_id       gaia_ra    gaia_dec   radial_velocity  radial_vel ⋯\n     │ Int32   Int64                Float64    Float64    Float32          Float32    ⋯\n─────┼─────────────────────────────────────────────────────────────────────────────────\n   1 │    428   386655019234959872    1.30108   45.7859          -1.24273             ⋯\n   2 │    436  4706630501049679744    1.32232  -67.8351          40.2364\n   3 │    439  2306965202564744064    1.38379  -37.3675          25.2944\n   4 │    473   386653851004022144    1.42676   45.8114           1.15092\n  ⋮  │   ⋮              ⋮               ⋮          ⋮             ⋮                    ⋱\n 796 │ 117779  2867175035571212416  358.285     29.0182           1.30031             ⋯\n 797 │ 117828  6377828354964753792  358.463    -75.6342          -9.62612\n 798 │ 117966  2442996678074668288  358.914     -6.14423         17.0672\n 799 │ 120005  1022456104850892928  138.591     52.6834          11.9794\n                                                        30 columns and 791 rows omitted","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"Let's break this down. First, we specify the column name as :parallax_gaia. The : syntax defines a Symbol in Julia which is a bit like a string and a variable name. Next, we say what filter we want to apply to this column by passing a key-value Pair constructed with =>. This syntax, e.g. 1 => 2 just groups two values and is unrelated to keyword arguments. Then, we pass a predicate function, that is a function that takes one value and returns true or false. The expression >(50.0) produces such a function that takes a value and compares it with 50.0 milliarseconds of parallax. Finally, we pass the table we want to filter.","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"This useful cheatsheet by Tom Kwong is a great reference for these sort of operations.","category":"page"},{"location":"tutorials/tabular-data/#Plotting","page":"Working with tabular data","title":"Plotting","text":"","category":"section"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"Let's now visualize these stars as they appear in the plane of the sky. We'll colour them based on the significance of the anomalous acceleration they had between the two satellite missions. This acceleration could be caused by a hidden companion star or planet.","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"julia> using Plots\njulia> scatter(\n    nearby.gaia_ra,\n    nearby.gaia_dec;\n    marker_z = log10.(nearby.chisq),\n    colorbartitle=\"log10 χ²\", # typed as \\chi <tab> \\^2 <tab>\n    label = \"\",\n    xlabel = \"right ascension (°)\", # typed as \\degree <tab>\n    ylabel = \"declination (°)\" \n)","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"Let's improve this plot by using a different map projection. We can make this conversion using AstroLib.jl.","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"The function aitoff takes longitude and latitude (or in this case, right-ascension and delcination) and returns a new position using an Aitoff projection.","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"julia> using AstroLib\njulia> newpoints = aitoff.(nearby.gaia_ra, nearby.gaia_dec)","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"newpoints is returned as a vector of Tuples of x and y coordinates, but to plot them we'll need separate flat vectors of x and y values. We can convert using getindex:","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"julia> newx = getindex.(newpoints, 1)\njulia> newy = getindex.(newpoints, 2)\n799-element Vector{Float64}:\n  49.51360693576993\n -71.02232113037604\n -40.77386766281466\n   ⋮\n -78.04105630927837\n  -6.821326623255115\n  64.9538084311332","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"getindex(obj, n) is equivalent to writing obj[n]. Here we use broadcasting to fetch the first and then second element of each point in the list.","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"Finally, we'll make the plot and tweak some formatting options:","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"julia> scatter(\n    newx,\n    newy;\n    marker_z = log10.(nearby.chisq),\n    color = :turbo,\n    colorbartitle=\"log10 χ²\", # typed as \\chi <tab> \\^2 <tab>\n    label = \"\",\n    xlabel = \"right ascension (°)\", # typed as \\degree <tab>\n    ylabel = \"declination (°)\",\n    background=:transparent,\n    foreground=:gray,\n    framestyle=:box,\n    markerstrokewidth=0,\n    grid=:none\n)","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"(Image: Plot of nearby stars with significant acceleration)","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"We can save the plot using savefig(\"myplot.pdf\"). png, svg, and other formats are also supported.","category":"page"},{"location":"tutorials/tabular-data/","page":"Working with tabular data","title":"Working with tabular data","text":"For more on plotting in general, see the Plots.jl documentation.","category":"page"},{"location":"modules/SAOImageDS9/drawing/#Drawing-in-SAOImage/DS9","page":"Drawing in SAOImage/DS9","title":"Drawing in SAOImage/DS9","text":"","category":"section"},{"location":"modules/SAOImageDS9/drawing/","page":"Drawing in SAOImage/DS9","title":"Drawing in SAOImage/DS9","text":"SAOImageDS9 can be used to quickly draw or display things in SAOImage/DS9.","category":"page"},{"location":"modules/SAOImageDS9/drawing/","page":"Drawing in SAOImage/DS9","title":"Drawing in SAOImage/DS9","text":"For instance, assuming img is a 2-dimensional Julia array, to display img as an image in SAOImage/DS9, call:","category":"page"},{"location":"modules/SAOImageDS9/drawing/","page":"Drawing in SAOImage/DS9","title":"Drawing in SAOImage/DS9","text":"SAOImageDS9.draw(img; kwds...)","category":"page"},{"location":"modules/SAOImageDS9/drawing/","page":"Drawing in SAOImage/DS9","title":"Drawing in SAOImage/DS9","text":"The main difference with SAOImageDS9.set(img) is that a number of keywords are supported:","category":"page"},{"location":"modules/SAOImageDS9/drawing/","page":"Drawing in SAOImage/DS9","title":"Drawing in SAOImage/DS9","text":"Use keyword frame to specify the frame number.\nUse keyword cmap to specify the name of the colormap.  For instance, cmap=\"gist_stern\".\nUse keyword zoom to specify the zoom factor.\nUse keywords min and/or max to specify the scale limits.","category":"page"},{"location":"modules/SAOImageDS9/drawing/","page":"Drawing in SAOImage/DS9","title":"Drawing in SAOImage/DS9","text":"The SAOImageDS9.draw method can be called with other kinds of arguments such as instances (or array or tuple) of TwoDimensional.Point to draw point(s) or instances of TwoDimensional.BoundingBox to draw rectangle(s).","category":"page"},{"location":"modules/Photometry/","page":"Home","title":"Home","text":"CurrentModule = Photometry\nDocTestSetup = :(using Photometry)","category":"page"},{"location":"modules/Photometry/#Photometry.jl","page":"Home","title":"Photometry.jl","text":"","category":"section"},{"location":"modules/Photometry/","page":"Home","title":"Home","text":"(Image: GitHub) (Image: Build Status) (Image: Coverage) (Image: License)","category":"page"},{"location":"modules/Photometry/#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"modules/Photometry/","page":"Home","title":"Home","text":"To install from the REPL, enter Pkg-mode (])","category":"page"},{"location":"modules/Photometry/","page":"Home","title":"Home","text":"pkg> add Photometry","category":"page"},{"location":"modules/Photometry/#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"modules/Photometry/","page":"Home","title":"Home","text":"Here is a basic example to do some aperture photometry using CircularAperture. The photometry function performs the photometry using a given method.","category":"page"},{"location":"modules/Photometry/","page":"Home","title":"Home","text":"data = ones(100, 100)\nerr = ones(100, 100)\n\nap1 = CircularAperture(50, 50, 3)\n# partial overlap\nap2 = CircularAperture(0.5, 0.5, 5)\n\nresults = photometry([ap1, ap2], data, err)\n@assert results.aperture_sum[1] ≈ 9π\n@assert results.aperture_sum[2] ≈ 25π / 4\n\nresults\n\n# output\nTable with 4 columns and 2 rows:\n     xcenter  ycenter  aperture_sum  aperture_sum_err\n   ┌─────────────────────────────────────────────────\n 1 │ 50.0     50.0     28.2743       5.31736\n 2 │ 0.5      0.5      19.635        4.43113","category":"page"},{"location":"modules/Photometry/#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"modules/Photometry/","page":"Home","title":"Home","text":"If you're interested in contributing, go ahead and check out the issues or make a pull request. If you add a new feature, please write appropriate unit tests for it and bump the package's minor version.","category":"page"},{"location":"modules/Photometry/#License","page":"Home","title":"License","text":"","category":"section"},{"location":"modules/Photometry/","page":"Home","title":"Home","text":"The work derived from astropy/photutils is BSD 3-clause and the work derived from kbarbary/sep is BSD 3-clause. All other work is considered MIT expat. Therefore this work as a whole is BSD 3-clause. LICENSE contains all licenses and any files using derived work are noted at the top of the file.","category":"page"},{"location":"highlevels/cosmology/#Cosmology-Overview","page":"Cosmology Overview","title":"Cosmology Overview","text":"","category":"section"},{"location":"modules/SAOImageDS9/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"modules/SAOImageDS9/","page":"Introduction","title":"Introduction","text":"The SAOImageDS9 package provides an interface between Julia and the image viewer SAOImage/DS9 via XPA.jl, a Julia interface to the XPA Messaging System.","category":"page"},{"location":"modules/SAOImageDS9/#Table-of-contents","page":"Introduction","title":"Table of contents","text":"","category":"section"},{"location":"modules/SAOImageDS9/","page":"Introduction","title":"Introduction","text":"Pages = [\"install.md\", \"starting.md\", \"requests.md\",\n         \"connect.md\", \"drawing.md\", \"examples.md\",\n         \"library.md\"]","category":"page"},{"location":"modules/SAOImageDS9/#Method-index","page":"Introduction","title":"Method index","text":"","category":"section"},{"location":"modules/SAOImageDS9/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"modules/Photometry/detection/#Source-Detection","page":"Getting Started","title":"Source Detection","text":"","category":"section"},{"location":"modules/Photometry/detection/","page":"Getting Started","title":"Getting Started","text":"The module provides tools and algorithms for detecting and extracting point-like sources.","category":"page"},{"location":"modules/Photometry/detection/#API/Reference","page":"Getting Started","title":"API/Reference","text":"","category":"section"},{"location":"modules/Photometry/detection/","page":"Getting Started","title":"Getting Started","text":"extract_sources","category":"page"},{"location":"modules/Photometry/detection/#Photometry.Detection.extract_sources","page":"Getting Started","title":"Photometry.Detection.extract_sources","text":"extract_sources(::SourceFinder, data, [error]; sorted=true)\n\nUses method to find and extract point-like sources. \n\nReturns a TypedTables.Table with positions and information related to the method. For instance, using PeakMesh returns a table a column for the peak values.\n\ndata is assumed to be background-subtracted. If error is provided it will be propagated into the detection algorithm. If sorted is true the sources will be sorted by their amplitude.\n\nSee Also\n\nSource Detection Algorithms\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/","page":"Home","title":"Home","text":"CurrentModule = CFITSIO","category":"page"},{"location":"modules/CFITSIO/#CFITSIO.jl","page":"Home","title":"CFITSIO.jl","text":"","category":"section"},{"location":"modules/CFITSIO/","page":"Home","title":"Home","text":"(Image: GitHub) (Image: Build Status) (Image: PkgEval) (Image: Coverage)","category":"page"},{"location":"modules/CFITSIO/","page":"Home","title":"Home","text":"This module provides an interface familiar to users of the CFITSIO C library. It can be used with","category":"page"},{"location":"modules/CFITSIO/","page":"Home","title":"Home","text":"using CFITSIO","category":"page"},{"location":"modules/CFITSIO/","page":"Home","title":"Home","text":"The functions exported by this module operate on FITSFile objects, which is a thin wrapper around a pointer to a CFITSIO fitsfile.  For the most part, the functions are thin wrappers around the CFITSIO routines of the same names. Typically, they:","category":"page"},{"location":"modules/CFITSIO/","page":"Home","title":"Home","text":"Convert from Julia types to C types as necessary.\nCheck the returned status value and raise an appropriate exception if non-zero.","category":"page"},{"location":"modules/CFITSIO/","page":"Home","title":"Home","text":"The following tables give the correspondances between CFITSIO \"types\", the BITPIX keyword and Julia types.","category":"page"},{"location":"modules/CFITSIO/#Type-Conversions","page":"Home","title":"Type Conversions","text":"","category":"section"},{"location":"modules/CFITSIO/#CFITSIO-Types","page":"Home","title":"CFITSIO Types","text":"","category":"section"},{"location":"modules/CFITSIO/","page":"Home","title":"Home","text":"CODE CFITSIO Julia\n int Cint\n long Clong\n LONGLONG Int64","category":"page"},{"location":"modules/CFITSIO/#FITS-BITPIX","page":"Home","title":"FITS BITPIX","text":"","category":"section"},{"location":"modules/CFITSIO/","page":"Home","title":"Home","text":"CODE CFITSIO Julia\n8 BYTE_IMG Uint8\n16 SHORT_IMG Int16\n32 LONG_IMG Int32\n64 LONGLONG_IMG Int64\n-32 FLOAT_IMG Float32\n-64 DOUBLE_IMG Float64","category":"page"},{"location":"modules/CFITSIO/#CFITSIO-Aliases","page":"Home","title":"CFITSIO Aliases","text":"","category":"section"},{"location":"modules/CFITSIO/","page":"Home","title":"Home","text":"CODE CFITSIO Julia Comments\n10 SBYTE_IMG Int8 written as: BITPIX = 8, BSCALE = 1, BZERO = -128\n20 USHORT_IMG Uint16 written as: BITPIX = 16, BSCALE = 1, BZERO = 32768\n40 LONG_IMG Uint32 written as: BITPIX = 32, BSCALE = 1, BZERO = 2147483648","category":"page"},{"location":"modules/CFITSIO/#FITS-Table-Data-Types","page":"Home","title":"FITS Table Data Types","text":"","category":"section"},{"location":"modules/CFITSIO/","page":"Home","title":"Home","text":"CODE CFITSIO Julia\n1 TBIT \n11 TBYTE Cuchar, Uint8\n12 TSBYTE Cchar, Int8\n14 TLOGICAL Bool\n16 TSTRING String\n20 TUSHORT Cushort\n21 TSHORT Cshort\n30 TUINT Cuint\n31 TINT Cint\n40 TULONG Culong\n41 TLONG Clong\n42 TFLOAT Cfloat\n81 TLONGLONG Int64\n82 TDOUBLE Cdouble\n83 TCOMPLEX Complex{Cfloat}\n163 TDBLCOMPLEX Complex{Cdouble}","category":"page"},{"location":"modules/CFITSIO/","page":"Home","title":"Home","text":"bitpix_from_type\ntype_from_bitpix\ncfitsio_typecode","category":"page"},{"location":"modules/CFITSIO/#CFITSIO.bitpix_from_type","page":"Home","title":"CFITSIO.bitpix_from_type","text":"bitpix_from_type(::Type) -> Cint\n\nReturn the FITS BITPIX code for the given Julia type\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.type_from_bitpix","page":"Home","title":"CFITSIO.type_from_bitpix","text":"type_from_bitpix(::Integer) -> Type\n\nReturn the Julia type from the FITS BITPIX code\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.cfitsio_typecode","page":"Home","title":"CFITSIO.cfitsio_typecode","text":"cfitsio_typecode(::Type) -> Cint\n\nReturn the CFITSIO type code for the given Julia type\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#File-access","page":"Home","title":"File access","text":"","category":"section"},{"location":"modules/CFITSIO/","page":"Home","title":"Home","text":"fits_create_file\nfits_create_diskfile\nfits_clobber_file\nfits_open_file\nfits_open_diskfile\nfits_open_table\nfits_open_image\nfits_open_data\nfits_close_file\nfits_delete_file\nfits_file_name\nfits_file_mode","category":"page"},{"location":"modules/CFITSIO/#CFITSIO.fits_create_file","page":"Home","title":"CFITSIO.fits_create_file","text":"fits_create_file(filename::AbstractString)\n\nCreate and open a new empty output FITSFile. This methods uses the extended file name syntax to create the file.\n\nSee also fits_create_diskfile which does not use the extended filename parser.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_create_diskfile","page":"Home","title":"CFITSIO.fits_create_diskfile","text":"fits_create_diskfile(filename::AbstractString)\n\nCreate and open a new empty output FITSFile. Unlike fits_create_file, this function does not use an extended filename parser and treats the string as is as the filename.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_clobber_file","page":"Home","title":"CFITSIO.fits_clobber_file","text":"fits_clobber_file(filename::AbstractString)\n\nLike fits_create_file, but overwrites filename if it exists.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_open_file","page":"Home","title":"CFITSIO.fits_open_file","text":"fits_open_file(filename::String, [mode = 0])\n\nOpen an existing data file.\n\nModes:\n\n0 : Read only (equivalently denoted by CFITSIO.R)\n1 : Read-write (equivalently denoted by CFITSIO.RW)\n\nThis function uses the extended filename syntax to open the file. See also fits_open_diskfile that does not use the extended filename parser and uses filename as is as the name of the file.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_open_diskfile","page":"Home","title":"CFITSIO.fits_open_diskfile","text":"fits_open_diskfile(filename::String, [mode = 0])\n\nOpen an existing data file.\n\nModes:\n\n0 : Read only (equivalently denoted by CFITSIO.R)\n1 : Read-write (equivalently denoted by CFITSIO.RW)\n\nThis function does not use the extended filename parser, and uses filename as is as the name of the file that is to be opened. See also fits_open_file which uses the extended filename syntax.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_open_table","page":"Home","title":"CFITSIO.fits_open_table","text":"fits_open_table(filename::String, [mode = 0])\n\nOpen an existing data file (like fits_open_file) and move to the first HDU containing either an ASCII or a binary table.\n\nModes:\n\n0 : Read only (equivalently denoted by CFITSIO.R)\n1 : Read-write (equivalently denoted by CFITSIO.RW)\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_open_image","page":"Home","title":"CFITSIO.fits_open_image","text":"fits_open_image(filename::String, [mode = 0])\n\nOpen an existing data file (like fits_open_file) and move to the first HDU containing an image.\n\nModes:\n\n0 : Read only (equivalently denoted by CFITSIO.R)\n1 : Read-write (equivalently denoted by CFITSIO.RW)\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_open_data","page":"Home","title":"CFITSIO.fits_open_data","text":"fits_open_data(filename::String, [mode = 0])\n\nOpen an existing data file (like fits_open_file) and move to the first HDU containing either an image or a table.\n\nModes:\n\n0 : Read only (equivalently denoted by CFITSIO.R)\n1 : Read-write (equivalently denoted by CFITSIO.RW)\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_close_file","page":"Home","title":"CFITSIO.fits_close_file","text":"fits_close_file(f::FITSFile)\n\nClose a previously opened FITS file.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_delete_file","page":"Home","title":"CFITSIO.fits_delete_file","text":"fits_delete_file(f::FITSFile)\n\nClose an opened FITS file (like fits_close_file) and removes it from the disk.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_file_name","page":"Home","title":"CFITSIO.fits_file_name","text":"fits_file_name(f::FITSFile)\n\nReturn the name of the file associated with object f.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_file_mode","page":"Home","title":"CFITSIO.fits_file_mode","text":"fits_file_mode(f::FITSFile)\n\nReturn the I/O mode of the FITS file, where 0 indicates a read-only mode and 1 indicates a read-write mode.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#HDU-Routines","page":"Home","title":"HDU Routines","text":"","category":"section"},{"location":"modules/CFITSIO/","page":"Home","title":"Home","text":"The functions described in this section change the current HDU and to find their number and type. The following is a short example which shows how to use them:","category":"page"},{"location":"modules/CFITSIO/","page":"Home","title":"Home","text":"num = fits_get_num_hdus(f)\nprintln(\"Number of HDUs in the file: \", num)\n\nfor i = 1:num\n    hdu_type = fits_movabs_hdu(f, i)\n    println(i, \") hdu_type = \", hdu_type)\nend","category":"page"},{"location":"modules/CFITSIO/","page":"Home","title":"Home","text":"fits_get_num_hdus\nfits_movabs_hdu\nfits_movrel_hdu\nfits_movnam_hdu\nfits_delete_hdu","category":"page"},{"location":"modules/CFITSIO/#CFITSIO.fits_get_num_hdus","page":"Home","title":"CFITSIO.fits_get_num_hdus","text":"fits_get_num_hdus(f::FITSFile)\n\nReturn the number of HDUs in the file.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_movabs_hdu","page":"Home","title":"CFITSIO.fits_movabs_hdu","text":"fits_movabs_hdu(f::FITSFile, hduNum::Integer)\n\nChange the current HDU to the value specified by hduNum, and return a symbol describing the type of the HDU.\n\nPossible symbols are: image_hdu, ascii_table, or binary_table. The value of hduNum must range between 1 and the value returned by fits_get_num_hdus.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_movrel_hdu","page":"Home","title":"CFITSIO.fits_movrel_hdu","text":"fits_movrel_hdu(f::FITSFile, hduNum::Integer)\n\nChange the current HDU by moving forward or backward by hduNum HDUs (positive means forward), and return the same as fits_movabs_hdu.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_movnam_hdu","page":"Home","title":"CFITSIO.fits_movnam_hdu","text":"fits_movnam_hdu(f::FITSFile, extname::String, extver::Integer=0,\n      hdu_type_int::Integer=-1)\n\nChange the current HDU by moving to the (first) HDU which has the specified extension type and EXTNAME and EXTVER keyword values (or HDUNAME and HDUVER keywords).\n\nIf extver is 0 (the default) then the EXTVER keyword is ignored and the first HDU with a matching EXTNAME (or HDUNAME) keyword will be found. If hdu_type_int is -1 (the default) only the extname and extver values will be used to locate the correct extension. If no matching HDU is found in the file, the current HDU will remain unchanged.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_delete_hdu","page":"Home","title":"CFITSIO.fits_delete_hdu","text":"fits_delete_hdu(f::FITSFile)\n\nDelete the HDU from the FITS file and shift the following HDUs forward. If f is the primary HDU in the file then it'll be replaced by a null primary HDU with no data and minimal header information.\n\nReturn a symbol to indicate the type of the new current HDU. Possible symbols are: image_hdu, ascii_table, or binary_table. The value of hduNum must range between 1 and the value returned by fits_get_num_hdus.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#Header-Keyword-Routines","page":"Home","title":"Header Keyword Routines","text":"","category":"section"},{"location":"modules/CFITSIO/","page":"Home","title":"Home","text":"fits_get_hdrspace\nfits_read_keyword\nfits_read_record\nfits_read_keyn\nfits_write_key\nfits_write_record\nfits_delete_record\nfits_delete_key\nfits_hdr2str","category":"page"},{"location":"modules/CFITSIO/#CFITSIO.fits_get_hdrspace","page":"Home","title":"CFITSIO.fits_get_hdrspace","text":"fits_get_hdrspace(f::FITSFile) -> (keysexist, morekeys)\n\nReturn the number of existing keywords (not counting the END keyword) and the amount of space currently available for more keywords.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_read_keyword","page":"Home","title":"CFITSIO.fits_read_keyword","text":"fits_read_keyword(f::FITSFile, keyname::String) -> (value, comment)\n\nyields the specified keyword value and commend (as a tuple of strings), throws and error if the keyword is not found.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_read_record","page":"Home","title":"CFITSIO.fits_read_record","text":"fits_read_record(f::FITSFile, keynum::Int) -> String\n\nReturn the nth header record in the CHU. The first keyword in the header is at keynum = 1.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_read_keyn","page":"Home","title":"CFITSIO.fits_read_keyn","text":"fits_read_keyn(f::FITSFile, keynum::Int) -> (name, value, comment)\n\nReturn the nth header record in the CHU. The first keyword in the header is at keynum = 1.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_write_key","page":"Home","title":"CFITSIO.fits_write_key","text":"fits_write_key(f::FITSFile, keyname::String, value, comment::String)\n\nWrite a keyword of the appropriate data type into the CHU.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_write_record","page":"Home","title":"CFITSIO.fits_write_record","text":"fits_write_record(f::FITSFile, card::String)\n\nWrite a user specified keyword record into the CHU.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_delete_record","page":"Home","title":"CFITSIO.fits_delete_record","text":"fits_delete_record(f::FITSFile, keynum::Int)\n\nDelete the keyword record at the specified index.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_delete_key","page":"Home","title":"CFITSIO.fits_delete_key","text":"fits_delete_key(f::FITSFile, keyname::String)\n\nDelete the keyword named keyname.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_hdr2str","page":"Home","title":"CFITSIO.fits_hdr2str","text":"fits_hdr2str(f::FITSFile, nocomments::Bool=false)\n\nReturn the header of the CHDU as a string. If nocomments is true, comment cards are stripped from the output.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#Image-HDU-Routines","page":"Home","title":"Image HDU Routines","text":"","category":"section"},{"location":"modules/CFITSIO/","page":"Home","title":"Home","text":"fits_get_img_size\nfits_create_img\nfits_insert_img\nfits_write_pix\nfits_write_pixnull\nfits_write_subset\nfits_read_pix\nfits_read_pixnull\nfits_read_subset\nfits_copy_image_section\nfits_write_null_img\nfits_resize_img","category":"page"},{"location":"modules/CFITSIO/#CFITSIO.fits_get_img_size","page":"Home","title":"CFITSIO.fits_get_img_size","text":"fits_get_img_size(f::FITSFile)\n\nGet the dimensions of the image.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_create_img","page":"Home","title":"CFITSIO.fits_create_img","text":"fits_create_img(f::FITSFile, T::Type, naxes::Vector{<:Integer})\n\nCreate a new primary array or IMAGE extension with the specified data type T and size naxes.\n\n\n\n\n\nfits_create_img(f::FITSFile, A::AbstractArray)\n\nCreate a new primary array or IMAGE extension with the element type and size of A, that is capable of storing the entire array A.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_insert_img","page":"Home","title":"CFITSIO.fits_insert_img","text":"fits_insert_img(f::FITSFile, T::Type, naxes::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}})\n\nInsert a new image extension immediately following the CHDU, or insert a new Primary Array at the beginning of the file.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_write_pix","page":"Home","title":"CFITSIO.fits_write_pix","text":"fits_write_pix(f::FITSFile, fpixel::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}, nelements::Integer, data::StridedArray)\n\nWrite nelements pixels from data into the FITS file starting from the pixel fpixel.\n\nnote: Note\ndata needs to be stored contiguously in memory.\n\nSee also: fits_write_pixnull\n\n\n\n\n\nfits_write_pix(f::FITSFile, data::StridedArray)\n\nWrite the entire array data into the FITS file.\n\nnote: Note\ndata needs to be stored contiguously in memory.\n\nSee also: fits_write_pixnull, fits_write_subset\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_write_pixnull","page":"Home","title":"CFITSIO.fits_write_pixnull","text":"fits_write_pixnull(f::FITSFile, fpixel::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}, nelements::Integer, data::StridedArray, nulval)\n\nWrite nelements pixels from data into the FITS file starting from the pixel fpixel. The argument nulval specifies the values that are to be considered as \"null values\", and replaced by appropriate numbers corresponding to the element type of data.\n\nnote: Note\ndata needs to be stored contiguously in memory.\n\nSee also: fits_write_pix\n\n\n\n\n\nfits_write_pixnull(f::FITSFile, data::StridedArray, nulval)\n\nWrite the entire array data into the FITS file. The argument nulval specifies the values that are to be considered as \"null values\", and replaced by appropriate numbers corresponding to the element type of data.\n\nnote: Note\ndata needs to be stored contiguously in memory.\n\nSee also: fits_write_pix\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_write_subset","page":"Home","title":"CFITSIO.fits_write_subset","text":"fits_write_subset(f::FITSFile, fpixel::V, lpixel::V, data::StridedArray) where {V<:Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}}\n\nWrite a rectangular section of the FITS image. The number of pixels to be written will be computed from the first and last pixels (specified as the fpixel and lpixel arguments respectively).\n\nnote: Note\nThe section to be written out must be contiguous in memory, so all the dimensions aside from the last one must span the entire axis range. The arguments fpixel and lpixel must account for this.\n\nSee also: fits_write_pix\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_read_pix","page":"Home","title":"CFITSIO.fits_read_pix","text":"fits_read_pix(f::FITSFile, fpixel::NTuple{Vector{<:Integer}, Tuple{Vararg{Integer}}}, nelements::Integer, [nulval], data::StridedArray)\n\nRead nelements pixels from the FITS file into data starting from the pixel fpixel. If the optional argument nulval is specified and is non-zero, any null value present in the array will be replaced by it.\n\nnote: Note\ndata needs to be stored contiguously in memory.\n\nSee also: fits_read_pixnull, fits_read_subset\n\n\n\n\n\nfits_read_pix(f::FITSFile, data::StridedArray, [nulval])\n\nRead length(data) pixels from the FITS file into data starting from the first pixel. The optional argument nulval, if specified and non-zero, is used to replace any null value present in the array.\n\nnote: Note\ndata needs to be stored contiguously in memory.\n\nSee also: fits_read_pixnull\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_read_pixnull","page":"Home","title":"CFITSIO.fits_read_pixnull","text":"fits_read_pixnull(f::FITSFile, fpixel::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}, nelements::Integer, data::StridedArray, nullarray::Array{UInt8})\n\nRead nelements pixels from the FITS file into data starting from the pixel fpixel. At output, the indices of nullarray where data has a corresponding null value are set to 1.\n\nnote: Note\ndata needs to be stored contiguously in memory.\n\nSee also: fits_read_pix\n\n\n\n\n\nfits_read_pixnull(f::FITSFile, data::StridedArray, nullarray::Array{UInt8})\n\nRead length(data) pixels from the FITS file into data starting from the first pixel. At output, the indices of nullarray where data has a corresponding null value are set to 1.\n\nnote: Note\ndata needs to be stored contiguously in memory.\n\nSee also: fits_read_pix\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_read_subset","page":"Home","title":"CFITSIO.fits_read_subset","text":"fits_read_subset(f::FITSFile, fpixel::V, lpixel::V, inc::V, [nulval], data::StridedArray) where {V<:Union{Vector{<:Integer}, Tuple{Vararg{Integer}}}}\n\nRead a rectangular section of the FITS image. The number of pixels to be read will be computed from the first and last pixels (specified as the fpixel and lpixel arguments respectively). The argument inc specifies the step-size in pixels along each dimension.\n\nIf the optional argument nulval is specified and is non-zero, null values in data will be replaced by it.\n\nnote: Note\ndata needs to be stored contiguously in memory, and will be populated contiguously with the pixels that are read in.\n\nSee also: fits_read_pix\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_copy_image_section","page":"Home","title":"CFITSIO.fits_copy_image_section","text":"fits_copy_image_section(fin::FITSFile, fout::FITSFile, section::String)\n\nCopy a rectangular section of an image from fin and write it to a new FITS primary image or image extension in fout. The section specifier is described on the CFITSIO website.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_write_null_img","page":"Home","title":"CFITSIO.fits_write_null_img","text":"fits_write_null_img(f::FITSFile, firstelem::Integer, nelements::Integer)\n\nSet a stretch of elements to the appropriate null value, starting from the pixel number firstelem and extending over nelements pixels.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_resize_img","page":"Home","title":"CFITSIO.fits_resize_img","text":"fits_resize_img(f::FITSFile, T::Type, naxis::Integer, sz::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}})\n\nModify the size, dimensions and optionally the element type of the image in f. The new image will have an element type T, be a naxis-dimensional image with size sz. If the new image is larger than the existing one, it will be zero-padded at the end. If the new image is smaller, existing image data will be truncated.\n\nfits_resize_img(f::FITSFile, sz::Union{Vector{<:Integer}, Tuple{Vararg{Integer}}})\n\nResize the image to the new size sz. The element type is preserved, and the number of dimensions is set equal to length(sz).\n\nfits_resize_img(f::FITSFile, T::Type)\n\nChange the element type of the image to T, leaving the size unchanged.\n\nnote: Note\nThis method reinterprets the data instead of coercing the elements.\n\nExample\n\njulia> f = fits_clobber_file(tempname());\n\njulia> a = [1 2; 3 4];\n\njulia> fits_create_img(f, a);\n\njulia> fits_write_pix(f, a);\n\njulia> fits_get_img_size(f)\n2-element Vector{Int64}:\n 2\n 2\n\njulia> fits_resize_img(f, [3,3]);\n\njulia> fits_get_img_size(f)\n2-element Vector{Int64}:\n 3\n 3\n\njulia> b = similar(a, (3,3));\n\njulia> fits_read_pix(f, b); b\n3×3 Matrix{Int64}:\n 1  4  0\n 3  0  0\n 2  0  0\n\njulia> fits_resize_img(f, [4]);\n\njulia> b = similar(a, (4,));\n\njulia> fits_read_pix(f, b); b\n4-element Vector{Int64}:\n 1\n 3\n 2\n 4\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#Table-Routines","page":"Home","title":"Table Routines","text":"","category":"section"},{"location":"modules/CFITSIO/","page":"Home","title":"Home","text":"There are two functions to create a new HDU table extension: fits_create_ascii_table and fits_create_binary_table. In general, one should pick the second as binary tables require less space on the disk and are more efficient to read and write. (Moreover, a few datatypes are not supported in ASCII tables). In order to create a table, the programmer must specify the characteristics of each column by passing an array of tuples. Here is an example:","category":"page"},{"location":"modules/CFITSIO/","page":"Home","title":"Home","text":"f = fits_create_file(\"!new.fits\")\ncoldefs = [(\"SPEED\", \"1D\", \"m/s\"),\n           (\"MASS\", \"1E\", \"kg\"),\n           (\"PARTICLE\", \"20A\", \"Name\")]\nfits_create_binary_tbl(f, 10, coldefs, \"PARTICLE\")","category":"page"},{"location":"modules/CFITSIO/","page":"Home","title":"Home","text":"This example creates a table with room for 10 entries, each of them describing the characteristics of a particle: its speed, its mass, and its name (codified as a 20-character string). See the documentation of fits_create_ascii_tbl for more details.","category":"page"},{"location":"modules/CFITSIO/","page":"Home","title":"Home","text":"fits_create_ascii_tbl\nfits_create_binary_tbl\nfits_get_coltype\nfits_insert_rows\nfits_delete_rows\nfits_read_col\nfits_write_col","category":"page"},{"location":"modules/CFITSIO/#CFITSIO.fits_create_ascii_tbl","page":"Home","title":"CFITSIO.fits_create_ascii_tbl","text":"fits_create_ascii_tbl(f::FITSFile, numrows::Integer, coldefs::Array{CFITSIO.ColumnDef},\n            extname::String)\n\nAppend a new HDU containing an ASCII table.\n\nThe table will have numrows rows (this parameter can be set to zero), each initialized with the default value. In order to create a table, the programmer must specify the characteristics of each column. The columns are specified by the coldefs variable, which is an array of tuples. Each tuple must have three string fields:\n\nThe name of the column.\nThe data type and the repetition count. It must be a string made by a number\n\n(the repetition count) followed by a letter specifying the type (in the example above, D stands for Float64, E stands for Float32, A stands for Char). Refer to the CFITSIO documentation for more information about the syntax of this parameter.\n\nThe measure unit of this field. This is used only as a comment.\n\nThe value of extname sets the \"extended name\" of the table, i.e., a string that in some situations can be used to refer to the HDU itself.\n\nNote that, unlike for binary tables, CFITSIO puts some limitations to the types that can be used in an ASCII table column. Refer to the CFITSIO manual for further information.\n\nSee also fits_create_binary_tbl for a similar function which creates binary tables.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_create_binary_tbl","page":"Home","title":"CFITSIO.fits_create_binary_tbl","text":"fits_create_binary_tbl(f::FITSFile, numrows::Integer, coldefs::Array{ColumnDef},\n             extname::String)\n\nAppend a new HDU containing a binary table. The meaning of the parameters is the same as in a call to fits_create_ascii_tbl.\n\nIn general, one should pick this function for creating tables in a new HDU, as binary tables require less space on the disk and are more efficient to read and write. (Moreover, a few datatypes are not supported in ASCII tables).\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_get_coltype","page":"Home","title":"CFITSIO.fits_get_coltype","text":"fits_get_coltype(f::FITSFile, colnum::Integer)\n\nProvided that the current HDU contains either an ASCII or binary table, return information about the column at position colnum (counting from 1).\n\nReturn is a tuple containing\n\ntypecode: CFITSIO integer type code of the column.\nrepcount: Repetition count for the column.\nwidth: Width of an individual element.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_insert_rows","page":"Home","title":"CFITSIO.fits_insert_rows","text":"fits_insert_rows(f::FITSFile, firstrow::Integer, nrows::Integer)\n\nInsert a number of rows equal to nrows after the row number firstrow.\n\nThe elements in each row are initialized to their default value: you can modify them later using fits_write_col.\n\nSince the first row is at position 1, in order to insert rows before the first one firstrow must be equal to zero.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_delete_rows","page":"Home","title":"CFITSIO.fits_delete_rows","text":"fits_delete_rows(f::FITSFile, firstrow::integer, nrows::Integer)\n\nDelete nrows rows, starting from the one at position firstrow. The index of the first row is 1.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_read_col","page":"Home","title":"CFITSIO.fits_read_col","text":"fits_read_col(f, colnum, firstrow, firstelem, data)\n\nRead data from one column of an ASCII/binary table and convert the data into the specified type T.\n\nArguments\n\nf::FITSFile: the file to be read.\ncolnum::Integer: the column number, where the value of the first column is 1.\nfirstrow::Integer: the elements to be read start from this row.\nfirstelem::Integer: specifies which is the first element to be read, when each\n\ncell contains more than one element (i.e., the \"repetition count\" of the field is greater than one).\n\ndata::Array: at the end of the call, this will be filled with the elements read\n\nfrom the column. The length of the array gives the overall number of elements.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#CFITSIO.fits_write_col","page":"Home","title":"CFITSIO.fits_write_col","text":"fits_write_col(f, colnum, firstrow, firstelem, data)\n\nWrite some data in one column of a ASCII/binary table.\n\nIf there is no room for the elements, new rows will be created. (It is therefore useless to call fits_insert_rows if you only need to append elements to the end of a table.)\n\nf::FITSFile: the file in which data will be written.\ncolnum::Integer: the column number, where the value of the first column is 1.\nfirstrow::Integer: the data wil be written from this row onwards.\nfirstelem::Integer: specifies the position in the row where the first element\n\nwill be written.\n\ndata::Array: contains the elements that are to be written to the column of the table.\n\n\n\n\n\n","category":"function"},{"location":"modules/CFITSIO/#Miscellaneous","page":"Home","title":"Miscellaneous","text":"","category":"section"},{"location":"modules/CFITSIO/","page":"Home","title":"Home","text":"libcfitsio_version","category":"page"},{"location":"modules/CFITSIO/#CFITSIO.libcfitsio_version","page":"Home","title":"CFITSIO.libcfitsio_version","text":"libcfitsio_version() -> VersionNumber\n\nReturn the version of the underlying CFITSIO library\n\nExample\n\njulia> libcfitsio_version()\nv\"3.37.0\"\n\n\n\n\n\n","category":"function"},{"location":"highlevels/vizplot/#Visualization-and-Plotting-Overview","page":"Visualization & Plotting Overview","title":"Visualization & Plotting Overview","text":"","category":"section"},{"location":"highlevels/vizplot/#[AstroImages.jl](https://github.com/JuliaAstro/AstroImages.jl)-[![](../assets/book.png)](https://juliaastro.github.io/AstroImages.jl/stable/)","page":"Visualization & Plotting Overview","title":"AstroImages.jl (Image: )","text":"","category":"section"},{"location":"highlevels/vizplot/","page":"Visualization & Plotting Overview","title":"Visualization & Plotting Overview","text":"Load, manipulate, and visualize astronomical images","category":"page"},{"location":"highlevels/vizplot/","page":"Visualization & Plotting Overview","title":"Visualization & Plotting Overview","text":"Works with the FileIO.jl interface\nAutomatic visualizations are directly integrated into many environments like VSCode, Pluto.jl, and IJulia.jl\nIncludes recipes for plotting with Plots.jl","category":"page"},{"location":"highlevels/vizplot/#[SAOImageDS9.jl](https://github.com/JuliaAstro/SAOImageDS9.jl)-[![](../assets/book.png)](https://juliaastro.github.io/SAOImageDS9.jl/stable/)","page":"Visualization & Plotting Overview","title":"SAOImageDS9.jl (Image: )","text":"","category":"section"},{"location":"highlevels/vizplot/","page":"Visualization & Plotting Overview","title":"Visualization & Plotting Overview","text":"Interface with the DS9 image viewer","category":"page"},{"location":"highlevels/vizplot/","page":"Visualization & Plotting Overview","title":"Visualization & Plotting Overview","text":"Uses XPA.jl to communicate with DS9 instances\nEasily display images in DS9 and add features like circles and lines\nLow-level API accessible with set and get","category":"page"},{"location":"modules/AstroTime/api/periods/#Periods","page":"Periods","title":"Periods","text":"","category":"section"},{"location":"modules/AstroTime/api/periods/","page":"Periods","title":"Periods","text":"Modules = [AstroTime.Periods]\nPrivate = false","category":"page"},{"location":"modules/AstroTime/api/periods/#AstroTime.Periods.AstroPeriod","page":"Periods","title":"AstroTime.Periods.AstroPeriod","text":"AstroPeriod{U, T}(unit, Δt) where {U<:TimeUnit, T}\n\nAn AstroPeriod object represents a time interval of Δt with a TimeUnit of unit.  Periods should be constructed via the shorthand syntax shown in the examples below.\n\nExamples\n\njulia> 3.0seconds\n3.0 seconds\n\njulia> 1.0minutes\n1.0 minutes\n\njulia> 12hours\n12.0 hours\n\njulia> days_per_year = 365\n365\njulia> days_per_year * days\n365.0 days\n\njulia> 10.0years\n10.0 years\n\njulia> 1centuries\n1.0 centuries\n\n\n\n\n\n","category":"type"},{"location":"modules/AstroTime/api/periods/#AstroTime.Periods.TimeUnit","page":"Periods","title":"AstroTime.Periods.TimeUnit","text":"All time units are subtypes of the abstract type TimeUnit. The following time units are defined:\n\nSecond\nMinute\nHour\nDay\nYear\nCentury\n\n\n\n\n\n","category":"type"},{"location":"modules/AstroTime/api/periods/#AstroTime.Periods.unit-Tuple{AstroPeriod}","page":"Periods","title":"AstroTime.Periods.unit","text":"unit(p::AstroPeriod)\n\nReturn the unit of the period p.\n\nExamples\n\njulia> unit(3.0seconds)\nAstroTime.Periods.Second()\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/periods/#AstroTime.Periods.value-Tuple{AstroPeriod}","page":"Periods","title":"AstroTime.Periods.value","text":"value(p::AstroPeriod)\n\nReturn the unitless value of the period p.\n\nExamples\n\njulia> value(3.0seconds)\n3.0\n\n\n\n\n\n","category":"method"},{"location":"modules/SAOImageDS9/connect/#Connection-to-a-specific-server","page":"Connection to a specific server","title":"Connection to a specific server","text":"","category":"section"},{"location":"modules/SAOImageDS9/connect/","page":"Connection to a specific server","title":"Connection to a specific server","text":"When SAOImageDS9.connect() is called without any argument, all subsequent requests will be sent to the first SAOImage/DS9 instance found by the XPA name server.  To send further requests to a specific SAOImage/DS9 server, you may do:","category":"page"},{"location":"modules/SAOImageDS9/connect/","page":"Connection to a specific server","title":"Connection to a specific server","text":"SAOImageDS9.connect(apt) -> ident","category":"page"},{"location":"modules/SAOImageDS9/connect/","page":"Connection to a specific server","title":"Connection to a specific server","text":"where apt is a string identifying a specific XPA access point.  The returned value is the fully qualified identifier of the access point, it has the form host:port for a TCP/IP socket or it is the path to the socket file for an AF/Unix socket.  The access point apt may be a fully qualified identifier or a template of the form class:name like \"DS9:*\" which corresponds to any server of the class \"DS9\".  Note that name is the argument of the -title option when SAOImage/DS9 is launched.  See XPA Template for a complete description.  When SAOImageDS9.connect() is called with no arguments or with a template containing wild characters, it automatically connects to the first access point matching the template (\"DS9.*\" by default) with a warning if no access points, or if more than one access point are found.","category":"page"},{"location":"modules/SAOImageDS9/connect/","page":"Connection to a specific server","title":"Connection to a specific server","text":"To retrieve the identifier of the current access point to SAOImage/DS9, you may call:","category":"page"},{"location":"modules/SAOImageDS9/connect/","page":"Connection to a specific server","title":"Connection to a specific server","text":"SAOImageDS9.accesspoint()","category":"page"},{"location":"modules/SAOImageDS9/connect/","page":"Connection to a specific server","title":"Connection to a specific server","text":"which yields an empty string if there are no current connection.","category":"page"},{"location":"modules/SAOImageDS9/connect/","page":"Connection to a specific server","title":"Connection to a specific server","text":"Remember that all requests are sent to a given access point, but you may switch between SAOImage/DS9 servers.  For instance:","category":"page"},{"location":"modules/SAOImageDS9/connect/","page":"Connection to a specific server","title":"Connection to a specific server","text":"apt1 = SAOImageDS9.accesspoint()             # retrieve current access point\napt2 = SAOImageDS9.connect(\"DS9:some_name\")  # second access point\nSAOImageDS9.set(arr)                         # send an image to apt2\nSAOImageDS9.connect(apt1);                   # switch to apt1\nSAOImageDS9.set(\"zoom to\", 1.4)              # set zoom in apt1","category":"page"},{"location":"modules/Transits/#Transits.jl","page":"Transits","title":"Transits.jl","text":"","category":"section"},{"location":"modules/Transits/","page":"Transits","title":"Transits","text":"(Image: Build Status) (Image: PkgEval) (Image: Coverage) (Image: License)","category":"page"},{"location":"modules/Transits/","page":"Transits","title":"Transits","text":"(Image: Stable) (Image: Dev) (Image: DOI)","category":"page"},{"location":"modules/Transits/","page":"Transits","title":"Transits","text":"Flexible photometric transit curves with limb darkening. The goals of this package are, in this order","category":"page"},{"location":"modules/Transits/","page":"Transits","title":"Transits","text":"have a simple interface with high composability\nbe flexible with respect to numeric types and application\nbe fully compatible with ChainRules.jl automatic differentiation (AD) system to leverage the derived analytical gradients\nprovide a codebase that is well-organized, instructive, and easy to extend\nmaintain high performance: at least as fast as similar tools","category":"page"},{"location":"modules/Transits/","page":"Transits","title":"Transits","text":"WIP: Currently under progress by @mileslucas","category":"page"},{"location":"modules/Transits/#Current-TODO-list","page":"Transits","title":"Current TODO list","text":"","category":"section"},{"location":"modules/Transits/","page":"Transits","title":"Transits","text":"in some order of importance","category":"page"},{"location":"modules/Transits/","page":"Transits","title":"Transits","text":"[x] ~Finish writing KeplerOrbit (help wanted)~\n[x] ~Gradients using ChainRulesCore~\n[x] ~Gradient tests using ChainRulesTestUtils~\n[x] ~Kipping prior distributions (with gradients) (help wanted)~\n[x] ~documenation section \"Introduction\" describing transits and talking about science, very expository (help wanted)~\n[ ] Plotting functions (recreate ALFM 20 plots)\nrecipe for lightcurve which automatically makes a simple orbit and shows features\nsimilar as above but special one for SecondaryLimbDark to side-by-side plot secondary\nfigure 3 and 6 can be written with recipe\n[ ] examples (show rich composability of julia)\nWe can use Pluto notebooks for examples that are learning-oriented\nFor tutorials and problem-oriented examples prefer a Julia script that can be weaved into the docs (with Literate.jl e.g.) (or just as easily weaved into a jupyter notebook!)\n[ ] benchmarks (recreate ALFM 20 plots)\nI have some code in bench/speed.jl. This needs modularized- the benchmark function can be rewritten like benchmark(f, Nu, Npts) and abstracted for f as types.\nonce the code is reorganized (maybe even put the new benchmark in a module for future thinking) decide whether to save data or save images, then build the link with the documentation\nneed to add benchmarks for the python code. PyCall has worked fine for benchmarking for me in the past, so lets write the driver in Julia. here is a link to the plotting code from ALFM\nin general, the more this can be automated the better (including CI!)\n[ ] look at simpson integrated light curve (ALFM 20)","category":"page"},{"location":"modules/Transits/","page":"Transits","title":"Transits","text":"If you would like to contribute, feel free to open a pull request. If you want to discuss something before contributing, head over to discussions and join or open a new topic.","category":"page"},{"location":"modules/Transits/#Installation","page":"Transits","title":"Installation","text":"","category":"section"},{"location":"modules/Transits/","page":"Transits","title":"Transits","text":"To install use Pkg. From the REPL, press ] to enter Pkg-mode","category":"page"},{"location":"modules/Transits/","page":"Transits","title":"Transits","text":"pkg> add Transits","category":"page"},{"location":"modules/Transits/","page":"Transits","title":"Transits","text":"If you want to use the most up-to-date version of the code, check it out from main","category":"page"},{"location":"modules/Transits/","page":"Transits","title":"Transits","text":"pkg> add Transits#main","category":"page"},{"location":"modules/Transits/#Usage","page":"Transits","title":"Usage","text":"","category":"section"},{"location":"modules/Transits/","page":"Transits","title":"Transits","text":"using Transits\n\norbit = SimpleOrbit(period=3, duration=1)\nu = [0.4, 0.26] # quad limb dark\nld = PolynomialLimbDark(u)\n\nt = range(-1, 1, length=1000) # days from t0\nrs = range(0, 0.2, length=10) # radius ratio\n\nfluxes = @. ld(orbit, t, rs')","category":"page"},{"location":"modules/Transits/","page":"Transits","title":"Transits","text":"(Image: )","category":"page"},{"location":"modules/Transits/#Integrated-and-Secondary-Curves","page":"Transits","title":"Integrated and Secondary Curves","text":"","category":"section"},{"location":"modules/Transits/","page":"Transits","title":"Transits","text":"IntegratedLimbDark can be used to numerically integrate each light curve exposure in time","category":"page"},{"location":"modules/Transits/","page":"Transits","title":"Transits","text":"ld = IntegratedLimbDark([0.4, 0.26])\norbit = SimpleOrbit(period=3, duration=1)\nt = range(-1, 1, length=1000)\ntexp = [0.1 0.2 0.3]\n# no extra calculations made\nflux = @. ld(orbit, t, 0.2)\n# use quadrature to find time-averaged flux for each t\nflux_int = @. ld(orbit, t, 0.2, texp)","category":"page"},{"location":"modules/Transits/","page":"Transits","title":"Transits","text":"(Image: )","category":"page"},{"location":"modules/Transits/","page":"Transits","title":"Transits","text":"SecondaryLimbDark can be used to generate secondary eclipses given a surface brightness ratio","category":"page"},{"location":"modules/Transits/","page":"Transits","title":"Transits","text":"ld = SecondaryLimbDark([0.4, 0.26], brightness_ratio=0.1)\nld_int = IntegratedLimbDark(ld) # composition works flawlessly\n\norbit = SimpleOrbit(period=4, duration=1)\nt = range(-1.25, 2.75, length=1000)\nrs = range(0.01, 0.1, length=6)\n\nf = @. ld(orbit, t, rs')\nf_int = @. ld_int(orbit, t, rs', texp=0.3)","category":"page"},{"location":"modules/Transits/","page":"Transits","title":"Transits","text":"(Image: )","category":"page"},{"location":"modules/Transits/#Using-Units","page":"Transits","title":"Using Units","text":"","category":"section"},{"location":"modules/Transits/","page":"Transits","title":"Transits","text":"Units from Unitful.jl are a drop-in substitution for numbers","category":"page"},{"location":"modules/Transits/","page":"Transits","title":"Transits","text":"using Unitful\norbit = SimpleOrbit(period=10u\"d\", duration=5u\"hr\")\nt = range(-6, 6, length=1000)u\"hr\"\nflux = @. ld(orbit, t, 0.1)","category":"page"},{"location":"modules/Transits/#Citations","page":"Transits","title":"Citations","text":"","category":"section"},{"location":"modules/Transits/","page":"Transits","title":"Transits","text":"If you use Transits.jl or a derivative of it in your work please consider citing it at the Zenodo DOI. If you use PolynomialLimbDark or QuadLimbDark please also cite Agol et al. (2020) and Luger et al. (2019). If you use Kipping13 please cite Kipping (2013). BibTeX for all those citations can be found in CITATIONS.bib.","category":"page"},{"location":"modules/AstroImages/guide/reproject/#Reprojecting-Images","page":"Reprojecting Images","title":"Reprojecting Images","text":"","category":"section"},{"location":"modules/AstroImages/guide/reproject/","page":"Reprojecting Images","title":"Reprojecting Images","text":"Integration with the Reproject.jl package is not yet complete.","category":"page"},{"location":"modules/AstroImages/manual/preserving-wrapper/#Preserving-the-AstroImage-Wrapper","page":"Preserving Wrapper","title":"Preserving the AstroImage Wrapper","text":"","category":"section"},{"location":"modules/AstroImages/manual/preserving-wrapper/","page":"Preserving Wrapper","title":"Preserving Wrapper","text":"Wherever possible, overloads have been added to DimensionalData and AstroImages so that common operations retain the AstroImage wrapper with associated dimensions, FITS header, and WCS information. Most of the time this works automatically if libraries follow good patterns like allocating outputs using Base.similar. However, some other library functions may follow patterns like allocating a plain Array of the correct size and then filling it. ","category":"page"},{"location":"modules/AstroImages/manual/preserving-wrapper/","page":"Preserving Wrapper","title":"Preserving Wrapper","text":"To make it easier to work with these libraries, AstroImages exports two functions copyheader and shareheader.  These functions wrap an AbstractArray in an AstroImage while copying over the header, dimensions, and WCS info.","category":"page"},{"location":"modules/AstroImages/manual/preserving-wrapper/","page":"Preserving Wrapper","title":"Preserving Wrapper","text":"Consider the function:","category":"page"},{"location":"modules/AstroImages/manual/preserving-wrapper/","page":"Preserving Wrapper","title":"Preserving Wrapper","text":"function badfunc(arr)\n    out = zeros(size(arr)) # instead of similar(arr)\n    out .= arr.^2\n    return out\nend","category":"page"},{"location":"modules/AstroImages/manual/preserving-wrapper/","page":"Preserving Wrapper","title":"Preserving Wrapper","text":"Calling badfunc(astroimg) will return a plain Array .","category":"page"},{"location":"modules/AstroImages/manual/preserving-wrapper/","page":"Preserving Wrapper","title":"Preserving Wrapper","text":"We can use copyheader to retain the AstroImage wrapper:","category":"page"},{"location":"modules/AstroImages/manual/preserving-wrapper/","page":"Preserving Wrapper","title":"Preserving Wrapper","text":"copyheader(astroimg, badfunc(astroimg))","category":"page"},{"location":"modules/AstroImages/manual/preserving-wrapper/","page":"Preserving Wrapper","title":"Preserving Wrapper","text":"For particularly incompatible functions that require an Array (not subtype of AbstractArray) we can go one step further:","category":"page"},{"location":"modules/AstroImages/manual/preserving-wrapper/","page":"Preserving Wrapper","title":"Preserving Wrapper","text":"copyheader(astroimg, worsefunc(parent(astroimg)))\n# Or:\ncopyheader(astroimg, worsefunc(collect(astroimg)))","category":"page"},{"location":"modules/AstroTime/#AstroTime","page":"Home","title":"AstroTime","text":"","category":"section"},{"location":"modules/AstroTime/","page":"Home","title":"Home","text":"Astronomical time keeping in Julia","category":"page"},{"location":"modules/AstroTime/","page":"Home","title":"Home","text":"AstroTime.jl provides a high-precision, time-scale aware, DateTime-like data type which supports all commonly used astronomical time scales.","category":"page"},{"location":"modules/AstroTime/#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"modules/AstroTime/","page":"Home","title":"Home","text":"The package can be installed through Julia's package manager:","category":"page"},{"location":"modules/AstroTime/","page":"Home","title":"Home","text":"julia> import Pkg; Pkg.add(\"AstroTime\")","category":"page"},{"location":"modules/AstroTime/#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"modules/AstroTime/","page":"Home","title":"Home","text":"# Create an Epoch based on the TT (Terrestial Time) scale\ntt = TTEpoch(\"2018-01-01T12:00:00\")\n\n# Transform to TAI (International Atomic Time)\ntai = TAIEpoch(tt)\n\n# Transform to TDB (Barycentric Dynamical Time)\ntdb = TDBEpoch(tai)\n\n# Shift an Epoch by one day\nanother_day = tt + 1days","category":"page"},{"location":"modules/AstroTime/#Next-Steps","page":"Home","title":"Next Steps","text":"","category":"section"},{"location":"modules/AstroTime/","page":"Home","title":"Home","text":"Follow the Tutorial to get an in-depth look at AstroTime.jl's functionality.","category":"page"},{"location":"modules/AstroImages/manual/converting-from-rgb/#Converting-From-RGB-Images","page":"Converting from RGB","title":"Converting From RGB Images","text":"","category":"section"},{"location":"modules/AstroImages/manual/converting-from-rgb/","page":"Converting from RGB","title":"Converting from RGB","text":"If you encouter an image in a standard graphics format (e.g. PNG, JPG) that you want to analyze or store in an AstroImage, it will likely contain RGB (or similar) pixels. ","category":"page"},{"location":"modules/AstroImages/manual/converting-from-rgb/","page":"Converting from RGB","title":"Converting from RGB","text":"It is possible to store RGB data in an AstroImage. Let's see how that works:","category":"page"},{"location":"modules/AstroImages/manual/converting-from-rgb/","page":"Converting from RGB","title":"Converting from RGB","text":"using AstroImages\ndownload(\"http://www.astro.uvic.ca/~wthompson/astroimages/fits/mw-crop2-small.png\",\"mw-crop2-small.png\")\n\n# First we load it from the PNG file\nmw_png = load(\"mw-crop2-small.png\")","category":"page"},{"location":"modules/AstroImages/manual/converting-from-rgb/","page":"Converting from RGB","title":"Converting from RGB","text":"You will need the Images.jl package installed to load formats like PNG. Once the RGB image is loaded, we can store it in an AstroImage if we'd like:","category":"page"},{"location":"modules/AstroImages/manual/converting-from-rgb/","page":"Converting from RGB","title":"Converting from RGB","text":"mw_ai = AstroImage(mw_png)","category":"page"},{"location":"modules/AstroImages/manual/converting-from-rgb/","page":"Converting from RGB","title":"Converting from RGB","text":"However, we may want to extract the RGB channels first. We can do this using Images.channelview.","category":"page"},{"location":"modules/AstroImages/manual/converting-from-rgb/","page":"Converting from RGB","title":"Converting from RGB","text":"Images.channelview returns a view into the RGB data as a 3 × X × Y dimension cube. Unfortunately, we will have to permute the dimensions slightly.","category":"page"},{"location":"modules/AstroImages/manual/converting-from-rgb/","page":"Converting from RGB","title":"Converting from RGB","text":"using Images\nmw_png = load(\"mw-crop2-small.png\")\nmw_chan_view = channelview(mw_png)\nmw_rgb_cube = AstroImage(\n    permutedims(mw_chan_view, (3, 2, 1))[:,end:-1:begin,:],\n    # Optional:\n    (X=:, Y=:, Spec=[:R,:G,:B])\n)","category":"page"},{"location":"modules/AstroImages/manual/converting-from-rgb/","page":"Converting from RGB","title":"Converting from RGB","text":"Here we chose to mark the third axis as a spectral axis with keys :R, :G, and :B.","category":"page"},{"location":"modules/AstroImages/manual/converting-from-rgb/","page":"Converting from RGB","title":"Converting from RGB","text":"We can now visualize each channel:","category":"page"},{"location":"modules/AstroImages/manual/converting-from-rgb/","page":"Converting from RGB","title":"Converting from RGB","text":"mw_rgb_cube[Spec=At(:R)] # Or just: mw_rgb_cube[:,:,1]","category":"page"},{"location":"modules/AstroImages/manual/converting-from-rgb/","page":"Converting from RGB","title":"Converting from RGB","text":"imview(\n    mw_rgb_cube[Spec=At(:R)],\n    cmap=nothing # Grayscale mode\n)","category":"page"},{"location":"modules/AstroImages/manual/converting-from-rgb/","page":"Converting from RGB","title":"Converting from RGB","text":"using Plots\nimplot(mw_rgb_cube[Spec=At(:B)])","category":"page"},{"location":"modules/AstroImages/manual/headers/#Headers","page":"Headers","title":"Headers","text":"","category":"section"},{"location":"modules/AstroImages/manual/headers/","page":"Headers","title":"Headers","text":"FITS files consist of one or more HDUs (header data units), and each HDU can contain an N-dimensional image or table. Before the data is a header. Headers contain (key, value, comment) groups as well as dedicated long-form COMMENT and HISTORY sections used to document, for example, the series of post-processing steps applied to an image.","category":"page"},{"location":"modules/AstroImages/manual/headers/#Accessing-Headers","page":"Headers","title":"Accessing Headers","text":"","category":"section"},{"location":"modules/AstroImages/manual/headers/","page":"Headers","title":"Headers","text":"Here are some examples of how to set and read keys, comments, and history.","category":"page"},{"location":"modules/AstroImages/manual/headers/","page":"Headers","title":"Headers","text":"Well start by making a blank image.","category":"page"},{"location":"modules/AstroImages/manual/headers/","page":"Headers","title":"Headers","text":"img = AstroImage(zeros(10,10))\n# Set keys to values with different data types\nimg[\"KEY1\"] = 2   # Integer\nimg[\"KEY2\"] = 2.0 # Float\nimg[\"KEY3\"] = \"STRING\"\nimg[\"KEY4\"] = true\nimg[\"KEY5\"] = false\nimg[\"KEY6\"] = nothing\n\n# Set comments\nimg[\"KEY1\", Comment] = \"A key with an integer value\"\n\n# Read keys\na = img[\"KEY3\"]\n\n# Read comment\ncom = img[\"KEY1\", Comment]\n\n# Add long-form COMMENT\npush!(img, Comment, \"\"\"\nWe now describe how to add a long form comment to the end of a header.\n\"\"\")\n\n# Add HISTORY entry\npush!(img, History, \"\"\"\nWe now describe how to add a long form history to the end of a header.\n\"\"\")\n\n# Retrieve long form comments/ history\ncomment_strings = img[Comment]\nhistory_strings = img[History]","category":"page"},{"location":"modules/AstroImages/manual/headers/","page":"Headers","title":"Headers","text":"Note that floating point values are formatted as ASCII strings when written to the FITS files, so the precision may be limited. ","category":"page"},{"location":"modules/AstroImages/manual/headers/","page":"Headers","title":"Headers","text":"AstroImage objects wrap a FITSIO.jl FITSHeader. If necessary, you can recover it using header(img); however, in most cases you can access header keywords directly from the image.","category":"page"},{"location":"modules/AstroImages/manual/headers/","page":"Headers","title":"Headers","text":"API docs: Comment History header","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/#Converting-to-RGB","page":"Converting to RGB","title":"Converting to RGB","text":"","category":"section"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"If you have two or more images of the same scene taken at different wavelengths, you may wish to combine them to create a colour composite.","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"For ultimate control, you can do this manually using imview. Simply map your channels to RGB values using imview and then sum the results.","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"For convenience, AstroImages.jl provides the function composecolors.","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/#Using-composecolors","page":"Converting to RGB","title":"Using composecolors","text":"","category":"section"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"We'll demonstrate composecolors using Hubble images of the Antenae colliding galaxies.","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"One can be very scientific about this process, but often the goal of producing color composites is aesthetic or about highlighting certain features for public consumption. ","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"I'll set the default color map to grayscale to avoid confusion.","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"using AstroImages\n\nAstroImages.set_cmap!(nothing)","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"Let's start by downloading the separate color channel FITS files:","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"antred = AstroImage(download(\"http://www.astro.uvic.ca/~wthompson/astroimages/fits/antenae/red.fits\"))","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"antgreen = AstroImage(download(\"http://www.astro.uvic.ca/~wthompson/astroimages/fits/antenae/green.fits\"))","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"antblue = AstroImage(download(\"http://www.astro.uvic.ca/~wthompson/astroimages/fits/antenae/blue.fits\"))","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"anthalph = AstroImage(download(\"http://www.astro.uvic.ca/~wthompson/astroimages/fits/antenae/hydrogen.fits\")); # Hydrogen-Alpha; we'll revisit later","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"The images will have to be aligned and cropped to the same size before making a color composite.","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"In order to compose these images, we'll have to match the relative intensity scales and clip outlying values. Thankfully, composecolors handles most of these details automatically.","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"rgb1 = composecolors([antred, antgreen, antblue])","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"It's a start!","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"By default, if you provide three images these are mapped to the color channels red, green, and blue. The intensities are limited to Percent(99.5).","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"We can now tweak these defaults to our tastes. We could try clamping the intensities more agressively to bring out more of the galaxy structure:","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"rgb2 = composecolors(\n    [antred, antgreen, antblue],\n    clims=Percent(97)\n)","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"This looks okay but saturates the galaxy cores.","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"Let's take care of that gash through the image by just blanking it out.","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"mask = antgreen .== antgreen[end,begin]\n# remove holes in the mask\nusing ImageFiltering, Statistics\nmask = BitMatrix(mapwindow(median, mask, (3,3)))\nimview(mask)","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"antred[mask] .= NaN\nantgreen[mask] .= NaN\nantblue[mask] .= NaN\nanthalph[mask] .= NaN;","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"Typically we need to perform a \"gamma correction\" aka non-lienar stretch to map the wide dynamic range of astronomical images into a narrower human visible range. We can do this using the stretch keyword. An asinhstretch is typically recommended when preparing RGB images:","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"rgb3 = composecolors(\n    [antred, antgreen, antblue],\n    stretch=asinhstretch\n)","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"Keywords like strech, clims, etc can be either a single value for all channels or a list of separate values/functions per channel.","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"The green channel appears to be quite faint compared to the red and blue channels. We can modify that by adjusting the relative intensities of the channels. ","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"We could also do this using a combination of the contrast and bias keywords.","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"rgb4 = composecolors(\n    [antred, antgreen, antblue],\n    stretch=asinhstretch,\n    multiplier=[1,1.7,1]\n)","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"That's better! Let's go one step further, and incorporate a fourth chanel: Hydrogen Alpha. Hydrogen Alpha is a narrow filter centered around one of the emission lines of Hydrogen atoms. It traces locations with hot gas; mostly star-formation regions in this case.","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"imview(anthalph, cmap=:magma, clims=Zscale())","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"We'll now need to specify the color channels we want to use for each wavelength since we can't use just the default three RGB. We can use any named color or julia ColorScheme.","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"rgb5 = composecolors(\n    [antred, antgreen, antblue, anthalph],\n    [\"red\", \"green\", \"blue\", \"maroon1\"],\n    stretch=asinhstretch,\n    multiplier=[1,1.7,1,0.8]\n)","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"Additionally, I'd like to just show the brightest areas of Hydrogen alpha emission rather than adding a diffuse pink glow. We can turn off the stretch for this one channel:","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"rgb6 = composecolors(\n    [antred, antgreen, antblue, anthalph],\n    [\"red\", \"green\", \"blue\", \"maroon1\"],\n    stretch=[\n        asinhstretch,\n        asinhstretch,\n        asinhstretch,\n        identity,\n    ],\n    multiplier=[1,1.7,1,0.8]\n)","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"Finally, we can crop the image and save it as a PNG.","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"crop = rgb6[200:end-100,50:end-50]","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"save(\"antenae-composite.png\", crop)","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"If you want to save it in a format like JPG that doesn't support transparent pixels, you could replace the masked area with zeros instead of NaN.","category":"page"},{"location":"modules/AstroImages/manual/converting-to-rgb/","page":"Converting to RGB","title":"Converting to RGB","text":"# restore package defaults\nusing AstroImages\nAstroImages.set_clims!(Percent(99.5))\nAstroImages.set_cmap!(:magma)\nAstroImages.set_stretch!(identity)","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"<img src=\"https://github.com/sefffal/PairPlots.jl/raw/master/docs/src/assets/logo.png\" width=100> ","category":"page"},{"location":"modules/PairPlots/#PairPlots.jl","page":"PairPlots","title":"PairPlots.jl","text":"","category":"section"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"Beautiful and flexible vizualizations of high dimensional data","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"(Image: ) (Image: Build status) (Image: Package Downloads) (Image: codecov) (Image: License) (Image: PkgEval)","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"This package produces pair plots, otherwise known as corner plots or scatter plot matrices: grids of 1D and 2D histograms that allow you to visualize high dimensional data.","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"Pair plots are an excellent way to vizualize the results of MCMC simulations, but are also a useful way to vizualize correlations in general data tables.","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"Read the documentation here: (https://sefffal.github.io/PairPlots.jl/dev/)","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"The default styles of this package roughly reproduce the output of the Python library corner.py for a single series, and chainconsumer.py for multiple series. If these are not to your tastes, this package is highly configurable.","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"The current version of PairPlots.jl requires the Makie plotting library. If instead you prefer to use Plots.jl, you can install the legacy version 0.6 of PairPlots (see archived documentation here)","category":"page"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"For related functionality, see also: StatsPlots.cornerplot and CornerPlot.jl for the Gadfly plotting library.","category":"page"},{"location":"modules/PairPlots/#Credits","page":"PairPlots","title":"Credits","text":"","category":"section"},{"location":"modules/PairPlots/","page":"PairPlots","title":"PairPlots","text":"This package is built on top of the great packages Makie, Contour, KernelDensity, and Tables. The overall inspiration and a few lines of code are taken  from corner.py and chainconsumer.py","category":"page"},{"location":"modules/AstroImages/guide/image-transformations/#Image-Transformations","page":"Transforming Images","title":"Image Transformations","text":"","category":"section"},{"location":"modules/AstroImages/guide/image-transformations/","page":"Transforming Images","title":"Transforming Images","text":"The ImageTransformations.jl package contains many useful functions for manipulating astronomical images.","category":"page"},{"location":"modules/AstroImages/guide/image-transformations/","page":"Transforming Images","title":"Transforming Images","text":"Note however that many of these functions drop the AstroImage wrapper and return plain arrays or OffsetArrays. They can be re-wrapped using copyheader or shareheader if you'd like to preserve the FITS header, dimension labels, WCS information, etc.","category":"page"},{"location":"modules/AstroImages/guide/image-transformations/","page":"Transforming Images","title":"Transforming Images","text":"You can install ImageTransformations by running ] add ImageTransformations at the REPL.","category":"page"},{"location":"modules/AstroImages/guide/image-transformations/","page":"Transforming Images","title":"Transforming Images","text":"using AstroImages\nAstroImages.set_clims!(Percent(99.5))\nAstroImages.set_cmap!(:magma)\nAstroImages.set_stretch!(identity)","category":"page"},{"location":"modules/AstroImages/guide/image-transformations/","page":"Transforming Images","title":"Transforming Images","text":"For these examples, we'll download an image of the Antenae galaxies from Hubble:","category":"page"},{"location":"modules/AstroImages/guide/image-transformations/","page":"Transforming Images","title":"Transforming Images","text":"using AstroImages\nusing ImageTransformations\n\nfname = download(\n    \"http://www.astro.uvic.ca/~wthompson/astroimages/fits/antenae/blue.fits\",\n    \"ant-blue.fits\"\n)\n\nantblue = load(\"ant-blue.fits\")\n\n# We'll change the defaults to avoid setting them each time\nAstroImages.set_clims!(Percent(99))\nAstroImages.set_cmap!(:ice)\nAstroImages.set_stretch!(asinhstretch)\n\nimview(antblue)","category":"page"},{"location":"modules/AstroImages/guide/image-transformations/#Rotations","page":"Transforming Images","title":"Rotations","text":"","category":"section"},{"location":"modules/AstroImages/guide/image-transformations/","page":"Transforming Images","title":"Transforming Images","text":"We can rotate images using the imrotate function.","category":"page"},{"location":"modules/AstroImages/guide/image-transformations/","page":"Transforming Images","title":"Transforming Images","text":"imrotate(antblue, 3π/4) |> imview","category":"page"},{"location":"modules/AstroImages/guide/image-transformations/","page":"Transforming Images","title":"Transforming Images","text":"The rotation angle is in radians, but you can use the function rad2deg to convert from degrees.","category":"page"},{"location":"modules/AstroImages/guide/image-transformations/#Resizing","page":"Transforming Images","title":"Resizing","text":"","category":"section"},{"location":"modules/AstroImages/guide/image-transformations/","page":"Transforming Images","title":"Transforming Images","text":"We can resize images using the imresize function:","category":"page"},{"location":"modules/AstroImages/guide/image-transformations/","page":"Transforming Images","title":"Transforming Images","text":"imresize(antblue, ratio=0.2) |> imview","category":"page"},{"location":"modules/AstroImages/guide/image-transformations/#Arbitrary-Transformations","page":"Transforming Images","title":"Arbitrary Transformations","text":"","category":"section"},{"location":"modules/AstroImages/guide/image-transformations/","page":"Transforming Images","title":"Transforming Images","text":"Arbitrary transformations can be performed using ImageTransformation's warp function. See the documentation linked above for more details.","category":"page"},{"location":"modules/AstroImages/guide/image-transformations/#Mapping-from-One-Coordinate-System-to-Another","page":"Transforming Images","title":"Mapping from One Coordinate System to Another","text":"","category":"section"},{"location":"modules/AstroImages/guide/image-transformations/","page":"Transforming Images","title":"Transforming Images","text":"For transforming an image from one coordiante system (say, RA & DEC) to another (e.g., galactic lattitude & logitude), see Reprojecting Images.","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"<img height=150 src=\"https://github.com/sefffal/PlanetOrbits.jl/blob/master/docs/src/assets/logo.png\"/>","category":"page"},{"location":"modules/PlanetOrbits/#PlanetOrbits.jl","page":"PlanetOrbits","title":"PlanetOrbits.jl","text":"","category":"section"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"(Image: ) (Image: codecov)","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"Tools for solving simple Keplerian orbits.  The primary use case is mapping orbital elements into e.g. Cartesian coordinates at different times. A Plots.jl recipe is included for easily plotting orbits. One can for instance calculate an orbit around a star in 3D, a projected position in the sky, a radial velocity curve, or stellar astrometric accleration over time.","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"It's a great tool for visualizing different orbits (see examples) and generating nice animations (e.g. with Plots or Luxor.jl). This package has been designed for good performance and composability with a wide range of packages in the Julia ecosystem, including ForwardDiff.  It forms the backbone of Octofitter.jl, a modelling framework for all kinds of exoplanet data.","category":"page"},{"location":"modules/PlanetOrbits/","page":"PlanetOrbits","title":"PlanetOrbits","text":"See documentation at https://sefffal.github.io/PlanetOrbits.jl/dev","category":"page"},{"location":"modules/AstroImages/manual/array/#Array-Operations","page":"Array Operations","title":"Array Operations","text":"","category":"section"},{"location":"modules/AstroImages/manual/array/","page":"Array Operations","title":"Array Operations","text":"You can operate on an AstroImage like any other Julia array.","category":"page"},{"location":"modules/AstroImages/manual/array/","page":"Array Operations","title":"Array Operations","text":"using AstroImages\n\nimg = AstroImage(randn(10,10))","category":"page"},{"location":"modules/AstroImages/manual/array/#Indexing","page":"Array Operations","title":"Indexing","text":"","category":"section"},{"location":"modules/AstroImages/manual/array/","page":"Array Operations","title":"Array Operations","text":"You can look up individual pixels (see Conventions)","category":"page"},{"location":"modules/AstroImages/manual/array/","page":"Array Operations","title":"Array Operations","text":"img[1,1] # Bottom left","category":"page"},{"location":"modules/AstroImages/manual/array/","page":"Array Operations","title":"Array Operations","text":"img[1:5,1:5]","category":"page"},{"location":"modules/AstroImages/manual/array/#Broadcasting","page":"Array Operations","title":"Broadcasting","text":"","category":"section"},{"location":"modules/AstroImages/manual/array/","page":"Array Operations","title":"Array Operations","text":"AstroImages participate in broadcasting as expected:","category":"page"},{"location":"modules/AstroImages/manual/array/","page":"Array Operations","title":"Array Operations","text":"@. img + img^2 + 2img^3","category":"page"},{"location":"modules/AstroImages/manual/array/","page":"Array Operations","title":"Array Operations","text":"You can update them in-place (if the underlying array you passed supports mutation)","category":"page"},{"location":"modules/AstroImages/manual/array/","page":"Array Operations","title":"Array Operations","text":"img[1:5,:] .= 0\nimg","category":"page"},{"location":"modules/AstroImages/manual/conventions/#Conventions","page":"Conventions","title":"Conventions","text":"","category":"section"},{"location":"modules/AstroImages/manual/conventions/","page":"Conventions","title":"Conventions","text":"In the Julia Astro ecosystem, images follow the following conventions.","category":"page"},{"location":"modules/AstroImages/manual/conventions/#Axes","page":"Conventions","title":"Axes","text":"","category":"section"},{"location":"modules/AstroImages/manual/conventions/","page":"Conventions","title":"Conventions","text":"For simple 2D images, the first axis is the horizontal axis and the second axis is the vertical axis. So images are indexed by img[xi, yi].","category":"page"},{"location":"modules/AstroImages/manual/conventions/","page":"Conventions","title":"Conventions","text":"The origin is at the bottom left of the image, so img[1,1] refers to the bottom left corner as does img[begin,begin]. img[end,end] is the top right corner, img[begin,end] is the top left, etc.","category":"page"},{"location":"modules/AstroImages/manual/conventions/","page":"Conventions","title":"Conventions","text":"Note that this is transposed and flipped from how how Julia prints arrays at the REPL, ","category":"page"},{"location":"modules/AstroImages/manual/conventions/#Pixels","page":"Conventions","title":"Pixels","text":"","category":"section"},{"location":"modules/AstroImages/manual/conventions/","page":"Conventions","title":"Conventions","text":"This library considers the exact location of img[1,1] to be the center of the pixel in the bottom left corner. This means that plot limits should have the 1 tick slightly away from the left/bottom spines of the image. The default plot limits for implot are -0.5 to end+0.5 along both axes. ","category":"page"},{"location":"modules/AstroImages/manual/conventions/","page":"Conventions","title":"Conventions","text":"There is a known bug with the Plots.jl GR backend that leads ticks to be slightly offset. PyPlot and Plotly backends show the correct tick locations.","category":"page"},{"location":"modules/OIFITS/#Support-for-OI-FITS-data-in-Julia","page":"OIFITS","title":"Support for OI-FITS data in Julia","text":"","category":"section"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"[![License][license-img]][license-url] [![Build Status][github-ci-img]][github-ci-url] [![Build Status][appveyor-img]][appveyor-url] [![Coverage][codecov-img]][codecov-url]","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"The OIFITS.jl package provides support for OI-FITS data in Julia language.","category":"page"},{"location":"modules/OIFITS/#OI-FITS-types","page":"OIFITS","title":"OI-FITS types","text":"","category":"section"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"OI-FITS is a standard to store optical interferometry data as a collection of data-blocks. In the second revision of the standard (see Ref. 1 and Ref. 2), an OI-FITS file may contain the following data-blocks:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"an OI_TARGET data-block stores a list of observed targets;\neach OI_ARRAY data-block describes a given array of telescope stations;\neach OI_WAVELENGTH data-block describes a given instrument notably the effective wavelengths and bandwidths of its spectral channels;\nOI_CORR data-blocks store correlation data;\nOI_VIS data-blocks store complex visibility data;\nOI_VIS2 data-blocks store squared visibility (powerspectrum) data;\nOI_T3 data-blocks store triple product (bispectrum) data;\nOI_FLUX data-blocks store spectral flux data;\nOI_INSPOL data-blocks store instrumental polarization data.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"These data-blocks are stored as binary tables in a FITS data file. The support for FITS files is provided by the FITSIO.jl package.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"The Julia type of an OI-FITS data-block is named as the corresponding OI-FITS extension. In addition to these types for individual OI-FITS data-blocks, the OIFITS.jl package provides data-sets (of type OIDataSet) that contain several OI-FITS data-blocks. Each data-set is an efficient representation of the contents of a compliant OI-FITS file.","category":"page"},{"location":"modules/OIFITS/#Reading-and-writing-OI-FITS-files","page":"OIFITS","title":"Reading and writing OI-FITS files","text":"","category":"section"},{"location":"modules/OIFITS/#Reading-and-writing-OI-FITS-data-sets","page":"OIFITS","title":"Reading and writing OI-FITS data-sets","text":"","category":"section"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Reading an OI-FITS data file in Julia yields a data-set and is done by:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"using OIFITS\nds = read(OIDataSet, input)","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"where input it the name of the OI-FITS file or an instance of FITSIO.FITS which represents an open FITS file. The above read call is equivalent to the shortcut:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"ds = OIDataSet(input)","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"It is possible to merge the contents of several OI-FITS file, say inp1, inp2, etc., by one of:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"ds = read(OIDataSet, inp1, inp2, ...)\nds = OIDataSet(inp1, inp2, ...)","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"or to merge them into an existing data-set ds:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"read!(ds, inp1, inp2, ...)","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Creating an OI-FITS file is as simple as writing the data-set ds:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"write(filename, ds)","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Overwriting is forbidden by default, but the keyword overwrite=true may be specified to allow for silently overwriting an existing file.","category":"page"},{"location":"modules/OIFITS/#Reading-individual-OI-FITS-data-blocks","page":"OIFITS","title":"Reading individual OI-FITS data-blocks","text":"","category":"section"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"It may be useful to read individual OI-FITS data-blocks, to debug or to fix the contents of a non-compliant OI-FITS file. To that end, you must open the FITS file and can then read a given HDU as an OI-FITS data-block:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"using FITSIO, OIFITS\nf = FITS(filename, \"r\")     # open FITS file for reading\ntgt = OI_TARGET(f[i])       # read OI_TARGET extension in i-th HDU\ntgt = read(OI_TARGET, f[i]) # idem\ndb = OI_VIS2(f[j])          # read OI_VIS2 extension in j-th HDU\ndb = read(OI_VIS2, f[j])    # idem\n...","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"any OI-FITS data-block type can be used in that way.  If the type of the i-th extension is not known, OIDataBlock can be used instead but the result is not type-stable:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"db = OIDataBlock(f[i])       # read OI-FITS extension extension in i-th HDU\ndb = read(OIDataBlock, f[i]) # idem","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Writing individual OI-FITS data-blocks is also possible:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"using FITSIO, OIFITS\nf = FITS(filename, \"w\") # open FITS file for writing\nwrite(f, db)            # write db in the next HDU of f","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"To fix a non-compliant OI-FITS file (usually duplicate target or instrument names), you can read all the data-blocks, fix those which are wrong and push them in order in an OIDataSet to have a consistent data-set which you can then directly use or write in an OI-FITS file for later. Thanks to the automatic rewriting of target identifiers and of the fact that targets (and other dependencies) are identified by their name and consistently merged, it is possible to push an OI_TARGET with multiply defined identical targets (apart maybe their identifiers).","category":"page"},{"location":"modules/OIFITS/#Accessing-the-contents-of-data-blocks-and-data-sets","page":"OIFITS","title":"Accessing the contents of data-blocks and data-sets","text":"","category":"section"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"The contents of OI-FITS data-blocks and data-sets may be accessed by the dot notation but also by indexation.","category":"page"},{"location":"modules/OIFITS/#Contents-of-data-sets","page":"OIFITS","title":"Contents of data-sets","text":"","category":"section"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"The dot notation can be used on a data-set object, say ds, storing a consistent set of OI-FITS data-blocks.  The following properties are available:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"ds.target is the OI_TARGET data-block of the OI-FITS structure.\nds.instr is a list of OI_WAVELENGTH data-blocks indexed by a regular integer index or by the instrument name:\nds.instr[i]       # yields the i-th OI_WAVELENGTH data-block\nds.instr[insname] # yields the OI_WAVELENGTH data-block whose name matches insname\nMatching of names follows FITS conventions that case of letters and trailing spaces are ignored. An exception is thrown if the index (integer or name) is not valid. The get method can be used to provide a default value, for example:\nget(ds.instr, insname, nothing)\nwould yield nothing if insname is not found in ds.instr instead of throwing an exception.\nds.array is a list of OI_ARRAY data-blocks indexed like ds.instr except that interferometric array names are assumed.\nds.correl is a list of OI_CORR data-blocks indexed like ds.instr except that correlation data array names are assumed.\nds.vis is a vector of OI_VIS data-blocks.\nds.vis2 is a vector of OI_VIS2 data-blocks.\nds.t3 is a vector of OI_T3 data-blocks.\nds.flux is a vector of OI_FLUX data-blocks.\nds.inspol is a vector of OI_INSPOL data-blocks.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Other fields of data-sets shall be considered as private and not accessed directly.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Using the dot notation, it is easy to access the different data-blocks containing measurements. For instance:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"for db in ds.vis2\n    ...\nend","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"is convenient to loop across all OI_VIS2 instances stored by ds.","category":"page"},{"location":"modules/OIFITS/#Contents-of-data-blocks","page":"OIFITS","title":"Contents of data-blocks","text":"","category":"section"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"The contents of a data-block, say db, may also be accessed by the dot notation.  As a general rule, db.key or db.col yield the value of the keyword key or the contents of the column col of the OI-FITS table corresponding to the data-block db.  In order to follow Julia conventions and to accommodate for a number of restrictions, key or col are the FITS keyword or column name converted to lower case letters and with non-alphanumeric letters replaced by underscores.  For instance db.date_obs yields the value of the keyword DATE-OBS, that is the UTC start date of observations.  The revision number corresponding to the keyword OI_REVN is however accessed as db.revn, this is the only exception.  Other properties are also accessible via this syntax:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"db.extname yields the OI-FITS name of the extension corresponding to the data-block db (for all data-block types);\ndb.array yields the OI_ARRAY data-block associated with data-block db (only for OI_VIS, OI_VIS2, OI_T3, OI_FLUX, and OI_INSPOL data-block).  Beware that the association with an OI_ARRAY is optional, so db.array may be actually undefined; this can be checked by isdefined(db,:array).\ndb.instr yields the OI_WAVELENGTH data-block associated with data-block db (only for OI_VIS, OI_VIS2, OI_T3, and OI_FLUX data-block).\ndb.correl yields the OI_CORR data-block associated with data-block db (only for OI_VIS, OI_VIS2, OI_T3, and OI_FLUX data-block).\ndb.name is an alias for db.arrname for OI_ARRAY instances, for db.insname for OI_WAVELENGTH instances, and for db.corrname for OI_CORR instances.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Of course, getting a given property must make sense.  For example, db.sta_name is only possible for an OI_ARRAY data-block but not for an OI_WAVELENGTH data-block.  The dot notation can be however be chained and:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"db.instr.eff_wave","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"can be used to access the effective wavelengths of the measurements in db via the instrument associated to db.  Shortcuts are provided:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"λ  = db.eff_wave # get effective wavelength\nΔλ = db.eff_band # get effective bandwidth","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"for OI_WAVELENGTH data-blocks but also for OI_VIS, OI_VIS2, OI_T3, and OI_FLUX data-blocks.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Some fields of a data-block db may however be undefined because:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"the field is not yet defined (the data-block is being constructed);\nthe field is optional in the revision db.revn of the data-block;\nthe field (for example db.instr for an OI_VIS data-block) involves links with other data-blocks (the dependencies) and these links are only defined when a data-block is part of a data-set (see Building of data-sets below).","category":"page"},{"location":"modules/OIFITS/#OI_TARGET-data-blocks","page":"OIFITS","title":"OI_TARGET data-blocks","text":"","category":"section"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"For efficiency, instances of OI_TARGET data-blocks do not follow the same rules as other types of OI-FITS data-blocks whose properties are the columns of the corresponding OI-FITS table: in an OI_TARGET instance, all parameters describing a target are repesented by an OITargetEntry structure and all targets are stored as a vector of OITargetEntry.  An OI_TARGET instance, say db, has the 3 following properties:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"db.extname # yields \"OI_TARGET\"\ndb.list    # yields a vector of OITargetEntry instances\ndb.revn    # yields the revision number","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"The list of targets db.list can be indexed by an integer (as any Julia vector) or by the target name (case of letters and trailing spaces are irrelevant).","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"As an OI_TARGET data-blocks is essentially a vector of target entries, it can be used as an iterable and it can indexed by an integer index or by a target name:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"length(db) # the number of targets, shortcut for `length(db.list)`\ndb[i]      # the i-th target, shortcut for `db.list[i]`\ndb[key]    # the target whose name matches string `key`, shortcut for `db.list[key]`","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Standard methods get and haskey, applied to db.list or directly to db, work as expected and according to the type (integer or string) of the key.  For the keys method, the default is to return an iterator over the target names, but the type of the expected keys can be specified:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"get(db,key,def)   # yields `db[key]` or `def` if `key` not found\nkeys(db)          # iterator over target names\nkeys(String, db)  # idem\nkeys(Integer, db) # iterator over target indices\nkeys(Int, db)     # idem","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"The method OIFITS.get_column is a helper to recover a single target field as a vector:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"OIFITS.get_column([T,] db, col)","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"yields the column col of an OI-FITS data-block db.  Column is identified by col which is either sym or Val(sym) where sym is the symbolic name of the corresponding field in OITargetEntry.  Optional argument T is to specify the element type of the returned array.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"To build an OI_TARGET instance, you may provide the list of targets and the revision number:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"OI_TARGET(lst=OITargetEntry[]; revn=0)","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"yields an OI_TARGET data-block.  Optional argument lst is a vector of OITargetEntry specifying the targets (none by default).  Keyword revn specifies the revision number.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"A target entry may be constructed by specifying all its fields (there are many) by keywords, all of which but category are mandatory:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"x = OITargetEntry(;\n        target_id ::Integer,\n        target    ::AbstractString,\n        raep0     ::AbstractFloat,\n        decep0    ::AbstractFloat,\n        equinox   ::AbstractFloat,\n        ra_err    ::AbstractFloat,\n        dec_err   ::AbstractFloat,\n        sysvel    ::AbstractFloat,\n        veltyp    ::AbstractString,\n        veldef    ::AbstractString,\n        pmra      ::AbstractFloat,\n        pmdec     ::AbstractFloat,\n        pmra_err  ::AbstractFloat,\n        pmdec_err ::AbstractFloat,\n        parallax  ::AbstractFloat,\n        para_err  ::AbstractFloat,\n        spectyp   ::AbstractString,\n        category  ::AbstractString = \"\")","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"It is also possible to specify another target entry, say ref, which is used as a template: any unspecified keyword is assume to have the same value as in ref:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"x = OITargetEntry(ref;\n        target_id = ref.target_id,\n        target    = ref.target,\n        ...)","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Note that, when an OI_TARGET instance is pushed in a data-set, target identifiers (field target_id) are automatically rewritten to be identical to the index in the list of targets of the data-set.","category":"page"},{"location":"modules/OIFITS/#Building-of-data-sets","page":"OIFITS","title":"Building of data-sets","text":"","category":"section"},{"location":"modules/OIFITS/#Pushing-data-blocks-to-data-sets","page":"OIFITS","title":"Pushing data-blocks to data-sets","text":"","category":"section"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Reading an OI-FITS file is the easiest way to define a data-set but a new OI-FITS data-set may be built by creating an empty data-set with OIDataSet(), and then pushing OI-FITS data-blocks in order with push!(...). Indeed, in order to ensure the consistency of a data-set, it is required to push the dependencies (OI_TARGET, OI_ARRAY, OI_WAVELENGTH, and OI_CORR data-blocks) before the data-blocks containing measurements (OI_VIS, OI_VIS2, OI_T3, OI_FLUX, and OI_INSPOL) that may refer to them.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"For example, building a new data-set, say ds, looks like:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"ds = OIDataSet() # create empty data-set\npush!(ds, arr)   # push OI_ARRAY data-block(s)\npush!(ds, ins)   # push OI_WAVELENGTH data-block(s)\npush!(ds, cor)   # push OI_CORR data-block(s)\npush!(ds, tgt)   # push OI_TARGET data-block\npush!(ds, db1)   # push data\npush!(ds, db2)   # push more data\npush!(ds, db3)   # push even more data\n...","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"with the dependencies:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"arr an OI_ARRAY instance defining the interferometric array (zero or any  number of such instances may be pushed),\nins an OI_WAVELENGTH instance defining the instrument (several such  instances can be pushed),\ncor an OI_COORREL instance defining the correlations (zero or any number  of such instances can be pushed),\ntgt an OI_TARGET instance defining the list of observed targets (at least one such instance is required, if more such instances are pushed in the same data-set, they are merged in a single one);","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"and where db1, db2, db3, etc., are instances of OI_VIS, OI_VIS2, OI_T3, OI_FLUX, or OI_INSPOL that provide measurements.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"You may push all data-blocks in a single push! call:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"ds = push!(OIDataSet(), arr, ins, cor, tgt, d1, db2, ...)","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"and the following shortcut is implemented:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"ds = OIDataSet(arr, ins, cor, tgt, d1, db2, ...)","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"These two are equivalent to the multi-line example above, but remember that pushing data-blocks in order (i.e., dependencies before they may be referenced) is required to have a consistent data-set. Apart from this constraint, dependencies may be pushed in any order before the data-blocks with measurements and data-blocks with measurements can be pushed in any order after dependencies.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"As a benefit of the constraint of pushing data-blocks in order, data-blocks with dependencies are automatically linked to these dependencies when pushed on the data-set (which implies that the dependencies already exist in the data-set). This allows for syntactic sugar like:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"ds.vis2[i].eff_wave # the wavelengths of the i-th OI_VIS2 data-block in ds\nds.t3[i].array      # the interferometric array for the i-th OI_T3 data-block in ds\nds.vis[i].instr     # the instrument used for the i-th OI_VIS data-block in ds","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Without linked dependencies, the first above example would require to (1) find in the data-set ds the OI_WAVELENGTH instance, say instr, whose name is matching ds.vi2[i].insname and (2) extract the field eff_wave of instr. The latter step is as simple as instr.eff_wave but the former one has some overheads and scales as O(n) with n the number of OI_WAVELENGTH instances in the data-set.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Since an OI-FITS data-set has a single list of targets (an OI_TARGET instance accessible via ds.target), a mean to merge list of targets had to be defined. The adopted rule is pretty simple:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"The target_id field of any data-block that is part of a data-set corresponds to the index of the target entry in the list of targets stored by the data-set.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"As a consequence, whenever a data-block is pushed into a data-set, the target identifiers of the data-block have to be rewritten according to this rule. Of course, this does not apply for data-blocks with no target_id field such as OI_ARRAY, OI_WAVELENGTH, and OI_CORR.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"To summarize, here is what happens under the hood when a data-block db is pushed into a data-set ds:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"When an OI_ARRAY, OI_WAVELENGTH, or OI_CORR instance db is pushed in a data-set ds, it is appended to the corresponding list (ds.array, ds.instr, or ds.correl) unless this list already has an entry with a name matching db.name. In this latter case, nothing is done unless that an assertion exception is thrown if the two data-blocks whose names are matching do not have the same contents (to prevent building inconsistent data-sets).\nWhen an OI_TARGET instance is pushed in a data-set, the new targets (according to their names) are appended to the list of targets in the data-set and their identifiers set to their index in this list. This also re-initializes an internal dictionary used to perform the conversion from all the target identifiers of the OI_TARGET instance that has been pushed to the target identifiers in the data-set. Until it is reinitialized (by pushing another OI_TARGET instance), this mapping is used to rewrite the target identifiers of subsequent data-blocks pushed in the data-set.\nWhen an OI_VIS, OI_VIS2, OI_T3, OI_FLUX, or OI_INSPOL instance db is pushed in a data-set ds, it is appended to the corresponding list (ds.vis, ds.vis2, db.t3, db.flux, or ds.inspol), after it has been linked to its dependencies (OI_ARRAY, OI_WAVELENGTH, etc., which must already exist in the data-set), and its target identifiers have been rewritten according to the mapping defined by the last OI_TARGET instance previously pushed to the data-set. Rewriting of the target identifiers may be avoided by using the keyword rewrite_target_id=false, this assumes that the target identifiers in the pushed data-block are already set according to the index in the list of targets ds.target.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Pushing a data-block in a data-set does check the consistency of the data-block. This is to allow for building the data-blocks step by step so that they not need to be consistent at all times (just when pushed into a data-set).","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Pushing a data-block in a data-set lefts the data-block unchanged. A swallow copy of it is added to the data-blocks stored by the data-set. Most members of the pushed data-blocks are shared by the one stored by the data-set with the notable exception of the target identifiers which are rewritten and the links to the dependencies which are updated.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"While it sounds complicated, the default rule of rewriting the target identifiers just amounts to assuming that the target identifiers of OI_VIS, OI_VIS2, OI_T3, OI_FLUX, or OI_INSPOL instances pushed in a data-set refer to the last OI_TARGET instance previously pushed on the same data-set.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Pushing several groups of data-blocks, each group making a consistent data-set, in the same data-set is easy. Typically:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"# First push dependencies for group 1.\npush!(ds, group1_arr) # push OI_ARRAY\npush!(ds, group1_ins) # push OI_INS\npush!(ds, group1_cor) # push OI_CORR\npush!(ds, group1_tgt) # push OI_TARGET (reinitializing target_id mapping)\n# Then push data for group 1 (using current target_id mapping).\npush!(ds, group1_db1)\npush!(ds, group1_db2)\n...\n# First push dependencies for group 2.\npush!(ds, group2_arr) # push OI_ARRAY\npush!(ds, group2_ins) # push OI_INS\npush!(ds, group2_cor) # push OI_CORR\npush!(ds, group2_tgt) # push OI_TARGET (reinitializing target_id mapping)\n# Then push data for group 2 (using current target_id mapping).\npush!(ds, group2_db1)\npush!(ds, group2_db2)\n...","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Since they are referenced by their names, it is not necessary to push OI_ARRAY, OI_WAVELENGTH, and OI_COORREL dependencies if they already exist in the data-set (according to their name), but it doesn't hurt. It is however mandatory to push an OI_TARGET instance with all targets and their identifiers as assumed by the subsequent data-blocks.","category":"page"},{"location":"modules/OIFITS/#Merging-data-sets","page":"OIFITS","title":"Merging data-sets","text":"","category":"section"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Two OI-FITS data-sets (or more), say A and B, can be consistently merged together by:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"C = merge(A, B)","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"As much as possible, the resulting data-set C will share its contents with A and/or B but without affecting A and B which are guaranteed to remain unchanged. As for pushing data-blocks, the target identifiers (the target_id field) may be rewritten in the result.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Merging of data-sets assumes that the two merged data-sets are consistent and compatible. Here compatible means that targets and dependencies with matching names must have the same contents. This is checked during the merge operation.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"It is also allowed to merge several data-sets and/or merge data-sets in-place:","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"ds = merge(ds1, ds2, ds3, ...) # merge ds1, ds2, ... in new data-set ds\nmerge!(ds, ds1, ds2, ds3, ...) # merge ds1, ds2, ... in existing data-set ds","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Note that merge!(ds,...) yields the destination ds.","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Also note that, after merging, the internal dictionary used for rewriting target identifiers is left with the mapping built from the targets of the last merged data-set.","category":"page"},{"location":"modules/OIFITS/#Credits","page":"OIFITS","title":"Credits","text":"","category":"section"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"The development of this package has received funding from the European Community's Seventh Framework Programme (FP7/2013-2016) under Grant Agreement 312430 (OPTICON) and is currently supported by the Jean-Marie Mariotti Center (JMMC).","category":"page"},{"location":"modules/OIFITS/#References","page":"OIFITS","title":"References","text":"","category":"section"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"Pauls, T. A., Young, J. S., Cotton, W. D., & Monnier, J. D. \"A data exchange standard for optical (visible/IR) interferometry.\" Publications of the Astronomical Society of the Pacific, vol. 117, no 837, p. 1255 (2005). [pdf]\nDuvert, G., Young, J., & Hummel, C. \"OIFITS 2: the 2nd version of the Data Exchange Standard for Optical (Visible/IR) Interferometry.\" arXiv preprint [arXiv:1510.04556v2.04556].","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"[doc-stable-img]: https://img.shields.io/badge/docs-stable-blue.svg [doc-stable-url]: https://emmt.github.io/OIFITS.jl/stable","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"[doc-dev-img]: https://img.shields.io/badge/docs-dev-blue.svg [doc-dev-url]: https://emmt.github.io/OIFITS.jl/dev","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"[license-url]: ./LICENSE.md [license-img]: http://img.shields.io/badge/license-MIT-brightgreen.svg?style=flat","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"[github-ci-img]: https://github.com/emmt/OIFITS.jl/actions/workflows/CI.yml/badge.svg?branch=master [github-ci-url]: https://github.com/emmt/OIFITS.jl/actions/workflows/CI.yml?query=branch%3Amaster","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"[appveyor-img]: https://ci.appveyor.com/api/projects/status/github/emmt/OIFITS.jl?branch=master [appveyor-url]: https://ci.appveyor.com/project/emmt/OIFITS-jl/branch/master","category":"page"},{"location":"modules/OIFITS/","page":"OIFITS","title":"OIFITS","text":"[codecov-img]: http://codecov.io/github/emmt/OIFITS.jl/coverage.svg?branch=master [codecov-url]: http://codecov.io/github/emmt/OIFITS.jl?branch=master","category":"page"},{"location":"modules/UnitfulAstro/#UnitfulAstro.jl-Documentation","page":"Home","title":"UnitfulAstro.jl Documentation","text":"","category":"section"},{"location":"modules/UnitfulAstro/","page":"Home","title":"Home","text":"UnitfulAstro.jl is an extension of Unitful.jl to include units commonly encountered in astronomy.","category":"page"},{"location":"modules/UnitfulAstro/#Table-of-Units","page":"Home","title":"Table of Units","text":"","category":"section"},{"location":"modules/UnitfulAstro/","page":"Home","title":"Home","text":"The list of additional units is given below:","category":"page"},{"location":"modules/UnitfulAstro/","page":"Home","title":"Home","text":"Name Binding Value\nErg UnitfulAstro.erg 1//10000000 J\nDyne UnitfulAstro.dyn 1//100000 N\nArcminute UnitfulAstro.arcminute 0.016666666666666666 °\nArcsecond UnitfulAstro.arcsecond 0.0002777777777777778 °\nJulian year UnitfulAstro.yr 365.25 dy\nAstronomical unit UnitfulAstro.AU 1.495978707e13 cm\nLight year UnitfulAstro.ly 9.4607304725808e17 cm\nParsec UnitfulAstro.pc 3.0856775814913674e18 cm\nJansky UnitfulAstro.Jy 1.0e-23 erg Hz^-1 cm^-2 s^-1\nSolar radius UnitfulAstro.Rsun 6.957e10 cm\nSolar irradiance UnitfulAstro.Ssun 1.361e6 erg cm^-2 s^-1\nSolar luminosity UnitfulAstro.Lsun 3.828e33 erg s^-1\nG × Solar mass UnitfulAstro.GMsun 1.3271244e20 m^3 s^-2\nSolar mass UnitfulAstro.Msun 1.9884754153381438e33 g\nEarth radius (equatorial) UnitfulAstro.Rearth_e 6.3781e8 cm\nEarth radius (polar) UnitfulAstro.Rearth_p 6.3568e8 cm\nEarth radius UnitfulAstro.Rearth 6.3781e8 cm\nG × Earth mass UnitfulAstro.GMearth 3.986004e14 m^3 s^-2\nEarth mass UnitfulAstro.Mearth 5.972364730419773e27 g\nJupiter radius (equatorial) UnitfulAstro.Rjup_e 7.1492e9 cm\nJupiter radius (polar) UnitfulAstro.Rjup_p 6.6854e9 cm\nJupiter radius UnitfulAstro.Rjup 7.1492e9 cm\nG × Jupiter mass UnitfulAstro.GMjup 1.2668653e17 m^3 s^-2\nJupiter mass UnitfulAstro.Mjup 1.8981871658715508e30 g\nFifty-one ergs UnitfulAstro.foe 1.0e51 erg\nSolar flux unit UnitfulAstro.SFU 10//1 kJy\nTotal electron content unit UnitfulAstro.TECU 1.0e12 cm^-2","category":"page"},{"location":"modules/UnitfulAstro/#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"modules/UnitfulAstro/","page":"Home","title":"Home","text":"julia> using Unitful, UnitfulAstro\n\njulia> uconvert(u\"erg\", 1 * Unitful.kg * Unitful.gn * Unitful.m)\n9.80665e7 erg\n\njulia> uconvert(u\"Jy\", 1.23e-20 * u\"erg/s/cm^2/Hz\")\n1230.0000000000002 Jy\n\njulia> uconvert(u\"ly\", 1 * u\"pc\")\n3.2615637771674333 ly","category":"page"},{"location":"modules/UnitfulAstro/#Magnitudes","page":"Home","title":"Magnitudes","text":"","category":"section"},{"location":"modules/UnitfulAstro/","page":"Home","title":"Home","text":"Name Binding Zero Point\nabsolute bolometric Magnitude UnitfulAstro.bol_Mag 3.0128e28 W\napparent bolometric magnitude UnitfulAstro.bol_mag 2.518021002e-8 W m^-2\nAB magnitude UnitfulAstro.AB_mag 3631 Jy\nJohnson U magnitude UnitfulAstro.U_mag 1810 Jy\nJohnson U magnitude UnitfulAstro.B_mag 4260 Jy\nJohnson V magnitude UnitfulAstro.V_mag 3640 Jy\nJohnson R magnitude UnitfulAstro.R_mag 3080 Jy\nJohnson I magnitude UnitfulAstro.I_mag 2550 Jy\nJohnson J magnitude UnitfulAstro.J_mag 1600 Jy\nJohnson H magnitude UnitfulAstro.H_mag 1080 Jy\nJohnson K magnitude UnitfulAstro.K_mag 670 Jy\nGunn g magnitude UnitfulAstro.g_mag 3730 Jy\nGunn r magnitude UnitfulAstro.r_mag 4490 Jy\nGunn i magnitude UnitfulAstro.i_mag 4760 Jy\nGunn z magnitude UnitfulAstro.z_mag 4810 Jy","category":"page"},{"location":"modules/UnitfulAstro/","page":"Home","title":"Home","text":"warn: Warn\nSupport for magnitudes is experimental. Please use care and report any issues you experience on the UnitfulAstro.jl GitHub issue tracker.","category":"page"},{"location":"modules/UnitfulAstro/","page":"Home","title":"Home","text":"Currently only AB, bolometric, Johnson, and Gunn magnitudes are supported.","category":"page"},{"location":"modules/UnitfulAstro/","page":"Home","title":"Home","text":"For example","category":"page"},{"location":"modules/UnitfulAstro/","page":"Home","title":"Home","text":"julia> using Unitful, UnitfulAstro\n    \njulia> u = UnitfulAstro;\n\njulia> 5*u.AB_mag + 5*u.AB_mag\n4.247425010840047 AB mag\n\njulia> 5*u.U_mag/100\n10.0 Johnson U mag\n\njulia> 5*u.g_mag + 10*u.Jy # magnitudes can be mixed with ordinary linear units\n47.300000000000004 Jy\n\njulia> uconvert(u.AB_mag, 1*u.μJy) # converting one μJy to AB magnitudes\n23.90006562228223 AB mag\n\njulia> uconvert(u.bol_mag, 1*u.Ssun) # apparent bolometric magnitude of the Sun\n-26.83199694276591 bol mag\n\njulia> uconvert(u.bol_Mag, 1*u.Lsun) # absolute bolometric magnitude of the Sun\n4.7399959339194595 bol Mag","category":"page"},{"location":"modules/UnitfulAstro/#Color","page":"Home","title":"Color","text":"","category":"section"},{"location":"modules/UnitfulAstro/","page":"Home","title":"Home","text":"Color index is also supported","category":"page"},{"location":"modules/UnitfulAstro/","page":"Home","title":"Home","text":"julia> using UnitfulAstro\n\njulia> u = UnitfulAstro;\n\njulia> 1u.B_mag - 0.5u.V_mag\n0.4999999999999999","category":"page"},{"location":"modules/UnitfulAstro/","page":"Home","title":"Home","text":"Note: that the only operation that can happen between different bands is subtraction","category":"page"},{"location":"modules/UnitfulAstro/","page":"Home","title":"Home","text":"julia> using UnitfulAstro\n\njulia> u = UnitfulAstro;\n\njulia> 1u.B_mag + 0.5u.V_mag\nERROR: MagnitudeError: an invalid operation was attempted with magnitudes: 0.9999999999999999 Johnson B mag, 0.5 Johnson V mag","category":"page"},{"location":"modules/UnitfulAstro/","page":"Home","title":"Home","text":"and that + and - work on individual bands","category":"page"},{"location":"modules/UnitfulAstro/","page":"Home","title":"Home","text":"julia> using UnitfulAstro\n\njulia> u = UnitfulAstro;\n\njulia> 1u.B_mag - 1.5u.B_mag\n2.0823085833406205 Johnson B mag\n\njulia> 1u.B_mag + 1.5u.B_mag\n0.46889349301415084 Johnson B mag","category":"page"},{"location":"modules/UnitfulAstro/#IAU-Resolutions","page":"Home","title":"IAU Resolutions","text":"","category":"section"},{"location":"modules/UnitfulAstro/","page":"Home","title":"Home","text":"Copies of recent IAU resolutions which formalize the definitions of some units used in this package are linked below.","category":"page"},{"location":"modules/UnitfulAstro/","page":"Home","title":"Home","text":"IAU 2012 (pdf)\nIAU 2015 (pdf)","category":"page"},{"location":"modules/SAOImageDS9/starting/#Starting","page":"Starting","title":"Starting","text":"","category":"section"},{"location":"modules/SAOImageDS9/starting/","page":"Starting","title":"Starting","text":"To use SAOImageDS9 package, type:","category":"page"},{"location":"modules/SAOImageDS9/starting/","page":"Starting","title":"Starting","text":"using SAOImageDS9","category":"page"},{"location":"modules/SAOImageDS9/starting/","page":"Starting","title":"Starting","text":"will import the symbol DS9 which can be used to prefix all methods available in SAOImageDS9 instead of the full package name which can be a bit tedious in interactive sessions.  If you prefer another prefix, say sao, you can do:","category":"page"},{"location":"modules/SAOImageDS9/starting/","page":"Starting","title":"Starting","text":"import SAOImageDS9\nconst sao = SAOImageDS9","category":"page"},{"location":"modules/SAOImageDS9/starting/","page":"Starting","title":"Starting","text":"or (provided your Julia version is at least 1.6):","category":"page"},{"location":"modules/SAOImageDS9/starting/","page":"Starting","title":"Starting","text":"import SAOImageDS9 as sao","category":"page"},{"location":"modules/SAOImageDS9/starting/","page":"Starting","title":"Starting","text":"You may also just import SAOImageDS9 and keep the SAOImageDS9 prefix. Throughout all the remaining documentation, no shortcut is assumed.","category":"page"},{"location":"modules/SAOImageDS9/starting/","page":"Starting","title":"Starting","text":"You may call the SAOImageDS9.connect method to specify the access point to a given running SAOImage/DS9 application.  If no given access point is specified, SAOImageDS9 will automatically attempts to connect to the first access point matching \"DS9.*\" when a command is sent to SAOImage/DS9.  The method SAOImageDS9.accesspoint() yields the name of the current access point to SAOImage/DS9, or an empty string if none has been chosen.","category":"page"},{"location":"modules/SAOImageDS9/starting/","page":"Starting","title":"Starting","text":"To check the connection to SAOImage/DS9, you can type:","category":"page"},{"location":"modules/SAOImageDS9/starting/","page":"Starting","title":"Starting","text":"SAOImageDS9.get(VersionNumber)","category":"page"},{"location":"modules/SAOImageDS9/starting/","page":"Starting","title":"Starting","text":"which should yield the version of the SAOImage/DS9 to which you are connected.","category":"page"},{"location":"tutorials/jwst-image-scale-bar/#tutorial-jwst-scalebar","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"","category":"section"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"This tutorial shows how to download one of the new famous JWST release images of the Carina nebula, plot it with world coordinates (RA and DEC), and add a scalebar. Let's get started!","category":"page"},{"location":"tutorials/jwst-image-scale-bar/#Packages","page":"JWST image with scale bar","title":"Packages","text":"","category":"section"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"Downloads: we'll use this built-in Julia standard library to download the raw image data\nAstroImages: we'll use this package to load and display the image\nPlots: we'll use this package to display coordinates along the image and add the scalebar","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"You can install the necessary packages by running Julia, and typing ] to enter Pkg-mode. Then: add AstroImages Plots. Alternatively, you can run using Pkg; Pkg.add([\"AstroImages\", \"Plots\"]).","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"If you will be using these tools as part of a bigger project, it's strongly recommended to create a Julia Project to record package versions.  If you're just experimenting, you can create a temporary project by running ] activate --temp.","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"If you're using Pluto notebooks, installing and recording package versions in a project are handled for you automatically.","category":"page"},{"location":"tutorials/jwst-image-scale-bar/#Downloading-the-data","page":"JWST image with scale bar","title":"Downloading the data","text":"","category":"section"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"All JWST data is available from the MAST archive. ","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"A mirror of the JWST initial release data is also hosted on AWS. We'll use this to directly download a specific famous image by URL.","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"warning: Large Download\nThe size of this image is over 3GB! Ensure you have enough space on your hard drive before running the following code.","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"using Downloads\n\nfname = Downloads.download(\n   \"https://stpubdata-jwst.stsci.edu/ero/jw02731/L3/t/\"*\n   \"jw02731-o001_t017_nircam_clear-f187n_i2d.fits\"\n)","category":"page"},{"location":"tutorials/jwst-image-scale-bar/#Loading-the-image","page":"JWST image with scale bar","title":"Loading the image","text":"","category":"section"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"We can use AstroImages.jl to load the image.","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"using AstroImages\n\ncarina_full = load(fname); # semi-colon prevents displaying the image","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"[ Info: Image was loaded from HDU 2","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"Let's check the resolution of the image:","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"size(carina)","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"(14436, 8568)","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"Wow, that's over 120 megapixels! ","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"AstroImages will fall back to downscaling it automatically before displaying it using ImageTransformations.restrict, but let's make our lives simpler and just use every 10th pixel:","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"carina = carina_full[begin:10:end, begin:10:end]","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"(Image: Carina nebula displayed as an image)","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"Since we didn't put a semi-colon, the image was displayed. This works automatically if you use the VS Code editor, Jupyter notebooks, or Pluto Notebooks. If you're using a terminal, you can use ElectronDisplay.jl or ImageView.jl to open an interactive window.","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"imview is the function that was called automatically  to display the image, but we can call it ourselves if we want to customize the display. We can make the image pop a little more by adjusting the display limits, or clims. These can be either a tuple of min and max values (i.e. (0.0, 100.0)) or a function to calculate them for us based on some criteria. We'll adjust the limits to remove the top and bottom 1% of all  pixels:","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"imview(carina; clims=Percent(98))","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"(Image: Carina nebula displayed as an image with higher contrast)","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"In Julia, keyword arguments come after positional arguments and they can be separated by a semi-colon.","category":"page"},{"location":"tutorials/jwst-image-scale-bar/#Adding-World-Coordinates","page":"JWST image with scale bar","title":"Adding World Coordinates","text":"","category":"section"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"The image header already contains WCS keys to specify the location of the image in the sky. Let's take a peek at one of these header keys:","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"println(carina[\"CTYPE1\", Comment])\nprintln(carina[\"CTYPE1\"])","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"first axis coordinate type\nRA---TAN","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"This shows that the coordinate type for the first axis is \"RA–-TAN\".","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"Now, we'll combine AstroImages with the Plots.jl library to display these coordinates.","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"using Plots\n\nimplot(carina; clims=Percent(98))","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"(Image: Carina nebula displayed in a plot)","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"The image is tilted compared to the right-ascension and declination celestial coordinate system, so the grid is rotated.","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"The colourbar on the right displays the units of the image: Mega-Janskys per steradian: units of energy per collecting area, per spectral bandwidth, per solid-angle on the sky.","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"Let's turn off the grid for now:","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"implot(carina; grid=false, clims=Percent(98))","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"(Image: Carina nebula displayed in a plot without grid lines)","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"Full documentation for the implot function is available in the AstroImages.jl docs.","category":"page"},{"location":"tutorials/jwst-image-scale-bar/#Adding-a-Scalebar","page":"JWST image with scale bar","title":"Adding a Scalebar","text":"","category":"section"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"Another way we can communicate the scale of this image is by adding a scalebar. Since we are working in spherical coordinates, the cartesian Pythagorean theorem won't quite cut it. There are approximations we can use for small angles, but let's go ahead and compute the scale bar length in a fully general way.","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"For two points of right-ascension alpha and declination delta, a=(alpha_a delta_a) and b=(alpha_b delta_b), the angular separation is","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"cos (gamma) = cos (90 - delta_a) cos (90 - delta_b) + sin (90 - delta_a) sin (90 - delta_b) cos (alpha_a - alpha_b)","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"We can calculate the length of our scalebar in pixels by picking a coordinate a, picking an angular separation gamma, and then solving for b:","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"using LinearAlgebra\n\n# Start the scalebar here in pixel coordinates\na_px = [1000, 100]\n\n# Convert to world coordinates\na_deg = pix_to_world(carina_full, a_px)\n\n# Extend by 10 arcminutes of declination\nb_deg  = a_deg .+ [0, 1/60]\n\n# Convert back to pixel coordinates\nb_px = world_to_pix(carina_full, b_deg)\n\n# Measure the angular distance in pixel coordinates\n# note: in theory this depends on where in the image we make this calculation\n# because the coordinate system is warped\narcmin_px = norm(stop_coord_pix .- start_coord_pix)\n\n# Plot our image again\nimplot(carina; grid=false, clims=Percent(98))\n\n# Overplot the scalebar\nplot!(\n    # X\n    [11000, 11000+arcmin_px],\n    # Y\n    [1000,  1000];\n    # Formatting:\n    color=:white,\n    linewidth=5,\n    label=\"\"\n)\n\n# add annotation\nannx = 11000+arcmin_px/2\nanny = 1000+100\nannotate!(\n    (annx, anny, text(\" 1' \", 10, :white, :center, :bottom))\n)","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"(Image: Carina nebula displayed with a scale bar)","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"Looking good! If we only want to communiate the scale and not the location, we can hide the tick marks and colorbar for a cleaner look:","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"\n# Hide decorations\nimplot(\n    carina[10:end-10, 10:end-10]; # crop slightly\n    grid=false,\n    ticks=false,\n    colorbar=false,\n    clims=Percent(98),\n    xlabel=\"\",\n    ylabel=\"\",\n    framestyle=:none,\n    background_outside=:transparent,\n)\n\n# Overplot the scalebar\nplot!(\n    # X\n    [11000, 11000+arcmin_px],\n    # Y\n    [1000,  1000];\n    # Formatting:\n    color=:white,\n    linewidth=5,\n    label=\"\",\n)\n\n# add annotation\nannx = 11000+arcmin_px/2\nanny = 1000+100\nannotate!(\n    (annx, anny, text(\" 1' \", 10, :white, :center, :bottom)) \n)","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"(Image: Carina nebula displayed with a scale bar and no other plot decorations)","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"To save the image, just run savefig(\"output.png\"). pdf, svg, and other file formats are also supported.","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"To learn more about displaying images and world coordinates, see the AstroImages.jl documentation.","category":"page"},{"location":"tutorials/jwst-image-scale-bar/","page":"JWST image with scale bar","title":"JWST image with scale bar","text":"For more on plotting in general, see the Plots.jl documentation.","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/#Dimensions-and-World-Coordinates","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"","category":"section"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"AstroImages are based on Dimensional Data. Each axis is assigned a dimension name and the indices are tracked.","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"using AstroImages\nAstroImages.set_clims!(Percent(99.5))\nAstroImages.set_cmap!(:magma)\nAstroImages.set_stretch!(identity)","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/#World-Coordinates","page":"Dimensions and World Coordinates","title":"World Coordinates","text":"","category":"section"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"FITS files with world coordinate system (WCS) headers contain all the information necessary to map a pixel location into celestial coordinates & back.","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"Let's see how this works with a 2D image with RA & DEC coordinates.","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"using AstroImages\nusing Plots\n\n# Download a Hubble image of the Eagle nebula\ndownload(\n    \"http://www.astro.uvic.ca/~wthompson/astroimages/fits/656nmos.fits\",\n    \"eagle-656nmos.fits\"\n);\neagle = load(\"eagle-656nmos.fits\")","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"This image contains world coordinate system headers. AstroImages.jl uses WCS.jl (and wcslib under the hood) to parse these headers. We can generate a WCSTransform object to inspect:","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"wcs(eagle, 1) # specify which coordinate system","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"Note that we specify with an index which coordinate system we'd like to use. Most images just contain one, but some contain multiple systems.","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"We can lookup a coordinate from the image:","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"world = pix_to_world(eagle, [1, 1]) # Bottom left corner","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"Or convert back from world coordinates to pixel coordinates: We can lookup a coordinate from the image:","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"world_to_pix(eagle, world) # Bottom left corner","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"These pixel coordinates do not necessarily have to lie within the bounds of the original image, and in general lie at a fractional pixel position.","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"If an image contains WCS headers, we can visualize them using implot:","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"implot(eagle)","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"We can adjust the color of the grid:","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"implot(eagle, gridcolor=:cyan)","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"If these aren't desired, we can turn off the grid or the WCS tick marks:","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"plot(\n  implot(eagle, grid=false),\n  implot(eagle, wcsticks=false),\n  size=(900,300),\n  bottommargin=10Plots.mm\n)","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"Since AstroImages are based on DimensionalData's AbstractDimArray, the mapping between pixel coordinates and world coordinates are preserved when slicing an AstroImage:","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"slice1 = eagle[1:800,1:800]\nslice2 = eagle[800:1600,1:800]\nplot(\n  implot(slice1),\n  implot(slice2),\n  size=(900,300),\n  bottommargin=10Plots.mm\n)","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"World coordinate queries from that slice are aware of their position in the parent image:","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"@show pix_to_world(slice1, [1,1])\n@show pix_to_world(slice2, [1,1])","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"Note  that you can query the dimensions of an image using the dims function from DimensionalData:","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"dims(slice2)","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/#Named-Dimensions","page":"Dimensions and World Coordinates","title":"Named Dimensions","text":"","category":"section"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"Each dimension of an AstroImage is named. The automatic dimension names are X, Y, Z, Dim{4}, Dim{5}, and so on; however you can pass in other names or orders to the load function and/or AstroImage contructor:","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"julia> img = load(\"eagle-656nmos.fits\",1,(Y,Z))\n1600×1600 AstroImage{Float32,2} with dimensions:\n  Y Sampled 1:1600 ForwardOrdered Regular Points,\n  Z Sampled 1:1600 ForwardOrdered Regular Points","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"Other useful dimension names are Spec for spectral axes, Pol for polarization data, and Ti for time axes. These are tracked the same was as the automatic dimension names and interact smoothly with any WCS headers. You can give an arbitrary name using as a Dim{Symbol}, e.g. Dim{:Velocity}.","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"You can access AstroImages using dimension names:","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"eagle[X=100]","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"When indexing into a slice out of a larger parent image or cube, this named access refers to the parent dimensions:","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"slice1 = eagle[600:800,600:800]\nslice1[X=At(700),Y=At(700)] == eagle[X=At(700),Y=At(700)] == eagle[700,700]","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/#Cubes","page":"Dimensions and World Coordinates","title":"Cubes","text":"","category":"section"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"Let's see how this works with a 3D cube.","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"using AstroImages\n\nHIcube = load(download(\"http://www.astro.uvic.ca/~wthompson/astroimages/fits/HIdat.fits\"))","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"Notice how the cube is not displayed automatically. We have to pick a specific slice:","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"HIcube[Z=228]","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"Using implot, the world coordinates are displayed automatically:","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"implot(HIcube[Z=228], cmap=:turbo)","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"The plot automatically reflects the world coordinates embeded in the file. It displays the x axis in galactic longitude, the y-axis in galactic latitude, and even shows the curved projection from pixel coordinates to galactic coordinates. The title is automatically set to the world coordinate along the Z axis in units of velocity. It also picks up the unit of the data (Kelvins) to display on the colorbar.","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"If we pick another slice, the title updates accordingly:","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"implot(HIcube[Z=308], cmap=:turbo)","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"This works for other slices through the cube as well:","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"implot(HIcube[Y=45],  cmap=:turbo, aspectratio=0.3)","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/#Custom-Dimensions","page":"Dimensions and World Coordinates","title":"Custom Dimensions","text":"","category":"section"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"julia> img = load(\"img.fits\",1,(Y=1:1600,Z=1:1600))\n1600×1600 AstroImage{Float32,2} with dimensions:\n  Y Sampled 1:1600 ForwardOrdered Regular Points,\n  Z Sampled 1:1600 ForwardOrdered Regular Points","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"Other useful dimension names are Spec for spectral axes, Pol for polarization data, and Ti for time axes. These are tracked the same was as the automatic dimension names and interact smoothly with any WCS headers.","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"Often times we have images or cubes that we want to index with physical coordinates where setting up a full WCS transform is overkill. In these cases, it's easier to leverage custom dimensions.","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"For example, one may wish to ","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"julia> img = load(\"img.fits\",1,(X=801:2400,Y=1:2:3200))\n1600×1600 AstroImage{Float32,2} with dimensions:\n  X Sampled 801:2400 ForwardOrdered Regular Points,\n  Y Sampled 1:2:3199 ForwardOrdered Regular Points\n...","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"Unlike OffsetArrays, the usual indexing remains so img[1,1] is still the bottom left of the image; however, data can be looked up according to the offset dimensions using specifiers:","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"julia> img[X=Near(2000),Y=1..100]\n50-element AstroImage{Float32,1} with dimensions:\n  Y Sampled 1:2:99 ForwardOrdered Regular Points\nand reference dimensions:\n  X Sampled 2000:2000 ForwardOrdered Regular Points\n  0.0","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"You can adjust the center of an image's dimensions using recenter:","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"eagle_cen = recenter(eagle, 801, 801);","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"Unlike an OffsetArray, eagle_cen[1,1] still refers to the bottom left of the image. This also has no effect on broadcasting, eagle_cen .+ ones(1600,1600) is perfectly valid. However, we see the new centered dimensions when we go to plot the image:","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"implot(eagle_cen, wcsticks=false)","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"And we can query positions using the offset dimensions:","category":"page"},{"location":"modules/AstroImages/manual/dimensions-and-world-coordinates/","page":"Dimensions and World Coordinates","title":"Dimensions and World Coordinates","text":"implot(eagle_cen[X=-300..300, Y=-300..300], wcsticks=false)","category":"page"},{"location":"modules/AstroTime/api/timescales/#Time-Scales","page":"Time Scales","title":"Time Scales","text":"","category":"section"},{"location":"modules/AstroTime/api/timescales/","page":"Time Scales","title":"Time Scales","text":"AstroTime.update","category":"page"},{"location":"modules/AstroTime/api/timescales/#AstroTime.update","page":"Time Scales","title":"AstroTime.update","text":"AstroTime.update()\n\nDownload up-to-date IERS tables from the internet to enable transformations to and from the UT1 time scale.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroTime/api/timescales/","page":"Time Scales","title":"Time Scales","text":"@timescale","category":"page"},{"location":"modules/AstroTime/api/timescales/#AstroTime.@timescale","page":"Time Scales","title":"AstroTime.@timescale","text":"@timescale scale [parent[, oneway]]\n\nDefine a new time scale and the corresponding Epoch type alias.\n\nArguments\n\nscale: The name of the time scale\nparent: The \"parent\" time scale to which it should be linked (optional)\noneway: If true, only the transformation from parent to scale is   registered (optional, default: false)\n\nExample\n\njulia> @timescale GMT TAI\n\njulia> GMT isa TimeScale\ntrue\n\njulia> GMTEpoch\nEpoch{GMTScale, T} where T\n\njulia> find_path(TT, GMT)\n3-element Vector{TimeScale}:\n TT\n TAI\n GMT\n\n\n\n\n\n","category":"macro"},{"location":"modules/AstroTime/api/timescales/","page":"Time Scales","title":"Time Scales","text":"Modules = [AstroTime.TimeScales]\nPrivate = false","category":"page"},{"location":"modules/AstroTime/api/timescales/#AstroTime.TimeScales.TAI","page":"Time Scales","title":"AstroTime.TimeScales.TAI","text":"TAI\n\nThe singleton instance of the InternationalAtomicTime type representing the International Atomic Time (TAI) time scale.\n\nReferences\n\nWikipedia\n\n\n\n\n\n","category":"constant"},{"location":"modules/AstroTime/api/timescales/#AstroTime.TimeScales.TCB","page":"Time Scales","title":"AstroTime.TimeScales.TCB","text":"TCB\n\nThe singleton instance of the BarycentricCoordinateTime type representing the Barycentric Coordinate Time (TCB) time scale.\n\nReferences\n\nWikipedia\n\n\n\n\n\n","category":"constant"},{"location":"modules/AstroTime/api/timescales/#AstroTime.TimeScales.TCG","page":"Time Scales","title":"AstroTime.TimeScales.TCG","text":"TCG\n\nThe singleton instance of the GeocentricCoordinateTime type representing the Geocentric Coordinate Time (TCG) time scale.\n\nReferences\n\nWikipedia\n\n\n\n\n\n","category":"constant"},{"location":"modules/AstroTime/api/timescales/#AstroTime.TimeScales.TDB","page":"Time Scales","title":"AstroTime.TimeScales.TDB","text":"TDB\n\nThe singleton instance of the BarycentricDynamicalTime type representing the Barycentric Dynamical Time (TDB) time scale.\n\nReferences\n\nWikipedia\n\n\n\n\n\n","category":"constant"},{"location":"modules/AstroTime/api/timescales/#AstroTime.TimeScales.TT","page":"Time Scales","title":"AstroTime.TimeScales.TT","text":"TT\n\nThe singleton instance of the TerrestrialTime type representing the Terrestrial Time (TT) time scale.\n\nReferences\n\nWikipedia\n\n\n\n\n\n","category":"constant"},{"location":"modules/AstroTime/api/timescales/#AstroTime.TimeScales.UT1","page":"Time Scales","title":"AstroTime.TimeScales.UT1","text":"UT1\n\nThe singleton instance of the UniversalTime type representing the Universal Time (UT1) time scale.\n\nReferences\n\nWikipedia\n\n\n\n\n\n","category":"constant"},{"location":"modules/AstroTime/api/timescales/#AstroTime.TimeScales.BarycentricCoordinateTime","page":"Time Scales","title":"AstroTime.TimeScales.BarycentricCoordinateTime","text":"BarycentricCoordinateTime\n\nA type representing the Barycentric Coordinate Time (TCB) time scale.\n\nReferences\n\nWikipedia\n\n\n\n\n\n","category":"type"},{"location":"modules/AstroTime/api/timescales/#AstroTime.TimeScales.BarycentricDynamicalTime","page":"Time Scales","title":"AstroTime.TimeScales.BarycentricDynamicalTime","text":"BarycentricDynamicalTime\n\nA type representing the Barycentric Dynamical Time (TDB) time scale.\n\nReferences\n\nWikipedia\n\n\n\n\n\n","category":"type"},{"location":"modules/AstroTime/api/timescales/#AstroTime.TimeScales.GeocentricCoordinateTime","page":"Time Scales","title":"AstroTime.TimeScales.GeocentricCoordinateTime","text":"GeocentricCoordinateTime\n\nA type representing the Geocentric Coordinate Time (TCG) time scale.\n\nReferences\n\nWikipedia\n\n\n\n\n\n","category":"type"},{"location":"modules/AstroTime/api/timescales/#AstroTime.TimeScales.InternationalAtomicTime","page":"Time Scales","title":"AstroTime.TimeScales.InternationalAtomicTime","text":"InternationalAtomicTime\n\nA type representing the International Atomic Time (TAI) time scale.\n\nReferences\n\nWikipedia\n\n\n\n\n\n","category":"type"},{"location":"modules/AstroTime/api/timescales/#AstroTime.TimeScales.TerrestrialTime","page":"Time Scales","title":"AstroTime.TimeScales.TerrestrialTime","text":"TerrestrialTime\n\nA type representing the Terrestrial Time (TT) time scale.\n\nReferences\n\nWikipedia\n\n\n\n\n\n","category":"type"},{"location":"modules/AstroTime/api/timescales/#AstroTime.TimeScales.TimeScale","page":"Time Scales","title":"AstroTime.TimeScales.TimeScale","text":"All timescales are subtypes of the abstract type TimeScale. The following timescales are defined:\n\nUT1 — Universal Time\nTAI — International Atomic Time\nTT — Terrestrial Time\nTCG — Geocentric Coordinate Time\nTCB — Barycentric Coordinate Time\nTDB — Barycentric Dynamical Time\n\n\n\n\n\n","category":"type"},{"location":"modules/AstroTime/api/timescales/#AstroTime.TimeScales.UniversalTime","page":"Time Scales","title":"AstroTime.TimeScales.UniversalTime","text":"UniversalTime\n\nA type representing the Universal Time (UT1) time scale.\n\nReferences\n\nWikipedia\n\n\n\n\n\n","category":"type"},{"location":"modules/LACosmic/api/#API/Reference","page":"API/Reference","title":"API/Reference","text":"","category":"section"},{"location":"modules/LACosmic/api/","page":"API/Reference","title":"API/Reference","text":"","category":"page"},{"location":"modules/LACosmic/api/","page":"API/Reference","title":"API/Reference","text":"","category":"page"},{"location":"modules/LACosmic/api/","page":"API/Reference","title":"API/Reference","text":"lacosmic","category":"page"},{"location":"modules/LACosmic/api/#LACosmic.lacosmic","page":"API/Reference","title":"LACosmic.lacosmic","text":"lacosmic(data::AbstractMatrix; \n    noise=nothing,\n    gain=1,\n    background=0,\n    readnoise=0,\n    mask=falses(size(data)),\n    sigma_clip=4.5,\n    contrast=5,\n    neighbor_thresh=0.3,\n    maxiter=4,\n    saturation_level=2^16,\n    block_size=2)\n\nLaplacian cosmic ray detection (LACosmic). This algorithm implements the algorithm presented in lacosmicx. The return values are the cleaned image and the bad pixel mask. The image cleaning is done via median interpolation.\n\nParameters\n\nnoise is the pre-determined estimate of the data noise (square root of variance), if any\ngain is the image gain in electrons per data number\nbackground is pre-determined image background, if any\nreadnoise is the read noise of the image in electrons\nmask is an input bad pixel mask, where true represents a bad pixel\nsigma_clip is the Laplacian signal-to-noise ratio for flagging bad pixels\ncontrast is the minimum contrast required to flag a bad pixel in the ratio of the Laplacian image to the fine-structure image\nneighbor_thresh is the fractional detection limit for cosmic rays surrounding other cosmic rays. Should be a number between 0 and 1.\nmaxiter is the maximum number of iterations used for detecting bad pixels\nsaturation_level is the saturation value in electrons\nblock_size is the subsampling factor for the Laplacian filter image.\n\nExamples\n\njulia> image = 100 .* randn(1001, 1001) .+ 1000;\n\njulia> clean_image, mask = lacosmic(image, gain=4);\n\nReferences\n\nvan Dokkum, P.G. (2001) - \"Cosmic-Ray Rejection by Laplacian Edge Detection\"\n\n\n\n\n\n","category":"function"},{"location":"modules/Photometry/background/#Background-Estimation","page":"Getting Started","title":"Background Estimation","text":"","category":"section"},{"location":"modules/Photometry/background/","page":"Getting Started","title":"Getting Started","text":"The module provides tools and algorithms for estimating the background of astronomical data.","category":"page"},{"location":"modules/Photometry/background/#Usage","page":"Getting Started","title":"Usage","text":"","category":"section"},{"location":"modules/Photometry/background/","page":"Getting Started","title":"Getting Started","text":"Estimating backgrounds is an important step in performing photometry. Ideally, we could perfectly describe the background with a scalar value or with some distribution. Unfortunately, it's impossible for us to precisely separate the background and foreground signals. Here, we use mixture of robust statistical estimators and meshing to let us get the spatially varying background from an astronomical photo.","category":"page"},{"location":"modules/Photometry/background/","page":"Getting Started","title":"Getting Started","text":"Let's show an example","category":"page"},{"location":"modules/Photometry/background/","page":"Getting Started","title":"Getting Started","text":"using Photometry\nusing FITSIO\nusing Plots\n\n# Download our image, courtesy of astropy\nhdu = FITS(download(\"https://rawcdn.githack.com/astropy/photutils-datasets/8c97b4fa3a6c9e6ea072faeed2d49a20585658ba/data/M6707HH.fits\"))\nimage = read(hdu[1])\n\n# Plot\nfunction imshow(image; kwargs...)\n    xs, ys = axes(image)\n    data = transpose(image)\n    heatmap(xs, ys, data; aspect_ratio=1, xlim=extrema(xs), ylim=extrema(ys), kwargs...)\nend\n\nimshow(image)","category":"page"},{"location":"modules/Photometry/background/","page":"Getting Started","title":"Getting Started","text":"Now let's try and estimate the background using estimate_background. First, we'll si gma-clip to try and remove the signals from the stars. Then, the background is broken down into boxes, in this case of size (50, 50). Within each box, the given statistical estimators get the background value and RMS. By default, we use SourceExtractorBackground and StdRMS. This creates a low-resolution image, which we then need to resize. We can accomplish this using an interpolator, by default a cubic-spline interpolator via ZoomInterpolator. The end result is a smooth estimate of the spatially varying background and background RMS.","category":"page"},{"location":"modules/Photometry/background/","page":"Getting Started","title":"Getting Started","text":"# sigma-clip\nclipped = sigma_clip(image, 1, fill=NaN)\n\n# get background and background rms with box-size (50, 50)\nbkg, bkg_rms = estimate_background(clipped, 50)\n\n# plot\nplot(\n    imshow(image, title=\"Original\"),\n    imshow(clipped, title=\"Sigma-Clipped\"),\n    imshow(bkg, title=\"Background\"),\n    imshow(bkg_rms, title=\"Background RMS\"),\n    layout=(2, 2), ticks=false\n)","category":"page"},{"location":"modules/Photometry/background/","page":"Getting Started","title":"Getting Started","text":"We could apply a median filter, too, by specifying filter_size","category":"page"},{"location":"modules/Photometry/background/","page":"Getting Started","title":"Getting Started","text":"# get background and background rms with box-size (50, 50) and filter_size (5, 5)\nbkg_f, bkg_rms_f = estimate_background(clipped, 50, filter_size=5)\n\n# plot\nplot(\n    imshow(bkg, title=\"Unfiltered\", ylabel=\"Background\"),\n    imshow(bkg_f, title=\"Filtered\"),\n    imshow(bkg_rms, ylabel=\"RMS\"),\n    imshow(bkg_rms_f);\n    layout=(2, 2), ticks=false\n)","category":"page"},{"location":"modules/Photometry/background/","page":"Getting Started","title":"Getting Started","text":"Now we can see our image after subtracting the filtered background and ready for Aperture Photometry!","category":"page"},{"location":"modules/Photometry/background/","page":"Getting Started","title":"Getting Started","text":"subt = image .- bkg_f[axes(image)...]\nplot(\n    imshow(image, title=\"Original\", colorbar=false),\n    imshow(subt, title=\"Subtracted\");\n    layout=(1, 2), size=(600, 260),\n    xlims=(400, 800), ylims=(400, 800),\n    clims=(minimum(subt), maximum(image)),\n    ticks=false, aspect_ratio=1\n)","category":"page"},{"location":"modules/Photometry/background/#IDW-Interpolator","page":"Getting Started","title":"IDW Interpolator","text":"","category":"section"},{"location":"modules/Photometry/background/","page":"Getting Started","title":"Getting Started","text":"Here is a quick example using the IDWInterpolator","category":"page"},{"location":"modules/Photometry/background/","page":"Getting Started","title":"Getting Started","text":"b1, r1 = estimate_background(clipped, 50, filter_size=5)\nb2, r2 = estimate_background(clipped, 50, itp=IDWInterpolator(50), filter_size=5)\n\nplot(\n    imshow(b1, title=\"ZoomInterpolator\", ylabel=\"Background\"),\n    imshow(b2, title=\"IDWInterpolator\"),\n    imshow(r1, ylabel=\"RMS\"),\n    imshow(r2);\n    layout=(2, 2), ticks=false\n)","category":"page"},{"location":"modules/Photometry/background/#API/Reference","page":"Getting Started","title":"API/Reference","text":"","category":"section"},{"location":"modules/Photometry/background/","page":"Getting Started","title":"Getting Started","text":"estimate_background\nsigma_clip\nsigma_clip!","category":"page"},{"location":"modules/Photometry/background/#Photometry.Background.estimate_background","page":"Getting Started","title":"Photometry.Background.estimate_background","text":"estimate_background(data;\n    location=SourceExtractorBackground(),\n    rms=StdRMS(),\n    dims=:)\n\nPerform scalar background estimation using the given estimators.\n\nThe value returned will be two values corresponding to the estimated background and the estimated background RMS. The dimensionality will depend on the dims keyword.\n\nlocation and rms can be anything that is callable, for example median, or one of the estimators we provide in Background Estimators.\n\nExamples\n\njulia> data = ones(3, 5);\n\njulia> bkg, bkg_rms = estimate_background(data)\n(1.0, 0.0)\n\njulia> using Statistics: median\n\njulia> bkg, bkg_rms = estimate_background(data; location=median, rms=MADStdRMS())\n(1.0, 0.0)\n\nSee Also\n\nLocation Estimators, RMS Estimators\n\n\n\n\n\nestimate_background(data, box_size;\n    location=SourceExtractorBackground(),\n    rms=StdRMS(),\n    itp=ZoomInterpolator(box_size),\n    edge_method=:pad,\n    [filter_size])\n\nPerform 2D background estimation using the given estimators mapped over windows of the data..\n\nThis function will estimate backgrounds in boxes of size box_size. When size(data) is not an integer multiple of the box size, there are two edge methods: :pad and :crop. The default is to pad (and is recommend to avoid losing image data). If box_size is an integer, the implicit shape will be square (eg. box_size=4 is equivalent to box_size=(4,4)).\n\nFor evaluating the meshes, each box will be passed into location to estimate the background and then into rms to estimate the background root-mean-square value. These can be anything that is callable, like median or one of our Background Estimators.\n\nOnce the meshes are created they will be median filtered if filter_size is given. filter_size can be either an integer or a tuple, with the integer being converted to a tuple the same way box_size is. Filtering is done via ImageFiltering.MapWindow.mapwindow. filter_size must be odd.\n\nAfter filtering (if applicable), the meshes are passed to the itp to recreate a low-order estimate of the background at the same resolution as the input.\n\nnote: Note\nIf your box_size is not an integer multiple of the input size, the output background and rms arrays will not have the same size.\n\nSee Also\n\nLocation Estimators, RMS Estimators, Interpolators\n\n\n\n\n\n","category":"function"},{"location":"modules/Photometry/background/#Photometry.Background.sigma_clip","page":"Getting Started","title":"Photometry.Background.sigma_clip","text":"sigma_clip(x, sigma; fill=:clamp, center=median(x), std=std(x, corrected=false))\nsigma_clip(x, sigma_low, sigma_high; fill=:clamp, center=median(x), std=std(x, corrected=false))\n\nThis function returns sigma-clipped values of the input x.\n\nSpecify the upper and lower bounds with sigma_low and sigma_high, otherwise assume they are equal. center and std are optional keyword arguments which are functions for finding central element and standard deviation.\n\nIf fill === :clamp, this will clamp values in x lower than center - sigma_low * std and values higher than center + sigma_high * std. Otherwise, they will be replaced with fill.\n\nExamples\n\njulia> x = randn(100_000);\n\njulia> extrema(x)\n(-4.496308951466683, 4.080724496910187)\n\njulia> x_clip = sigma_clip(x, 1);\n\njulia> extrema(x_clip) # should be close to (-1, 1)\n(-1.0042721545326967, 0.9957463910682249)\n\n\n\n\n\n","category":"function"},{"location":"modules/Photometry/background/#Photometry.Background.sigma_clip!","page":"Getting Started","title":"Photometry.Background.sigma_clip!","text":"sigma_clip!(x, sigma; fill=:clamp, center=median(x), std=std(x))\nsigma_clip!(x, sigma_low, sigma_high; fill=:clamp, center=median(x), std=std(x))\n\nIn-place version of sigma_clip\n\nwarning: Warning\nsigma_clip! mutates the element in place and mutation cannot lead to change in type. Please be considerate of your input type, because if you are using Int64 and we try to clip it to 0.5 an InexactError will be thrown.To avoid this, we recommend converting to float before clipping, or using sigma_clip which does this internally.\n\n\n\n\n\n","category":"function"},{"location":"modules/Photometry/detection/algs/#Source-Detection-Algorithms","page":"Algorithms","title":"Source Detection Algorithms","text":"","category":"section"},{"location":"modules/Photometry/detection/algs/","page":"Algorithms","title":"Algorithms","text":"Detection.SourceFinder","category":"page"},{"location":"modules/Photometry/detection/algs/#Photometry.Detection.SourceFinder","page":"Algorithms","title":"Photometry.Detection.SourceFinder","text":"Detection.SourceFinder\n\nAbstract super type for source detection algorithms used with extract_sources.\n\n\n\n\n\n","category":"type"},{"location":"modules/Photometry/detection/algs/#API/Reference","page":"Algorithms","title":"API/Reference","text":"","category":"section"},{"location":"modules/Photometry/detection/algs/","page":"Algorithms","title":"Algorithms","text":"PeakMesh","category":"page"},{"location":"modules/Photometry/detection/algs/#Photometry.Detection.PeakMesh","page":"Algorithms","title":"Photometry.Detection.PeakMesh","text":"PeakMesh(box_size=(3, 3), nsigma=3.0)\n\nDetect sources by finding peaks above a threshold in grids across the image.\n\nThis creates a pixel-wise threshold for sources by calculating error * nsigma when used with extract_sources The peaks are found by searching the image in boxes of size box_size. If the maximum value in that box is greater than the threshold set above, the point is extracted.\n\n\n\n\n\n","category":"type"},{"location":"modules/AstroLib/#AstroLib.jl","page":"Introduction","title":"AstroLib.jl","text":"","category":"section"},{"location":"modules/AstroLib/","page":"Introduction","title":"Introduction","text":"AstroLib is a package of small generic routines useful above all in astronomical and astrophysical context, written in Julia.","category":"page"},{"location":"modules/AstroLib/","page":"Introduction","title":"Introduction","text":"Included are also translations of some IDL Astronomy User’s Library procedures, which are released under terms of BSD-2-Clause License. AstroLib’s functions are not drop-in replacement of those procedures, Julia standard data types are often used (e.g., DateTime type instead of generic string for dates) and the syntax may slightly differ.","category":"page"},{"location":"modules/AstroLib/","page":"Introduction","title":"Introduction","text":"An extensive error testing suite ensures old fixed bugs will not be brought back by future changes.","category":"page"},{"location":"modules/AstroLib/#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"modules/AstroLib/","page":"Introduction","title":"Introduction","text":"AstroLib is available for Julia 1.0 and later versions, and can be installed with Julia's built-in package manager. In a Julia session run the command","category":"page"},{"location":"modules/AstroLib/","page":"Introduction","title":"Introduction","text":"julia> Pkg.update()\njulia> Pkg.add(\"AstroLib\")","category":"page"},{"location":"modules/AstroLib/","page":"Introduction","title":"Introduction","text":"Older versions are also available for Julia 0.4-0.6.","category":"page"},{"location":"modules/AstroLib/","page":"Introduction","title":"Introduction","text":"Note that, in order to work, a few functions require external files, which are automatically downloaded when building the package. Should these files be missing for some reason, you will be able to load the package but some functions may not work properly. You can manually build the package with","category":"page"},{"location":"modules/AstroLib/","page":"Introduction","title":"Introduction","text":"julia> Pkg.build(\"AstroLib\")","category":"page"},{"location":"modules/AstroLib/#Usage","page":"Introduction","title":"Usage","text":"","category":"section"},{"location":"modules/AstroLib/","page":"Introduction","title":"Introduction","text":"After installing the package, you can start using AstroLib with","category":"page"},{"location":"modules/AstroLib/","page":"Introduction","title":"Introduction","text":"using AstroLib","category":"page"},{"location":"modules/AstroLib/","page":"Introduction","title":"Introduction","text":"Many functions in AstroLib.jl are compatible with Measurements.jl package, which allows you to define quantities with uncertainty and propagate the error when performing calculations according to propagation of uncertainty rules. For example:","category":"page"},{"location":"modules/AstroLib/","page":"Introduction","title":"Introduction","text":"julia> using AstroLib, Measurements\n\njulia> mag2flux(12.54 ± 0.03)\n3.499451670283562e-14 ± 9.669342299577655e-16","category":"page"},{"location":"modules/AstroLib/#How-Can-I-Help?","page":"Introduction","title":"How Can I Help?","text":"","category":"section"},{"location":"modules/AstroLib/","page":"Introduction","title":"Introduction","text":"AstroLib.jl is developed on GitHub. You can contribute to the project in a number of ways: by translating more routines from IDL Astronomy User’s Library, or providing brand-new functions, or even improving existing ones (make them faster and more precise). Also bug reports are encouraged.","category":"page"},{"location":"modules/AstroLib/#License","page":"Introduction","title":"License","text":"","category":"section"},{"location":"modules/AstroLib/","page":"Introduction","title":"Introduction","text":"The AstroLib.jl package is licensed under the MIT “Expat” License. The original author is Mosè Giordano.","category":"page"},{"location":"modules/AstroLib/#Notes","page":"Introduction","title":"Notes","text":"","category":"section"},{"location":"modules/AstroLib/","page":"Introduction","title":"Introduction","text":"This project is a work-in-progress, only few procedures have been translated so far. In addition, function syntax may change from time to time. Check TODO.md out to see how you can help. Volunteers are welcome!","category":"page"},{"location":"modules/AstroLib/#Documentation","page":"Introduction","title":"Documentation","text":"","category":"section"},{"location":"modules/AstroLib/","page":"Introduction","title":"Introduction","text":"Every function provided has detailed documentation that can be accessed at Julia REPL with","category":"page"},{"location":"modules/AstroLib/","page":"Introduction","title":"Introduction","text":"julia> ?FunctionName","category":"page"},{"location":"modules/AstroLib/","page":"Introduction","title":"Introduction","text":"or with","category":"page"},{"location":"modules/AstroLib/","page":"Introduction","title":"Introduction","text":"julia> @doc FunctionName","category":"page"},{"location":"modules/AstroLib/#Related-Projects","page":"Introduction","title":"Related Projects","text":"","category":"section"},{"location":"modules/AstroLib/","page":"Introduction","title":"Introduction","text":"This is not the only effort to bundle astronomical functions written in Julia language. Other packages useful for more specific purposes are available at JuliaAstro. A list of other packages is available here.","category":"page"},{"location":"modules/AstroLib/","page":"Introduction","title":"Introduction","text":"Because of this, some of IDL AstroLib’s utilities are not provided in AstroLib.jl as they are already present in other Julia packages. Here is a list of such utilities:","category":"page"},{"location":"modules/AstroLib/","page":"Introduction","title":"Introduction","text":"aper, see Photometry.jl package\nasinh, already present in Julia with the same name\ncirrange, it is equivalent to mod(x, 360).  To restrict a number to the   range [0, 2pi) use mod2pi(x)\ncosmo_param, see Cosmology.jl package\ngalage, see Cosmology.jl package\nglactc_pm, see SkyCoords.jl package\nglactc, see SkyCoords.jl package\njplephinterp, see JPLEphemeris.jl package\njplephread, see JPLEphemeris.jl package\njplephtest, see JPLEphemeris.jl package\nlumdist, see Cosmology.jl package\nreadcol, use readdlm, part of Julia Base.DataFmt module. This is not a complete replacement for readcol but most of the time it does-the-right-thing even without using any option (it automatically identifies string and numerical columns) and you do not need to manually specify a variable for each column","category":"page"},{"location":"modules/AstroLib/","page":"Introduction","title":"Introduction","text":"In addition, there are similar projects for Python (Python AstroLib) and R (Astronomy Users Library).","category":"page"},{"location":"modules/Difmap/#Overview","page":"Difmap","title":"Overview","text":"","category":"section"},{"location":"modules/Difmap/","page":"Difmap","title":"Difmap","text":"Julia wrapper for the difmap program. Conveniently execute difmap scripts, handle input/output files and logs. Relies on the difmap_jll.jl package to provide the difmap binary.","category":"page"},{"location":"modules/Difmap/#Usage","page":"Difmap","title":"Usage","text":"","category":"section"},{"location":"modules/Difmap/","page":"Difmap","title":"Difmap","text":"See also the Pluto notebook that includes plots.","category":"page"},{"location":"modules/Difmap/","page":"Difmap","title":"Difmap","text":"julia> using Difmap\n\njulia> script = [\n          \"print(1 + 2)\",\n          \"exit\",\n       ];\n\njulia> res = Difmap.execute(script);\n\njulia> res.success\ntrue\n\njulia> Difmap.inout_pairs(res)[begin+1:end-1]  # first and last lines contain current time\n1-element Vector{Pair{String, Vector{String}}}:\n \"print(1 + 2)\" => [\"3\"]","category":"page"},{"location":"modules/Difmap/","page":"Difmap","title":"Difmap","text":"julia> script = [\n           \"observe vis.fits\",\n           \"select I\",\n           \"mapsize 512, 0.2\",\n           \"clean 500\",\n           \"restore\",\n           \"device tmp.ps/PS\",\n           \"mapplot cln\",\n           \"save result\",\n           \"exit\",\n       ];\n\n\njulia> vis_file = joinpath(dirname(dirname(pathof(Difmap))), \"test/data/vis.fits\");\n\njulia> res = Difmap.execute(script,\n           in_files=[vis_file => \"vis.fits\"],\n           out_files=[\"result.fits\", \"result.mod\", \"result.par\", \"result.uvf\", \"tmp.ps\"] .=> nothing,  # target is nothing - ignore these files\n       );\n\njulia> res.success\ntrue\n\njulia> Difmap.inout_pairs(res)[begin+1:end-1]  # first and last lines contain current time\n8-element Vector{Pair{String, Vector{String}}}:\n \"observe vis.fits\" => [\"Reading UV FITS file: vis.fits\", \"AN table 1: 4 integrations on 36 of 36 possible baselines.\", \"Apparent sampling: 1 visibilities/baseline/integration-bin.\", \"Found source: J0000+0248\", \"\", \"There are 8 IFs, and a total of 8 channels:\", \"\", \"IF  Channel    Frequency  Freq offset  Number of   Overall IF\", \"origin    at origin  per channel   channels    bandwidth\", \"------------------------------------------------------------- (Hz)\"  …  \"05        5    4.416e+09      3.2e+07          1      3.2e+07\", \"06        6    4.512e+09      3.2e+07          1      3.2e+07\", \"07        7    4.544e+09      3.2e+07          1      3.2e+07\", \"08        8    4.576e+09      3.2e+07          1      3.2e+07\", \"\", \"Polarization(s): RR\", \"\", \"Read 0 lines of history.\", \"\", \"Reading 1152 visibilities.\"]\n         \"select I\" => [\"Polarization I is unavailable.\", \"Selecting polarization: RR,  channels: 1..8\", \"Reading IF 1 channels: 1..1\", \"Reading IF 2 channels: 2..2\", \"Reading IF 3 channels: 3..3\", \"Reading IF 4 channels: 4..4\", \"Reading IF 5 channels: 5..5\", \"Reading IF 6 channels: 6..6\", \"Reading IF 7 channels: 7..7\", \"Reading IF 8 channels: 8..8\"]\n \"mapsize 512, 0.2\" => [\"Map grid = 512x512 pixels with 0.200x0.200 milli-arcsec cellsize.\"]\n        \"clean 500\" => [\"Inverting map and beam\", \"Estimated beam: bmin=1.195 mas, bmaj=3.79 mas, bpa=-3.012 degrees\", \"Estimated noise=0.541101 mJy/beam.\", \"clean: niter=500  gain=0.05  cutoff=0\", \"Component: 050  -  total flux cleaned = 0.0188812 Jy\", \"Component: 100  -  total flux cleaned = 0.0252178 Jy\", \"Component: 150  -  total flux cleaned = 0.0277823 Jy\", \"Component: 200  -  total flux cleaned = 0.0290343 Jy\", \"Component: 250  -  total flux cleaned = 0.0300524 Jy\", \"Component: 300  -  total flux cleaned = 0.0302839 Jy\", \"Component: 350  -  total flux cleaned = 0.0304884 Jy\", \"Component: 400  -  total flux cleaned = 0.0304353 Jy\", \"Component: 450  -  total flux cleaned = 0.0305383 Jy\", \"Component: 500  -  total flux cleaned = 0.030393 Jy\", \"Total flux subtracted in 500 components = 0.030393 Jy\", \"Clean residual min=-0.000455 max=0.000452 Jy/beam\", \"Clean residual mean=0.000001 rms=0.000189 Jy/beam\", \"Combined flux in latest and established models = 0.030393 Jy\"]\n          \"restore\" => [\"restore: Substituting estimate of restoring beam from last 'invert'.\", \"Restoring with beam: 1.195 x 3.79 at -3.012 degrees (North through East)\", \"Clean map  min=-0.0010866  max=0.019272 Jy/beam\"]\n \"device tmp.ps/PS\" => [\"Attempting to open device: 'tmp.ps/PS'\"]\n      \"mapplot cln\" => []\n      \"save result\" => [\"Writing UV FITS file: result.uvf\", \"Writing 174 model components to file: result.mod\", \"Adding 174 model components to the UV plane model.\", \"The established model now contains 174 components and 0.030393 Jy\", \"Inverting map\", \"restore: Substituting estimate of restoring beam from last 'invert'.\", \"Restoring with beam: 1.195 x 3.79 at -3.012 degrees (North through East)\", \"Clean map  min=-0.0010295  max=0.019271 Jy/beam\", \"Writing clean map to FITS file: result.fits\", \"Writing difmap environment to: result.par\"]","category":"page"},{"location":"highlevels/images/#Images-Overview","page":"Images Overview","title":"Images Overview","text":"","category":"section"},{"location":"modules/AstroImages/manual/getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"modules/AstroImages/manual/getting-started/","page":"Getting Started","title":"Getting Started","text":"To get started, you will first need to install AstroImages. After starting Julia, enter package-mode by typing ] and then","category":"page"},{"location":"modules/AstroImages/manual/getting-started/","page":"Getting Started","title":"Getting Started","text":"pkg> add AstroImages","category":"page"},{"location":"modules/AstroImages/manual/getting-started/","page":"Getting Started","title":"Getting Started","text":"To display images and save them in traditional graphics formats like PNG, JPG, GIF, etc., you will also need to add the ImageIO package. Once installed, this package doesn't need to be loaded explicitly.","category":"page"},{"location":"modules/AstroImages/manual/getting-started/","page":"Getting Started","title":"Getting Started","text":"For some of the more advanced visualizations you may also want Plots:","category":"page"},{"location":"modules/AstroImages/manual/getting-started/","page":"Getting Started","title":"Getting Started","text":"pkg> add Plots","category":"page"},{"location":"modules/AstroImages/manual/getting-started/","page":"Getting Started","title":"Getting Started","text":"To load the package, run:","category":"page"},{"location":"modules/AstroImages/manual/getting-started/","page":"Getting Started","title":"Getting Started","text":"using AstroImages\n# And if desired:\nusing Plots","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/#Displaying-Images","page":"Displaying Images","title":"Displaying Images","text":"","category":"section"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"The imview and implot functions are very similar.  Both allow any abstract array of numbers to be rendered into an image or a Plots.jl image series. implot is largely a superset of imview because it also supports colorbars, tick marks, WCS grid lines, overplotting other data & shapes, and automatic axis and title naming (from the FITS header if available).","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/#imview","page":"Displaying Images","title":"imview","text":"","category":"section"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"Any AbstractArray (including an AstroImage) can be displayed using imview. This function renders an arbitrary array into an array of RGBA values using a number of parameters. If the input is an AstroImage{<:Number}, an AstroImage{RGBA} will be returned that retains headers, WCS information, etc.","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"using AstroImages\nusing Plots\n\nAstroImages.set_clims!(Percent(99.5))\nAstroImages.set_cmap!(:magma)\nAstroImages.set_stretch!(identity)","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"The defaults for the imview function are:","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"img = randn(50,50);\nimview(img; clims=Percent(99.5), cmap=:magma, stretch=identity, contrast=1.0, bias=0.5)","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"We can adjust the color limits explicitly:","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"imview(img; clims=(-1, 1))","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"Or pass a function/callable object to calculate them for us:","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"imview(img; clims=Zscale())","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"We can turn off the colormap and use it in grayscale mode:","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"imview(img; cmap=nothing)","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"Pass any color scheme from ColorSchemes.jl:","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"imview(img; cmap=:ice)","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"imview(img; cmap=:seaborn_rocket_gradient)","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"Or an RGB or named color value:","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"imview(img; cmap=\"#F00\")\nimview(img; cmap=\"red\")","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"Let's now switch to an astronomical image:","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"fname = download(\n    \"http://www.astro.uvic.ca/~wthompson/astroimages/fits/656nmos.fits\",\n    \"eagle-656nmos.fits\"\n);\neagle = AstroImage(\"eagle-656nmos.fits\")","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"We can apply a non-linear stretch like a log-scale, power-scale, or asinh stretch:","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"imview(eagle, stretch=asinhstretch)","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"Once rendered, we can also tweak the bias and contrast:","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"imview(eagle, stretch=asinhstretch, contrast=1.5)","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"imview(eagle, stretch=asinhstretch, contrast=1.5, bias=0.6)","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"These are the parameters that change when you click and drag in some applications like DS9.","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"Once rendered via imview, the resulting image can be saved in traditional image formats like PNG, JPG, GIF, etc:","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"save(\"out.png\", imview(eagle, cmap=:viridis))","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"Very large Images are automatically downscaled to ensure consistent performance using restrict from Images.jl. This function filters the data before downscaling to prevent aliasing, so it may take a moment for truly huge images. In these cases, a faster method that doesn't prevent aliasing would be imview(img[begin:10:end, begin:10:end]) or similar.","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"imview is called automatically on AstroImage{<:Number} when using a Julia environment with rich graphical IO capabilities (e.g. VSCode, Jupyter, Pluto, etc.). The defaults for this case can be modified using AstroImages.set_clims!(...), AstroImages.set_cmap!(...), and AstroImages.set_stretch!(...).","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/#Note-on-Views","page":"Displaying Images","title":"Note on Views","text":"","category":"section"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"The function imview has its name because it produces a \"view\" into the image. The result from calling imview is an object that lazily maps data values into RGBA colors on the fly. This means that if you change the underlying data array, the view will update (the next time it is shown). If you have many data files to render, you may find it faster to create a single imview and then mutate the data in the underlying array. This is faster since imview only has to resolve colormaps and compute limits once.","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"For example:","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"data = randn(100,100)\niv = imview(data)\ndisplay(iv)\ndata[1:50,1:50] .= 0\ndisplay(iv)","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"iv will reflect the changes to data when it is displayed the second time.","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/#implot","page":"Displaying Images","title":"implot","text":"","category":"section"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"implot  is a Plots.jl recipe, which means before you can use it you first have to load Plots.jl:","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"using Plots","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"implot accepts all the arguments imview does for controlling how data is rendered to the screen:","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"implot(img; clims=Percent(99.5), cmap=:magma, stretch=identity, contrast=1.0, bias=0.5)","category":"page"},{"location":"modules/AstroImages/manual/displaying-images/","page":"Displaying Images","title":"Displaying Images","text":"For more on implot, including offset dimensions and world coordinates, see Dimensions and World Coordinates.","category":"page"},{"location":"modules/SAOImageDS9/examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"modules/SAOImageDS9/examples/#Basic-examples","page":"Examples","title":"Basic examples","text":"","category":"section"},{"location":"modules/SAOImageDS9/examples/","page":"Examples","title":"Examples","text":"import SAOImageDS9\nusing SAOImageDS9: TupleOf\nSAOImageDS9.connect()","category":"page"},{"location":"modules/SAOImageDS9/examples/","page":"Examples","title":"Examples","text":"For a 512×861 image img with Float32 pixels, SAOImageDS9.set(img) takes 8.502 ms (28 allocations: 1.30 KiB) while SAOImageDS9.get(Array) takes 5.844 ms (50 allocations: 1.68 MiB).","category":"page"},{"location":"modules/SAOImageDS9/examples/","page":"Examples","title":"Examples","text":"Query parameters of the image displayed in the current DS9 frame:","category":"page"},{"location":"modules/SAOImageDS9/examples/","page":"Examples","title":"Examples","text":"SAOImageDS9.get(Int, \"fits width\")         # get the width of the image\nSAOImageDS9.get(Int, \"fits height\")        # get the height of the image\nSAOImageDS9.get(Int, \"fits depth\")         # get the depth of the image\nSAOImageDS9.get(Int, \"fits bitpix\")        # get the bits per pixel of the image\nSAOImageDS9.get(TupleOf{Int}, \"fits size\") # get the dimensions of the image","category":"page"},{"location":"modules/SAOImageDS9/examples/","page":"Examples","title":"Examples","text":"The dimensions are ordered as width, height and depth.","category":"page"},{"location":"modules/SAOImageDS9/examples/","page":"Examples","title":"Examples","text":"To retrieve or set the dimensions of the display window:","category":"page"},{"location":"modules/SAOImageDS9/examples/","page":"Examples","title":"Examples","text":"SAOImageDS9.get(Int, \"width\")    # get the width of the image display window\nSAOImageDS9.get(Int, \"height\")   # get the height of the image display window\nSAOImageDS9.set(\"width\", n)      # set the width of the image display window\nSAOImageDS9.set(\"height\", n)     # set the height of the image display window","category":"page"},{"location":"modules/SAOImageDS9/examples/","page":"Examples","title":"Examples","text":"Display an image and set the scale limits:","category":"page"},{"location":"modules/SAOImageDS9/examples/","page":"Examples","title":"Examples","text":"SAOImageDS9.set(img)\nSAOImageDS9.set(\"scale limits\", 0, maximum(img))","category":"page"},{"location":"modules/SAOImageDS9/examples/#Frame-settings","page":"Examples","title":"Frame settings","text":"","category":"section"},{"location":"modules/SAOImageDS9/examples/#Set-frame-settings","page":"Examples","title":"Set frame settings","text":"","category":"section"},{"location":"modules/SAOImageDS9/examples/","page":"Examples","title":"Examples","text":"SAOImageDS9.set(\"frame center\")       # center current frame\nSAOImageDS9.set(\"frame center\",1)     # center 'Frame1'\nSAOImageDS9.set(\"frame center all\")   # center all frames\nSAOImageDS9.set(\"frame clear\")        # clear current frame\nSAOImageDS9.set(\"frame new\")          # create new frame\nSAOImageDS9.set(\"frame new rgb\")      # create new rgb frame\nSAOImageDS9.set(\"frame delete\")       # delete current frame\nSAOImageDS9.set(\"frame reset\")        # reset current frame\nSAOImageDS9.set(\"frame refresh\")      # refresh current frame\nSAOImageDS9.set(\"frame hide\")         # hide current frame\nSAOImageDS9.set(\"frame show\",1)       # show frame 'Frame1'\nSAOImageDS9.set(\"frame move first\")   # move frame to first in order\nSAOImageDS9.set(\"frame move back\")    # move frame back in order\nSAOImageDS9.set(\"frame move forward\") # move frame forward in order\nSAOImageDS9.set(\"frame move last\")    # move frame to last in order\nSAOImageDS9.set(\"frame first\")        # goto first frame\nSAOImageDS9.set(\"frame prev\")         # goto prev frame\nSAOImageDS9.set(\"frame next\")         # goto next frame\nSAOImageDS9.set(\"frame last\")         # goto last frame\nSAOImageDS9.set(\"frame frameno 4\")    # goto frame 'Frame4',create if needed\nSAOImageDS9.set(\"frame\", 3)           # goto frame 'Frame3',create if needed\nSAOImageDS9.set(\"frame match wcs\")\nSAOImageDS9.set(\"frame lock wcs\")","category":"page"},{"location":"modules/SAOImageDS9/examples/#Get-frame-settings","page":"Examples","title":"Get frame settings","text":"","category":"section"},{"location":"modules/SAOImageDS9/examples/","page":"Examples","title":"Examples","text":"SAOImageDS9.get(Int, \"frame\")            # returns the id of the current frame\nSAOImageDS9.get(Int, \"frame frameno\")    # returns the id of the current frame\nSAOImageDS9.get(TupleOf{Int}, \"frame all\")    # returns the id of all frames\nSAOImageDS9.get(TupleOf{Int}, \"frame active\") # returns the id of all active frames\nSAOImageDS9.get(String, \"frame lock\")\nSAOImageDS9.get(Bool, \"frame has amplifier\")\nSAOImageDS9.get(Bool, \"frame has datamin\")\nSAOImageDS9.get(Bool, \"frame has datasec\")\nSAOImageDS9.get(Bool, \"frame has detector\")\nSAOImageDS9.get(Bool, \"frame has grid\")\nSAOImageDS9.get(Bool, \"frame has iis\")\nSAOImageDS9.get(Bool, \"frame has irafmin\")\nSAOImageDS9.get(Bool, \"frame has physical\")\nSAOImageDS9.get(Bool, \"frame has smooth\")\nSAOImageDS9.get(Bool, \"frame has contour\")\nSAOImageDS9.get(Bool, \"frame has contour aux\")\nSAOImageDS9.get(Bool, \"frame has fits\")\nSAOImageDS9.get(Bool, \"frame has fits bin\")\nSAOImageDS9.get(Bool, \"frame has fits cube\")\nSAOImageDS9.get(Bool, \"frame has fits mosaic\")\nSAOImageDS9.get(Bool, \"frame has marker highlite\")\nSAOImageDS9.get(Bool, \"frame has marker paste\")\nSAOImageDS9.get(Bool, \"frame has marker select\")\nSAOImageDS9.get(Bool, \"frame has marker undo\")\nSAOImageDS9.get(Bool, \"frame has system physical\")\nSAOImageDS9.get(Bool, \"frame has wcs wcsa\")\nSAOImageDS9.get(Bool, \"frame has wcs equatorial wcsa\")\nSAOImageDS9.get(Bool, \"frame has wcs linear wcsa\")","category":"page"},{"location":"modules/SAOImageDS9/examples/#Other-examples","page":"Examples","title":"Other examples","text":"","category":"section"},{"location":"modules/SAOImageDS9/examples/","page":"Examples","title":"Examples","text":"Get about string:","category":"page"},{"location":"modules/SAOImageDS9/examples/","page":"Examples","title":"Examples","text":"SAOImageDS9.get(String, \"about\")","category":"page"},{"location":"modules/SAOImageDS9/examples/","page":"Examples","title":"Examples","text":"Get version number:","category":"page"},{"location":"modules/SAOImageDS9/examples/","page":"Examples","title":"Examples","text":"SAOImageDS9.get(VersionNumber, \"version\")","category":"page"},{"location":"modules/SAOImageDS9/examples/","page":"Examples","title":"Examples","text":"Exit SAOImage/DS9:","category":"page"},{"location":"modules/SAOImageDS9/examples/","page":"Examples","title":"Examples","text":"SAOImageDS9.set(\"exit\")","category":"page"},{"location":"modules/SAOImageDS9/examples/","page":"Examples","title":"Examples","text":"Is SAOImage/DS9 iconified?","category":"page"},{"location":"modules/SAOImageDS9/examples/","page":"Examples","title":"Examples","text":"SAOImageDS9.get(Bool, \"iconify\")","category":"page"},{"location":"modules/SAOImageDS9/examples/","page":"Examples","title":"Examples","text":"(De)iconify SAOImage/DS9:","category":"page"},{"location":"modules/SAOImageDS9/examples/","page":"Examples","title":"Examples","text":"SAOImageDS9.set(\"iconify\", bool)","category":"page"},{"location":"modules/SAOImageDS9/examples/","page":"Examples","title":"Examples","text":"SAOImageDS9.set(\"lower\")\nSAOImageDS9.set(\"raise\") # can be used to de-iconify","category":"page"},{"location":"modules/SAOImageDS9/examples/","page":"Examples","title":"Examples","text":"Get/set zoom level:","category":"page"},{"location":"modules/SAOImageDS9/examples/","page":"Examples","title":"Examples","text":"SAOImageDS9.get(Float64, \"zoom\")  # get current zoom level\nSAOImageDS9.set(\"zoom\", value)\nSAOImageDS9.set(\"zoom to\", value)\nSAOImageDS9.set(\"zoom to fit\")","category":"page"},{"location":"modules/SAOImageDS9/examples/","page":"Examples","title":"Examples","text":"Rotation:","category":"page"},{"location":"modules/SAOImageDS9/examples/","page":"Examples","title":"Examples","text":"SAOImageDS9.get(Float64, \"rotate\")\nSAOImageDS9.set(\"rotate\", value)\nSAOImageDS9.set(\"rotate to\", value)\nSAOImageDS9.set(\"rotate open\")\nSAOImageDS9.set(\"rotate close\")","category":"page"},{"location":"modules/SAOImageDS9/examples/","page":"Examples","title":"Examples","text":"SAOImageDS9.get(String, \"orient\")\nSAOImageDS9.set(\"orient\", value)","category":"page"},{"location":"modules/SAOImageDS9/examples/","page":"Examples","title":"Examples","text":"#iexam(;event::Union{AbstractString,Symbol}=:button) = get_words(\"iexam\", event)\n\niexam(args...; event::Union{AbstractString,Symbol}=:button) =\n    get_words(\"iexam\", event, args...)\n\nSAOImageDS9.get(Int, :threads)  # get threads\nSAOImageDS9.set(\"threads\", n)","category":"page"},{"location":"modules/Photometry/apertures/apertures/","page":"Apertures","title":"Apertures","text":"DocTestSetup = :(using Photometry)","category":"page"},{"location":"modules/Photometry/apertures/apertures/#Apertures","page":"Apertures","title":"Apertures","text":"","category":"section"},{"location":"modules/Photometry/apertures/apertures/","page":"Apertures","title":"Apertures","text":"All apertures will rely on a position and the shape parameters.","category":"page"},{"location":"modules/Photometry/apertures/apertures/","page":"Apertures","title":"Apertures","text":"aperture = Aperture(x0, y0, shape_params...)","category":"page"},{"location":"modules/Photometry/apertures/apertures/","page":"Apertures","title":"Apertures","text":"The position can be pixels or sky coordinates. The sky coordinate positions utilize SkyCoords.jl and WCS.jl for conversion.","category":"page"},{"location":"modules/Photometry/apertures/apertures/","page":"Apertures","title":"Apertures","text":"warning: Warning\nSky coordinates are not supported yet.","category":"page"},{"location":"modules/Photometry/apertures/apertures/","page":"Apertures","title":"Apertures","text":"note: Note\nSee Pixel Convention - The origin is the bottom-left with (1, 1) being the center of the pixel.","category":"page"},{"location":"modules/Photometry/apertures/apertures/#API/Reference","page":"Apertures","title":"API/Reference","text":"","category":"section"},{"location":"modules/Photometry/apertures/apertures/","page":"Apertures","title":"Apertures","text":"Aperture.AbstractAperture\nSubpixel","category":"page"},{"location":"modules/Photometry/apertures/apertures/#Photometry.Aperture.AbstractAperture","page":"Apertures","title":"Photometry.Aperture.AbstractAperture","text":"AbstractAperture{T} <: AbstractMatrix{T}\n\nThe abstract super-type for Apertures.\n\nApertures can be thought of as a cutout or stamp of a geometric shape with shading applied. For example, a circular aperture with a diameter of 3 pixels will require a 5x5 pixel grid (when perfectly on-grid) to represent.\n\njulia> ap = CircularAperture(3, 3, 2.5)\n5×5 CircularAperture{Float64} with indices 1:5×1:5:\n 0.136857  0.769325  0.983232  0.769325  0.136857\n 0.769325  1.0       1.0       1.0       0.769325\n 0.983232  1.0       1.0       1.0       0.983232\n 0.769325  1.0       1.0       1.0       0.769325\n 0.136857  0.769325  0.983232  0.769325  0.136857\n\nThis is a useful way of thinking about apertures: if we have some data, we can weight the data with the aperture\n\njulia> data = fill(2, 5, 5);\n\njulia> idxs = map(intersect, axes(ap), axes(data)) |> CartesianIndices;\n\njulia> weighted_cutout = data[idxs] .* ap[idxs]\n5×5 Matrix{Float64}:\n 0.273713  1.53865  1.96646  1.53865  0.273713\n 1.53865   2.0      2.0      2.0      1.53865\n 1.96646   2.0      2.0      2.0      1.96646\n 1.53865   2.0      2.0      2.0      1.53865\n 0.273713  1.53865  1.96646  1.53865  0.273713\n\nPerforming aperture photometry is merely summing the weighted cutout shown above.\n\njulia> flux = sum(weighted_cutout)\n39.269908169872416\n\njulia> flux ≈ (π * 2.5^2) * 2 # area of circle times intensity of 2\ntrue\n\nWhat's interesting about the implementation of apertures, though, is they are lazy. This means there is no stored matrix of aperture values; rather, they are calculated on the fly as needed.\n\njulia> axes(ap)\n(1:5, 1:5)\n\njulia> ap[-10, -10] # out-of-bounds, but calculated on the fly\n0.0\n\njulia> ap .* ones(5, 7) # broadcasts to eachindex(data), regardless of ap bound\n5×7 Matrix{Float64}:\n 0.136857  0.769325  0.983232  0.769325  0.136857  0.0  0.0\n 0.769325  1.0       1.0       1.0       0.769325  0.0  0.0\n 0.983232  1.0       1.0       1.0       0.983232  0.0  0.0\n 0.769325  1.0       1.0       1.0       0.769325  0.0  0.0\n 0.136857  0.769325  0.983232  0.769325  0.136857  0.0  0.0\n\nThis allows extremely efficient computation of aperture photometry from small to medium sized apertures.\n\njulia> using BenchmarkTools\n\njulia> @btime sum(idx -> $ap[idx] * $data[idx], $idxs)\n  1.097 μs (0 allocations: 0 bytes)\n39.26990816987243\n\nThis is essentially the full implementation of photometry, save for the packing of additional information into a tabular form.\n\n\n\n\n\n","category":"type"},{"location":"modules/Photometry/apertures/apertures/#Photometry.Aperture.Subpixel","page":"Apertures","title":"Photometry.Aperture.Subpixel","text":"Subpixel(ap, N=1) <: AbstractAperture\n\nUse a subpixel quadrature approximation for pixel shading instead of exact geometric methods.\n\nFor any pixel laying on the border of ap, this alters the shading algorithm by breaking the border pixel up into (N, N) subpixels. The shading value is the fraction of these subpixels within the geometric border of ap.\n\nUsing a subpixel shading method is sometimes faster than exact methods at the cost of accuracy. For CircularAperture the subpixel method is only faster than the exact method for N ~ 7. for EllipticalAperture the cutoff is N ~ 12, and for RectangularAperture the cutoff is N ~ 20.\n\nExamples\n\njulia> ap = CircularAperture(3, 3, 2.5)\n5×5 CircularAperture{Float64} with indices 1:5×1:5:\n 0.136857  0.769325  0.983232  0.769325  0.136857\n 0.769325  1.0       1.0       1.0       0.769325\n 0.983232  1.0       1.0       1.0       0.983232\n 0.769325  1.0       1.0       1.0       0.769325\n 0.136857  0.769325  0.983232  0.769325  0.136857\n\njulia> sub_ap = Subpixel(ap, 5)\n5×5 Subpixel{Float64, CircularAperture{Float64}} with indices 1:5×1:5:\n 0.12  0.76  1.0  0.76  0.12\n 0.76  1.0   1.0  1.0   0.76\n 1.0   1.0   1.0  1.0   1.0\n 0.76  1.0   1.0  1.0   0.76\n 0.12  0.76  1.0  0.76  0.12\n\nnote: Note\nphotutils offers a center shading method which is equivalent to using the Subpixel method with 1 subpixel. To avoid unneccessary namespace cluttering, we simply instruct users to use Subpixel(ap) instead.\n\n\n\n\n\n","category":"type"},{"location":"modules/Photometry/apertures/apertures/#Circular-Apertures","page":"Apertures","title":"Circular Apertures","text":"","category":"section"},{"location":"modules/Photometry/apertures/apertures/","page":"Apertures","title":"Apertures","text":"These apertures are parameterized by radius.","category":"page"},{"location":"modules/Photometry/apertures/apertures/","page":"Apertures","title":"Apertures","text":"CircularAperture\nCircularAnnulus","category":"page"},{"location":"modules/Photometry/apertures/apertures/#Photometry.Aperture.CircularAperture","page":"Apertures","title":"Photometry.Aperture.CircularAperture","text":"CircularAperture(x, y, r)\nCircularAperture(position, r)\n\nA circular aperture.\n\nA circular aperture with radius r. r must be greater than or equal to 0.\n\nExamples\n\njulia> ap = CircularAperture(0, 0, 10)\n21×21 CircularAperture{Int64} with indices -10:10×-10:10:\n 0          0         0           …  0           0         0\n 0          0         0              0           0         0\n 0          0         0              0           0         0\n 0          0         0.00571026     0.00571026  0         0\n 0          0         0.491844       0.491844    0         0\n 0          0.170878  0.982952    …  0.982952    0.170878  0\n 0          0.659735  1              1           0.659735  0\n 0.0590655  0.975524  1              1           0.975524  0.0590655\n 0.293527   1         1              1           1         0.293527\n 0.445643   1         1              1           1         0.445643\n ⋮                                ⋱                        ⋮\n 0.293527   1         1              1           1         0.293527\n 0.0590655  0.975524  1              1           0.975524  0.0590655\n 0          0.659735  1              1           0.659735  0\n 0          0.170878  0.982952    …  0.982952    0.170878  0\n 0          0         0.491844       0.491844    0         0\n 0          0         0.00571026     0.00571026  0         0\n 0          0         0              0           0         0\n 0          0         0              0           0         0\n 0          0         0           …  0           0         0\n\n\n\n\n\n","category":"type"},{"location":"modules/Photometry/apertures/apertures/#Photometry.Aperture.CircularAnnulus","page":"Apertures","title":"Photometry.Aperture.CircularAnnulus","text":"CircularAnnulus(x, y, r_in, r_out)\nCircularAnnulus(position, r_in, r_out)\n\nA circular annulus with inner radius r_in and outer radius r_out. 0 ≤ r_in ≤ r_out.\n\nExamples\n\njulia> ap = CircularAnnulus(0, 0, 5, 10)\n21×21 CircularAnnulus{Int64} with indices -10:10×-10:10:\n 0          0         0           …  0           0         0\n 0          0         0              0           0         0\n 0          0         0              0           0         0\n 0          0         0.00571026     0.00571026  0         0\n 0          0         0.491844       0.491844    0         0\n 0          0.170878  0.982952    …  0.982952    0.170878  0\n 0          0.659735  1              1           0.659735  0\n 0.0590655  0.975524  1              1           0.975524  0.0590655\n 0.293527   1         1              1           1         0.293527\n 0.445643   1         1              1           1         0.445643\n ⋮                                ⋱                        ⋮\n 0.293527   1         1              1           1         0.293527\n 0.0590655  0.975524  1              1           0.975524  0.0590655\n 0          0.659735  1              1           0.659735  0\n 0          0.170878  0.982952    …  0.982952    0.170878  0\n 0          0         0.491844       0.491844    0         0\n 0          0         0.00571026     0.00571026  0         0\n 0          0         0              0           0         0\n 0          0         0              0           0         0\n 0          0         0           …  0           0         0\n\n\n\n\n\n","category":"type"},{"location":"modules/Photometry/apertures/apertures/#Elliptical-Apertures","page":"Apertures","title":"Elliptical Apertures","text":"","category":"section"},{"location":"modules/Photometry/apertures/apertures/","page":"Apertures","title":"Apertures","text":"These apertures are parameterized by the semi-major axis a, semi-minor axis b and position angle in degrees counter-clockwise from the positive x-axis θ","category":"page"},{"location":"modules/Photometry/apertures/apertures/","page":"Apertures","title":"Apertures","text":"EllipticalAperture\nEllipticalAnnulus","category":"page"},{"location":"modules/Photometry/apertures/apertures/#Photometry.Aperture.EllipticalAperture","page":"Apertures","title":"Photometry.Aperture.EllipticalAperture","text":"EllipticalAperture(x, y, a, b, θ=0)\nEllipticalAperture(position, a, b, θ=0)\n\nAn elliptical aperture with semi-major axis a, semi-minor axis b, and position angle θ. a and b must be ≥ 0, θ is measured in degrees counter-clockwise the standard x-axis.\n\nExamples\n\njulia> ap = EllipticalAperture(0, 0, 4, 2, 35)\n7×5 EllipticalAperture{Int64} with indices -3:3×-2:2:\n 0.873382  0.844185  0.324917  0         0\n 1         1         0.997821  0.435284  0\n 1         1         1         0.990119  0.23968\n 0.796137  1         1         1         0.796137\n 0.23968   0.990119  1         1         1\n 0         0.435284  0.997821  1         1\n 0         0         0.324917  0.844185  0.873382\n\n\n\n\n\n","category":"type"},{"location":"modules/Photometry/apertures/apertures/#Photometry.Aperture.EllipticalAnnulus","page":"Apertures","title":"Photometry.Aperture.EllipticalAnnulus","text":"EllipticalAnnulus(x, y, a_in, a_out, b_out, θ=0)\nEllipticalAnnulus(position, a_in, a_out, b_out, θ=0)\n\nAn elliptical annulus with inner semi-major axis a_in, outer semi-major axis a_out, outer semi-minor axis b_out, and position angle θ. a_out ≥ a_in ≥ 0 and b_out must be ≥ 0, θ is measured in degrees counter-clockwise the standard x-axis.\n\nb_in will automatically be calculated from (a_in / a_out) * b_out. Note this may cause a type instability.\n\nExamples\n\njulia> ap = EllipticalAnnulus(0, 0, 4, 10, 5, 45)\n15×15 EllipticalAnnulus{Float64} with indices -7:7×-7:7:\n 0.594853   1.0       1.0       1.0         …  0.0       0.0       0.0\n 1.0        1.0       1.0       1.0            0.0       0.0       0.0\n 1.0        1.0       1.0       1.0            0.0       0.0       0.0\n 1.0        1.0       1.0       1.0            0.0       0.0       0.0\n 1.0        1.0       1.0       1.0            0.0       0.0       0.0\n 0.814163   1.0       1.0       1.0         …  0.414163  0.0       0.0\n 0.369432   1.0       1.0       1.0            0.975704  0.193728  0.0\n 0.0112571  0.809079  1.0       1.0            1.0       0.809079  0.0112571\n 0.0        0.193728  0.975704  1.0            1.0       1.0       0.369432\n 0.0        0.0       0.414163  1.0            1.0       1.0       0.814163\n 0.0        0.0       0.0       0.546165    …  1.0       1.0       1.0\n 0.0        0.0       0.0       0.00252321     1.0       1.0       1.0\n 0.0        0.0       0.0       0.0            1.0       1.0       1.0\n 0.0        0.0       0.0       0.0            1.0       1.0       1.0\n 0.0        0.0       0.0       0.0            1.0       1.0       0.594853\n\n\n\n\n\n","category":"type"},{"location":"modules/Photometry/apertures/apertures/#Rectangular-Apertures","page":"Apertures","title":"Rectangular Apertures","text":"","category":"section"},{"location":"modules/Photometry/apertures/apertures/","page":"Apertures","title":"Apertures","text":"These apertures are parameterized by width w, height h, and position angle in degrees counter-clockwise from the positive x-axis θ.","category":"page"},{"location":"modules/Photometry/apertures/apertures/","page":"Apertures","title":"Apertures","text":"RectangularAperture\nRectangularAnnulus","category":"page"},{"location":"modules/Photometry/apertures/apertures/#Photometry.Aperture.RectangularAperture","page":"Apertures","title":"Photometry.Aperture.RectangularAperture","text":"RectangularAperture(x, y, w, h, θ=0)\nRectangularAperture(position, w, h, θ=0)\n\nA rectangular aperture.\n\nA rectangular aperture with width w, height h, and position angle θ in degrees.\n\nExamples\n\njulia> ap = RectangularAperture(0, 0, 10, 4, 0)\n11×5 RectangularAperture{Int64} with indices -5:5×-2:2:\n 0.25  0.5  0.5  0.5  0.25\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.5   1    1    1    0.5\n 0.25  0.5  0.5  0.5  0.25\n\n\n\n\n\n","category":"type"},{"location":"modules/Photometry/apertures/apertures/#Photometry.Aperture.RectangularAnnulus","page":"Apertures","title":"Photometry.Aperture.RectangularAnnulus","text":"RectangularAnnulus(x, y, w_in, w_out, h_out, θ=0)\nRectangularAnnulus(position, w_in, w_out, h_out, θ=0)\n\nA rectangular annulus with inner width w_in, outer width w_out, outer height h_out, and position angle θ in degrees. h_in is automatically calculated from w_in / w_out * h_out. Note that w_out ≥ w_in > 0.\n\nExamples\n\njulia> ap = RectangularAnnulus(0, 0, 5, 10, 8, 45)\n13×13 RectangularAnnulus{Float64} with indices -6:6×-6:6:\n 0.0       0.0       0.0         …  0.0         0.0       0.0\n 0.0       0.0       0.0            0.0         0.0       0.0\n 0.0       0.0       0.00252532     0.0         0.0       0.0\n 0.0       0.0       0.568542       0.0         0.0       0.0\n 0.0       0.568542  1.0            0.215729    0.0       0.0\n 0.528175  1.0       1.0         …  1.0         0.215729  0.0\n 0.215729  1.0       1.0            1.0         1.0       0.215729\n 0.0       0.215729  1.0            1.0         1.0       0.528175\n 0.0       0.0       0.215729       1.0         0.568542  0.0\n 0.0       0.0       0.0            0.568542    0.0       0.0\n 0.0       0.0       0.0         …  0.00252532  0.0       0.0\n 0.0       0.0       0.0            0.0         0.0       0.0\n 0.0       0.0       0.0            0.0         0.0       0.0\n\n\n\n\n\n","category":"type"},{"location":"modules/SAOImageDS9/library/#Package-library","page":"Package library","title":"Package library","text":"","category":"section"},{"location":"modules/SAOImageDS9/library/#Requests-to-SAOImage/DS9","page":"Package library","title":"Requests to SAOImage/DS9","text":"","category":"section"},{"location":"modules/SAOImageDS9/library/","page":"Package library","title":"Package library","text":"SAOImageDS9.get\nSAOImageDS9.set","category":"page"},{"location":"modules/SAOImageDS9/library/#SAOImageDS9.get","page":"Package library","title":"SAOImageDS9.get","text":"SAOImageDS9.get([T, [dims,]] args...)\n\nsends a \"get\" request to the SAOImage/DS9 server.  The request is made of arguments args... converted into strings and merged with separating spaces. An exception is thrown in case of error.\n\nThe returned value depends on the optional arguments T and dims:\n\nIf neither T nor dims are specified, an instance of XPA.Reply is returned with at most one answer (see documentation for XPA.get for more details).\nIf only T is specified, it can be:\nString to return the answer as a single string;\nVector{String}} or Tuple{Vararg{String}} to return the answer split in words as a vector or as a tuple of strings;\nT where T<:Real to return a value of type T obtained by parsing the textual answer.\nTuple{Vararg{T}} where T<:Real to return a value of type T obtained by parsing the textual answer;\nVector{T} where T is not String to return the binary contents of the answer as a vector of type T;\nIf both T and dims are specified, T can be an array type like Array{S} or Array{S,N} and dims a list of N dimensions to retrieve the binary contents of the answer as an array of type Array{S,N}.\n\nAs a special case:\n\nSAOImageDS9.get(Array; endian=:native) -> arr\n\nyields the contents of current SAOImage/DS9 frame as an array (or as nothing if the frame is empty). Keyword endian can be used to specify the byte order of the received values (see SAOImageDS9.byte_order).\n\nTo retrieve the version of the SAOImage/DS9 program:\n\nSAOImageDS9.get(VersionNumber)\n\nSee also SAOImageDS9.connect, SAOImageDS9.set and XPA.get.\n\n\n\n\n\n","category":"function"},{"location":"modules/SAOImageDS9/library/#SAOImageDS9.set","page":"Package library","title":"SAOImageDS9.set","text":"SAOImageDS9.set(args...; data=nothing)\n\nsends command and/or data to the SAOImage/DS9 server.  The command is made of arguments args... converted into strings and merged with a separating spaces. Keyword data can be used to specify the data to send.  An exception is thrown in case of error.\n\nAs a special case:\n\nSAOImageDS9.set(arr; mask=false, new=false, endian=:native)\n\nset the contents of the current SAOImage/DS9 frame to be array arr.  Keyword new can be set true to create a new frame for displyaing the array.  Keyword endian can be used to specify the byte order of the values in arr (see SAOImageDS9.byte_order.\n\nSee also SAOImageDS9.connect, SAOImageDS9.get and XPA.set.\n\n\n\n\n\n","category":"function"},{"location":"modules/SAOImageDS9/library/#Connection","page":"Package library","title":"Connection","text":"","category":"section"},{"location":"modules/SAOImageDS9/library/","page":"Package library","title":"Package library","text":"SAOImageDS9.connect\nSAOImageDS9.accesspoint","category":"page"},{"location":"modules/SAOImageDS9/library/#SAOImageDS9.connect","page":"Package library","title":"SAOImageDS9.connect","text":"SAOImageDS9.connect(ident=\"DS9:*\") -> apt\n\nset the access point for further SAOImage/DS9 commands.  Argument ident identifies the XPA access point, it can be a template string like \"DS9:*\" which is the default value or a regular expression.  The returned value is the name of the access point.\n\nTo retrieve the name of the current SAOImage/DS9 access point, call the SAOImageDS9.accesspoint method.\n\n\n\n\n\n","category":"function"},{"location":"modules/SAOImageDS9/library/#SAOImageDS9.accesspoint","page":"Package library","title":"SAOImageDS9.accesspoint","text":"SAOImageDS9.accesspoint()\n\nyields the XPA access point which identifies the SAOImage/DS9 server.  This access point can be set by calling the SAOImageDS9.connect method. An empty string is returned if no access point has been chosen.  To automatically connect to SAOImage/DS9 if not yet done, you can do:\n\nif SAOImageDS9.accesspoint() == \"\"; SAOImageDS9.connect(); end\n\nSee also SAOImageDS9.connect and SAOImageDS9.accesspoint.\n\n\n\n\n\n","category":"function"},{"location":"modules/SAOImageDS9/library/#Drawing","page":"Package library","title":"Drawing","text":"","category":"section"},{"location":"modules/SAOImageDS9/library/","page":"Package library","title":"Package library","text":"SAOImageDS9.draw","category":"page"},{"location":"modules/SAOImageDS9/library/#SAOImageDS9.draw","page":"Package library","title":"SAOImageDS9.draw","text":"SAOImageDS9.draw(args...; kwds...)\n\ndraws something in SAOImage/DS9 application.  The operation depends on the type of the arguments.\n\n\n\nSAOImageDS9.draw(img; kwds...)\n\ndisplays image img (a 2-dimensional Julia array) in SAOImage/DS9. The following keywords are possible:\n\nKeyword frame can be used to specify the frame number.\nKeyword cmap can be used to specify the name of the colormap.  For instance, cmap=\"gist_stern\".\nKeyword zoom can be used to specify the zoom factor.\nKeywords min and/or max can be used to specify the scale limits.\n\n\n\nSAOImageDS9.draw(pnt; kwds...)\n\ndraws pnt as point(s) in SAOImage/DS9, pnt is a Point, an array or a tuple of Point.\n\n\n\nSAOImageDS9.draw(box; kwds...)\n\ndraws box as rectangle(s) in SAOImage/DS9, box is a BoundingBox, an array or a tuple of BoundingBox.\n\n\n\n\n\n","category":"function"},{"location":"modules/SAOImageDS9/library/#Utilities","page":"Package library","title":"Utilities","text":"","category":"section"},{"location":"modules/SAOImageDS9/library/","page":"Package library","title":"Package library","text":"SAOImageDS9.bitpix_of\nSAOImageDS9.bitpix_to_type\nSAOImageDS9.byte_order","category":"page"},{"location":"modules/SAOImageDS9/library/#SAOImageDS9.bitpix_of","page":"Package library","title":"SAOImageDS9.bitpix_of","text":"SAOImageDS9.bitpix_of(x) -> bp\n\nyields FITS bits-per-pixel (BITPIX) value for x which can be an array or a type.  A value of 0 is returned if x is not of a supported type.\n\nSee also SAOImageDS9.bitpix_to_type.\n\n\n\n\n\n","category":"function"},{"location":"modules/SAOImageDS9/library/#SAOImageDS9.bitpix_to_type","page":"Package library","title":"SAOImageDS9.bitpix_to_type","text":"SAOImageDS9.bitpix_to_type(bp) -> T\n\nyields Julia type corresponding to FITS bits-per-pixel (BITPIX) value bp. The value Nothing is returned if bp is unknown.\n\nSee also SAOImageDS9.bitpix_of.\n\n\n\n\n\n","category":"function"},{"location":"modules/SAOImageDS9/library/#SAOImageDS9.byte_order","page":"Package library","title":"SAOImageDS9.byte_order","text":"SAOImageDS9.byte_order(endian)\n\nyields the byte order for retrieving the elements of a SAOImage/DS9 array. Argument can be one of the strings (or the equivalent symbol): \"big\" for most significant byte first, \"little\" for least significant byte first or \"native\" to yield the byte order of the machine.\n\nSee also SAOImageDS9.get, SAOImageDS9.set.\n\n\n\n\n\n","category":"function"},{"location":"modules/FITSIO/api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"modules/FITSIO/api/#File-operations","page":"API Reference","title":"File operations","text":"","category":"section"},{"location":"modules/FITSIO/api/","page":"API Reference","title":"API Reference","text":"FITS\nlength\nclose\ndeleteat!","category":"page"},{"location":"modules/FITSIO/api/#FITSIO.FITS","page":"API Reference","title":"FITSIO.FITS","text":"FITS(filename::String[, mode::String = \"r\"]; extendedparser = true)\n\nOpen or create a FITS file. mode can be one of \"r\" (read-only), \"r+\" (read-write) or \"w\" (write). In \"write\" mode, any existing file of the same name is overwritten.\n\nA FITS object is a collection of \"Header-Data Units\" (HDUs) and supports the following operations:\n\nf[i]: Return the i-th HDU.\nf[name] or f[name, ver]: Return the HDU containing the given the given EXTNAME (or HDUNAME) keyword (a String), and optionally the given EXTVER (or HDUVER) number (an Integer).\nIteration:\nfor hdu in f\n    ...\nend\n\nThe keyword argument extendedparser may be used to enable or disable the extended filename parser. If disabled, filename is treated exactly as the name of the file and is not tokenized into parameters.\n\n\n\n\n\n","category":"type"},{"location":"modules/FITSIO/api/#Base.length","page":"API Reference","title":"Base.length","text":"length(f::FITS)\n\nNumber of HDUs in the file.\n\n\n\n\n\nlength(hdr::FITSHeader)\n\nNumber of records in header of HDU.\n\n\n\n\n\nlength(hdu::ImageHDU)\n\nGet total number of pixels in image (product of size(hdu)).\n\n\n\n\n\n","category":"function"},{"location":"modules/FITSIO/api/#Base.close","page":"API Reference","title":"Base.close","text":"close(f::FITS)\n\nClose the file.\n\nSubsequent attempts to operate on f will result in an error. FITS objects are also automatically closed when they are garbage collected.\n\n\n\n\n\n","category":"function"},{"location":"modules/FITSIO/api/#Base.deleteat!","page":"API Reference","title":"Base.deleteat!","text":"deleteat!(f::FITS, i::Integer)\n\nDelete the HDU at index i in the FITS file. If i == 1, this deletes the primary HDU and replaces it with a bare HDU with no data and a minimal header. If i > 1, this removes the HDU at index i and moves the following HDUs forward.\n\n\n\n\n\n","category":"function"},{"location":"modules/FITSIO/api/#Header-operations","page":"API Reference","title":"Header operations","text":"","category":"section"},{"location":"modules/FITSIO/api/","page":"API Reference","title":"API Reference","text":"read_key\nwrite_key\nread_header\nFITSHeader\nlength(::FITSHeader)\nhaskey(::FITSHeader, ::String)\nkeys(::FITSHeader)\nvalues(::FITSHeader)\nget_comment\nset_comment!\ndefault_header","category":"page"},{"location":"modules/FITSIO/api/#FITSIO.read_key","page":"API Reference","title":"FITSIO.read_key","text":"read_key(hdu::HDU, key::String) -> (value, comment)\n\nRead the HDU header record specified by keyword and return a tuple where value is the keyword parsed value (of type String, Bool, Int, Float64 or Nothing), comment is the keyword comment (as a string). Throw an error if key is not found.\n\nread_key(hdu::HDU, key::Integer) -> (keyname, value, comment)\n\nSame as above but FITS card is specified by its position and returns a 3 element tuple where keyname is the keyword name (a string).\n\n\n\n\n\n","category":"function"},{"location":"modules/FITSIO/api/#FITSIO.write_key","page":"API Reference","title":"FITSIO.write_key","text":"write_key(hdu::HDU, key::String, value[, comment])\n\nWrite a keyword value the HDU's header. value can be a standard header type (String, Bool, Integer, AbstractFloat) or nothing, in which case the value part of the record will be empty. If the keyword already exists, the value will be overwritten. The comment will only be overwritten if given. If the keyword does not already exist, a new record will be appended at the end of the header.\n\n\n\n\n\n","category":"function"},{"location":"modules/FITSIO/api/#FITSIO.read_header","page":"API Reference","title":"FITSIO.read_header","text":"read_header(filename::AbstractString, hduindex = 1) -> FITSHeader\n\nConvenience function to read the entire header corresponding to the HDU at index hduindex contained in the FITS file named filename. Functionally read_header(filename, hduindex) is equivalent to\n\nFITS(filename, \"r\") do f\n    read_header(f[hduindex])\nend\n\n\n\n\n\nread_header(hdu::HDU) -> FITSHeader\n\nRead the entire header from the given HDU and return a FITSHeader object. The value of each header record is parsed as Int, Float64, String, Bool or nothing according to the FITS standard.\n\nIf the value cannot be parsed according to the FITS standard, the value is stored as the raw unparsed String.\n\n\n\n\n\nread_header(hdu::HDU, String) -> String\n\nRead the entire header from the given HDU as a single string.\n\n\n\n\n\n","category":"function"},{"location":"modules/FITSIO/api/#FITSIO.FITSHeader","page":"API Reference","title":"FITSIO.FITSHeader","text":"FITSHeader(keys::Vector{String}, values::Vector, comments::Vector{String})\n\nAn in-memory representation of the header of an HDU. It stores the (key, value, comment) information for each 80-character \"card\" in a header.\n\nNote that this structure is not linked to a FITS file in any way; it is just a convenient structure for storing the header contents after reading from a file. (This is similar to how an Array returned by read(f[1]) is not linked to the FITS file f.)  Manipulating a FITSHeader will therefore have no immediate impact on any file, even if it was created by read_header(::HDU).  You can, however, write a FITSHeader to a file using the write(::FITS, ...) methods that append a new HDU to a file.\n\n\n\n\n\n","category":"type"},{"location":"modules/FITSIO/api/#Base.length-Tuple{FITSHeader}","page":"API Reference","title":"Base.length","text":"length(hdr::FITSHeader)\n\nNumber of records in header of HDU.\n\n\n\n\n\n","category":"method"},{"location":"modules/FITSIO/api/#Base.haskey-Tuple{FITSHeader, String}","page":"API Reference","title":"Base.haskey","text":"haskey(hdr::FITSHeader, key::String)\n\nReturns true if key exists in header, otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"modules/FITSIO/api/#Base.keys-Tuple{FITSHeader}","page":"API Reference","title":"Base.keys","text":"keys(hdr::FITSHeader)\n\nArray of keywords in header of HDU (not a copy).\n\n\n\n\n\n","category":"method"},{"location":"modules/FITSIO/api/#Base.values-Tuple{FITSHeader}","page":"API Reference","title":"Base.values","text":"values(hdr::FITSHeader)\n\nArray of values in header of HDU (not a copy).\n\n\n\n\n\n","category":"method"},{"location":"modules/FITSIO/api/#FITSIO.get_comment","page":"API Reference","title":"FITSIO.get_comment","text":"get_comment(hdr::FITSHeader, key_or_index::Union{String,Integer})\n\nGet the comment based on keyword or index.\n\n\n\n\n\n","category":"function"},{"location":"modules/FITSIO/api/#FITSIO.set_comment!","page":"API Reference","title":"FITSIO.set_comment!","text":"set_comment!(hdr::FITSHeader, key_or_index::Union{String,Integer}, comment::String)\n\nSet the comment based on keyword or index.\n\n\n\n\n\n","category":"function"},{"location":"modules/FITSIO/api/#FITSIO.default_header","page":"API Reference","title":"FITSIO.default_header","text":"default_header(data::AbstractArray)\n\nCreates a default header for the given array with the SIMPLE, BITPIX, NAXIS, NAXIS*, and EXTEND entries.\n\n\n\n\n\n","category":"function"},{"location":"modules/FITSIO/api/#Image-operations","page":"API Reference","title":"Image operations","text":"","category":"section"},{"location":"modules/FITSIO/api/","page":"API Reference","title":"API Reference","text":"read(::ImageHDU)\nread!\nFITSIO.fitsread\nwrite(::FITS, ::StridedArray{<:Real})\nwrite(::ImageHDU, ::StridedArray{<:Real})\nFITSIO.fitswrite\neltype(::ImageHDU)\nndims(::ImageHDU)\nsize(::ImageHDU)\nlength(::ImageHDU)\ncopy_section","category":"page"},{"location":"modules/FITSIO/api/#Base.read-Tuple{ImageHDU}","page":"API Reference","title":"Base.read","text":"read(hdu::ImageHDU)\nread(hdu::ImageHDU, range...)\n\nRead the data array or a subset thereof from disk. The first form reads the entire data array. The second form reads a slice of the array given by the specified ranges or integers. Dimensions specified by integers will be dropped in the returned array, while those specified by ranges will be retained.\n\nnote: Note\nJulia follows a column-major array indexing convention, so the indices provided must account for this. In particular this means that FITS files created externally following a row-major convention (eg. using astropy) will have the sequence of axes flipped when read in using FITSIO.\n\n\n\n\n\n","category":"method"},{"location":"modules/FITSIO/api/#Base.read!","page":"API Reference","title":"Base.read!","text":"read!(hdu::ImageHDU, A::StridedArray)\nread!(hdu::ImageHDU, A::StridedArray, range...)\n\nRead the data or a subset thereof from disk, and save it in a pre-allocated output array A. The first form reads the entire data from disk. The second form reads a slice of the array given by the specified ranges or integers. The array A needs to have the same length as the number of elements to be read in. Additionally A needs to be stored contiguously in memory.\n\nnote: Note\nJulia follows a column-major array indexing convention, so the indices provided must account for this. In particular this means that FITS files created externally following a row-major convention (eg. using astropy) will have the sequence of the axes flipped when read in using FITSIO.\n\n\n\n\n\n","category":"function"},{"location":"modules/FITSIO/api/#FITSIO.fitsread","page":"API Reference","title":"FITSIO.fitsread","text":"fitsread(filename::AbstractString[, hduindex = 1[, arrayindices...]]; extendedparser = true)\n\nConvenience function to read in an image corresponding to the HDU at index hduindex contained in the FITS file named filename. If arrayindices are provided, only a slice of the image corresponding to the indices is read in.\n\nFunctionally fitsread(filename, hduindex, arrayindices...; extendedparser) is equivalent to\n\nFITS(filename, \"r\"; extendedparser = extendedparser) do f\n    read(f[hduindex], arrayindices...)\nend\n\nThe keyword argument extendedparser may be used to enable or disable the extended filename parser. If disabled, filename is treated exactly as the name of the file and is not tokenized into parameters.\n\nnote: Note\nJulia follows a column-major array indexing convention, so the indices provided must account for this. In particular this means that FITS files created externally following a row-major convention (eg. using astropy) will have the sequence of axes flipped when read in using FITSIO.\n\nSee also: read\n\n\n\n\n\n","category":"function"},{"location":"modules/FITSIO/api/#Base.write-Tuple{FITS, StridedArray{<:Real}}","page":"API Reference","title":"Base.write","text":"write(f::FITS, data::StridedArray{<:Real}; header=nothing, name=nothing, ver=nothing)\n\nAdd a new image HDU to FITS file f with contents data. The following array element types are supported: UInt8, Int8, UInt16, Int16, UInt32, Int32, Int64, Float32, Float64. If a FITSHeader object is passed as the header keyword argument, the header will also be added to the new HDU. The data to be written out must be stored contiguously in memory.\n\ntip: Unsupported element types\nIt might be possible to write out an array with an element type other than those mentioned above by reinterpreting it as one that is supported. For example, to write out a Complex array and read it back in, we may usejulia> a = rand(ComplexF64, 2)\n2-element Array{Complex{Float64},1}:\n 0.4943325325752195 + 0.2034650017475852im\n 0.2495752009567498 + 0.819163869249041im\n\n# We may write this out as Float64\njulia> FITSIO.fitswrite(\"temp.fits\", reinterpret(Float64, a))\n\n# reinterpret it back as a complex one while reading it in\njulia> reinterpret(ComplexF64, FITSIO.fitsread(\"temp.fits\"))\n2-element reinterpret(Complex{Float64}, ::Array{Float64,1}):\n 0.4943325325752195 + 0.2034650017475852im\n 0.2495752009567498 + 0.819163869249041imWhile this often works in practice, such a workaround is not officially supported by FITSIO, and care must be taken to ensure the correctness of data.\n\n\n\n\n\n","category":"method"},{"location":"modules/FITSIO/api/#Base.write-Tuple{ImageHDU, StridedArray{<:Real}}","page":"API Reference","title":"Base.write","text":"write(hdu::ImageHDU, data::StridedArray{<:Real})\n\nWrite data to an existing image HDU. The data to be written out must be stored contiguously in memory.\n\n\n\n\n\n","category":"method"},{"location":"modules/FITSIO/api/#FITSIO.fitswrite","page":"API Reference","title":"FITSIO.fitswrite","text":"fitswrite(filename::AbstractString, data; extendedparser = true, kwargs...)\n\nConvenience function to write the image array data to a file named filename.\n\nFunctionally fitswrite(filename, data; extendedparser, kwargs...) is equivalent to\n\nFITS(filename, \"w\"; extendedparser = extendedparser) do f\n    write(f, data; kwargs...)\nend\n\nThe keyword argument extendedparser may be used to enable or disable the extended filename parser. If disabled, filename is treated exactly as the name of the file and is not tokenized into parameters.\n\nwarn: Warning\nExisting files with the same name will be overwritten.\n\nSee also: write\n\n\n\n\n\n","category":"function"},{"location":"modules/FITSIO/api/#Base.eltype-Tuple{ImageHDU}","page":"API Reference","title":"Base.eltype","text":"eltype(hdu::ImageHDU)\n\nReturn the element type of the image in hdu.\n\n\n\n\n\n","category":"method"},{"location":"modules/FITSIO/api/#Base.ndims-Tuple{ImageHDU}","page":"API Reference","title":"Base.ndims","text":"ndims(hdu::ImageHDU)\n\nGet number of image dimensions, without reading the image into memory.\n\n\n\n\n\n","category":"method"},{"location":"modules/FITSIO/api/#Base.size-Tuple{ImageHDU}","page":"API Reference","title":"Base.size","text":"size(hdu::ImageHDU)\nsize(hdu::ImageHDU, i)\n\nGet image dimensions (or ith dimension), without reading the image into memory.\n\n\n\n\n\n","category":"method"},{"location":"modules/FITSIO/api/#Base.length-Tuple{ImageHDU}","page":"API Reference","title":"Base.length","text":"length(hdu::ImageHDU)\n\nGet total number of pixels in image (product of size(hdu)).\n\n\n\n\n\n","category":"method"},{"location":"modules/FITSIO/api/#FITSIO.copy_section","page":"API Reference","title":"FITSIO.copy_section","text":"copy_section(hdu, dest, r...)\n\nCopy a rectangular section of an image and write it to a new FITS primary image or image extension in FITS object dest. The new image HDU is appended to the end of dest. All the keywords in the input image will be copied to the output image. The common WCS keywords will be updated if necessary to correspond to the coordinates of the section.\n\nExamples\n\nCopy the lower-left 200 x 200 pixel section of the image in hdu to an open file, f\n\ncopy_section(hdu, f, 1:200, 1:200)\n\nSame as above but only copy odd columns in y:\n\ncopy_section(hdu, f, 1:200, 1:2:200)\n\n\n\n\n\n","category":"function"},{"location":"modules/FITSIO/api/#Table-operations","page":"API Reference","title":"Table operations","text":"","category":"section"},{"location":"modules/FITSIO/api/","page":"API Reference","title":"API Reference","text":"FITSIO.colnames\nwrite(::FITS, ::Dict{String})\nwrite(::FITS, ::Vector{String}, ::Vector)\nread(::TableHDU, ::String)","category":"page"},{"location":"modules/FITSIO/api/#FITSIO.colnames","page":"API Reference","title":"FITSIO.colnames","text":"colnames(hdu) -> Vector{String}\n\nReturn the names of columns in a table HDU.\n\n\n\n\n\n","category":"function"},{"location":"modules/FITSIO/api/#Base.write-Tuple{FITS, Dict{String}}","page":"API Reference","title":"Base.write","text":"write(f::FITS, data::Dict; hdutype=TableHDU, name=nothing, ver=nothing, header=nothing, units=nothing, varcols=nothing)\n\nCreate a new table extension and write data to it. If the FITS file is currently empty then a dummy primary array will be created before appending the table extension to it. data should be a dictionary with String keys (giving the column names) and Array values (giving data to write to each column). The following types are supported in binary tables: UInt8, Int8, UInt16, Int16, UInt32, Int32, Int64, Float32, Float64, Complex{Float32}, Complex{Float64}, String, Bool.\n\nOptional inputs:\n\nhdutype: Type of table extension to create. Can be either TableHDU (binary table) or ASCIITableHDU (ASCII table).\nname: Name of extension.\nver: Version of extension (Int).\nheader: FITSHeader instance to write to new extension.\nunits: Dictionary mapping column name to units (as a string).\nvarcols: An array giving the column names or column indicies to write as \"variable-length columns\".\n\nnote: Variable length columns\nVariable length columns allow a column's row entries to contain arrays of different lengths. They can potentially save diskspace when the rows of a column vary greatly in length, as the column data is all written to a contiguous heap area at the end of the table. Only column data of type Vector{String} or types such as Vector{Vector{UInt8}} can be written as variable length columns. In the second case, ensure that the column data type is a leaf type. That is, the type cannot be Vector{Vector{T}}, which would be an array of arrays having potentially non-uniform element types (which would not be writable as a FITS table column).\n\n\n\n\n\n","category":"method"},{"location":"modules/FITSIO/api/#Base.write-Tuple{FITS, Vector{String}, Vector}","page":"API Reference","title":"Base.write","text":"write(f::FITS, colnames, coldata; hdutype=TableHDU, name=nothing, ver=nothing, header=nothing, units=nothing, varcols=nothing)\n\nSame as write(f::FITS, data::Dict; ...) but providing column names and column data as a separate arrays. This is useful for specifying the order of the columns. Column names must be Vector{String} and column data must be a vector of arrays.\n\n\n\n\n\n","category":"method"},{"location":"modules/FITSIO/api/#Base.read-Tuple{TableHDU, String}","page":"API Reference","title":"Base.read","text":"read(hdu::TableHDU, colname; case_sensitive=true)\n\nRead a column as an array from the given table HDU.\n\nThe column name may contain wild card characters (*, ?, or #). The * wild card character matches any sequence of characters (including zero characters) and the ? character matches any single character. The # wildcard will match any consecutive string of decimal digits (0-9). The string must match a unique column.  The optional boolean keyword case_sensitive, true by default, specifies whether the column name is to be considered case sensitive.\n\nnote: Array order\nJulia arrays are column-major (like Fortran), not row-major (like C and numpy), so elements of multi-dimensional columns will be the transpose of what you get with astropy.\n\n\n\n\n\n","category":"method"},{"location":"highlevels/timecoords/#Time,-Coordinates,-and-Units-Overview","page":"Time, Coordinates, & Units Overview","title":"Time, Coordinates, & Units Overview","text":"","category":"section"},{"location":"highlevels/timecoords/#[AstroAngles.jl](https://github.com/JuliaAstro/AstroAngles.jl)","page":"Time, Coordinates, & Units Overview","title":"AstroAngles.jl","text":"","category":"section"},{"location":"highlevels/timecoords/","page":"Time, Coordinates, & Units Overview","title":"Time, Coordinates, & Units Overview","text":"String parsing and representation of angles","category":"page"},{"location":"highlevels/timecoords/","page":"Time, Coordinates, & Units Overview","title":"Time, Coordinates, & Units Overview","text":"Parse and represent sexagesimal angles with a variety of delimiters\nMethods for converting to hour-minute-second angles from degrees and radians, and vice-versa","category":"page"},{"location":"highlevels/timecoords/#[AstroTime.jl](https://github.com/JuliaAstro/AstroTime.jl)-[![](../assets/book.png)](https://juliaastro.github.io/AstroTime.jl/stable/)","page":"Time, Coordinates, & Units Overview","title":"AstroTime.jl (Image: )","text":"","category":"section"},{"location":"highlevels/timecoords/","page":"Time, Coordinates, & Units Overview","title":"Time, Coordinates, & Units Overview","text":"Astronomical time keeping","category":"page"},{"location":"highlevels/timecoords/","page":"Time, Coordinates, & Units Overview","title":"Time, Coordinates, & Units Overview","text":"High-precision, time-scale aware, DateTime-like data type\nSupport all commonly used astronomical time scales","category":"page"},{"location":"highlevels/timecoords/#[ERFA.jl](https://github.com/JuliaAstro/ERFA.jl)","page":"Time, Coordinates, & Units Overview","title":"ERFA.jl","text":"","category":"section"},{"location":"highlevels/timecoords/","page":"Time, Coordinates, & Units Overview","title":"Time, Coordinates, & Units Overview","text":"Time systems conversions","category":"page"},{"location":"highlevels/timecoords/","page":"Time, Coordinates, & Units Overview","title":"Time, Coordinates, & Units Overview","text":"Low-level wrapper for liberfa","category":"page"},{"location":"highlevels/timecoords/#[SkyCoords.jl](https://github.com/JuliaAstro/SkyCoords.jl)","page":"Time, Coordinates, & Units Overview","title":"SkyCoords.jl","text":"","category":"section"},{"location":"highlevels/timecoords/","page":"Time, Coordinates, & Units Overview","title":"Time, Coordinates, & Units Overview","text":"Astronomical coordinate systems","category":"page"},{"location":"highlevels/timecoords/","page":"Time, Coordinates, & Units Overview","title":"Time, Coordinates, & Units Overview","text":"Supports ICRS, galactic, and FK5 coordinate systems\nFast conversion of coordinates between different systems","category":"page"},{"location":"highlevels/timecoords/#[UnitfulAstro.jl](https://github.com/JuliaAstro/UnitfulAstro.jl)-[![](../assets/book.png)](https://juliaastro.github.io/UnitfulAstro.jl/stable/)","page":"Time, Coordinates, & Units Overview","title":"UnitfulAstro.jl (Image: )","text":"","category":"section"},{"location":"highlevels/timecoords/","page":"Time, Coordinates, & Units Overview","title":"Time, Coordinates, & Units Overview","text":"Astronomical units","category":"page"},{"location":"highlevels/timecoords/","page":"Time, Coordinates, & Units Overview","title":"Time, Coordinates, & Units Overview","text":"Extension of Unitful.jl","category":"page"},{"location":"highlevels/timecoords/#[WCS.jl](https://github.com/JuliaAstro/WCS.jl)-[![](../assets/book.png)](https://juliaastro.github.io/WCS.jl/stable/)","page":"Time, Coordinates, & Units Overview","title":"WCS.jl (Image: )","text":"","category":"section"},{"location":"highlevels/timecoords/","page":"Time, Coordinates, & Units Overview","title":"Time, Coordinates, & Units Overview","text":"World Coordinate System transformations","category":"page"},{"location":"highlevels/timecoords/","page":"Time, Coordinates, & Units Overview","title":"Time, Coordinates, & Units Overview","text":"Wrapper for wcslib","category":"page"},{"location":"modules/AstroAngles/#AstroAngles.jl","page":"AstroAngles","title":"AstroAngles.jl","text":"","category":"section"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"(Image: Build Status) (Image: PkgEval) (Image: Coverage) (Image: License)","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"Lightweight string parsing and representation of angles.","category":"page"},{"location":"modules/AstroAngles/#Installation","page":"AstroAngles","title":"Installation","text":"","category":"section"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"To install use Pkg. From the REPL, press ] to enter Pkg-mode","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"pkg> add AstroAngles","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"If you want to use the most up-to-date version of the code, check it out from main","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"pkg> add AstroAngles#main","category":"page"},{"location":"modules/AstroAngles/#Usage","page":"AstroAngles","title":"Usage","text":"","category":"section"},{"location":"modules/AstroAngles/#Angle-Parsing-Utilities","page":"AstroAngles","title":"Angle Parsing Utilities","text":"","category":"section"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"String representations of angles in both \"degree:arcmin:arcsec\" and  \"hour:min:sec\" format can be parsed using a variety of delimiters, which can be mixed together (e.g. can use ° after degrees but : after the arcminutes). The directions \"S\" and \"W\" are considered negative and \"-1:0:0S\" is 1 degree North, for example.","category":"page"},{"location":"modules/AstroAngles/#dms-formats","page":"AstroAngles","title":"dms formats","text":"","category":"section"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"\"[+-]xx:xx:xx.x[NESW]\"\n\"[+-]xx xx xx.x[NESW]\"\n\"[+-]xxdxxmxx.xs[NESW]\"\n\"[+-]xx°xx'xx.x\\\"[NESW]\"\n\"[+-]xx°xx′xx.x″[NESW]\" # \\prime, \\pprime","category":"page"},{"location":"modules/AstroAngles/#hms-formats","page":"AstroAngles","title":"hms formats","text":"","category":"section"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"\"[+-]xx:xx:xx.x[NESW]\"\n\"[+-]xx xx xx.x[NESW]\"\n\"[+-]xxhxxmxx.xs[NESW]\"\n\"[+-]xxhxx'xx.x\\\"[NESW]\"\n\"[+-]xx°xx′xx.x″[NESW]\"","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"the simplest way to convert is to use the @dms_str and @hms_str macros, which allows you to choose the output angle type","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"julia> dms\"12:17:25.3\"\n0.21450726764795752\n\njulia> dms\"12:17:25.3\"rad # default\n0.21450726764795752\n\njulia> dms\"12:17:25.3\"deg\n12.29036111111111\n\njulia> dms\"12:17:25.3\"ha\n0.8193574074074074","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"here is a showcase of the variety of ways to parse inputs","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"julia> dms\"10.2345d\"deg\n10.2345\n\njulia> dms\"1:2:30.43\"deg\n1.041786111111111\n\njulia> hms\"1 2 0\"ha\n1.0333333333333334\n\njulia> dms\"1°2′3″\"deg\n1.0341666666666667\n\njulia> dms\"1°2′3″N\"deg\n1.0341666666666667\n\njulia> dms\"1d2m3.4s\"deg\n1.0342777777777779\n\njulia> dms\"1d2m3.4sS\"deg\n-1.0342777777777779\n\njulia> hms\"-1h2m3s\"ha\n-1.0341666666666667\n\njulia> hms\"-1h2m3sW\"ha\n1.0341666666666667","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"for more control on the output, you can use the parse_dms and parse_hms methods, which returns a tuple of the parsed dms or hms values","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"parse_dms # string -> (deg, arcmin, arcsec)\nparse_hms # string -> (hours, mins, secs)","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"julia> parse_dms(\"12:17:25.3\")\n(12.0, 17.0, 25.3)\n\njulia> parse_hms(\"-4:4:6\")\n(-4.0, 4.0, 6.0)","category":"page"},{"location":"modules/AstroAngles/#Angle-Conversion-Utilities","page":"AstroAngles","title":"Angle Conversion Utilities","text":"","category":"section"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"The following methods are added for converting to and from hour angles","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"deg2ha # degrees -> hour angles\nrad2ha # radians -> hour angles\nha2deg # hour angles -> degrees\nha2rad # hour angles -> radians","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"The following methods convert from angles as a single number to tuples consistent with sexagesimal","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"deg2dms # degrees -> (deg, arcmin, arcsec)\nrad2dms # radians -> (deg, arcmin, arcsec)\nha2dms  # hour angles -> (deg, arcmin, arcsec)\n\ndeg2hms # degrees -> (hours, mins, secs)\nrad2hms # radians -> (hours, mins, secs)\nha2hms  # hour angles -> (hours, mins, secs)","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"and the inverse","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"dms2deg # (deg, arcmin, arcsec) -> degrees\ndms2rad # (deg, arcmin, arcsec) -> radians\ndms2ha  # (deg, arcmin, arcsec) -> hour angles\n\nhms2deg # (hours, mins, secs) -> degrees\nhms2rad # (hours, mins, secs) -> radians\nhms2ha  # (hours, mins, secs) -> hour angles","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"the above functions can take a string as input and will automatically parse it (using parse_dms or parse_hms, respectively) before converting.","category":"page"},{"location":"modules/AstroAngles/#Formatting-angles","page":"AstroAngles","title":"Formatting angles","text":"","category":"section"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"Lastly, we have some simple methods for formatting angles into strings, although for more fine-tuned control we recommend using Printf or a package like Formatting.jl. format_angle takes parts (like from deg2dms or rad2hms) and a delimiter (or collection of 3 delimiters for each value).","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"julia> format_angle(deg2dms(45.0))\n\"45:0:0.0\"\n\njulia> format_angle(deg2hms(-65.0); delim=[\"h\", \"m\", \"s\"])\n\"-4h19m59.999999999998934s\"","category":"page"},{"location":"modules/AstroAngles/#Example:-reading-coordinates-from-a-table","page":"AstroAngles","title":"Example: reading coordinates from a table","text":"","category":"section"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"Here's an example of reading sky coordinates from a CSV formatted target list and converting them to degrees-","category":"page"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"julia> using AstroAngles, CSV, DataFrames\n\njulia> table = CSV.File(\"target_list.csv\") |> DataFrame;\n\njulia> [table.ra table.dec]\n203×2 Matrix{String}:\n \"00 05 01.42\"  \"40 03 35.82\"\n \"00 05 07.52\"  \"73 13 11.34\"\n \"00 36 01.40\"  \"-11 12 13.00\"\n[...]\n\njulia> ra_d = @. hms2deg(table.ra)\n203-element Vector{Float64}:\n   1.2559166666666666\n   1.2813333333333332\n   9.005833333333333\n[...]\n\njulia> dec_d = @. dms2deg(table.dec)\n203-element Vector{Float64}:\n  40.05995\n  73.21981666666667\n -11.203611111111112\n[...]","category":"page"},{"location":"modules/AstroAngles/#Contributing/Support","page":"AstroAngles","title":"Contributing/Support","text":"","category":"section"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"To contribute, feel free to open a pull request. If you run into problems, please open an issue. To discuss ideas, usage, or to plan contributions, open a new discussion.","category":"page"},{"location":"modules/AstroAngles/#License","page":"AstroAngles","title":"License","text":"","category":"section"},{"location":"modules/AstroAngles/","page":"AstroAngles","title":"AstroAngles","text":"This code is MIT licensed. For more information, see LICENSE.","category":"page"},{"location":"highlevels/dataio/#Data-I/O-Overview","page":"Data I/O Overview","title":"Data I/O Overview","text":"","category":"section"},{"location":"highlevels/dataio/#Data-I/O","page":"Data I/O Overview","title":"Data I/O","text":"","category":"section"},{"location":"highlevels/dataio/#[AstroImages.jl](https://github.com/JuliaAstro/AstroImages.jl)-[![](../assets/book.png)](https://juliaastro.github.io/AstroImages.jl/stable/)","page":"Data I/O Overview","title":"AstroImages.jl (Image: )","text":"","category":"section"},{"location":"highlevels/dataio/","page":"Data I/O Overview","title":"Data I/O Overview","text":"Load, manipulate, and visualize astronomical images","category":"page"},{"location":"highlevels/dataio/","page":"Data I/O Overview","title":"Data I/O Overview","text":"Works with the FileIO.jl interface","category":"page"},{"location":"highlevels/dataio/#[FITSIO.jl](https://github.com/JuliaAstro/FITSIO.jl)-[![](../assets/book.png)](https://juliaastro.github.io/FITSIO.jl/stable/)","page":"Data I/O Overview","title":"FITSIO.jl (Image: )","text":"","category":"section"},{"location":"highlevels/dataio/","page":"Data I/O Overview","title":"Data I/O Overview","text":"Reading and writing FITS files","category":"page"},{"location":"highlevels/dataio/","page":"Data I/O Overview","title":"Data I/O Overview","text":"Interact with header data units (HDUs), FITS headers, and FITS data: both images and tables\nFITS tables follow the Tables.jl interface, allowing seamless integration with the rich data ecosystem, like CSV.jl, DataFrames.jl, etc.","category":"page"},{"location":"highlevels/dataio/#[CFITSIO.jl](https://github.com/JuliaAstro/CFITSIO.jl)-[![](../assets/book.png)](https://juliaastro.github.io/FITSIO.jl/stable/)","page":"Data I/O Overview","title":"CFITSIO.jl (Image: )","text":"","category":"section"},{"location":"highlevels/dataio/","page":"Data I/O Overview","title":"Data I/O Overview","text":"Reading and writing FITS files","category":"page"},{"location":"highlevels/dataio/","page":"Data I/O Overview","title":"Data I/O Overview","text":"Low-level wrapper for cfitsio\nThe c interface can be directly accessed with the CFITSIO_jll package","category":"page"},{"location":"highlevels/dataio/#[mweastwood/CasaCore.jl](https://github.com/mweastwood/CasaCore.jl)-[![](../assets/book.png)](http://mweastwood.info/CasaCore.jl/stable/)","page":"Data I/O Overview","title":"mweastwood/CasaCore.jl (Image: )","text":"","category":"section"},{"location":"highlevels/dataio/","page":"Data I/O Overview","title":"Data I/O Overview","text":"Tables and measurement sets for radio astronomy","category":"page"},{"location":"highlevels/dataio/","page":"Data I/O Overview","title":"Data I/O Overview","text":"Wrapper for CasaCore\nInterface for CASA tables and measures","category":"page"},{"location":"highlevels/dataio/#[emmt/OIFITS.jl](https://github.com/emmt/OIFITS.jl)","page":"Data I/O Overview","title":"emmt/OIFITS.jl","text":"","category":"section"},{"location":"highlevels/dataio/","page":"Data I/O Overview","title":"Data I/O Overview","text":"Support for OI-FITS","category":"page"},{"location":"highlevels/dataio/","page":"Data I/O Overview","title":"Data I/O Overview","text":"Read and write OI-FITS optical interferometry data format","category":"page"},{"location":"highlevels/dataio/#[aplavin/VLBIData.jl](https://gitlab.com/aplavin/VLBIData.jl)-[![](../assets/book.png)](https://aplavin.github.io/VLBIData.jl/test/examples.html)","page":"Data I/O Overview","title":"aplavin/VLBIData.jl (Image: )","text":"","category":"section"},{"location":"highlevels/dataio/","page":"Data I/O Overview","title":"Data I/O Overview","text":"Work with data formats common in very long baseline interferometry (VLBI)","category":"page"},{"location":"highlevels/dataio/","page":"Data I/O Overview","title":"Data I/O Overview","text":"Read interferometric visibilities (uvfits), images (fits), and source models\nMinimal writing support for source models","category":"page"},{"location":"highlevels/dataio/#[aplavin/Difmap.jl](https://gitlab.com/aplavin/Difmap.jl)","page":"Data I/O Overview","title":"aplavin/Difmap.jl","text":"","category":"section"},{"location":"highlevels/dataio/","page":"Data I/O Overview","title":"Data I/O Overview","text":"Wrapper for the Difmap program used in synthesis imaging","category":"page"},{"location":"highlevels/dataio/","page":"Data I/O Overview","title":"Data I/O Overview","text":"Execute Difmap scripts, handle inputs/outputs and logs\nDisplay images and plots from Difmap in interactive Julia environments","category":"page"},{"location":"modules/LombScargle/#LombScargle.jl","page":"Home","title":"LombScargle.jl","text":"","category":"section"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"DocTestSetup = quote\n    using LombScargle\nend","category":"page"},{"location":"modules/LombScargle/#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"LombScargle.jl is a package for a fast multi-threaded estimation of the frequency spectrum of a periodic signal with the Lomb–Scargle periodogram.  This is written in Julia, a modern high-level, high-performance dynamic programming language designed for technical computing.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"Another Julia package that provides tools to perform spectral analysis of signals is DSP.jl, but its methods require that the signal has been sampled at equally spaced times. Instead, the Lomb–Scargle periodogram enables you to analyze unevenly sampled data as well, which is a fairly common case in astronomy, a field where this periodogram is widely used.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"The algorithms used in this package are reported in the following papers:","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"[PR89] Press, W. H., Rybicki, G. B. 1989, ApJ, 338, 277 (URL: http://dx.doi.org/10.1086/167197, Bibcode: http://adsabs.harvard.edu/abs/1989ApJ...338..277P)\n[TOW10] Townsend, R. H. D. 2010, ApJS, 191, 247 (URL: http://dx.doi.org/10.1088/0067-0049/191/2/247, Bibcode: http://adsabs.harvard.edu/abs/2010ApJS..191..247T)\n[ZK09] Zechmeister, M., Kürster, M. 2009, A&A, 496, 577 (URL: http://dx.doi.org/10.1051/0004-6361:200811296, Bibcode: http://adsabs.harvard.edu/abs/2009A%26A...496..577Z)","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"Other relevant papers are:","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"[CMB99] Cumming, A., Marcy, G. W., & Butler, R. P. 1999, ApJ, 526, 890 (URL: http://dx.doi.org/10.1086/308020, Bibcode: http://adsabs.harvard.edu/abs/1999ApJ...526..890C)\n[CUM04] Cumming, A. 2004, MNRAS, 354, 1165 (URL: http://dx.doi.org/10.1111/j.1365-2966.2004.08275.x, Bibcode: http://adsabs.harvard.edu/abs/2004MNRAS.354.1165C)\n[HB86] Horne, J. H., & Baliunas, S. L. 1986, ApJ, 302, 757 (URL: http://dx.doi.org/10.1086/164037, Bibcode: http://adsabs.harvard.edu/abs/1986ApJ...302..757H)\n[LOM76] Lomb, N. R. 1976, Ap&SS, 39, 447 (URL: http://dx.doi.org/10.1007/BF00648343, Bibcode: http://adsabs.harvard.edu/abs/1976Ap%26SS..39..447L)\n[MHC93] Murdoch, K. A., Hearnshaw, J. B., & Clark, M. 1993, ApJ, 413, 349 (URL: http://dx.doi.org/10.1086/173003, Bibcode: http://adsabs.harvard.edu/abs/1993ApJ...413..349M)\n[SCA82] Scargle, J. D. 1982, ApJ, 263, 835 (URL: http://dx.doi.org/10.1086/160554, Bibcode: http://adsabs.harvard.edu/abs/1982ApJ...263..835S)\n[SS10] Sturrock, P. A., & Scargle, J. D. 2010, ApJ, 718, 527 (URL: http://dx.doi.org/10.1088/0004-637X/718/1/527, Bibcode: http://adsabs.harvard.edu/abs/2010ApJ...718..527S)","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"The package provides facilities to:","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"compute the periodogram using different methods (with different speeds) and different normalizations. This is one of the fastest implementations of these methods available as free software. If Julia is run with more than one thread, computation is automatically multi-threaded, further speeding up calculations;\naccess the frequency and period grid of the resulting periodogram, together with the power spectrum;\nfind the maximum power in the periodogram and the frequency and period corresponding to the peak. All these queries can be restricted to a specified region, in order to search a local maximum, instead of the global one;\ncalculate the probability that a peak arises from noise only (false-alarm probability) using analytic formulas, in order to assess the significance of the peak;\nperform bootstrap resamplings in order to compute the false-alarm probability with a statistical method;\ndetermine the best-fitting Lomb–Scargle model for the given data set at the given frequency.","category":"page"},{"location":"modules/LombScargle/#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"LombScargle.jl is available for Julia 0.7 and later versions, and can be installed with Julia's built-in package manager. In a Julia session run the commands","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"julia> using Pkg\njulia> Pkg.update()\njulia> Pkg.add(\"LombScargle\")","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"Older versions are also available for Julia 0.4-0.6.","category":"page"},{"location":"modules/LombScargle/#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"After installing the package, you can start using it with","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"using LombScargle","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"The module defines a new LombScargle.Periodogram data type, which, however, is not exported because you will most probably not need to directly manipulate such objects. This data type holds both the frequency and the power vectors of the periodogram.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"The main function provided by the package is lombscargle:","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"lombscargle(::AbstractVector{<:Real}, rest...)","category":"page"},{"location":"modules/LombScargle/#LombScargle.lombscargle-Tuple{AbstractVector{<:Real}, Vararg{Any}}","page":"Home","title":"LombScargle.lombscargle","text":"lombscargle(times::AbstractVector{<:Real}, signal::AbstractVector{<:Real},\n            [errors::AbstractVector{<:Real}]; keywords...)\n\nCompute the Lomb–Scargle periodogram of the signal vector, observed at times.  You can also specify the uncertainties for each signal point with errors argument.  All these vectors must have the same length.\n\nAll optional keywords are described in the docstring of LombScargle.plan.\n\nIf the signal has uncertainties, the signal vector can also be a vector of Measurement objects (from Measurements.jl package), in which case you don’t need to pass a separate errors vector for the uncertainties of the signal.\n\n\n\n\n\n","category":"method"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"lombscargle returns a LombScargle.Periodogram. The only two mandatory arguments are:","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"times: the vector of observation times\nsignal: the vector of observations associated with times","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"The optional argument is:","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"errors: the uncertainties associated to each signal point.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"All these vectors must have the same length.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"tip: Tip\nYou can pre-plan a periodogram with LombScargle.plan function, which has the same syntax as lombscargle described in this section. In this way the actual computation of the periodogram is faster and you will save memory. See the Planning the Periodogram section below.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"tip: Tip\nLombScargle.jl exploits Julia's native multi-threading for the non-fast methods (the methods used when you set the keyword fast=false). Run Julia with n threads (e.g., JULIA_NUM_THREADS=4 julia for 4 threads, if your machine has 4 physical cores) in order to automatically gain an n -fold scaling.Please note that multi-threading is still an experimental feature in Julia, so you may encounter issues when running it with more than one thread. For example, bug #17395 (if still open) may prevent the function, on some systems, from effectively scaling.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"If the signal has uncertainties, the signal vector can also be a vector of Measurement objects (from Measurements.jl package), in which case you need not to pass a separate errors vector for the uncertainties of the signal. You can create arrays of Measurement objects with the measurement function, see Measurements.jl manual at https://juliaphysics.github.io/Measurements.jl/stable for more details. The generalised Lomb–Scargle periodogram by [ZK09] is always used when the signal has uncertainties, because the original Lomb–Scargle algorithm cannot handle them.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"tip: Tip\nThe uncertainties are only used in the generalised Lomb–Scargle algorithm to build an inverse-variance weights vector (see [ZK09]), that gives more importance to datapoints with lower uncertainties. The case where all measurements have the same uncertainty (a condition known as homoskedasticity) results in a constant weights vector, like if there are no uncertainties at all. If you have homoskedastic errors, you do not need to provide them to lombscargle.","category":"page"},{"location":"modules/LombScargle/#Planning-the-Periodogram","page":"Home","title":"Planning the Periodogram","text":"","category":"section"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"In a manner similar to planning Fourier transforms with FFTW, it is possible to speed-up computation of the Lomb–Scargle periodogram by pre-planning it with LombScargle.plan function. It has the same syntax as lombscargle, which in the base case is:","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"LombScargle.plan\nLombScargle.autofrequency","category":"page"},{"location":"modules/LombScargle/#LombScargle.plan","page":"Home","title":"LombScargle.plan","text":"LombScargle.plan(times::AbstractVector{<:Real}, signal::AbstractVector{<:Real},\n                 [errors::AbstractVector{<:Real}];\n                 normalization::Symbol=:standard,\n                 noise_level::Real=1,\n                 center_data::Bool=true,\n                 fit_mean::Bool=true,\n                 fast::Bool=true,\n                 flags::Integer=FFTW.ESTIMATE,\n                 timelimit::Real=Inf,\n                 oversampling::Integer=5,\n                 padding_factors::Vector{Int}=[2],\n                 Mfft::Integer=4,\n                 samples_per_peak::Integer=5,\n                 nyquist_factor::Integer=5,\n                 minimum_frequency::Real=NaN,\n                 maximum_frequency::Real=NaN,\n                 frequencies::AbstractVector{Real}=\n                 autofrequency(times,\n                               samples_per_peak=samples_per_peak,\n                               nyquist_factor=nyquist_factor,\n                               minimum_frequency=minimum_frequency,\n                               maximum_frequency=maximum_frequency))\n\nPre-plan the Lomb–Scargle periodogram of the signal vector, observed at times.  The periodogram can then be computed by passing the result of this function to lombscargle.\n\nYou can also specify the uncertainties for each signal point with errors argument.  All these vectors must have the same length.\n\nOptional keywords arguments are:\n\nnormalization: how to normalize the periodogram.  Valid choices are: :standard, :model, :log, :psd, :Scargle, :HorneBaliunas, :Cumming\nnoise_level: the noise level used to normalize the periodogram when normalization is set to :Scargle\nfit_mean: if true, fit for the mean of the signal using the Generalised Lomb–Scargle algorithm (see Zechmeister & Kürster paper below).  If this is false and no uncertainty on the signal is provided, the original algorithm by Lomb and Scargle will be employed (see Townsend paper below)\ncenter_data: if true, subtract the weighted mean of signal from signal itself before performing the periodogram.  This is especially important if fit_mean is false\nfrequencies: the frequecy grid (not angular frequencies) at which the periodogram will be computed, as a vector.  If not provided, it is an evenly spaced grid of type Range, automatically determined with LombScargle.autofrequency function, which see.  See below for other available keywords that can be used to affect the frequency grid without directly setting frequencies\n\nYou can explicitely require to use or not the fast method by Press & Rybicki, overriding the default choice, by setting the fast keyword.  In any case, frequencies must be a Range object (this is the default) in order to actually use this method.  A few other keywords are available to adjust the settings of the periodogram when the fast method is used (otherwise they are ignored):\n\nfast: whether to use the fast method.\nflags: this integer keyword is a bitwise-or of FFTW planner flags, defaulting to FFTW.ESTIMATE.  Passing FFTW.MEASURE or FFTW.PATIENT will instead spend several seconds (or more) benchmarking different possible FFT algorithms and picking the fastest one; see the FFTW manual for more information on planner flags.\ntimelimit: specifies a rough upper bound on the allowed planning time, in seconds.\noversampling: oversampling the frequency factor for the approximation; roughly the number of time samples across the highest-frequency sinusoid. This parameter contains the tradeoff between accuracy and speed.\npadding_factors: the FFT is performed on a vector with length equal to the smallest number larger than or equal to N * oversampling which is a product of all numbers in this vector.  E.g., use padding_factors=[2] to perform the FFT on a vector padded to a power of 2, or padding_factors=[2, 3, 5, 7] for the optimal size for the FFTW library.\nMfft: the number of adjacent points to use in the FFT approximation.\n\nIn addition, you can use all optional keyword arguments of LombScargle.autofrequency function in order to tune the frequencies.\n\nIf the signal has uncertainties, the signal vector can also be a vector of Measurement objects (from Measurements.jl package), in which case you don’t need to pass a separate errors vector for the uncertainties of the signal.\n\n\n\n\n\n","category":"function"},{"location":"modules/LombScargle/#LombScargle.autofrequency","page":"Home","title":"LombScargle.autofrequency","text":"autofrequency(times::AbstractVector{Real};\n              samples_per_peak::Integer=5,\n              nyquist_factor::Integer=5,\n              minimum_frequency::Real=NaN,\n              maximum_frequency::Real=NaN)\n\nDetermine a suitable frequency grid for the given vector of times.\n\nOptional keyword arguments are:\n\nsamples_per_peak: the approximate number of desired samples across the typical peak\nnyquist_factor: the multiple of the average Nyquist frequency used to choose the maximum frequency if maximum_frequency is not provided\nminimum_frequency: if specified, then use this minimum frequency rather than one chosen based on the size of the baseline\nmaximum_frequency: if specified, then use this maximum frequency rather than one chosen based on the average Nyquist frequency\n\nThis is based on prescription given at https://jakevdp.github.io/blog/2015/06/13/lomb-scargle-in-python/ and uses the same keywords names adopted in Astropy.\n\n\n\n\n\n","category":"function"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"LombScargle.plan takes all the same argument as lombscargle shown above and returns a LombScargle.PeriodogramPlan object after having pre-computed certain quantities needed afterwards, and pre-allocated the memory for the periodogram. It is highly suggested to plan a periodogram before actually computing it, especially for the fast method. Once you plan a periodogram, you can pass the LombScargle.PeriodogramPlan to lombscargle as the only argument.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"lombscargle(::LombScargle.PeriodogramPlan)","category":"page"},{"location":"modules/LombScargle/#LombScargle.lombscargle-Tuple{LombScargle.PeriodogramPlan}","page":"Home","title":"LombScargle.lombscargle","text":"lombscargle(plan::PeriodogramPlan)\n\nCompute the Lomb–Scargle periodogram for the given plan.  This method has no other arguments.  See documentation of LombScargle.plan for how to plan a Lomb–Scargle periodogram.\n\n\n\n\n\n","category":"method"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"Planning the periodogram has a twofold advantage. First of all, the planning stage is type-unstable, because the type of the plan depends on the value of input parameters, and not on their types. Thus, separating the planning (inherently inefficient) from the actual computation of the periodogram (completely type-stable) makes overall computation faster than directly calling lombscargle. Secondly, the LombScargle.PeriodogramPlan bears the time vector, but the quantities that are pre-computed in planning stage do not actually depend on it. This is particularly useful if you want to calculate the False-Alarm Probability via bootstrapping with LombScargle.bootstrap: the vector time is randomly shuffled, but pre-computed quantities will remain the same, saving both time and memory in each iteration. In addition, you ensure that you will use the same options you used to compute the periodogram.","category":"page"},{"location":"modules/LombScargle/#Fast-Algorithm","page":"Home","title":"Fast Algorithm","text":"","category":"section"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"When the frequency grid is evenly spaced, you can compute an approximate generalised Lomb–Scargle periodogram using a fast algorithm proposed by [PR89] that greatly speeds up calculations, as it scales as ON log(M) for N data points and M frequencies. For comparison, the true Lomb–Scargle periodogram has complexity ONM.  The larger the number of datapoints, the more accurate the approximation.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"note: Note\nThis method internally performs a Fast Fourier Transform (FFT) to compute some quantities, but it is in no way equivalent to conventional Fourier periodogram analysis.LombScargle.jl uses FFTW functions to compute the FFT. You can speed-up this task by using multi-threading: call FFTW.set_num_threads(n) to use n threads. However, please note that the running time will not scale as n because computation of the FFT is only a part of the algorithm.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"The only prerequisite in order to be able to employ this fast method is to provide a frequencies vector as an AbstractRange object, which ensures that the frequency grid is perfectly evenly spaced. This is the default, since LombScargle.autofrequency returns an AbstractRange object.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"tip: Tip\nIn Julia, an AbstractRange object can be constructed for example with the range function (you specify the start of the range, and optionally the stop, the length and the step of the vector) or with the syntax start:[step:]stop (you specify the start and the end of the range, and optionally the linear step).","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"Since this fast method is accurate only for large datasets, it is enabled by default only if the number of output frequencies is larger than 200. You can override the default choice of using this method by setting the fast keyword to true or false. We recall that in any case, the frequencies vector must be a Range in order to use this method.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"To summarize, provided that frequencies vector is an AbstractRange object, you can use the fast method:","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"by default if the length of the output frequency grid is larger than 200 points\nin any case with the fast=true keyword","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"Setting fast=false always ensures you that this method will not be used, instead fast=true actually enables it only if frequencies is an AbstractRange.","category":"page"},{"location":"modules/LombScargle/#Normalization","page":"Home","title":"Normalization","text":"","category":"section"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"By default, the periodogram p(f) is normalized so that it has values in the range 0 leq p(f) leq 1, with p = 0 indicating no improvement of the fit and p = 1 a \"perfect\" fit (100% reduction of chi^2 or chi^2 = 0). This is the normalization suggested by [LOM76] and [ZK09], and corresponds to the :standard normalization in lombscargle function. [ZK09] wrote the formula for the power of the periodogram at frequency f as","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"p(f) = frac1YYleftfracYC^2_tauCC_tau +\nfracYS^2_tauSS_tauright","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"See the paper for details. The other normalizations for periodograms P(f) are calculated from this one. In what follows, N is the number of observations.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":":model:\nP(f) = fracp(f)1 - p(f)\n:log:\nP(f) = -log(1 - p(f))\n:psd:\nP(f) = fracW2leftfracYC^2_tauCC_tau +\nfracYS^2_tauSS_tauright = p(f) fracW*YY2\nwhere W is the sum of the inverse of the individual errors, W = sum frac1sigma_i, as given in [ZK09].\n:Scargle:\nP(f) = fracp(f)textnoise level\nThis normalization can be used when you know the noise level (expected from the a priori known noise variance or population variance), but this isn't usually the case. See [SCA82]\n:HorneBaliunas:\nP(f) = fracN - 12 p(f)\nThis is like the :Scargle normalization, where the noise has been estimated for Gaussian noise to be (N - 1)2. See [HB86]\nIf the data contains a signal or if errors are under- or overestimated or if intrinsic variability is present, then (N-1)2 may not be a good uncorrelated estimator for the noise level.  [CMB99] suggested to estimate the noise level a posteriori with the residuals of the best fit and normalised the periodogram as:\nP(f) = fracN - 32 fracp(f)1 - p(f_textbest)\nThis is the :Cumming normalization option","category":"page"},{"location":"modules/LombScargle/#Access-Frequency-Grid-and-Power-Spectrum-of-the-Periodogram","page":"Home","title":"Access Frequency Grid and Power Spectrum of the Periodogram","text":"","category":"section"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"lombscargle returns a LombScargle.Periodogram object, but you most probably want to use the frequency grid and the power spectrum. You can access these vectors with freq and power functions, just like in DSP.jl package. If you want to get the 2-tuple (freq(p), power(p)) use the freqpower function.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"power\nfreq\nfreqpower","category":"page"},{"location":"modules/LombScargle/#LombScargle.power","page":"Home","title":"LombScargle.power","text":"power(p::Periodogram)\n\nReturn the power vector of Lomb–Scargle periodogram p.\n\n\n\n\n\n","category":"function"},{"location":"modules/LombScargle/#LombScargle.freq","page":"Home","title":"LombScargle.freq","text":"freq(p::Periodogram)\n\nReturn the frequency vector of Lomb–Scargle periodogram p.\n\n\n\n\n\n","category":"function"},{"location":"modules/LombScargle/#LombScargle.freqpower","page":"Home","title":"LombScargle.freqpower","text":"freqpower(p::Periodogram)\n\nReturn the 2-tuple (freq(p), power(p)), where freq(p) and power(p) are the frequency vector and the power vector of Lomb–Scargle periodogram p respectively.\n\n\n\n\n\n","category":"function"},{"location":"modules/LombScargle/#Access-Period-Grid","page":"Home","title":"Access Period Grid","text":"","category":"section"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"The following utilities are the analogs of freq and freqpower, but relative to the periods instead of the frequencies. Thus period(p) returns the vector of periods in the periodogram, that is 1./freq(p), and periodpower(p) gives you the 2-tuple (period(p), power(p)).","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"period\nperiodpower","category":"page"},{"location":"modules/LombScargle/#LombScargle.period","page":"Home","title":"LombScargle.period","text":"period(p::Periodogram)\n\nReturn the period vector of Lomb–Scargle periodogram p.  It is equal to 1 ./ freq(p).\n\n\n\n\n\n","category":"function"},{"location":"modules/LombScargle/#LombScargle.periodpower","page":"Home","title":"LombScargle.periodpower","text":"periodpower(p::Periodogram)\n\nReturn the 2-tuple (period(p), power(p)), where period(p) and power(p) are the period vector and the power vector of Lomb–Scargle periodogram p respectively.\n\n\n\n\n\n","category":"function"},{"location":"modules/LombScargle/#findmaxpower,-findmaxfreq,-and-findmaxperiod-Functions","page":"Home","title":"findmaxpower, findmaxfreq, and findmaxperiod Functions","text":"","category":"section"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"Once you compute the periodogram, you usually want to know which are the frequencies or periods with highest power. To do this, you can use the findmaxfreq and findmaxperiod functions.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"findmaxpower\nfindmaxfreq\nfindmaxperiod","category":"page"},{"location":"modules/LombScargle/#LombScargle.findmaxpower","page":"Home","title":"LombScargle.findmaxpower","text":"findmaxpower(p::Periodogram)\n\nReturn the highest power of the periodogram p.\n\n\n\n\n\n","category":"function"},{"location":"modules/LombScargle/#LombScargle.findmaxfreq","page":"Home","title":"LombScargle.findmaxfreq","text":"findmaxfreq(p::Periodogram, [interval::AbstractVector{Real}], threshold::Real=findmaxpower(p))\n\nReturn the array of frequencies with the highest power in the periodogram p. If a scalar real argument threshold is provided, return the frequencies with power larger than or equal to threshold.  If you want to limit the search to a narrower frequency range, pass as second argument a vector with the extrema of the interval.\n\n\n\n\n\n","category":"function"},{"location":"modules/LombScargle/#LombScargle.findmaxperiod","page":"Home","title":"LombScargle.findmaxperiod","text":"findmaxperiod(p::Periodogram, [interval::AbstractVector{Real}], threshold::Real=findmaxpower(p))\n\nReturn the array of periods with the highest power in the periodogram p.  If a scalar real argument threshold is provided, return the period with power larger than or equal to threshold.  If you want to limit the search to a narrower period range, pass as second argument a vector with the extrema of the interval.\n\n\n\n\n\n","category":"function"},{"location":"modules/LombScargle/#False-Alarm-Probability","page":"Home","title":"False-Alarm Probability","text":"","category":"section"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"Noise in the data produce fluctuations in the periodogram that will present several local peaks, but not all of them related to real periodicities. The significance of the peaks can be tested by calculating the probability that its power can arise purely from noise.  The higher the value of the power, the lower will be this probability.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"note: Note\n[CMB99] showed that the different normalizations result in different probability functions. LombScargle.jl can calculate the probability (and the false-alarm probability) only for the normalizations reported by [ZK09], that are :standard, :Scargle, :HorneBaliunas, and :Cumming.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"The probability textProb(p  p_0) that the periodogram power p can exceed the value p_0 can be calculated with the prob function, whose first argument is the periodogram and the second one is the p_0 value. The function probinv is its inverse: it takes the probability as second argument and returns the corresponding p_0 value.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"prob(::LombScargle.Periodogram, ::Real)\nprobinv(::LombScargle.Periodogram, ::Real)\nLombScargle.M\nfap(::LombScargle.Periodogram, ::Real)\nfapinv(::LombScargle.Periodogram, ::Real)","category":"page"},{"location":"modules/LombScargle/#LombScargle.prob-Tuple{LombScargle.Periodogram, Real}","page":"Home","title":"LombScargle.prob","text":"prob(P::Periodogram, pow::Real)\n\nReturn the probability that the periodogram power can exceed the value pow.\n\nIts inverse is the probinv function.\n\n\n\n\n\n","category":"method"},{"location":"modules/LombScargle/#LombScargle.probinv-Tuple{LombScargle.Periodogram, Real}","page":"Home","title":"LombScargle.probinv","text":"probinv(P::Periodogram, prob::Real)\n\nReturn the power value of the periodogram power whose probability is prob.\n\nThis is the inverse of prob function.\n\n\n\n\n\n","category":"method"},{"location":"modules/LombScargle/#LombScargle.M","page":"Home","title":"LombScargle.M","text":"LombScargle.M(P::Periodogram)\n\nEstimates the number of independent frequencies in the periodogram P.\n\n\n\n\n\n","category":"function"},{"location":"modules/LombScargle/#LombScargle.fap-Tuple{LombScargle.Periodogram, Real}","page":"Home","title":"LombScargle.fap","text":"fap(P::Periodogram, pow::Real)\n\nReturn the false-alarm probability for periodogram P and power value pow.\n\nIts inverse is the fapinv function.\n\n\n\n\n\n","category":"method"},{"location":"modules/LombScargle/#LombScargle.fapinv-Tuple{LombScargle.Periodogram, Real}","page":"Home","title":"LombScargle.fapinv","text":"fapinv(P::Periodogram, prob::Real)\n\nReturn the power value of the periodogram whose false-alarm probability is prob.\n\nThis is the inverse of fap function.\n\n\n\n\n\n","category":"method"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"Here are the probability functions for each normalization supported by LombScargle.jl:","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":":standard (p in 0 1):\ntextProb(p  p_0) = (1 - p_0)^(N - 3)2\n:Scargle (p in 0 infty)):\ntextProb(p  p_0) = exp(-p_0)\n:HorneBaliunas (p in 0 (N - 1)2):\ntextProb(p  p_0) = left(1 - frac2p_0N - 1right)^(N - 3)2\n:Cumming (p in 0 infty)):\ntextProb(p  p_0) = left(1 + frac2p_0N - 3right)^-(N - 3)2","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"As explained by [SS10], «the term \"false-alarm probability denotes the probability that at least one out of M independent power values in a prescribed search band of a power spectrum computed from a white-noise time series is expected to be as large as or larger than a given value». LombScargle.jl provides the fap function to calculate the false-alarm probability (FAP) of a given power in a periodogram. Its first argument is the periodogram, the second one is the value p_0 of the power of which you want to calculate the FAP. The function fap uses the formula","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"textFAP = 1 - (1 - textProb(p  p_0))^M","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"where M is the number of independent frequencies estimated with M = T cdot Delta f, being T the duration of the observations and Delta f the width of the frequency range in which the periodogram has been calculated (see [CUM04]). The function fapinv is the inverse of fap: it takes as second argument the value of the FAP and returns the corresponding value p_0 of the power.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"The detection threshold p_0 is the periodogram power corresponding to some (small) value of textFAP, i.e. the value of p exceeded due to noise alone in only a small fraction textFAP of trials. An observed power larger than p_0 indicates that a signal is likely present (see [CUM04]).","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"warning: Warning\nSome authors stressed that this method to calculate the false-alarm probability is not completely reliable. A different approach to calculate the false-alarm probability is to perform Monte Carlo or bootstrap simulations in order to determine how often a certain power level p_0 is exceeded just by chance (see [CMB99], [CUM04], and [ZK09]). See the Bootstrapping section.","category":"page"},{"location":"modules/LombScargle/#Bootstrapping","page":"Home","title":"Bootstrapping","text":"","category":"section"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"One of the possible and simplest statistical methods that you can use to measure the false-alarm probability and its inverse is bootstrapping (see section 4.2.2 of [MHC93]).","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"note: Note\nWe emphasize that you can use this method only if you know your data points are independent and identically distributed, and they have white uncorrelated noise.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"The recipe of the bootstrap method is very simple to implement:","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"repeat the Lomb–Scargle analysis a large number N of times on the original data, but with the signal (and errors, if present) vector randomly shuffled. As an alternative, shuffle only the time vector;\nout of all these simulations, store the powers of the highest peaks;\nin order to estimate the false-alarm probability of a given power, count how many times the highest peak of the simulations exceeds that power, as a fraction of N. If you instead want to find the inverse of the false-alarm probability textprob, looks for the Ncdottextprob-th element of the highest peaks vector sorted in descending order.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"Remember to pass to lombscargle function the same options, if any, you used to compute the Lomb–Scargle periodogram before.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"LombScargle.jl provides simple methods to perform such analysis. The LombScargle.bootstrap function allows you to create a bootstrap sample with N permutations of the original data.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"LombScargle.bootstrap","category":"page"},{"location":"modules/LombScargle/#LombScargle.bootstrap","page":"Home","title":"LombScargle.bootstrap","text":"LombScargle.bootstrap(N::Integer,\n                      times::AbstractVector{Real},\n                      signal::AbstractVector{Real},\n                      errors::AbstractVector{Real}=ones(signal); ...)\n\nCreate N bootstrap samples, perform the Lomb–Scargle analysis on them, and store all the highest peaks for each one in a LombScargle.Bootstrap object. All the arguments after N are passed around to lombscargle.\n\n\n\n\n\nLombScargle.bootstrap(N::Integer, plan::PeriodogramPlan)\n\nCreate N bootstrap samples, perform the Lomb–Scargle analysis on them for the given plan, and store all the highest peaks for each one in a LombScargle.Bootstrap object.\n\nSee documentation of LombScargle.plan for how to plan a Lomb–Scargle periodogram.\n\n\n\n\n\n","category":"function"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"The false-alarm probability and its inverse can be calculated with fap and fapinv functions respectively.  Their syntax is the same as the methods introduced above, but with a LombScargle.Bootstrap object as first argument, instead of the LombScargle.Periodogram one.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"fap(::LombScargle.Bootstrap{<:AbstractFloat}, ::Real)\nfapinv(::LombScargle.Bootstrap{<:AbstractFloat}, ::Real)","category":"page"},{"location":"modules/LombScargle/#LombScargle.fap-Tuple{LombScargle.Bootstrap, Real}","page":"Home","title":"LombScargle.fap","text":"fap(b::Bootstrap, power::Real)\n\nReturn the false-alarm probability for power in the bootstrap sample b.\n\nIts inverse is the fapinv function.\n\n\n\n\n\n","category":"method"},{"location":"modules/LombScargle/#LombScargle.fapinv-Tuple{LombScargle.Bootstrap, Real}","page":"Home","title":"LombScargle.fapinv","text":"fapinv(b::Bootstrap, prob::Real)\n\nReturn the power value whose false-alarm probability is prob in the bootstrap sample b.\n\nIt returns NaN if the requested probability is too low and the power cannot be determined with the bootstrap sample b.  In this case, you should enlarge your bootstrap sample so that N*fap can be rounded to an integer larger than or equal to 1.\n\nThis is the inverse of fap function.\n\n\n\n\n\n","category":"method"},{"location":"modules/LombScargle/#LombScargle.model-Function","page":"Home","title":"LombScargle.model Function","text":"","category":"section"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"For each frequency f (and hence for the corresponding angular frequency omega = 2pi f) the Lomb–Scargle algorithm looks for the sinusoidal function of the type","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"a_fcos(omega t) + b_fsin(omega t) + c_f","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"that best fits the data. In the original Lomb–Scargle algorithm the offset c is null (see [LOM76]). In order to find the best-fitting coefficients a_f, b_f, and c_f for the given frequency f, without actually performing the periodogram, you can solve the linear system mathbfAx = mathbfy, where mathbfA is the matrix","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"beginaligned\nbeginbmatrix\n  cos(omega t)  sin(omega t)  1\nendbmatrix =\nbeginbmatrix\n  cos(omega t_1)  sin(omega t_1)  1      \n  vdots              vdots              vdots \n  cos(omega t_n)  sin(omega t_n)  1\nendbmatrix\nendaligned","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"t = t_1 dots t_n^textT is the column vector of observation times, x is the column vector with the unknown coefficients","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"beginaligned\nbeginbmatrix\n  a_f \n  b_f \n  c_f\nendbmatrix\nendaligned","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"and textbfy is the column vector of the signal. The solution of the matrix gives the wanted coefficients.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"This is what the LombScargle.model function does in order to return the best fitting Lomb–Scargle model for the given signal at the given frequency.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"LombScargle.model","category":"page"},{"location":"modules/LombScargle/#LombScargle.model","page":"Home","title":"LombScargle.model","text":"LombScargle.model(times::AbstractVector{Real},\n                  signal::AbstractVector{R2},\n                  [errors::AbstractVector{R3},]\n                  frequency::Real,\n                  [times_fit::AbstractVector{R4}];\n                  center_data::Bool=true,\n                  fit_mean::Bool=true)\n\nReturn the best fitting Lomb–Scargle model for the given signal at the given frequency.\n\nMandatory arguments are:\n\ntimes: the observation times\nsignal: the signal, sampled at times (must have the same length as times)\nfrequency: the frequency at which to calculate the model\n\nOptional arguments are:\n\nerrors: the vector of uncertainties of the signal.  If provided, it must have the same length as signal and times, and be the third argument.  Like for lombscargle, if the signal has uncertainties, the signal vector can also be a vector of Measurement objects, and this argument should be omitted\ntimes_fit: the vector of times at which the model will be calculated.  It defaults to times.  If provided, it must come after frequency\n\nOptional keyword arguments center_data and fit_mean have the same meaning as in lombscargle:\n\nfit_mean: whether to fit for the mean. If this is false, like in the original Lomb–Scargle periodogram, mathbfA does not have the third column of ones, c_f is set to 0 and the unknown vector to be determined becomes x = a_f b_f^textT\ncenter_data: whether the data should be pre-centered before solving the linear system. This is particularly important if fit_mean=false\n\n\n\n\n\n","category":"function"},{"location":"modules/LombScargle/#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"Here is an example of a noisy periodic signal (sin(pi t) + 15cos(2pi t)) sampled at unevenly spaced times.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"julia> using LombScargle\n\njulia> ntimes = 1001\n1001\n\njulia> t = range(0.01, stop = 10pi, length = ntimes) # Observation times\n0.01:0.03140592653589793:31.41592653589793\n\njulia> t += step(t)*rand(ntimes) # Randomize times\n\njulia> s = sinpi.(t) .+ 1.5cospi.(2t) .+ rand(ntimes) # The signal\n\njulia> plan = LombScargle.plan(t, s); # Pre-plan the periodogram\n\njulia> pgram = lombscargle(plan) # Compute the periodogram\nLombScargle.Periodogram{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}},Array{Float64,1}}([0.000472346, 0.000461633, 0.000440906, 0.000412717, 0.000383552, 0.000355828, 0.000289723, 0.000154585, 3.44734e-5, 5.94437e-7  …  3.15125e-5, 0.000487391, 0.0018939, 0.00367003, 0.00484181, 0.00495189, 0.00453233, 0.00480968, 0.00619657, 0.0074052], 0.003185690706734265:0.00637138141346853:79.72190993602499, [0.0295785, 0.0540516, 0.0780093, 0.122759, 0.15685, 0.192366, 0.206601, 0.252829, 0.265771, 0.315443  …  31.1512, 31.1758, 31.2195, 31.2342, 31.2752, 31.293, 31.3517, 31.3761, 31.4148, 31.4199], :standard)","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"You can plot the result, for example with Plots package. Use freqpower function to get the frequency grid and the power of the periodogram as a 2-tuple.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"using Plots\nplot(freqpower(pgram)...)","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"(Image: image)","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"You can also plot the power vs the period, instead of the frequency, with periodpower:","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"using Plots\nplot(periodpower(pgram)...)","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"(Image: image)","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"warning: Warning\nIf you do not fit for the mean of the signal (fit_mean=false keyword to lombscargle function) without centering the data (center_data=false) you can get inaccurate results. For example, spurious peaks at low frequencies can appear and the real peaks lose power:plot(freqpower(lombscargle(t, s, fit_mean=false, center_data=false))...)(Image: image)","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"tip: Tip\nYou can tune the frequency grid with appropriate keywords to lombscargle function. For example, in order to increase the sampling increase samples_per_peak, and set maximum_frequency to lower values in order to narrow the frequency range:plot(freqpower(lombscargle(t, s, samples_per_peak=20, maximum_frequency=1.5))...)(Image: image)If you simply want to use your own frequency grid, directly set the frequencies keyword:plot(freqpower(lombscargle(t, s, frequencies=0.001:1e-3:1.5))...)(Image: image)","category":"page"},{"location":"modules/LombScargle/#Signal-with-Uncertainties","page":"Home","title":"Signal with Uncertainties","text":"","category":"section"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"The generalised Lomb–Scargle periodogram is able to handle a signal with uncertainties, and they will be used as weights in the algorithm.  The uncertainties can be passed either as the third optional argument errors to lombscargle or by providing this function with a signal vector of type Measurement (from Measurements.jl package).","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"using Measurements, Plots\nntimes = 1001\nt = range(0.01, stop = 10pi, length = ntimes)\ns = sinpi.(2t)\nerrors = rand(0.1:1e-3:4.0, ntimes)\n# Run one of the two following equivalent commands\nplot(freqpower(lombscargle(t, s, errors, maximum_frequency=1.5))...)\nplot(freqpower(lombscargle(t, measurement(s, errors), maximum_frequency=1.5))...)","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"(Image: image)","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"This is the plot of the power versus the period:","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"# Run one of the two following equivalent commands\nplot(periodpower(lombscargle(t, s, errors, maximum_frequency=1.5))...)\nplot(periodpower(lombscargle(t, measurement(s, errors), maximum_frequency=1.5))...)","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"(Image: image)","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"We recall that the generalised Lomb–Scargle algorithm is used when the fit_mean optional keyword to lombscargle is true if no error is provided, instead it is always used if the signal has uncertainties.","category":"page"},{"location":"modules/LombScargle/#Find-Highest-Power-and-Associated-Frequencies-and-Periods","page":"Home","title":"Find Highest Power and Associated Frequencies and Periods","text":"","category":"section"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"findmaxfreq function tells you the frequencies with the highest power in the periodogram (and you can get the period by taking its inverse):","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"julia> t = range(0, stop = 10, length = 1001);\n\njulia> s = sinpi.(t);\n\njulia> plan = LombScargle.plan(t, s); # Plan the periodogram\n\njulia> p = lombscargle(plan);\n\njulia> findmaxperiod(p) # Period with highest power\n1-element Array{Float64,1}:\n 0.004987779939149084\n\njulia> findmaxfreq(p) # Frequency with the highest power\n1-element Array{Float64,1}:\n 200.49","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"This peak is at high frequencies, very far from the expected value of the period of 2. In order to find the real peak, you can either narrow the ranges in order to exclude higher armonics","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"julia> findmaxperiod(p, [1, 10]) # Limit the search to periods in [1, 10]\n1-element Array{Float64,1}:\n 2.04082\n\njulia> findmaxfreq(p, [0.1, 1]) # Limit the search to frequencies in [0.1, 1]\n1-element Array{Float64,1}:\n 0.49","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"or pass the threshold argument to findmaxfreq or findmaxperiod. You can use findmaxpower to discover the highest power in the periodogram:","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"julia> findmaxpower(p)\n0.9958310178312316\n\njulia> findmaxperiod(p, 0.95)\n10-element Array{Float64,1}:\n 2.04082\n 1.96078\n 0.0100513\n 0.0100492\n 0.00995124\n 0.00994926\n 0.00501278\n 0.00501228\n 0.00498778\n 0.00498728\n\njulia> findmaxfreq(p, 0.95)\n10-element Array{Float64,1}:\n   0.49\n   0.51\n  99.49\n  99.51\n 100.49\n 100.51\n 199.49\n 199.51\n 200.49\n 200.51","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"The first peak is the real one, the other double peaks appear at higher armonics.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"tip: Tip\nUsually, plotting the periodogram can give you a clue of what's going on.","category":"page"},{"location":"modules/LombScargle/#Significance-of-the-Peaks","page":"Home","title":"Significance of the Peaks","text":"","category":"section"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"The significance of the peaks in the Lomb–Scargle periodogram can be assessed by measuring the False-Alarm Probability. Analytic expressions of this quantity and its inverse can be obtained with the fap and fapinv functions, respectively.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"julia> t = linspace(0.01, 20, samples_per_peak = 10)\n\njulia> s = sinpi.(e.*t).^2 .- cos.(5t).^4\n\njulia> plan = LombScargle.plan(t, s);\n\njulia> p = lombscargle(plan)\n\n# Find the false-alarm probability for the highest peak.\njulia> fap(p, 0.3)\n0.028198095962262748","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"Thus, a peak with power 03 has a probability of 0028 that it is due to noise only. A quantity that is often used is the inverse of the false-alarm probability as well: what is the minimum power whose false-alarm probability is lower than the given probability? For example, if you want to know the minimum power for which the false-alarm probability is at most 001 you can use:","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"julia> fapinv(p, 0.01)\n0.3304696923786712","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"As we already noted, analytic expressions of the false-alarm probability and its inverse may not be reliable if your data does not satisfy specific assumptions. A better way to calculate this quantity is to use statistical methods. One of this is bootstrapping. In LombScargle.jl, you can use the function LombScargle.bootstrap to create a bootstrap sample and then you can calculate the false-alarm probability and its inverse using this sample.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"tip: Tip\nWhen applying the bootstrap method you should use the same options you used to perform the periodogram on your data. Using the same periodogram plan you used to compute the periodogram will ensure that you use the same options. However, note that the fast method gives approximate results that for some frequencies may not be reliable (they can go outside the range 0 1 for the standard normalization). More robust results can be obtained with the fast = false option.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"# Create a bootstrap sample with 10000\n# resamplings of the original data, re-using the\n# same periodogram plan.  The larger the better.\n# This may take some minutes.\njulia> b = LombScargle.bootstrap(10000, plan)\n\n# Calculate the false-alarm probability of a peak\n# with power 0.3 using this bootstrap sample.\njulia> fap(b, 0.3)\n0.0209\n\n# Calculate the lowest power that has probability\n# less than 0.01 in this bootstrap sample.\njulia> fapinv(b, 0.01)\n0.3268290388848437","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"If you query fapinv with a too low probability, the corresponding power cannot be determined and you will get NaN as result.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"julia> fapinv(b, 1e-5)\nNaN","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"If you want to find the power corresponding to a false-alarm probability of textprob = 10^-5, you have to create a new bootstrap sample with N resamplings so that Ncdottextprob can be rounded to an integer larger than or equal to one (for example N = 10^5).","category":"page"},{"location":"modules/LombScargle/#Find-the-Best-Fitting-Model","page":"Home","title":"Find the Best-Fitting Model","text":"","category":"section"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"The LombScargle.model function can help you to test whether a certain frequency fits well your data.","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"using Plots\nt = range(0.01, stop = 10pi, length = 1000) # Observation times\ns = sinpi.(t) .+ 1.2cospi.(t) .+ 0.3rand(length(t)) # The noisy signal\n# Pick-up the best frequency\nf = findmaxfreq(lombscargle(t, s, maximum_frequency=10, samples_per_peak=20))[1]\nt_fit = range(0, stop = 1, length = 50)\ns_fit = LombScargle.model(t, s, f, t_fit/f) # Determine the model\nscatter(mod.(t.*f, 1), s, lab=\"Phased data\", title=\"Best Lomb-Scargle frequency: $f\")\nplot!(t_fit, s_fit, lab=\"Best-fitting model\", linewidth=4)","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"(Image: image)","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"tip: Tip\nIf there are more than one dominant frequency you may need to consider more models. This task may require some work and patience. Plot the periodogram in order to find the best frequencies.using Plots\nt = range(0.01, stop = 5, length = 1000) # Observation times\ns = sinpi.(2t) .+ 1.2cospi.(4t) .+ 0.3rand(length(t)) # Noisy signal\nplan = LombScargle.plan(t, s, samples_per_peak=50)\np = lombscargle(plan)\n# After plotting the periodogram, you discover\n# that it has two prominent peaks around 1 and 2.\nf1 = findmaxfreq(p, [0.8, 1.2])[1] # Get peak frequency around 1\nf2 = findmaxfreq(p, [1.8, 2.2])[1] # Get peak frequency around 2\nfit1 = LombScargle.model(t, s, f1) # Determine the first model\nfit2 = LombScargle.model(t, s, f2) # Determine the second model\nscatter(t, s, lab=\"Data\", title=\"Best-fitting Lomb-Scargle model\")\nplot!(t, fit1 + fit2, lab=\"Best-fitting model\", linewidth=4)(Image: image)","category":"page"},{"location":"modules/LombScargle/#Performance","page":"Home","title":"Performance","text":"","category":"section"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"A pre-planned periodogram in LombScargle.jl computed in single thread mode with the fast method is more than 2 times faster than the implementation of the same algorithm provided by AstroPy, and more than 4 times faster if 4 FFTW threads are used (on machines with at least 4 physical CPUs).","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"The following plot shows a comparison between the times needed to compute a periodogram for a signal with N datapoints using LombScargle.jl, with 1 or 4 FFTW threads (with flags = FFTW.MEASURE for better performance), and the single-threaded Astropy implementation.  (Julia version: 1.6.0; LombScargle.jl version: 1.0.0; Python version: 3.8.6; Astropy version: 4.1.  CPU: Intel(R) Core(TM) i7-4870HQ CPU @ 2.50GHz.)","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"(Image: image)","category":"page"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"Note that this comparison is unfair, as Astropy doesn’t support pre-planning a periodogram nor multi-threading, and it pads vectors for FFT to a length which is a power of 2, while by default LombScargle.jl uses length which are multiples of 2, 3, 5, 7.  A non-planned periodogram in single thread mode in LombScargle.jl is still twice as fast as Astropy.","category":"page"},{"location":"modules/LombScargle/#Development","page":"Home","title":"Development","text":"","category":"section"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"The package is developed at https://github.com/JuliaAstro/LombScargle.jl. There you can submit bug reports, make suggestions, and propose pull requests.","category":"page"},{"location":"modules/LombScargle/#History","page":"Home","title":"History","text":"","category":"section"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"The ChangeLog of the package is available in NEWS.md file in top directory.","category":"page"},{"location":"modules/LombScargle/#License","page":"Home","title":"License","text":"","category":"section"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"The LombScargle.jl package is licensed under the BSD 3-clause \"New\" or \"Revised\" License. The original author is Mosè Giordano.","category":"page"},{"location":"modules/LombScargle/#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"modules/LombScargle/","page":"Home","title":"Home","text":"This package adapts the implementation in Astropy of the the fast Lomb–Scargle method by [PR89]. We claim no endorsement nor promotion by the Astropy Team.","category":"page"},{"location":"modules/EarthOrientation/internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"modules/EarthOrientation/internals/","page":"Internals","title":"Internals","text":"Modules = [EarthOrientation]\nPublic = false","category":"page"},{"location":"modules/EarthOrientation/internals/#EarthOrientation.getdate-Tuple{Any}","page":"Internals","title":"EarthOrientation.getdate","text":"getdate(data)\n\nDetermine the creation date of an IERS table by finding the last entry which is marked as \"final\".\n\n\n\n\n\n","category":"method"},{"location":"modules/EarthOrientation/internals/#EarthOrientation.update-Tuple{}","page":"Internals","title":"EarthOrientation.update","text":"update(; force=false)\n\nDownload weekly EOP data from the IERS servers if newer files are available or no data has been downloaded previously. If the keyword force is true, then all the files will be downloaded again.\n\n\n\n\n\n","category":"method"},{"location":"modules/PSFModels/#PSFModels.jl","page":"PSFModels","title":"PSFModels.jl","text":"","category":"section"},{"location":"modules/PSFModels/","page":"PSFModels","title":"PSFModels","text":"(Image: Build Status) (Image: PkgEval) (Image: Coverage) (Image: License)","category":"page"},{"location":"modules/PSFModels/","page":"PSFModels","title":"PSFModels","text":"(Image: Stable) (Image: Dev)","category":"page"},{"location":"modules/PSFModels/","page":"PSFModels","title":"PSFModels","text":"Fast, allocation-free point-spread function (PSF) representations","category":"page"},{"location":"modules/PSFModels/#Models","page":"PSFModels","title":"Models","text":"","category":"section"},{"location":"modules/PSFModels/","page":"PSFModels","title":"PSFModels","text":"gaussian (or normal)\nairydisk\nmoffat","category":"page"},{"location":"modules/PSFModels/#Installation","page":"PSFModels","title":"Installation","text":"","category":"section"},{"location":"modules/PSFModels/","page":"PSFModels","title":"PSFModels","text":"From the Julia REPL","category":"page"},{"location":"modules/PSFModels/","page":"PSFModels","title":"PSFModels","text":"julia> ]\n\n(@v1.5) pkg> add PSFModels","category":"page"},{"location":"modules/PSFModels/","page":"PSFModels","title":"PSFModels","text":"To import the library","category":"page"},{"location":"modules/PSFModels/","page":"PSFModels","title":"PSFModels","text":"julia> using PSFModels","category":"page"},{"location":"modules/PSFModels/","page":"PSFModels","title":"PSFModels","text":"julia> using PSFModels: gaussian\n\njulia> model = gaussian(x=0, y=0, fwhm=8)","category":"page"},{"location":"modules/PSFModels/","page":"PSFModels","title":"PSFModels","text":"or you can create an alias for PSFModels","category":"page"},{"location":"modules/PSFModels/","page":"PSFModels","title":"PSFModels","text":"# julia version 1.5 or below\nusing PSFModels\nconst M = PSFModels\n# julia version 1.6 or above\nimport PSFModels as M\n\nmodel = M.gaussian(fwhm=10)","category":"page"},{"location":"modules/PSFModels/#Usage","page":"PSFModels","title":"Usage","text":"","category":"section"},{"location":"modules/PSFModels/","page":"PSFModels","title":"PSFModels","text":"For more in-depth usage and examples, please see the documentation.","category":"page"},{"location":"modules/PSFModels/","page":"PSFModels","title":"PSFModels","text":"First, load the package","category":"page"},{"location":"modules/PSFModels/","page":"PSFModels","title":"PSFModels","text":"julia> using PSFModels","category":"page"},{"location":"modules/PSFModels/#Evaluating-models","page":"PSFModels","title":"Evaluating models","text":"","category":"section"},{"location":"modules/PSFModels/","page":"PSFModels","title":"PSFModels","text":"Directly evaluating the functions is the most straightforward way to use this package","category":"page"},{"location":"modules/PSFModels/","page":"PSFModels","title":"PSFModels","text":"julia> gaussian(0, 0; x=0, y=0, fwhm=3)\n1.0\n\njulia> gaussian(BigFloat, 0, 0; x=0, y=0, fwhm=3, amp=0.1)\n0.1000000000000000055511151231257827021181583404541015625","category":"page"},{"location":"modules/PSFModels/","page":"PSFModels","title":"PSFModels","text":"We also provide \"curried\" versions of the functions, which allow you to specify the parameters and evaluate the PSF later","category":"page"},{"location":"modules/PSFModels/","page":"PSFModels","title":"PSFModels","text":"julia> model = gaussian(x=0, y=0, fwhm=3);\n\njulia> model(0, 0)\n1.0","category":"page"},{"location":"modules/PSFModels/","page":"PSFModels","title":"PSFModels","text":"If we want to collect the model into a dense matrix, simply iterate over indices","category":"page"},{"location":"modules/PSFModels/","page":"PSFModels","title":"PSFModels","text":"julia> inds = CartesianIndices((-2:2, -2:2));\n\njulia> model.(inds) # broadcasting\n5×5 Matrix{Float64}:\n 0.0850494  0.214311  0.291632  0.214311  0.0850494\n 0.214311   0.54003   0.734867  0.54003   0.214311\n 0.291632   0.734867  1.0       0.734867  0.291632\n 0.214311   0.54003   0.734867  0.54003   0.214311\n 0.0850494  0.214311  0.291632  0.214311  0.0850494","category":"page"},{"location":"modules/PSFModels/","page":"PSFModels","title":"PSFModels","text":"This makes it very easy to evaluate the PSF on the same axes as an image (array)","category":"page"},{"location":"modules/PSFModels/","page":"PSFModels","title":"PSFModels","text":"julia> img = randn(5, 5);\n\njulia> model.(CartesianIndices(img))\n5×5 Matrix{Float64}:\n 0.54003      0.214311     0.0459292    0.00531559   0.000332224\n 0.214311     0.0850494    0.018227     0.00210949   0.000131843\n 0.0459292    0.018227     0.00390625   0.000452087  2.82555e-5\n 0.00531559   0.00210949   0.000452087  5.2322e-5    3.27013e-6\n 0.000332224  0.000131843  2.82555e-5   3.27013e-6   2.04383e-7","category":"page"},{"location":"modules/PSFModels/","page":"PSFModels","title":"PSFModels","text":"this is trivially expanded to fit \"stamps\" in images","category":"page"},{"location":"modules/PSFModels/","page":"PSFModels","title":"PSFModels","text":"julia> big_img = randn(1000, 1000);\n\njulia> stamp_inds = (750:830, 400:485);\n\njulia> stamp = @view big_img[stamp_inds...];\n\njulia> stamp_model = model.(CartesianIndices(stamp_inds));","category":"page"},{"location":"modules/PSFModels/","page":"PSFModels","title":"PSFModels","text":"or we can create a loss function for fitting PSFs without allocating any memory. We are simply iterating over the image array!","category":"page"},{"location":"modules/PSFModels/","page":"PSFModels","title":"PSFModels","text":"julia> using Statistics\n\njulia> mse = mean(I -> (big_img[I] - model(I))^2, CartesianIndices(stamp_inds));","category":"page"},{"location":"modules/PSFModels/#Fitting-data","page":"PSFModels","title":"Fitting data","text":"","category":"section"},{"location":"modules/PSFModels/","page":"PSFModels","title":"PSFModels","text":"There exists a simple, yet powerful, API for fitting data with these PSF models. See the full documentation for more details and examples.","category":"page"},{"location":"modules/PSFModels/","page":"PSFModels","title":"PSFModels","text":"# `fit` is not exported to avoid namespace clashes\nusing PSFModels: fit\n\ndata = # load data\nstamp_inds = # optionally choose indices to \"cutout\"\n\n# use an isotropic Gaussian\nP0 = (x=12, y=13, fwhm=3.2, amp=0.1)\nparams, synthpsf = fit(gaussian, P0, data, stamp_inds)\n\n# elliptical, rotated Gaussian\nP0 = (x=12, y=13, fwhm=(3.2, 3.2), amp=0.1, theta=0)\nparams, synthpsf = fit(gaussian, P0, data, stamp_inds)\n\n# obscured Airy disk\nP0 = (x=12, y=13, fwhm=3.2, amp=0.1, ratio=0.3)\nparams, synthpsf = fit(airydisk, P0, data, stamp_inds)\n\n# bivariate Moffat with arbitrary alpha\nP0 = (x=12, y=13, fwhm=(3.2, 3.2), amp=0.1, alpha=1)\n# fixed (\"frozen\") rotation angle\nfunc_kwargs = (;theta=15)\nparams, synthpsf = fit(moffat, P0, data, stamp_inds; func_kwargs)","category":"page"},{"location":"modules/PSFModels/#Plotting-models","page":"PSFModels","title":"Plotting models","text":"","category":"section"},{"location":"modules/PSFModels/","page":"PSFModels","title":"PSFModels","text":"We provide simple user recipes from RecipesBase.jl, which can be called with psfplot/psfplot!","category":"page"},{"location":"modules/PSFModels/","page":"PSFModels","title":"PSFModels","text":"using Plots\n\ninds = (1:30, 1:30)\nmodel = airydisk(x=12, y=13, fwhm=(4.5, 6.7), theta=12, ratio=0.3)\npsfplot(model, inds, colorbar_scale=:log10)","category":"page"},{"location":"modules/PSFModels/#Contributing-and-Support","page":"PSFModels","title":"Contributing and Support","text":"","category":"section"},{"location":"modules/PSFModels/","page":"PSFModels","title":"PSFModels","text":"If you would like to contribute, feel free to open a pull request. If you want to discuss something before contributing, head over to discussions and join or open a new topic. If you're having problems with something, please open an issue.","category":"page"},{"location":"#JuliaAstro","page":"Home","title":"JuliaAstro","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JuliaAstro and its affiliated organizations are a community for astronomy in Julia. We have a wide variety of packages from aperture photometry to cosmology. Check out a curated list of packages in the JuliaAstro ecosystem (and beyond) on the ecosystem page.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Our contributors come from diverse backgrounds and have various levels of interactions within astronomy and academia. Use the packages, file issues, and join the conversation!","category":"page"},{"location":"","page":"Home","title":"Home","text":"JuliaAstro on GitHub\nJuliaHCI on GitHub\njulia-astro mailing list on Google Groups\nAstro/Space topics on JuliaLang Discourse\n#JuliaAstro:openastronomy.org on Matrix\n#astronomy on JuliaLang Slack","category":"page"},{"location":"#Google-Summer-of-Code-(GSoC)","page":"Home","title":"Google Summer of Code (GSoC)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Would you like to contribute to JuliaAstro through Google Summer of Code? You can! We are member of OpenAstronomy; go to the GSoC page to see how to apply and the list of ideas. You can also propose your own idea to us!","category":"page"},{"location":"#Talks-and-Presentations","page":"Home","title":"Talks and Presentations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<details>\n<summary>JuliaCon 2022</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"Julia in Astronomy & Astrophysics Research\nComrade: High-Performance Black Hole Imaging\nRVSpectML: Precision Velocities from Spectroscopic Time Series\nFinding Fast Radio Bursts, Faster\nCosmological Emulators with Flux.jl and DifferentialEquations.jl\nVisualizing astronomical data with AstroImages.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"modules/WCS/#WCS.jl","page":"Home","title":"WCS.jl","text":"","category":"section"},{"location":"modules/WCS/","page":"Home","title":"Home","text":"(Image: Code) (Image: Build Status) (Image: PkgEval) (Image: Coverage) (Image: License)","category":"page"},{"location":"modules/WCS/","page":"Home","title":"Home","text":"Astronomical World Coordinate System library for Julia. This package wraps the WCSLIB C library. This is a tool made for users who are already familiar with WCS transformations. If you are not, please reference the following manuscripts","category":"page"},{"location":"modules/WCS/","page":"Home","title":"Home","text":"Representation of world coordinates in FITS\nRepresentations of celestial coordinates in FITS\nRepresentations of spectral coordinates in FITS\nRepresentations of distortions in FITS world coordinate systems","category":"page"},{"location":"modules/WCS/#Table-of-Contents","page":"Home","title":"Table of Contents","text":"","category":"section"},{"location":"modules/WCS/","page":"Home","title":"Home","text":"","category":"page"},{"location":"modules/WCS/#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"modules/WCS/","page":"Home","title":"Home","text":"From the REPL, press ] to enter Pkg mode","category":"page"},{"location":"modules/WCS/","page":"Home","title":"Home","text":"(v 1.2) pkg> add WCS","category":"page"},{"location":"modules/WCS/#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"modules/WCS/","page":"Home","title":"Home","text":"Import the library","category":"page"},{"location":"modules/WCS/","page":"Home","title":"Home","text":"DocTestSetup = quote\n    using WCS\nend","category":"page"},{"location":"modules/WCS/","page":"Home","title":"Home","text":"julia> using WCS","category":"page"},{"location":"modules/WCS/","page":"Home","title":"Home","text":"There are many ways to utilize WCS transformations. Let's make one for a 2-dimensional array (like an image) from scratch.","category":"page"},{"location":"modules/WCS/","page":"Home","title":"Home","text":"julia> wcs = WCSTransform(2;\n                          cdelt = [-0.066667, 0.066667],\n                          ctype = [\"RA---AIR\", \"DEC--AIR\"],\n                          crpix = [-234.75, 8.3393],\n                          crval = [0., -90],\n                          pv    = [(2, 1, 45.0)])\nWCSTransform(naxis=2,cdelt=[-0.066667, 0.066667],crval=[0.0, -90.0],crpix=[-234.75, 8.3393])","category":"page"},{"location":"modules/WCS/","page":"Home","title":"Home","text":"We can also create one from a FITS header if it contains the appropriate keywords","category":"page"},{"location":"modules/WCS/","page":"Home","title":"Home","text":"# Or from a FITS header with appropriate keywords\njulia> wcs_array = WCS.from_header(header)\n\njulia> wcs = wcs_array[1]\n","category":"page"},{"location":"modules/WCS/","page":"Home","title":"Home","text":"Now we can do conversions between pixel and world coordinates.","category":"page"},{"location":"modules/WCS/","page":"Home","title":"Home","text":"note: Note\nthat WCS transforms use pixel (0, 0) as the top-left corner (not 1-indexed!!!)","category":"page"},{"location":"modules/WCS/","page":"Home","title":"Home","text":"# convert pixel -> world coordinates\njulia> pixcoords = [0.0  24.0  45.0;  # x coordinates\n                    0.0  38.0  98.0]  # y coordinates\n2×3 Matrix{Float64}:\n 0.0  24.0  45.0\n 0.0  38.0  98.0\n\njulia> worldcoords = pix_to_world(wcs, pixcoords)\n2×3 Matrix{Float64}:\n 267.965   276.539   287.771\n -73.7366  -71.9741  -69.6781\njulia> pixcoords = world_to_pix(wcs, worldcoords)\n2×3 Matrix{Float64}:\n  1.16529e-12  24.0  45.0\n -7.10543e-14  38.0  98.0\n","category":"page"},{"location":"modules/WCS/#API/Reference","page":"Home","title":"API/Reference","text":"","category":"section"},{"location":"modules/WCS/","page":"Home","title":"Home","text":"Modules = [WCS]","category":"page"},{"location":"modules/WCS/#WCS.WCSTransform","page":"Home","title":"WCS.WCSTransform","text":"WCSTransform(naxis; kwds...)\n\nConstruct a WCS transformation with the given number of axes naxis. Keyword arguments can be passed to set various attributes of the transform. Specifying keyword arguments is equivalent to setting them after construction:\n\njulia> wcs = WCSTransform(2; crpix=[1000., 1000.])\n\nis equilvalent to:\n\njulia> wcs = WCSTransform(2)\n\njulia> wcs.crpix = [1000., 1000.]\n\nProperties\n\nBelow is the entire list of public properties for a WCSTransform\n\nKeyword Type Description\nnaxis Int Number of dimensions\ncrval Vector{Float}[naxis] coordinate value at reference point\ncrpix Vector{Float}[naxis] array location of the reference point in pixels\ncdelt Vector{Float}[naxis] coordinate increment at reference point\ncrder Vector{Float}[naxis] random error in coordinate\ncsyer Vector{Float}[naxis] systematic error in coordinate\nctype Vector{String}[naxis] axis type (8 characters)\ncrota Vector{Float}[naxis] rotation from stated coordinate type\ncunit Vector{String}[naxis] units of axes\ncunit Vector{String}[naxis] names of axes\npc Matrix{Float}[naxis, naxis] linear transformation matrix\ncd Matrix{Float}[naxis, naxis] linear transformation matrix (with scale)\nequinox Float the equinox associated with dynamical equatorial or ecliptic coordinate systems\nlatpole Float the native latitude of the celestial pole\nlonpole Float the native longitude of the celestial pole\nmjdavg Float Modified Julian Date corresponding to DATE-AVG\nmjdobs Float Modified Julian Date corresponding to DATE-OBS\nrestfrq Float rest frequency (Hz)\nrestwav Float rest wavelength (m)\nvelangl Float velocity angle\nvelosys Float relative radial velocity\nzsource Float the redshift of the source\ncolnum Int column of FITS binary table associated with this WCS\ndateavg String representative mid-point of the date of observation\ndateobs String start of the date of observation\nradesys String the equatorial or ecliptic coordinate system type\nspecsys String spectral reference frame (standard of rest)\nssysobs String spectral reference frame\nssyssrc String spectral reference frame for redshift\nwcsname String name of this coordinate representation\nobsgeo Vector{Float}[3] or Vector{Float}[6] location of the observer in a standard terrestrial reference frame\nalt String character code for alternate coordinate descriptions\n\n\n\n\n\n","category":"type"},{"location":"modules/WCS/#WCS.from_header-Tuple{String}","page":"Home","title":"WCS.from_header","text":"from_header(header[; relax=WCS.HDR_ALL, ctrl=0, ignore_rejected=false, table=false])\n\nParse the FITS image header in the String header, returning a Vector{WCSTransform} giving all the transforms defined in the header. The relax determines the treatment of non-standard keywords. The default is to accept all known non-standard keywords. Use relax=WCS.HDR_NONE to ignore all non-standard keywords. Use, e.g., relax=(WCS.HDR_RADECSYS & WCS.HDR_CROTAia) to only accept selected non-standard keywords.\n\n\n\n\n\n","category":"method"},{"location":"modules/WCS/#WCS.obsfix-Tuple{Integer, WCSTransform}","page":"Home","title":"WCS.obsfix","text":"obsfix(ctrl::Integer, wcs::WCSTransform)\n\nComplete the obsgeo field wcs of observatory coordinates.  That is, if only the (x,y,z) Cartesian coordinate triplet or the (l,b,h) geodetic coordinate triplet are set, then it derives the other triplet from it. If both triplets are set, then it checks for consistency at the level of 1 metre.\n\nParameters\n\nctrl: flag that controls behaviour if one triplet is defined and the other is only partially defined:\n0: Reset only the undefined elements of an incomplete coordinate triplet.\n1: Reset all elements of an incomplete triplet.\n2: Don't make any changes, check for consistency only. Returns an error if either of the two triplets is incomplete.\nwcs: Coordinate transformation parameters. Its obsgeo field may be changed.\n\nReturns\n\n-1: No change required (not an error).\n0: Success.\n1: Null wcsprm pointer passed.\n5: Invalid parameter value.\n\n\n\n\n\n","category":"method"},{"location":"modules/WCS/#WCS.pix_to_world!-Tuple{WCSTransform, Any, Any}","page":"Home","title":"WCS.pix_to_world!","text":"pix_to_world!(wcs, pixcoords, worldcoords[; stat=, imcoords=, phi=, theta=])\n\nConvert the array of pixel coordinates pixcoords to world coordinates according to the WCSTransform wcs, storing the result in the worldcoords and stat arrays. pixcoords should be a 2-d array where \"pixcoords[:, i]\" is the i-th set of coordinates, or a 1-d array representing a single set of coordinates. worldcoords must be the same size and type as pixcoords.\n\nIf given, the arrays stat, imcoords, phi, theta will be used to store intermediate results. Their sizes and types must all match pixcoords, except for stat which should be the same size but of type Cint (typically Int32).\n\n\n\n\n\n","category":"method"},{"location":"modules/WCS/#WCS.pix_to_world-Tuple{WCSTransform, VecOrMat{Float64}}","page":"Home","title":"WCS.pix_to_world","text":"pix_to_world(wcs, pixcoords)\n\nConvert the array of pixel coordinates pixcoords to world coordinates according to the WCSTransform wcs. pixcoords should be a 2-d array where \"pixcoords[:, i]\" is the i-th set of coordinates, or a 1-d array representing a single set of coordinates.\n\nThe return value is the same shape as pixcoords.\n\n\n\n\n\n","category":"method"},{"location":"modules/WCS/#WCS.to_header-Tuple{WCSTransform}","page":"Home","title":"WCS.to_header","text":"to_header(wcs[; relax=WCS.HDR_NONE])\n\nEncode the WCSTransform wcs as a FITS header string. The relax keyword controls how non-standard extensions to the WCS standard are handled.\n\n\n\n\n\n","category":"method"},{"location":"modules/WCS/#WCS.world_to_pix!-Tuple{WCSTransform, Any, Any}","page":"Home","title":"WCS.world_to_pix!","text":"world_to_pix!(wcs, worldcoords, pixcoords[; stat=, phi=, theta=, imcoords=])\n\nConvert the array of pixel coordinates worldcoords to pixel coordinates according to the WCSTransform wcs, storing the result in the pixcoords array. worldcoords should be a 2-d array where \"worldcoords[:, i]\" is the i-th set of coordinates, or a 1-d array representing a single set of coordinates. pixcoords must be the same size and type as worldcoords.\n\nIf given, the arrays stat, imcoords, phi, theta will be used to store intermediate results. Their sizes and types must all match worldcoords, except for stat which should be the same size but of type Cint (typically Int32).\n\n\n\n\n\n","category":"method"},{"location":"modules/WCS/#WCS.world_to_pix-Tuple{WCSTransform, VecOrMat{Float64}}","page":"Home","title":"WCS.world_to_pix","text":"world_to_pix(wcs, worldcoords)\n\nConvert the array of world coordinates worldcoords to pixel coordinates according to the WCSTransform wcs. worldcoords is a 2-d array where \"worldcoords[:, i]\" is the i-th set of coordinates, or a 1-d array representing a single set of coordinates.\n\nThe return value is the same size as worldcoords.\n\n\n\n\n\n","category":"method"},{"location":"modules/WCS/#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"modules/WCS/","page":"Home","title":"Home","text":"","category":"page"},{"location":"modules/EarthOrientation/#EarthOrientation.jl","page":"Home","title":"EarthOrientation.jl","text":"","category":"section"},{"location":"modules/EarthOrientation/","page":"Home","title":"Home","text":"Calculate Earth orientation parameters from IERS tables in Julia.","category":"page"},{"location":"modules/EarthOrientation/#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"modules/EarthOrientation/","page":"Home","title":"Home","text":"The package can be installed through Julia's package manager:","category":"page"},{"location":"modules/EarthOrientation/","page":"Home","title":"Home","text":"Pkg.add(\"EarthOrientation\")","category":"page"},{"location":"modules/EarthOrientation/#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"modules/EarthOrientation/","page":"Home","title":"Home","text":"Fetch the latest [IERS][iers-link] tables:","category":"page"},{"location":"modules/EarthOrientation/","page":"Home","title":"Home","text":"using EarthOrientation\nEarthOrientation.update()","category":"page"},{"location":"modules/EarthOrientation/","page":"Home","title":"Home","text":"Get the current Earth orientation parameters, e.g. for polar motion:","category":"page"},{"location":"modules/EarthOrientation/","page":"Home","title":"Home","text":"xp, yp = polarmotion(now()) # arcseconds","category":"page"},{"location":"modules/EarthOrientation/","page":"Home","title":"Home","text":"Or the current difference between UT1 and UTC and the associated prediction error:","category":"page"},{"location":"modules/EarthOrientation/","page":"Home","title":"Home","text":"ΔUT1 = getΔUT1(now()) # seconds\nΔUT1_err = getΔUT1_err(now()) # seconds","category":"page"},{"location":"modules/EarthOrientation/#Available-data","page":"Home","title":"Available data","text":"","category":"section"},{"location":"modules/EarthOrientation/","page":"Home","title":"Home","text":"Polar motion:\nx-coordinate of Earth's north pole: getxp\ny-coordinate of Earth's north pole: getyp\nboth: polarmotion\nEarth rotation\nDifference between UT1 and UTC: getΔUT1\nDifference between UT1 and TAI: getΔUT1_TAI\nExcess length of day: getlod\nPrecession and nutation based on the 1980 IAU conventions\nCorrection to the nutation of the ecliptic: getdψ\nCorrection to the obliquity of the ecliptic: getdϵ\nboth: precession_nutation80\nPrecession and nutation based on the 2000 IAU conventions\nCorrection to the celestial pole's x-coordinate: getdx\nCorrection to the celestial pole's y-coordinate: getdy\nboth: precession_nutation00","category":"page"},{"location":"modules/EarthOrientation/","page":"Home","title":"Home","text":"There is an associated function that returns the prediction error for each data type, e.g. getxp_err.","category":"page"},{"location":"modules/EarthOrientation/#Manual-Data-Management","page":"Home","title":"Manual Data Management","text":"","category":"section"},{"location":"modules/EarthOrientation/","page":"Home","title":"Home","text":"By default the files downloaded by EarthOrientation.update() will be used. It is also possible to pass different finals.all and finals2000A.all files in CSV format.","category":"page"},{"location":"modules/EarthOrientation/","page":"Home","title":"Home","text":"using EarthOrientation\n\npush!(EOP_DATA, \"finals.csv\", \"finals2000A.csv\")","category":"page"},{"location":"highlevels/numerical-utils/#Numerical-Utilities-Overview","page":"Numerical Utilities Overview","title":"Numerical Utilities Overview","text":"","category":"section"},{"location":"modules/AstroImages/guide/photometry/#Photometry","page":"Extracting Photometry","title":"Photometry","text":"","category":"section"},{"location":"modules/AstroImages/guide/photometry/","page":"Extracting Photometry","title":"Extracting Photometry","text":"The following examples are adapted from Photometry.jl to show the same examples combined with AstroImages.jl. To learn how to measure background levels, perform aperture photometry, etc see the Photometry.jl documentation.","category":"page"},{"location":"modules/AstroImages/guide/photometry/#Background-Estimation","page":"Extracting Photometry","title":"Background Estimation","text":"","category":"section"},{"location":"modules/AstroImages/guide/photometry/","page":"Extracting Photometry","title":"Extracting Photometry","text":"From Photometry.jl:","category":"page"},{"location":"modules/AstroImages/guide/photometry/","page":"Extracting Photometry","title":"Extracting Photometry","text":"Estimating backgrounds is an important step in performing photometry. Ideally, we could perfectly describe the background with a scalar value or with some distribution. Unfortunately, it's impossible for us to precisely separate the background and foreground signals. Here, we use mixture of robust statistical estimators and meshing to let us get the spatially varying background from an astronomical photo. Let's show an example Now let's try and estimate the background using estimate_background. First, we'll si gma-clip to try and remove the signals from the stars. Then, the background is broken down into boxes, in this case of size (50, 50). Within each box, the given statistical estimators get the background value and RMS. By default, we use SourceExtractorBackground and StdRMS. This creates a low-resolution image, which we then need to resize. We can accomplish this using an interpolator, by default a cubic-spline interpolator via ZoomInterpolator. The end result is a smooth estimate of the spatially varying background and background RMS.","category":"page"},{"location":"modules/AstroImages/guide/photometry/","page":"Extracting Photometry","title":"Extracting Photometry","text":"using AstroImages\nAstroImages.set_clims!(Percent(99.5))\nAstroImages.set_cmap!(:magma)\nAstroImages.set_stretch!(identity)","category":"page"},{"location":"modules/AstroImages/guide/photometry/","page":"Extracting Photometry","title":"Extracting Photometry","text":"using Photometry\nusing AstroImages\nusing Plots # optional, for implot functionality\n\n# Download our image, courtesy of astropy\nimage = AstroImage(download(\"https://rawcdn.githack.com/astropy/photutils-datasets/8c97b4fa3a6c9e6ea072faeed2d49a20585658ba/data/M6707HH.fits\"))\n\n# sigma-clip\nclipped = sigma_clip(image, 1, fill=NaN)\n\n# get background and background rms with box-size (50, 50)\nbkg, bkg_rms = estimate_background(clipped, 50)\n\nimview(image)\nimview(clipped)\nimview(bkg)\nimview(bkg_rms)","category":"page"},{"location":"modules/AstroImages/guide/photometry/","page":"Extracting Photometry","title":"Extracting Photometry","text":"Or, if you have Plots loaded:","category":"page"},{"location":"modules/AstroImages/guide/photometry/","page":"Extracting Photometry","title":"Extracting Photometry","text":"using Plots\n\nAstroImages.set_clims!(Percent(99.5))\nAstroImages.set_cmap!(:magma)\nAstroImages.set_stretch!(identity)\n\nplot(\n    implot(image, title=\"Original\"),\n    implot(clipped, title=\"Sigma-Clipped\"),\n    implot(bkg, title=\"Background\"),\n    implot(bkg_rms, title=\"Background RMS\"),\n    layout=(2, 2)\n)","category":"page"},{"location":"modules/AstroImages/guide/photometry/","page":"Extracting Photometry","title":"Extracting Photometry","text":"(Image: )","category":"page"},{"location":"modules/AstroImages/guide/photometry/","page":"Extracting Photometry","title":"Extracting Photometry","text":"We could apply a median filter, too, by specifying filter_size","category":"page"},{"location":"modules/AstroImages/guide/photometry/","page":"Extracting Photometry","title":"Extracting Photometry","text":"# get background and background rms with box-size (50, 50) and filter_size (5, 5)\nbkg_f, bkg_rms_f = estimate_background(clipped, 50, filter_size=5)\n\n# plot\nplot(\n    implot(bkg, title=\"Unfiltered\", ylabel=\"Background\"),\n    implot(bkg_f, title=\"Filtered\"),\n    implot(bkg_rms, ylabel=\"RMS\"),\n    implot(bkg_rms_f);\n    layout=(2, 2),)","category":"page"},{"location":"modules/AstroImages/guide/photometry/","page":"Extracting Photometry","title":"Extracting Photometry","text":"Now we can see our image after subtracting the filtered background and ready for Aperture Photometry!","category":"page"},{"location":"modules/AstroImages/guide/photometry/","page":"Extracting Photometry","title":"Extracting Photometry","text":"subt = image .- bkg_f[axes(image)...]\nclims = extrema(vcat(vec(image), vec(subt)))\nplot(\n    implot(image; title=\"Original\", clims),\n    implot(subt; title=\"Subtracted\", clims),\n    size=(1600,1000)\n)","category":"page"},{"location":"modules/AstroImages/guide/photometry/#Source-Extraction","page":"Extracting Photometry","title":"Source Extraction","text":"","category":"section"},{"location":"modules/AstroImages/guide/photometry/","page":"Extracting Photometry","title":"Extracting Photometry","text":"From the background-subtracted image, we can detect all sources in the image:","category":"page"},{"location":"modules/AstroImages/guide/photometry/","page":"Extracting Photometry","title":"Extracting Photometry","text":"# We specify the uncertainty in the pixel data. We'll set it equal to zero.\nerrs = zeros(axes(subt))\nsources = extract_sources(PeakMesh(), subt, errs, true) # sort from brightest to darkest","category":"page"},{"location":"modules/AstroImages/guide/photometry/","page":"Extracting Photometry","title":"Extracting Photometry","text":"There's over 60,000 sources!","category":"page"},{"location":"modules/AstroImages/guide/photometry/","page":"Extracting Photometry","title":"Extracting Photometry","text":"We'll define a circular apperture for each source:","category":"page"},{"location":"modules/AstroImages/guide/photometry/","page":"Extracting Photometry","title":"Extracting Photometry","text":"aps = CircularAperture.(sources.x, sources.y, 6)[1:1000] # just brightest thousand point sources","category":"page"},{"location":"modules/AstroImages/guide/photometry/","page":"Extracting Photometry","title":"Extracting Photometry","text":"We can overplot them on our original image. The coordinate sytem used by the Photometry.jl plot recipes (but not the actual return values) doesn't match AstroImages, so we must transpose our image:","category":"page"},{"location":"modules/AstroImages/guide/photometry/","page":"Extracting Photometry","title":"Extracting Photometry","text":"implot(subt', colorbar=false)\nplot!(aps) ","category":"page"},{"location":"modules/AstroImages/guide/photometry/#Measuring-Photometry","page":"Extracting Photometry","title":"Measuring Photometry","text":"","category":"section"},{"location":"modules/AstroImages/guide/photometry/","page":"Extracting Photometry","title":"Extracting Photometry","text":"Finally we can extract the source photometry ","category":"page"},{"location":"modules/AstroImages/guide/photometry/","page":"Extracting Photometry","title":"Extracting Photometry","text":"table = photometry(aps, subt)","category":"page"},{"location":"modules/AstroImages/guide/photometry/","page":"Extracting Photometry","title":"Extracting Photometry","text":"And plot them: ","category":"page"},{"location":"modules/AstroImages/guide/photometry/","page":"Extracting Photometry","title":"Extracting Photometry","text":"scatter(\n    table.xcenter,\n    table.ycenter,\n    aspectratio=1,\n    marker_z=table.aperture_sum,\n    markerstrokewidth=0,\n    label=\"\",\n    framestyle=:box,\n    background_inside=:black,\n    color=:white\n)","category":"page"},{"location":"modules/Cosmology/#Cosmology.jl","page":"Home","title":"Cosmology.jl","text":"","category":"section"},{"location":"modules/Cosmology/","page":"Home","title":"Home","text":"(Image: Build Status) (Image: Coverage Status)","category":"page"},{"location":"modules/Cosmology/","page":"Home","title":"Home","text":"Cosmology.jl provides functions for quick cosmological calculations, written in pure Julia. ","category":"page"},{"location":"modules/Cosmology/#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"modules/Cosmology/","page":"Home","title":"Home","text":"To install the package, enter pkg mode (])","category":"page"},{"location":"modules/Cosmology/","page":"Home","title":"Home","text":"pkg> add Cosmology","category":"page"},{"location":"modules/Cosmology/","page":"Home","title":"Home","text":"Then, to load the package","category":"page"},{"location":"modules/Cosmology/","page":"Home","title":"Home","text":"julia> using Cosmology","category":"page"},{"location":"modules/Cosmology/#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"modules/Cosmology/","page":"Home","title":"Home","text":"If you would like to contribute to Cosmology.jl, head over to our GitHub page and open an issue or pull request!","category":"page"},{"location":"modules/Cosmology/","page":"Home","title":"Home","text":"For any new features, we ask the contributors to add any relevant unit tests and bump the package version by one minor version.","category":"page"},{"location":"modules/AstroLib/ref/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"modules/AstroLib/ref/#Data-types","page":"Reference","title":"Data types","text":"","category":"section"},{"location":"modules/AstroLib/ref/#Observatory","page":"Reference","title":"Observatory","text":"","category":"section"},{"location":"modules/AstroLib/ref/","page":"Reference","title":"Reference","text":"AstroLib.jl defines a new Observatory type. This can be used to define a new object holding information about an observing site. It is a [composite type] whose fields are","category":"page"},{"location":"modules/AstroLib/ref/","page":"Reference","title":"Reference","text":"name (String type): the name of the site\nlatitude (Float64 type): North-ward latitude of the site in degrees\nlongitude (Float64 type): East-ward longitude of the site in degrees\naltitude (Float64 type): altitude of the site in meters\ntz (Float64 type): the number of hours of offset from UTC","category":"page"},{"location":"modules/AstroLib/ref/","page":"Reference","title":"Reference","text":"The type constructor Observatory can be used to create a new Observatory object. Its syntax is","category":"page"},{"location":"modules/AstroLib/ref/","page":"Reference","title":"Reference","text":"Observatory(name, lat, long, alt, tz)","category":"page"},{"location":"modules/AstroLib/ref/","page":"Reference","title":"Reference","text":"name should be a string; lat, long, and tz should be anything that can be converted to a floating number with ten function; alt should be a real number.","category":"page"},{"location":"modules/AstroLib/ref/","page":"Reference","title":"Reference","text":"A predefined list of some observing sites is provided with AstroLib.observatories constant. It is a dictionary whose keys are the abbreviated names of the observatories. For example, you can access information of the European Southern Observatory with","category":"page"},{"location":"modules/AstroLib/ref/","page":"Reference","title":"Reference","text":"julia> obs = AstroLib.observatories[\"eso\"]\nObservatory: European Southern Observatory\nlatitude:    -29.256666666666668°N\nlongitude:   -70.73°E\naltitude:    2347.0 m\ntime zone:   UTC-4\n\njulia> obs.longitude\n-70.73","category":"page"},{"location":"modules/AstroLib/ref/","page":"Reference","title":"Reference","text":"You can list all keys of the dictionary with","category":"page"},{"location":"modules/AstroLib/ref/","page":"Reference","title":"Reference","text":"keys(AstroLib.observatories)","category":"page"},{"location":"modules/AstroLib/ref/","page":"Reference","title":"Reference","text":"Feel free to contribute new sites or adjust information of already present ones.","category":"page"},{"location":"modules/AstroLib/ref/#Planet","page":"Reference","title":"Planet","text":"","category":"section"},{"location":"modules/AstroLib/ref/","page":"Reference","title":"Reference","text":"The package provides Planet type to hold information about Solar System planets. Its fields are","category":"page"},{"location":"modules/AstroLib/ref/","page":"Reference","title":"Reference","text":"Designation:\nname: the name\nPhysical characteristics:\nradius: mean radius in meters\neqradius: equatorial radius in meters\npolradius: polar radius in meters\nmass: mass in kilogram\nOrbital characteristics (epoch J2000):\necc: eccentricity of the orbit\naxis: semi-major axis of the orbit in meters\nperiod: sidereal orbital period in seconds","category":"page"},{"location":"modules/AstroLib/ref/","page":"Reference","title":"Reference","text":"The constructor has this syntax:","category":"page"},{"location":"modules/AstroLib/ref/","page":"Reference","title":"Reference","text":"Planet(name, radius, eqradius, polradius, mass, ecc, axis, period)","category":"page"},{"location":"modules/AstroLib/ref/","page":"Reference","title":"Reference","text":"The list of Solar System planets, from Mercury to Pluto, is available with AstroLib.planets dictionary. The keys of this dictionary are the lowercase names of the planets. For example:","category":"page"},{"location":"modules/AstroLib/ref/","page":"Reference","title":"Reference","text":"julia> AstroLib.planets[\"mercury\"]\nPlanet:            Mercury\nmean radius:       2.4397e6 m\nequatorial radius: 2.4397e6 m\npolar radius:      2.4397e6 m\nmass:              3.3011e23 kg\neccentricity:      0.20563069\nsemi-major axis:   5.790905e10 m\nperiod:            5.790905e10 s\n\njulia> AstroLib.planets[\"mars\"].eqradius\n3.3962e6\n\njulia> AstroLib.planets[\"saturn\"].mass\n5.6834e26","category":"page"},{"location":"modules/AstroLib/ref/#Functions-organized-by-category","page":"Reference","title":"Functions organized by category","text":"","category":"section"},{"location":"modules/AstroLib/ref/#Coordinates-and-positions","page":"Reference","title":"Coordinates and positions","text":"","category":"section"},{"location":"modules/AstroLib/ref/","page":"Reference","title":"Reference","text":"adstring(), aitoff(), altaz2hadec(), baryvel(), bprecess(), co_aberration(), co_nutate(), co_refract(), eci2geo(), eq2hor(), eqpole(), euler(), gcirc(), geo2eci(), geo2geodetic(), geo2mag(), geodetic2geo(), hadec2altaz(), helio_rv(), helio(), hor2eq(), jprecess(), mag2geo(), mean_obliquity(), planet_coords(), polrec(), posang(), precess(), precess_cd(), precess_xyz(), premat(), radec(), recpol(), true_obliquity(), zenpos()","category":"page"},{"location":"modules/AstroLib/ref/#Time-and-date","page":"Reference","title":"Time and date","text":"","category":"section"},{"location":"modules/AstroLib/ref/","page":"Reference","title":"Reference","text":"ct2lst(), daycnv(), get_date(), get_juldate(), helio_jd(), jdcnv(), juldate(), month_cnv(), nutate(), ydn2md(), ymd2dn()","category":"page"},{"location":"modules/AstroLib/ref/#Moon-and-sun","page":"Reference","title":"Moon and sun","text":"","category":"section"},{"location":"modules/AstroLib/ref/","page":"Reference","title":"Reference","text":"moonpos(), mphase(), sunpos(), xyz()","category":"page"},{"location":"modules/AstroLib/ref/#Utilities","page":"Reference","title":"Utilities","text":"","category":"section"},{"location":"modules/AstroLib/ref/","page":"Reference","title":"Reference","text":"airtovac(), calz_unred(), deredd(), flux2mag(), gal_uvw(), imf(), ismeuv(), kepler_solver(), lsf_rotate(), mag2flux(), paczynski(), planck_freq(), planck_wave(), rad2sec(), rhotheta(), sec2rad(), sixty(), sphdist(), ten(), tic_one(), ticpos(), tics(), trueanom(), uvbybeta(), vactoair()","category":"page"},{"location":"modules/AstroLib/ref/#Miscellaneous-(non-astronomy)-functions","page":"Reference","title":"Miscellaneous (non-astronomy) functions","text":"","category":"section"},{"location":"modules/AstroLib/ref/","page":"Reference","title":"Reference","text":"ordinal()","category":"page"},{"location":"modules/AstroLib/ref/#Types-and-functions-organized-alphabetically","page":"Reference","title":"Types and functions organized alphabetically","text":"","category":"section"},{"location":"modules/AstroLib/ref/","page":"Reference","title":"Reference","text":"Modules = [AstroLib]","category":"page"},{"location":"modules/AstroLib/ref/#AstroLib.POLELATLONG","page":"Reference","title":"AstroLib.POLELATLONG","text":"List of locations of North Magnetic Pole since 1590.\n\nThis is provided by World Magnetic Model (https://www.ngdc.noaa.gov/geomag/data/poles/NP.xy).\n\n\n\n\n\n","category":"constant"},{"location":"modules/AstroLib/ref/#AstroLib.observatories","page":"Reference","title":"AstroLib.observatories","text":"List of observing sites.  The observatories have Observatory type.\n\n\n\n\n\n","category":"constant"},{"location":"modules/AstroLib/ref/#AstroLib.planets","page":"Reference","title":"AstroLib.planets","text":"List of planets of the Solar System, from Mercury to Pluto.  The elements of the list have Planet type.\n\nReference for most quantities is the Planetary Fact Sheet: http://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html and the Keplerian Elements for Approximate Positions of the Major Planets: https://ssd.jpl.nasa.gov/txt/pelemt1.txt\n\n\n\n\n\n","category":"constant"},{"location":"modules/AstroLib/ref/#AstroLib.Observatory","page":"Reference","title":"AstroLib.Observatory","text":"Type holding information about an observing site.  Its fields are:\n\nname: the name of the site\nlatitude: North-ward latitude of the site in degrees\nlongitude: East-ward longitude of the site in degrees\naltitude: altitude of the site in meters\ntz: the number of hours of offset from UTC\n\n\n\n\n\n","category":"type"},{"location":"modules/AstroLib/ref/#AstroLib.Planet","page":"Reference","title":"AstroLib.Planet","text":"Type holding information about a planet.  Its fields are:\n\nDesignation:\n\nname: the name\n\nPhysical characteristics:\n\nradius: mean radius in meters\neqradius: equatorial radius in meters\npolradius: polar radius in meters\nmass: mass in kilogram\n\nOrbital characteristics (epoch J2000):\n\necc: eccentricity of the orbit\naxis: semi-major axis of the orbit in meters\nperiod: sidereal orbital period in seconds\n\nPosition characteristics (epoch J2000):\n\ninc: inclination in degrees\nasc_long: longitude of the ascending node in degrees\nper_long: longitude of perihelion in degrees\nmean_long: mean longitude in degrees\n\n\n\n\n\n","category":"type"},{"location":"modules/AstroLib/ref/#AstroLib.adstring-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractFloat","page":"Reference","title":"AstroLib.adstring","text":"adstring(ra::Real, dec::Real[, precision::Int=2, truncate::Bool=true]) -> string\nadstring([ra, dec]) -> string\nadstring(dec) -> string\nadstring([ra], [dec]) -> [\"string1\", \"string2\", ...]\n\nPurpose\n\nReturns right ascension and declination as string(s) in sexagesimal format.\n\nExplanation\n\nTakes right ascension and declination expressed in decimal format, converts them to sexagesimal and return a formatted string.  The precision of right ascension and declination can be specified.\n\nArguments\n\nArguments of this function are:\n\nra: right ascension in decimal degrees.  It is converted to hours before printing.\ndec: declination in decimal degrees.\n\nThe function can be called in different ways:\n\nTwo numeric arguments: first is ra, the second is dec.\nAn iterable (array, tuple) of two elements: (ra, dec).\nOne numeric argument: it is assumed only dec is provided.\n\nOptional keywords affecting the output format are always available:\n\nprecision (optional integer keyword): specifies the number of digits of declination seconds.  The number of digits for right ascension seconds is always assumed to be one more precision.  If the function is called with only dec as input, precision default to 1, in any other case defaults to 0.\ntruncate (optional boolean keyword): if true, then the last displayed digit in the output is truncated in precision rather than rounded.  This option is useful if adstring is used to form an official IAU name (see http://vizier.u-strasbg.fr/Dic/iau-spec.htx) with coordinate specification.\n\nOutput\n\nThe function returns one string.  The format of strings can be specified with precision and truncate keywords, see above.\n\nExample\n\njulia> using AstroLib\n\njulia> adstring(30.4, -1.23, truncate=true)\n\" 02 01 35.9  -01 13 48\"\n\njulia> adstring.([30.4, -15.63], [-1.23, 48.41], precision=1)\n2-element Array{String,1}:\n \" 02 01 36.00  -01 13 48.0\"\n \" 22 57 28.80  +48 24 36.0\"\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.airtovac-Tuple{Real}","page":"Reference","title":"AstroLib.airtovac","text":"airtovac(wave_air) -> wave_vacuum\n\nPurpose\n\nConverts air wavelengths to vacuum wavelengths.\n\nExplanation\n\nWavelengths are corrected for the index of refraction of air under standard conditions. Wavelength values below 2000 Å will not be altered, take care within 1 Å 2000 Å.  Uses relation of Ciddor (1996).\n\nArguments\n\nwave_air: the wavelength in air.\n\nOutput\n\nVacuum wavelength in angstroms.\n\nMethod\n\nUses relation of Ciddor (1996), Applied Optics 62, 958.\n\nExample\n\nIf the air wavelength is w = 6056.125 (a Krypton line), then airtovac(w) yields a vacuum wavelength of 6057.8019.\n\njulia> using AstroLib\n\njulia> airtovac(6056.125)\n6057.801930991426\n\nNotes\n\nvactoair converts vacuum wavelengths to air wavelengths.\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.aitoff-Tuple{Real, Real}","page":"Reference","title":"AstroLib.aitoff","text":"aitoff(l, b) -> x, y\n\nPurpose\n\nConvert longitude l and latitude b to (x, y) using an Aitoff projection.\n\nExplanation\n\nThis function can be used to create an all-sky map in Galactic coordinates with an equal-area Aitoff projection.  Output map coordinates are zero longitude centered.\n\nArguments\n\nl: longitude, scalar or vector, in degrees.\nb: latitude, number of elements as l, in degrees.\n\nCoordinates can be given also as a 2-tuple (l, b).\n\nOutput\n\n2-tuple (x, y).\n\nx: x coordinate, same number of elements as l.  x is normalized to be in -180 180.\ny: y coordinate, same number of elements as l.  y is normalized to be in -90 90.\n\nExample\n\nGet (x y) Aitoff coordinates of Sirius, whose Galactic coordinates are (22723 -8890).\n\njulia> using AstroLib\n\njulia> x, y = aitoff(227.23, -8.890)\n(-137.92196683723276, -11.772527357473054)\n\nNotes\n\nSee AIPS memo No. 46 (ftp://ftp.aoc.nrao.edu/pub/software/aips/TEXT/PUBL/AIPSMEMO46.PS), page 4, for details of the algorithm.  This version of aitoff assumes the projection is centered at b=0 degrees.\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.altaz2hadec-Tuple{Real, Real, Real}","page":"Reference","title":"AstroLib.altaz2hadec","text":"altaz2hadec(alt, az, lat) -> ha, dec\n\nPurpose\n\nConvert Horizon (Alt-Az) coordinates to Hour Angle and Declination.\n\nExplanation\n\nCan deal with the NCP singularity.  Intended mainly to be used by program hor2eq.\n\nArguments\n\nInput coordinates may be either a scalar or an array, of the same dimension.\n\nalt: local apparent altitude, in degrees, scalar or array.\naz: the local apparent azimuth, in degrees, scalar or vector, measured east of north!!!  If you have measured azimuth west-of-south (like the book Meeus does), convert it to east of north via: az = (az + 180) % 360.\nlat: the local geodetic latitude, in degrees, scalar or array.\n\nalt and az can be given as a 2-tuple (alt, az).\n\nOutput\n\n2-tuple (ha, dec)\n\nha: the local apparent hour angle, in degrees.  The hour angle is the time that right ascension of 0 hours crosses the local meridian.  It is unambiguously defined.\ndec: the local apparent declination, in degrees.\n\nThe output coordinates are always floating points and have the same type (scalar or array) as the input coordinates.\n\nExample\n\nArcturus is observed at an apparent altitude of 59d,05m,10s and an azimuth (measured east of north) of 133d,18m,29s while at the latitude of +43.07833 degrees.  What are the local hour angle and declination of this object?\n\njulia> using AstroLib\n\njulia> ha, dec = altaz2hadec(ten(59,05,10), ten(133,18,29), 43.07833)\n(336.6828582472844, 19.182450965120402)\n\nThe widely available XEPHEM code gets:\n\nHour Angle = 336.683\nDeclination = 19.1824\n\nNotes\n\nhadec2altaz converts Hour Angle and Declination to Horizon (Alt-Az) coordinates.\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.baryvel-Tuple{Real}","page":"Reference","title":"AstroLib.baryvel","text":"baryvel(dje, deq) -> dvelh, dvelb\n\nPurpose\n\nCalculates heliocentric and barycentric velocity components of Earth.\n\nExplanation\n\nBaryvel takes into account the Earth-Moon motion, and is useful for radial velocity work to an accuracy of ~1 m/s.\n\nArguments\n\ndje: julian ephemeris date\ndeq (optional): epoch of mean equinox of dvelh and dvelb. If deq is not provided, then it is assumed to be equal to dje.\n\nOutput\n\ndvelh: heliocentric velocity component. in km/s\ndvelb: barycentric velocity component. in km/s\n\nExample\n\nCompute the radial velocity of the Earth toward Altair on 15-Feb-1994 using both the original Stumpf algorithm.\n\njulia> using AstroLib\n\njulia> jd = jdcnv(1994, 2, 15, 0)\n2.4493985e6\n\njulia> baryvel(jd, 2000)\n([-17.0724258266945, -22.81120895274765, -9.889315408506354], [-17.080834081384847, -22.80470807516409, -9.886258269159352])\n\nNotes\n\nThe 3-vectors outputs dvelh and dvelb are given in a right-handed coordinate system with the +X axis toward the Vernal Equinox, and +Z axis toward the celestial pole.\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.bprecess","page":"Reference","title":"AstroLib.bprecess","text":"bprecess(ra, dec[, epoch]) -> ra1950, dec1950\nbprecess(ra, dec, muradec[, parallax=parallax, radvel=radvel]) -> ra1950, dec1950\n\nPurpose\n\nPrecess positions from J2000.0 (FK5) to B1950.0 (FK4).\n\nExplanation\n\nCalculates the mean place of a star at B1950.0 on the FK4 system from the mean place at J2000.0 on the FK5 system.\n\nbprecess function has two methods, one for each of the following cases:\n\nthe proper motion is known and non-zero\nthe proper motion is unknown or known to be exactly zero (i.e. extragalactic radio sources).  Better precision can be achieved in this case by inputting the epoch of the original observations.\n\nArguments\n\nThe function has 2 methods.  The common mandatory arguments are:\n\nra: input J2000 right ascension, in degrees.\ndec: input J2000 declination, in degrees.\n\nThe two methods have a different third argument (see \"Explanation\" section for more details).  It can be one of the following:\n\nmuradec: 2-element vector containing the proper motion in seconds of arc per tropical century in right ascension and declination.\nepoch: scalar giving epoch of original observations.\n\nIf none of these two arguments is provided (so bprecess is fed only with right ascension and declination), it is assumed that proper motion is exactly zero and epoch = 2000.\n\nIf it is used the method involving muradec argument, the following keywords are available:\n\nparallax (optional numerical keyword): stellar parallax, in seconds of arc.\nradvel (optional numerical keyword): radial velocity in km/s.\n\nRight ascension and declination can be passed as the 2-tuple (ra, dec).  You can also pass ra, dec, parallax, and radvel as arrays, all of the same length N.  In that case, muradec should be a matrix 2×N.\n\nOutput\n\nThe 2-tuple of right ascension and declination in 1950, in degrees, of input coordinates is returned.  If ra and dec (and other possible optional arguments) are arrays, the 2-tuple of arrays (ra1950, dec1950) of the same length as the input coordinates is returned.\n\nMethod\n\nThe algorithm is taken from the Explanatory Supplement to the Astronomical Almanac 1992, page 186.  See also Aoki et al (1983), A&A, 128, 263.  URL: http://adsabs.harvard.edu/abs/1983A%26A...128..263A.\n\nExample\n\nThe SAO2000 catalogue gives the J2000 position and proper motion for the star HD\n\nFind the B1950 position.\n\nRA(2000) = 13h 42m 12.740s\nDec(2000) = 8d 23' 17.69''\nMu(RA) = -.0257 s/yr\nMu(Dec) = -.090 ''/yr\n\njulia> using AstroLib\n\njulia> muradec = 100*[-15*0.0257, -0.090]; # convert to century proper motion\n\njulia> ra = ten(13, 42, 12.74)*15;\n\njulia> decl = ten(8, 23, 17.69);\n\njulia> adstring(bprecess(ra, decl, muradec), precision=2)\n\" 13 39 44.526  +08 38 28.63\"\n\nNotes\n\n\"When transferring individual observations, as opposed to catalog mean place, the safest method is to transform the observations back to the epoch of the observation, on the FK4 system (or in the system that was used to to produce the observed mean place), convert to the FK5 system, and transform to the the epoch and equinox of J2000.0\" – from the Explanatory Supplement (1992), p. 180\n\njprecess performs the precession to J2000 coordinates.\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroLib/ref/#AstroLib.calz_unred","page":"Reference","title":"AstroLib.calz_unred","text":"calz_unred(wave, flux, ebv[, r_v]) -> deredden_wave\n\nPurpose\n\nDeredden a galaxy spectrum using the Calzetti et al. (2000) recipe.\n\nExplanation\n\nCalzetti et al.  (2000, ApJ 533, 682; http://adsabs.harvard.edu/abs/2000ApJ...533..682C) developed a recipe for dereddening the spectra of galaxies where massive stars dominate the radiation output, valid between 012 to 22 microns.  (calz_unred extrapolates between 012 and 00912 microns.)\n\nArguments\n\nwave: wavelength (Angstroms)\nflux: calibrated flux.\nebv: color excess E(B-V).  If a negative ebv is supplied, then fluxes will be reddened rather than deredenned.  Note that the supplied color excess should be that derived for the stellar continuum, EBV(stars), which is related to the reddening derived from the gas, EBV(gas), via the Balmer decrement by EBV(stars) = 0.44*EBV(gas).\nr_v (optional): ratio of total to selective extinction, default is 4.05.  Calzetti et al. (2000) estimate r_v = 405 pm 080 from optical-IR observations of 4 starbursts.\n\nOutput\n\nUnreddened flux, same units as flux.  Flux values will be left unchanged outside valid domain (00912 - 22 microns).\n\nExample\n\nEstimate how a flat galaxy spectrum (in wavelength) between 1200 Å and 3200 Å is altered by a reddening of E(B-V) = 0.1.\n\nwave = collect(1200:50:3150);\nflux = ones(wave);\nflux_new = calz_unred.(wave, flux, -0.1);\n\nUsing a plotting tool you can visualize the unreddend flux.  For example, with PyPlot.jl\n\nusing PyPlot\nplot(wave, flux_new)\n\nNotes\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroLib/ref/#AstroLib.co_aberration","page":"Reference","title":"AstroLib.co_aberration","text":"co_aberration(jd, ra, dec[, eps=NaN]) -> d_ra, d_dec\n\nPurpose\n\nCalculate changes to right ascension and declination due to the effect of annual aberration\n\nExplanation\n\nWith reference to Meeus, Chapter 23\n\nArguments\n\njd: julian date, scalar or vector\nra: right ascension in degrees, scalar or vector\ndec: declination in degrees, scalar or vector\neps (optional): true obliquity of the ecliptic (in radians). It will be calculated if no argument is specified.\n\nOutput\n\nThe 2-tuple (d_ra, d_dec):\n\nd_ra: correction to right ascension due to aberration, in arc seconds\nd_dec: correction to declination due to aberration, in arc seconds\n\nExample\n\nCompute the change in RA and Dec of Theta Persei (RA = 2h46m,11.331s, Dec = 49d20',54.5'') due to aberration on 2028 Nov 13.19 TD\n\njulia> using AstroLib\n\njulia> jd = jdcnv(2028,11,13,4, 56)\n2.4620887055555554e6\n\njulia> co_aberration(jd,ten(2,46,11.331)*15,ten(49,20,54.54))\n(30.04404628365077, 6.699400463119431)\n\ndra = 30.04404628365103'' (≈ 2.003s) ddec = 6.699400463118504''\n\nNotes\n\nCode of this function is based on IDL Astronomy User's Library.\n\nThe output dra is not multiplied by cos(dec), so that apparentra = ra + d_ra/3600.\n\nThese formula are from Meeus, Chapters 23.  Accuracy is much better than 1 arcsecond. The maximum deviation due to annual aberration is 20.49'' and occurs when the Earth's velocity is perpendicular to the direction of the star.\n\nThis function calls true_obliquity and sunpos.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroLib/ref/#AstroLib.co_nutate-Tuple{Real, Real, Real}","page":"Reference","title":"AstroLib.co_nutate","text":"co_nutate(jd, ra, dec) -> d_ra, d_dec, eps, d_psi, d_eps\n\nPurpose\n\nCalculate changes in RA and Dec due to nutation of the Earth's rotation\n\nExplanation\n\nCalculates necessary changes to ra and dec due to the nutation of the Earth's rotation axis, as described in Meeus, Chap 23. Uses formulae from Astronomical Almanac, 1984, and does the calculations in equatorial rectangular coordinates to avoid singularities at the celestial poles.\n\nArguments\n\njd: julian date, scalar or vector\nra: right ascension in degrees, scalar or vector\ndec: declination in degrees, scalar or vector\n\nOutput\n\nThe 5-tuple (d_ra, d_dec, eps, d_psi, d_eps):\n\nd_ra: correction to right ascension due to nutation, in degrees\nd_dec: correction to declination due to nutation, in degrees\neps: the true obliquity of the ecliptic\nd_psi: nutation in the longitude of the ecliptic\nd_eps: nutation in the obliquity of the ecliptic\n\nExample\n\nExample 23a in Meeus: On 2028 Nov 13.19 TD the mean position of Theta Persei is 2h 46m 11.331s 49d 20' 54.54''. Determine the shift in position due to the Earth's nutation.\n\njulia> using AstroLib\n\njulia> jd = jdcnv(2028,11,13,4,56)\n2.4620887055555554e6\n\njulia> co_nutate(jd,ten(2,46,11.331) * 15,ten(49,20,54.54))\n(0.004400660977140092, 0.00172668646508356, 0.40904016038217555, 14.859389427896472, 2.703809037235057)\n\nNotes\n\nCode of this function is based on IDL Astronomy User's Library.\n\nThe output of d_ra and d_dec in IDL AstroLib is in arcseconds, however it is in degrees here.\n\nThis function calls mean_obliquity and nutate.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.co_refract","page":"Reference","title":"AstroLib.co_refract","text":"co_refract(old_alt[, altitude=0, pressure=NaN, temperature=NaN,\n           epsilon=0.25, to_observe=false]) -> aout\n\nPurpose\n\nCalculate correction to altitude due to atmospheric refraction.\n\nExplanation\n\nBecause the index of refraction of air is not precisely 1.0, the atmosphere bends all incoming light, making a star or other celestial object appear at a slightly different altitude (or elevation) than it really is.  It is important to understand the following definitions:\n\nObserved Altitude: The altitude that a star is seen to be, with a telescope. This is where it appears in the sky. This is should be always greater than the apparent altitude.\nApparent Altitude: The altitude that a star would be at, if ~there were no atmosphere~ (sometimes called the \"true\" altitude). This is usually calculated from an object's celestial coordinates. Apparent altitude should always be smaller than the observed altitude.\n\nThus, for example, the Sun's apparent altitude when you see it right on the horizon is actually -34 arcminutes.\n\nThis program uses a couple of simple formulae to estimate the effect for most optical and radio wavelengths. Typically, you know your observed altitude (from an observation), and want the apparent altitude. To go the other way, this program uses an iterative approach.\n\nArguments\n\nold_alt: observed altitude in degrees. If to_observe is set to true, this should be apparent altitude\naltitude (optional): the height of the observing location, in meters. This is only used to determine an approximate temperature and pressure, if these are not specified separately. Default is 0 i.e. sea level\npressure (optional): the pressure at the observing location, in millibars. Default is NaN\ntemperature (optional): the temperature at the observing location, in Kelvins. Default is NaN\nepsilon (optional): the accuracy to obtain, in arcseconds. If to_observe is true, then it will be calculated. Default is 0.25 arcseconds\nto_observe (optional boolean keyword): if set to true, it is assumed that old_alt has apparent altitude as its input and the observed altitude will be found\n\nOutput\n\naout: apparent altitude, in degrees. Observed altitude is returned if to_observe is set to true\n\nExample\n\nThe lower limb of the Sun is observed to have altitude of 0d 30'. Calculate the the true (i.e. apparent) altitude of the Sun's lower limb using mean  conditions of air pressure and temperature.\n\njulia> using AstroLib\n\njulia> co_refract(0.5)\n0.02584736873098442\n\nNotes\n\nIf altitude is set but the temperature or pressure is not, the program will make an intelligent guess for the temperature and pressure.\n\nWavelength Dependence\n\nThis correction is 0 at zenith, about 1 arcminute at 45 degrees, and 34 arcminutes at the horizon for optical wavelengths. The correction is non-negligible at all wavelengths, but is not very easily calculable. These formulae assume a wavelength of 550 nm, and will be accurate to about 4 arcseconds for all visible wavelengths, for elevations of 10 degrees and higher. Amazingly, they are also accurate for radio frequencies less than ~ 100 GHz.\n\nReferences\n\nMeeus, Astronomical Algorithms, Chapter 15.\nExplanatory Supplement to the Astronomical Almanac, 1992.\nMethods of Experimental Physics, Vol 12 Part B, Astrophysics, Radio Telescopes, Chapter 2.5, \"Refraction Effects in the Neutral Atmosphere\", by R.K. Crane.\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroLib/ref/#AstroLib.co_refract_forward-Tuple{Real, Real, Real}","page":"Reference","title":"AstroLib.co_refract_forward","text":"co_refract_forward(alt, pre, temp) -> ref\n\nPurpose\n\nA function used by co_refract to find apparent (or observed) altitude\n\nArguments\n\nalt: the observed (or apparent) altitude, in degrees\npre: pressure, in millibars\ntemp: temperature, in Kelvins\n\nOutput\n\nref: the atmospheric refraction, in minutes of arc\n\nNotes\n\nThe atmospheric refraction is calculated by Saemundsson's formula\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.ct2lst-Tuple{Real, Real}","page":"Reference","title":"AstroLib.ct2lst","text":"ct2lst(longitude, jd) -> local_sidereal_time\nct2lst(longitude, tz, date) -> local_sidereal_time\n\nPurpose\n\nConvert from Local Civil Time to Local Mean Sidereal Time.\n\nArguments\n\nThe function can be called in two different ways.  The only argument common to both methods is longitude:\n\nlongitude: the longitude in degrees (east of Greenwich) of the place for which the local sidereal time is desired.  The Greenwich mean sidereal time (GMST) can be found by setting longitude = 0.\n\nThe civil date to be converted to mean sidereal time can be specified either by providing the Julian days:\n\njd: this is number of Julian days for the date to be converted.\n\nor the time zone and the date:\n\ntz: the time zone of the site in hours, positive East of the Greenwich meridian (ahead of GMT).  Use this parameter to easily account for Daylight Savings time (e.g. -4=EDT, -5 = EST/CDT).\ndate: this is the local civil time with type DateTime.\n\nOutput\n\nThe local sidereal time for the date/time specified in hours.\n\nMethod\n\nThe Julian days of the day and time is question is used to determine the number of days to have passed since 2000-01-01.  This is used in conjunction with the GST of that date to extrapolate to the current GST; this is then used to get the LST.  See Astronomical Algorithms by Jean Meeus, p. 84 (Eq. 11-4) for the constants used.\n\nExample\n\nFind the Greenwich mean sidereal time (GMST) on 2008-07-30 at 15:53 in Baltimore, Maryland (longitude=-76.72 degrees).  The timezone is EDT or tz=-4\n\njulia> using AstroLib, Dates\n\njulia> lst = ct2lst(-76.72, -4, DateTime(2008, 7, 30, 15, 53))\n11.356505172312609\n\njulia> sixty(lst)\n3-element StaticArrays.SArray{Tuple{3},Float64,1,3} with indices SOneTo(3):\n 11.0\n 21.0\n 23.418620325392112\n\nFind the Greenwich mean sidereal time (GMST) on 2015-11-24 at 13:21 in Heidelberg, Germany (longitude=08° 43' E).  The timezone is CET or tz=1. Provide ct2lst only with the longitude of the place and the number of Julian days.\n\njulia> using AstroLib, Dates\n\njulia> longitude=ten(8, 43); # Convert longitude to decimals.\n\njulia> jd = jdcnv(DateTime(2015, 11, 24, 13, 21) - Dates.Hour(1));\n# Get number of Julian days. Remember to subtract the time zone in\n# order to convert local time to UTC.\n\njulia> lst = ct2lst(longitude, jd) # Calculate Greenwich Mean Sidereal Time.\n17.140685171005316\n\njulia> sixty(lst)\n3-element StaticArrays.SArray{Tuple{3},Float64,1,3} with indices SOneTo(3):\n 17.0\n  8.0\n 26.466615619137883\n\nNotes\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.daycnv","page":"Reference","title":"AstroLib.daycnv","text":"daycnv(julian_days) -> DateTime\n\nPurpose\n\nConverts Julian days number to Gregorian calendar dates.\n\nExplanation\n\nTakes the number of Julian calendar days since epoch -4713-11-24T12:00:00 and returns the corresponding proleptic Gregorian Calendar date.\n\nArgument\n\njulian_days: Julian days number.\n\nOutput\n\nProleptic Gregorian Calendar date, of type DateTime, corresponding to the given Julian days number.\n\nExample\n\njulia> using AstroLib\n\njulia> daycnv(2440000)\n1968-05-23T12:00:00\n\nNotes\n\njdcnv is the inverse of this function.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroLib/ref/#AstroLib.deredd-NTuple{5, Real}","page":"Reference","title":"AstroLib.deredd","text":"deredd(Eby, by, m1, c1, ub) -> by0, m0, c0, ub0\n\nPurpose\n\nDeredden stellar Stromgren parameters given for a value of E(b-y)\n\nArguments\n\nEby: color index E(b-y), scalar (E(b-y) = 0.73*E(B-V))\nby: b-y color (observed)\nm1: Stromgren line blanketing parameter (observed)\nc1: Stromgren Balmer discontinuity parameter (observed)\nub: u-b color (observed)\n\nAll arguments can be either scalars or arrays all of the same length.\n\nOutput\n\nThe 4-tuple (by0, m0, c0, ub0).\n\nby0: b-y color (dereddened)\nm0: line blanketing index (dereddened)\nc0: Balmer discontinuity parameter (dereddened)\nub0: u-b color (dereddened)\n\nThese are scalars or arrays of the same length as the input arguments.\n\nExample\n\njulia> using AstroLib\n\njulia> deredd(0.5, 0.2, 1.0, 1.0, 0.1)\n(-0.3, 1.165, 0.905, -0.665)\n\nNotes\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.eci2geo-NTuple{4, Real}","page":"Reference","title":"AstroLib.eci2geo","text":"eci2geo(x, y, z, jd) -> latitude, longitude, altitude\n\nPurpose\n\nConvert Earth-centered inertial coordinates to geographic spherical coordinates.\n\nExplanation\n\nConverts from ECI (Earth-Centered Inertial) (x, y, z) rectangular coordinates to geographic spherical coordinates (latitude, longitude, altitude).  Julian day is also needed as input.\n\nECI coordinates are in km from Earth center at the supplied time (True of Date). Geographic coordinates assume the Earth is a perfect sphere, with radius equal to its equatorial radius.\n\nArguments\n\nx: ECI x coordinate at jd, in kilometers.\ny: ECI y coordinate at jd, in kilometers.\nz: ECI z coordinate at jd, in kilometers.\njd: Julian days.\n\nThe three coordinates can be passed as a 3-tuple (x, y, z).  In addition, x, y, z, and jd can be given as arrays of the same length.\n\nOutput\n\nThe 3-tuple of geographical coordinate (latitude, longitude, altitude).\n\nlatitude: latitude, in degrees.\nlongitude: longitude, in degrees.\naltitude: altitude, in kilometers.\n\nIf ECI coordinates are given as arrays, a 3-tuple of arrays of the same length is returned.\n\nExample\n\nObtain the geographic direction of the vernal point on 2015-06-30T14:03:12.857, in geographic coordinates, at altitude 600 km.  Note: equatorial radii of Solar System planets in meters are stored into AstroLib.planets dictionary.\n\njulia> using AstroLib\n\njulia> x = AstroLib.planets[\"earth\"].eqradius*1e-3 + 600;\n\njulia> lat, long, alt = eci2geo(x, 0, 0, jdcnv(\"2015-06-30T14:03:12.857\"))\n(0.0, 230.87301833205856, 600.0)\n\nThese coordinates can be further transformed into geodetic coordinates using geo2geodetic or into geomagnetic coordinates using geo2mag.\n\nNotes\n\ngeo2eci converts geographic spherical coordinates to Earth-centered inertial coordinates.\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.eq2hor","page":"Reference","title":"AstroLib.eq2hor","text":"eq2hor(ra, dec, jd[, obsname; ws=false, B1950=false, precession=true, nutate=true,\n       aberration=true, refract=true, pressure=NaN, temperature=NaN]) -> alt, az, ha\n\neq2hor(ra, dec, jd, lat, lon[, altitude=0; ws=false, B1950=false,\n       precession=true, nutate=true, aberration=true, refract=true,\n       pressure=NaN, temperature=NaN]) -> alt, az, ha\n\nPurpose\n\nConvert celestial  (ra-dec) coords to local horizon coords (alt-az).\n\nExplanation\n\nThis code calculates horizon (alt,az) coordinates from equatorial (ra,dec) coords. It performs precession, nutation, aberration, and refraction corrections.\n\nArguments\n\nThis function has two base methods.  With one you can specify the name of the observatory, if present in AstroLib.observatories, with the other one you can provide the coordinates of the observing site and, optionally, the altitude.\n\nCommon mandatory arguments:\n\nra: right ascension of object, in degrees\ndec: declination of object, in degrees\njd: julian date\n\nOther positional arguments:\n\nobsname: set this to a valid observatory name in AstroLib.observatories.\n\nor\n\nlat: north geodetic latitude of location, in degrees.\nlon: AST longitude of location, in degrees. You can specify west longitude with a negative sign.\naltitude: the altitude of the observing location, in meters.  It is 0 by default\n\nOptional keyword arguments:\n\nws (optional boolean keyword): set this to true to get the azimuth measured westward from south (not East of North)\nB1950 (optional boolean keyword): set this to true if the ra and dec are specified in B1950 (FK4 coordinates) instead of J2000 (FK5). This is false by default\nprecession (optional boolean keyword): set this to false for no precession correction, true by default\nnutate (optional boolean keyword): set this to false for no nutation, true by default\naberration (optional boolean keyword): set this to false for no aberration correction, true by default\nrefract (optional boolean keyword): set this to false for no refraction correction, true by default\npressure (optional keyword): the pressure at the observing location, in millibars. Default value is NaN\ntemperature (optional keyword): the temperature at the observing location, in Kelvins. Default value is NaN\n\nOutput\n\nalt: altitude of horizon coords, in degrees\naz: azimuth angle measured East from North (unless ws is true), in degrees\nha: hour angle, in degrees\n\nExample\n\njulia> using AstroLib\n\njulia> alt_o, az_o = eq2hor(ten(6,40,58.2)*15, ten(9,53,44), 2460107.25, ten(50,31,36),\n                            ten(6,51,18), 369, pressure = 980, temperature=283)\n(16.423991509721567, 265.60656932130564, 76.11502253130612)\n\njulia> adstring(az_o, alt_o)\n\" 17 42 25.6  +16 25 26\"\n\nNotes\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroLib/ref/#AstroLib.eqpole-Tuple{Real, Real}","page":"Reference","title":"AstroLib.eqpole","text":"eqpole(l, b[; southpole = false]) -> x, y\n\nPurpose\n\nConvert right ascension l and declination b to coordinate (x y) using an equal-area polar projection.\n\nExplanation\n\nThe output x and y coordinates are scaled to be in the range -90 90 and to go from equator to pole to equator.  Output map points can be centered on the north pole or south pole.\n\nArguments\n\nl: longitude, scalar or vector, in degrees\nb: latitude, same number of elements as right ascension, in degrees\nsouthpole (optional boolean keyword): keyword to indicate that the plot is to be centered on the south pole instead of the north pole.  Default is false.\n\nOutput\n\nThe 2-tuple (x y):\n\nx coordinate, same number of elements as right ascension, normalized to be in the range -90 90.\ny coordinate, same number of elements as declination, normalized to be in the range -90 90.\n\nExample\n\njulia> using AstroLib\n\njulia> eqpole(100, 35, southpole=true)\n(-111.18287262822456, -19.604540237028665)\n\njulia> eqpole(80, 19)\n(72.78853915267848, 12.83458333897169)\n\nNotes\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.euler-Tuple{Real, Real, Integer}","page":"Reference","title":"AstroLib.euler","text":"euler(ai, bi, select[, FK4=true, radians=true])\n\nPurpose\n\nTransform between Galactic, celestial, and ecliptic coordinates.\n\nExplanation\n\nThe function is used by the astro procedure.\n\nArguments\n\nai: input longitude, scalar or vector.\nbi: input latitude, scalar or vector.\nselect : integer input specifying type of coordinate transformation. SELECT   From          To     | SELECT   From       To    1   RA-Dec (2000) Galactic |   4    Ecliptic   RA-Dec    2   Galactic      RA-DEC   |   5    Ecliptic   Galactic    3   RA-Dec        Ecliptic |   6    Galactic   Ecliptic\nFK4 (optional boolean keyword) : if this keyword is set to true, then input and output celestial and ecliptic coordinates should be given in equinox B1950. When false, by default, they should be given in equinox J2000.\nradians (optional boolean keyword) : if this keyword is set to true, all input and output angles are in radians rather than degrees.\n\nOutput\n\na 2-tuple (ao, bo):\n\nao: output longitude in degrees.\nbo: output latitude in degrees.\n\nExample\n\nFind the Galactic coordinates of Cyg X-1 (ra=299.590315, dec=35.201604)\n\njulia> using AstroLib\n\njulia> euler(299.590315, 35.201604, 1)\n(71.33498957116959, 3.0668335310640984)\n\nNotes\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.flux2mag","page":"Reference","title":"AstroLib.flux2mag","text":"flux2mag(flux[, zero_point, ABwave=number]) -> magnitude\n\nPurpose\n\nConvert from flux expressed in erg/(s cm² Å) to magnitudes.\n\nExplanation\n\nThis is the reverse of mag2flux.\n\nArguments\n\nflux: the flux to be converted in magnitude, expressed in erg/(s cm² Å).\nzero_point: the zero point level of the magnitude.  If not\n\nsupplied then defaults to 21.1 (Code et al 1976).  Ignored if the ABwave  keyword is supplied\n\nABwave (optional numeric keyword): wavelength in Angstroms.\n\nIf supplied, then returns Oke AB magnitudes (Oke & Gunn 1983, ApJ, 266, 713;  http://adsabs.harvard.edu/abs/1983ApJ...266..713O).\n\nOutput\n\nThe magnitude.\n\nIf the ABwave keyword is set then magnitude is given by the expression\n\ntextABmag = -25log_10(f) - 5log_10(textABwave) - 2406\n\nOtherwise, magnitude is given by the expression\n\ntextmag = -25log_10(textflux) - textzero point\n\nExample\n\njulia> using AstroLib\n\njulia> flux2mag(5.2e-15)\n14.609991640913002\n\njulia> flux2mag(5.2e-15, 15)\n20.709991640913003\n\njulia> flux2mag(5.2e-15, ABwave=15)\n27.423535345634598\n\nNotes\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroLib/ref/#AstroLib.gal_uvw-NTuple{6, Real}","page":"Reference","title":"AstroLib.gal_uvw","text":"gal_uvw(ra, dec, pmra, pmdec, vrad, plx[, lsr=true]) -> u, v, w\n\nPurpose\n\nCalculate the Galactic space velocity (u v w) of a star.\n\nExplanation\n\nCalculates the Galactic space velocity (u v w) of a star given its (1) coordinates, (2) proper motion, (3) parallax, and (4) radial velocity.\n\nArguments\n\nUser must supply a position, proper motion, radial velocity and parallax. Either scalars or arrays all of the same length can be supplied.\n\n(1) Position:\n\nra: right ascension, in degrees\ndec: declination, in degrees\n\n(2) Proper Motion\n\npmra: proper motion in right ascension in arc units (typically milli-arcseconds/yr).  If given mu_alpha – proper motion in seconds of time/year – then this is equal to 15 mu_alpha cos(textdec).\npmdec: proper motion in declination (typically mas/yr).\n\n(3) Radial Velocity\n\nvrad: velocity in km/s\n\n(4) Parallax\n\nplx: parallax with same distance units as proper motion measurements typically milliarcseconds (mas)\n\nIf you know the distance in parsecs, then set plx to 1000textdistance, if proper motion measurements are given in milli-arcseconds/yr.\n\nThere is an additional optional keyword:\n\nlsr (optional boolean keyword): if this keyword is set to true, then the output velocities will be corrected for the solar motion (u v w)_odot = (-85 1338 649) (Coşkunoǧlu et al. 2011 MNRAS, 412, 1237; DOI:10.1111/j.1365-2966.2010.17983.x) to the local standard of rest (LSR).  Note that the value of the solar motion through the LSR remains poorly determined.\n\nOutput\n\nThe 3-tuple (u v w)\n\nu: velocity (km/s) positive toward the Galactic anticenter\nv: velocity (km/s) positive in the direction of Galactic rotation\nw: velocity (km/s) positive toward the North Galactic Pole\n\nMethod\n\nFollows the general outline of Johnson & Soderblom (1987, AJ, 93, 864; DOI:10.1086/114370) except that u is positive outward toward the Galactic anticenter, and the J2000 transformation matrix to Galactic coordinates is taken from the introduction to the Hipparcos catalog.\n\nExample\n\nCompute the U,V,W coordinates for the halo star HD 6755.  Use values from Hipparcos catalog, and correct to the LSR.\n\njulia> using AstroLib\n\njulia> ra=ten(1,9,42.3)*15.; dec = ten(61,32,49.5);\n\njulia> pmra = 627.89;  pmdec = 77.84; # mas/yr\n\njulia> vrad = -321.4; dis = 129; # distance in parsecs\n\njulia> u, v, w = gal_uvw(ra, dec, pmra, pmdec, vrad, 1e3/dis, lsr=true)\n(118.2110474553902, -466.4828898385057, 88.16573278565097)\n\nNotes\n\nThis function does not take distance as input.  See \"Arguments\" section above for how to provide it using parallax argument.\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.gcirc-Tuple{Integer, Vararg{Real, 4}}","page":"Reference","title":"AstroLib.gcirc","text":"gcirc(units, ra1, dec1, ra2, dec2) -> angular_distance\n\nPurpose\n\nComputes rigorous great circle arc distances.\n\nExplanation\n\nInput position can be either radians, sexagesimal right ascension and declination, or degrees.\n\nArguments\n\nunits: integer, can be either 0, or 1, or 2.  Describes units of inputs and output:\n0: everything (input right ascensions and declinations, and output distance) is radians\n1: right ascensions are in decimal hours, declinations in decimal degrees, output distance in arc seconds\n2: right ascensions and declinations are in degrees, output distance in arc seconds\nra1:  right ascension or longitude of point 1\ndec1: declination or latitude of point 1\nra2: right ascension or longitude of point 2\ndec2: declination or latitude of point 2\n\nBoth ra1 and dec1, and ra2 and dec2 can be given as 2-tuples (ra1, dec1) and (ra2, dec2).\n\nOutput\n\nAngular distance on the sky between points 1 and 2, as a AbstractFloat.  See units argument above for the units.\n\nMethod\n\n\"Haversine formula\" see http://en.wikipedia.org/wiki/Great-circle_distance.\n\nExample\n\njulia> using AstroLib\n\njulia> gcirc(0, 120, -43, 175, +22)\n1.590442261600714\n\nNotes\n\nThe function sphdist provides an alternate method of computing a spherical\n\ndistance.\n\nThe Haversine formula can give rounding errors for antipodal points.\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.geo2eci-NTuple{4, Real}","page":"Reference","title":"AstroLib.geo2eci","text":"geo2eci(latitude, longitude, altitude, jd) -> x, y, z\n\nPurpose\n\nConvert geographic spherical coordinates to Earth-centered inertial coordinates.\n\nExplanation\n\nConverts from geographic spherical coordinates (latitude, longitude, altitude) to ECI (Earth-Centered Inertial) (x, y, z) rectangular coordinates.  Julian days is also needed.\n\nGeographic coordinates assume the Earth is a perfect sphere, with radius equal to its equatorial radius.  ECI coordinates are in km from Earth center at epoch TOD (True of Date).\n\nArguments\n\nlatitude: geographic latitude, in degrees.\nlongitude: geographic longitude, in degrees.\naltitude: geographic altitude, in kilometers.\njd: Julian days.\n\nThe three coordinates can be passed as a 3-tuple (latitude, longitude, altitude).  In addition, latitude, longitude, altitude, and jd can be given as arrays of the same length.\n\nOutput\n\nThe 3-tuple of ECI (x, y, z) coordinates, in kilometers.  The TOD epoch is the supplied jd time.\n\nIf geographical coordinates are given as arrays, a 3-tuple of arrays of the same length is returned.\n\nExample\n\nObtain the ECI coordinates of the intersection of the equator and Greenwich's meridian on 2015-06-30T14:03:12.857\n\njulia> using AstroLib\n\njulia> geo2eci(0, 0, 0, jdcnv(\"2015-06-30T14:03:12.857\"))\n(-4024.8671780315185, 4947.835465127513, 0.0)\n\nNotes\n\neci2geo converts Earth-centered inertial coordinates to geographic spherical coordinates.\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.geo2geodetic-NTuple{5, Real}","page":"Reference","title":"AstroLib.geo2geodetic","text":"geo2geodetic(latitude, longitude, altitude) -> latitude, longitude, altitude\ngeo2geodetic(latitude, longitude, altitude, planet) -> latitude, longitude, altitude\ngeo2geodetic(latitude, longitude, altitude, equatorial_radius, polar_radius) -> latitude, longitude, altitude\n\nPurpose\n\nConvert from geographic (or planetographic) to geodetic coordinates.\n\nExplanation\n\nConverts from geographic (latitude, longitude, altitude) to geodetic (latitude, longitude, altitude).  In geographic coordinates, the Earth is assumed a perfect sphere with a radius equal to its equatorial radius.  The geodetic (or ellipsoidal) coordinate system takes into account the Earth's oblateness.\n\nGeographic and geodetic longitudes are identical.  Geodetic latitude is the angle between local zenith and the equatorial plane.  Geographic and geodetic altitudes are both the closest distance between the satellite and the ground.\n\nArguments\n\nThe function has two base methods.  The arguments common to all methods and always mandatory are latitude, longitude, and altitude:\n\nlatitude: geographic latitude, in degrees.\nlongitude: geographic longitude, in degrees.\naltitude: geographic altitude, in kilometers.\n\nIn order to convert to geodetic coordinates, you can either provide custom equatorial and polar radii of the planet or use the values of one of the planets of Solar System (Pluto included).\n\nIf you want to use the method with explicit equatorial and polar radii the additional mandatory arguments are:\n\nequatorial_radius: value of the equatorial radius of the body, in kilometers.\npolar_radius: value of the polar radius of the body, in kilometers.\n\nInstead, if you want to use the method with the selection of a planet, the only additional argument is the planet name:\n\nplanet (optional string argument): string with the name of the Solar System planet, from \"Mercury\" to \"Pluto\".  If omitted (so, when only latitude, longitude, and altitude are provided), the default is \"Earth\".\n\nIn all cases, the three coordinates can be passed as a 3-tuple (latitude, longitude, altitude).  In addition, geographical latitude, longitude, and altitude can be given as arrays of the same length.\n\nOutput\n\nThe 3-tuple (latitude, longitude, altitude) in geodetic coordinates, for the body with specified equatorial and polar radii (Earth by default).\n\nIf geographical coordinates are given as arrays, a 3-tuple of arrays of the same length is returned.\n\nMethod\n\nStephen P.  Keeler and Yves Nievergelt, \"Computing geodetic coordinates\", SIAM Rev. Vol. 40, No. 2, pp. 300-309, June 1998 (DOI:10.1137/S0036144597323921).\n\nPlanetary constants are from Planetary Fact Sheet (http://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html).\n\nExample\n\nLocate the Earth geographic North pole (latitude: 90°, longitude: 0°, altitude 0 km), in geodetic coordinates:\n\njulia> using AstroLib\n\njulia> geo2geodetic(90, 0, 0)\n(90.0, 0.0, 21.38499999999931)\n\nThe same for Jupiter:\n\njulia> using AstroLib\n\njulia> geo2geodetic(90, 0, 0, \"Jupiter\")\n(90.0, 0.0, 4638.0)\n\nFind geodetic coordinates for point of geographic coordinates (latitude, longitude, altitude) = (43.16°, -24.32°, 3.87 km) on a planet with equatorial radius 8724.32 km and polar radius 8619.19 km:\n\njulia> using AstroLib\n\njulia> geo2geodetic(43.16, -24.32, 3.87, 8724.32, 8619.19)\n(43.849399515234516, -24.32, 53.53354478670965)\n\nNotes\n\nWhereas the conversion from geodetic to geographic coordinates is given by an exact, analytical formula, the conversion from geographic to geodetic isn't. Approximative iterations (as used here) exist, but tend to become less good with increasing eccentricity and altitude.  The formula used in this routine should give correct results within six digits for all spatial locations, for an ellipsoid (planet) with an eccentricity similar to or less than Earth's.  More accurate results can be obtained via calculus, needing a non-determined amount of iterations.\n\nIn any case, the function geodetic2geo, which converts from geodetic (or planetodetic) to geographic coordinates, can be used to estimate the accuracy of geo2geodetic.\n\njulia> using AstroLib\n\njulia> collect(geodetic2geo(geo2geodetic(67.2, 13.4, 1.2))) - [67.2, 13.4, 1.2]\n3-element Array{Float64,1}:\n -3.5672513831741526e-9\n  0.0\n  9.484211194177306e-10\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.geo2mag","page":"Reference","title":"AstroLib.geo2mag","text":"geo2mag(latitude, longitude[, year]) -> geomagnetic_latitude, geomagnetic_longitude\n\nPurpose\n\nConvert from geographic to geomagnetic coordinates.\n\nExplanation\n\nConverts from geographic (latitude, longitude) to geomagnetic (latitude, longitude).  Altitude is not involved in this function.\n\nArguments\n\nlatitude: geographic latitude (North), in degrees.\nlongitude: geographic longitude (East), in degrees.\nyear (optional numerical argument): the year in which to perform conversion. If omitted, defaults to current year.\n\nThe coordinates can be passed as arrays of the same length.\n\nOutput\n\nThe 2-tuple of magnetic (latitude, longitude) coordinates, in degrees.\n\nIf geographical coordinates are given as arrays, a 2-tuple of arrays of the same length is returned.\n\nExample\n\nKyoto has geographic coordinates 35° 00' 42'' N, 135° 46' 06'' E, find its geomagnetic coordinates in 2016:\n\njulia> using AstroLib\n\njulia> geo2mag(ten(35,0,42), ten(135,46,6), 2016)\n(36.86579228937769, -60.184060536651614)\n\nNotes\n\nThis function uses list of North Magnetic Pole positions provided by World Magnetic Model (https://www.ngdc.noaa.gov/geomag/data/poles/NP.xy).\n\nmag2geo converts geomagnetical coordinates to geographic coordinates.\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroLib/ref/#AstroLib.geodetic2geo-NTuple{5, Real}","page":"Reference","title":"AstroLib.geodetic2geo","text":"geodetic2geo(latitude, longitude, altitude) -> latitude, longitude, altitude\ngeodetic2geo(latitude, longitude, altitude, planet) -> latitude, longitude, altitude\ngeodetic2geo(latitude, longitude, altitude, equatorial_radius, polar_radius) -> latitude, longitude, altitude\n\nPurpose\n\nConvert from geodetic (or planetodetic) to geographic coordinates.\n\nExplanation\n\nConverts from geodetic (latitude, longitude, altitude) to geographic (latitude, longitude, altitude).  In geographic coordinates, the Earth is assumed a perfect sphere with a radius equal to its equatorial radius.  The geodetic (or ellipsoidal) coordinate system takes into account the Earth's oblateness.\n\nGeographic and geodetic longitudes are identical.  Geodetic latitude is the angle between local zenith and the equatorial plane.  Geographic and geodetic altitudes are both the closest distance between the satellite and the ground.\n\nArguments\n\nThe function has two base methods.  The arguments common to all methods and always mandatory are latitude, longitude, and altitude:\n\nlatitude: geodetic latitude, in degrees.\nlongitude: geodetic longitude, in degrees.\naltitude: geodetic altitude, in kilometers.\n\nIn order to convert to geographic coordinates, you can either provide custom equatorial and polar radii of the planet or use the values of one of the planets of Solar System (Pluto included).\n\nIf you want to use the method with explicit equatorial and polar radii the additional mandatory arguments are:\n\nequatorial_radius: value of the equatorial radius of the body, in kilometers.\npolar_radius: value of the polar radius of the body, in kilometers.\n\nInstead, if you want to use the method with the selection of a planet, the only additional argument is the planet name:\n\nplanet (optional string argument): string with the name of the Solar System planet, from \"Mercury\" to \"Pluto\".  If omitted (so, when only latitude, longitude, and altitude are provided), the default is \"Earth\".\n\nIn all cases, the three coordinates can be passed as a 3-tuple (latitude, longitude, altitude).  In addition, geodetic latitude, longitude, and altitude can be given as arrays of the same length.\n\nOutput\n\nThe 3-tuple (latitude, longitude, altitude) in geographic coordinates, for the body with specified equatorial and polar radii (Earth by default).\n\nIf geodetic coordinates are given as arrays, a 3-tuple of arrays of the same length is returned.\n\nMethod\n\nStephen P.  Keeler and Yves Nievergelt, \"Computing geodetic coordinates\", SIAM Rev. Vol. 40, No. 2, pp. 300-309, June 1998 (DOI:10.1137/S0036144597323921).\n\nPlanetary constants from \"Allen's Astrophysical Quantities\", Fourth Ed., (2000).\n\nExample\n\nFind geographic coordinates of geodetic North pole (latitude: 90°, longitude: 0°, altitude 0 km) of the Earth:\n\njulia> using AstroLib\n\njulia> geodetic2geo(90, 0, 0)\n(90.0, 0.0, -21.38499999999931)\n\nThe same for Jupiter:\n\njulia> using AstroLib\n\njulia> geodetic2geo(90, 0, 0, \"Jupiter\")\n(90.0, 0.0, -4638.0)\n\nFind geographic coordinates for point of geodetic coordinates (latitude, longitude, altitude) = (43.16°, -24.32°, 3.87 km) on a planet with equatorial radius 8724.32 km and polar radius 8619.19 km:\n\njulia> using AstroLib\n\njulia> geodetic2geo(43.16, -24.32, 3.87, 8724.32, 8619.19)\n(42.46772711708433, -24.32, -44.52902080669082)\n\nNotes\n\ngeo2geodetic converts from geographic (or planetographic) to geodetic coordinates.\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.get_date-Tuple{Dates.DateTime, Bool, Bool}","page":"Reference","title":"AstroLib.get_date","text":"get_date([date, old=true, timetag=true]) -> string\n\nPurpose\n\nReturns the UTC date in \"CCYY-MM-DD\" format for FITS headers.\n\nExplanation\n\nThis is the format required by the DATE and DATE-OBS keywords in a FITS header.\n\nArgument\n\ndate (optional): the date in UTC standard.  If omitted, defaults to the current UTC time.  Each element can be either a DateTime type or anything that can be converted to that type.  In the case of vectorial input, each element is considered as a date, so you cannot provide a date by parts.\nold (optional boolean keyword): see below.\ntimetag (optional boolean keyword): see below.\n\nOutput\n\nA string with the date formatted according to the given optional keywords.\n\nWhen no optional keywords (timetag and old) are supplied, the format of the output string is \"CCYY-MM-DD\" (year-month-day part of the date), where CCYY represents a 4-digit calendar year, MM the 2-digit ordinal number of a calendar month within the calendar year, and DD the 2-digit ordinal number of a day within the calendar month.\nIf the boolean keyword old is true (default: false), the year-month-day part of date has \"DD/MM/YY\" format.  This is the formerly (pre-1997) recommended for FITS.  Note that this format is now deprecated because it uses only a 2-digit representation of the year.\nIf the boolean keyword timetag is true (default: false), \"Thh:mm:ss\" is appended to the year-month-day part of the date, where <hh> represents the hour in the day, <mm> the minutes, <ss> the seconds, and the literal 'T' the ISO 8601 time designator.\n\nNote that old and timetag keywords can be used together, so that the output string will have \"DD/MM/YYThh:mm:ss\" format.\n\nExample\n\njulia> using AstroLib, Dates\n\njulia> get_date(DateTime(21937, 05, 30, 09, 59, 00), timetag=true)\n\"21937-05-30T09:59:00\"\n\nNotes\n\nA discussion of the DATExxx syntax in FITS headers can be found in\n\nhttp://www.cv.nrao.edu/fits/documents/standards/year2000.txt\n\nThose who wish to use need further flexibility in their date formats (e.g. to\n\nuse TAI time) should look at Bill Thompson's time routines in  http://sohowww.nascom.nasa.gov/solarsoft/gen/idl/time\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.get_juldate-Tuple{}","page":"Reference","title":"AstroLib.get_juldate","text":"get_juldate() -> julian_days\n\nPurpose\n\nReturn the number of Julian days for current time.\n\nExplanation\n\nReturn for current time the number of Julian calendar days since epoch -4713-11-24T12:00:00 as a floating point.\n\nExample\n\nget_juldate()\ndaycnv(get_juldate())\n\nNotes\n\nUse jdcnv to get the number of Julian days for a different date.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.hadec2altaz-Tuple{Real, Real, Real}","page":"Reference","title":"AstroLib.hadec2altaz","text":"hadec2altaz(ha, dec, lat[, ws=true]) -> alt, az\n\nPurpose\n\nConvert Hour Angle and Declination to Horizon (Alt-Az) coordinates.\n\nExplanation\n\nCan deal with the NCP singularity.  Intended mainly to be used by program eq2hor.\n\nArguments\n\nInput coordinates may be either a scalar or an array, of the same dimension.\n\nha: the local apparent hour angle, in degrees.  The hour angle is the time that right ascension of 0 hours crosses the local meridian.  It is unambiguously defined.\ndec: the local apparent declination, in degrees.\nlat: the local geodetic latitude, in degrees, scalar or array.\nws (optional boolean keyword): if true, the output azimuth is measured West from South.  The default is to measure azimuth East from North.\n\nha and dec can be given as a 2-tuple (ha, dec).\n\nOutput\n\n2-tuple (alt, az)\n\nalt: local apparent altitude, in degrees.\naz: the local apparent azimuth, in degrees.\n\nThe output coordinates are always floating points and have the same type (scalar or array) as the input coordinates.\n\nExample\n\nArcturus is observed at an apparent hour angle of 336.6829 and a declination of 19.1825 while at the latitude of +43° 4' 42''.  What are the local altitude and azimuth of this object?\n\njulia> using AstroLib\n\njulia> alt, az = hadec2altaz(336.6829, 19.1825, ten(43, 4, 42))\n(59.08617155005685, 133.3080693440254)\n\nNotes\n\naltaz2hadec converts Horizon (Alt-Az) coordinates to Hour Angle and Declination.\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.helio","page":"Reference","title":"AstroLib.helio","text":"helio(jd, list[, radians=true]) -> hrad, hlong, hlat\n\nPurpose\n\nCompute heliocentric coordinates for the planets.\n\nExplanation\n\nThe mean orbital elements for epoch J2000 are used. These are derived from a 250 yr least squares fit of the DE 200 planetary ephemeris to a Keplerian orbit where each element is allowed to vary linearly with time. Useful mainly for dates between 1800 and 2050, this solution fits the terrestrial planet orbits to ~25'' or better, but achieves only ~600'' for Saturn.\n\nArguments\n\njd: julian date, scalar or vector\nnum: integer denoting planet number, scalar or vector 1 = Mercury, 2 = Venus, ... 9 = Pluto\nradians(optional): if this keyword is set to true, than the longitude and latitude output are in radians rather than degrees.\n\nOutput\n\nhrad: the heliocentric radii, in astronomical units.\nhlong: the heliocentric (ecliptic) longitudes, in degrees.\nhlat: the heliocentric latitudes in degrees.\n\nExample\n\n(1) Find heliocentric position of Venus on August 23, 2000\n\njulia> using AstroLib\n\njulia> helio(jdcnv(2000,08,23,0), 2)\n(0.7213758288364316, 198.39093251916148, 2.887355631705488)\n\n(2) Find the current heliocentric positions of all the planets\n\njulia> using AstroLib\n\njulia> helio.([jdcnv(1900)], 1:9)\n9-element Array{Tuple{Float64,Float64,Float64},1}:\n (0.4207394142180803, 202.60972662618906, 3.0503005607270532)\n (0.7274605731764012, 344.5381482401048, -3.3924346961624785)\n (0.9832446886519147, 101.54969268801035, 0.012669354526696368)\n (1.4212659241051142, 287.8531100442217, -1.5754626002228043)\n (5.386813769590955, 235.91306092135062, 0.9131692817310215)\n (10.054339927304339, 268.04069870870387, 1.0851704598594278)\n (18.984683376211326, 250.0555468087738, 0.05297087029604253)\n (29.87722677219009, 87.07244903504716, -1.245060583142733)\n (46.9647515992327, 75.94692594417324, -9.576681044165511)\n\nNotes\n\nThis program is based on the two-body model and thus neglects interactions between the planets.\n\nThe coordinates are given for equinox 2000 and not the equinox of the supplied date.\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroLib/ref/#AstroLib.helio_jd-Tuple{Real, Real, Real}","page":"Reference","title":"AstroLib.helio_jd","text":"helio_jd(date, ra, dec[, B1950=true, diff=false]) -> jd_helio\nhelio_jd(date, ra, dec[, B1950=true, diff=true]) -> time_diff\n\nPurpose\n\nConvert geocentric (reduced) Julian date to heliocentric Julian date.\n\nExplanation\n\nThis procedure corrects for the extra light travel time between the Earth and the Sun.\n\nAn online calculator for this quantity is available at http://www.physics.sfasu.edu/astro/javascript/hjd.html\n\nUsers requiring more precise calculations and documentation should look at the IDL code available at http://astroutils.astronomy.ohio-state.edu/time/\n\nArguments\n\ndate: reduced Julian date (= JD - 2400000).  You can use juldate() to calculate the reduced Julian date.\nra and dec: right ascension and declination in degrees.  Default equinox is J2000.\nB1950 (optional boolean keyword): if set to true, then input coordinates are assumed to be in equinox B1950 coordinates.  Default is false.\ndiff (optional boolean keyword): if set to true, the function returns the time difference (heliocentric JD - geocentric JD) in seconds.  Default is false.\n\nOutput\n\nThe return value depends on the value of diff optional keywords:\n\nif diff is false (default), then the heliocentric reduced Julian date is returned.\nif diff is true, then the time difference in seconds between the geocentric and heliocentric Julian date is returned.\n\nExample\n\nWhat is the heliocentric Julian date of an observation of V402 Cygni (J2000: RA = 20 9 7.8, Dec = 37 09 07) taken on June 15, 2016 at 11:40 UT?\n\njulia> using AstroLib\n\njulia> jd = juldate(2016, 6, 15, 11, 40);\n\njulia> helio_jd(jd, ten(20, 9, 7.8) * 15, ten(37, 9, 7))\n57554.98808289718\n\nNotes\n\nWayne Warren (Raytheon ITSS) has compared the results of this algorithm with the FORTRAN subroutines in the STARLINK SLALIB library (see http://star-www.rl.ac.uk/).\n\n                                                 Time Diff (sec)\n     Date               RA(2000)   Dec(2000)  STARLINK      IDL\n\n1999-10-29T00:00:00.0  21 08 25.  -67 22 00.  -59.0        -59.0\n1999-10-29T00:00:00.0  02 56 33.4 +00 26 55.  474.1        474.1\n1940-12-11T06:55:00.0  07 34 41.9 -00 30 42.  366.3        370.2\n1992-02-29T03:15:56.2  12 56 27.4 +42 10 17.  350.8        350.9\n2000-03-01T10:26:31.8  14 28 36.7 -20 42 11.  243.7        243.7\n2100-02-26T09:18:24.2  08 26 51.7 +85 47 28.  104.0        108.8\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.helio_rv","page":"Reference","title":"AstroLib.helio_rv","text":"helio_rv(jd, T, P, V_0, K[, e, ω]) -> rv\n\nPurpose\n\nReturn the heliocentric radial velocity of a spectroscopic binary.\n\nExplanation\n\nThis function will return the heliocentric radial velocity of a spectroscopic binary star at a given heliocentric date given its orbit.\n\nArguments\n\njd: time of observation, as number of Julian days.\nT: time of periastron passage (max. +ve velocity for circular orbits), same time system as jd\nP: the orbital period in same units as jd\nV_0: systemic velocity\nK: velocity semi-amplitude in the same units as V_0\ne: eccentricity of the orbit.  It defaults to 0 if omitted\nω: longitude of periastron in degrees.  It defaults to 0 if omitted\n\nOutput\n\nThe predicted heliocentric radial velocity in the same units as Gamma for the date(s) specified by jd.\n\nExample\n\n(1) What was the heliocentric radial velocity of the primary component of HU Tau at 1730 UT 25 Oct 1994?\n\njulia> using AstroLib\n\njulia> jd = juldate(94, 10, 25, 17, 30); # Obtain Geocentric Julian days\n\njulia> hjd = helio_jd(jd, ten(04, 38, 16) * 15, ten(20, 41, 05)); # Convert to HJD\n\njulia> helio_rv(hjd, 46487.5303, 2.0563056, -6, 59.3)\n-62.965570107789475\n\nNB: the functions juldate and helio_jd return a reduced HJD (HJD - 2400000) and so T and P must be specified in the same fashion.\n\n(2) Plot two cycles of an eccentric orbit, e=06, omega=45degree for both components of a binary star.  Use PyPlot.jl for plotting.\n\nusing PyPlot\nφ = range(0, stop=2, length=1000); # Generate 1000 phase points\nplot(φ ,helio_rv.(φ, 0, 1, 0, 100, 0.6, 45)) # Plot 1st component\nplot(φ ,helio_rv.(φ, 0, 1, 0, 100, 0.6, 45+180)) # Plot 2nd component\n\nNotes\n\nThe user should ensure consistency with all time systems being used (i.e. jd and t should be in the same units and time system).  Generally, users should reduce large time values by subtracting a large constant offset, which may improve numerical accuracy.\n\nIf using the the function juldate and helio_jd, the reduced HJD time system must be used throughtout.\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroLib/ref/#AstroLib.hor2eq","page":"Reference","title":"AstroLib.hor2eq","text":"hor2eq(alt, az, jd[, obsname; ws=false, B1950=false, precession=true, nutate=true,\n       aberration=true, refract=true, lat=NaN, lon=NaN, altitude=0, pressure=NaN,\n       temperature=NaN]) -> ra, dec, ha\n\nhor2eq(alt, az, jd, lat, lon[, altitude=0; ws=false, B1950=false,\n       precession=true, nutate=true, aberration=true, refract=true, pressure=NaN,\n       temperature=NaN]) -> ra, dec, ha\n\nPurpose\n\nConverts local horizon coordinates (alt-az) to equatorial (ra-dec) coordinates.\n\nExplanation\n\nThis is a function to calculate equatorial (ra,dec) coordinates from horizon (alt,az) coords. It is accurate to about 1 arcsecond or better. It performs precession, nutation, aberration, and refraction corrections.\n\nArguments\n\nThis function has two base methods.  With one you can specify the name of the observatory, if present in AstroLib.observatories, with the other one you can provide the coordinates of the observing site and, optionally, the altitude.\n\nCommon mandatory arguments:\n\nalt: altitude of horizon coords, in degrees\naz: azimuth angle measured East from North (unless ws is true), in degrees\njd: julian date\n\nOther positional arguments:\n\nobsname: set this to a valid observatory name in AstroLib.observatories.\n\nor\n\nlat: north geodetic latitude of location, in degrees.\nlon: AST longitude of location, in degrees. You can specify west longitude with a negative sign.\naltitude: the altitude of the observing location, in meters.  It is 0 by default\n\nOptional keyword arguments:\n\nws (optional boolean keyword): set this to true to get the azimuth measured westward from south. This is false by default\nB1950 (optional boolean keyword): set this to true if the ra and dec are specified in B1950 (FK4 coordinates) instead of J2000 (FK5). This is false by default\nprecession (optional boolean keyword): set this to false for no precession, true by default\nnutate (optional boolean keyword): set this to false for no nutation, true by default\naberration (optional boolean keyword): set this to false for no aberration correction, true by default\nrefract (optional boolean keyword): set this to false for no refraction correction, true by default\npressure (optional keyword): the pressure at the observing location, in millibars. Default value is NaN\ntemperature (optional keyword): the temperature at the observing location, in Kelvins. Default value is NaN\n\nOutput\n\nra: right ascension of object, in degrees (FK5)\ndec: declination of the object, in degrees (FK5)\nha: hour angle, in degrees\n\nExample\n\nYou are at Kitt Peak National Observatory, looking at a star at azimuth angle 264d 55m 06s and elevation 37d 54m 41s (in the visible). Today is Dec 25, 2041 and the local time is 10 PM precisely. What is the right ascension and declination (J2000) of the star you're looking at? The temperature here is about 0 Celsius, and the pressure is 781 millibars. The Julian date for this time is 2466879.7083333\n\njulia> using AstroLib\n\njulia> ra_o, dec_o = hor2eq(ten(37,54,41), ten(264,55,06), 2466879.7083333,\n                            \"kpno\", pressure = 781, temperature = 273)\n(3.3224480269254717, 15.19061543702944, 54.61174536229464)\n\njulia> adstring(ra_o, dec_o)\n\" 00 13 17.4  +15 11 26\"\n\nNotes\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroLib/ref/#AstroLib.imf-Tuple{AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}}","page":"Reference","title":"AstroLib.imf","text":"imf(mass, expon, mass_range) -> psi\n\nPurpose\n\nCompute an N-component power-law logarithmic initial mass function (IMF).\n\nExplanation\n\nThe function is normalized so that the total mass distribution equals one solar mass.\n\nArguments\n\nmass: mass in units of solar mass, vector.\nexpon: power law exponent, vector. The number of values in expon equals the number of different power-law components in the IMF.\nmass_range: vector containing the mass upper and lower limits of the IMF and masses where the IMF exponent changes. The number of values in massrange should be one more than in expon. The values in massrange should be monotonically increasing and positive.\n\nOutput\n\npsi: mass function, number of stars per unit logarithmic mass interval evaluated for supplied masses.\n\nExample\n\nShow the number of stars per unit mass interval at 3 Msun for a Salpeter (expon = -1.35) IMF, with a mass range from 0.1 MSun to 110 Msun.\n\njulia> using AstroLib\n\njulia> imf([3], [-1.35], [0.1, 110]) / 3\n1-element Array{Float64,1}:\n 0.01294143518151214\n\nNotes\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.ismeuv","page":"Reference","title":"AstroLib.ismeuv","text":"ismeuv(wave, hcol[, he1col=hcol*0.1, he2col=0, fano=false]) -> tau\n\nPurpose\n\nCompute the continuum interstellar EUV optical depth\n\nExplanation\n\nThe EUV optical depth is computed from the photoionization of hydrogen and helium.\n\nArguments\n\nwave: wavelength value (in Angstroms). Useful range is 40 - 912 A; at shorter wavelength metal opacity should be considered, at longer wavelengths there is no photoionization.\nhcol: interstellar hydrogen column density in cm-2.\nhe1col (optional): neutral helium column density in cm-2. Default is 0.1*hcol (10% of hydrogen column)\nhe2col (optional): ionized helium column density in cm-2 Default is 0.\nfano (optional boolean keyword): If this keyword is true, then the 4 strongest auto-ionizing resonances of He I are included. The shape of these resonances is given by a Fano profile - see Rumph, Bowyer, & Vennes 1994, AJ, 107, 2108. If these resonances are included then the input wavelength vector should have a fine (>~0.01 A) grid between 190 A and 210 A, since the resonances are very narrow.\n\nOutput\n\ntau: Vector giving resulting optical depth, non-negative values.\n\nExample\n\nOne has a model EUV spectrum with wavelength, w (in Angstroms). Find the EUV optical depth by 1e18 cm-2 of HI, with N(HeI)/N(HI) = N(HeII)/N(HI) = 0.05.\n\njulia> using AstroLib\n\njulia> ismeuv.([670, 910], 1e19, 5e17, 5e17)\n2-element Array{Float64,1}:\n 27.35393320556168\n 62.683796028917286\n\nNotes\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroLib/ref/#AstroLib.jdcnv","page":"Reference","title":"AstroLib.jdcnv","text":"jdcnv(date) -> julian_days\n\nPurpose\n\nConvert proleptic Gregorian Calendar date in UTC standard to number of Julian days.\n\nExplanation\n\nTakes the given proleptic Gregorian date in UTC standard and returns the number of Julian calendar days since epoch -4713-11-24T12:00:00.\n\nArgument\n\ndate: date in proleptic Gregorian Calendar.  Each element can be either a DateTime or anything that can be converted directly to DateTime.\n\nOutput\n\nNumber of Julian days, as a floating point.\n\nExample\n\nFind the Julian days number at 2016 August 23, 03:39:06.\n\njulia> using AstroLib, Dates\n\njulia> jdcnv(DateTime(2016, 08, 23, 03, 39, 06))\n2.4576236521527776e6\n\njulia> jdcnv(2016, 08, 23, 03, 39, 06)\n2.4576236521527776e6\n\njulia> jdcnv(\"2016-08-23T03:39:06\")\n2.4576236521527776e6\n\nNotes\n\nThis is the inverse of daycnv.\n\nget_juldate returns the number of Julian days for current time.  It is equivalent to jdcnv(now(Dates.UTC)).\n\nFor the conversion of Julian date to number of Julian days, use juldate.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroLib/ref/#AstroLib.jprecess","page":"Reference","title":"AstroLib.jprecess","text":"jprecess(ra, dec[, epoch]) -> ra2000, dec2000\njprecess(ra, dec, muradec[, parallax=parallax, radvel=radvel]) -> ra2000, dec2000\n\nPurpose\n\nPrecess positions from B1950.0 (FK4) to J2000.0 (FK5).\n\nExplanation\n\nCalculate the mean place of a star at J2000.0 on the FK5 system from the mean place at B1950.0 on the FK4 system.\n\njprecess function has two methods, one for each of the following cases:\n\nthe proper motion is known and non-zero\nthe proper motion is unknown or known to be exactly zero (i.e. extragalactic radio sources).  Better precision can be achieved in this case by inputting the epoch of the original observations.\n\nArguments\n\nThe function has 2 methods.  The common mandatory arguments are:\n\nra: input B1950 right ascension, in degrees.\ndec: input B1950 declination, in degrees.\n\nThe two methods have a different third argument (see \"Explanation\" section for more details).  It can be one of the following:\n\nmuradec: 2-element vector containing the proper motion in seconds of arc per tropical century in right ascension and declination.\nepoch: scalar giving epoch of original observations.\n\nIf none of these two arguments is provided (so jprecess is fed only with right ascension and declination), it is assumed that proper motion is exactly zero and epoch = 1950.\n\nIf it is used the method involving muradec argument, the following keywords are available:\n\nparallax (optional numerical keyword): stellar parallax, in seconds of arc.\nradvel (optional numerical keyword): radial velocity in km/s.\n\nRight ascension and declination can be passed as the 2-tuple (ra, dec).  You can also pass ra, dec, parallax, and radvel as arrays, all of the same length N.  In that case, muradec should be a matrix 2×N.\n\nOutput\n\nThe 2-tuple of right ascension and declination in 2000, in degrees, of input coordinates is returned.  If ra and dec (and other possible optional arguments) are arrays, the 2-tuple of arrays (ra2000, dec2000) of the same length as the input coordinates is returned.\n\nMethod\n\nThe algorithm is taken from the Explanatory Supplement to the Astronomical Almanac 1992, page 184.  See also Aoki et al (1983), A&A, 128, 263.  URL: http://adsabs.harvard.edu/abs/1983A%26A...128..263A.\n\nExample\n\nThe SAO catalogue gives the B1950 position and proper motion for the star HD 119288.   Find the J2000 position.\n\nRA(1950) = 13h 39m 44.526s\nDec(1950) = 8d 38' 28.63''\nMu(RA) = -.0259 s/yr\nMu(Dec) = -.093 ''/yr\n\njulia> using AstroLib\n\njulia> muradec = 100 * [-15*0.0259, -0.093]; # convert to century proper motion\n\njulia> ra = ten(13, 39, 44.526)*15;\n\njulia> decl = ten(8, 38, 28.63);\n\njulia> adstring(jprecess(ra, decl, muradec), precision=2)\n\" 13 42 12.740  +08 23 17.69\"\n\nNotes\n\n\"When transferring individual observations, as opposed to catalog mean place, the safest method is to tranform the observations back to the epoch of the observation, on the FK4 system (or in the system that was used to to produce the observed mean place), convert to the FK5 system, and transform to the the epoch and equinox of J2000.0\" – from the Explanatory Supplement (1992), p. 180\n\nbprecess performs the precession to B1950 coordinates.\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroLib/ref/#AstroLib.juldate-Tuple{Dates.DateTime}","page":"Reference","title":"AstroLib.juldate","text":"juldate(date::DateTime) -> reduced_julia_days\n\nPurpose\n\nConvert from calendar to Reduced Julian Days.\n\nExplanation\n\nJulian Day Number is a count of days elapsed since Greenwich mean noon on 1 January 4713 B.C.  Julian Days are the number of Julian days followed by the fraction of the day elapsed since the preceding noon.\n\nThis function takes the given date and returns the number of Julian calendar days since epoch 1858-11-16T12:00:00 (Reduced Julian Days = Julian Days - 2400000).\n\nArgument\n\ndate: date in Julian Calendar, UTC standard.  Each element can be given in DateTime type or anything that can be converted to that type.\n\nOutput\n\nThe number of Reduced Julian Days is returned.\n\nExample\n\nGet number of Reduced Julian Days at 2016-03-20T15:24:00.\n\njulia> using AstroLib, Dates\n\njulia> juldate(DateTime(2016, 03, 20, 15, 24))\n57468.14166666667\n\njulia> juldate(2016, 03, 20, 15, 24)\n57468.14166666667\n\njulia> juldate(\"2016-03-20T15:24\")\n57468.14166666667\n\nNotes\n\nJulian Calendar is assumed, thus before 1582-10-15T00:00:00 this function is not the inverse of daycnv.  For the conversion proleptic Gregorian date to number of Julian days, use jdcnv, which is the inverse of daycnv.\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.kepler_solver","page":"Reference","title":"AstroLib.kepler_solver","text":"kepler_solver(M, e) -> E\n\nPurpose\n\nSolve Kepler's equation in the elliptic motion regime (0 leq e leq 1) and return eccentric anomaly E.\n\nExplanation\n\nIn order to find the position of a body in elliptic motion (e.g., in the two-body problem) at a given time t, one has to solve the Kepler's equation\n\nM(t) = E(t) - esin E(t)\n\nwhere M(t) = (t - t_0)P is the mean anomaly, E(t) the eccentric anomaly, e the eccentricity of the orbit, t_0 is the time of periapsis passage, and P is the period of the orbit.  Usually the eccentricity is given and one wants to find the eccentric anomaly E(t) at a specific time t, so that also the mean anomaly M(t) is known.\n\nArguments\n\nM: mean anomaly.\ne: eccentricity, in the elliptic motion regime (0 leq e leq 1)\n\nOutput\n\nThe eccentric anomaly E, restricted to the range -pi pi.\n\nMethod\n\nMany different numerical methods exist to solve Kepler's equation.  This function implements the algorithm proposed in Markley (1995) Celestial Mechanics and Dynamical Astronomy, 63, 101 (DOI:10.1007/BF00691917).  This method is not iterative, requires only four transcendental function evaluations, and has been proved to be fast and efficient over the entire range of elliptic motion 0 leq e leq 1.\n\nExample\n\n(1) Find the eccentric anomaly for an orbit with eccentricity e = 07 and for M(t) = 8pi3.\n\njulia> using AstroLib\n\njulia> ecc = 0.7;\n\njulia> E = kepler_solver(8pi/3, ecc)\n2.5085279492864223\n\n(2) Plot the eccentric anomaly as a function of mean anomaly for eccentricity e = 0, 05, 09.  Recall that kepler_solver gives E in -pi pi, use mod2pi to have it in 0 2pi.  Use PyPlot.jl for plotting.\n\nusing AstroLib, PyPlot\nM = range(0, stop=2pi, length=1001)[1:end-1];\nfor ecc in (0, 0.5, 0.9); plot(M, mod2pi.(kepler_solver.(M, ecc))); end\n\nNotes\n\nThe true anomaly can be calculated with trueanom function.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroLib/ref/#AstroLib.lsf_rotate","page":"Reference","title":"AstroLib.lsf_rotate","text":"lsf_rotate(delta_v, v_sin_i[, epsilon = 0.3]) -> velocity_grid, lsf\n\nPurpose\n\nCreate a 1-d convolution kernel to broaden a spectrum from a rotating star.\n\nExplanation\n\nCan be used to derive the broadening effect (LSF, line spread function) due to rotation on a synthetic stellar spectrum.  Assumes constant limb darkening across the disk.\n\nArguments\n\ndelta_v: the step increment (in km/s) in the output rotation kernel\nv_sin_i: the rotational velocity projected along the line of sight (km/s)\nepsilon (optional numeric argument): the limb-darkening coefficient, default = 0.6 which is typical for photospheric lines.  The specific intensity I at any angle theta from the specific intensity I_textcen at the center of the disk is given by:\nI = I_textcencdot(1 - varepsiloncdot(1 - cos(theta)))\n\nOutput\n\nThe 2-tuple (velocity_grid, lsf):\n\nvelocity_grid: vector of velocity grid with the same number of elements as lsf (see below)\nlsf: the convolution kernel vector for the specified rotational velocity. The number of points in lsf will be always be odd (the kernel is symmetric) and equal to either ceil(2*v_sin_i/delta_v) or ceil(2*v_sin_i/delta_v) + 1, whichever number is odd.  Elements of lsf will always be of type AbstractFloat.  To actually compute the broadening, the spectrum should be convolved with the rotational lsf\n\nExample\n\nPlot the line spread function for a star rotating at 90 km/s in velocity space every 3 km/s.  Use PyPlot.jl for plotting.\n\nusing PyPlot\nplot(lsf_rotate(3, 90)...)\n\nNotes\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroLib/ref/#AstroLib.mag2flux","page":"Reference","title":"AstroLib.mag2flux","text":"mag2flux(mag[, zero_point, ABwave=number]) -> flux\n\nPurpose\n\nConvert from magnitudes to flux expressed in erg/(s cm² Å).\n\nExplanation\n\nThis is the reverse of flux2mag.\n\nArguments\n\nmag: the magnitude to be converted in flux.\nzero_point: the zero point level of the magnitude.  If not supplied then defaults to\n\n21.1 (Code et al 1976).  Ignored if the ABwave keyword is supplied\n\nABwave (optional numeric keyword): wavelength, in Angstroms.  If supplied, then the\n\ninput mag is assumed to contain Oke AB magnitudes (Oke & Gunn 1983, ApJ, 266, 713;  http://adsabs.harvard.edu/abs/1983ApJ...266..713O).\n\nOutput\n\nThe flux.\n\nIf the ABwave keyword is set, then the flux is given by the expression\n\ntextflux = 10^-04(textmag +2406 + 4log_10(textABwave))\n\nOtherwise the flux is given by\n\ntextflux =  10^-04(textmag + textzero point)\n\nExample\n\njulia> using AstroLib\n\njulia> mag2flux(8.3)\n1.7378008287493692e-12\n\njulia> mag2flux(8.3, 12)\n7.58577575029182e-9\n\njulia> mag2flux(8.3, ABwave=12)\n3.6244115683017193e-7\n\nNotes\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroLib/ref/#AstroLib.mag2geo","page":"Reference","title":"AstroLib.mag2geo","text":"mag2geo(latitude, longitude[, year]) -> geographic_latitude, geographic_longitude\n\nPurpose\n\nConvert from geomagnetic to geographic coordinates.\n\nExplanation\n\nConverts from geomagnetic (latitude, longitude) to geographic (latitude, longitude).  Altitude is not involved in this function.\n\nArguments\n\nlatitude: geomagnetic latitude (North), in degrees.\nlongitude: geomagnetic longitude (East), in degrees.\nyear (optional numerical argument): the year in which to perform conversion. If omitted, defaults to current year.\n\nThe coordinates can be passed as arrays of the same length.\n\nOutput\n\nThe 2-tuple of geographic (latitude, longitude) coordinates, in degrees.\n\nIf geomagnetic coordinates are given as arrays, a 2-tuple of arrays of the same length is returned.\n\nExample\n\nFind position of North Magnetic Pole in 2016\n\njulia> using AstroLib\n\njulia> mag2geo(90, 0, 2016)\n(86.395, -166.29000000000002)\n\nNotes\n\nThis function uses list of North Magnetic Pole positions provided by World Magnetic Model (https://www.ngdc.noaa.gov/geomag/data/poles/NP.xy).\n\ngeo2mag converts geographic coordinates to geomagnetic coordinates.\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroLib/ref/#AstroLib.mean_obliquity-Tuple{Real}","page":"Reference","title":"AstroLib.mean_obliquity","text":"mean_obliquity(jd) -> m_eps\n\nPurpose\n\nReturn the mean obliquity of the ecliptic for a given Julian date\n\nExplanation\n\nThe function is used by the co_nutate procedure.\n\nArguments\n\njd: julian date\n\nOutput\n\nm_eps: mean obliquity of the ecliptic, in radians\n\nExample\n\njulia> using AstroLib\n\njulia> mean_obliquity(jdcnv(1978,01,7,11, 01))\n0.4091425159336512\n\nNotes\n\nThe algorithm used to find the mean obliquity(eps0) is mentioned in USNO Circular 179, but the canonical reference for the IAU adoption is apparently Hilton et al., 2006, Celest.Mech.Dyn.Astron. 94, 351. 2000\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.month_cnv-Tuple{Integer}","page":"Reference","title":"AstroLib.month_cnv","text":"month_cnv(number[, shor=true, up=true, low=true]) -> month_name\nmonth_cnv(name) -> number\n\nPurpose\n\nConvert between a month English name and  the equivalent number.\n\nExplanation\n\nFor example, converts from \"January\" to 1  or vice-versa.\n\nArguments\n\nThe functions has two methods, one with numeric input (and three possible boolean keywords) and the other one with string input.\n\nNumeric input arguments:\n\nnumber: the number of the month to be converted to month name.\nshort (optional boolean keyword): if true, the abbreviated (3-character) name of the month will be returned, e.g. \"Apr\" or \"Oct\".  Default is false.\nup (optional boolean keyword): if true, the name of the month will be all in upper case, e.g. \"APRIL\" or \"OCTOBER\".  Default is false.\nlow (optional boolean keyword): if true, the name of the month will be all in lower case, e.g. \"april\" or \"october\".  Default is false.\n\nString input argument:\n\nname: month name to be converted to month number.\n\nOutput\n\nThe month name or month number, depending on the input.  For numeric input, the format of the month name is influenced by the optional keywords.\n\nExample\n\njulia> using AstroLib\n\njulia> month_cnv.([\"janua\", \"SEP\", \"aUgUsT\"])\n3-element Array{Int64,1}:\n 1\n 9\n 8\n\njulia> month_cnv.([2, 12, 6], short=true, low=true)\n3-element Array{String,1}:\n \"feb\"\n \"dec\"\n \"jun\"\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.moonpos-Tuple{Real}","page":"Reference","title":"AstroLib.moonpos","text":"moonpos(jd[, radians=true]) -> ra, dec, dis, geolong, geolat\n\nPurpose\n\nCompute the right ascension and declination of the Moon at specified Julian date.\n\nArguments\n\njd: the Julian ephemeris date.  It can be either a scalar or an array\nradians (optional boolean keyword): if set to true, then all output angular quantities are given in radians rather than degrees.  The default is false\n\nOutput\n\nThe 5-tuple (ra, dec, dis, geolong, geolat):\n\nra: apparent right ascension of the Moon in degrees, referred to the true equator of the specified date(s)\ndec: the declination of the Moon in degrees\ndis: the distance between the centre of the Earth and the centre of the Moon in kilometers\ngeolong: apparent longitude of the moon in degrees, referred to the ecliptic of the specified date(s)\ngeolat: apparent longitude of the moon in degrees, referred to the ecliptic of the specified date(s)\n\nIf jd is an array, then all output quantities are arrays of the same length as jd.\n\nMethod\n\nDerived from the Chapront ELP2000/82 Lunar Theory (Chapront-Touze' and Chapront, 1983, 124, 50), as described by Jean Meeus in Chapter 47 of ``Astronomical Algorithms'' (Willmann-Bell, Richmond), 2nd edition, 1998.  Meeus quotes an approximate accuracy of 10\" in longitude and 4\" in latitude, but he does not give the time range for this accuracy.\n\nComparison of the IDL procedure with the example in ``Astronomical Algorithms'' reveals a very small discrepancy (~1 km) in the distance computation, but no difference in the position calculation.\n\nExample\n\n(1) Find the position of the moon on April 12, 1992\n\njulia> using AstroLib\n\njulia> jd = jdcnv(1992, 4, 12);\n\njulia> adstring(moonpos(jd)[1:2],precision=1)\n\" 08 58 45.23  +13 46 06.1\"\n\nThis is within 1\" from the position given in the Astronomical Almanac.\n\n(2) Plot the Earth-moon distance during 2016 with sampling of 6 hours.  Use PyPlot.jl for plotting\n\nusing PyPlot\npoints = DateTime(2016):Dates.Hour(6):DateTime(2017);\nplot(points, moonpos(jdcnv.(points))[3])\n\nNotes\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.mphase-Tuple{Real}","page":"Reference","title":"AstroLib.mphase","text":"mphase(jd) -> k\n\nPurpose\n\nReturn the illuminated fraction of the Moon at given Julian date(s).\n\nArguments\n\njd: the Julian ephemeris date.\n\nOutput\n\nThe illuminated fraction k of Moon's disk, with 0 leq k leq 1. k = 0 indicates a new moon, while k = 1 stands for a full moon.\n\nMethod\n\nAlgorithm from Chapter 46 of \"Astronomical Algorithms\" by Jean Meeus (Willmann-Bell, Richmond) 1991.  sunpos and moonpos are used to get positions of the Sun and the Moon, and the Moon distance.  The selenocentric elongation of the Earth from the Sun (phase angle) is then computed, and used to determine the illuminated fraction.\n\nExample\n\nPlot the illuminated fraction of the Moon for every day in January 2018 with a hourly sampling.  Use PyPlot.jl for plotting\n\nusing PyPlot\npoints = DateTime(2018,01,01):Dates.Hour(1):DateTime(2018,01,31,23,59,59);\nplot(points, mphase.(jdcnv.(points)))\n\nNote that in this calendar month there are two full moons, this event is called blue moon.\n\nNotes\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.nutate-Tuple{Real}","page":"Reference","title":"AstroLib.nutate","text":"nutate(jd) -> long, obliq\n\nPurpose\n\nReturn the nutation in longitude and obliquity for a given Julian date.\n\nArguments\n\njd: Julian ephemeris date, it can be either a scalar or a vector\n\nOutput\n\nThe 2-tuple (long, obliq), where\n\nlong: the nutation in longitude\nobl: the nutation in latitude\n\nIf jd is an array, long and obl are arrays of the same length.\n\nMethod\n\nUses the formula in Chapter 22 of ``Astronomical Algorithms'' by Jean Meeus (1998, 2nd ed.) which is based on the 1980 IAU Theory of Nutation and includes all terms larger than 0.0003\".\n\nExample\n\n(1) Find the nutation in longitude and obliquity 1987 on Apr 10 at Oh.  This is example 22.a from Meeus\n\njulia> using AstroLib\n\njulia> jd = jdcnv(1987, 4, 10);\n\njulia> nutate(jd)\n(-3.787931077110494, 9.44252069864449)\n\n(2) Plot the daily nutation in longitude and obliquity during the 21st century. Use PyPlot.jl for plotting.\n\nusing PyPlot\nyears = DateTime(2000):DateTime(2100);\nlong, obl = nutate(jdcnv.(years));\nplot(years, long); plot(years, obl)\n\nYou can see both the dominant large scale period of nutation, of 18.6 years, and smaller oscillations with shorter periods.\n\nNotes\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.ordinal-Tuple{Integer}","page":"Reference","title":"AstroLib.ordinal","text":"ordinal(num) -> result\n\nPurpose\n\nConvert an integer to a correct English ordinal string.\n\nExplanation\n\nThe first four ordinal strings are \"1st\", \"2nd\", \"3rd\", \"4th\" ....\n\nArguments\n\nnum: number to be made ordinal. It should be of type int.\n\nOutput\n\nresult: ordinal string, such as '1st' '3rd '164th' '87th' etc\n\nExample\n\njulia> using AstroLib\n\njulia> ordinal.(1:5)\n5-element Array{String,1}:\n \"1st\"\n \"2nd\"\n \"3rd\"\n \"4th\"\n \"5th\"\n\nNotes\n\nThis function does not support float arguments, unlike the IDL implementation. Code of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.paczynski-Tuple{Real}","page":"Reference","title":"AstroLib.paczynski","text":"paczynski(u) -> amplification\n\nPurpose\n\nCalculate gravitational microlensing amplification of a point-like source by a single point-like lens.\n\nExplanation\n\nReturn the gravitational microlensing amplification of a point-like source by a single point-like lens, using Paczyński formula\n\nA(u) = fracu^2 + 2usqrtu^2 + 4\n\nwhere u is the projected distance between the lens and the source in units of Einstein radii.\n\nIn order to speed up calculations for extreme values of u, the following asyntotic expressions for A(u) are used:\n\nA(u) =\nbegincases\n 1u  u ll 1 \n textsgn(u)  u gg 1\nendcases\n\nArguments\n\nu: projected distance between the lens and the source, in units of Einstein radii\n\nOutput\n\nThe microlensing amplification for the given distance.\n\nExample\n\nCalculate the microlensing amplification for u = 10^-10, 10^-1, 1, 10, 10^10:\n\njulia> using AstroLib\n\njulia> paczynski.([1e-10, 1e-1, 1, 10, 1e10])\n5-element Array{Float64,1}:\n  1.0e10\n 10.037461005722337\n  1.3416407864998738\n  1.0001922892047386\n  1.0\n\nNotes\n\nThe expression of A(u) of microlensing amplification has been given by Bohdan Paczyński in\n\nPaczynski, B. 1986, ApJ, 304, 1. DOI:10.1086/164140, Bibcode:1986ApJ...304....1P\n\nThe same expression was actually found by Albert Einstein half a century earlier:\n\nEinstein, A. 1936, Science, 84, 506. DOI:10.1126/science.84.2188.506, Bibcode:1936Sci....84..506E\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.planck_freq-Tuple{Real, Real}","page":"Reference","title":"AstroLib.planck_freq","text":"planck_freq(frequency, temperature) -> black_body_flux\n\nPurpose\n\nCalculate the flux of a black body per unit frequency.\n\nExplanation\n\nReturn the spectral radiance of a black body per unit frequency using Planck's law\n\nB_nu(nu T) = frac2hnu ^3c^2 frac1e^frachnuk_mathrmBT - 1\n\nArguments\n\nfrequency: frequency at which the flux is to be calculated, in Hertz.\ntemperature: the equilibrium temperature of the black body, in Kelvin.\n\nOutput\n\nThe spectral radiance of the black body, in units of W/(sr·m²·Hz).\n\nExample\n\nPlot the spectrum of a black body in 10^12 10^154 Hz at 8000 K. Use PyPlot.jl for plotting.\n\nusing PyPlot\nfrequency = exp10.(range(12, stop=15.4, length=1000));\ntemperature = ones(frequency)*8000;\nflux = planck_freq.(frequency, temperature);\nplot(frequency, flux)\n\nNotes\n\nplanck_wave calculates the flux of a black body per unit wavelength.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.planck_wave-Tuple{Real, Real}","page":"Reference","title":"AstroLib.planck_wave","text":"planck_wave(wavelength, temperature) -> black_body_flux\n\nPurpose\n\nCalculate the flux of a black body per unit wavelength.\n\nExplanation\n\nReturn the spectral radiance of a black body per unit wavelength using Planck's law\n\nB_lambda(lambda T) =frac2hc^2lambda^5frac1e^frachclambda k_mathrmBT - 1\n\nArguments\n\nwavelength: wavelength at which the flux is to be calculated, in meters.\ntemperature: the equilibrium temperature of the black body, in Kelvin.\n\nOutput\n\nThe spectral radiance of the black body, in units of W/(sr·m³).\n\nExample\n\nPlot the spectrum of a black body in 0 3 µm at 5000 K.  Use PyPlot.jl for plotting.\n\nusing PyPlot\nwavelength = range(0, stop=3e-6, length=1000);\ntemperature = ones(wavelength)*5000;\nflux = planck_wave.(wavelength, temperature);\nplot(wavelength, flux)\n\nNotes\n\nplanck_freq calculates the flux of a black body per unit frequency.\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.planet_coords-Tuple{Real, Integer}","page":"Reference","title":"AstroLib.planet_coords","text":"planet_coords(date, num)\n\nPurpose\n\nFind right ascension and declination for the planets when provided a date as input.\n\nExplanation\n\nThis function uses the helio to get the heliocentric ecliptic coordinates of the planets at the given date which it then converts these to geocentric ecliptic coordinates ala \"Astronomical Algorithms\" by Jean Meeus (1991, p 209). These are then converted to right ascension and declination using euler.\n\nThe accuracy between the years 1800 and 2050 is better than 1 arcminute for the terrestial planets, but reaches 10 arcminutes for Saturn. Before 1850 or after 2050 the accuracy can get much worse.\n\nArguments\n\ndate: Can be either a single date or an array of dates. Each element can be either a DateTime type or Julian Date. It can be a scalar or vector.\nnum: integer denoting planet number, scalar or vector 1 = Mercury, 2 = Venus, ... 9 = Pluto. If not in that change, then the program will throw an error.\n\nOutput\n\nra: right ascension of planet(J2000), in degrees\ndec: declination of the planet(J2000), in degrees\n\nExample\n\nFind the RA, Dec of Venus on 1992 Dec 20\n\njulia> using AstroLib, Dates\n\njulia> adstring(planet_coords(DateTime(1992,12,20),2))\n\" 21 05 02.8  -18 51 41\"\n\nNotes\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.polrec-Tuple{Real, Real}","page":"Reference","title":"AstroLib.polrec","text":"polrec(radius, angle[, degrees=true]) -> x, y\n\nPurpose\n\nConvert 2D polar coordinates to rectangular coordinates.\n\nExplanation\n\nThis is the partial inverse function of recpol.\n\nArguments\n\nradius: radial coordinate of the point.  It may be a scalar or an array.\nangle: the angular coordinate of the point.  It may be a scalar or an array of the same lenth as radius.\ndegrees (optional boolean keyword): if true, the angle is assumed to be in degrees, otherwise in radians.  It defaults to false.\n\nMandatory arguments can also be passed as the 2-tuple (radius, angle), so that it is possible to execute recpol(polrec(radius, angle)).\n\nOutput\n\nA 2-tuple (x, y) with the rectangular coordinate of the input.  If radius and angle are arrays, x and y are arrays of the same length as radius and angle.\n\nExample\n\nGet rectangular coordinates (x y) of the point with polar coordinates (r varphi) = (17 227), with angle varphi expressed in degrees.\n\njulia> using AstroLib\n\njulia> x, y = polrec(1.7, 227, degrees=true)\n(-1.1593972121062475, -1.2433012927525897)\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.posang-Tuple{Integer, Vararg{Real, 4}}","page":"Reference","title":"AstroLib.posang","text":"posang(units, ra1, dec1, ra2, dec2) -> angular_distance\n\nPurpose\n\nCompute rigorous position angle of point 2 relative to point 1.\n\nExplanation\n\nComputes the rigorous position angle of point 2 (with given right ascension and declination) using point 1 (with given right ascension and declination) as the center.\n\nArguments\n\nunits: integer, can be either 0, or 1, or 2.  Describes units of inputs and\n\noutput:     * 0: everything (input right ascensions and declinations, and output       distance) is radians     * 1: right ascensions are in decimal hours, declinations in decimal degrees,       output distance in degrees     * 2: right ascensions and declinations are in degrees, output distance in       degrees\n\nra1:  right ascension or longitude of point 1\ndec1: declination or latitude of point 1\nra2: right ascension or longitude of point 2\ndec2: declination or latitude of point 2\n\nBoth ra1 and dec1, and ra2 and dec2 can be given as 2-tuples (ra1, dec1) and (ra2, dec2).\n\nOutput\n\nAngle of the great circle containing [ra2, dec2] from the meridian containing [ra1, dec1], in the sense north through east rotating about [ra1, dec1]. See units argument above for units.\n\nMethod\n\nThe \"four-parts formula\" from spherical trigonometry (p. 12 of Smart's Spherical Astronomy or p. 12 of Green' Spherical Astronomy).\n\nExample\n\nMizar has coordinates (ra, dec) = (13h 23m 55.5s, +54° 55' 31'').  Its companion, Alcor, has coordinates (ra, dec) = (13h 25m 13.5s, +54° 59' 17''). Find the position angle of Alcor with respect to Mizar.\n\njulia> using AstroLib\n\njulia> posang(1, ten(13, 25, 13.5), ten(54, 59, 17), ten(13, 23, 55.5), ten(54, 55, 31))\n-108.46011246802047\n\nNotes\n\nThe function sphdist provides an alternate method of computing a spherical\n\ndistance.\n\nNote that posang is not commutative: the position angle between A and B is theta, then the position angle between B and A is 180 + theta.\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.precess-NTuple{4, Real}","page":"Reference","title":"AstroLib.precess","text":"precess(ra, dec, equinox1, equinox2[, FK4=true, radians=true]) -> prec_ra, prec_dec\n\nPurpose\n\nPrecess coordinates from equinox1 to equinox2.\n\nExplanation\n\nThe default (ra, dec) system is FK5 based on epoch J2000.0 but FK4 based on B1950.0 is available via the FK4 boolean keyword.\n\nArguments\n\nra: input right ascension, scalar or vector, in degrees, unless the radians keyword is set to true\ndec: input declination, scalar or vector, in degrees, unless the radians keyword is set to true\nequinox1: original equinox of coordinates, numeric scalar.\nequinox2: equinox of precessed coordinates.\nFK4 (optional boolean keyword): if this keyword is set to true, the FK4 (B1950.0) system precession angles are used to compute the precession matrix. When it is false, the default, use FK5 (J2000.0) precession angles.\nradians (optional boolean keyword): if this keyword is set to true, then the input and output right ascension and declination vectors are in radians rather than degrees.\n\nOutput\n\nThe 2-tuple (ra, dec) of coordinates modified by precession.\n\nExample\n\nThe Pole Star has J2000.0 coordinates (2h, 31m, 46.3s, 89d 15' 50.6\"); compute its coordinates at J1985.0\n\njulia> using AstroLib\n\njulia> ra, dec = ten(2,31,46.3)*15, ten(89,15,50.6)\n(37.94291666666666, 89.26405555555556)\n\njulia> adstring(precess(ra, dec, 2000, 1985), precision=1)\n\" 02 16 22.73  +89 11 47.3\"\n\nPrecess the B1950 coordinates of Eps Ind (RA = 21h 59m,33.053s, DEC = (-56d, 59', 33.053\") to equinox B1975.\n\njulia> using AstroLib\n\njulia> ra, dec = ten(21, 59, 33.053) * 15, ten(-56, 59, 33.053)\n(329.88772083333333, -56.992514722222225)\n\njulia> adstring(precess(ra, dec, 1950, 1975, FK4=true), precision=1)\n\" 22 01 15.46  -56 52 18.7\"\n\nMethod\n\nAlgorithm from \"Computational Spherical Astronomy\" by Taff (1983), p. 24. (FK4). FK5 constants from \"Explanatory Supplement To The Astronomical Almanac\" 1992, page 104 Table 3.211.1 (https://archive.org/details/131123ExplanatorySupplementAstronomicalAlmanac).\n\nNotes\n\nAccuracy of precession decreases for declination values near 90 degrees. precess should not be used more than 2.5 centuries from 2000 on the FK5 system (1950.0 on the FK4 system).  If you need better accuracy, use bprecess or jprecess as needed.\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.precess_cd","page":"Reference","title":"AstroLib.precess_cd","text":"precess_cd(cd, epoch1, epoch2, crval_old, crval_new[, FK4=true]) -> cd\n\nPurpose\n\nPrecess the coordinate description matrix.\n\nExplanation\n\nThe coordinate matrix is precessed from epoch1 to epoch2.\n\nArguments\n\ncd: 2 x 2 coordinate description matrix in degrees\nepoch1: original equinox of coordinates, scalar\nepoch2: equinox of precessed coordinates, scalar\ncrval_old: 2 element vector containing right ascension and declination in degrees of the reference pixel in the original equinox\ncrval_new: 2 element vector giving crval in the new equinox\nFK4 (optional boolean keyword): if this keyword is set to true, then the precession constants are taken in the FK4 reference frame. When it is false, the default is the FK5 frame\n\nOutput\n\ncd: coordinate description containing precessed values\n\nExample\n\njulia> using AstroLib\n\njulia> precess_cd([20 60; 45 45], 1950, 2000, [34, 58], [12, 83])\n2×2 Array{Float64,2}:\n  48.8944  147.075\n 110.188   110.365\n\nNotes\n\nCode of this function is based on IDL Astronomy User's Library. This function should not be used for values more than 2.5 centuries from the year 1900. This function calls sec2rad, precess and bprecess.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroLib/ref/#AstroLib.precess_xyz-NTuple{5, Real}","page":"Reference","title":"AstroLib.precess_xyz","text":"precess_xyz(x, y, z, equinox1, equinox2) -> prec_x, prec_y, prec_z\n\nPurpose\n\nPrecess equatorial geocentric rectangular coordinates.\n\nArguments\n\nx, y, z: scalars or vectors giving heliocentric rectangular coordinates.\nequinox1: original equinox of coordinates, numeric scalar.\nequinox2: equinox of precessed coordinates, numeric scalar.\n\nInput coordinates can be given also a 3-tuple (x, y, z).\n\nOutput\n\nThe 3-tuple (x, y, z) of coordinates modified by precession.\n\nExample\n\nPrecess 2000 equinox coordinates (1, 1, 1) to 2050.\n\njulia> using AstroLib\n\njulia> precess_xyz(1, 1, 1, 2000, 2050)\n(0.9838854500981734, 1.0110925876508692, 1.0048189888146941)\n\nMethod\n\nThe equatorial geocentric rectangular coordinates are converted to right ascension and declination, precessed in the normal way, then changed back to x, y and z using unit vectors.\n\nNotes\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.premat-Tuple{Real, Real}","page":"Reference","title":"AstroLib.premat","text":"premat(equinox1, equinox2[, FK4=true]) -> precession_matrix\n\nPurpose\n\nReturn the precession matrix needed to go from equinox1 to equinox2.\n\nExplanation\n\nThis matrix is used by precess and baryvel to precess astronomical coordinates.\n\nArguments\n\nequinox1: original equinox of coordinates.\nequinox2: equinox of precessed coordinates.\nFK4 (optional boolean keyword): if this keyword is set to true, the FK4 (B1950.0) system precession angles are used to compute the precession matrix. When it is false, the default, use FK5 (J2000.0) precession angles.\n\nOutput\n\nA 3×3 matrix, used to precess equatorial rectangular coordinates.\n\nExample\n\nReturn the precession matrix from 1950.0 to 1975.0 in the FK4 system\n\njulia> using AstroLib\n\njulia> premat(1950,1975,FK4=true)\n3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9} with indices SOneTo(3)×SOneTo(3):\n 0.999981    -0.00558775  -0.00242909\n 0.00558775   0.999984    -6.78691e-6\n 0.00242909  -6.78633e-6   0.999997\n\nMethod\n\nFK4 constants from \"Computational Spherical Astronomy\" by Taff (1983), p. 24. (FK4). FK5 constants from \"Explanatory Supplement To The Astronomical Almanac\" 1992, page 104 Table 3.211.1 (https://archive.org/details/131123ExplanatorySupplementAstronomicalAlmanac).\n\nNotes\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.rad2sec-Tuple{Real}","page":"Reference","title":"AstroLib.rad2sec","text":"rad2sec(rad) -> seconds\n\nPurpose\n\nConvert from radians to seconds.\n\nArgument\n\nrad: number of radians.\n\nOutput\n\nThe number of seconds corresponding to rad.\n\nExample\n\njulia> using AstroLib\n\njulia> rad2sec(1)\n206264.80624709636\n\nNotes\n\nUse sec2rad to convert seconds to radians.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.radec-Tuple{Real, Real}","page":"Reference","title":"AstroLib.radec","text":"radec(ra::Real, dec::Real[, hours=true]) -> ra_hours, ra_minutes, ra_seconds, dec_degrees, dec_minutes, dec_seconds\n\nPurpose\n\nConvert right ascension and declination from decimal to sexagesimal units.\n\nExplanation\n\nThe conversion is to sexagesimal hours for right ascension, and sexagesimal degrees for declination.\n\nArguments\n\nra: decimal right ascension, scalar or array.  It is expressed in degrees, unless the optional keyword hours is set to true.\ndec: declination in decimal degrees, scalar or array, same number of elements as ra.\nhours (optional boolean keyword): if false (the default), ra is assumed to be given in degrees, otherwise ra is assumed to be expressed in hours.\n\nOutput\n\nA 6-tuple of AbstractFloat:\n\n(ra_hours, ra_minutes, ra_seconds, dec_degrees, dec_minutes, dec_seconds)\n\nIf ra and dec are arrays, also each element of the output 6-tuple are arrays of the same dimension.\n\nExample\n\nPosition of Sirius in the sky is (ra, dec) = (6.7525, -16.7161), with right ascension expressed in hours.  Its sexagesimal representation is given by\n\njulia> using AstroLib\n\njulia> radec(6.7525, -16.7161, hours=true)\n(6.0, 45.0, 9.0, -16.0, 42.0, 57.9600000000064)\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.recpol-Tuple{Real, Real}","page":"Reference","title":"AstroLib.recpol","text":"recpol(x, y[, degrees=true]) -> radius, angle\n\nPurpose\n\nConvert 2D rectangular coordinates to polar coordinates.\n\nExplanation\n\nThis is the partial inverse function of polrec.\n\nArguments\n\nx: the abscissa coordinate of the point.  It may be a scalar or an array.\ny: the ordinate coordinate of the point.  It may be a scalar or an array of the same lenth as x.\ndegrees (optional boolean keyword): if true, the output angle is given\n\nin degrees, otherwise in radians.  It defaults to false.\n\nMandatory arguments may also be passed as the 2-tuple (x, y), so that it is possible to execute polrec(recpol(x, y)).\n\nOutput\n\nA 2-tuple (radius, angle) with the polar coordinates of the input.  The coordinate angle coordinate lies in the range -pi pi if degrees=false, or -180 180 when degrees=true.\n\nIf x and y are arrays, radius and angle are arrays of the same length as radius and angle.\n\nExample\n\nCalculate polar coordinates (r varphi) of point with rectangular coordinates (x y) = (224 -187).\n\njulia> using AstroLib\n\njulia> r, phi = recpol(2.24, -1.87)\n(2.9179616172938263, -0.6956158538564537)\n\nAngle varphi is given in radians.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.rhotheta-NTuple{8, Real}","page":"Reference","title":"AstroLib.rhotheta","text":"rhotheta(period, periastron, eccentricity, semimajor_axis, inclination, omega, omega2, epoch) -> rho, theta\n\nPurpose\n\nCalculate the separation and position angle of a binary star.\n\nExplanation\n\nThis function will return the separation rho and position angle theta of a visual binary star derived from its orbital elements.  The algorithms described in the following book will be used: Meeus J., 1992, Astronomische Algorithmen, Barth.  Compared to the examples given at page 400 and no discrepancy found.\n\nArguments\n\nperiod: period [year]\nperiastro: time of periastron passage [year]\neccentricity: eccentricity of the orbit\nsemimajor_axis: semi-major axis [arc second]\ninclination: inclination angle [degree]\nomega: node [degree]\nomega2: longitude of periastron [degree]\nepoch: epoch of observation [year]\n\nAll input parameters have to be scalars.\n\nOutput\n\nThe 2-tuple (rho theta), where\n\nrho is separation [arc second], and\ntheta is position angle (degree).\n\nExample\n\nFind the position of Eta Coronae Borealis at the epoch 2016\n\njulia> using AstroLib\n\njulia> ρ, θ = rhotheta(41.623, 1934.008, 0.2763, 0.907, 59.025, 23.717, 219.907, 2016)\n(0.6351167848659552, 214.42513387396497)\n\nNotes\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.sec2rad-Tuple{Real}","page":"Reference","title":"AstroLib.sec2rad","text":"sec2rad(sec) -> radians\n\nPurpose\n\nConvert from seconds to radians.\n\nArgument\n\nsec: number of seconds.\n\nOutput\n\nThe number of radians corresponding to sec.\n\nExample\n\njulia> using AstroLib\n\njulia> sec2rad(3600 * 30)\n0.5235987755982988\n\nNotes\n\nUse rad2sec to convert radians to seconds.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.sixty-Tuple{Real}","page":"Reference","title":"AstroLib.sixty","text":"sixty(number) -> [deg, min, sec]\n\nPurpose\n\nConverts a decimal number to sexagesimal.\n\nExplanation\n\nThe reverse of ten function.\n\nArgument\n\nnumber: decimal number to be converted to sexagesimal.\n\nOutput\n\nAn array of three AbstractFloat, that are the sexagesimal counterpart (degrees, minutes, seconds) of number.\n\nExample\n\njulia> using AstroLib\n\njulia> sixty(-0.615)\n3-element StaticArrays.SArray{Tuple{3},Float64,1,3} with indices SOneTo(3):\n -0.0\n 36.0\n 54.0\n\nNotes\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.sphdist-NTuple{4, Real}","page":"Reference","title":"AstroLib.sphdist","text":"sphdist(long1, lat1, long2, lat2[, degrees=true]) -> angular_distance\n\nPurpose\n\nAngular distance between points on a sphere.\n\nArguments\n\nlong1:  longitude of point 1\nlat1: latitude of point 1\nlong2: longitude of point 2\nlat2: latitude of point 2\ndegrees (optional boolean keyword): if true, all angles, including the output distance, are assumed to be in degrees, otherwise they are all in radians.  It defaults to false.\n\nOutput\n\nAngular distance on a sphere between points 1 and 2, as an AbstractFloat.  It is expressed in radians unless degrees keyword is set to true.\n\nExample\n\njulia> using AstroLib\n\njulia> sphdist(120, -43, 175, +22)\n1.5904422616007134\n\nNotes\n\ngcirc function is similar to sphdist, but may be more suitable for astronomical applications.\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.ten","page":"Reference","title":"AstroLib.ten","text":"ten(deg[, min, sec]) -> decimal\nten(\"deg:min:sec\") -> decimal\n\nPurpose\n\nConverts a sexagesimal number or string to decimal.\n\nExplanation\n\nten is the inverse of the sixty function.\n\nArguments\n\nten takes as argument either three scalars (deg, min, sec) or a string. The string should have the form \"deg:min:sec\" or \"deg min sec\".  Also any iterable like (deg, min, sec) or [deg, min, sec] is accepted as argument.\n\nIf minutes and seconds are not specified they default to zero.\n\nOutput\n\nThe decimal conversion of the sexagesimal numbers provided is returned.\n\nMethod\n\nThe formula used for the conversion is\n\nmathrmsign(mathrmdeg)left(mathrmdeg + fracmathrmmin60 + fracmathrmsec3600right)\n\nExample\n\njulia> using AstroLib\n\njulia> ten(-0.0, 19, 47)\n-0.3297222222222222\n\njulia> ten(\"+5:14:58\")\n5.249444444444444\n\njulia> ten(\"-10 26\")\n-10.433333333333334\n\njulia> ten((-10, 26))\n-10.433333333333334\n\nNotes\n\nThese functions cannot deal with -0 (negative integer zero) in numeric input. If it is important to give sense to negative zero, you can either make sure to pass a floating point negative zero -0.0 (this is the best option), or use negative minutes and seconds, or non-integer negative degrees and minutes.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroLib/ref/#AstroLib.tic_one","page":"Reference","title":"AstroLib.tic_one","text":"tic_one(zmin, pixx, incr[, ra=true]) -> min2, tic1\n\nPurpose\n\nDetermine the position of the first tic mark for astronomical images.\n\nExplanation\n\nFor use in labelling images with right ascension and declination axes. This routine determines the position in pixels of the first tic.\n\nArguments\n\nzmin: astronomical coordinate value at axis zero point (degrees  or hours).\npixx: distance in pixels between tic marks (usually obtained from tics).\nincr - increment in minutes for labels (usually an even number obtained  from the procedure tics).\nra (optional boolean keyword): if true, incremental value being entered  is in minutes of time, else it is assumed that value is in else it's in minutes of arc.  Default is false.\n\nOutput\n\nThe 2 tuple (min2, tic1):\n\nmin2: astronomical coordinate value at first tic mark\ntic1: position in pixels of first tic mark\n\nExample\n\nSuppose a declination axis has a value of 30.2345 degrees at its zero point.  A tic mark is desired every 10 arc minutes, which corresponds to 12.74 pixels, with increment for labels being 10 minutes. Then\n\njulia> using AstroLib\n\njulia> tic_one(30.2345, 12.74, 10)\n(30.333333333333332, 7.554820000000081)\n\nyields values of min2 ≈ 30.333 and tic1 ≈ 7.55482, i.e. the first tic mark should be labeled 30 deg 20 minutes and be placed at pixel value 7.55482.\n\nNotes\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroLib/ref/#AstroLib.ticpos-Tuple{Real, Real, Real}","page":"Reference","title":"AstroLib.ticpos","text":"ticpos(deglen, pixlen, ticsize) -> ticsize, incr, units\n\nPurpose\n\nSpecify distance between tic marks for astronomical coordinate overlays.\n\nExplanation\n\nUser inputs number an approximate distance between tic marks, and the axis length in degrees. ticpos will return a distance between tic marks such that the separation is a round multiple in arc seconds, arc minutes, or degrees.\n\nArguments\n\ndeglen: length of axis in degrees, positive scalar\npixlen: length of axis in plotting units (pixels), postive scalar\nticsize: distance between tic marks (pixels).  This value will be  adjusted by ticpos such that the distance corresponds to a round  multiple in the astronomical coordinate.\n\nOutput\n\nThe 3-tuple (ticsize, incr, units):\n\nticsize: distance between tic marks (pixels), positive scalar\nincr: incremental value for tic marks in round units given  by the units parameter\nunits: string giving units of ticsize, either 'Arc Seconds', 'Arc Minutes', or 'Degrees'\n\nExample\n\nSuppose a 512 x 512 image array corresponds to 0.2 x 0.2 degrees on the sky. A tic mark is desired in round angular units, approximately every 75 pixels. Then\n\njulia> using AstroLib\n\njulia> ticpos(0.2, 512, 75)\n(85.33333333333333, 2.0, \"Arc Minutes\")\n\ni.e. a good tic mark spacing is every 2 arc minutes, corresponding to 85.333 pixels.\n\nNotes\n\nAll the arguments taken as input are assumed to be positive in nature.\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.tics","page":"Reference","title":"AstroLib.tics","text":"tics(radec_min, radec_max, numx, ticsize[, ra=true]) -> ticsize, incr\n\nPurpose\n\nCompute a nice increment between tic marks for astronomical images.\n\nExplanation\n\nFor use in labelling a displayed image with right ascension or declination axes.  An approximate distance between tic marks is input, and a new value is computed such that the distance between tic marks is in simple increments of the tic label values.\n\nArguements\n\nradec_min : minimum axis value (degrees).\nradec_min : maximum axis value (degrees).\nnumx : number of pixels in x direction.\nticsize : distance between tic marks (pixels).\nra (optional boolean keyword): if true, incremental value would be in minutes of time. Default is false.\n\nOutput\n\nA 2-tuple (ticsize, incr):\n\nticsize : distance between tic marks (pixels).\nincr : incremental value for tic labels.  The format is dependent on the optional keyword. If true (i.e for right ascension), it's in minutes of time, else it's in minutes of arc (for declination).\n\nExample\n\njulia> using AstroLib\n\njulia> tics(55, 60, 100.0, 1/2)\n(0.66, 2.0)\n\njulia> tics(30, 60, 12, 2, true)\n(2.75, 30.0)\n\nNotes\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroLib/ref/#AstroLib.true_obliquity-Tuple{Real}","page":"Reference","title":"AstroLib.true_obliquity","text":"true_obliquity(jd) -> t_eps\n\nPurpose\n\nReturn the true obliquity of the ecliptic for a given Julian date\n\nExplanation\n\nThe function is used by the co_aberration procedure.\n\nArguments\n\njd: Julian date.\n\nOutput\n\nt_eps: true obliquity of the ecliptic, in radians\n\nExample\n\njulia> using AstroLib\n\njulia> true_obliquity(jdcnv(1978,01,7,11, 01))\n0.4090953896211926\n\nNotes\n\nThe function calls mean_obliquity.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.trueanom-Tuple{Real, Real}","page":"Reference","title":"AstroLib.trueanom","text":"trueanom(E, e) -> true anomaly\n\nPurpose\n\nCalculate true anomaly for a particle in elliptic orbit with eccentric anomaly E and eccentricity e.\n\nExplanation\n\nIn the two-body problem, once that the Kepler's equation is solved and E(t) is determined, the polar coordinates (r(t) theta(t)) of the body at time t in the elliptic orbit are given by\n\ntheta(t) = 2arctan left(sqrtfrac1 + e1 - e tanfracE(t)2 right)\n\nr(t) = fraca(1 - e^2)1 + ecos(theta(t) - theta_0)\n\nin which a is the semi-major axis of the orbit, and theta_0 the value of angular coordinate at time t = t_0.\n\nArguments\n\nE: eccentric anomaly.\ne: eccentricity, in the elliptic motion regime (0 leq e leq 1)\n\nOutput\n\nThe true anomaly.\n\nExample\n\nPlot the true anomaly as a function of mean anomaly for eccentricity e = 0, 05, 09.  Use PyPlot.jl for plotting.\n\nusing PyPlot\nM = range(0, stop=2pi, length=1001)[1:end-1];\nfor ecc in (0, 0.5, 0.9)\n    plot(M, mod2pi.(trueanom.(kepler_solver.(M, ecc), ecc)))\nend\n\nNotes\n\nThe eccentric anomaly can be calculated with kepler_solver function.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.uvbybeta","page":"Reference","title":"AstroLib.uvbybeta","text":"uvbybeta(by, m1, c1, n[, hbeta=NaN, eby_in=NaN]) -> te, mv, eby, delm0, radius\n\nPurpose\n\nDerive dereddened colors, metallicity, and Teff from Stromgren colors.\n\nArguments\n\nby: Stromgren b-y color\nm1: Stromgren line-blanketing parameter\nc1: Stromgren Balmer discontinuity parameter\nn: Integer which can be any value between 1 to 8, giving approximate stellar classification. (1) B0 - A0, classes III - V, 2.59 < Hbeta < 2.88,-0.20 <   c0   < 1.00 (2) B0 - A0, class   Ia     , 2.52 < Hbeta < 2.59,-0.15 <   c0   < 0.40 (3) B0 - A0, class   Ib     , 2.56 < Hbeta < 2.61,-0.10 <   c0   < 0.50 (4) B0 - A0, class   II     , 2.58 < Hbeta < 2.63,-0.10 <   c0   < 0.10 (5) A0 - A3, classes III - V, 2.87 < Hbeta < 2.93,-0.01 < (b-y)o < 0.06 (6) A3 - F0, classes III - V, 2.72 < Hbeta < 2.88, 0.05 < (b-y)o < 0.22 (7) F1 - G2, classes III - V, 2.60 < Hbeta < 2.72, 0.22 < (b-y)o < 0.39 (8) G2 - M2, classes  IV - V, 0.20 < m0    < 0.76, 0.39 < (b-y)o < 1.00\nhbeta (optional): H-beta line strength index. If it is not supplied, then by default its value will be NaN and the code will estimate a value based on by, m1,and c1. It is not used for stars in group 8.\neby_in (optional): specifies the E(b-y) color to use. If not supplied, then by default its value will be NaN and E(b-y) will be estimated from the Stromgren colors.\n\nOutput\n\nte: approximate effective temperature\nmv: absolute visible magnitude\neby: color excess E(b-y)\ndelm0: metallicity index, delta m0, may not be calculable for early B stars and so returns NaN.\nradius: stellar radius (R/R(solar))\n\nExample\n\nSuppose 5 stars have the following Stromgren parameters\n\nby = [-0.001 ,0.403, 0.244, 0.216, 0.394] m1 = [0.105, -0.074, -0.053, 0.167, 0.186] c1 = [0.647, 0.215, 0.051, 0.785, 0.362] hbeta = [2.75, 2.552, 2.568, 2.743, 0] nn = [1,2,3,7,8]\n\nDetermine the stellar parameters\n\njulia> using AstroLib\n\njulia> by = [-0.001 ,0.403, 0.244, 0.216, 0.394];\n\njulia> m1 = [0.105, -0.074, -0.053, 0.167, 0.186];\n\njulia> c1 = [0.647, 0.215, 0.051, 0.785, 0.362];\n\njulia> hbeta = [2.75, 2.552, 2.568, 2.743, 0];\n\njulia> nn = [1,2,3,7,8];\n\njulia> uvbybeta.(by, m1, c1, nn, hbeta)\n5-element Array{NTuple{5,Float64},1}:\n (13057.535222326893, -0.27375469585031265, 0.04954396423248884, -0.008292894218734928, 2.7136529525371897)\n (14025.053834219656, -6.907050783073221, 0.4140562248995983, NaN, 73.50771722263974)\n (18423.76405400214, -5.935816553877892, 0.2828247876690783, NaN, 39.84106215808709)\n (7210.507090112837, 2.2180408083364167, 0.018404079180028038, 0.018750927360588615, 2.0459018065648165)\n (5755.671513413262, 3.9449408311022, -0.025062997393370458, 0.03241423718769865, 1.5339239690774464)\n\nNotes\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroLib/ref/#AstroLib.vactoair-Tuple{Real}","page":"Reference","title":"AstroLib.vactoair","text":"vactoair(wave_vacuum) -> wave_air\n\nPurpose\n\nConverts vacuum wavelengths to air wavelengths.\n\nExplanation\n\nCorrects for the index of refraction of air under standard conditions. Wavelength values below 2000 Å will not be altered.  Uses relation of Ciddor (1996).\n\nArguments\n\nwave_vacuum: vacuum wavelength in angstroms.  Wavelengths are corrected for the index of refraction of air under standard conditions.  Wavelength values below 2000 Å will not be altered, take care within 1 Å 2000 Å.\n\nOutput\n\nAir wavelength in angstroms.\n\nMethod\n\nUses relation of Ciddor (1996), Applied Optics 35, 1566 (http://adsabs.harvard.edu/abs/1996ApOpt..35.1566C).\n\nExample\n\nIf the vacuum wavelength is w = 2000, then vactoair(w) yields an air wavelength of 1999.353.\n\njulia> using AstroLib\n\njulia> vactoair(2000)\n1999.3526230448367\n\nNotes\n\nairtovac converts air wavelengths to vacuum wavelengths.\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.xyz","page":"Reference","title":"AstroLib.xyz","text":"xyz(jd[, equinox]) -> x, y, z, v_x, v_y, v_z\n\nPurpose\n\nCalculate geocentric x, y, and z and velocity coordinates of the Sun.\n\nExplanation\n\nCalculates geocentric x, y, and z vectors and velocity coordinates (dx, dy and dz) of the Sun.  (The positive x axis is directed towards the equinox, the y-axis, towards the point on the equator at right ascension 6h, and the z axis toward the north pole of the equator).  Typical position accuracy is 10^-4 AU (15000 km).\n\nArguments\n\njd: number of Reduced Julian Days for the wanted date.  It can be either a scalar or a vector.\nequinox (optional numeric argument): equinox of output. Default is 1950.\n\nYou can use juldate to get the number of Reduced Julian Days for the selected dates.\n\nOutput\n\nThe 6-tuple (x y z v_x v_y v_z), where\n\nx y z: scalars or vectors giving heliocentric rectangular coordinates (in AU) for each date supplied.  Note that sqrtx^2 + y^2 + z^2 gives the Earth-Sun distance for the given date.\nv_x v_y v_z: velocity vectors corresponding to x y, and z.\n\nExample\n\nWhat were the rectangular coordinates and velocities of the Sun on 1999-01-22T00:00:00 (= JD 2451200.5) in J2000 coords?  Note: Astronomical Almanac (AA) is in TDT, so add 64 seconds to UT to convert.\n\njulia> using AstroLib, Dates\n\njulia> jd = juldate(DateTime(1999, 1, 22))\n51200.5\n\njulia> xyz(jd + 64/86400, 2000)\n(0.514568709240398, -0.7696326261820209, -0.33376880143023935, 0.014947267514079971, 0.008314838205477328, 0.003606857607575486)\n\nCompare to Astronomical Almanac (1999 page C20)\n\n            x  (AU)        y  (AU)     z (AU)\nxyz:      0.51456871   -0.76963263  -0.33376880\nAA:       0.51453130   -0.7697110   -0.3337152\nabs(err): 0.00003739    0.00007839   0.00005360\nabs(err)\n    (km):   5609          11759         8040\n\nNOTE: Velocities in AA are for Earth/Moon barycenter       (a very minor offset) see AA 1999 page E3\n\n           x vel (AU/day) y vel (AU/day)   z vel (AU/day)\nxyz:      -0.014947268   -0.0083148382    -0.0036068576\nAA:       -0.01494574    -0.00831185      -0.00360365\nabs(err):  0.000001583    0.0000029886     0.0000032076\nabs(err)\n (km/sec): 0.00265        0.00519          0.00557\n\nNotes\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroLib/ref/#AstroLib.ydn2md-Tuple{Integer, Integer}","page":"Reference","title":"AstroLib.ydn2md","text":"ydn2md(year, day) -> date\n\nPurpose\n\nConvert from year and day number of year to a date.\n\nExplanation\n\nReturns the date corresponding to the day of year.\n\nArguments\n\nyear: the year, as an integer.\nday: the day of year, as an integer.\n\nOutput\n\nThe date, of Date type, of textday - 1 days after January 1st of year.\n\nExample\n\nFind the date of the 60th and 234th days of the year 2016.\n\njulia> using AstroLib\n\njulia> ydn2md.(2016, [60, 234])\n2-element Array{Dates.Date,1}:\n 2016-02-29\n 2016-08-21\n\nNote\n\nymd2dn converts from a date to day of the year.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroLib/ref/#AstroLib.ymd2dn","page":"Reference","title":"AstroLib.ymd2dn","text":"ymd2dn(date) -> number_of_days\n\nPurpose\n\nConvert from a date to day of the year.\n\nExplanation\n\nReturns the day of the year for date with January 1st being day 1.\n\nArguments\n\ndate: the date with Date type.  Can be a single date or an array of dates.\n\nOutput\n\nThe day of the year for the given date.  If date is an array, returns an array of days.\n\nExample\n\nFind the days of the year for March 5 in the years 2015 and 2016 (this is a leap year).\n\njulia> using AstroLib, Dates\n\njulia> ymd2dn.([Date(2015, 3, 5), Date(2016, 3, 5)])\n2-element Array{Int64,1}:\n 64\n 65\n\nNote\n\nydn2md converts from year and day number of year to a date.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroLib/ref/#AstroLib.zenpos","page":"Reference","title":"AstroLib.zenpos","text":"zenpos(jd, latitude, longitude) -> zenith_right_ascension, declination\nzenpos(date, latitude, longitude, tz) -> zenith_right_ascension, declination\n\nPurpose\n\nReturn the zenith right ascension and declination in radians for a given Julian date or a local civil time and timezone.\n\nExplanation\n\nThe local sidereal time is computed with the help of ct2lst, which is the right ascension of the zenith. This and the observatories latitude (corresponding to the declination) are converted to radians and returned as the zenith direction.\n\nArguments\n\nThe function can be called in two different ways. The arguments common to both methods are latitude and longitude:\n\nlatitude : latitude of the desired location.\nlongitude : longitude of the desired location.\n\nThe zenith direction can be computed either by providing the Julian date:\n\njd : the Julian date of the date and time for which the zenith position is desired.\n\nor the time zone and the date:\n\ntz: the time zone (in hours) of the desired location (e.g. 4 = EDT, 5 = EST)\ndate: the local civil time with type DateTime.\n\nOutput\n\nA 2-tuple (ra, dec):\n\nra : the right ascension (in radians) of the zenith.\ndec : the declination (in radians) of the zenith.\n\nExample\n\njulia> using AstroLib, Dates\n\njulia> zenpos(DateTime(2017, 04, 25, 18, 59), 43.16, -24.32, 4)\n(0.946790432684706, 0.7532841051607526)\n\njulia> zenpos(jdcnv(2016, 05, 05, 13, 41), ten(35,0,42), ten(135,46,6))\n(3.5757821152779536, 0.6110688599440813)\n\nNotes\n\nCode of this function is based on IDL Astronomy User's Library.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/curve-fit/#curve-fit","page":"Curve Fitting","title":"Curve Fitting","text":"","category":"section"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"This tutorial will demonstrate fitting data with a straight line (linear regression), an abitrary non-linear model, and finally a Bayesian model.","category":"page"},{"location":"tutorials/curve-fit/#Packages","page":"Curve Fitting","title":"Packages","text":"","category":"section"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"LinearAlgebra we'll use this built-in Julia standard library to perform a linear regression\nOptimization: we'll use this package to display coordinates along the image and add the scalebar\nOptimizationOptimJL: the specific optimizer backend we will use.  For your own problems, select the best backend from the Optimization.jl documentation page.\nTuring: we'll use this package for Bayesian modelling.\nPairPlots: we'll use this for creating a corner plot of the posterior from our Bayesian models.","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"You can install the necessary packages by running Julia, and typing ] to enter Pkg-mode. Then: add Plots Optimization OptimizationOptimJL Turing PairPlots. Alternatively, you can run using Pkg; Pkg.add([\"Plots\", \"Optimization\", \"OptimizationOptimJL\", \"Turing\", \"PairPlots\"]). In your own code, you most likely won't need all of these packages. Pick and choose the one that best fits your problem.","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"If you will be using these tools as part of a bigger project, it's strongly recommended to create a Julia Project to record package versions. If you're just experimenting, you can create a temporary project by running ] activate --temp.","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"If you're using Pluto notebooks, installing and recording package versions in a project are handled for you automatically.","category":"page"},{"location":"tutorials/curve-fit/#Generating-the-data","page":"Curve Fitting","title":"Generating the data","text":"","category":"section"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"We'll generate synthetic data for this problem. We'll make a weak parabola with some noise. For consistency, we'll seed the Julia random number generator so that we see the same noise each time the tutorial is run.","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"julia> using Random\njulia> Random.seed!(1234)","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"By calling seed!, the pattern of random numbers generated by rand and randn will be the same each time.","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"Now we'll generate the data:","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"julia> x = 0:5:100 # Or equivalently: range(0, 100, step=5)\n0:1:100\n\njulia> y = (x ./ 20 .- 0.2).^2 .+ 2 .+ randn(length(x))\n101-element Vector{Float64}:\n  3.010656328855214\n  1.0432815884648003\n  ⋮\n 25.653998582068482\n 26.260043796712125\n","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"The randn function generates a random value normally distributed around 0 with a standard deviation of 1. rand on the other hand creates uniformly distributed random values distributed between 0 and 1.","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"Let's plot the data to see what it looks like:","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"julia> using Plots\njulia> scatter(x, y; xlabel=\"x\", ylabel=\"y\", label=\"data\")","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"(Image: )","category":"page"},{"location":"tutorials/curve-fit/#Linear-regression","page":"Curve Fitting","title":"Linear regression","text":"","category":"section"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"Before using any packages, let's perform a linear fit from scratch using some linear algebra.","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"The equation of a line can be written in matrix form as ","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"quad\nbeginpmatrix \nN  sum y_i \nsum y_i  sum y_i^2\nendpmatrix\nbeginpmatrix\nc_1 \nc_2 \nendpmatrix=\nbeginpmatrix\nsum y_i \nsum y_i x_i\nendpmatrix","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"where c_1 and c_2 are the intercept and slope.","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"Multiplying both sides by the inverse of the first matrix gives","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"quad\nbeginpmatrix\nc_1 \nc_2 \nendpmatrix=\nbeginpmatrix \nN  sum y_i \nsum y_i  sum y_i^2\nendpmatrix^-1\nbeginpmatrix\nsum y_i \nsum y_i x_i\nendpmatrix","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"We can write the right-hand side matrix and vector (let's call them A and b) in Julia notation like so:","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"julia> A = [\n          length(x) sum(x)\n          sum(x)    sum(x.^2)\n      ]\n2×2 Matrix{Int64}:\n   21   1050\n 1050  71750\n\njulia> b = [\n           sum(y)\n           sum(y .* x)                                          \n       ]\n2-element Vector{Float64}:\n   210.4250937868108\n 15023.030866331104","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"We can now perform the linear fit by solving the system of equations with the \\ operator:","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"julia> c = A\\b\n2-element Vector{Float64}:\n -1.67268257376372\n  0.2338585027008085\n","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"Let's make a helper function linfunc that takes an x value, a slope, and an intercept and calculates the corresponding y value:","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"julia> linfunc(x; slope, intercept) = slope*x + intercept\nlinfunc (generic function with 1 method)\n","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"Finally, we can plot the solution:","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"julia> yfit = linfunc.(x; slope=c[2], intercept=c[1])\njulia> scatter(x, y, xlabel=\"x\", ylabel=\"y\", label=\"data\")\njulia> plot!(x, yfit, label=\"best fit\")","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"(Image: )","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"The packages LsqFit and GLM (for generalized linear models) contain functions for performing and evaluating these types of linear fits.","category":"page"},{"location":"tutorials/curve-fit/#(Non-)linear-curve-fit","page":"Curve Fitting","title":"(Non-)linear curve fit","text":"","category":"section"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"The packages above can be used to fit different polynomial models, but if we have a truly arbitrary Julia function we would like to fit to some data we can use the Optimization.jl package. Through its various backends, Optimization.jl supports a very wide range of algorithms for local, global, convex, and non-convex optimization. ","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"The first step is to define our objective function. We'll reuse our simple linfunc linear function from above:","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"linfunc(x; slope, intercept) = slope*x + intercept\n\n# We must supply an objective function that will be minimized\n# The u argument is a vector of parameters from the optimizer.\n# data is a vector of static parameters passed through below.\nfunction objective(u, data)\n    # Get our fit parameters from u\n    slope, intercept = u\n    # equivalent to:\n    # slope = u[1]\n    # intercept = u[2]\n\n    # Get the x and y vectors from data\n    x, y = data\n    \n    # Calculate the residuals between our model and the data\n    residuals = linfunc.(x; slope, intercept) .- y\n\n    # Return the sum of squares of the residuals to minimize\n    return sum(residuals.^2)\nend\n\n# Define the initial parameter values for slope and intercept\nu0 = [1.0, 1.0]\n# Pass through the data we want to fit\ndata = [x,y]\n\n# Create an OptimizationProblem object to hold the function, initial\n# values, and data.\nusing Optimization\nprob = OptimizationProblem(objective,u0,data)\n\n# Import the optimization backend we want to use\nusing OptimizationOptimJL\n\n# Minimize the function. Optimization.jl uses the SciML common solver\n# interface. Pass the problem you want to solve (optimization problem\n# here) and a solver to use.\n# NelderMead() is a derivative-free method for finding a function's\n# local minimum.\nsol = solve(prob,NelderMead())\n\n# Exctract the best-fitting parameters\nslope, intercept = sol.u","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"Note: the NelderMead() algorithm behaves nearly identically to MATLAB's fminsearch. ","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"We can now plot the solution:","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"julia> yfit = linfunc.(x; slope, intercept)\njulia> scatter(x, y, xlabel=\"x\", ylabel=\"y\", label=\"data\")\njulia> plot!(x, yfit, label=\"best fit\")","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"(Image: )","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"We can now test out a quadratic fit using the same package:","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"function objective(u, data)\n    x, y = data\n    \n    # Define an equation of a quadratic, e.g.:\n    # 3x^2 + 2x + 1\n    model = u[1] .* x.^2 .+ u[2] .* x .+ u[3]\n\n    # Calculate the residuals between our model and the data\n    residuals = model .- y\n\n    # Return the sum of squares of the residuals to minimize\n    return sum(residuals.^2)\nend\n\nu0 = [1.0, 1.0, 1.0]\ndata = [x,y]\nprob = OptimizationProblem(objective,u0,data)\nusing OptimizationOptimJL\nsol = solve(prob,NelderMead())\nu = sol.u\n\nyfit = u[1] .* x.^2 .+ u[2] .* x .+ u[3]\n\nscatter(x, y, xlabel=\"x\", ylabel=\"y\", label=\"data\")\nplot!(x,  yfit, label=\"quadratic fit\")","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"(Image: )","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"This is already very fast; however, as the scale of your problem grows, there are several routes you can take to improve the optimization performance. First, you can use automatic differentiation and a higher order optimization algorithm:","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"using ForwardDiff\noptf = OptimizationFunction(objective, Optimization.AutoForwardDiff())\nprob = OptimizationProblem(optf,u0,data)\n@time sol = solve(prob,BFGS())  # another good algorithm is Newton()","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"You can also write an \"in-place\" version of objective that doesn't allocate new arrays with each iteration.","category":"page"},{"location":"tutorials/curve-fit/#Bayesian-models","page":"Curve Fitting","title":"Bayesian models","text":"","category":"section"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"Let's shift gears and now create a fully Bayesian model using the Turing.jl package.","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"Instead of defining an arbitrary Julia function, this package requires us to use a macro called @model.","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"Let's start with a linear model once more, now with the Turing @model syntax:","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"# Bayesian linear regression.\n@model function linear_regression(x, y)\n    # Set variance prior.\n    σ₂ ~ truncated(Normal(0, 100), 0, Inf)\n    # Typed as \\sigma <tab> \\_2 <tab>\n\n    # Set intercept prior.\n    intercept ~ Normal(0, 5)\n\n    # Set the prior on our slope coefficient.\n    slope ~ Normal(0, 10)\n\n    # Each point is drawn from a gaussian (Normal) distribution\n    # with mean calculated form our linear model, and standard\n    # deviation as the square root of the variance variable\n    for i in eachindex(x,y)\n        y[i] ~ Normal(x[i] * slope + intercept, sqrt(σ₂))\n    end\nend\n","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"We can now draw posterior samples from this model using one of many available samplers, NUTS, the No U-Turn Sampler.","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"model = linear_regression(x, y)\nchain = sample(model, NUTS(0.65), 500)","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"┌ Info: Found initial step size\n└   ϵ = 0.003125\nSampling 100%|█████████████████████████████████████| Time: 0:00:05\nChains MCMC chain (25000×15×1 Array{Float64, 3}):\n\nIterations        = 1001:1:26000\nNumber of chains  = 1\nSamples per chain = 25000\nWall duration     = 5.88 seconds\nCompute duration  = 5.88 seconds\nparameters        = σ₂, intercept, slope\ninternals         = lp, n_steps, is_accept, acceptance_rate, log_density, hamiltonian_energy, hamiltonian_energy_error, max_hamiltonian_energy_error, tree_depth, numerical_error, step_size, nom_step_size\n\nSummary Statistics\n  parameters      mean       std   naive_se      mcse          ess      rhat   ess_per_sec \n      Symbol   Float64   Float64    Float64   Float64      Float64   Float64       Float64\n\n          σ₂    6.7431    2.6279     0.0166    0.0265   10640.9415    1.0000     1810.6077\n   intercept   -1.5979    1.0739     0.0068    0.0105   10239.7534    1.0001     1742.3436\n       slope    0.2328    0.0186     0.0001    0.0002   10306.9493    1.0001     1753.7773\n\nQuantiles\n  parameters      2.5%     25.0%     50.0%     75.0%     97.5% \n      Symbol   Float64   Float64   Float64   Float64   Float64\n\n          σ₂    3.3126    4.9457    6.1965    7.9372   13.3608\n   intercept   -3.6910   -2.2965   -1.5992   -0.9049    0.5423\n       slope    0.1959    0.2206    0.2329    0.2449    0.2690","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"intercept = chain[\"intercept\"]\nslope = chain[\"slope\"]\nσ₂ = chain[\"σ₂\"]\n\nplot(x, x .* slope' .+ intercept';\n    label=\"\",\n    color=:gray,\n    alpha=0.05\n)\nscatter!(x, y, xlabel=\"x\", ylabel=\"y\", label=\"data\", color=1)","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"(Image: )","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"Each gray curve is a sample from the posterior distribution of this model. To examine the model parameters and their covariance in greater detail, we can make a corner plot using the PairPlots.jl package. We'll need a few more samples for a nice plot, so re-run the NUTS sampler with more iterations first.","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"Random.seed!(1234)\nchain = sample(model, NUTS(0.65), 25_000)\n\nusing PairPlots\ntable = (;\n    intercept= chain[\"intercept\"],\n    slope= chain[\"slope\"],\n    σ= sqrt.(chain[\"σ₂\"])\n)\nPairPlots.corner(table)","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"(Image: )","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"Let's now repeat this proceedure with a Bayesian quadratic model.","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"@model function quad_regression(x, y)\n    # Prior on the variance of the data around the best-fit line\n    σ₂ ~ truncated(Normal(0, 10), 0, Inf)\n\n    # Priors on the three quadratic parameters\n    u1 ~ Normal(0,0.01)\n    u2 ~ Normal(0,0.1)\n    u3 ~ Normal(0,5)\n\n    for i in eachindex(x,y)\n        model = u1 * x[i]^2 + u2*x[i] + u3\n        y[i] ~ Normal(model, sqrt(σ₂))\n    end\nend\n","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"We can now draw posterior samples from this model using one of many available samplers, NUTS, or the No U-Turn Sampler.","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"model = quad_regression(x, y)\nchain = sample(model, NUTS(0.65), 500)","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"┌ Info: Found initial step size\n└   ϵ = 0.0001953125\nSampling 100%|█████████████████████████████████████| Time: 0:00:05\nChains MCMC chain (500×16×1 Array{Float64, 3}):\n\nIterations        = 251:1:750\nNumber of chains  = 1\nSamples per chain = 500\nWall duration     = 5.89 seconds\nCompute duration  = 5.89 seconds\nparameters        = σ₂, u1, u2, u3\ninternals         = lp, n_steps, is_accept, acceptance_rate, log_density, hamiltonian_energy, hamiltonian_energy_error, max_hamiltonian_energy_error, tree_depth, numerical_error, step_size, nom_step_size\n\nSummary Statistics\n  parameters      mean       std   naive_se      mcse        ess      rhat   ess_per_sec \n      Symbol   Float64   Float64    Float64   Float64    Float64   Float64       Float64\n\n          σ₂    1.5698    0.6322     0.0283    0.0518   117.5553    0.9994       19.9517\n          u1    0.0024    0.0003     0.0000    0.0000   134.9184    0.9997       22.8986\n          u2   -0.0059    0.0283     0.0013    0.0024   107.3698    0.9995       18.2230\n          u3    2.1371    0.6109     0.0273    0.0562    87.2121    0.9995       14.8018\n\nQuantiles\n  parameters      2.5%     25.0%     50.0%     75.0%     97.5% \n      Symbol   Float64   Float64   Float64   Float64   Float64\n\n          σ₂    0.8757    1.1468    1.3945    1.8181    3.3834\n          u1    0.0018    0.0022    0.0024    0.0026    0.0030\n          u2   -0.0612   -0.0237   -0.0045    0.0133    0.0438\n          u3    0.9635    1.7155    2.1211    2.5172    3.3960","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"u1 = chain[\"u1\"]\nu2 = chain[\"u2\"]\nu3 = chain[\"u3\"]\nposterior = u1' .* x.^2 .+ u2' .* x .+ u3'\n\nplot(x, posterior;\n    label=\"\",\n    color=:gray,\n    alpha=0.1\n)\nscatter!(x, y, xlabel=\"x\", ylabel=\"y\", label=\"data\", color=1)","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"(Image: )","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"Random.seed!(1)\nchain = sample(model, NUTS(0.65), 25_000)\n\nusing PairPlots\ntable = (;\n    u_1 = chain[\"u1\"],\n    u_2 = chain[\"u2\"],\n    u_3 = chain[\"u3\"],\n    σ= sqrt.(chain[\"σ₂\"])\n)\nPairPlots.corner(table)","category":"page"},{"location":"tutorials/curve-fit/","page":"Curve Fitting","title":"Curve Fitting","text":"(Image: )","category":"page"},{"location":"tutorials/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"tutorials/","page":"Getting Started","title":"Getting Started","text":"Welcome! This page contains links to general tutorials useful to astronomers and astrophysicists getting started with Julia.","category":"page"},{"location":"tutorials/","page":"Getting Started","title":"Getting Started","text":"In Julia, smaller focussed packages are preferred. This page shows how you can combine smaller packages to get big results!","category":"page"},{"location":"tutorials/","page":"Getting Started","title":"Getting Started","text":"For more advanced usage examples, please see the documentation pages of the individual packages linked on the Ecosystem page.","category":"page"},{"location":"tutorials/#Installing-Julia","page":"Getting Started","title":"Installing Julia","text":"","category":"section"},{"location":"tutorials/","page":"Getting Started","title":"Getting Started","text":"To install Julia, it's strongly recommended to download the official binary for your operating system.  Visit the julialang.org Downloads page, and select the latest stable version for your operating system. Currently, this is 1.7.3. Click the [help] links next to your operating system if you require more detailed instructions.","category":"page"},{"location":"tutorials/#Installing-Packages","page":"Getting Started","title":"Installing Packages","text":"","category":"section"},{"location":"tutorials/","page":"Getting Started","title":"Getting Started","text":"Julia packages are installed and managed using the built-in package manager called Pkg.jl. You can either use it interactively by entering \"Pkg mode\" in your terminal, or programatically. We'll illustrate interactive use here.","category":"page"},{"location":"tutorials/","page":"Getting Started","title":"Getting Started","text":"Start julia in a terminal by running julia.\nType ] to enter package-mode (see Julia documentation for more details)\nType add SomePackage to install a package, replacing SomePackage with the desired package name without the .jl extension.","category":"page"},{"location":"tutorials/","page":"Getting Started","title":"Getting Started","text":"This will take a little while to download all the required packages and precompile for your system. If you have several packages to install, list them all at once instead of one by one to save time: add SomePackage1 SomePackage2 SomePackage3","category":"page"},{"location":"tutorials/","page":"Getting Started","title":"Getting Started","text":"It's recommended to use Julia projects to store what packages you use and make it easier to reproduce your work. You can create or activate a previously created project by entering Pkg-mode (type ]) and running activate myproject. Another option is to create a folder for your project, and start julia in that folder with the option julia --project=./. ","category":"page"},{"location":"tutorials/","page":"Getting Started","title":"Getting Started","text":"For more information on how to use the Julia package manager, refer to the Pkg.jl documentation.","category":"page"},{"location":"tutorials/#Tutorial-Index","page":"Getting Started","title":"Tutorial Index","text":"","category":"section"},{"location":"tutorials/","page":"Getting Started","title":"Getting Started","text":"The following tutorials show how to use Julia to perform common taks in astronomy and astrophysics.","category":"page"},{"location":"tutorials/#General","page":"Getting Started","title":"General","text":"","category":"section"},{"location":"tutorials/","page":"Getting Started","title":"Getting Started","text":"Plot a JWST image with world coordinates and a scale bar\nLoad tabular data from a FITS file and plot acceleration of nearby stars\nCurve fitting: least square and Bayesian","category":"page"},{"location":"highlevels/orb-ephem/#Orbits-and-Ephemerides-Overview","page":"Orbits & Ephemerides Overview","title":"Orbits & Ephemerides Overview","text":"","category":"section"},{"location":"highlevels/orb-ephem/#[Transits.jl](https://github.com/JuliaAstro/Transits.jl)-[![](../assets/book.png)](https://juliaastro.github.io/Transits.jl/stable/)","page":"Orbits & Ephemerides Overview","title":"Transits.jl (Image: )","text":"","category":"section"},{"location":"highlevels/orb-ephem/","page":"Orbits & Ephemerides Overview","title":"Orbits & Ephemerides Overview","text":"Flexible photometric transit curves with limb darkening","category":"page"},{"location":"highlevels/orb-ephem/","page":"Orbits & Ephemerides Overview","title":"Orbits & Ephemerides Overview","text":"Inspired by exoplanet\nIncludes Keplerian orbits and generic orbits\nFully compatible with Unitful.jl","category":"page"},{"location":"highlevels/orb-ephem/#[sefffal/PlanetOrbits.jl](https://github.com/sefffal/PlanetOrbits.jl)-[![](../assets/book.png)](https://sefffal.github.io/PlanetOrbits.jl/stable/)","page":"Orbits & Ephemerides Overview","title":"sefffal/PlanetOrbits.jl (Image: )","text":"","category":"section"},{"location":"highlevels/orb-ephem/","page":"Orbits & Ephemerides Overview","title":"Orbits & Ephemerides Overview","text":"Tools for displaying and solving Keplerian orbits in the context of direct imaging","category":"page"},{"location":"highlevels/orb-ephem/#[EarthOrientation.jl](https://github.com/JuliaAstro/EarthOrientation.jl)-[![](../assets/book.png)](https://juliaastro.github.io/EarthOrientation.jl/stable/)","page":"Orbits & Ephemerides Overview","title":"EarthOrientation.jl (Image: )","text":"","category":"section"},{"location":"highlevels/orb-ephem/","page":"Orbits & Ephemerides Overview","title":"Orbits & Ephemerides Overview","text":"Earth orientation parameters","category":"page"},{"location":"highlevels/orb-ephem/","page":"Orbits & Ephemerides Overview","title":"Orbits & Ephemerides Overview","text":"Calculate Earth orientation parameters from IERS tables","category":"page"},{"location":"highlevels/orb-ephem/#[JPLEphemeris.jl](https://github.com/JuliaAstro/JPLEphemeris.jl)","page":"Orbits & Ephemerides Overview","title":"JPLEphemeris.jl","text":"","category":"section"},{"location":"highlevels/orb-ephem/","page":"Orbits & Ephemerides Overview","title":"Orbits & Ephemerides Overview","text":"JPL Development Ephemerides","category":"page"},{"location":"highlevels/orb-ephem/","page":"Orbits & Ephemerides Overview","title":"Orbits & Ephemerides Overview","text":"Calculate positions and velocities of solar system bodies","category":"page"},{"location":"highlevels/orb-ephem/#[AstroLib.jl](https://github.com/JuliaAstro/astrolib.jl)-[![](../assets/book.png)](https://juliaastro.github.io/AstroLib.jl/stable/)","page":"Orbits & Ephemerides Overview","title":"AstroLib.jl (Image: )","text":"","category":"section"},{"location":"highlevels/orb-ephem/","page":"Orbits & Ephemerides Overview","title":"Orbits & Ephemerides Overview","text":"Collection of generic astronomical and astrophysical functions","category":"page"},{"location":"highlevels/orb-ephem/","page":"Orbits & Ephemerides Overview","title":"Orbits & Ephemerides Overview","text":"Translation of many IDL AstroLib procedures","category":"page"},{"location":"ecosystem/#eco","page":"Ecosystem","title":"Ecosystem","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"The joy of our community is the many astronomy and astrophysics packages available for wide use. Packages are separated by functionality and Julia's declarative package manager takes care of resolving dependencies. You get just the functionality you need, and smaller packages lead to more rapid development.","category":"page"},{"location":"ecosystem/#Data-I/O","page":"Ecosystem","title":"Data I/O","text":"","category":"section"},{"location":"ecosystem/#[AstroImages.jl](https://github.com/JuliaAstro/AstroImages.jl)-[![](assets/book.png)](https://juliaastro.github.io/AstroImages.jl/stable/)","page":"Ecosystem","title":"AstroImages.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Load, manipulate, and visualize astronomical images","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Works with the FileIO.jl interface","category":"page"},{"location":"ecosystem/#[FITSIO.jl](https://github.com/JuliaAstro/FITSIO.jl)-[![](assets/book.png)](https://juliaastro.github.io/FITSIO.jl/stable/)","page":"Ecosystem","title":"FITSIO.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Reading and writing FITS files","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Interact with header data units (HDUs), FITS headers, and FITS data: both images and tables\nFITS tables follow the Tables.jl interface, allowing seamless integration with the rich data ecosystem, like CSV.jl, DataFrames.jl, etc.","category":"page"},{"location":"ecosystem/#[CFITSIO.jl](https://github.com/JuliaAstro/CFITSIO.jl)-[![](assets/book.png)](https://juliaastro.github.io/FITSIO.jl/stable/)","page":"Ecosystem","title":"CFITSIO.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Reading and writing FITS files","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Low-level wrapper for cfitsio\nThe c interface can be directly accessed with the CFITSIO_jll package","category":"page"},{"location":"ecosystem/#[mweastwood/CasaCore.jl](https://github.com/mweastwood/CasaCore.jl)-[![](assets/book.png)](http://mweastwood.info/CasaCore.jl/stable/)","page":"Ecosystem","title":"mweastwood/CasaCore.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Tables and measurement sets for radio astronomy","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Wrapper for CasaCore\nInterface for CASA tables and measures","category":"page"},{"location":"ecosystem/#[emmt/OIFITS.jl](https://github.com/emmt/OIFITS.jl)","page":"Ecosystem","title":"emmt/OIFITS.jl","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Support for OI-FITS","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Read and write OI-FITS optical interferometry data format","category":"page"},{"location":"ecosystem/#[aplavin/VLBIData.jl](https://gitlab.com/aplavin/VLBIData.jl)-[![](assets/book.png)](https://aplavin.github.io/VLBIData.jl/test/examples.html)","page":"Ecosystem","title":"aplavin/VLBIData.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Work with data formats common in very long baseline interferometry (VLBI)","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Read interferometric visibilities (uvfits), images (fits), and source models\nMinimal writing support for source models","category":"page"},{"location":"ecosystem/#[aplavin/Difmap.jl](https://gitlab.com/aplavin/Difmap.jl)","page":"Ecosystem","title":"aplavin/Difmap.jl","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Wrapper for the Difmap program used in synthesis imaging","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Execute Difmap scripts, handle inputs/outputs and logs\nDisplay images and plots from Difmap in interactive Julia environments","category":"page"},{"location":"ecosystem/#Visualization-and-Plotting","page":"Ecosystem","title":"Visualization and Plotting","text":"","category":"section"},{"location":"ecosystem/#[AstroImages.jl](https://github.com/JuliaAstro/AstroImages.jl)-[![](assets/book.png)](https://juliaastro.github.io/AstroImages.jl/stable/)-2","page":"Ecosystem","title":"AstroImages.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Load, manipulate, and visualize astronomical images","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Works with the FileIO.jl interface\nAutomatic visualizations are directly integrated into many environments like VSCode, Pluto.jl, and IJulia.jl\nIncludes recipes for plotting with Plots.jl","category":"page"},{"location":"ecosystem/#[SAOImageDS9.jl](https://github.com/JuliaAstro/SAOImageDS9.jl)-[![](assets/book.png)](https://juliaastro.github.io/SAOImageDS9.jl/stable/)","page":"Ecosystem","title":"SAOImageDS9.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Interface with the DS9 image viewer","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Uses XPA.jl to communicate with DS9 instances\nEasily display images in DS9 and add features like circles and lines\nLow-level API accessible with set and get","category":"page"},{"location":"ecosystem/#Image-Processing","page":"Ecosystem","title":"Image Processing","text":"","category":"section"},{"location":"ecosystem/#[CCDReduction.jl](https://github.com/JuliaAstro/CCDReduction.jl)-[![](assets/book.png)](https://juliaastro.github.io/CCDReduction.jl/stable/)","page":"Ecosystem","title":"CCDReduction.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Common CCD image processing routines","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Creation of calibration files\nDark subtraction, flat normalization, bias subtraction, cropping\nSpecialized iterator for processing directories of FITS files using a table built from the FITS headers.","category":"page"},{"location":"ecosystem/#[LACosmic.jl](https://github.com/JuliaAstro/LACosmic.jl)-[![](assets/book.png)](https://juliaastro.github.io/LACosmic.jl/stable/)","page":"Ecosystem","title":"LACosmic.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Cosmic-ray rejection by Laplacian edge detection","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Implementation of the L.A.Cosmic algorithm (van Dokkum, 2001)\nReturns bad pixel masks and cleaned data","category":"page"},{"location":"ecosystem/#[Photometry.jl](https://github.com/JuliaAstro/Photometry.jl)-[![](assets/book.png)](https://juliaastro.github.io/Photometry.jl/stable/)","page":"Ecosystem","title":"Photometry.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Aperture photometry","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Background estimation and source extraction\nFast and precise aperture photometry","category":"page"},{"location":"ecosystem/#[PSFModels.jl](https://github.com/JuliaAstro/PSFModels.jl)-[![](assets/book.png)](https://juliaastro.github.io/PSFModels.jl/stable/)","page":"Ecosystem","title":"PSFModels.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Analytical, allocation-free point-spread-functions (PSF)","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Lazy representation allows fast allocation-free calculations\nGaussian (Normal), Moffat, and Airy disk.","category":"page"},{"location":"ecosystem/#[Reproject.jl](https://github.com/JuliaAstro/Reproject.jl)-[![](assets/book.png)](https://juliaastro.github.io/Reproject.jl/stable/)","page":"Ecosystem","title":"Reproject.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Astronomical image reprojection","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Uses FITSIO.jl and WCS.jl to reproject coordinate systems between FITS images","category":"page"},{"location":"ecosystem/#[JuliaHCI/HCIToolbox.jl](https://github.com/JuliaHCI/HCIToolbox.jl)-[![](assets/book.png)](http://JuliaHCI.github.io/HCIToolbox.jl/stable/)","page":"Ecosystem","title":"JuliaHCI/HCIToolbox.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Common utilities for high-contrast imaging (HCI) processing","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Morphological operations (rotation, stacking, shifting)\nMasking routines (circles, annulus, series of annuli)\nSpectral scaling and descaling","category":"page"},{"location":"ecosystem/#[JuliaHCI/SubpixelRegistration.jl](https://github.com/JuliaHCI/SubpixelRegistration.jl)-[![](assets/book.png)](http://JuliaHCI.github.io/SubpixelRegistration.jl/stable/)","page":"Ecosystem","title":"JuliaHCI/SubpixelRegistration.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Sub-pixel registration using discrete Fourier transforms","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Uses FFTs to register images, with arbitrary precision\nIncludes methods for Fourier based image-translation (phase-shifting)","category":"page"},{"location":"ecosystem/#[JuliaHCI/ADI.jl](https://github.com/JuliaHCI/ADI.jl)-[![](assets/book.png)](http://JuliaHCI.github.io/ADI.jl/stable/)","page":"Ecosystem","title":"JuliaHCI/ADI.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Angular Differential Imaging (ADI) routines in Julia","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"PCA, NMF, LLSG, LOCI, etc.\nApply algorithms framewise or in spectral differential imaging (SDI) using Julia's multiple dispatch\nProvide an interface for using these algorithms in other tools\nCommon HCI metrics including S/N maps, contrast curves, throughput curves (from PSF injection), STIM, etc.","category":"page"},{"location":"ecosystem/#Statistics","page":"Ecosystem","title":"Statistics","text":"","category":"section"},{"location":"ecosystem/#[mileslucas/BiweightStats.jl](https://github.com/mileslucas/BiweightStats.jl)-[![](assets/book.png)](http://mileslucas.com/BiweightStats.jl/stable/)","page":"Ecosystem","title":"mileslucas/BiweightStats.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Robust statistics based on the biweight transform","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Implements the location, scale, midvariance, midcovariance, and midcorrelation statistics","category":"page"},{"location":"ecosystem/#[JuliaHCI/ADI.jl](https://github.com/JuliaHCI/ADI.jl)-[![](assets/book.png)](http://JuliaHCI.github.io/ADI.jl/stable/)-2","page":"Ecosystem","title":"JuliaHCI/ADI.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Angular Differential Imaging (ADI) routines in Julia","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"PCA, NMF, LLSG, LOCI, etc.\nApply algorithms framewise or in spectral differential imaging (SDI) using Julia's multiple dispatch\nProvide an interface for using these algorithms in other tools\nCommon HCI metrics including S/N maps, contrast curves, throughput curves (from PSF injection), STIM, etc.","category":"page"},{"location":"ecosystem/#Time,-Coordinates,-Units","page":"Ecosystem","title":"Time, Coordinates, Units","text":"","category":"section"},{"location":"ecosystem/#[AstroAngles.jl](https://github.com/JuliaAstro/AstroAngles.jl)","page":"Ecosystem","title":"AstroAngles.jl","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"String parsing and representation of angles","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Parse and represent sexagesimal angles with a variety of delimiters\nMethods for converting to hour-minute-second angles from degrees and radians, and vice-versa","category":"page"},{"location":"ecosystem/#[AstroTime.jl](https://github.com/JuliaAstro/AstroTime.jl)-[![](assets/book.png)](https://juliaastro.github.io/AstroTime.jl/stable/)","page":"Ecosystem","title":"AstroTime.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Astronomical time keeping","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"High-precision, time-scale aware, DateTime-like data type\nSupport all commonly used astronomical time scales","category":"page"},{"location":"ecosystem/#[ERFA.jl](https://github.com/JuliaAstro/ERFA.jl)","page":"Ecosystem","title":"ERFA.jl","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Time systems conversions","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Low-level wrapper for liberfa","category":"page"},{"location":"ecosystem/#[SkyCoords.jl](https://github.com/JuliaAstro/SkyCoords.jl)","page":"Ecosystem","title":"SkyCoords.jl","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Astronomical coordinate systems","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Supports ICRS, galactic, and FK5 coordinate systems\nFast conversion of coordinates between different systems","category":"page"},{"location":"ecosystem/#[UnitfulAstro.jl](https://github.com/JuliaAstro/UnitfulAstro.jl)-[![](assets/book.png)](https://juliaastro.github.io/UnitfulAstro.jl/stable/)","page":"Ecosystem","title":"UnitfulAstro.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Astronomical units","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Extension of Unitful.jl","category":"page"},{"location":"ecosystem/#[WCS.jl](https://github.com/JuliaAstro/WCS.jl)-[![](assets/book.png)](https://juliaastro.github.io/WCS.jl/stable/)","page":"Ecosystem","title":"WCS.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"World Coordinate System transformations","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Wrapper for wcslib","category":"page"},{"location":"ecosystem/#Orbits-and-Ephemerides","page":"Ecosystem","title":"Orbits and Ephemerides","text":"","category":"section"},{"location":"ecosystem/#[Transits.jl](https://github.com/JuliaAstro/Transits.jl)-[![](assets/book.png)](https://juliaastro.github.io/Transits.jl/stable/)","page":"Ecosystem","title":"Transits.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Flexible photometric transit curves with limb darkening","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Inspired by exoplanet\nIncludes Keplerian orbits and generic orbits\nFully compatible with Unitful.jl","category":"page"},{"location":"ecosystem/#[sefffal/PlanetOrbits.jl](https://github.com/sefffal/PlanetOrbits.jl)-[![](assets/book.png)](https://sefffal.github.io/PlanetOrbits.jl/stable/)","page":"Ecosystem","title":"sefffal/PlanetOrbits.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Tools for displaying and solving Keplerian orbits in the context of direct imaging","category":"page"},{"location":"ecosystem/#[EarthOrientation.jl](https://github.com/JuliaAstro/EarthOrientation.jl)-[![](assets/book.png)](https://juliaastro.github.io/EarthOrientation.jl/stable/)","page":"Ecosystem","title":"EarthOrientation.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Earth orientation parameters","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Calculate Earth orientation parameters from IERS tables","category":"page"},{"location":"ecosystem/#[JPLEphemeris.jl](https://github.com/JuliaAstro/JPLEphemeris.jl)","page":"Ecosystem","title":"JPLEphemeris.jl","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"JPL Development Ephemerides","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Calculate positions and velocities of solar system bodies","category":"page"},{"location":"ecosystem/#[AstroLib.jl](https://github.com/JuliaAstro/astrolib.jl)-[![](assets/book.png)](https://juliaastro.github.io/AstroLib.jl/stable/)","page":"Ecosystem","title":"AstroLib.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Collection of generic astronomical and astrophysical functions","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Translation of many IDL AstroLib procedures","category":"page"},{"location":"ecosystem/#General","page":"Ecosystem","title":"General","text":"","category":"section"},{"location":"ecosystem/#[AstroLib.jl](https://github.com/JuliaAstro/astrolib.jl)-[![](assets/book.png)](https://juliaastro.github.io/AstroLib.jl/stable/)-2","page":"Ecosystem","title":"AstroLib.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Collection of generic astronomical and astrophysical functions","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Translation of many IDL AstroLib procedures","category":"page"},{"location":"ecosystem/#[BoxLeastSquares.jl](https://github.com/JuliaAstro/BoxLeastSquares.jl)-[![](assets/book.png)](https://juliaastro.github.io/BoxLeastSquares.jl/stable/)","page":"Ecosystem","title":"BoxLeastSquares.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Compute box-least-squares periodogram","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Fit BLS periodograms to time-series data\nExtract best-fitting transit parameters from the BLS periodogram\nFully compatible with Unitful.jl","category":"page"},{"location":"ecosystem/#[Cosmology.jl](https://github.com/JuliaAstro/Cosmology.jl)-[![](assets/book.png)](https://juliaastro.github.io/Cosmology.jl/stable/)","page":"Ecosystem","title":"Cosmology.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Distances in the universe","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Lambda-CDM and w_0-w_a cosmologies\nOpen, closed, and flat variants\nFully compatible with Unitful.jl","category":"page"},{"location":"ecosystem/#[DustExtinction.jl](https://github.com/JuliaAstro/DustExtinction.jl)-[![](assets/book.png)](https://juliaastro.github.io/DustExtinction.jl/stable/)","page":"Ecosystem","title":"DustExtinction.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Dust extinction laws and maps","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Various empirical extinction models\nSFD (1998) galactic dust map\nFully compatible with Unitful.jl","category":"page"},{"location":"ecosystem/#[LombScargle.jl](https://github.com/JuliaAstro/LombScargle.jl)-[![](assets/book.png)](https://juliaastro.github.io/LombScargle.jl/stable/)","page":"Ecosystem","title":"LombScargle.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Compute Lomb-Scargle periodogram","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Create periodograms from unevenly sampled periodic signals\nSupports multi-threading","category":"page"},{"location":"ecosystem/#[manuelbehrendt/Mera.jl](https://github.com/ManuelBehrendt/Mera.jl)-[![](assets/book.png)](https://manuelbehrendt.github.io/Mera.jl/stable/)","page":"Ecosystem","title":"manuelbehrendt/Mera.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Working with large hydrodynamical simulation data","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Loading, writing, analysing 3D AMR/uniform-grid and N-body data sets\nMemory lightweight data processing within a database framework\nMany predefined functions and examples","category":"page"},{"location":"ecosystem/#[Photometry.jl](https://github.com/JuliaAstro/Photometry.jl)-[![](assets/book.png)](https://juliaastro.github.io/Photometry.jl/stable/)-2","page":"Ecosystem","title":"Photometry.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Aperture photometry","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Background estimation and source extraction\nFast and precise aperture photometry","category":"page"},{"location":"ecosystem/#[Transits.jl](https://github.com/JuliaAstro/Transits.jl)-[![](assets/book.png)](https://juliaastro.github.io/Transits.jl/stable/)-2","page":"Ecosystem","title":"Transits.jl (Image: )","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Flexible photometric transit curves with limb darkening","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"Inspired by exoplanet\nIncludes Keplerian orbits and generic orbits\nFast polynomial limb-darkening laws based on Agol, Luger, Foreman-Mackey (2020)\nComposable limb-darkening extensions for integrated light curves and secondary light curves.\nFully compatible with Unitful.jl","category":"page"},{"location":"modules/FITSIO/#FITSIO.jl","page":"Introduction","title":"FITSIO.jl","text":"","category":"section"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"(Image: GitHub) (Image: Build Status) (Image: Coverage Status)","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"A Julia package for reading and writing Flexible Image Transport System (FITS) files, based on the cfitsio library.","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"The interface is inspired by Erin Sheldon's fitsio Python package.","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"warning: Warning\nThe Libcfitsio submodule has been moved to CFITSIO.jl and will be deprecated in a future release.","category":"page"},{"location":"modules/FITSIO/#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"FITSIO.jl can be installed using the built-in package manager","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"pkg> add FITSIO","category":"page"},{"location":"modules/FITSIO/#Usage","page":"Introduction","title":"Usage","text":"","category":"section"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"To open an existing file for reading:","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"julia> using FITSIO\n\njulia> f = FITS(\"file.fits\")\nFile: file.fits\nMode: \"w\" (read-write)\nHDUs: Num  Name  Type   \n      1          Image  \n      2          Table  ","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"(At the REPL, information about the file contents is shown.)","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"A FITS file consists of one or more header-data units (HDUs), concatenated one after the other. The FITS object therefore is represented as a collection of these HDUs.","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"Get information about the first HDU:","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"julia> f[1]\nFile: file.fits\nHDU: 1\nType: Image\nDatatype: Float64\nDatasize: (800, 800)","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"Iterate over HDUs in the file:","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"julia> for hdu in f; println(typeof(hdu)); end\nFITSIO.ImageHDU\nFITSIO.TableHDU","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"Each HDU can contain image data, or table data (either binary or ASCII-formatted). For image extensions, get the size of the image without reading it:","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"julia> ndims(f[1])\n    2\n\njulia> size(f[1])\n(800,800)\n\njulia> size(f[1], 2)\n800","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"Read an image from disk:","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"julia> data = read(f[1]);  # read an image from disk\n\njulia> data = read(f[1], :, 790:end);  # read just a subset of image","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"Show info about a binary table:","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"julia> f[2]\nFile: file.fits\nHDU: 2\nType: Table\nRows: 20\nColumns: Name  Size  Type    TFORM  \n         col2        String  5A     \n         col1        Int64   1K     ","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"Read a column from the table:","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":" julia> data = read(f[2], \"col1\")","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"Table HDUs implement the Tables.jl interface, so you can load them into other table types, like DataFrames.","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"julia> df = DataFrame(f[2])","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"Variable length columns are not supported by the Tables.jl interface, and Tables methods will ignore them.","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"Read the entire header into memory and get values from it:","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"julia> header = read_header(f[1]);  # read the entire header from disk\n\njulia> length(header)  # total number of records in header\n17\n\njulia> haskey(header, \"NAXIS1\")  # check if a key exists\ntrue\n\njulia> header[\"NAXIS1\"]  # get value by keyword\n800\n\njulia> header[4]  # get value by position\n800\n\njulia> get_comment(header, \"NAXIS\")  # get comment for a given keyword\n\"length of data axis 1\"","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"Read just a single header record without reading the entire header:","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"julia> read_key(f[1], 4)  # by position\n(\"NAXIS1\",800,\"length of data axis 1\")\n\njulia> read_key(f[1], \"NAXIS1\")  # read by keyword\n(800,\"length of data axis 1\")","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"Manipulate a header in memory:","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"julia> header[\"NEWKEY\"] = 10  # change or add a keyword\n\njulia> set_comment!(header, \"NEWKEY\", \"this is a comment\")","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"Close the file:","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"julia> close(f)","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"(FITS objects are also closed automatically when garbage collected.)","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"Open a new file for writing:","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"julia> f = FITS(\"newfile.fits\", \"w\");","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"The second argument can be \"r\" (read-only; default), \"r+\" (read-write) or \"w\" (write). In \"write\" mode, any existing file of the same name is overwritten.","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"Write an image to the file:","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"julia> data = reshape([1:100;], 5, 20)\n\njulia> write(f, data)  # Write a new image extension with the data\njulia> close(f)","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"To write some header keywords in the new extension, pass a FITSHeader instance as a keyword: write(f, data; header=header)","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"Overwrite image data in an existing file:","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"julia> f = FITS(\"newfile.fits\", \"r+\")  # Reopen the file in read-write mode\njulia> data = reshape([101:200;], 5, 20)  # Prepare new image data\njulia> image_hdu = f[1]\njulia> write(image_hdu, data)  # Overwrite the image","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"Write a table to the file:","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"julia> data = Dict(\"col1\"=>[1., 2., 3.], \"col2\"=>[1, 2, 3]);\n\njulia> write(f, data)  # write a new binary table to a new extension","category":"page"},{"location":"modules/FITSIO/","page":"Introduction","title":"Introduction","text":"tip: Compressed storage\nSetting the file extension to .gz will automatically use GZIP compression and save on storage space.julia> FITS(\"abc.fits\", \"w\") do f # save the image uncompressed\n           write(f, ones(200,200))\n       end\n\njulia> filesize(\"abc.fits\")\n325440\n\njulia> FITS(\"abc.fits.gz\", \"w\") do f # save the image compressed\n            write(f, ones(200,200))\n       end\n\njulia> filesize(\"abc.fits.gz\")\n2117Alternately the compression algorithm might be specified in square brackets after the filename. Check the CFITSIO website for the details of this usage.julia> FITS(\"abc.fits[compress R 100,100]\", \"w\") do f # Rice algorithm with a 100 x 100 pixel tile size\n           write(f, ones(200,200))\n       end\n\njulia> filesize(\"abc.fits\")\n8640warn: Warn\nCompression is \"loss-less\" for images with integer pixel values, and might be lossy for floating-point images. ","category":"page"},{"location":"modules/LACosmic/examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"modules/LACosmic/examples/#Setup","page":"Examples","title":"Setup","text":"","category":"section"},{"location":"modules/LACosmic/examples/","page":"Examples","title":"Examples","text":"You will need the following packages installed to replicate this tutorial","category":"page"},{"location":"modules/LACosmic/examples/","page":"Examples","title":"Examples","text":"julia> ]add Distributions LACosmic Plots PSFModels","category":"page"},{"location":"modules/LACosmic/examples/#Removing-bad-pixels-with-LACosmic.jl","page":"Examples","title":"Removing bad pixels with LACosmic.jl","text":"","category":"section"},{"location":"modules/LACosmic/examples/","page":"Examples","title":"Examples","text":"First, let's create some fake data with Gaussian sources","category":"page"},{"location":"modules/LACosmic/examples/","page":"Examples","title":"Examples","text":"using Distributions\nusing PSFModels: gaussian\nusing Random\n\nfunction make_data(rng, N; N_sources=20, N_cosmics=20)\n    imdata = fill(200.0, (N, N))\n\n    # Add some fake sources\n    for _ in 1:N_sources\n        x = rand(rng, Uniform(1, N + 1))\n        y = rand(rng, Uniform(1, N + 1))\n        brightness = rand(rng, Uniform(1000, 30000)) / (2π * 3.5^2)\n\t\tmodel = gaussian(;x, y, fwhm=3.5, amp=brightness)\n        imdata .+= model[axes(imdata)...]\n\tend\n\n    # Add the poisson noise\n    imdata .= rand.(rng, Poisson.(imdata))\n\n    # Add readnoise\n    imdata .+= rand(rng, Normal(0, 10), (N, N))\n\n    clean_image = copy(imdata)\n\t\n    # Add Nc fake cosmic rays\n    crmask = falses((N, N))\n\tfor i in 1:N_cosmics\n    \tcr_x = round(Int, rand(rng, Uniform(6, N - 5)))\n    \tcr_y = round(Int, rand(rng, Uniform(6, N - 5)))\n    \tcr_brightnesses = rand(rng, Uniform(1000, 30000))\n    \timdata[cr_y, cr_x] += cr_brightnesses\n    \tcrmask[cr_y, cr_x] = true\n\tend\n\n    # Make a mask where the detected cosmic rays should be\n    return (image=imdata, clean_image, mask=crmask)\nend\n\nrng = MersenneTwister(808)\ndata = make_data(rng, 201)","category":"page"},{"location":"modules/LACosmic/examples/","page":"Examples","title":"Examples","text":"let's inspect it","category":"page"},{"location":"modules/LACosmic/examples/","page":"Examples","title":"Examples","text":"using Plots\n\nfunction imshow(image; kwargs...)\n\taxy, axx = axes(image)\n\theatmap(axy, axx, image; \n        aspect_ratio=1,\n        ticks=false,\n        xlim=extrema(axx),\n        ylim=extrema(axy),\n        kwargs...)\nend\n\nplot(\n    imshow(log10.(data.clean_image), title=\"original image\"),\n    imshow(log10.(data.image), title=\"image w/cosmics\"),\n    size=(775, 350)\n)","category":"page"},{"location":"modules/LACosmic/examples/","page":"Examples","title":"Examples","text":"now we can clean it using lacosmic","category":"page"},{"location":"modules/LACosmic/examples/","page":"Examples","title":"Examples","text":"using LACosmic\n\nclean_image, mask = lacosmic(data.image, sigma_clip=6, contrast=5, neighbor_thresh=1)\n\nplot(\n    imshow(log10.(data.clean_image), title=\"original image\"),\n    imshow(log10.(clean_image), title=\"cleaned image\"),\n    size=(775, 350)\n)","category":"page"},{"location":"modules/LACosmic/examples/","page":"Examples","title":"Examples","text":"plot(\n    imshow(data.mask, title=\"true cosmics\", cbar=false),\n    imshow(mask, title=\"detected cosmics\", cbar=false),\n    size=(700, 400)\n)","category":"page"},{"location":"modules/LACosmic/examples/","page":"Examples","title":"Examples","text":"data.mask == mask","category":"page"},{"location":"modules/BoxLeastSquares/api/#API/Reference","page":"API/Reference","title":"API/Reference","text":"","category":"section"},{"location":"modules/BoxLeastSquares/api/","page":"API/Reference","title":"API/Reference","text":"","category":"page"},{"location":"modules/BoxLeastSquares/api/","page":"API/Reference","title":"API/Reference","text":"Modules = [BoxLeastSquares]","category":"page"},{"location":"modules/BoxLeastSquares/api/#BoxLeastSquares.BLSPeriodogram","page":"API/Reference","title":"BoxLeastSquares.BLSPeriodogram","text":"BLSPeriodogram\n\nA convenient wrapper for outputs from BLS.\n\nMethods\n\nBoxLeastSquares.params\nBoxLeastSquares.power\nBoxLeastSquares.periods\n\nAttributes\n\nt - input time grid\ny - input data\nyerr - input data uncertainty\nperiods - the input periods\nduration_in - the input durations\nobjective - the objective that was maximized\npower - the power calculated at each period\nduration - the best duration at each period\nt0 - the best transit time at each period\ndepth - the best transit depth at each period\nsnr - the signal-to-noise ratio at each period\nloglike - the log-likeilhood at each period\n\nPlotting\n\nPlotting recipes are provided for BLSPeriodogram which automatically plots the period and the power\n\n\n\n\n\n","category":"type"},{"location":"modules/BoxLeastSquares/api/#BoxLeastSquares.BLS","page":"API/Reference","title":"BoxLeastSquares.BLS","text":"BLS(t, y, [yerr];\n    duration, periods=autoperiod(t, duration, kwargs...), \n    objective=:likelihood, oversample=10, kwargs...)\n\nCompute the box-least-squares periodogram.\n\nParameters\n\nt - the time for each observation. Units are irrelevant, except that they must be consistent for all temporal parameters (e.g., duration). Unitful.jl units work seamlessly without needing to convert.\ny - the flux value for each observation\nyerr, optional - the uncertainty for each observation, if not provided, will default to ones\nduration - The duration or durations to consider. Same units as t\nperiods, optional - The period grid to computer the BLS power over. If not provided, autoperiod will be called along with any extra keyword arguments (like minimum_period)\nobjective, optional - Choose between maximizing the likeilhood (:likeilhood, default) or the signal-to-noise ratio (:snr).\noversample, optional - The number of bins per duration that should be used. Larger values of oversample will lead to a finer grid.\n\nThe returned values are wrapped into a convenience type BoxLeastSquares.BLSPeriodogram\n\n\n\n\n\n","category":"function"},{"location":"modules/BoxLeastSquares/api/#BoxLeastSquares.autoperiod-Union{Tuple{T}, Tuple{AbstractVector{T}, Any}} where T","page":"API/Reference","title":"BoxLeastSquares.autoperiod","text":"autoperiod(t, duration;\n    minimum_n_transit=3, frequency_factor=1.0,\n    [minimum_period, maximum_period])\n\nAutomatically determine a period grid from the given times and duration(s). Periods are selected such that at least minimum_n_trasnit transits occur. The default minimum period is twice the maximum duration. The default maximum period is (maximum(t) - minimum(t)) / (minimum_n_transit - 1). The frequency factor changes the granularity in frequency space- a smaller frequency factor will create a finer period grid.\n\n\n\n\n\n","category":"method"},{"location":"modules/BoxLeastSquares/api/#BoxLeastSquares.model","page":"API/Reference","title":"BoxLeastSquares.model","text":"BoxLeastSquares.model(t, y, [yerr]; period, duration, t0)\n\nEvaluate the transit model on the given time grid. If yerr is not provided, it will default to 1. The following transit parameters must be set:\n\nperiod orbital period in the same units as t\nduration the transit duration in the same units as t\nt0 the transit time (middle of transit) in the same units as t\n\nIf you are using Unitful.jl, the unit conversions will be made automatically.\n\n\n\n\n\n","category":"function"},{"location":"modules/BoxLeastSquares/api/#BoxLeastSquares.model-Tuple{BoxLeastSquares.BLSPeriodogram}","page":"API/Reference","title":"BoxLeastSquares.model","text":"BoxLeastSquares.model(::BLSPeriodogram; kwargs...)\n\nCreate a transit model using the data and best-fitting parameters from the given BLS periodogram. Any keyword parameters can be overriden.\n\n\n\n\n\n","category":"method"},{"location":"modules/BoxLeastSquares/api/#BoxLeastSquares.params-Tuple{BoxLeastSquares.BLSPeriodogram}","page":"API/Reference","title":"BoxLeastSquares.params","text":"BoxLeastSquares.params(::BLSPeriodogram)\n\nReturn the transit parameters for the best fitting period. Returns period, duration, t0, and power as well as the index of the max-power period.\n\n\n\n\n\n","category":"method"},{"location":"modules/BoxLeastSquares/api/#BoxLeastSquares.periods-Tuple{BoxLeastSquares.BLSPeriodogram}","page":"API/Reference","title":"BoxLeastSquares.periods","text":"BoxLeastSquares.periods(::BLSPeriodogram)\n\nReturn the period grid for the periodogram\n\n\n\n\n\n","category":"method"},{"location":"modules/BoxLeastSquares/api/#BoxLeastSquares.power-Tuple{BoxLeastSquares.BLSPeriodogram}","page":"API/Reference","title":"BoxLeastSquares.power","text":"BoxLeastSquares.power(::BLSPeriodogram)\n\nReturn the power calculated for each period for the periodogram\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroImages/manual/loading-images/#Loading-Images","page":"Loading & Saving Images","title":"Loading Images","text":"","category":"section"},{"location":"modules/AstroImages/manual/loading-images/","page":"Loading & Saving Images","title":"Loading & Saving Images","text":"FITS (Flexible Image Transport System) files can be loaded and saved using AstroImages thanks to the FITSIO package.","category":"page"},{"location":"modules/AstroImages/manual/loading-images/","page":"Loading & Saving Images","title":"Loading & Saving Images","text":"AstroImages is registered with FileIO, so if you have FileIO and AstroImages installed you can get started with the load function. When you pass a file name with the appropriate file extension (\".fits\", \".fit\", etc.) FileIO will import AstroImages automatically.","category":"page"},{"location":"modules/AstroImages/manual/loading-images/","page":"Loading & Saving Images","title":"Loading & Saving Images","text":"Alternatively, you can use the AstroImage contructor instead of load. This will work on fits files with any file extension, including compressed files (e.g. \".fits.gz\").","category":"page"},{"location":"modules/AstroImages/manual/loading-images/","page":"Loading & Saving Images","title":"Loading & Saving Images","text":"julia> img = load(\"myfitsimg.fits\")\n1600×1600 AstroImage{Float32,2} with dimensions:\n  X Sampled Base.OneTo(1600) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(1600) ForwardOrdered Regular Points\n 0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n ⋮                        ⋱\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0","category":"page"},{"location":"modules/AstroImages/manual/loading-images/","page":"Loading & Saving Images","title":"Loading & Saving Images","text":"Note: if you are in an interactive environment like VSCode, Jupyter, or Pluto, instead of a REPL, AstroImages are automatically rendered to images and displayed. You can see this plain text output by explicitly calling: show(stdout, MIME(\"text/plain\"), img).","category":"page"},{"location":"modules/AstroImages/manual/loading-images/","page":"Loading & Saving Images","title":"Loading & Saving Images","text":"Or:","category":"page"},{"location":"modules/AstroImages/manual/loading-images/","page":"Loading & Saving Images","title":"Loading & Saving Images","text":" julia> img = AstroImage(\"myfitsimg.fits.gz\")\n1600×1600 AstroImage{Float32,2} with dimensions:\n  X Sampled Base.OneTo(1600) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(1600) ForwardOrdered Regular Points\n 0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n ⋮                        ⋱\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0","category":"page"},{"location":"modules/AstroImages/manual/loading-images/","page":"Loading & Saving Images","title":"Loading & Saving Images","text":"A FITS file can contain multiple N-dimensional images and tables. When you call load or AstroImage with a file name and no other arguments, the package will search through the file and return the first image HDU. That is, it will skip any FITS tables or empty HDUs with only headers.","category":"page"},{"location":"modules/AstroImages/manual/loading-images/","page":"Loading & Saving Images","title":"Loading & Saving Images","text":"You can also specify an HDU number explicitly:","category":"page"},{"location":"modules/AstroImages/manual/loading-images/","page":"Loading & Saving Images","title":"Loading & Saving Images","text":"julia> img = load(\"myfitsimg.fits\",1)\n1600×1600 AstroImage{Float32,2} with dimensions:\n  X Sampled Base.OneTo(1600) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(1600) ForwardOrdered Regular Points\n...","category":"page"},{"location":"modules/AstroImages/manual/loading-images/","page":"Loading & Saving Images","title":"Loading & Saving Images","text":"This way, you can load specific images from multi-extension files.","category":"page"},{"location":"modules/AstroImages/manual/loading-images/","page":"Loading & Saving Images","title":"Loading & Saving Images","text":"You can load all HDUs simultaneously by passing ::","category":"page"},{"location":"modules/AstroImages/manual/loading-images/","page":"Loading & Saving Images","title":"Loading & Saving Images","text":"julia> hdus = load(\"multiext.fits\", :);\njulia> hdus[2] # Second HDU as an AstroImage\n10×10 AstroImage{Float64,2} with dimensions:\n  X Sampled Base.OneTo(10) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(10) ForwardOrdered Regular Points\n -0.777315  -1.36683   -0.580179     1.39629      …  -2.14298     0.450059   0.432065\n -1.09619    0.789249   0.938415     0.959903        -0.88995    -1.29406   -0.4291\n  0.47427   -1.41855    0.814823    -1.15975          0.0427149  -1.20116   -0.0920709\n -0.179858  -1.60228    1.09648     -0.497927        -1.31824    -0.156529  -0.0223846\n  2.64162    0.131437   0.320476     0.331197        -0.914713   -1.55162   -0.18862\n  0.209669  -1.17923   -0.656512     0.000775311  …   0.377461   -0.24278    0.967202\n  1.01442   -0.762895  -2.13238     -0.456932        -0.415733   -1.21416   -1.6108\n  0.385626   0.389335  -0.00726015   0.309936        -0.533175    0.157878   0.100876\n -1.24799    0.461216  -0.868826    -0.255654        -0.37151     0.49479   -1.87129\n  1.39356    2.29254    0.0548325    1.50674         -0.0880865   0.580978  -1.81629\njulia> # Or:\njulia> hdu1, hdu2, hdu3 = load(\"multiext.fits\", :);","category":"page"},{"location":"modules/AstroImages/manual/loading-images/","page":"Loading & Saving Images","title":"Loading & Saving Images","text":"There is also limited support for table HDUs. In this case, a bare-bones Tables.jl compatible  object is returned.","category":"page"},{"location":"modules/AstroImages/manual/loading-images/#Dimension-Names","page":"Loading & Saving Images","title":"Dimension Names","text":"","category":"section"},{"location":"modules/AstroImages/manual/loading-images/","page":"Loading & Saving Images","title":"Loading & Saving Images","text":"You may have noticed the entries above the image array:","category":"page"},{"location":"modules/AstroImages/manual/loading-images/","page":"Loading & Saving Images","title":"Loading & Saving Images","text":"10×10 AstroImage{Float64,2} with dimensions:\n  X Sampled Base.OneTo(10) ForwardOrdered Regular Points,\n  Y Sampled Base.OneTo(10) ForwardOrdered Regular Points","category":"page"},{"location":"modules/AstroImages/manual/loading-images/","page":"Loading & Saving Images","title":"Loading & Saving Images","text":"AstroImages are based on Dimensional Data. Each axis is assigned a dimension name and the indices are tracked. The automatic dimension names are X, Y, Z, Dim{4}, Dim{5}, and so on; however you can pass in other names or orders to the load function and/or AstroImage contructor:","category":"page"},{"location":"modules/AstroImages/manual/loading-images/","page":"Loading & Saving Images","title":"Loading & Saving Images","text":"julia> img = load(\"img.fits\",1,(Y=1:1600,Z=1:1600))\n1600×1600 AstroImage{Float32,2} with dimensions:\n  Y Sampled 1:1600 ForwardOrdered Regular Points,\n  Z Sampled 1:1600 ForwardOrdered Regular Points","category":"page"},{"location":"modules/AstroImages/manual/loading-images/","page":"Loading & Saving Images","title":"Loading & Saving Images","text":"Other useful dimension names are Spec for spectral axes, Pol for polarization data, and Ti for time axes.","category":"page"},{"location":"modules/AstroImages/manual/loading-images/","page":"Loading & Saving Images","title":"Loading & Saving Images","text":"These will be further discussed in Dimensions and World Coordinates.","category":"page"},{"location":"modules/AstroImages/manual/loading-images/#Saving-Images","page":"Loading & Saving Images","title":"Saving Images","text":"","category":"section"},{"location":"modules/AstroImages/manual/loading-images/","page":"Loading & Saving Images","title":"Loading & Saving Images","text":"You can save one or more AstroImages and tables to a FITS file using the save function:","category":"page"},{"location":"modules/AstroImages/manual/loading-images/","page":"Loading & Saving Images","title":"Loading & Saving Images","text":"julia> save(\"abc.fits\", astroimage1, astroimage2, table1)","category":"page"},{"location":"modules/AstroImages/manual/loading-images/","page":"Loading & Saving Images","title":"Loading & Saving Images","text":"You can also save individual images to traditional graphics formats by first rendering them with imview (for more on imview, see Displaying Images).","category":"page"},{"location":"modules/AstroImages/manual/loading-images/","page":"Loading & Saving Images","title":"Loading & Saving Images","text":"julia> save(\"abc.png\", imview(astroimage1))","category":"page"},{"location":"modules/AstroImages/manual/loading-images/","page":"Loading & Saving Images","title":"Loading & Saving Images","text":"You can save animated GIFs by saving a 3D datacube that has been rendered with imview:","category":"page"},{"location":"modules/AstroImages/manual/loading-images/","page":"Loading & Saving Images","title":"Loading & Saving Images","text":"julia> cube =  imview(AstroImage(randn(100,100,10)));\njulia> save(\"abc.gif\", cube, fps=10)\n\njulia> # Or a more complex example (changing color schemes each frame)\njulia> img = randn(10,10)\njulia> cube2 = [imview(img1, cmap=:magma) ;;; imview(img2, cmap=:plasma) ;;; imview(img3, cmap=:viridis)]\njulia> # Alternative syntax:\njulia> cube2 = cat(imview(img1, cmap=:magma), imview(img2, cmap=:plasma), imview(img3, cmap=:viridis), dims=3)\njulia> save(\"abc.gif\", cube, fps=10)","category":"page"},{"location":"modules/VLBIData/","page":"VLBIData","title":"VLBIData","text":"VLBIData.jl reads a range of data formats typically used in very long baseline interferometry (VLBI).","category":"page"},{"location":"modules/VLBIData/","page":"VLBIData","title":"VLBIData","text":"See the notebook for docs and usage examples.","category":"page"},{"location":"modules/AstroTime/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"This tutorial will walk you through the features and functionality of AstroTime.jl. Everything in this package revolves around the Epoch data type. Epochs are a high-precision, time-scale aware version of the DateTime type from Julia's standard library. This means that while DateTime timestamps are always assumed to be based on Universal Time (UT), Epochs can be created in several pre-defined time scales or custom user-defined time scales.","category":"page"},{"location":"modules/AstroTime/tutorial/#Creating-Epochs","page":"Tutorial","title":"Creating Epochs","text":"","category":"section"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"You construct Epoch instances similar to DateTime instances, for example by using date and time components. The main difference is that you need to supply the time scale to be used. Out of the box, the following time scales are defined:","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"TAI: International Atomic Time\nUT1: Universal Time[1]\nTT: Terrestrial Time\nTCG: Geocentric Coordinate Time\nTCB: Barycentric Coordinate Time\nTDB: Barycentric Dynamical Time","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"Conspicuously missing from this list is Coordinated Universal Time (UTC). While AstroTime.jl does support UTC, it requires special treatment due to the discontinuities in the time scale from the introduction of leap seconds. See UTC and Leap Seconds for more details.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"[1]: Transformations to and from UT1 depend on the measured quantity ΔUT1 which is published in IERS tables on a weekly basis. AstroTime.jl can automatically fetch these tables by running AstroTime.update(). If you work with UT1, you need to run this function periodically.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"using AstroTime\n\nep = Epoch{InternationalAtomicTime}(2018, 2, 6, 20, 45, 0.0)\n\n# The following shorthand syntax also works\nep = TAIEpoch(2018, 2, 6, 20, 45, 0.0)\n\n# Or in another time scale\nep = TTEpoch(2018, 2, 6, 20, 45, 0.0)\n\n# Or use UTC with leap second handling\nep = from_utc(2018, 2, 6, 20, 45, 0.0)","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"You can also parse an Epoch from a string. AstroTime.jl uses the DateFormat type and specification language from the Dates module from Julia's standard library. For example:","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"ep = TAIEpoch(\"2018-02-06T20:45:00.000\", \"yyyy-mm-ddTHH:MM:SS.fff\")\n\n# The format string above `yyyy-mm-ddTHH:MM:SS.fff` is also the default format.\n# Thus, this also works...\nep = TAIEpoch(\"2018-02-06T20:45:00.000\")\n\nimport Dates\n\n# You can also reuse the format string\ndf = Dates.dateformat\"dd.mm.yyyy HH:MM\"\n\nutc = from_utc(\"06.02.2018 20:45\", df)\ntai = TAIEpoch(\"06.02.2018 20:45\", df)","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"There are three additional character codes supported.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"f: This character code is parsed as the fraction of the current second and supports an arbitrary number of decimal places.\nt: This character code is parsed as the time scale.\nD: This character code is parsed as the day number within a year.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"# The time scale can be omitted from the constructor because it is already\n# defined in the input string\njulia> Epoch(\"2018-02-06T20:45:00.000 TAI\", \"yyyy-mm-ddTHH:MM:SS.fff ttt\")\n2018-02-06T20:45:00.000 TAI\n\n# February 6 is the 37th day of the year\njulia> TAIEpoch(\"2018-037T20:45:00.000\", \"yyyy-DDDTHH:MM:SS.fff\")\n2018-02-06T20:45:00.000 TAI","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"When printing Epochs, you can format the output in the same way.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> ep = TAIEpoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TAI\njulia> AstroTime.format(ep, \"dd.mm.yyyy HH:MM ttt\")\n06.02.2018 20:45 TAI","category":"page"},{"location":"modules/AstroTime/tutorial/#Working-with-Epochs-and-Periods","page":"Tutorial","title":"Working with Epochs and Periods","text":"","category":"section"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"You can shift an Epoch in time by adding or subtracting an AstroPeriod to it.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"AstroTime.jl provides a convenient way to construct periods by multiplying a value with a time unit.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> 23 * seconds\n23 seconds\n\njulia> 1hours # You can use Julia's factor juxtaposition syntax and omit the `*`\n1 hour","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"The following time units are available:","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"seconds\nminutes\nhours\ndays\nyears\ncenturies","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"To shift an Epoch forward in time add an AstroPeriod to it.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> ep = TAIEpoch(2000, 1, 1)\n2000-01-01T00:00:00.000 TAI\n\njulia> ep + 1days\n2000-01-02T00:00:00.000 TAI","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"Or subtract it to shift the Epoch backwards.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> ep = TAIEpoch(2000, 1, 1)\n2000-01-01T00:00:00.000 TAI\n\njulia> ep - 1days\n1999-12-31T00:00:00.000 TAI","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"If you subtract two epochs you will receive the time between them as an AstroPeriod.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> ep1 = TAIEpoch(2000, 1, 1)\n2000-01-01T00:00:00.000 TAI\n\njulia> ep2 = TAIEpoch(2000, 1, 2)\n2000-01-02T00:00:00.000 TAI\n\njulia> ep2 - ep1\n86400.0 seconds","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"You can also construct an AstroPeriod with a different time unit from another AstroPeriod.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> dt = 86400.0seconds\n86400.0 seconds\n\njulia> days(dt)\n1.0 days","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"To access the raw value of a period, i.e. without a unit, use the value function.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> dt = 86400.0seconds\n86400.0 seconds\n\njulia> value(days(dt))\n1.0","category":"page"},{"location":"modules/AstroTime/tutorial/#Ranges","page":"Tutorial","title":"Ranges","text":"","category":"section"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"You can also construct ranges of Epochs. The default step size one second.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> TAIEpoch(2021, 7, 30, 17, 34, 30.0):TAIEpoch(2021, 7, 30, 17, 34, 31.0)\n2021-07-30T17:34:30.000 TAI:1.0 seconds:2021-07-30T17:34:31.000 TAI","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"Or you can adjust the step size with any of the units supported.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> collect(TAIEpoch(2000, 1, 1):1days:TAIEpoch(2000, 1, 5))\n5-element Vector{TAIEpoch{Float64}}:\n 2000-01-01T00:00:00.000 TAI\n 2000-01-02T00:00:00.000 TAI\n 2000-01-03T00:00:00.000 TAI\n 2000-01-04T00:00:00.000 TAI\n 2000-01-05T00:00:00.000 TAI","category":"page"},{"location":"modules/AstroTime/tutorial/#Converting-Between-Time-Scales","page":"Tutorial","title":"Converting Between Time Scales","text":"","category":"section"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"You convert an Epoch to another time scale by constructing a new Epoch with the target time scale from it.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> tai = TAIEpoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TAI\n\njulia> tt = TTEpoch(tai) # Convert to TT\n2018-02-06T20:45:32.184 TT","category":"page"},{"location":"modules/AstroTime/tutorial/#UTC-and-Leap-Seconds","page":"Tutorial","title":"UTC and Leap Seconds","text":"","category":"section"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"UTC is the primary civil time standard and aims to provide a time scale based on TAI and uniform SI seconds that is at the same time aligned with UT1 which is based on solar time and governed by the rotation of the Earth. The problem is that Earth's rotation speed is much more irregular compared to atomic clocks which define the SI second. Over the past decades, Earth's rotation has continuously slowed and thus TAI has been running ahead of UT1.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"Leap seconds are inserted into the UTC time scale to keep it within 0.9 seconds of UT1. This introduces ambiguities in AstroTime.jl's data model (see #50). As a consequence, UTCEpochs are not supported. Nevertheless, UTC is supported as an I/O format for timestamps through the from_utc and to_utc functions.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"The last leap second was introduced at the end of December 31, 2016. You can create a TAIEpoch (or other Epochs) from a UTC date with proper leap second handling:","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> from_utc(2016, 12, 31, 23, 59, 60.0)\n2017-01-01T00:00:36.000 TAI\n\njulia> from_utc(\"2016-12-31T23:59:60.0\")\n2017-01-01T00:00:36.000 TAI\n\njulia> from_utc(\"2016-12-31T23:59:60.0\", scale=TDB)\n2017-01-01T00:01:08.183 TDB","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"You can also use Dates.DateTime but note that you cannot represent a leap second date with it.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> tai = from_utc(Dates.DateTime(2018, 2, 6, 20, 45, 0, 0))\n2018-02-06T20:45:37.000 TAI","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"And go back to UTC:","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> to_utc(tai)\n\"2018-02-06T20:45:00.000\"\n\njulia> to_utc(String, tai, Dates.dateformat\"yyyy-mm-dd\")\n\"2018-02-06\"\n\njulia> to_utc(Dates.DateTime, tai)\n2018-02-06T20:45:00","category":"page"},{"location":"modules/AstroTime/tutorial/#High-Precision-Conversions-and-Custom-Offsets","page":"Tutorial","title":"High-Precision Conversions and Custom Offsets","text":"","category":"section"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"Some time scale transformations depend on measured quantities which cannot be accurately predicted (e.g. UT1) or there are different algorithms which offer variable levels of accuracy. For the former, AstroTime.jl can download the required data automatically from the internet. You need to run AstroTime.update() periodically (weekly) to keep this data up-to-date. For the latter, AstroTime.jl will use the alogrithm which provides the best trade-off between accuracy and performance for most applications.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"If you cannot use the internet or want to use a different data source, e.g. a time ephemeris, to obtain the offset between time scales, you can use the following constructor for epochs which overrides the default algorithms.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"# AstroTime.jl provides a higher precision TDB<->TT transformation that is dependent on\n# the position of the observer on Earth\n\ntt = TTEpoch(2018, 2, 6, 20, 46, 9.184)\ndt = getoffset(tt, TDB, elong, u, v)\n\n# Use the custom offset for the transformation\ntdb = TDBEpoch(dt, tt)","category":"page"},{"location":"modules/AstroTime/tutorial/#Working-with-Julian-Dates","page":"Tutorial","title":"Working with Julian Dates","text":"","category":"section"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"Epochs can be converted to and from Julian Dates. Three different base epochs are supported:","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"The (default) J2000 date which starts at January 1, 2000, at 12h,\nthe standard Julian date which starts at January 1, 4712BC, at 12h,\nand the Modified Julian date which starts at November 17, 1858, at midnight.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"You can get Julian date in days from an Epoch like this:","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> ep = TTEpoch(2000,1,2)\n2000-01-02T00:00:00.000 TT\n\njulia> j2000(ep)\n0.5 days\n\njulia> julian(ep)\n2.4515455e6 days\n\njulia> modified_julian(ep)\n51545.0 days","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"To construct an Epoch from a Julian date do this:","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> TTEpoch(0.5days) # J2000 is the default\n2000-01-02T00:00:00.000 TT\n\njulia> TTEpoch(0.5days, origin=:j2000)\n2000-01-02T00:00:00.000 TT\n\njulia> TTEpoch(2.4515455e6days, origin=:julian)\n2000-01-02T00:00:00.000 TT\n\njulia> TTEpoch(51545.0days, origin=:modified_julian)\n2000-01-02T00:00:00.000 TT\n\njulia> TTEpoch(86400.0seconds, origin=:j2000)\n2000-01-02T12:00:00.000 TT","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"Some libraries (such as ERFA) expect a two-part Julian date as input. You can use julian_twopart(ep) in this case. If you need more control over the output, have a look at the julian_period function.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"warning: Warning\nYou should not convert an Epoch to a Julian date to do arithmetic because this will result in a loss of accuracy.","category":"page"},{"location":"modules/AstroTime/tutorial/#Converting-to-Standard-Library-Types","page":"Tutorial","title":"Converting to Standard Library Types","text":"","category":"section"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"Epoch instances satisfy the AbstractDateTime interface specified in the Dates module of Julia's standard library.  Thus, you should be able to pass them to other libraries which expect a standard DateTime. Please open an issue on the issue tracker if you encounter any problems with this.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"It is nevertheless possible to convert an Epoch to a DateTime if it should become necessary. Please note that the time scale information will be lost in the process.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> ep = TTEpoch(2000,1,1)\n2000-01-01T00:00:00.000 TT\n\njulia> import Dates; Dates.DateTime(ep)\n2000-01-01T00:00:00","category":"page"},{"location":"modules/AstroTime/tutorial/#Defining-Custom-Time-Scales","page":"Tutorial","title":"Defining Custom Time Scales","text":"","category":"section"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"AstroTime.jl enables you to create your own first-class time scales via the @timescale macro. The macro will define the necessary structs and register the new time scale.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's start with a simple example and assume that you want to define EphemerisTime as an alias for TDB. You need to provide the name of the time scale and optionally a \"parent\" time scale to which it is linked.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"@timescale EphemerisTime TDB","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"At this point, you can already use the new time scale to create epochs.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> EphemerisTime\nEphemerisTime\n\njulia> typeof(EphemerisTime)\nEphemerisTimeScale\n\njulia> et = EphemerisTimeEpoch(2000, 1, 1)\n2000-01-01T00:00:00.000 EphemerisTime","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"Conversion to other Epoch types will not yet work for the newly created time because you need to provide the necessary methods for getoffset. If you are unsure which methods are needed, you can try to transform the epoch and the resulting error message will provide a hint.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> TDBEpoch(et)\nERROR: No conversion 'EphemerisTime->TDB' available. If one of these is a custom time scale,\nyou may need to define `AstroTime.Epochs.getoffset(::EphemerisTimeScale, ::BarycentricDynamicalTime, second, fraction, args...)`.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"To enable transformations between EphemerisTime and TDB in both directions you need to define the following methods. Since EphemerisTime and TDB are identical, the offset between them is zero.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"AstroTime.Epochs.getoffset(::EphemerisTimeType, ::CoordinatedUniversalTime, second, fraction) = 0.0\nAstroTime.Epochs.getoffset(::CoordinatedUniversalTime, ::EphemerisTimeType, second, fraction) = 0.0","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"You can now use EphemerisTimeEpoch like any other epoch type, e.g.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> ep = TDBEpoch(2000, 1, 1)\n2000-01-01T00:00:00.000 TDB\n\njulia> EphemerisTimeEpoch(ep)\n2000-01-01T00:00:00.000 EphemerisTime","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"For a more complex example, let's reimplement the Geocentric Coordinate Time (TCG) scale. It is a linear transformation from Terrestrial Time (TT), i.e. the transformation is dependent on the point in time in the current time scale (the second and fraction arguments to getoffset).","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"@timescale CustomTCG TT\n\n# The reference point\nconst JD77_SEC = -7.25803167816e8\n# The linear rate of change\nconst LG_RATE = 6.969290134e-10\n\nfunction getoffset(::CustomTCGScale, ::TerrestrialTime, second, fraction)\n    # `second` is the number of full seconds since 2000-01-01\n    # `fraction` is the fraction of the current second\n    dt = second - JD77_SEC + fraction\n    return -LG_RATE * dt\nend\n\nfunction getoffset(::TerrestrialTime, ::CustomTCGScale, second, fraction)\n    # The inverse rate for the backwards transformation\n    rate = LG_RATE / (1.0 - LG_RATE)\n    dt = second - JD77_SEC + fraction\n    return rate * dt\nend\n","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's assume that you want to define a time scale that determines the Spacecraft Event Time which takes the one-way light time into account.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"You could use the following definitions adding the distance parameter which is the distance of the spacecraft from Earth.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"const speed_of_light = 299792458.0 # m/s\n\n@timescale SCET TAI\n\nfunction AstroTime.Epochs.getoffset(::SCETScale, ::InternationalAtomicTime,\n                                    second, fraction, distance)\n    return distance / speed_of_light\nend\nfunction AstroTime.Epochs.getoffset(::InternationalAtomicTime, ::SCETScale,\n                                    second, fraction, distance)\n    return -distance / speed_of_light\nend","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"If you want to convert another epoch to SCET, you now need to pass this additional parameter. For example, for a spacecraft that is one astronomical unit away from Earth:","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> astronomical_unit = 149597870700.0 # m\n149597870700.0\n\njulia> ep = TAIEpoch(2000, 1, 1)\n2000-01-01T00:00:00.000 TAI\n\njulia> SCETEpoch(ep, astronomical_unit)\n1999-12-31T23:51:40.995 SCET","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Note\nAt this time, custom epochs with additional parameters cannot be parsed from strings.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"You can also introduce time scales that are disjoint from AstroTime.jl's default graph of time scales by defining a time scale without a parent.","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> @timescale Disjoint\n\njulia> typeof(Disjoint)\nDisjointScale","category":"page"},{"location":"modules/AstroTime/tutorial/","page":"Tutorial","title":"Tutorial","text":"By defining additional time scales connected to this scale and the appropriate getoffset methods, you can create your own graph of time scales that is completely independent of the defaults provided by the library.","category":"page"},{"location":"modules/CasaCore/#CasaCore.jl","page":"CasaCore","title":"CasaCore.jl","text":"","category":"section"},{"location":"modules/CasaCore/","page":"CasaCore","title":"CasaCore","text":"<img src=\"docs/src/assets/logo.png\" alt=\"CasaCore.jl\" width=\"200\">","category":"page"},{"location":"modules/CasaCore/","page":"CasaCore","title":"CasaCore","text":"(Image: Build Status) (Image: codecov) (Image: DOI)","category":"page"},{"location":"modules/CasaCore/","page":"CasaCore","title":"CasaCore","text":"CasaCore.jl is a Julia wrapper of CasaCore, which is a commonly used library in radio astronomy.","category":"page"},{"location":"modules/CasaCore/","page":"CasaCore","title":"CasaCore","text":"Functionality is divided into two submodules:","category":"page"},{"location":"modules/CasaCore/","page":"CasaCore","title":"CasaCore","text":"CasaCore.Tables for interfacing with tables (for example Casa measurement sets), and\nCasaCore.Measures for performing coordinate system conversions (for example calculating the azimuth and elevation of an astronomical target).","category":"page"},{"location":"modules/CasaCore/","page":"CasaCore","title":"CasaCore","text":"Documentation: http://mweastwood.info/CasaCore.jl/stable/","category":"page"},{"location":"modules/CasaCore/","page":"CasaCore","title":"CasaCore","text":"Author: Michael Eastwood","category":"page"},{"location":"modules/CasaCore/","page":"CasaCore","title":"CasaCore","text":"License: GPLv3+","category":"page"},{"location":"modules/SkyCoords/api/#API/Reference","page":"API/Reference","title":"API/Reference","text":"","category":"section"},{"location":"modules/SkyCoords/api/","page":"API/Reference","title":"API/Reference","text":"DocTestSetup = :(using SkyCoords)","category":"page"},{"location":"modules/SkyCoords/api/#Index","page":"API/Reference","title":"Index","text":"","category":"section"},{"location":"modules/SkyCoords/api/","page":"API/Reference","title":"API/Reference","text":"pages = [\"api.md\"]","category":"page"},{"location":"modules/SkyCoords/api/#Types","page":"API/Reference","title":"Types","text":"","category":"section"},{"location":"modules/SkyCoords/api/","page":"API/Reference","title":"API/Reference","text":"AbstractSkyCoords\nICRSCoords\nGalCoords\nFK5Coords\nEclipticCoords","category":"page"},{"location":"modules/SkyCoords/api/#SkyCoords.AbstractSkyCoords","page":"API/Reference","title":"SkyCoords.AbstractSkyCoords","text":"The supertype for all sky coordinate systems.\n\n\n\n\n\n","category":"type"},{"location":"modules/SkyCoords/api/#SkyCoords.ICRSCoords","page":"API/Reference","title":"SkyCoords.ICRSCoords","text":"ICRSCoords(ra, dec)\n\nInternational Celestial Reference System\n\nThis is the current standard adopted by the International Astronomical Union notably due to its high level of accuracy compared to standard equatorial coordinate systems. What sets this apart from FK5Coords is that it is completely defined using extragalactic radio sources rather than a geocentric frame, which means the reference frame will not change due to Earth's motion.\n\nCoordinates\n\nra - Right ascension in radians (0, 2π)\ndec - Declination in radians (-π/2, π/2)\n\n\n\n\n\n","category":"type"},{"location":"modules/SkyCoords/api/#SkyCoords.GalCoords","page":"API/Reference","title":"SkyCoords.GalCoords","text":"GalCoords(l, b)\n\nGalactic Coordinate System\n\nThis coordinate system is defined based on the projection of the Milky Way galaxy onto our celestial sphere, with (0, 0) being approximately the center of our galaxy.\n\nCoordinates\n\nl - Galactic longitude in radians (-π, π)\nb - Galactic latitude in radians (-π/2, π/2)\n\n\n\n\n\n","category":"type"},{"location":"modules/SkyCoords/api/#SkyCoords.FK5Coords","page":"API/Reference","title":"SkyCoords.FK5Coords","text":"FK5Coords{equinox}(ra, dec)\n\nEquatorial Coordinate System\n\nThis coordinate system maps the celestial sphere based on a geocentric observer. Historically the oldest, this coordinate system has been shown to be inaccurate due to its definitions based on the Earth, which has long-scale precession causing the reference frame to change. Because of this, an equinox must be provided (typically 2000, commonly known as J2000) which defines the reference frame.\n\nCoordinates\n\nra - Right ascension in radians (0, 2π)\ndec - Declination in radians (-π/2, π/2)\n\n\n\n\n\n","category":"type"},{"location":"modules/SkyCoords/api/#SkyCoords.EclipticCoords","page":"API/Reference","title":"SkyCoords.EclipticCoords","text":"EclipticCoords{equinox}(lon, lat)\n\nEcliptic Coordinate System\n\nThis coordinate system is geocentric with the ecliptic plane as the xy-plane with x oriented according to the equinox specified by equinox.\n\nCoordinates\n\nlon - Longitude in radians (0, 2π)\nlat - Latitude in radians (-π/2, π/2)\n\n\n\n\n\n","category":"type"},{"location":"modules/SkyCoords/api/#Conversion","page":"API/Reference","title":"Conversion","text":"","category":"section"},{"location":"modules/SkyCoords/api/","page":"API/Reference","title":"API/Reference","text":"To convert between types, there are three (equivalent) methods of doing so.","category":"page"},{"location":"modules/SkyCoords/api/","page":"API/Reference","title":"API/Reference","text":"julia> c1 = ICRSCoords(0., 0.)\nICRSCoords{Float64}(0.0, 0.0)","category":"page"},{"location":"modules/SkyCoords/api/","page":"API/Reference","title":"API/Reference","text":"using convert","category":"page"},{"location":"modules/SkyCoords/api/","page":"API/Reference","title":"API/Reference","text":"julia> convert(GalCoords, c1)\nGalCoords{Float64}(1.6814027872278692, -1.0504884034813007)","category":"page"},{"location":"modules/SkyCoords/api/","page":"API/Reference","title":"API/Reference","text":"using constructors","category":"page"},{"location":"modules/SkyCoords/api/","page":"API/Reference","title":"API/Reference","text":"julia> GalCoords(c1)\nGalCoords{Float64}(1.6814027872278692, -1.0504884034813007)","category":"page"},{"location":"modules/SkyCoords/api/","page":"API/Reference","title":"API/Reference","text":"using |>","category":"page"},{"location":"modules/SkyCoords/api/","page":"API/Reference","title":"API/Reference","text":"julia> c1 |> GalCoords\nGalCoords{Float64}(1.6814027872278692, -1.0504884034813007)","category":"page"},{"location":"modules/SkyCoords/api/#Functions","page":"API/Reference","title":"Functions","text":"","category":"section"},{"location":"modules/SkyCoords/api/","page":"API/Reference","title":"API/Reference","text":"separation\nposition_angle\noffset","category":"page"},{"location":"modules/SkyCoords/api/#SkyCoords.separation","page":"API/Reference","title":"SkyCoords.separation","text":"separation(c1::AbstractSkyCoords, c2::AbstractSkyCoords) -> distance\n\nReturn angular separation between two sky coordinates, in radians.\n\nThe angular separation is calculated using the Vincenty formula, which is slightly more complex and computationally expensive than some alternatives, but is stable at at all distances, including the poles and antipodes.\n\n\n\n\n\n","category":"function"},{"location":"modules/SkyCoords/api/#SkyCoords.position_angle","page":"API/Reference","title":"SkyCoords.position_angle","text":"position_angle(c1::AbstractSkyCoords, c2::AbstractSkyCoords) -> angle\n\nReturn position angle between two sky coordinates, in positive radians.\n\nExamples\n\njulia> c1 = ICRSCoords(0, 0); c2 = ICRSCoords(deg2rad(1), 0);\n\njulia> position_angle(c1, c2) |> rad2deg\n90.0\n\n\n\n\n\n","category":"function"},{"location":"modules/SkyCoords/api/#SkyCoords.offset","page":"API/Reference","title":"SkyCoords.offset","text":"offset(::AbstractSkyCoords, separation, pa) -> coordinate\n\nOffset a coordinate by a given angular separation, separation, in radians and position angle, pa, in radians.\n\nUses the sine and cosine rules in spherical coordinates with corrections for the antipodes. Returns a sky coordinate of the same type as input.\n\nExamples\n\njulia> c1 = ICRSCoords(0, 0);\n\njulia> c2 = offset(c1, deg2rad(1), deg2rad(90))\nICRSCoords{Float64}(0.017453292519943295, 1.0686516840418957e-18)\n\njulia> offset(c1, c2) .|> rad2deg\n(1.0, 90.0)\n\nSee Also\n\nseparation, position_angle\n\n\n\n\n\noffset(::AbstractSkyCoords, AbstractSkyCoords) -> angle, angle\n\nReturn the separation and position angle in radians between two sky coordinates.\n\nExamples\n\njulia> c1 = ICRSCoords(0, 0); c2 = ICRSCoords(deg2rad(1), 0);\n\njulia> offset(c1, c2) .|> rad2deg\n(1.0, 90.0)\n\nSee Also\n\nseparation, position_angle\n\n\n\n\n\n","category":"function"},{"location":"modules/SAOImageDS9/install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"modules/SAOImageDS9/install/","page":"Installation","title":"Installation","text":"To use this package, the SAOImage/DS9 program and the XPA dynamic library and headers must be installed on your computer.  If this is not the case, they are available for different operating systems.  For example, on Debian or Ubuntu-like Linux system, you can call apt-get from the command line:","category":"page"},{"location":"modules/SAOImageDS9/install/","page":"Installation","title":"Installation","text":"sudo apt-get install saods9 libxpa-dev","category":"page"},{"location":"modules/SAOImageDS9/install/","page":"Installation","title":"Installation","text":"SAOImageDS9 can be can be installed by Julia's package manager:","category":"page"},{"location":"modules/SAOImageDS9/install/","page":"Installation","title":"Installation","text":"... pkg> add https://github.com/JuliaAstro/SAOImageDS9.jl","category":"page"},{"location":"modules/SAOImageDS9/install/","page":"Installation","title":"Installation","text":"Another possibility from Julia's REPL or in a Julia script:","category":"page"},{"location":"modules/SAOImageDS9/install/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(PackageSpec(url=\"https://github.com/JuliaAstro/SAOImageDS9.jl\", rev=\"master\"))","category":"page"},{"location":"modules/SAOImageDS9/install/","page":"Installation","title":"Installation","text":"See XPA.jl site for instructions about how to install this package if the installation of SAOImageDS9 fails to properly install this required package.","category":"page"},{"location":"modules/SAOImageDS9/install/","page":"Installation","title":"Installation","text":"To upgrade the SAOImageDS9 package:","category":"page"},{"location":"modules/SAOImageDS9/install/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.update(\"SAOImageDS9\")","category":"page"},{"location":"modules/SAOImageDS9/install/","page":"Installation","title":"Installation","text":"There is nothing to build.","category":"page"},{"location":"modules/SAOImageDS9/requests/#SAOImage/DS9-requests","page":"SAOImage/DS9 requests","title":"SAOImage/DS9 requests","text":"","category":"section"},{"location":"modules/SAOImageDS9/requests/","page":"SAOImage/DS9 requests","title":"SAOImage/DS9 requests","text":"There are two kinds of requests: get requests to retrieve some information or data from SAOImage/DS9 and set requests to send some data to SAOImage/DS9 or to set some of its parameters.","category":"page"},{"location":"modules/SAOImageDS9/requests/#Set-requests","page":"SAOImage/DS9 requests","title":"Set requests","text":"","category":"section"},{"location":"modules/SAOImageDS9/requests/","page":"SAOImage/DS9 requests","title":"SAOImage/DS9 requests","text":"The general syntax to perform a set request to the current SAOImage/DS9 access point is:","category":"page"},{"location":"modules/SAOImageDS9/requests/","page":"SAOImage/DS9 requests","title":"SAOImage/DS9 requests","text":"SAOImageDS9.set(args...; data=nothing)","category":"page"},{"location":"modules/SAOImageDS9/requests/","page":"SAOImage/DS9 requests","title":"SAOImage/DS9 requests","text":"where args... are any number of arguments which will be automatically converted in a string where the arguments are separated by spaces.  The keyword data may be used to specify the data to send with the request, it may be nothing (the default) or a Julia array.  For instance, the following 3 calls will set the current zoom to be equal to 3.7:","category":"page"},{"location":"modules/SAOImageDS9/requests/","page":"SAOImage/DS9 requests","title":"SAOImage/DS9 requests","text":"SAOImageDS9.set(:zoom,:to,3.7)\nSAOImageDS9.set(\"zoom to\",3.7)\nSAOImageDS9.set(\"zoom to 3.7\")","category":"page"},{"location":"modules/SAOImageDS9/requests/","page":"SAOImage/DS9 requests","title":"SAOImage/DS9 requests","text":"where the last line shows the string which is effectively sent to SAOImage/DS9 via the XPA.set method in the 3 above cases.","category":"page"},{"location":"modules/SAOImageDS9/requests/","page":"SAOImage/DS9 requests","title":"SAOImage/DS9 requests","text":"As a special case, args... can be a single array to send to SAOImage/DS9 for being displayed:","category":"page"},{"location":"modules/SAOImageDS9/requests/","page":"SAOImage/DS9 requests","title":"SAOImage/DS9 requests","text":"SAOImageDS9.set(arr)","category":"page"},{"location":"modules/SAOImageDS9/requests/","page":"SAOImage/DS9 requests","title":"SAOImage/DS9 requests","text":"where arr is a 2D or 3D Julia array.  SAOImage/DS9 will display the values of arr as an image (if arr is a 2D array) or a sequence of images (if arr is a 3D array) in the currently selected frame with the current scale parameters, zoom, orientation, rotation, etc.  Keyword order can be used to specify the byte ordering.  Keyword new can be set true to display the image in a new SAOImage/DS9 frame.","category":"page"},{"location":"modules/SAOImageDS9/requests/#Get-requests","page":"SAOImage/DS9 requests","title":"Get requests","text":"","category":"section"},{"location":"modules/SAOImageDS9/requests/","page":"SAOImage/DS9 requests","title":"SAOImage/DS9 requests","text":"To perform a get request, the general syntax is:","category":"page"},{"location":"modules/SAOImageDS9/requests/","page":"SAOImage/DS9 requests","title":"SAOImage/DS9 requests","text":"SAOImageDS9.get([T, [dims,]] args...)","category":"page"},{"location":"modules/SAOImageDS9/requests/","page":"SAOImage/DS9 requests","title":"SAOImage/DS9 requests","text":"where the args... arguments are treated as for the SAOImageDS9.set method (that is converted into a single text string with separating spaces).  Optional arguments T and dims are to specify the type of the expected result and, possibly, its list of dimensions.","category":"page"},{"location":"modules/SAOImageDS9/requests/","page":"SAOImage/DS9 requests","title":"SAOImage/DS9 requests","text":"If neither T nor dims are specified, the result of the SAOImageDS9.get(args...) call is an instance of XPA.Reply (see documentation about XPA.jl package for how to deal with the contents of such an instance).","category":"page"},{"location":"modules/SAOImageDS9/requests/","page":"SAOImage/DS9 requests","title":"SAOImage/DS9 requests","text":"The following methods can be used to issue a get request to the current DS9 access point depending on the expected type of result:","category":"page"},{"location":"modules/SAOImageDS9/requests/","page":"SAOImage/DS9 requests","title":"SAOImage/DS9 requests","text":"SAOImageDS9.get(Vector{UInt8}, args...)         -> buf\nSAOImageDS9.get(String, args...)                -> str\nSAOImageDS9.get(Vector{String}, args...;\n                delim=isspace, keepempty=false) -> arr\nSAOImageDS9.get(Tuple{Vararg{String}}, args...;\n                delim=isspace, keepempty=false) -> tup","category":"page"},{"location":"modules/SAOImageDS9/requests/","page":"SAOImage/DS9 requests","title":"SAOImage/DS9 requests","text":"where args... are treated as for the SAOImageDS9.set method.  The returned values are respectively a vector of bytes, a single string (with the last end-of-line removed if any), an array of strings (one for each line of the result and empty line removed unless keyword keepempty is set true), or an array of (non-empty) words.","category":"page"},{"location":"modules/SAOImageDS9/requests/","page":"SAOImage/DS9 requests","title":"SAOImage/DS9 requests","text":"If a single scalar integer or floating point is expected, two methods are available:","category":"page"},{"location":"modules/SAOImageDS9/requests/","page":"SAOImage/DS9 requests","title":"SAOImage/DS9 requests","text":"SAOImageDS9.get(Int, args...)    -> scalar\nSAOImageDS9.get(Float, args...)  -> scalar","category":"page"},{"location":"modules/SAOImageDS9/requests/","page":"SAOImage/DS9 requests","title":"SAOImage/DS9 requests","text":"which return respectively an Int and a Float64.","category":"page"},{"location":"modules/SAOImageDS9/requests/","page":"SAOImage/DS9 requests","title":"SAOImage/DS9 requests","text":"To retrieve the array displayed by the current SAOImage/DS9 frame, do:","category":"page"},{"location":"modules/SAOImageDS9/requests/","page":"SAOImage/DS9 requests","title":"SAOImage/DS9 requests","text":"arr = SAOImageDS9.get(Array);","category":"page"},{"location":"modules/SAOImageDS9/requests/","page":"SAOImage/DS9 requests","title":"SAOImage/DS9 requests","text":"Keyword order can be used to specify the byte ordering.","category":"page"},{"location":"modules/EarthOrientation/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"modules/EarthOrientation/tutorial/","page":"Tutorial","title":"Tutorial","text":"EarthOrientation.jl downloads, parses, and interpolates weekly-updated tables from the IERS that contain the following Earth Orientation Parameters (EOP):","category":"page"},{"location":"modules/EarthOrientation/tutorial/","page":"Tutorial","title":"Tutorial","text":"Polar motion:\nx-coordinate of Earth's north pole: x_p\ny-coordinate of Earth's north pole: y_p\nEarth rotation\nDifference between UT1 and UTC: Delta UT1\nExcess length of day: LOD\nPrecession and nutation based on the 1980 IAU conventions\nCorrection to the nutation of the ecliptic: dpsi\nCorrection to the obliquity of the ecliptic: depsilon\nPrecession and nutation based on the 2000 IAU conventions\nCorrection to the celestial pole's x-coordinate: dx\nCorrection to the celestial pole's y-coordinate: dy","category":"page"},{"location":"modules/EarthOrientation/tutorial/","page":"Tutorial","title":"Tutorial","text":"These parameters are required for precise transformations between quasi-inertial and rotating terrestrial reference frames.","category":"page"},{"location":"modules/EarthOrientation/tutorial/#Getting-Earth-Orientation-Data","page":"Tutorial","title":"Getting Earth Orientation Data","text":"","category":"section"},{"location":"modules/EarthOrientation/tutorial/","page":"Tutorial","title":"Tutorial","text":"When the package is imported for the first time the required data will be automatically downloaded from the IERS servers. After that the data needs to be updated manually like shown below.","category":"page"},{"location":"modules/EarthOrientation/tutorial/","page":"Tutorial","title":"Tutorial","text":"using EarthOrientation\nEarthOrientation.update()","category":"page"},{"location":"modules/EarthOrientation/tutorial/#Loading-Earth-Orientation-Data","page":"Tutorial","title":"Loading Earth Orientation Data","text":"","category":"section"},{"location":"modules/EarthOrientation/tutorial/","page":"Tutorial","title":"Tutorial","text":"The downloaded data is parsed into an EOParams object:","category":"page"},{"location":"modules/EarthOrientation/tutorial/","page":"Tutorial","title":"Tutorial","text":"eop = EOParams()","category":"page"},{"location":"modules/EarthOrientation/tutorial/","page":"Tutorial","title":"Tutorial","text":"By default the files downloaded by EarthOrientation.update() will be used. It is also possible to manually pass the required finals.all and finals2000A.all files in CSV format.","category":"page"},{"location":"modules/EarthOrientation/tutorial/","page":"Tutorial","title":"Tutorial","text":"eop = EOParams(\"finals.csv\", \"finals2000A.csv\")","category":"page"},{"location":"modules/EarthOrientation/tutorial/","page":"Tutorial","title":"Tutorial","text":"This is useful if the data should not be managed by EarthOrientation.jl but by a different system instead.","category":"page"},{"location":"modules/EarthOrientation/tutorial/#Interpolating-Earth-Orientation-Data","page":"Tutorial","title":"Interpolating Earth Orientation Data","text":"","category":"section"},{"location":"modules/EarthOrientation/tutorial/","page":"Tutorial","title":"Tutorial","text":"Get the current Earth orientation parameters, e.g. for polar motion:","category":"page"},{"location":"modules/EarthOrientation/tutorial/","page":"Tutorial","title":"Tutorial","text":"xp, yp = polarmotion(eop, now()) # arcseconds","category":"page"},{"location":"modules/EarthOrientation/tutorial/","page":"Tutorial","title":"Tutorial","text":"Or the current difference between UT1 and UTC and the associated prediction error:","category":"page"},{"location":"modules/EarthOrientation/tutorial/","page":"Tutorial","title":"Tutorial","text":"ΔUT1 = getΔUT1(eop, now()) # seconds\nΔUT1_err = getΔUT1_err(eop, now()) # milliseconds","category":"page"},{"location":"modules/Photometry/background/interpolators/#Background-Interpolators","page":"Background Interpolators","title":"Background Interpolators","text":"","category":"section"},{"location":"modules/Photometry/background/interpolators/","page":"Background Interpolators","title":"Background Interpolators","text":"Background interpolators provide a method for converting a low-resolution mesh into a low-order high-resolution image.","category":"page"},{"location":"modules/Photometry/background/interpolators/","page":"Background Interpolators","title":"Background Interpolators","text":"Background.BackgroundInterpolator","category":"page"},{"location":"modules/Photometry/background/interpolators/#Photometry.Background.BackgroundInterpolator","page":"Background Interpolators","title":"Photometry.Background.BackgroundInterpolator","text":"Background.BackgroundInterpolator\n\nThis abstract type embodies the different ways of converting a low-resolution mesh into a high-resolution image, especially for dispatch with estimate_background\n\nTo implement a new interpolation scheme, you must define the struct and define a method like (::MyInterpolator)(mesh)\n\nSee Also\n\nInterpolators\n\n\n\n\n\n","category":"type"},{"location":"modules/Photometry/background/interpolators/#Interpolators","page":"Background Interpolators","title":"Interpolators","text":"","category":"section"},{"location":"modules/Photometry/background/interpolators/","page":"Background Interpolators","title":"Background Interpolators","text":"ZoomInterpolator\nIDWInterpolator","category":"page"},{"location":"modules/Photometry/background/interpolators/#Photometry.Background.ZoomInterpolator","page":"Background Interpolators","title":"Photometry.Background.ZoomInterpolator","text":"ZoomInterpolator(factors)\n\nUse a cubic-spline interpolation scheme to increase resolution of a mesh.\n\nfactors represents the level of \"zoom\", so an input mesh of size (10, 10) with factors (2, 2) will have an output size of (20, 20). If only an integer is provided, it will be used as the factor for every axis.\n\nExamples\n\njulia> ZoomInterpolator(2)([1 0; 0 1])\n4×4 Matrix{Float64}:\n  1.0          0.75   0.25   -2.77556e-17\n  0.75         0.625  0.375   0.25\n  0.25         0.375  0.625   0.75\n -5.55112e-17  0.25   0.75    1.0\n\njulia> ZoomInterpolator(3, 1)([1 0; 0 1])\n6×2 Matrix{Float64}:\n  1.0          -2.77556e-17\n  1.0          -2.77556e-17\n  0.666667      0.333333\n  0.333333      0.666667\n -5.55112e-17   1.0\n -5.55112e-17   1.0\n\n\n\n\n\n\n","category":"type"},{"location":"modules/Photometry/background/interpolators/#Photometry.Background.IDWInterpolator","page":"Background Interpolators","title":"Photometry.Background.IDWInterpolator","text":"IDWInterpolator(factors; leafsize=10,  k=8, power=1, reg=0, conf_dist=1e-12)\n\nUse Shepard Inverse Distance Weighing interpolation scheme to increase resolution of a mesh.\n\nfactors represents the level of \"zoom\", so an input mesh of size (10, 10) with factors (2, 2) will have an output size of (20, 20). If only an integer is provided, it will be used as the factor for every axis.\n\nThe interpolator can be called with some additional parameter being, leaf_size determines at what number of points to stop splitting the tree further, k which is the number of nearest neighbors to be considered, power is the exponent for distance in the weighing factor, reg is the offset for the weighing factor in denominator, conf_dist is the distance below which two points would be considered as the same point.\n\nExamples\n\njulia> IDWInterpolator(2, k=2)([1 0; 0 1])\n4×4 Matrix{Float64}:\n 1.0   0.75      0.25      0.0\n 0.75  0.690983  0.309017  0.25\n 0.25  0.309017  0.690983  0.75\n 0.0   0.25      0.75      1.0\n\njulia> IDWInterpolator(3, 1; k=2, power=4)([1 0; 0 1])\n6×2 Matrix{Float64}:\n 1.0        0.0\n 1.0        0.0\n 0.941176   0.0588235\n 0.0588235  0.941176\n 0.0        1.0\n 0.0        1.0\n\n\n\n\n\n","category":"type"},{"location":"modules/AstroTime/api/epochs/#Epochs","page":"Epochs","title":"Epochs","text":"","category":"section"},{"location":"modules/AstroTime/api/epochs/","page":"Epochs","title":"Epochs","text":"Modules = [AstroTime.Epochs]\nPrivate = false","category":"page"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.Epoch","page":"Epochs","title":"AstroTime.Epochs.Epoch","text":"Epoch(str[, format])\n\nConstruct an Epoch from a string str. Optionally a format definition can be passed as a DateFormat object or as a string. In addition to the character codes supported by DateFormat the character code D is supported which is parsed as \"day of year\" (see the example below) and the character code t which is parsed as the time scale.  The default format is yyyy-mm-ddTHH:MM:SS.sss ttt.\n\nNote: Please be aware that this constructor requires that the time scale is part of str, e.g. 2018-02-06T00:00 TAI. Otherwise use an explicit constructor, e.g. Epoch{TAI}.\n\nExample\n\njulia> Epoch(\"2018-02-06T20:45:00.0 TAI\")\n2018-02-06T20:45:00.000 TAI\n\njulia> Epoch(\"2018-037T00:00 TAI\", \"yyyy-DDDTHH:MM ttt\")\n2018-02-06T00:00:00.000 TAI\n\n\n\n\n\n","category":"type"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.Epoch-Union{Tuple{AbstractString}, Tuple{S}, Tuple{AbstractString, Dates.DateFormat}} where S","page":"Epochs","title":"AstroTime.Epochs.Epoch","text":"Epoch{S}(str[, format]) where S\n\nConstruct an Epoch with time scale S from a string str. Optionally a format definition can be passed as a DateFormat object or as a string. In addition to the character codes supported by DateFormat the code D can be used which is parsed as \"day of year\" (see the example below).  The default format is yyyy-mm-ddTHH:MM:SS.sss.\n\nExample\n\njulia> Epoch{InternationalAtomicTime}(\"2018-02-06T20:45:00.0\")\n2018-02-06T20:45:00.000 TAI\n\njulia> Epoch{InternationalAtomicTime}(\"February 6, 2018\", \"U d, y\")\n2018-02-06T00:00:00.000 TAI\n\njulia> Epoch{InternationalAtomicTime}(\"2018-037T00:00\", \"yyyy-DDDTHH:MM\")\n2018-02-06T00:00:00.000 TAI\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.Epoch-Union{Tuple{Epoch{S1}}, Tuple{S2}, Tuple{S1}} where {S1<:TimeScale, S2<:TimeScale}","page":"Epochs","title":"AstroTime.Epochs.Epoch","text":"Epoch{S2}(ep::Epoch{S1}) where {S1, S2}\n\nConvert ep, an Epoch with time scale S1, to an Epoch with time scale S2.\n\nExamples\n\njulia> ep = TTEpoch(2000,1,1)\n2000-01-01T00:00:00.000 TT\n\njulia> TAIEpoch(ep)\n1999-12-31T23:59:27.816 TAI\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.Epoch-Union{Tuple{Int64, Int64, Int64}, NTuple{4, Int64}, NTuple{5, Int64}, Tuple{S}, Tuple{Int64, Int64, Int64, Int64, Int64, Float64, Vararg{Any}}} where S","page":"Epochs","title":"AstroTime.Epochs.Epoch","text":"Epoch{S}(year, month, day, hour=0, minute=0, second=0.0) where S\n\nConstruct an Epoch with time scale S from date and time components.\n\nExample\n\njulia> Epoch{InternationalAtomicTime}(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TAI\n\njulia> Epoch{InternationalAtomicTime}(2018, 2, 6)\n2018-02-06T00:00:00.000 TAI\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.Epoch-Union{Tuple{S2}, Tuple{S1}, Tuple{Any, Epoch{S1}}} where {S1<:TimeScale, S2<:TimeScale}","page":"Epochs","title":"AstroTime.Epochs.Epoch","text":"Epoch{S}(Δtai, ep::TAIEpoch) where S\n\nConvert ep, a TAIEpoch, to an Epoch with time scale S by overriding the offset between S2 and TAI with Δtai.\n\nExamples\n\njulia> ep = TAIEpoch(2000,1,1)\n2000-01-01T00:00:00.000 TAI\n\njulia> TTEpoch(32.184, ep)\n2000-01-01T00:00:32.184 TT\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.Epoch-Union{Tuple{S2}, Tuple{S1}, Tuple{Epoch{S1}, S2}} where {S1<:TimeScale, S2<:TimeScale}","page":"Epochs","title":"AstroTime.Epochs.Epoch","text":"Epoch(ep::Epoch{S1}, scale::S2) where {S1, S2}\n\nConvert ep, an Epoch with time scale S1, to an Epoch with time scale S2.\n\nExamples\n\njulia> ep = TTEpoch(2000,1,1)\n2000-01-01T00:00:00.000 TT\n\njulia> Epoch(ep, TAI)\n1999-12-31T23:59:27.816 TAI\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.Epoch-Union{Tuple{T}, Tuple{S}, Tuple{T, T, Vararg{Any}}} where {S, T<:AstroPeriod}","page":"Epochs","title":"AstroTime.Epochs.Epoch","text":"Epoch{S}(jd1::T, jd2::T=zero(T); origin=:j2000) where {S, T<:AstroPeriod}\n\nConstruct an Epoch with time scale S from a Julian date (optionally split into jd1 and jd2). origin determines the variant of Julian date that is used. Possible values are:\n\n:j2000: J2000 Julian date, starts at 2000-01-01T12:00\n:julian: Julian date, starts at -4712-01-01T12:00\n:modified_julian: Modified Julian date, starts at 1858-11-17T00:00\n\nExamples\n\njulia> Epoch{InternationalAtomicTime}(0.0days, 0.5days)\n2000-01-02T00:00:00.000 TAI\n\njulia> Epoch{InternationalAtomicTime}(2.451545e6days, origin=:julian)\n2000-01-01T12:00:00.000 TAI\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.TAIEpoch-Tuple{AbstractString}","page":"Epochs","title":"AstroTime.Epochs.TAIEpoch","text":"TAIEpoch(str[, format])\n\nConstruct a TAIEpoch from a string str. Optionally a format definition can be passed as a DateFormat object or as a string. In addition to the character codes supported by DateFormat the code D is supported which is parsed as \"day of year\" (see the example below). The default format is yyyy-mm-ddTHH:MM:SS.sss.\n\nExample\n\njulia> TAIEpoch(\"2018-02-06T20:45:00.0\")\n2018-02-06T20:45:00.000 TAI\n\njulia> TAIEpoch(\"February 6, 2018\", \"U d, y\")\n2018-02-06T00:00:00.000 TAI\n\njulia> TAIEpoch(\"2018-37T00:00\", \"yyyy-DDDTHH:MM\")\n2018-02-06T00:00:00.000 TAI\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.TAIEpoch-Tuple{Int64, Int64, Int64}","page":"Epochs","title":"AstroTime.Epochs.TAIEpoch","text":"TAIEpoch(year, month, day, hour=0, minute=0, second=0.0)\n\nConstruct a TAIEpoch from date and time components.\n\nExample\n\njulia> TAIEpoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TAI\n\njulia> TAIEpoch(2018, 2, 6)\n2018-02-06T00:00:00.000 TAI\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.TAIEpoch-Tuple{Number, Number}","page":"Epochs","title":"AstroTime.Epochs.TAIEpoch","text":"TAIEpoch(jd1::T, jd2::T=zero(T); origin=:j2000) where T<:AstroPeriod\n\nConstruct a TAIEpoch from a Julian date (optionally split into jd1 and jd2). origin determines the variant of Julian date that is used. Possible values are:\n\n:j2000: J2000 Julian date, starts at 2000-01-01T12:00\n:julian: Julian date, starts at -4712-01-01T12:00\n:modified_julian: Modified Julian date, starts at 1858-11-17T00:00\n\nExamples\n\njulia> TAIEpoch(0.0days, 0.5days)\n2000-01-02T00:00:00.000 TAI\n\njulia> TAIEpoch(2.451545e6days, origin=:julian)\n2000-01-01T12:00:00.000 TAI\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.TCBEpoch-Tuple{AbstractString}","page":"Epochs","title":"AstroTime.Epochs.TCBEpoch","text":"TCBEpoch(str[, format])\n\nConstruct a TCBEpoch from a string str. Optionally a format definition can be passed as a DateFormat object or as a string. In addition to the character codes supported by DateFormat the code D is supported which is parsed as \"day of year\" (see the example below). The default format is yyyy-mm-ddTHH:MM:SS.sss.\n\nExample\n\njulia> TCBEpoch(\"2018-02-06T20:45:00.0\")\n2018-02-06T20:45:00.000 TCB\n\njulia> TCBEpoch(\"February 6, 2018\", \"U d, y\")\n2018-02-06T00:00:00.000 TCB\n\njulia> TCBEpoch(\"2018-37T00:00\", \"yyyy-DDDTHH:MM\")\n2018-02-06T00:00:00.000 TCB\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.TCBEpoch-Tuple{Int64, Int64, Int64}","page":"Epochs","title":"AstroTime.Epochs.TCBEpoch","text":"TCBEpoch(year, month, day, hour=0, minute=0, second=0.0)\n\nConstruct a TCBEpoch from date and time components.\n\nExample\n\njulia> TCBEpoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TCB\n\njulia> TCBEpoch(2018, 2, 6)\n2018-02-06T00:00:00.000 TCB\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.TCBEpoch-Tuple{Number, Number}","page":"Epochs","title":"AstroTime.Epochs.TCBEpoch","text":"TCBEpoch(jd1::T, jd2::T=zero(T); origin=:j2000) where T<:AstroPeriod\n\nConstruct a TCBEpoch from a Julian date (optionally split into jd1 and jd2). origin determines the variant of Julian date that is used. Possible values are:\n\n:j2000: J2000 Julian date, starts at 2000-01-01T12:00\n:julian: Julian date, starts at -4712-01-01T12:00\n:modified_julian: Modified Julian date, starts at 1858-11-17T00:00\n\nExamples\n\njulia> TCBEpoch(0.0days, 0.5days)\n2000-01-02T00:00:00.000 TCB\n\njulia> TCBEpoch(2.451545e6days, origin=:julian)\n2000-01-01T12:00:00.000 TCB\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.TCGEpoch-Tuple{AbstractString}","page":"Epochs","title":"AstroTime.Epochs.TCGEpoch","text":"TCGEpoch(str[, format])\n\nConstruct a TCGEpoch from a string str. Optionally a format definition can be passed as a DateFormat object or as a string. In addition to the character codes supported by DateFormat the code D is supported which is parsed as \"day of year\" (see the example below). The default format is yyyy-mm-ddTHH:MM:SS.sss.\n\nExample\n\njulia> TCGEpoch(\"2018-02-06T20:45:00.0\")\n2018-02-06T20:45:00.000 TCG\n\njulia> TCGEpoch(\"February 6, 2018\", \"U d, y\")\n2018-02-06T00:00:00.000 TCG\n\njulia> TCGEpoch(\"2018-37T00:00\", \"yyyy-DDDTHH:MM\")\n2018-02-06T00:00:00.000 TCG\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.TCGEpoch-Tuple{Int64, Int64, Int64}","page":"Epochs","title":"AstroTime.Epochs.TCGEpoch","text":"TCGEpoch(year, month, day, hour=0, minute=0, second=0.0)\n\nConstruct a TCGEpoch from date and time components.\n\nExample\n\njulia> TCGEpoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TCG\n\njulia> TCGEpoch(2018, 2, 6)\n2018-02-06T00:00:00.000 TCG\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.TCGEpoch-Tuple{Number, Number}","page":"Epochs","title":"AstroTime.Epochs.TCGEpoch","text":"TCGEpoch(jd1::T, jd2::T=zero(T); origin=:j2000) where T<:AstroPeriod\n\nConstruct a TCGEpoch from a Julian date (optionally split into jd1 and jd2). origin determines the variant of Julian date that is used. Possible values are:\n\n:j2000: J2000 Julian date, starts at 2000-01-01T12:00\n:julian: Julian date, starts at -4712-01-01T12:00\n:modified_julian: Modified Julian date, starts at 1858-11-17T00:00\n\nExamples\n\njulia> TCGEpoch(0.0days, 0.5days)\n2000-01-02T00:00:00.000 TCG\n\njulia> TCGEpoch(2.451545e6days, origin=:julian)\n2000-01-01T12:00:00.000 TCG\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.TDBEpoch-Tuple{AbstractString}","page":"Epochs","title":"AstroTime.Epochs.TDBEpoch","text":"TDBEpoch(str[, format])\n\nConstruct a TDBEpoch from a string str. Optionally a format definition can be passed as a DateFormat object or as a string. In addition to the character codes supported by DateFormat the code D is supported which is parsed as \"day of year\" (see the example below). The default format is yyyy-mm-ddTHH:MM:SS.sss.\n\nExample\n\njulia> TDBEpoch(\"2018-02-06T20:45:00.0\")\n2018-02-06T20:45:00.000 TDB\n\njulia> TDBEpoch(\"February 6, 2018\", \"U d, y\")\n2018-02-06T00:00:00.000 TDB\n\njulia> TDBEpoch(\"2018-37T00:00\", \"yyyy-DDDTHH:MM\")\n2018-02-06T00:00:00.000 TDB\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.TDBEpoch-Tuple{Int64, Int64, Int64}","page":"Epochs","title":"AstroTime.Epochs.TDBEpoch","text":"TDBEpoch(year, month, day, hour=0, minute=0, second=0.0)\n\nConstruct a TDBEpoch from date and time components.\n\nExample\n\njulia> TDBEpoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TDB\n\njulia> TDBEpoch(2018, 2, 6)\n2018-02-06T00:00:00.000 TDB\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.TDBEpoch-Tuple{Number, Number}","page":"Epochs","title":"AstroTime.Epochs.TDBEpoch","text":"TDBEpoch(jd1::T, jd2::T=zero(T); origin=:j2000) where T<:AstroPeriod\n\nConstruct a TDBEpoch from a Julian date (optionally split into jd1 and jd2). origin determines the variant of Julian date that is used. Possible values are:\n\n:j2000: J2000 Julian date, starts at 2000-01-01T12:00\n:julian: Julian date, starts at -4712-01-01T12:00\n:modified_julian: Modified Julian date, starts at 1858-11-17T00:00\n\nExamples\n\njulia> TDBEpoch(0.0days, 0.5days)\n2000-01-02T00:00:00.000 TDB\n\njulia> TDBEpoch(2.451545e6days, origin=:julian)\n2000-01-01T12:00:00.000 TDB\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.TTEpoch-Tuple{AbstractString}","page":"Epochs","title":"AstroTime.Epochs.TTEpoch","text":"TTEpoch(str[, format])\n\nConstruct a TTEpoch from a string str. Optionally a format definition can be passed as a DateFormat object or as a string. In addition to the character codes supported by DateFormat the code D is supported which is parsed as \"day of year\" (see the example below). The default format is yyyy-mm-ddTHH:MM:SS.sss.\n\nExample\n\njulia> TTEpoch(\"2018-02-06T20:45:00.0\")\n2018-02-06T20:45:00.000 TT\n\njulia> TTEpoch(\"February 6, 2018\", \"U d, y\")\n2018-02-06T00:00:00.000 TT\n\njulia> TTEpoch(\"2018-37T00:00\", \"yyyy-DDDTHH:MM\")\n2018-02-06T00:00:00.000 TT\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.TTEpoch-Tuple{Int64, Int64, Int64}","page":"Epochs","title":"AstroTime.Epochs.TTEpoch","text":"TTEpoch(year, month, day, hour=0, minute=0, second=0.0)\n\nConstruct a TTEpoch from date and time components.\n\nExample\n\njulia> TTEpoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TT\n\njulia> TTEpoch(2018, 2, 6)\n2018-02-06T00:00:00.000 TT\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.TTEpoch-Tuple{Number, Number}","page":"Epochs","title":"AstroTime.Epochs.TTEpoch","text":"TTEpoch(jd1::T, jd2::T=zero(T); origin=:j2000) where T<:AstroPeriod\n\nConstruct a TTEpoch from a Julian date (optionally split into jd1 and jd2). origin determines the variant of Julian date that is used. Possible values are:\n\n:j2000: J2000 Julian date, starts at 2000-01-01T12:00\n:julian: Julian date, starts at -4712-01-01T12:00\n:modified_julian: Modified Julian date, starts at 1858-11-17T00:00\n\nExamples\n\njulia> TTEpoch(0.0days, 0.5days)\n2000-01-02T00:00:00.000 TT\n\njulia> TTEpoch(2.451545e6days, origin=:julian)\n2000-01-01T12:00:00.000 TT\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.UT1Epoch-Tuple{AbstractString}","page":"Epochs","title":"AstroTime.Epochs.UT1Epoch","text":"UT1Epoch(str[, format])\n\nConstruct a UT1Epoch from a string str. Optionally a format definition can be passed as a DateFormat object or as a string. In addition to the character codes supported by DateFormat the code D is supported which is parsed as \"day of year\" (see the example below). The default format is yyyy-mm-ddTHH:MM:SS.sss.\n\nExample\n\njulia> UT1Epoch(\"2018-02-06T20:45:00.0\")\n2018-02-06T20:45:00.000 UT1\n\njulia> UT1Epoch(\"February 6, 2018\", \"U d, y\")\n2018-02-06T00:00:00.000 UT1\n\njulia> UT1Epoch(\"2018-37T00:00\", \"yyyy-DDDTHH:MM\")\n2018-02-06T00:00:00.000 UT1\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.UT1Epoch-Tuple{Int64, Int64, Int64}","page":"Epochs","title":"AstroTime.Epochs.UT1Epoch","text":"UT1Epoch(year, month, day, hour=0, minute=0, second=0.0)\n\nConstruct a UT1Epoch from date and time components.\n\nExample\n\njulia> UT1Epoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 UT1\n\njulia> UT1Epoch(2018, 2, 6)\n2018-02-06T00:00:00.000 UT1\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.UT1Epoch-Tuple{Number, Number}","page":"Epochs","title":"AstroTime.Epochs.UT1Epoch","text":"UT1Epoch(jd1::T, jd2::T=zero(T); origin=:j2000) where T<:AstroPeriod\n\nConstruct a UT1Epoch from a Julian date (optionally split into jd1 and jd2). origin determines the variant of Julian date that is used. Possible values are:\n\n:j2000: J2000 Julian date, starts at 2000-01-01T12:00\n:julian: Julian date, starts at -4712-01-01T12:00\n:modified_julian: Modified Julian date, starts at 1858-11-17T00:00\n\nExamples\n\njulia> UT1Epoch(0.0days, 0.5days)\n2000-01-02T00:00:00.000 UT1\n\njulia> UT1Epoch(2.451545e6days, origin=:julian)\n2000-01-01T12:00:00.000 UT1\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.AstroDates.fractionofday-Tuple{Epoch}","page":"Epochs","title":"AstroTime.AstroDates.fractionofday","text":"fractionofday(ep::Epoch)\n\nGet the time of the day of the epoch ep as a fraction.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.AstroDates.fractionofsecond-Tuple{Epoch}","page":"Epochs","title":"AstroTime.AstroDates.fractionofsecond","text":"fractionofsecond(ep::Epoch)\n\nGet the fraction of the current second of the epoch ep.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.AstroDates.j2000-Tuple{Epoch}","page":"Epochs","title":"AstroTime.AstroDates.j2000","text":"j2000(ep)\n\nReturn the J2000 Julian Date for epoch ep.\n\nExample\n\njulia> j2000(TAIEpoch(2000, 1, 1, 12))\n0.0 days\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.AstroDates.julian-Tuple{Epoch}","page":"Epochs","title":"AstroTime.AstroDates.julian","text":"julian(ep)\n\nReturn the Julian Date for epoch ep.\n\nExample\n\njulia> julian(TAIEpoch(2000, 1, 1, 12))\n2.451545e6 days\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.AstroDates.julian_twopart-Tuple{Epoch}","page":"Epochs","title":"AstroTime.AstroDates.julian_twopart","text":"julian_twopart(ep)\n\nReturn the two-part Julian Date for epoch ep, which is a tuple consisting of the Julian day number and the fraction of the day.\n\nExample\n\njulia> julian_twopart(TAIEpoch(2000, 1, 2))\n(2.451545e6 days, 0.5 days)\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.AstroDates.subsecond-Tuple{Epoch, Any}","page":"Epochs","title":"AstroTime.AstroDates.subsecond","text":"subsecond(ep::Epoch, n)\n\nGet the number of fractional seconds with the unit s * frac110^n, e.g. subsecond(ep, 3) for milliseconds, of the epoch ep. n must be divisible by 3.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.from_utc","page":"Epochs","title":"AstroTime.Epochs.from_utc","text":"from_utc(str::AbstractString, dateformat::Dates.DateFormat; scale=TAI)\nfrom_utc(dt::Dates.DateTime; scale=TAI)\nfrom_utc(year, month, day, hour=0, minute=0, second=0, fraction=0.0; scale=TAI)\nfrom_utc(year, month, day, hour, minute, seconds; scale=TAI)\n\nCreate an Epoch in scale based on a UTC timestamp, Dates.DateTime or date and time components.\n\nExamples\n\njulia> from_utc(2016, 12, 31, 23, 59, 60, 0.0)\n2017-01-01T00:00:36.000 TAI\n\njulia> from_utc(2016, 12, 31, 23, 59, 60.0)\n2017-01-01T00:00:36.000 TAI\n\njulia> from_utc(\"2016-12-31T23:59:60.0\")\n2017-01-01T00:00:36.000 TAI\n\njulia> from_utc(\"2016-12-31T23:59:60.0\", scale=TDB)\n2017-01-01T00:01:08.183 TDB\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.getoffset","page":"Epochs","title":"AstroTime.Epochs.getoffset","text":"getoffset(UT1, TAI, second, fraction[, eop])\n\nReturn the offset between UT1 and TAI for the current epoch (second after J2000 and fraction) in seconds. Optionally, a custom Earth orientation data struct eop can be provided, see EarthOrientation.jl.\n\nExample\n\njulia> getoffset(UT1, TAI, 0, 0.0)\n31.644974965344606\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.getoffset-2","page":"Epochs","title":"AstroTime.Epochs.getoffset","text":"getoffset(TAI, UT1, second, fraction[, eop])\n\nReturn the offset between TAI and UT1 for the current epoch (second after J2000 and fraction) in seconds. Optionally, a custom Earth orientation data struct eop can be provided, see EarthOrientation.jl.\n\nExample\n\njulia> getoffset(TAI, UT1, 0, 0.0)\n-31.644974644349812\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.getoffset-Tuple{BarycentricCoordinateTime, BarycentricDynamicalTime, Any, Any}","page":"Epochs","title":"AstroTime.Epochs.getoffset","text":"getoffset(TCB, TDB, second, fraction)\n\nReturn the linear offset between TCB and TDB for the current epoch (second after J2000 and fraction) in seconds.\n\nExample\n\njulia> getoffset(TCB, TDB, 0, 0.0)\n-11.253721593757295\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.getoffset-Tuple{BarycentricDynamicalTime, BarycentricCoordinateTime, Any, Any}","page":"Epochs","title":"AstroTime.Epochs.getoffset","text":"getoffset(TDB, TCB, second, fraction)\n\nReturn the linear offset between TDB and TCB for the current epoch (second after J2000 and fraction) in seconds.\n\nExample\n\njulia> getoffset(TDB, TCB, 0, 0.0)\n11.253721768248475\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.getoffset-Tuple{BarycentricDynamicalTime, TerrestrialTime, Any, Any}","page":"Epochs","title":"AstroTime.Epochs.getoffset","text":"getoffset(TDB, TT, second, fraction[, eop])\n\nReturn the offset between TDB and TT for the current epoch (second after J2000 and fraction) in seconds. This routine is accurate to ~40 microseconds over the interval 1900-2100.\n\nnote: Note\nAn accurate transformation between TDB and TT depends on the trajectory of the observer. For two observers fixed on Earth's surface the quantity TDB-TT can differ by as much as ~4 microseconds. See here.\n\nExample\n\njulia> getoffset(TDB, TT, 0, 0.0)\n7.273677616693264e-5\n\nReferences\n\nhttps://www.cv.nrao.edu/~rfisher/Ephemerides/times.html#TDB\nIssue #26\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.getoffset-Tuple{BarycentricDynamicalTime, TerrestrialTime, Vararg{Any, 5}}","page":"Epochs","title":"AstroTime.Epochs.getoffset","text":"getoffset(TDB, TT, second, fraction[, eop])\n\nReturn the offset between TDB and TT for the current epoch (second after J2000 and fraction) for an observer on earth in seconds.\n\nArguments\n\nsecond, fraction: Current epoch\nelong: Longitude (east positive, radians)\nu: Distance from Earth's spin axis (km)\nv: Distance north of equatorial plane (km)\n\nExample\n\njulia> getoffset(TDB, TT, 0, 0.0, π, 6371.0, 0.0)\n9.928419814106208e-5\n\nReferences\n\nERFA\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.getoffset-Tuple{GeocentricCoordinateTime, TerrestrialTime, Any, Any}","page":"Epochs","title":"AstroTime.Epochs.getoffset","text":"getoffset(TCG, TT, second, fraction)\n\nReturn the linear offset between TCG and TT for the current epoch (second after J2000 and fraction) in seconds.\n\nExample\n\njulia> getoffset(TCG, TT, 0, 0.0)\n-0.5058332856685995\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.getoffset-Tuple{InternationalAtomicTime, TerrestrialTime, Vararg{Any}}","page":"Epochs","title":"AstroTime.Epochs.getoffset","text":"getoffset(TAI, TT, args...)\n\nReturn the fixed offset between TAI and TT in seconds.\n\nExample\n\njulia> getoffset(TAI, TT)\n32.184\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.getoffset-Tuple{TerrestrialTime, BarycentricDynamicalTime, Any, Any}","page":"Epochs","title":"AstroTime.Epochs.getoffset","text":"getoffset(TT, TDB, second, fraction[, eop])\n\nReturn the offset between TT and TDB for the current epoch (second after J2000 and fraction) in seconds. This routine is accurate to ~40 microseconds over the interval 1900-2100.\n\nnote: Note\nAn accurate transformation between TDB and TT depends on the trajectory of the observer. For two observers fixed on Earth's surface the quantity TDB-TT can differ by as much as ~4 microseconds. See here.\n\nExample\n\njulia> getoffset(TT, TDB, 0, 0.0)\n-7.273677619130569e-5\n\nReferences\n\nhttps://www.cv.nrao.edu/~rfisher/Ephemerides/times.html#TDB\nIssue #26\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.getoffset-Tuple{TerrestrialTime, BarycentricDynamicalTime, Vararg{Any, 5}}","page":"Epochs","title":"AstroTime.Epochs.getoffset","text":"getoffset(TT, TDB, second, fraction[, eop])\n\nReturn the offset between TT and TDB for the current epoch (second after J2000 and fraction) for an observer on earth in seconds.\n\nArguments\n\nsecond, fraction: Current epoch\nelong: Longitude (east positive, radians)\nu: Distance from Earth's spin axis (km)\nv: Distance north of equatorial plane (km)\n\nExample\n\njulia> getoffset(TT, TDB, 0, 0.0, π, 6371.0, 0.0)\n-9.928419818977206e-5\n\nReferences\n\nERFA\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.getoffset-Tuple{TerrestrialTime, GeocentricCoordinateTime, Any, Any}","page":"Epochs","title":"AstroTime.Epochs.getoffset","text":"getoffset(TT, TCG, second, fraction)\n\nReturn the linear offset between TT and TCG for the current epoch (second after J2000 and fraction) in seconds.\n\nExample\n\njulia> getoffset(TT, TCG, 0, 0.0)\n0.5058332860211293\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.getoffset-Tuple{TerrestrialTime, InternationalAtomicTime, Vararg{Any}}","page":"Epochs","title":"AstroTime.Epochs.getoffset","text":"getoffset(TT, TAI, args...)\n\nReturn the fixed offset between TT and TAI in seconds.\n\nExample\n\njulia> getoffset(TT, TAI)\n-32.184\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.getoffset-Union{Tuple{S}, Tuple{Epoch{S}, TimeScale, Vararg{Any}}} where S<:TimeScale","page":"Epochs","title":"AstroTime.Epochs.getoffset","text":"getoffset(ep::Epoch, scale::TimeScale)\n\nFor a given epoch ep return the offset between its time scale and another time scale in seconds.\n\nExample\n\njulia> tai = TAIEpoch(2000, 1, 1)\n2000-01-01T00:00:00.000 TAI\n\njulia> getoffset(tai, TT)\n32.184\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.julian_period-Tuple{Epoch}","page":"Epochs","title":"AstroTime.Epochs.julian_period","text":"julian_period([T,] ep::Epoch; origin=:j2000, scale=timescale(ep), unit=days)\n\nReturn the period since Julian Epoch origin within the time scale scale expressed in unit for a given epoch ep. The result is an AstroPeriod object by default. If the type argument T is present, the result is converted to T instead.\n\nExample\n\njulia> ep = TAIEpoch(2018, 2, 6, 20, 45, 0.0)\n2018-02-06T20:45:00.000 TAI\n\njulia> julian_period(ep; scale=TT)\n6611.364955833334 days\n\njulia> julian_period(ep; unit=years)\n18.100929728496464 years\n\njulia> julian_period(Float64, ep)\n6611.364583333333\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.modified_julian-Tuple{Epoch}","page":"Epochs","title":"AstroTime.Epochs.modified_julian","text":"modified_julian(ep)\n\nReturn the Modified Julian Date for epoch ep.\n\nExample\n\njulia> modified_julian(TAIEpoch(2000, 1, 1, 12))\n51544.5 days\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.timescale-Tuple{Epoch}","page":"Epochs","title":"AstroTime.Epochs.timescale","text":"timescale(ep)\n\nReturn the time scale of epoch ep.\n\nExample\n\njulia> ep = TTEpoch(2000, 1, 1)\n2000-01-01T00:00:00.000 TT\n\njulia> timescale(ep)\nTT\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#AstroTime.Epochs.to_utc","page":"Epochs","title":"AstroTime.Epochs.to_utc","text":"to_utc(ep)\nto_utc(::Type{DateTime}, ep)\nto_utc(::Type{Dates.DateTime}, ep)\nto_utc(::Type{String}, ep, dateformat=Dates.default_format(DateTime))\n\nCreate a UTC timestamp or Dates.DateTime from an Epoch ep.\n\nExamples\n\njulia> tai = from_utc(Dates.DateTime(2018, 2, 6, 20, 45, 0, 0))\n2018-02-06T20:45:37.000 TAI\n\njulia> to_utc(tai)\n\"2018-02-06T20:45:00.000\"\n\njulia> to_utc(String, tai, Dates.dateformat\"yyyy-mm-dd\")\n\"2018-02-06\"\n\njulia> to_utc(Dates.DateTime, tai)\n2018-02-06T20:45:00\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroTime/api/epochs/#Base.:--Union{Tuple{S}, Tuple{Epoch{S}, Epoch{S}}} where S<:TimeScale","page":"Epochs","title":"Base.:-","text":"-(a::Epoch, b::Epoch)\n\nReturn the duration between epoch a and epoch b.\n\nExamples\n\njulia> TAIEpoch(2018, 2, 6, 20, 45, 20.0) - TAIEpoch(2018, 2, 6, 20, 45, 0.0)\n20.0 seconds\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#Dates.day-Tuple{Epoch}","page":"Epochs","title":"Dates.day","text":"day(ep::Epoch)\n\nGet the day of the epoch ep.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#Dates.dayofyear-Tuple{Epoch}","page":"Epochs","title":"Dates.dayofyear","text":"dayofyear(ep::Epoch)\n\nGet the day of the year of the epoch ep.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#Dates.hour-Tuple{Epoch}","page":"Epochs","title":"Dates.hour","text":"hour(ep::Epoch)\n\nGet the hour of the epoch ep.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#Dates.microsecond-Tuple{Epoch}","page":"Epochs","title":"Dates.microsecond","text":"microsecond(ep::Epoch)\n\nGet the number of microseconds of the epoch ep.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#Dates.millisecond-Tuple{Epoch}","page":"Epochs","title":"Dates.millisecond","text":"millisecond(ep::Epoch)\n\nGet the number of milliseconds of the epoch ep.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#Dates.minute-Tuple{Epoch}","page":"Epochs","title":"Dates.minute","text":"minute(ep::Epoch)\n\nGet the minute of the epoch ep.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#Dates.month-Tuple{Epoch}","page":"Epochs","title":"Dates.month","text":"month(ep::Epoch)\n\nGet the month of the epoch ep.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#Dates.nanosecond-Tuple{Epoch}","page":"Epochs","title":"Dates.nanosecond","text":"nanosecond(ep::Epoch)\n\nGet the number of nanoseconds of the epoch ep.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#Dates.now-Union{Tuple{Type{Epoch{S}}}, Tuple{S}} where S","page":"Epochs","title":"Dates.now","text":"now(::Type{Epoch})\nnow(::Type{Epoch{S}}) where S<:TimeScale\n\nGet the current date and time as an Epoch. The default time scale is TAI.\n\nExample\n\njulia> now(Epoch)\n2021-04-11T13:20:29.160 TAI\n\njulia> now(TDBEpoch)\n2021-04-11T13:21:21.518 TDB\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#Dates.second-Tuple{Any, Epoch}","page":"Epochs","title":"Dates.second","text":"second(type, ep::Epoch)\n\nGet the second of the epoch ep as a type.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#Dates.second-Tuple{Epoch}","page":"Epochs","title":"Dates.second","text":"second(ep::Epoch) -> Int\n\nGet the second of the epoch ep as an Int.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#Dates.year-Tuple{Epoch}","page":"Epochs","title":"Dates.year","text":"year(ep::Epoch)\n\nGet the year of the epoch ep.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/#Dates.yearmonthday-Tuple{Epoch}","page":"Epochs","title":"Dates.yearmonthday","text":"yearmonthday(ep::Epoch)\n\nGet the year, month, and day of the epoch ep as a tuple.\n\n\n\n\n\n","category":"method"},{"location":"modules/AstroTime/api/epochs/","page":"Epochs","title":"Epochs","text":"AstroTime.AstroDates.DateTime\nAstroTime.AstroDates.Date\nAstroTime.AstroDates.Time","category":"page"},{"location":"modules/AstroTime/api/epochs/#AstroTime.AstroDates.DateTime","page":"Epochs","title":"AstroTime.AstroDates.DateTime","text":"DateTime(ep::Epoch)\n\nConvert the epoch ep to an AstroDates.DateTime.\n\n\n\n\n\n","category":"type"},{"location":"modules/AstroTime/api/epochs/#AstroTime.AstroDates.Date","page":"Epochs","title":"AstroTime.AstroDates.Date","text":"Date(ep::Epoch)\n\nGet the Date of the epoch ep.\n\n\n\n\n\n","category":"type"},{"location":"modules/AstroTime/api/epochs/#AstroTime.AstroDates.Time","page":"Epochs","title":"AstroTime.AstroDates.Time","text":"Time(ep::Epoch)\n\nGet the Time of the epoch ep.\n\n\n\n\n\n","category":"type"},{"location":"highlevels/stats/#Statistics-Overview","page":"Statistics Overview","title":"Statistics Overview","text":"","category":"section"},{"location":"modules/SkyCoords/#SkyCoords.jl","page":"Home","title":"SkyCoords.jl","text":"","category":"section"},{"location":"modules/SkyCoords/","page":"Home","title":"Home","text":"(Image: GitHub) (Image: Build Status) (Image: PkgEval) (Image: Coverage)","category":"page"},{"location":"modules/SkyCoords/","page":"Home","title":"Home","text":"SkyCoords.jl provides a type system for astronomical coordinate systems with appropriate conversions between them.","category":"page"},{"location":"modules/SkyCoords/#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"modules/SkyCoords/","page":"Home","title":"Home","text":"From the Julia REPL","category":"page"},{"location":"modules/SkyCoords/","page":"Home","title":"Home","text":"(v1.6) pkg> add SkyCoords\n\njulia> using SkyCoords","category":"page"},{"location":"modules/SkyCoords/","page":"Home","title":"Home","text":"DocTestSetup = :(using SkyCoords)","category":"page"},{"location":"modules/SkyCoords/#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"modules/SkyCoords/","page":"Home","title":"Home","text":"There are currently three supported coordinate systems. The following immutable types are used to represent coordinates in each system:","category":"page"},{"location":"modules/SkyCoords/","page":"Home","title":"Home","text":"ICRSCoords: ICRS coordinates system\nGalCoords: Galactic coordinates system\nFK5Coords: FK5 coordinates system (with arbitrary equinox)\nEclipticCoords: Ecliptic coordinates system","category":"page"},{"location":"modules/SkyCoords/","page":"Home","title":"Home","text":"Each type holds a longitude and latitude, and each is a subtype of AbstractSkyCoords.","category":"page"},{"location":"modules/SkyCoords/","page":"Home","title":"Home","text":"julia> c1 = ICRSCoords(0.0, 0.0)  # inputs are ra, dec in radians\nICRSCoords{Float64}(0.0, 0.0)\n\njulia> c1.ra # access ra, dec individually\n0.0\n\njulia> c2 = convert(GalCoords, c1) # convert to a different system\nGalCoords{Float64}(1.6814027872278692, -1.0504884034813007)\n\njulia> c2.l # Note that galactic coordinate fields are l, b\n1.6814027872278692\n\njulia> c1 |> FK5Coords{2000} # Can use piping syntax for conversion\nFK5Coords{2000, Float64}(1.1102233723050067e-7, 4.411803426976326e-8)","category":"page"},{"location":"modules/SkyCoords/#Units","page":"Home","title":"Units","text":"","category":"section"},{"location":"modules/SkyCoords/","page":"Home","title":"Home","text":"There is built-in support for units via Unitful.jl","category":"page"},{"location":"modules/SkyCoords/","page":"Home","title":"Home","text":"julia> using Unitful\n\njulia> c = ICRSCoords(0.11255u\"°\", 0.00091u\"rad\")\nICRSCoords{Float64}(0.0019643680731196178, 0.00091)\n\njulia> c2 = FK5Coords{2000}(0.1u\"rad\", 0.5)\nFK5Coords{2000, Float64}(0.1, 0.5)\n\njulia> SkyCoords.lat(u\"μrad\", c)\n910.0 μrad","category":"page"},{"location":"modules/SkyCoords/#Parsing-from-strings","page":"Home","title":"Parsing from strings","text":"","category":"section"},{"location":"modules/SkyCoords/","page":"Home","title":"Home","text":"The AstroAngles.jl package provides convenient string parsing utilities","category":"page"},{"location":"modules/SkyCoords/","page":"Home","title":"Home","text":"julia> using AstroAngles\n\njulia> c3 = ICRSCoords(hms\"05:34:31.94\", dms\"+22:00:52.2\")\nICRSCoords{Float64}(1.4596726677614607, 0.3842255081802917)","category":"page"},{"location":"modules/SkyCoords/","page":"Home","title":"Home","text":"for example, to load coordinates from a target list","category":"page"},{"location":"modules/SkyCoords/","page":"Home","title":"Home","text":"julia> using CSV, DataFrames\n\njulia> table = CSV.File(\"target_list.csv\") |> DataFrame;\n\njulia> [table.ra table.dec]\n203×2 Matrix{String}:\n \"00 05 01.42\"  \"40 03 35.82\"\n \"00 05 07.52\"  \"73 13 11.34\"\n \"00 36 01.40\"  \"-11 12 13.00\"\n[...]\n\njulia> coords = @. ICRSCoords(hms2rad(table.ra), dms2rad(table.dec))\n203-element Vector{ICRSCoords{Float64}}:\n ICRSCoords{Float64}(0.021919880964005448, 0.6991780256843024)\n ICRSCoords{Float64}(0.022363485482220672, 1.277926878539953)\n ICRSCoords{Float64}(0.15718144355252264, -0.19553990200190915)\n[...]","category":"page"},{"location":"modules/SkyCoords/#Angular-Separation-between-Coordinates","page":"Home","title":"Angular Separation between Coordinates","text":"","category":"section"},{"location":"modules/SkyCoords/","page":"Home","title":"Home","text":"The separation function allows you to compute the angular (great-circle) distance between two coordinates, in radians, using the Vincenty formula.  The coordinates can be also given in different systems.  For example, according to SIMBAD the FK5Coords{2000} coordinates of Mizar are","category":"page"},{"location":"modules/SkyCoords/","page":"Home","title":"Home","text":"julia> mizar = FK5Coords{2000}(3.507787, 0.958628)\nFK5Coords{2000, Float64}(3.507787, 0.958628)","category":"page"},{"location":"modules/SkyCoords/","page":"Home","title":"Home","text":"while the GalCoords coordinates of Alcor are","category":"page"},{"location":"modules/SkyCoords/","page":"Home","title":"Home","text":"julia> alcor = GalCoords(1.968189, 1.072829)\nGalCoords{Float64}(1.968189, 1.072829)","category":"page"},{"location":"modules/SkyCoords/","page":"Home","title":"Home","text":"Their angular separation is given by","category":"page"},{"location":"modules/SkyCoords/","page":"Home","title":"Home","text":"julia> separation(mizar, alcor) # Radians\n0.003435309169452965\n\njulia> rad2deg(separation(mizar, alcor)) * 60 # Arcminutes\n11.809723003934822","category":"page"},{"location":"modules/SkyCoords/","page":"Home","title":"Home","text":"with an angle","category":"page"},{"location":"modules/SkyCoords/","page":"Home","title":"Home","text":"julia> position_angle(mizar, alcor) # radians\n1.2446024012417884\n\njulia> position_angle(mizar, alcor) |> rad2deg # degrees\n71.31046476300233\n","category":"page"},{"location":"modules/SkyCoords/#Accuracy","page":"Home","title":"Accuracy","text":"","category":"section"},{"location":"modules/SkyCoords/","page":"Home","title":"Home","text":"All the supported conversions have been compared to the results of astropy.coordinates (to better than 0.0001 arcsec agreement for Float64). In turn, astropy.coordinates has been tested against many other tools.","category":"page"},{"location":"modules/SkyCoords/#Performance","page":"Home","title":"Performance","text":"","category":"section"},{"location":"modules/SkyCoords/","page":"Home","title":"Home","text":"For small and moderate numbers of coordinates, conversions are much faster than astropy.coordinates in Python. The following plot shows the performance for converting ICRS coordinates to various other systems (Galactic, FK5J2000 and FK5J1975), using astropy.coordinates (py_* labels) and SkyCoords.jl (jl_* labels). The x axis denotes the number of coordinates being simultaneously converted, with 1 corresponding to scalar coordinates.","category":"page"},{"location":"modules/SkyCoords/","page":"Home","title":"Home","text":"(Image: times)","category":"page"},{"location":"modules/SkyCoords/","page":"Home","title":"Home","text":"Specs \nCPU Intel core i5-8259U @ 2.3GHz (4 cores)\nRAM 16GB\nJulia Version 1.2\nPython Version 3.7\nAstropy Version 3.1.2","category":"page"},{"location":"modules/SkyCoords/","page":"Home","title":"Home","text":"For scalar coordinates, SkyCoords.jl is up to 100,000 times faster. For very large vectors of one million coordinates or more, SkyCoords.jl is 2-4 times faster.  The source code for these benchmarks can be found in bench/.","category":"page"},{"location":"modules/SkyCoords/#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"modules/SkyCoords/","page":"Home","title":"Home","text":"If you would like to contribute to SkyCoords please head over to the GitHub page and file an issue or open a pull request!","category":"page"},{"location":"modules/LACosmic/","page":"Home","title":"Home","text":"CurrentModule = LACosmic","category":"page"},{"location":"modules/LACosmic/#LACosmic.jl","page":"Home","title":"LACosmic.jl","text":"","category":"section"},{"location":"modules/LACosmic/","page":"Home","title":"Home","text":"(Image: Code) (Image: Build Status) (Image: PkgEval) (Image: Coverage) (Image: License)","category":"page"},{"location":"modules/LACosmic/","page":"Home","title":"Home","text":"Laplacian cosmic-ray detection (L.A.Cosmic) in pure Julia.","category":"page"},{"location":"modules/LACosmic/#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"modules/LACosmic/","page":"Home","title":"Home","text":"To use the LACosmic library, first install it using Pkg","category":"page"},{"location":"modules/LACosmic/","page":"Home","title":"Home","text":"julia> ]add LACosmic","category":"page"},{"location":"modules/LACosmic/#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"modules/LACosmic/","page":"Home","title":"Home","text":"To import the library","category":"page"},{"location":"modules/LACosmic/","page":"Home","title":"Home","text":"using LACosmic","category":"page"},{"location":"modules/LACosmic/","page":"Home","title":"Home","text":"there is one exported function: lacosmic","category":"page"},{"location":"modules/LACosmic/","page":"Home","title":"Home","text":"clean_image, mask = lacosmic(image)","category":"page"},{"location":"modules/LACosmic/#Performance","page":"Home","title":"Performance","text":"","category":"section"},{"location":"modules/LACosmic/","page":"Home","title":"Home","text":"This code has been benchmarked against the Cython implementation in Astro-SCRAPPY. This benchmark simply computes the time it takes to run the LACosmic algorithm with different image sizes. The size is the length of one dimension of the image, so the expected scaling should be propto N^2. The code can be found in bench/benchmark.jl. Here is the information for my system-","category":"page"},{"location":"modules/LACosmic/","page":"Home","title":"Home","text":"Julia Version 1.6.0\nCommit f9720dc2eb* (2021-03-24 12:55 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin20.3.0)\n  CPU: Intel(R) Core(TM) i5-8259U CPU @ 2.30GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, skylake)\nEnvironment:\n  OMP_NUM_THREADS = 1\n  JULIA_NUM_THREADS = 1","category":"page"},{"location":"modules/LACosmic/","page":"Home","title":"Home","text":"using CSV, DataFrames, Plots, LaTeXStrings # hide\nusing LACosmic # hide\nbenchdir = joinpath(dirname(pathof(LACosmic)), \"..\", \"bench\") # hide\nresults = DataFrame(CSV.File(joinpath(benchdir, \"benchmark_results.csv\"))) # hide\n\nplot(results.N_data, [results.t_python results.t_julia]; # hide\n    label=[\"Astro-SCRAPPY\" \"LACosmic.jl\"], leg=:topleft, # hide\n    xlabel=\"image size\", ylabel=\"time (s)\", # hide\n    yscale=:log10, shape=:o) # hide\npoints = range(extrema(results.N_data)..., length=51) # hide\nfactor = results.t_julia[begin] / (results.N_data[begin])^2 # hide\nplot!(points, t -> t^2 * factor, ls=:dash, c=:black, alpha=0.3, lab=L\"\\propto N^2\") # hide\n","category":"page"},{"location":"modules/LACosmic/#Contributing-and-Support","page":"Home","title":"Contributing and Support","text":"","category":"section"},{"location":"modules/LACosmic/","page":"Home","title":"Home","text":"If you would like to contribute, feel free to open a pull request. If you want to discuss something before contributing, head over to discussions and join or open a new topic. If you're having problems with something, please open an issue.","category":"page"},{"location":"modules/AstroImages/#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"modules/AstroImages/","page":"Home","title":"Home","text":"(Image: GitHub) (Image: Build Status)","category":"page"},{"location":"modules/AstroImages/","page":"Home","title":"Home","text":"AstroImage.jl is a Julia package for loading, manipulating, and visualizing astronomical images.","category":"page"},{"location":"modules/AstroImages/","page":"Home","title":"Home","text":"It supports FITS files (FITSIO.jl), world coordinates  (WCS.jl), rendering images (Images.jl), and plot recipes (Plots.jl).","category":"page"},{"location":"modules/AstroImages/#Videos","page":"Home","title":"Videos","text":"","category":"section"},{"location":"modules/AstroImages/","page":"Home","title":"Home","text":"AstroImages.jl was presented at JuliaCon in 2022. You can view the talk here.","category":"page"},{"location":"modules/BoxLeastSquares/","page":"Home","title":"Home","text":"CurrentModule = BoxLeastSquares","category":"page"},{"location":"modules/BoxLeastSquares/#BoxLeastSquares.jl","page":"Home","title":"BoxLeastSquares.jl","text":"","category":"section"},{"location":"modules/BoxLeastSquares/","page":"Home","title":"Home","text":"(Image: GitHub) (Image: Build Status) (Image: PkgEval) (Image: Coverage) (Image: License)","category":"page"},{"location":"modules/BoxLeastSquares/#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"modules/BoxLeastSquares/","page":"Home","title":"Home","text":"To install use Pkg. From the REPL, press ] to enter Pkg-mode","category":"page"},{"location":"modules/BoxLeastSquares/","page":"Home","title":"Home","text":"pkg> add BoxLeastSquares","category":"page"},{"location":"modules/BoxLeastSquares/","page":"Home","title":"Home","text":"If you want to use the most up-to-date version of the code, check it out from main","category":"page"},{"location":"modules/BoxLeastSquares/","page":"Home","title":"Home","text":"pkg> add BoxLeastSquares#main","category":"page"},{"location":"modules/BoxLeastSquares/#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"modules/BoxLeastSquares/","page":"Home","title":"Home","text":"First, import the package","category":"page"},{"location":"modules/BoxLeastSquares/","page":"Home","title":"Home","text":"julia> using BoxLeastSquares","category":"page"},{"location":"modules/BoxLeastSquares/","page":"Home","title":"Home","text":"you can optionally alias the package name, too","category":"page"},{"location":"modules/BoxLeastSquares/","page":"Home","title":"Home","text":"julia> import BoxLeastSquares as BLS","category":"page"},{"location":"modules/BoxLeastSquares/","page":"Home","title":"Home","text":"now, load some data. If you don't have an estimate of the y error it will default to 1.","category":"page"},{"location":"modules/BoxLeastSquares/","page":"Home","title":"Home","text":"DocTestSetup = quote\n    using StableRNGs\n    rng = StableRNG(3351)\n    t = 10 .* rand(rng, 1000);\n    yerr = 5e-3 .* (rand(rng, 1000) .+ 1)\n    P = 2; t0 = 0.5; dur = 0.16; depth = 0.2;\n    mask = @. abs((t - t0 + 0.5P) % P - 0.5P) < 0.5dur;\n    y = @. ifelse(mask, 1 - depth, 1);\n    y .+= yerr .* randn(rng, 1000)\n    load_data() = t, y, yerr\nend","category":"page"},{"location":"modules/BoxLeastSquares/","page":"Home","title":"Home","text":"julia> t, y, yerr = load_data(); # load data somehow","category":"page"},{"location":"modules/BoxLeastSquares/","page":"Home","title":"Home","text":"The primary interface is through the BLS method","category":"page"},{"location":"modules/BoxLeastSquares/","page":"Home","title":"Home","text":"julia> result = BLS(t, y, yerr; duration=0.16)\nBLSPeriodogram\n==============\ninput dim: 1000\noutput dim: 1820\nperiod range: 0.32 - 5.014724142709022\nduration range: 0.16 - 0.16\nobjective: likelihood\n\nparameters\n----------\nindex: 1633\nperiod: 1.99930396919953\nduration: 0.16\nt0: 0.5001330656464655\ndepth: 0.19594118110109113 ± 0.0008688097746093883\nsnr: 225.52828804117118\nlog-likelihood: 27396.365214805144","category":"page"},{"location":"modules/BoxLeastSquares/","page":"Home","title":"Home","text":"to extract the parameters in a convenient named tuple use BoxLeastSquares.params","category":"page"},{"location":"modules/BoxLeastSquares/","page":"Home","title":"Home","text":"julia> BoxLeastSquares.params(result)\n(index = 1633, power = 27396.365214805144, period = 1.99930396919953, duration = 0.16, t0 = 0.5001330656464655, depth = 0.19594118110109113, depth_err = 0.0008688097746093883, snr = 225.52828804117118, loglike = 27396.365214805144)","category":"page"},{"location":"modules/BoxLeastSquares/","page":"Home","title":"Home","text":"The period grid was automatically determined using autoperiod, but you can supply your own, too:","category":"page"},{"location":"modules/BoxLeastSquares/","page":"Home","title":"Home","text":"julia> periods = exp.(range(log(2) - 0.1, log(2) + 0.1, length=1000));\n\njulia> result_fine = BLS(t, y, yerr; duration=0.12:0.01:0.20, periods=periods)\nBLSPeriodogram\n==============\ninput dim: 1000\noutput dim: 1000\nperiod range: 1.809674836071919 - 2.210341836151295\nduration range: 0.12 - 0.2\nobjective: likelihood\n\nparameters\n----------\nindex: 503\nperiod: 2.001001251543549\nduration: 0.168\nt0: 0.4961330656464656\ndepth: 0.19466955969052016 ± 0.0008627202098527317\nsnr: 225.64622628204188\nlog-likelihood: 27457.6383039924","category":"page"},{"location":"modules/BoxLeastSquares/#Unitful.jl","page":"Home","title":"Unitful.jl","text":"","category":"section"},{"location":"modules/BoxLeastSquares/","page":"Home","title":"Home","text":"BoxLeastSquares.jl is fully compatible with Unitful.jl (although it is not a dependency of the library). For example","category":"page"},{"location":"modules/BoxLeastSquares/","page":"Home","title":"Home","text":"julia> using Unitful\n\njulia> tu = t * u\"d\";\n\njulia> results_units = BLS(tu, y, yerr; duration=(2:0.1:4)u\"hr\")\nBLSPeriodogram\n==============\ninput dim: 1000\noutput dim: 3343\nperiod range: 0.3333333333333333 d - 4.988348864592586 d\nduration range: 2.0 hr - 4.0 hr\nobjective: likelihood\n\nparameters\n----------\nindex: 2986\nperiod: 2.0019235780121827 d\nduration: 3.8000000000000003 hr\nt0: 0.4916330656464656 d\ndepth: 0.19445716575012517 ± 0.0008692454825826517\nsnr: 223.70799693127577\nlog-likelihood: 26953.643422397385","category":"page"},{"location":"modules/BoxLeastSquares/#Plotting","page":"Home","title":"Plotting","text":"","category":"section"},{"location":"modules/BoxLeastSquares/","page":"Home","title":"Home","text":"BoxLeastSquares.BLSPeriodogram has plotting shorthands built right in- by default it will plot the period grid and the computed power","category":"page"},{"location":"modules/BoxLeastSquares/","page":"Home","title":"Home","text":"using BoxLeastSquares, Unitful, StableRNGs # hide\nrng = StableRNG(3351) # hide\nt = 10 .* rand(rng, 1000)u\"d\" # hide\nyerr = 5e-3 .* (rand(rng, 1000) .+ 1) # hide\nP = 2u\"d\"; t0 = 0.5u\"d\"; dur = 0.16u\"d\"; depth = 0.2; # hide\nmask = @. abs((t - t0 + 0.5P) % P - 0.5P) < 0.5dur # hide\ny = @. ifelse(mask, 1.0 - depth, 1.0) # hide\ny .+= yerr .* randn(rng, 1000) # hide\nresults_units = BLS(t, y, yerr; duration=(2:0.1:4)u\"hr\") # hide\nusing Plots, UnitfulRecipes\n\nplot(results_units, label=\"\")","category":"page"},{"location":"modules/BoxLeastSquares/","page":"Home","title":"Home","text":"now let's look at how the transit model compares to the data","category":"page"},{"location":"modules/BoxLeastSquares/","page":"Home","title":"Home","text":"pars = BoxLeastSquares.params(results_units)\nwrap = 0.5 * pars.period\nphases = @. (mod(t - pars.t0 + wrap, pars.period) - wrap) / pars.period\ninds = sortperm(phases)\nmodel = BoxLeastSquares.model(results_units)\n\nscatter(phases[inds], y[inds], yerr=yerr[inds],\n    label=\"data\", xlabel=\"phase\", xlim=(-0.2, 0.2), leg=:bottomright)\nplot!(phases[inds], model[inds], lw=3, label=\"BLS model\")","category":"page"},{"location":"modules/BoxLeastSquares/#Performance","page":"Home","title":"Performance","text":"","category":"section"},{"location":"modules/BoxLeastSquares/","page":"Home","title":"Home","text":"This code has been benchmarked against the C implementation in astropy.timeseries.bls. The C version uses OpenMP to multi-thread some parts of the core BLS algorithm, but BoxLeastSquares.jl has no threading support currently. For a fair comparison, we set OMP_NUM_THREADS to 1 for the following tests.","category":"page"},{"location":"modules/BoxLeastSquares/","page":"Home","title":"Home","text":"This first benchmark is simply the time it takes to evaluate the BLS periodogram. Periods are pre-computed using autoperiod. We simulate different sizes of data sets (x-axis) as well as different sizes of period grids (shape). This benchmark does not use units. The code can be found in bench/benchmark.jl. Here is the information for my system-","category":"page"},{"location":"modules/BoxLeastSquares/","page":"Home","title":"Home","text":"Julia Version 1.6.0\nCommit f9720dc2eb* (2021-03-24 12:55 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin20.3.0)\n  CPU: Intel(R) Core(TM) i5-8259U CPU @ 2.30GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, skylake)\nEnvironment:\n  OMP_NUM_THREADS = 1\n  JULIA_NUM_THREADS = 1","category":"page"},{"location":"modules/BoxLeastSquares/","page":"Home","title":"Home","text":"using CSV, DataFrames, Plots # hide\nusing BoxLeastSquares # hide\nbenchdir = joinpath(dirname(pathof(BoxLeastSquares)), \"..\", \"bench\") # hide\nresults = DataFrame(CSV.File(joinpath(benchdir, \"benchmark_results.csv\"))) # hide\ngroups = groupby(results, :N_per) # hide\n\nplot(xlabel=\"# data points\", ylabel=\"time (s)\") # hide\n\n# plot main curves # hide\nshapes = [:o :dtriangle :diamond] # hide\nfor (g, shape) in zip(groups, shapes) # hide\n    plot!(g.N_data, [g.t_astropy g.t_bls]; c=[1 2], shape, label=\"\") # hide\nend # hide\nplot!(xscale=:log10, yscale=:log10) # hide\n# create faux-legends # hide\nbbox_ = bbox(0, 0, 1, 1, :bottom, :left) # hide\nplot!([1 2]; c=[1 2], label=[\"astropy\" \"BoxLeastSquares.jl\"], inset=(1, bbox_), # hide\n    bg=:transparent, border=:none, axes=false, sp=2, leg=:topleft, bgcolorlegend=:white) # hide\nnpers = hcat((string(k.N_per) for k in keys(groups))...) # hide\nscatter!([0 0 0]; shape=shapes, c=:black, alpha=0.4, label=npers, inset=(1, bbox_), # hide\n    bg=:transparent, border=:none, axes=false, sp=3, ylim=(1, 2), # hide\n    legtitle=\"# periods\", leg=:bottomright, legendtitlefontsize=9, bgcolorlegend=:white) # hide","category":"page"},{"location":"modules/BoxLeastSquares/#Contributing-and-Support","page":"Home","title":"Contributing and Support","text":"","category":"section"},{"location":"modules/BoxLeastSquares/","page":"Home","title":"Home","text":"If you would like to contribute, feel free to open a pull request. If you want to discuss something before contributing, head over to discussions and join or open a new topic. If you're having problems with something, open an issue.","category":"page"},{"location":"modules/Photometry/apertures/examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"modules/Photometry/apertures/examples/#Plotting","page":"Examples","title":"Plotting","text":"","category":"section"},{"location":"modules/Photometry/apertures/examples/","page":"Examples","title":"Examples","text":"We have recipes for all our aperture types, so you can easily create overlays on your images.","category":"page"},{"location":"modules/Photometry/apertures/examples/","page":"Examples","title":"Examples","text":"using Photometry\nusing Plots\n\nplot(CircularAperture(2, 3, 4), c=1, xlims=(-1, 12), ylims=(0, 9))\nplot!(CircularAnnulus(5, 5, 2.1, 3), c=2)\nplot!(EllipticalAperture(0, 0, 10, 1, 32), c=3)\nplot!(EllipticalAnnulus(5, 5, 4, 5, 2, -32), c=4)\nplot!(RectangularAperture(0, 0, 4, 4, 4), c=5)\nplot!(RectangularAnnulus(5, 1, 3, 4, 4, 4), c=6)","category":"page"},{"location":"modules/Photometry/apertures/examples/#Simple-Stars","page":"Examples","title":"Simple Stars","text":"","category":"section"},{"location":"modules/Photometry/apertures/examples/","page":"Examples","title":"Examples","text":"Here is an example where we will find aperture fluxes for stars from M67. The dataset is provided as part of the astropy/photutils-datasets repository.","category":"page"},{"location":"modules/Photometry/apertures/examples/","page":"Examples","title":"Examples","text":"Let's start by downloading and showing our image","category":"page"},{"location":"modules/Photometry/apertures/examples/","page":"Examples","title":"Examples","text":"using Photometry\nusing Plots\nusing FITSIO\n\n# Load data in\nhdu = FITS(download(\"https://rawcdn.githack.com/astropy/photutils-datasets/8c97b4fa3a6c9e6ea072faeed2d49a20585658ba/data/M6707HH.fits\"))\nchunk = read(hdu[1], 81:155, 71:150)\n\n# Plot\nfunction imshow(image; kwargs...)\n    xs, ys = axes(image)\n    data = transpose(image)\n    heatmap(xs, ys, data; aspect_ratio=1, xlim=extrema(xs), ylim=extrema(ys), kwargs...)\nend\n\nimshow(chunk)","category":"page"},{"location":"modules/Photometry/apertures/examples/","page":"Examples","title":"Examples","text":"Now let's add some apertures!","category":"page"},{"location":"modules/Photometry/apertures/examples/","page":"Examples","title":"Examples","text":"positions = [\n    [47.5 , 67.5],\n    [29.5 , 62.5],\n    [23.5 , 48.5],\n    [17.5 , 29.5],\n    [13.25, 10.5],\n    [65.5 , 14.0]\n]\n\nradii = [3, 3, 2.7, 2, 2.7, 3]\n\naps = CircularAperture.(positions, radii)","category":"page"},{"location":"modules/Photometry/apertures/examples/","page":"Examples","title":"Examples","text":"now let's plot them up","category":"page"},{"location":"modules/Photometry/apertures/examples/","page":"Examples","title":"Examples","text":"imshow(chunk)\nplot!(aps, c=:white)","category":"page"},{"location":"modules/Photometry/apertures/examples/","page":"Examples","title":"Examples","text":"and finally let's get our output table for the photometry","category":"page"},{"location":"modules/Photometry/apertures/examples/","page":"Examples","title":"Examples","text":"table = photometry(aps, chunk)","category":"page"},{"location":"modules/Photometry/apertures/examples/#Stars-with-Spatial-Background-Subtraction","page":"Examples","title":"Stars with Spatial Background Subtraction","text":"","category":"section"},{"location":"modules/Photometry/apertures/examples/","page":"Examples","title":"Examples","text":"This example will be the same as Simple Stars but will add background estimation using the tools in Background Estimation","category":"page"},{"location":"modules/Photometry/apertures/examples/","page":"Examples","title":"Examples","text":"clipped = sigma_clip(chunk, 1, fill=NaN)\n# Estimate 2D spatial background using boxes of size (5, 5)\nbkg, bkg_rms = estimate_background(clipped, 5)\n\nplot(\n    imshow(chunk, title=\"Original\"),\n    imshow(clipped, title=\"Sigma-Clipped\"),\n    imshow(bkg, title=\"Background\"),\n    imshow(bkg_rms, title=\"Background RMS\");\n    layout=(2, 2), size=(600, 600), ticks=false\n)","category":"page"},{"location":"modules/Photometry/apertures/examples/","page":"Examples","title":"Examples","text":"Now, using the same apertures, let's find the output using the background-subtracted image","category":"page"},{"location":"modules/Photometry/apertures/examples/","page":"Examples","title":"Examples","text":"plot(\n    imshow(chunk, title=\"Original\"),\n    imshow(chunk .- bkg, title=\"Subtracted\");\n    layout=2, size=(600, 260), ticks=false, colorbar=false\n)\nplot!(aps, c=:white, subplot=1)\nplot!(aps, c=:white, subplot=2)","category":"page"},{"location":"modules/Photometry/apertures/examples/","page":"Examples","title":"Examples","text":"table = photometry(aps, chunk .- bkg, bkg_rms)","category":"page"},{"location":"modules/EarthOrientation/api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"modules/EarthOrientation/api/","page":"API","title":"API","text":"Modules = [EarthOrientation]\nPrivate = false","category":"page"},{"location":"modules/EarthOrientation/api/#EarthOrientation.EOParams-Tuple{String, String}","page":"API","title":"EarthOrientation.EOParams","text":"EOParams(iau1980file::String, iau2000file::String)\n\nParse IERS data files into a EOParams object. iau1980file and iau2000file are the paths to a 'finals.all' and a 'finals2000A.all' CSV file, respectively.\n\n\n\n\n\n","category":"method"},{"location":"modules/EarthOrientation/api/#EarthOrientation.getdx-Tuple{Any, Any}","page":"API","title":"EarthOrientation.getdx","text":"getdx(date; outside_range=:warn)\n\nGet the celestial pole x-coordinate correction for a certain date in milliarcseconds.\n\ndate can either be a DateTime object or a Julian date represented by a number. The outside_range argument determines what to do if no data is available for date:\n\n:warn: The last valid value is returned and a warning will be displayed.\n:nothing: The last valid value is returned.\n:error: An OutOfRangeError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"modules/EarthOrientation/api/#EarthOrientation.getdx_err-Tuple{Any, Any}","page":"API","title":"EarthOrientation.getdx_err","text":"getdx_err(date; outside_range=:warn)\n\nGet the error in celestial pole x-coordinate correction for a certain date in milliarcseconds.\n\ndate can either be a DateTime object or a Julian date represented by a number. The outside_range argument determines what to do if no data is available for date:\n\n:warn: The last valid value is returned and a warning will be displayed.\n:nothing: The last valid value is returned.\n:error: An OutOfRangeError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"modules/EarthOrientation/api/#EarthOrientation.getdy-Tuple{Any, Any}","page":"API","title":"EarthOrientation.getdy","text":"getdy(date; outside_range=:warn)\n\nGet the celestial pole y-coordinate correction for a certain date in milliarcseconds.\n\ndate can either be a DateTime object or a Julian date represented by a number. The outside_range argument determines what to do if no data is available for date:\n\n:warn: The last valid value is returned and a warning will be displayed.\n:nothing: The last valid value is returned.\n:error: An OutOfRangeError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"modules/EarthOrientation/api/#EarthOrientation.getdy_err-Tuple{Any, Any}","page":"API","title":"EarthOrientation.getdy_err","text":"getdy_err(date; outside_range=:warn)\n\nGet the error in celestial pole y-coordinate correction for a certain date in milliarcseconds.\n\ndate can either be a DateTime object or a Julian date represented by a number. The outside_range argument determines what to do if no data is available for date:\n\n:warn: The last valid value is returned and a warning will be displayed.\n:nothing: The last valid value is returned.\n:error: An OutOfRangeError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"modules/EarthOrientation/api/#EarthOrientation.getdψ-Tuple{Any, Any}","page":"API","title":"EarthOrientation.getdψ","text":"getdψ(date; outside_range=:warn)\n\nGet the ecliptic nutation correction for a certain date in milliarcseconds.\n\ndate can either be a DateTime object or a Julian date represented by a number. The outside_range argument determines what to do if no data is available for date:\n\n:warn: The last valid value is returned and a warning will be displayed.\n:nothing: The last valid value is returned.\n:error: An OutOfRangeError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"modules/EarthOrientation/api/#EarthOrientation.getdψ_err-Tuple{Any, Any}","page":"API","title":"EarthOrientation.getdψ_err","text":"getdψ_err(date; outside_range=:warn)\n\nGet the error in the ecliptic nutation correction for a certain date in milliarcseconds.\n\ndate can either be a DateTime object or a Julian date represented by a number. The outside_range argument determines what to do if no data is available for date:\n\n:warn: The last valid value is returned and a warning will be displayed.\n:nothing: The last valid value is returned.\n:error: An OutOfRangeError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"modules/EarthOrientation/api/#EarthOrientation.getdϵ-Tuple{Any, Any}","page":"API","title":"EarthOrientation.getdϵ","text":"getdϵ(date; outside_range=:warn)\n\nGet the ecliptic obliquity correction for a certain date in milliarcseconds.\n\ndate can either be a DateTime object or a Julian date represented by a number. The outside_range argument determines what to do if no data is available for date:\n\n:warn: The last valid value is returned and a warning will be displayed.\n:nothing: The last valid value is returned.\n:error: An OutOfRangeError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"modules/EarthOrientation/api/#EarthOrientation.getdϵ_err-Tuple{Any, Any}","page":"API","title":"EarthOrientation.getdϵ_err","text":"getdϵ_err(date; outside_range=:warn)\n\nGet the error in the ecliptic obliquity correction for a certain date in milliarcseconds.\n\ndate can either be a DateTime object or a Julian date represented by a number. The outside_range argument determines what to do if no data is available for date:\n\n:warn: The last valid value is returned and a warning will be displayed.\n:nothing: The last valid value is returned.\n:error: An OutOfRangeError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"modules/EarthOrientation/api/#EarthOrientation.getlod-Tuple{Any, Any}","page":"API","title":"EarthOrientation.getlod","text":"getlod(date; outside_range=:warn)\n\nGet the excess length of day for a certain date in milliseconds.\n\ndate can either be a DateTime object or a Julian date represented by a number. The outside_range argument determines what to do if no data is available for date:\n\n:warn: The last valid value is returned and a warning will be displayed.\n:nothing: The last valid value is returned.\n:error: An OutOfRangeError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"modules/EarthOrientation/api/#EarthOrientation.getlod_err-Tuple{Any, Any}","page":"API","title":"EarthOrientation.getlod_err","text":"getlod_err(date; outside_range=:warn)\n\nGet the error in the excess length of day for a certain date in milliseconds.\n\ndate can either be a DateTime object or a Julian date represented by a number. The outside_range argument determines what to do if no data is available for date:\n\n:warn: The last valid value is returned and a warning will be displayed.\n:nothing: The last valid value is returned.\n:error: An OutOfRangeError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"modules/EarthOrientation/api/#EarthOrientation.getxp-Tuple{Any, Any}","page":"API","title":"EarthOrientation.getxp","text":"getxp(date; outside_range=:warn)\n\nGet the x-coordinate of Earth's north pole w.r.t. the CIO for a certain date in arcseconds.\n\ndate can either be a DateTime object or a Julian date represented by a number. The outside_range argument determines what to do if no data is available for date:\n\n:warn: The last valid value is returned and a warning will be displayed.\n:nothing: The last valid value is returned.\n:error: An OutOfRangeError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"modules/EarthOrientation/api/#EarthOrientation.getxp_err-Tuple{Any, Any}","page":"API","title":"EarthOrientation.getxp_err","text":"getxp_err(date; outside_range=:warn)\n\nGet the error for the x-coordinate of Earth's north pole w.r.t. the CIO for a certain date in arcseconds.\n\ndate can either be a DateTime object or a Julian date represented by a number. The outside_range argument determines what to do if no data is available for date:\n\n:warn: The last valid value is returned and a warning will be displayed.\n:nothing: The last valid value is returned.\n:error: An OutOfRangeError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"modules/EarthOrientation/api/#EarthOrientation.getyp-Tuple{Any, Any}","page":"API","title":"EarthOrientation.getyp","text":"getyp(date; outside_range=:warn)\n\nGet the y-coordinate of Earth's north pole w.r.t. the CIO for a certain date in arcseconds.\n\ndate can either be a DateTime object or a Julian date represented by a number. The outside_range argument determines what to do if no data is available for date:\n\n:warn: The last valid value is returned and a warning will be displayed.\n:nothing: The last valid value is returned.\n:error: An OutOfRangeError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"modules/EarthOrientation/api/#EarthOrientation.getyp_err-Tuple{Any, Any}","page":"API","title":"EarthOrientation.getyp_err","text":"getyp_err(date; outside_range=:warn)\n\nGet the error for the y-coordinate of Earth's north pole w.r.t. the CIO for a certain date in arcseconds.\n\ndate can either be a DateTime object or a Julian date represented by a number. The outside_range argument determines what to do if no data is available for date:\n\n:warn: The last valid value is returned and a warning will be displayed.\n:nothing: The last valid value is returned.\n:error: An OutOfRangeError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"modules/EarthOrientation/api/#EarthOrientation.getΔUT1-Tuple{Any, Any}","page":"API","title":"EarthOrientation.getΔUT1","text":"getΔUT1(date; outside_range=:warn)\n\nGet the difference between UTC and UT1 for a certain date in seconds.\n\ndate can either be a DateTime object or a Julian date represented by a number. The outside_range argument determines what to do if no data is available for date:\n\n:warn: The last valid value is returned and a warning will be displayed.\n:nothing: The last valid value is returned.\n:error: An OutOfRangeError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"modules/EarthOrientation/api/#EarthOrientation.getΔUT1_TAI-Tuple{Any, Any}","page":"API","title":"EarthOrientation.getΔUT1_TAI","text":"getΔUT1_TAI(date; outside_range=:warn)\n\nGet the difference between TAI and UT1 for a certain date in seconds.\n\ndate can either be a DateTime object or a Julian date represented by a number. The outside_range argument determines what to do if no data is available for date:\n\n:warn: The last valid value is returned and a warning will be displayed.\n:nothing: The last valid value is returned.\n:error: An OutOfRangeError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"modules/EarthOrientation/api/#EarthOrientation.getΔUT1_err-Tuple{Any, Any}","page":"API","title":"EarthOrientation.getΔUT1_err","text":"getΔUT1_err(date; outside_range=:warn)\n\nGet the error in the difference between UTC and UT1 for a certain date in seconds.\n\ndate can either be a DateTime object or a Julian date represented by a number. The outside_range argument determines what to do if no data is available for date:\n\n:warn: The last valid value is returned and a warning will be displayed.\n:nothing: The last valid value is returned.\n:error: An OutOfRangeError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"modules/EarthOrientation/api/#EarthOrientation.polarmotion-Tuple{Any, Any}","page":"API","title":"EarthOrientation.polarmotion","text":"polarmotion(date; outside_range=:warn)\n\nGet the coordinates of Earth's north pole w.r.t. the CIO for a certain date in arcseconds.\n\ndate can either be a DateTime object or a Julian date represented by a number. The outside_range argument determines what to do if no data is available for date:\n\n:warn: The last valid value is returned and a warning will be displayed.\n:nothing: The last valid value is returned.\n:error: An OutOfRangeError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"modules/EarthOrientation/api/#EarthOrientation.precession_nutation00-Tuple{Any, Any}","page":"API","title":"EarthOrientation.precession_nutation00","text":"precession_nutation00(date; outside_range=:warn)\n\nGet the celestial pole coordinate corrections for a certain date in milliarcseconds.\n\ndate can either be a DateTime object or a Julian date represented by a number. The outside_range argument determines what to do if no data is available for date:\n\n:warn: The last valid value is returned and a warning will be displayed.\n:nothing: The last valid value is returned.\n:error: An OutOfRangeError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"modules/EarthOrientation/api/#EarthOrientation.precession_nutation80-Tuple{Any, Any}","page":"API","title":"EarthOrientation.precession_nutation80","text":"precession_nutation80(date; outside_range=:warn)\n\nGet the ecliptic corrections for a certain date in milliarcseconds.\n\ndate can either be a DateTime object or a Julian date represented by a number. The outside_range argument determines what to do if no data is available for date:\n\n:warn: The last valid value is returned and a warning will be displayed.\n:nothing: The last valid value is returned.\n:error: An OutOfRangeError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"modules/Photometry/apertures/#Aperture-Photometry","page":"Getting Started","title":"Aperture Photometry","text":"","category":"section"},{"location":"modules/Photometry/apertures/#Introduction","page":"Getting Started","title":"Introduction","text":"","category":"section"},{"location":"modules/Photometry/apertures/","page":"Getting Started","title":"Getting Started","text":"Aperture photometry uses Apertures to cut out and sum values in an image. A very basic mask might be a square of pixels at a certain position. We can model this as a matrix of ones and zeros like","category":"page"},{"location":"modules/Photometry/apertures/","page":"Getting Started","title":"Getting Started","text":"[0 0 0 0 0\n 0 1 1 1 0\n 0 1 1 1 0\n 0 1 1 1 0\n 0 0 0 0 0]","category":"page"},{"location":"modules/Photometry/apertures/","page":"Getting Started","title":"Getting Started","text":"If we have some data like","category":"page"},{"location":"modules/Photometry/apertures/","page":"Getting Started","title":"Getting Started","text":"[7 9 6 0 8\n 8 5 8 7 9\n 5 6 2 2 7\n 9 7 3 4 1\n 7 8 0 9 8]","category":"page"},{"location":"modules/Photometry/apertures/","page":"Getting Started","title":"Getting Started","text":"then the result of our aperture photometry looks like","category":"page"},{"location":"modules/Photometry/apertures/","page":"Getting Started","title":"Getting Started","text":"[0 0 0 0 0     [7 9 6 0 8     [0 0 0 0 0\n 0 1 1 1 0      8 5 8 7 9      0 5 8 7 0\n 0 1 1 1 0  .*  5 6 2 2 7  =   0 6 2 2 0\n 0 1 1 1 0      9 7 3 4 1      0 7 3 4 0\n 0 0 0 0 0]     7 8 0 9 8]     0 0 0 0 0]\n\nsum(result) = 44","category":"page"},{"location":"modules/Photometry/apertures/","page":"Getting Started","title":"Getting Started","text":"This module uses the above principal with common aperture shapes in a fast and precise manner, including exact overlaps between apertures and pixels.","category":"page"},{"location":"modules/Photometry/apertures/","page":"Getting Started","title":"Getting Started","text":"The majority of the lifting is done with the photometry function with common shapes being described in Apertures. It is possible to create a custom aperture by sub-typing the Aperture.AbstractAperture class, although it may be easier to perform PSF photometry instead.","category":"page"},{"location":"modules/Photometry/apertures/#Pixel-Convention","page":"Getting Started","title":"Pixel Convention","text":"","category":"section"},{"location":"modules/Photometry/apertures/","page":"Getting Started","title":"Getting Started","text":"Photometry.jl follows the same convention as FITS, WCS, IRAF, DS9, and SourceExtractor with (1, 1) being the center on the bottom-left pixel. This means the exact bottom-left corner is at (0.5, 0.5). Pixels increase up and to the right until axis_length + 0.5.","category":"page"},{"location":"modules/Photometry/apertures/#API/Reference","page":"Getting Started","title":"API/Reference","text":"","category":"section"},{"location":"modules/Photometry/apertures/","page":"Getting Started","title":"Getting Started","text":"photometry","category":"page"},{"location":"modules/Photometry/apertures/#Photometry.Aperture.photometry","page":"Getting Started","title":"Photometry.Aperture.photometry","text":"photometry(::AbstractAperture, data::AbstractMatrix, [error])\nphotometry(::AbstractVector{<:AbstractAperture}, data::AbstractMatrix, [error])\n\nPerform aperture photometry on data given aperture(s). If error (the pixel-wise standard deviation) is provided, will calculate sum error. If a list of apertures is provided the output will be a TypedTables.Table, otherwise a NamedTuple.\n\ntip: Tip\nThis code is automatically multi-threaded. To take advantage of this please make sure JULIA_NUM_THREADS is set before starting your runtime.\n\n\n\n\n\n","category":"function"},{"location":"modules/Photometry/apertures/#Performance","page":"Getting Started","title":"Performance","text":"","category":"section"},{"location":"modules/Photometry/apertures/","page":"Getting Started","title":"Getting Started","text":"Below are some benchmarks comparing the aperture photometry capabilities of Photometry.jl with the photutils asropy package. The benchmark code can be found in the bench folder. Note that for the multi-threaded examples my machine has 4 physical cores with 8 threads.","category":"page"},{"location":"modules/Photometry/apertures/","page":"Getting Started","title":"Getting Started","text":"julia> versioninfo()\nJulia Version 1.5.0\nCommit 96786e22cc (2020-08-01 23:44 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin18.7.0)\n  CPU: Intel(R) Core(TM) i5-8259U CPU @ 2.30GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-9.0.1 (ORCJIT, skylake)","category":"page"},{"location":"modules/Photometry/apertures/#Number-of-Apertures","page":"Getting Started","title":"Number of Apertures","text":"","category":"section"},{"location":"modules/Photometry/apertures/","page":"Getting Started","title":"Getting Started","text":"This benchmark shows how performance scales as we increase the number of apertures. The apertures are distributed randomly across the image with a fixed radius of 10. The image size is (512, 512). We see an improvement of ~10-100x (depending on multithreading) over photutils.","category":"page"},{"location":"modules/Photometry/apertures/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"modules/Photometry/apertures/#Size-of-Apertures","page":"Getting Started","title":"Size of Apertures","text":"","category":"section"},{"location":"modules/Photometry/apertures/","page":"Getting Started","title":"Getting Started","text":"This benchmark analyzes how the aperture size affects performance. Theoretically it should increase with O(n^2) complexity. For aperture sizes increasing from 1 to 200,  located in the center of a an image of size (512, 512).","category":"page"},{"location":"modules/Photometry/apertures/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"modules/Photometry/background/estimators/#Background-Estimators","page":"Background Estimators","title":"Background Estimators","text":"","category":"section"},{"location":"modules/Photometry/background/estimators/","page":"Background Estimators","title":"Background Estimators","text":"All of these estimators are subtypes of Background.LocationEstimator or Background.RMSEstimator and are derived using various statistical and image processing methods.","category":"page"},{"location":"modules/Photometry/background/estimators/#Location-Estimators","page":"Background Estimators","title":"Location Estimators","text":"","category":"section"},{"location":"modules/Photometry/background/estimators/","page":"Background Estimators","title":"Background Estimators","text":"These estimators are used for estimating the background using some form of a central statistic.","category":"page"},{"location":"modules/Photometry/background/estimators/","page":"Background Estimators","title":"Background Estimators","text":"Background.LocationEstimator\nMMMBackground\nSourceExtractorBackground\nBiweightLocationBackground","category":"page"},{"location":"modules/Photometry/background/estimators/#Photometry.Background.LocationEstimator","page":"Background Estimators","title":"Photometry.Background.LocationEstimator","text":"Background.LocationEstimator\n\nThis abstract type embodies the possible background estimation algorithms for dispatch with estimate_background.\n\nTo implement a new estimator, you must define the struct and define a method like (::MyEstimator)(data::AbstractArray; dims=:).\n\nSee Also\n\nLocation Estimators\n\n\n\n\n\n","category":"type"},{"location":"modules/Photometry/background/estimators/#Photometry.Background.MMMBackground","page":"Background Estimators","title":"Photometry.Background.MMMBackground","text":"MMMBackground(median_factor=3, mean_factor=2)\n\nEstimate the background using a mode estimator of the form median_factor * median - mean_factor * mean. This algorithm is based on the MMMBackground routine originally implemented in DAOPHOT. MMMBackground uses factors of median_factor=3 and mean_factor=2 by default. This estimator assumes that contaminated sky pixel values overwhelmingly display positive departures from the true value.\n\nExamples\n\njulia> x = ones(3, 5);\n\njulia> MMMBackground()(x)\n1.0\n\njulia> MMMBackground(median_factor=4, mean_factor=3)(x, dims = 1)\n1×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0\n\nSee Also\n\nSourceExtractorBackground\n\n\n\n\n\n","category":"type"},{"location":"modules/Photometry/background/estimators/#Photometry.Background.SourceExtractorBackground","page":"Background Estimators","title":"Photometry.Background.SourceExtractorBackground","text":"SourceExtractorBackground()\n\nThis estimator returns the background of the input using the SourceExtractorBackground algorithm.\n\nThe background is calculated using a mode estimator of the form (2.5 * median) - (1.5 * mean).\n\nIf (mean - median) / std > 0.3 then the median is used and if std = 0 then the mean is used.\n\nExamples\n\njulia> data = ones(3, 5);\n\njulia> SourceExtractorBackground()(data)\n1.0\n\njulia> SourceExtractorBackground()(data, dims=1)\n1×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"modules/Photometry/background/estimators/#Photometry.Background.BiweightLocationBackground","page":"Background Estimators","title":"Photometry.Background.BiweightLocationBackground","text":"BiweightLocationBackground(c = 6.0, M = nothing)\n\nEstimate the background using the robust biweight location statistic.\n\nxi_biloc=M + fracsum_u_i1(x_i - M)(1 - u_i^2)^2sum_u_i1(1-u_i^2)^2\n\nu_i = frac(x_i - M)ccdottextMAD(x)\n\nWhere textMAD(x) is median absolute deviation of x.\n\nExamples\n\njulia> x = ones(3,5);\n\njulia> BiweightLocationBackground()(x)\n1.0\n\njulia> BiweightLocationBackground(c=5.5)(x; dims = 1)\n1×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"modules/Photometry/background/estimators/#RMS-Estimators","page":"Background Estimators","title":"RMS Estimators","text":"","category":"section"},{"location":"modules/Photometry/background/estimators/","page":"Background Estimators","title":"Background Estimators","text":"These estimators are used for estimating the root-mean-square (RMS) of the background using some form of a deviation statistic.","category":"page"},{"location":"modules/Photometry/background/estimators/","page":"Background Estimators","title":"Background Estimators","text":"Background.RMSEstimator\nStdRMS\nMADStdRMS\nBiweightScaleRMS","category":"page"},{"location":"modules/Photometry/background/estimators/#Photometry.Background.RMSEstimator","page":"Background Estimators","title":"Photometry.Background.RMSEstimator","text":"Background.RMSEstimator\n\nThis abstract type embodies the possible background RMS estimation algorithms for dispatch with estimate_background.\n\nTo implement a new estimator, you must define the struct and define a method like (::MyRMSEstimator)(data::AbstractArray; dims=:).\n\nSee Also\n\nRMS Estimators\n\n\n\n\n\n","category":"type"},{"location":"modules/Photometry/background/estimators/#Photometry.Background.StdRMS","page":"Background Estimators","title":"Photometry.Background.StdRMS","text":"StdRMS()\n\nUses the standard deviation statistic for background RMS estimation.\n\nExamples\n\njulia> data = ones(3, 5);\n\njulia> StdRMS()(data)\n0.0\n\njulia> StdRMS()(data, dims=1)\n1×5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0\n\n\n\n\n\n","category":"type"},{"location":"modules/Photometry/background/estimators/#Photometry.Background.MADStdRMS","page":"Background Estimators","title":"Photometry.Background.MADStdRMS","text":"MADStdRMS()\n\nUses the standard median absolute deviation (MAD) statistic for background RMS estimation.\n\nThis is typically given as\n\nsigma approx 14826 cdot textMAD\n\nExamples\n\njulia> data = ones(3, 5);\n\njulia> MADStdRMS()(data)\n0.0\n\njulia> MADStdRMS()(data, dims=1)\n1×5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0\n\n\n\n\n\n","category":"type"},{"location":"modules/Photometry/background/estimators/#Photometry.Background.BiweightScaleRMS","page":"Background Estimators","title":"Photometry.Background.BiweightScaleRMS","text":"BiweightScaleRMS(c=9.0, M=nothing)\n\nUses the robust biweight scale statistic for background RMS estimation.\n\nThe biweight scale is the square root of the biweight midvariance. The biweight midvariance uses a tuning constant, c, and an optional initial guess of the central value M.\n\nzeta^2_biscl= fracnsum_u_i1(x_i - M)^2(1 - u_i^2)^4leftsum_u_i1(1-u_i^2)(1-5u_i^2)right^2\n\nu_i = frac(x_i - M)ccdottextMAD(x)\n\nWhere textMAD(x) is median absolute deviation of x.\n\nExamples\n\njulia> data = ones(3, 5);\n\njulia> BiweightScaleRMS()(data)\n0.0\n\njulia> BiweightScaleRMS(c=3.0)(data, dims=1)\n1×5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0\n\n\n\n\n\n","category":"type"},{"location":"modules/Cosmology/api/","page":"API/Reference","title":"API/Reference","text":"DocTestSetup = :(using Cosmology, Unitful, UnitfulAstro)","category":"page"},{"location":"modules/Cosmology/api/#API/Reference","page":"API/Reference","title":"API/Reference","text":"","category":"section"},{"location":"modules/Cosmology/api/","page":"API/Reference","title":"API/Reference","text":"tip: Unitful\nUnitful.jl works seamlessly with Cosmology.jl. In order to use its features, make sure it is installed and imported, along with UnitfulAstro.pkg> add Unitful UnitfulAstro\njulia> using Unitful, UnitfulAstro","category":"page"},{"location":"modules/Cosmology/api/#Cosmological-Models","page":"API/Reference","title":"Cosmological Models","text":"","category":"section"},{"location":"modules/Cosmology/api/","page":"API/Reference","title":"API/Reference","text":"cosmology","category":"page"},{"location":"modules/Cosmology/api/#Cosmology.cosmology","page":"API/Reference","title":"Cosmology.cosmology","text":"cosmology(;h = 0.69,\n           Neff = 3.04,\n           OmegaK = 0,\n           OmegaM = 0.29,\n           OmegaR = nothing,\n           Tcmb = 2.7255,\n           w0 = -1,\n           wa = 0)\n\nParameters\n\nh - Dimensionless Hubble constant\nOmegaK - Curvature density (Ω_k)\nOmegaM - Matter density (Ω_m)\nOmegaR - Radiation density (Ω_r)\nTcmb - CMB temperature in Kelvin; used to compute Ω_γ\nNeff - Effective number of massless neutrino species; used to compute Ω_ν\nw0 - CPL dark energy equation of state; w = w0 + wa(1-a)\nwa - CPL dark energy equation of state; w = w0 + wa(1-a)\n\nExamples\n\njulia> c = cosmology()\nCosmology.FlatLCDM{Float64}(0.69, 0.7099122024007928, 0.29, 8.77975992071536e-5)\n\njulia> c = cosmology(OmegaK=0.1)\nCosmology.OpenLCDM{Float64}(0.69, 0.1, 0.6099122024007929, 0.29, 8.77975992071536e-5)\n\njulia> c = cosmology(w0=-0.9, OmegaK=-0.1)\nCosmology.ClosedWCDM{Float64}(0.69, -0.1, 0.8099122024007929, 0.29, 8.77975992071536e-5, -0.9, 0.0)\n\n\n\n\n\n","category":"function"},{"location":"modules/Cosmology/api/#Distances","page":"API/Reference","title":"Distances","text":"","category":"section"},{"location":"modules/Cosmology/api/","page":"API/Reference","title":"API/Reference","text":"angular_diameter_dist\ncomoving_radial_dist\nluminosity_dist\ndistmod","category":"page"},{"location":"modules/Cosmology/api/#Cosmology.angular_diameter_dist","page":"API/Reference","title":"Cosmology.angular_diameter_dist","text":"angular_diameter_dist([u::Unitlike,] c::AbstractCosmology, [z₁,] z₂)\n\nRatio of the proper transverse size in Mpc of an object at redshift z₂ to its angular size in radians, as seen by an observer at z₁.  Redshift z₁ defaults to 0 if omitted.  Will convert to compatible unit u if provided.\n\n\n\n\n\n","category":"function"},{"location":"modules/Cosmology/api/#Cosmology.comoving_radial_dist","page":"API/Reference","title":"Cosmology.comoving_radial_dist","text":"comoving_radial_dist([u::Unitlike,] c::AbstractCosmology, [z₁,] z₂)\n\nComoving radial distance in Mpc at redshift z₂ as seen by an observer at z₁.  Redshift z₁ defaults to 0 if omitted.  Will convert to compatible unit u if provided.\n\n\n\n\n\n","category":"function"},{"location":"modules/Cosmology/api/#Cosmology.luminosity_dist","page":"API/Reference","title":"Cosmology.luminosity_dist","text":"luminosity_dist([u::Unitlike,] c::AbstractCosmology, z)\n\nBolometric luminosity distance in Mpc at redshift z. Will convert to compatible unit u if provided.\n\n\n\n\n\n","category":"function"},{"location":"modules/Cosmology/api/#Cosmology.distmod","page":"API/Reference","title":"Cosmology.distmod","text":"distmod(c::AbstractCosmology, z)\n\nDistance modulus in magnitudes at redshift z.\n\n\n\n\n\n","category":"function"},{"location":"modules/Cosmology/api/#Examples","page":"API/Reference","title":"Examples","text":"","category":"section"},{"location":"modules/Cosmology/api/","page":"API/Reference","title":"API/Reference","text":"julia> c = cosmology(OmegaM=0.26)\nCosmology.FlatLCDM{Float64}(0.69, 0.7399122024007928, 0.26, 8.77975992071536e-5)\n\njulia> angular_diameter_dist(c, 1.2)\n1784.0089227105113 Mpc\n\njulia> angular_diameter_dist(c, 0.7, 1.2)\n606.6521737365097 Mpc\n\njulia> luminosity_dist(c, 1.5)\n11420.338287150073 Mpc\n\njulia> luminosity_dist(u\"Gpc\", c, 1.5) # Can convert to appropriate unit\n11.420338287150074 Gpc","category":"page"},{"location":"modules/Cosmology/api/#Volumes","page":"API/Reference","title":"Volumes","text":"","category":"section"},{"location":"modules/Cosmology/api/","page":"API/Reference","title":"API/Reference","text":"comoving_volume_element\ncomoving_volume","category":"page"},{"location":"modules/Cosmology/api/#Cosmology.comoving_volume_element","page":"API/Reference","title":"Cosmology.comoving_volume_element","text":"comoving_volume_element([u::Unitlike,] c::AbstractCosmology, z)\n\nComoving volume element in Gpc out to redshift z. Will convert to compatible unit u if provided.\n\n\n\n\n\n","category":"function"},{"location":"modules/Cosmology/api/#Cosmology.comoving_volume","page":"API/Reference","title":"Cosmology.comoving_volume","text":"comoving_volume([u::Unitlike,] c::AbstractCosmology, z)\n\nComoving volume in cubic Gpc out to redshift z. Will convert to compatible unit u if provided.\n\n\n\n\n\n","category":"function"},{"location":"modules/Cosmology/api/#Examples-2","page":"API/Reference","title":"Examples","text":"","category":"section"},{"location":"modules/Cosmology/api/","page":"API/Reference","title":"API/Reference","text":"julia> c = cosmology(OmegaM=0.26)\nCosmology.FlatLCDM{Float64}(0.69, 0.7399122024007928, 0.26, 8.77975992071536e-5)\n\njulia> comoving_volume_element(c, 2.1)\n46.74459228888612 Gpc^3\n\njulia> comoving_volume(c, 0.6)\n49.3633436631307 Gpc^3\n\njulia> comoving_volume(u\"ly^3\", c, 0.6)\n1.7127035381753e30 ly^3","category":"page"},{"location":"modules/Cosmology/api/#Times","page":"API/Reference","title":"Times","text":"","category":"section"},{"location":"modules/Cosmology/api/","page":"API/Reference","title":"API/Reference","text":"age\nlookback_time","category":"page"},{"location":"modules/Cosmology/api/#Cosmology.age","page":"API/Reference","title":"Cosmology.age","text":"age([u::Unitlike,] c::AbstractCosmology, z)\n\nAge of the universe in Gyr at redshift z. Will convert to compatible unit u if provided.\n\n\n\n\n\n","category":"function"},{"location":"modules/Cosmology/api/#Cosmology.lookback_time","page":"API/Reference","title":"Cosmology.lookback_time","text":"lookback_time([u::Unitlike,] c::AbstractCosmology, z)\n\nDifference between age at redshift 0 and age at redshift z in Gyr. Will convert to compatible unit u if provided.\n\n\n\n\n\n","category":"function"},{"location":"modules/Cosmology/api/#Examples-3","page":"API/Reference","title":"Examples","text":"","category":"section"},{"location":"modules/Cosmology/api/","page":"API/Reference","title":"API/Reference","text":"julia> c = cosmology(OmegaM=0.26)\nCosmology.FlatLCDM{Float64}(0.69, 0.7399122024007928, 0.26, 8.77975992071536e-5)\n\njulia> age(c, 1.2)\n5.445600787626434 Gyr\n\njulia> lookback_time(u\"yr\", c, 1.2)\n8.761660748088268e9 yr","category":"page"},{"location":"modules/AstroImages/api/#API-Documentation","page":"API","title":"API Documentation","text":"","category":"section"},{"location":"modules/AstroImages/api/","page":"API","title":"API","text":"load\nsave\nAstroImage\nimview\nimplot\ndims\nrefdims\nComment\nHistory\npix_to_world\nworld_to_pix\nX\nY\nZ\nDim\nAt\nNear\nheader\nwcs\nWCSGrid\ncomposecolors\nZscale\nPercent\nlogstretch\npowstretch\nsqrtstretch\nsquarestretch\nasinhstretch\nsinhstretch\npowerdiststretch\ncopyheader\nshareheader","category":"page"},{"location":"modules/AstroImages/api/#FileIO.load","page":"API","title":"FileIO.load","text":"load(filename) loads the contents of a formatted file, trying to infer the format from filename and/or magic bytes in the file (see query).\nload(strm) loads from an IOStream or similar object. In this case, there is no filename extension, so we rely on the magic bytes for format identification.\nload(File{format\"PNG\"}(filename)) specifies the format directly, and bypasses the format query.\nload(Stream{format\"PNG\"}(io)) specifies the format directly, and bypasses the format query.\nload(f; options...) passes keyword arguments on to the loader.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroImages/api/#FileIO.save","page":"API","title":"FileIO.save","text":"save(filename, data...) saves the contents of a formatted file, trying to infer the format from filename.\nsave(Stream{format\"PNG\"}(io), data...) specifies the format directly, and bypasses the format query.\nsave(File{format\"PNG\"}(filename), data...) specifies the format directly, and bypasses the format query.\nsave(f, data...; options...) passes keyword arguments on to the saver.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroImages/api/#AstroImages.AstroImage","page":"API","title":"AstroImages.AstroImage","text":"Provides access to a FITS image along with its accompanying  header and WCS information, if applicable.\n\n\n\n\n\n","category":"type"},{"location":"modules/AstroImages/api/#AstroImages.imview","page":"API","title":"AstroImages.imview","text":"imview(img; clims=Percent(99.5), stretch=identity, cmap=:magma, contrast=1.0, bias=0.5)\n\nCreate a read only view of an array or AstroImageMat mapping its data values to Colors according to clims, stretch, and cmap.\n\nThe data is first clamped to clims, which can either be a tuple of (min, max) values or a function accepting an iterator of pixel values that returns (min, max). By default, clims=Percent(99.5) which sets the display min and max to the central 99.5 percentile range of pixel values. Convenient functions to use for clims are: extrema, Zscale, and Percent(p)\n\nNext, the data is rescaled to [0,1] and remapped according to the function stretch. Stretch can be any monotonic fuction mapping values in the range [0,1] to some range [a,b]. Note that log(0) is not defined so is not directly supported. For a list of convenient stretch functions, see: logstretch, powstretch, squarestretch, asinhstretch, sinhstretch, powerdiststretch\n\nFinally the data is mapped to RGB values according to cmap. If cmap is nothing, grayscale is used. ColorSchemes.jl defines hundreds of colormaps. A few nice ones for images include: :viridis, :magma, :plasma, :thermal, and :turbo.\n\nCrucially, this function returns a view over the underlying data. If img is updated then those changes will be reflected by this view with the exception of clims which is not recalculated.\n\nNote: if clims or stretch is a function, the pixel values passed in are first filtered to remove non-finite or missing values.\n\nDefaults\n\nThe default values of clims, stretch, and cmap are extrema, identity, and nothing respectively. You may alter these defaults using AstroImages.set_clims!,  AstroImages.set_stretch!, and AstroImages.set_cmap!.\n\nAutomatic Display\n\nArrays wrapped by AstroImageMat() get displayed as images automatically by calling  imview on them with the default settings when using displays that support showing PNG images.\n\nMissing data\n\nPixels that are NaN or missing will be displayed as transparent when cmap is set or black if. +/- Inf will be displayed as black or white respectively.\n\nExporting Images\n\nThe view returned by imview can be saved using general FileIO.save methods. Example:\n\nv = imview(data, cmap=:magma, stretch=asinhstretch, clims=Percent(95))\nsave(\"output.png\", v)\n\n\n\n\n\nimview(img::AbstractArray{<:Complex}; ...)\n\nWhen applied to an image with complex values, display the magnitude of the pixels using imview and display the phase angle as a panel below using a cyclical color map. For more customatization, you can create a view like this yourself:\n\nvcat(\n    imview(abs.(img)),\n    imview(angle.(img)),\n)\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroImages/api/#AstroImages.implot","page":"API","title":"AstroImages.implot","text":"implot(\n    img::AbstractArray;\n    clims=Percent(99.5),\n    stretch=identity,\n    cmap=:magma,\n    bias=0.5,\n    contrast=1,\n    wcsticks=true,\n    grid=true,\n    platescale=1\n)\n\nCreate a read only view of an array or AstroImageMat mapping its data values to an array of Colors. Equivalent to:\n\nimplot(\n    imview(\n        img::AbstractArray;\n        clims=Percent(99.5),\n        stretch=identity,\n        cmap=:magma,\n        bias=0.5,\n        contrast=1,\n    ),\n    wcsn=1,\n    wcsticks=true,\n    wcstitle=true,\n    grid=true,\n    platescale=1\n)\n\nImage Rendering\n\nSee imview for how data is mapped to RGBA pixel values.\n\nWCS & Image Coordinates\n\nIf provided with an AstroImage that has WCS headers set, the tick marks and plot grid are calculated using WCS.jl. By default, use the first WCS coordinate system. The underlying pixel coordinates are those returned by dims(img) multiplied by platescale. This allows you to overplot lines, regions, etc. using pixel coordinates. If you wish to compute the pixel coordinate of a point in world coordinates, see world_to_pix.\n\nwcsn (default 1) select which WCS transform in the headers to use for ticks & grid\nwcsticks (default true if WCS headers present) display ticks and labels, and title using world coordinates\nwcstitle (default true if WCS headers present and length(refdims(img))>0). When slicing a cube, display the location along unseen axes in world coordinates instead of pixel coordinates.\ngrid (default true) show a grid over the plot. Uses WCS coordinates if wcsticks is true, otherwise pixel coordinates multiplied by platescale.\nplatescale (default 1). Scales the underlying pixel coordinates to ease overplotting, etc. If wcsticks is false, the displayed pixel coordinates are also scaled.\n\nDefaults\n\nThe default values of clims, stretch, and cmap are extrema, identity, and nothing respectively. You may alter these defaults using AstroImages.set_clims!,  AstroImages.set_stretch!, and AstroImages.set_cmap!.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroImages/api/#DimensionalData.Dimensions.dims","page":"API","title":"DimensionalData.Dimensions.dims","text":"dims(x, [dims::Tuple]) => Tuple{Vararg{Dimension}}\ndims(x, dim) => Dimension\n\nReturn a tuple of Dimensions for an object, in the order that matches the axes or columns of the underlying data.\n\ndims can be Dimension, Dimension types, or Symbols for Dim{Symbol}.\n\nThe default is to return nothing.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroImages/api/#DimensionalData.Dimensions.refdims","page":"API","title":"DimensionalData.Dimensions.refdims","text":"refdims(x, [dims::Tuple]) => Tuple{Vararg{Dimension}}\nrefdims(x, dim) => Dimension\n\nReference dimensions for an array that is a slice or view of another array with more dimensions.\n\nslicedims(a, dims) returns a tuple containing the current new dimensions and the new reference dimensions. Refdims can be stored in a field or disgarded, as it is mostly to give context to plots. Ignoring refdims will simply leave some captions empty.\n\nThe default is to return an empty Tuple ().\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroImages/api/#AstroImages.Comment","page":"API","title":"AstroImages.Comment","text":"Index for accessing a comment associated with a header keyword or COMMENT entry.\n\nExample:\n\nimg = AstroImage(randn(10,10))\nimg[\"ABC\"] = 1\nimg[\"ABC\", Comment] = \"A comment describing this key\"\n\npush!(img, Comment, \"The purpose of this file is to demonstrate comments\")\nimg[Comment] # [\"The purpose of this file is to demonstrate comments\")]\n\n\n\n\n\n","category":"type"},{"location":"modules/AstroImages/api/#AstroImages.History","page":"API","title":"AstroImages.History","text":"Allows accessing and setting HISTORY header entries\n\nimg = AstroImage(randn(10,10)) push!(img, History, \"2023-04-19: Added history entry.\") img[History] # [\"2023-04-19: Added history entry.\"]\n\n\n\n\n\n","category":"type"},{"location":"modules/AstroImages/api/#WCS.pix_to_world","page":"API","title":"WCS.pix_to_world","text":"pix_to_world(wcs, pixcoords)\n\nConvert the array of pixel coordinates pixcoords to world coordinates according to the WCSTransform wcs. pixcoords should be a 2-d array where \"pixcoords[:, i]\" is the i-th set of coordinates, or a 1-d array representing a single set of coordinates.\n\nThe return value is the same shape as pixcoords.\n\n\n\n\n\npix_to_world(img::AstroImage, pixcoords; all=false)\n\nGiven an astro image, look up the world coordinates of the pixels given  by pixcoords. World coordinates are resolved using WCS.jl and a WCSTransform calculated from any FITS header present in img. If no WCS information is in the header, or the axes are all linear, this will just return pixel coordinates.\n\npixcoords should be the coordinates in your current selection of the image. For example, if you select a slice like this:\n\njulia> cube = load(\"some-3d-cube.fits\")\njulia> slice = cube[10:20, 30:40, 5]\n\nThen to look up the coordinates of the pixel in the bottom left corner of slice, run:\n\njulia> world_coords = pix_to_world(img, [1, 1])\n[10, 30]\n\nIf WCS information was present in the header of cube, then those coordinates would be resolved using axis 1, 2, and 3 respectively.\n\nTo include world coordinates in all axes, pass all=true\n\njulia> world_coords = pix_to_world(img, [1, 1], all=true)\n[10, 30, 5]\n\n!! Coordinates must be provided in the order of dims(img). If you transpose  an image, the order you pass the coordinates should not change.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroImages/api/#WCS.world_to_pix","page":"API","title":"WCS.world_to_pix","text":"world_to_pix(wcs, worldcoords)\n\nConvert the array of world coordinates worldcoords to pixel coordinates according to the WCSTransform wcs. worldcoords is a 2-d array where \"worldcoords[:, i]\" is the i-th set of coordinates, or a 1-d array representing a single set of coordinates.\n\nThe return value is the same size as worldcoords.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroImages/api/#DimensionalData.Dimensions.X","page":"API","title":"DimensionalData.Dimensions.X","text":"X <: XDim\n\nX(val=:)\n\nX Dimension. X <: XDim <: IndependentDim\n\nExample:\n\nxdim = X(2:2:10)\n# Or\nval = A[X(1)]\n# Or\nmean(A; dims=X)\n\n\n\n\n\n","category":"type"},{"location":"modules/AstroImages/api/#DimensionalData.Dimensions.Y","page":"API","title":"DimensionalData.Dimensions.Y","text":"Y <: YDim\n\nY(val=:)\n\nY Dimension. Y <: YDim <: DependentDim\n\nExample:\n\nydim = Y(['a', 'b', 'c'])\n# Or\nval = A[Y(1)]\n# Or\nmean(A; dims=Y)\n\n\n\n\n\n","category":"type"},{"location":"modules/AstroImages/api/#DimensionalData.Dimensions.Z","page":"API","title":"DimensionalData.Dimensions.Z","text":"Z <: ZDim\n\nZ(val=:)\n\nZ Dimension. Z <: ZDim <: Dimension\n\nExample:\n\nzdim = Z(10:10:100)\n# Or\nval = A[Z(1)]\n# Or\nmean(A; dims=Z)\n\n\n\n\n\n","category":"type"},{"location":"modules/AstroImages/api/#DimensionalData.Dimensions.Dim","page":"API","title":"DimensionalData.Dimensions.Dim","text":"Dim{S}(val=:)\n\nA generic dimension. For use when custom dims are required when loading data from a file. Can be used as keyword arguments for indexing.\n\nDimension types take precedence over same named Dim types when indexing with symbols, or e.g. creating Tables.jl keys.\n\nusing DimensionalData\n\ndim = Dim{:custom}(['a', 'b', 'c'])\n\n# output\n\nDim{:custom} Char['a', 'b', 'c']\n\n\n\n\n\n","category":"type"},{"location":"modules/AstroImages/api/#DimensionalData.Dimensions.LookupArrays.At","page":"API","title":"DimensionalData.Dimensions.LookupArrays.At","text":"At <: IntSelector\n\nAt(x, atol, rtol)\nAt(x; atol=nothing, rtol=nothing)\n\nSelector that exactly matches the value on the passed-in dimensions, or throws an error. For ranges and arrays, every intermediate value must match an existing value - not just the end points.\n\nx can be any value or Vector of values.\n\natol and rtol are passed to isapprox. For Number rtol will be set to Base.rtoldefault, otherwise nothing, and wont be used.\n\nExample\n\nusing DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))\nA[X(At(20)), Y(At(6))]\n\n# output\n\n5\n\n\n\n\n\n","category":"type"},{"location":"modules/AstroImages/api/#DimensionalData.Dimensions.LookupArrays.Near","page":"API","title":"DimensionalData.Dimensions.LookupArrays.Near","text":"Near <: IntSelector\n\nNear(x)\n\nSelector that selects the nearest index to x.\n\nWith Points this is simply the index values nearest to the x, however with Intervals it is the interval center nearest to x. This will be offset from the index value for Start and End loci.\n\nExample\n\nusing DimensionalData\n\nA = DimArray([1 2 3; 4 5 6], (X(10:10:20), Y(5:7)))\nA[X(Near(23)), Y(Near(5.1))]\n\n# output\n4\n\n\n\n\n\n","category":"type"},{"location":"modules/AstroImages/api/#AstroImages.header","page":"API","title":"AstroImages.header","text":"header(img::AstroImage)\n\nReturn the underlying FITSIO.FITSHeader object wrapped by an AstroImage. Note that this object has less flexible getindex and setindex methods. Indexing by symbol, Comment, History, etc are not supported.\n\n\n\n\n\nheader(array::AbstractArray)\n\nReturns an empty FITSIO.FITSHeader object when called with a non-AstroImage abstract array.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroImages/api/#AstroImages.wcs","page":"API","title":"AstroImages.wcs","text":"wcs(img)\n\nComputes and returns a list of World Coordinate System WCSTransform objects from WCS.jl. The resultss are cached after the first call, so subsequent calls are fast. Modifying a WCS header invalidates this cache automatically, so users should call wcs(...) each time rather than keeping the WCSTransform object around.\n\n\n\n\n\nwcs(img, index)\n\nComputes and returns a World Coordinate System WCSTransform objects from WCS.jl by index. This is to support files with multiple WCS transforms specified. wcs(img,1) is useful for selecting selecting the first WCSTranform object. The resultss are cached after the first call, so subsequent calls are fast. Modifying a WCS header invalidates this cache automatically, so users should call wcs(...) each time rather than keeping the WCSTransform object around.\n\n\n\n\n\nwcs(array)\n\nReturns a list with a single basic WCSTransform object when called with a non-AstroImage abstract array.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroImages/api/#AstroImages.WCSGrid","page":"API","title":"AstroImages.WCSGrid","text":"WCSGrid(img::AstroImageMat, ax=(1,2), coords=(first(axes(img,ax[1])),first(axes(img,ax[2]))))\n\nGiven an AstroImageMat, return information necessary to plot WCS gridlines in physical coordinates against the image's pixel coordinates. This function has to work on both plotted axes at once to handle rotation and general curvature of the WCS grid projected on the image coordinates.\n\n\n\n\n\n","category":"type"},{"location":"modules/AstroImages/api/#AstroImages.composecolors","page":"API","title":"AstroImages.composecolors","text":"composecolors(\n    images,\n    cmap=[\"#F00\", \"#0F0\", \"#00F\"];\n    clims,\n    stretch,\n    contrast,\n    bias,\n    multiplier\n)\n\nCreate a color composite of multiple images by applying imview and blending  the results. This function can be used to create RGB composites using any number of channels (e.g. red, green, blue, and hydrogen alpha) as well as more exotic images like blending radio and optical data using two different colormaps.\n\ncmap should be a list of colorants, named colors (see Colors.jl), or colorschemes (see ColorSchemes.jl). clims, stretch, contrast, and bias are passed on to imview. They can be a single value or a list of different values for each image.\n\nThe headers of the returned image are copied from the first image.\n\nExamples:\n\n# Basic RGB\ncomposecolors([redimage, greenimage, blueimage])\n# Non-linear stretch before blending\ncomposecolors([redimage, greenimage, blueimage], stretch=asinhstretch)\n# More than three channels are allowed (H alpha in pink)\ncomposecolors(\n    [antred, antgreen, antblue, anthalp],\n    [\"red\", \"green\", \"blue\", \"maroon1\"],\n    multiplier=[1,2,1,1]\n)\n# Can mix \ncomposecolors([radioimage, xrayimage], [:ice, :magma], clims=extrema)\ncomposecolors([radioimage, xrayimage], [:magma, :viridis], clims=[Percent(99), Zscale()])\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroImages/api/#AstroImages.Zscale","page":"API","title":"AstroImages.Zscale","text":"Zscale(options)(data)\n\nWraps PlotUtils.zscale in a callable with default parameters. This is a common algorithm for agressively stretching astronomical data to see faint structure that originated in IRAF: https://iraf.net/forum/viewtopic.php?showtopic=134139 but is now seen in many other applications/libraries (DS9, Astropy, etc.)\n\nUsage:\n\nimview(img, clims=Zscale())\nimplot(img, clims=Zscale(contrast=0.1))\n\nDefault parameters:\n\nnsamples::Int=1000\ncontrast::Float64=0.25\nmax_reject::Float64=0.5\nmin_npixels::Float64=5\nk_rej::Float64=2.5\nmax_iterations::Int=5\n\n\n\n\n\n","category":"type"},{"location":"modules/AstroImages/api/#AstroImages.Percent","page":"API","title":"AstroImages.Percent","text":"Percent(99.5)\n\nReturns a callable that calculates display limits that include the given  percent of the image data. Reproduces the behaviour of the SAO DS9 scale menu.\n\nExample:\n\njulia> imview(img, clims=Percent(90))\n\nThis will set the limits to be the 5th percentile to the 95th percentile.\n\n\n\n\n\n","category":"type"},{"location":"modules/AstroImages/api/#AstroImages.logstretch","page":"API","title":"AstroImages.logstretch","text":"logstretch(num,a=1000)\n\nA log-stretch as defined by the SAO DS9 application: http://ds9.si.edu/doc/ref/how.html\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroImages/api/#AstroImages.powstretch","page":"API","title":"AstroImages.powstretch","text":"powstretch(num, a=1000)\n\nA power-stretch as defined by the SAO DS9 application: http://ds9.si.edu/doc/ref/how.html\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroImages/api/#AstroImages.sqrtstretch","page":"API","title":"AstroImages.sqrtstretch","text":"sqrtstretch(num)\n\nA square root stretch (simply defined as Base.sqrt)\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroImages/api/#AstroImages.squarestretch","page":"API","title":"AstroImages.squarestretch","text":"squarestretch(num)\n\nA squarestretch-stretch as defined by the SAO DS9 application: http://ds9.si.edu/doc/ref/how.html\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroImages/api/#AstroImages.asinhstretch","page":"API","title":"AstroImages.asinhstretch","text":"asinhstretch(num)\n\nA hyperbolic arcsin stretch as defined by the SAO DS9 application: http://ds9.si.edu/doc/ref/how.html.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroImages/api/#AstroImages.sinhstretch","page":"API","title":"AstroImages.sinhstretch","text":"sinhstretch(num)\n\nA hyperbolic sin stretch as defined by the SAO DS9 application: http://ds9.si.edu/doc/ref/how.html\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroImages/api/#AstroImages.powerdiststretch","page":"API","title":"AstroImages.powerdiststretch","text":"logstretch(num,a=1000)\n\nA power distance stretch as defined by astropy.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroImages/api/#AstroImages.copyheader","page":"API","title":"AstroImages.copyheader","text":"copyheader(img::AstroImage, data) -> imgnew\n\nCreate a new image copying the header of img but using the data of the AbstractArray data. Note that changing the header of imgnew does not affect the header of img. See also: shareheader.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroImages/api/#AstroImages.shareheader","page":"API","title":"AstroImages.shareheader","text":"shareheader(img::AstroImage, data) -> imgnew\n\nCreate a new image reusing the header dictionary of img but using the data of the AbstractArray data. The two images have synchronized header; modifying one also affects the other. See also: copyheader.\n\n\n\n\n\n","category":"function"},{"location":"modules/AstroImages/guide/contours/#Contours","page":"Plotting Contours","title":"Contours","text":"","category":"section"},{"location":"modules/AstroImages/guide/contours/","page":"Plotting Contours","title":"Plotting Contours","text":"This guide shows a few different ways to measure and visualize contours of images.","category":"page"},{"location":"modules/AstroImages/guide/contours/#Using-Plots","page":"Plotting Contours","title":"Using Plots","text":"","category":"section"},{"location":"modules/AstroImages/guide/contours/","page":"Plotting Contours","title":"Plotting Contours","text":"The most basic way to create a contour plot is simply to use Plots.jl contour and contourf functions on your image.","category":"page"},{"location":"modules/AstroImages/guide/contours/","page":"Plotting Contours","title":"Plotting Contours","text":"Let's see how that works:","category":"page"},{"location":"modules/AstroImages/guide/contours/","page":"Plotting Contours","title":"Plotting Contours","text":"using AstroImages, Plots\n\n\n# First load a FITS file of interest\nfname = download(\n    \"http://www.astro.uvic.ca/~wthompson/astroimages/fits/herca/herca_radio.fits\",\n    \"herca-radio.fits\"\n)\n\nherca = load(\"herca-radio.fits\")","category":"page"},{"location":"modules/AstroImages/guide/contours/","page":"Plotting Contours","title":"Plotting Contours","text":"Create a contour plot","category":"page"},{"location":"modules/AstroImages/guide/contours/","page":"Plotting Contours","title":"Plotting Contours","text":"contour(herca)","category":"page"},{"location":"modules/AstroImages/guide/contours/","page":"Plotting Contours","title":"Plotting Contours","text":"Create a filled contour plot","category":"page"},{"location":"modules/AstroImages/guide/contours/","page":"Plotting Contours","title":"Plotting Contours","text":"contourf(herca)","category":"page"},{"location":"modules/AstroImages/guide/contours/","page":"Plotting Contours","title":"Plotting Contours","text":"Specify the number of levels","category":"page"},{"location":"modules/AstroImages/guide/contours/","page":"Plotting Contours","title":"Plotting Contours","text":"contour(herca, levels=5)","category":"page"},{"location":"modules/AstroImages/guide/contours/","page":"Plotting Contours","title":"Plotting Contours","text":"Specify specific levels","category":"page"},{"location":"modules/AstroImages/guide/contours/","page":"Plotting Contours","title":"Plotting Contours","text":"contour(herca, levels=[1, 1000, 5000])","category":"page"},{"location":"modules/AstroImages/guide/contours/","page":"Plotting Contours","title":"Plotting Contours","text":"Overplot contours on image:","category":"page"},{"location":"modules/AstroImages/guide/contours/","page":"Plotting Contours","title":"Plotting Contours","text":"implot(herca)\ncontour!(herca, levels=4, color=:cyan)","category":"page"},{"location":"modules/AstroImages/guide/contours/#Using-Contour.jl","page":"Plotting Contours","title":"Using Contour.jl","text":"","category":"section"},{"location":"modules/AstroImages/guide/contours/","page":"Plotting Contours","title":"Plotting Contours","text":"For more control over how contours are calculated and plotted, you can use the Contour.jl package:","category":"page"},{"location":"modules/AstroImages/guide/contours/","page":"Plotting Contours","title":"Plotting Contours","text":"using Contour\nherca = load(\"herca-radio.fits\")\n\np = implot(herca, cmap=nothing, colorbar=false)\n\n# Note: Contour.jl only supports float inputs https://github.com/JuliaGeometry/Contour.jl/issues/73\nfor cl in levels(contours(dims(herca)..., float.(herca)))\n    lvl = level(cl) # the z-value of this contour level\n    for line in lines(cl)\n        xs, ys = coordinates(line) # coordinates of this line segment\n        plot!(p, xs, ys, line_z=lvl, label=\"\")\n    end\nend\n\np","category":"page"},{"location":"modules/AstroImages/guide/contours/","page":"Plotting Contours","title":"Plotting Contours","text":"Here we plot just the contours, now in world coordinates:","category":"page"},{"location":"modules/AstroImages/guide/contours/","page":"Plotting Contours","title":"Plotting Contours","text":"p = plot(xlabel=\"RA\", ylabel=\"DEC\")\nfor cl in levels(contours(dims(herca)..., float.(herca)))\n    lvl = level(cl) # the z-value of this contour level\n    for line in lines(cl)\n        xs, ys = coordinates(line) # coordinates of this line segment\n        worldcoords = map(zip(xs,ys)) do pixcoord\n            pix_to_world(herca, [pixcoord...])\n        end\n        plot!(p, getindex.(worldcoords,1), getindex.(worldcoords,2), line_z=lvl, label=\"\")\n    end\nend\np","category":"page"},{"location":"modules/AstroImages/guide/image-filtering/#Image-Filtering","page":"Blurring & Filtering Images","title":"Image Filtering","text":"","category":"section"},{"location":"modules/AstroImages/guide/image-filtering/","page":"Blurring & Filtering Images","title":"Blurring & Filtering Images","text":"The package ImageFiltering.jl makes it easy to apply arbitrary filters to images.","category":"page"},{"location":"modules/AstroImages/guide/image-filtering/","page":"Blurring & Filtering Images","title":"Blurring & Filtering Images","text":"using AstroImages\nAstroImages.set_clims!(Percent(99.5))\nAstroImages.set_cmap!(:magma)\nAstroImages.set_stretch!(identity)","category":"page"},{"location":"modules/AstroImages/guide/image-filtering/#Gaussian-Blurs","page":"Blurring & Filtering Images","title":"Gaussian Blurs","text":"","category":"section"},{"location":"modules/AstroImages/guide/image-filtering/","page":"Blurring & Filtering Images","title":"Blurring & Filtering Images","text":"Let's start by downloading a radio image of Hercules A:","category":"page"},{"location":"modules/AstroImages/guide/image-filtering/","page":"Blurring & Filtering Images","title":"Blurring & Filtering Images","text":"using AstroImages\nusing ImageFiltering\n\nfname = download(\n    \"http://www.astro.uvic.ca/~wthompson/astroimages/fits/herca/herca_radio.fits\",\n    \"herca-radio.fits\"\n)\n\nherca = load(\"herca-radio.fits\")","category":"page"},{"location":"modules/AstroImages/guide/image-filtering/","page":"Blurring & Filtering Images","title":"Blurring & Filtering Images","text":"Let's now apply a Gaussian blur (aka a low pass filter) using the imfilter function:","category":"page"},{"location":"modules/AstroImages/guide/image-filtering/","page":"Blurring & Filtering Images","title":"Blurring & Filtering Images","text":"herca_blur_20 = imfilter(herca, Kernel.gaussian(20.0))","category":"page"},{"location":"modules/AstroImages/guide/image-filtering/","page":"Blurring & Filtering Images","title":"Blurring & Filtering Images","text":"The image has been smoothed out by convolving it with a wide Gaussian.","category":"page"},{"location":"modules/AstroImages/guide/image-filtering/","page":"Blurring & Filtering Images","title":"Blurring & Filtering Images","text":"Let's now do the opposite and perform a high-pass filter. This will bring out faint variations in structure. We can do this by subtracting a blurred image from the original:","category":"page"},{"location":"modules/AstroImages/guide/image-filtering/","page":"Blurring & Filtering Images","title":"Blurring & Filtering Images","text":"herca_blur_4 = imfilter(herca, Kernel.gaussian(4.0))\nherca_highpass = herca .- herca_blur_4","category":"page"},{"location":"modules/AstroImages/guide/image-filtering/","page":"Blurring & Filtering Images","title":"Blurring & Filtering Images","text":"We now see lots of faint structure inside the jets!","category":"page"},{"location":"modules/AstroImages/guide/image-filtering/","page":"Blurring & Filtering Images","title":"Blurring & Filtering Images","text":"Finally, let's adjust how the image is displayed and apply a non-linear stretch:","category":"page"},{"location":"modules/AstroImages/guide/image-filtering/","page":"Blurring & Filtering Images","title":"Blurring & Filtering Images","text":"imview(\n    herca_highpass,\n    cmap=:seaborn_rocket_gradient,\n    clims=(-50,1500),\n    stretch=asinhstretch\n)","category":"page"},{"location":"modules/AstroImages/guide/image-filtering/","page":"Blurring & Filtering Images","title":"Blurring & Filtering Images","text":"If you have Plots loaded, we can add a colorbar and coordinate axes by switching to implot:","category":"page"},{"location":"modules/AstroImages/guide/image-filtering/","page":"Blurring & Filtering Images","title":"Blurring & Filtering Images","text":"using Plots\nimplot(\n    herca_highpass,\n    cmap=:seaborn_rocket_gradient,\n    clims=(-50,1500),\n    stretch=asinhstretch\n)","category":"page"},{"location":"modules/AstroImages/guide/image-filtering/#Median-Filtering","page":"Blurring & Filtering Images","title":"Median Filtering","text":"","category":"section"},{"location":"modules/AstroImages/guide/image-filtering/","page":"Blurring & Filtering Images","title":"Blurring & Filtering Images","text":"In addition to linear filters using imfilter, ImageFiltering.jl also includes a great function called mapwindow. This functions allows you to map an arbitrary function over a patch of an image. ","category":"page"},{"location":"modules/AstroImages/guide/image-filtering/","page":"Blurring & Filtering Images","title":"Blurring & Filtering Images","text":"Let's use mapwindow to perform a median filter. This is a great way to suppress salt and pepper noise, or remove stars from some images.","category":"page"},{"location":"modules/AstroImages/guide/image-filtering/","page":"Blurring & Filtering Images","title":"Blurring & Filtering Images","text":"We'll use a Hubble picture of the Eagle nebula:","category":"page"},{"location":"modules/AstroImages/guide/image-filtering/","page":"Blurring & Filtering Images","title":"Blurring & Filtering Images","text":"using AstroImages\nusing ImageFiltering\n\nfname = download(\n    \"http://www.astro.uvic.ca/~wthompson/astroimages/fits/eagle/673nmos.fits\",\n    \"eagle-673nmos.fits\"\n)\n\neagle673 = load(\"eagle-673nmos.fits\")","category":"page"},{"location":"modules/AstroImages/guide/image-filtering/","page":"Blurring & Filtering Images","title":"Blurring & Filtering Images","text":"The data is originally from https://esahubble.org/projects/fits_liberator/eagledata/.","category":"page"},{"location":"modules/AstroImages/guide/image-filtering/","page":"Blurring & Filtering Images","title":"Blurring & Filtering Images","text":"We can apply a median filter using mapwindow. Make sure the patch size is an odd number in each direction!","category":"page"},{"location":"modules/AstroImages/guide/image-filtering/","page":"Blurring & Filtering Images","title":"Blurring & Filtering Images","text":"using Statistics\nmedfilt = copyheader(eagle673, mapwindow(median, eagle673, (11,11)))","category":"page"},{"location":"modules/AstroImages/guide/image-filtering/","page":"Blurring & Filtering Images","title":"Blurring & Filtering Images","text":"We use copyheader here since mapwindow returns a plain array and drops the image meta data.","category":"page"},{"location":"modules/AstroImages/guide/image-filtering/","page":"Blurring & Filtering Images","title":"Blurring & Filtering Images","text":"We can put this side by side with the original to see how some of the faint stars have been removed from the image:","category":"page"},{"location":"modules/AstroImages/guide/image-filtering/","page":"Blurring & Filtering Images","title":"Blurring & Filtering Images","text":"imview([eagle673[1:800,1:800]; medfilt[1:800,1:800]])","category":"page"}]
}
