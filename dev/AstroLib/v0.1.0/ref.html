<!DOCTYPE html><HTML lang="en"><head><script charset="utf-8" src="../../assets/default/multidoc_injector.js" type="text/javascript"></script><script charset="utf-8" type="text/javascript">window.MULTIDOCUMENTER_ROOT_PATH = '/docs/'</script><script charset="utf-8" src="../../assets/default/flexsearch.bundle.js" type="text/javascript"></script><script charset="utf-8" src="../../assets/default/flexsearch_integration.js" type="text/javascript"></script><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Reference · AstroLib</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script data-main="assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="https://JuliaAstro.org/docs/AstroLib/stable/ref.html" rel="canonical"/><link href="../../assets/default/multidoc.css" rel="stylesheet" type="text/css"/><link href="../../assets/default/flexsearch.css" rel="stylesheet" type="text/css"/></head><body><nav id="multi-page-nav"><a class="brand" href="../.."><img alt="home" src="../../assets/logo.svg"/></a><div class="hidden-on-mobile" id="nav-items"><a class="nav-link nav-item" href="../../docs/">Home</a><div class="nav-dropdown"><button class="nav-item dropdown-label">Data I/O</button><ul class="nav-dropdown-container"><a class="nav-link nav-item" href="../../AstroImages/">AstroImages</a><a class="nav-link nav-item" href="../../CFITSIO/">CFITSIO</a><a class="nav-link nav-item" href="../../FITSIO/">FITSIO</a><a class="nav-link nav-item" href="https://eschnett.github.io/ASDF2.jl/dev/" target="_blank">eschnett/ASDF2</a><a class="nav-link nav-item" href="https://github.com/torrance/Casacore.jl?tab=readme-ov-file#casacorejl" target="_blank">torrance/Casacore</a><a class="nav-link nav-item" href="https://aplavin.github.io/Difmap.jl/test/examples.html" target="_blank">JuliaAPlavin/Difmap</a><a class="nav-link nav-item" href="https://emmt.github.io/EasyFITS.jl/dev" target="_blank">emmt/EasyFITS</a><a class="nav-link nav-item" href="https://github.com/emmt/OIFITS.jl?tab=readme-ov-file#support-for-oi-fits-data-in-julia" target="_blank">emmt/OIFITS</a><a class="nav-link nav-item" href="https://github.com/JuliaAPlavin/VirtualObservatory.jl?tab=readme-ov-file#virtualobservatoryjl" target="_blank">JuliaAPlavin/VirtualObservatory</a><a class="nav-link nav-item" href="https://aplavin.github.io/VLBIData.jl/test/examples.html" target="_blank">JuliaAPlavin/VLBIData</a></ul></div><div class="nav-dropdown"><button class="nav-item dropdown-label">Images</button><ul class="nav-dropdown-container"><a class="nav-link nav-item" href="../../AstroImages/">AstroImages</a><a class="nav-link nav-item" href="../../CCDReduction/">CCDReduction</a><a class="nav-link nav-item" href="../../LACosmic/">LACosmic</a><a class="nav-link nav-item" href="../../Photometry/">Photometry</a><a class="nav-link nav-item" href="../../PSFModels/">PSFModels</a><a class="nav-link nav-item" href="https://github.com/JuliaAstro/Reproject.jl?tab=readme-ov-file#reproject" target="_blank">Reproject</a><a class="nav-link nav-item" href="../../SAOImageDS9/">SAOImageDS9</a><a class="nav-link nav-item" href="http://JuliaHCI.github.io/ADI.jl/stable/" target="_blank">JuliaHCI/ADI</a><a class="nav-link nav-item" href="http://JuliaHCI.github.io/HCIToolbox.jl/stable/" target="_blank">JuliaHCI/HCIToolbox</a></ul></div><div class="nav-dropdown"><button class="nav-item dropdown-label">Time, Coords, Units</button><ul class="nav-dropdown-container"><a class="nav-link nav-item" href="../../AstroAngles/">AstroAngles</a><a class="nav-link nav-item" href="../../AstroTime/">AstroTime</a><a class="nav-link nav-item" href="https://github.com/JuliaAstro/ERFA.jl?tab=readme-ov-file#erfajl" target="_blank">ERFA</a><a class="nav-link nav-item" href="../../SkyCoords/">SkyCoords</a><a class="nav-link nav-item" href="../../SPICE/">SPICE</a><a class="nav-link nav-item" href="../../UnitfulAstro/">UnitfulAstro</a><a class="nav-link nav-item" href="../../WCS/">WCS</a></ul></div><div class="nav-dropdown"><button class="nav-item dropdown-label">Orbits</button><ul class="nav-dropdown-container"><a class="nav-link nav-item" href="../../EarthOrientation/">EarthOrientation</a><a class="nav-link nav-item" href="../../Transits/">Transits</a><a class="nav-link nav-item" href="https://juliaastro.org/EphemerisSources.jl/docs" target="_blank">EphemerisSources</a><a class="nav-link nav-item" href="https://barrettp.github.io/Astrometry/dev" target="_blank">barrettp/Astrometry</a><a class="nav-link nav-item" href="https://github.com/PerezHz/HORIZONS.jl?tab=readme-ov-file#horizonsjl" target="_blank">PerezHz/HORIZONS</a><a class="nav-link nav-item" href="https://sefffal.github.io/PlanetOrbits.jl/dev/" target="_blank">sefffal/PlanetOrbits</a></ul></div><div class="nav-dropdown"><button class="nav-item dropdown-label">General</button><ul class="nav-dropdown-container"><a class="nav-link active nav-item" href="../">AstroLib</a><a class="nav-link nav-item" href="../../BoxLeastSquares/">BoxLeastSquares</a><a class="nav-link nav-item" href="../../Cosmology/">Cosmology</a><a class="nav-link nav-item" href="../../DustExtinction/">DustExtinction</a><a class="nav-link nav-item" href="../../LombScargle/">LombScargle</a><a class="nav-link nav-item" href="../../Photometry/">Photometry</a><a class="nav-link nav-item" href="http://mileslucas.com/BiweightStats.jl/stable/" target="_blank">mileslucas/BiweightStats</a><a class="nav-link nav-item" href="https://ziotom78.github.io/Healpix.jl/stable/" target="_blank">ziotom78/Healpix</a><a class="nav-link nav-item" href="https://ajwheeler.github.io/Korg.jl/stable/" target="_blank">ajwheeler/Korg</a><a class="nav-link nav-item" href="https://manuelbehrendt.github.io/Mera.jl/stable/" target="_blank">ManuelBehrendt/Mera</a><a class="nav-link nav-item" href="https://fabienbaron.github.io/OITOOLS.jl/dev" target="_blank">fabienbaron/OITOOLS</a><a class="nav-link nav-item" href="https://sefffal.github.io/PairPlots.jl/dev/" target="_blank">sefffal/PairPlots</a><a class="nav-link nav-item" href="https://juliaspace.github.io/SatelliteToolbox.jl/stable/" target="_blank">JuliaSpace/SatelliteToolbox</a></ul></div><div class="search nav-item"><input id="search-input" placeholder="Search everywhere..."/><ul class="suggestions hidden" id="search-result-container"></ul><div class="search-keybinding">/</div></div></div><button id="multidoc-toggler"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"></path></svg></button></nav><nav class="toc"><a href="index.html"><img alt="AstroLib logo" class="logo" src="assets/logo.png"/></a><h1>AstroLib</h1><select id="version-selector" onchange="window.location.href=this.value" style="visibility: hidden"></select><form action="search.html" class="search"><input id="search-query" name="q" placeholder="Search docs" type="text"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li class="current"><a class="toctext" href="ref.html">Reference</a><ul class="internal"><li><a class="toctext" href="#Data-types-1">Data types</a></li><li><a class="toctext" href="#Functions-organized-by-category-1">Functions organized by category</a></li><li><a class="toctext" href="#Types-and-functions-organized-alphabetically-1">Types and functions organized alphabetically</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="ref.html">Reference</a></li></ul><a class="edit-page" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/docs/src/ref.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" href="#Reference-1" id="Reference-1">Reference</a></h1><h2><a class="nav-anchor" href="#Data-types-1" id="Data-types-1">Data types</a></h2><h3><a class="nav-anchor" href="#Observatory-1" id="Observatory-1">Observatory</a></h3><p><code>AstroLib.jl</code> defines a new <code>Observatory</code> type. This can be used to define a new object holding information about an observing site. It is a [composite type] whose fields are</p><ul><li><p><code>name</code> (<code>String</code> type): the name of the site</p></li><li><p><code>latitude</code> (<code>Float64</code> type): North-ward latitude of the site in degrees</p></li><li><p><code>longitude</code> (<code>Float64</code> type): East-ward longitude of the site in degrees</p></li><li><p><code>altitude</code> (<code>Float64</code> type): altitude of the site in meters</p></li><li><p><code>tz</code> (<code>Float64</code> type): the number of hours of offset from UTC</p></li></ul><p>The type constructor <code>Observatory</code> can be used to create a new <code>Observatory</code> object. Its syntax is</p><pre><code class="language-julia">Observatory(name, lat, long, alt, tz)</code></pre><p><code>name</code> should be a string; <code>lat</code>, <code>long</code>, and <code>tz</code> should be anything that can be converted to a floating number with <code>ten</code> function; <code>alt</code> should be a real number.</p><p>A predefined list of some observing sites is provided with <code>AstroLib.observatories</code> constant. It is a dictionary whose keys are the abbreviated names of the observatories. For example, you can access information of the European Southern Observatory with</p><pre><code class="language-julia">julia&gt; obs = AstroLib.observatories["eso"]
Observatory: European Southern Observatory
latitude:    -29.256666666666668°N
longitude:   -70.73°E
altitude:    2347.0 m
time zone:   UTC-4

julia&gt; obs.longitude
-70.73</code></pre><p>You can list all keys of the dictionary with</p><pre><code class="language-julia">keys(AstroLib.observatories)</code></pre><p>Feel free to contribute new sites or adjust information of already present ones.</p><h3><a class="nav-anchor" href="#Planet-1" id="Planet-1">Planet</a></h3><p>The package provides <code>Planet</code> type to hold information about Solar System planets. Its fields are</p><ul><li><p>Designation:</p><ul><li><p><code>name</code>: the name</p></li></ul></li><li><p>Physical characteristics:</p><ul><li><p><code>radius</code>: mean radius in meters</p></li><li><p><code>eqradius</code>: equatorial radius in meters</p></li><li><p><code>polradius</code>: polar radius in meters</p></li><li><p><code>mass</code>: mass in kilogram</p></li></ul></li><li><p>Orbital characteristics (epoch J2000):</p><ul><li><p><code>ecc</code>: eccentricity of the orbit</p></li><li><p><code>axis</code>: semi-major axis of the orbit in meters</p></li><li><p><code>period</code>: sidereal orbital period in seconds</p></li></ul></li></ul><p>The constructor has this syntax:</p><pre><code class="language-julia">Planet(name, radius, eqradius, polradius, mass, ecc, axis, period)</code></pre><p>The list of Solar System planets, from Mercury to Pluto, is available with <code>AstroLib.planets</code> dictionary. The keys of this dictionary are the lowercase names of the planets. For example:</p><pre><code class="language-julia">julia&gt; AstroLib.planets["mercury"]
Planet:            Mercury
mean radius:       2.4397e6 m
equatorial radius: 2.4397e6 m
polar radius:      2.4397e6 m
mass:              3.3011e23 kg
eccentricity:      0.20563069
semi-major axis:   5.790905e10 m
period:            5.790905e10 s

julia&gt; AstroLib.planets["mars"].eqradius
3.3962e6

julia&gt; AstroLib.planets["saturn"].mass
5.6834e25</code></pre><h2><a class="nav-anchor" href="#Functions-organized-by-category-1" id="Functions-organized-by-category-1">Functions organized by category</a></h2><h3><a class="nav-anchor" href="#Coordinates-and-positions-1" id="Coordinates-and-positions-1">Coordinates and positions</a></h3><p><a href="ref.html#AstroLib.adstring-Union{Tuple{T,T}, Tuple{T}} where T&lt;:AbstractFloat"><code>adstring()</code></a>, <a href="ref.html#AstroLib.aitoff-Tuple{Real,Real}"><code>aitoff()</code></a>, <a href="ref.html#AstroLib.altaz2hadec-Tuple{Real,Real,Real}"><code>altaz2hadec()</code></a>, <a href="ref.html#AstroLib.bprecess"><code>bprecess()</code></a><a href="ref.html#AstroLib.eci2geo-NTuple{4,Real}"><code>eci2geo()</code></a><a href="ref.html#AstroLib.eqpole-Tuple{Real,Real}"><code>eqpole()</code></a><a href="ref.html#AstroLib.gcirc-Tuple{Integer,Real,Real,Real,Real}"><code>gcirc()</code></a><a href="ref.html#AstroLib.geo2eci-NTuple{4,Real}"><code>geo2eci()</code></a><a href="ref.html#AstroLib.geo2geodetic-NTuple{5,Real}"><code>geo2geodetic()</code></a>, <a href="ref.html#AstroLib.geo2mag"><code>geo2mag()</code></a>, <a href="ref.html#AstroLib.geodetic2geo-NTuple{5,Real}"><code>geodetic2geo()</code></a>, <a href="ref.html#AstroLib.hadec2altaz-Tuple{Real,Real,Real}"><code>hadec2altaz()</code></a>, <a href="ref.html#AstroLib.helio_rv"><code>helio_rv()</code></a>, <a href="ref.html#AstroLib.jprecess"><code>jprecess()</code></a>, <a href="ref.html#AstroLib.mag2geo"><code>mag2geo()</code></a>, <a href="ref.html#AstroLib.polrec-Tuple{Real,Real}"><code>polrec()</code></a>, <a href="ref.html#AstroLib.posang-Tuple{Integer,Real,Real,Real,Real}"><code>posang()</code></a>, <a href="ref.html#AstroLib.precess-NTuple{4,Real}"><code>precess()</code></a>, <a href="ref.html#AstroLib.precess_xyz-NTuple{5,Real}"><code>precess_xyz()</code></a>, <a href="ref.html#AstroLib.premat-Tuple{Real,Real}"><code>premat()</code></a>, <a href="ref.html#AstroLib.radec-Tuple{Real,Real}"><code>radec()</code></a>, <a href="ref.html#AstroLib.recpol-Tuple{Real,Real}"><code>recpol()</code></a><a href="ref.html#AstroLib.zenpos"><code>zenpos()</code></a></p><h3><a class="nav-anchor" href="#Time-and-date-1" id="Time-and-date-1">Time and date</a></h3><p><a href="ref.html#AstroLib.ct2lst-Tuple{Real,Real}"><code>ct2lst()</code></a>, <a href="ref.html#AstroLib.daycnv"><code>daycnv()</code></a>, <a href="ref.html#AstroLib.get_date-Tuple{DateTime,Bool,Bool}"><code>get_date()</code></a>, <a href="ref.html#AstroLib.get_juldate-Tuple{}"><code>get_juldate()</code></a>, <a href="ref.html#AstroLib.helio_jd-Tuple{Real,Real,Real}"><code>helio_jd()</code></a>, <a href="ref.html#AstroLib.jdcnv"><code>jdcnv()</code></a>, <a href="ref.html#AstroLib.juldate-Tuple{DateTime}"><code>juldate()</code></a>, <a href="ref.html#AstroLib.month_cnv-Tuple{Integer}"><code>month_cnv()</code></a>, <a href="ref.html#AstroLib.nutate-Tuple{Real}"><code>nutate()</code></a>, <a href="ref.html#AstroLib.ydn2md-Tuple{Integer,Integer}"><code>ydn2md()</code></a>, <a href="ref.html#AstroLib.ymd2dn"><code>ymd2dn()</code></a></p><h3><a class="nav-anchor" href="#Moon-and-sun-1" id="Moon-and-sun-1">Moon and sun</a></h3><p><a href="ref.html#AstroLib.moonpos-Tuple{Real}"><code>moonpos()</code></a>, <a href="ref.html#AstroLib.mphase-Tuple{Real}"><code>mphase()</code></a>, <a href="ref.html#AstroLib.sunpos-Tuple{Real}"><code>sunpos()</code></a>, <a href="ref.html#AstroLib.xyz"><code>xyz()</code></a></p><h3><a class="nav-anchor" href="#Utilities-1" id="Utilities-1">Utilities</a></h3><p><a href="ref.html#AstroLib.airtovac-Tuple{Real}"><code>airtovac()</code></a>, <a href="ref.html#AstroLib.calz_unred"><code>calz_unred()</code></a>, <a href="ref.html#AstroLib.cirrange"><code>cirrange()</code></a>, <a href="ref.html#AstroLib.deredd-NTuple{5,Real}"><code>deredd()</code></a>, <a href="ref.html#AstroLib.flux2mag"><code>flux2mag()</code></a>, <a href="ref.html#AstroLib.gal_uvw-NTuple{6,Real}"><code>gal_uvw()</code></a>, <a href="ref.html#AstroLib.kepler_solver-Tuple{Real,Real}"><code>kepler_solver()</code></a>, <a href="ref.html#AstroLib.lsf_rotate"><code>lsf_rotate()</code></a>, <a href="ref.html#AstroLib.mag2flux"><code>mag2flux()</code></a>, <a href="ref.html#AstroLib.paczynski-Tuple{Real}"><code>paczynski()</code></a>, <a href="ref.html#AstroLib.planck_freq-Tuple{Real,Real}"><code>planck_freq()</code></a>, <a href="ref.html#AstroLib.planck_wave-Tuple{Real,Real}"><code>planck_wave()</code></a>, <a href="ref.html#AstroLib.rad2sec-Tuple{Real}"><code>rad2sec()</code></a>, <a href="ref.html#AstroLib.rhotheta-NTuple{8,Real}"><code>rhotheta()</code></a>, <a href="ref.html#AstroLib.sec2rad-Tuple{Real}"><code>sec2rad()</code></a>, <a href="ref.html#AstroLib.sixty-Tuple{Real}"><code>sixty()</code></a>, <a href="ref.html#AstroLib.sphdist-NTuple{4,Real}"><code>sphdist()</code></a>, <a href="ref.html#AstroLib.ten"><code>ten()</code></a>, <a href="ref.html#AstroLib.tic_one"><code>tic_one()</code></a>, <a href="ref.html#AstroLib.ticpos-Tuple{Real,Real,Real}"><code>ticpos()</code></a>, <a href="ref.html#AstroLib.tics"><code>tics()</code></a>, <a href="ref.html#AstroLib.trueanom-Tuple{Real,Real}"><code>trueanom()</code></a>, <a href="ref.html#AstroLib.vactoair-Tuple{Real}"><code>vactoair()</code></a></p><h3><a class="nav-anchor" href="#Miscellaneous-(non-astronomy)-functions-1" id="Miscellaneous-(non-astronomy)-functions-1">Miscellaneous (non-astronomy) functions</a></h3><p><a href="ref.html#AstroLib.ordinal-Tuple{Integer}"><code>ordinal()</code></a></p><h2><a class="nav-anchor" href="#Types-and-functions-organized-alphabetically-1" id="Types-and-functions-organized-alphabetically-1">Types and functions organized alphabetically</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.Observatory" id="AstroLib.Observatory"><code>AstroLib.Observatory</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Type holding information about an observing site.  Its fields are:</p><ul><li><p><code>name</code>: the name of the site</p></li><li><p><code>latitude</code>: North-ward latitude of the site in degrees</p></li><li><p><code>longitude</code>: East-ward longitude of the site in degrees</p></li><li><p><code>altitude</code>: altitude of the site in meters</p></li><li><p><code>tz</code>: the number of hours of offset from UTC</p></li></ul></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/types.jl#L7-L15" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.Planet" id="AstroLib.Planet"><code>AstroLib.Planet</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Type holding information about a planet.  Its fields are:</p><p>Designation:</p><ul><li><p><code>name</code>: the name</p></li></ul><p>Physical characteristics:</p><ul><li><p><code>radius</code>: mean radius in meters</p></li><li><p><code>eqradius</code>: equatorial radius in meters</p></li><li><p><code>polradius</code>: polar radius in meters</p></li><li><p><code>mass</code>: mass in kilogram</p></li></ul><p>Orbital characteristics (epoch J2000):</p><ul><li><p><code>ecc</code>: eccentricity of the orbit</p></li><li><p><code>axis</code>: semi-major axis of the orbit in meters</p></li><li><p><code>period</code>: sidereal orbital period in seconds</p></li></ul></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/types.jl#L41-L60" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.adstring-Union{Tuple{T,T}, Tuple{T}} where T&lt;:AbstractFloat" id="AstroLib.adstring-Union{Tuple{T,T}, Tuple{T}} where T&lt;:AbstractFloat"><code>AstroLib.adstring</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">adstring(ra::Real, dec::Real[, precision::Int=2, truncate::Bool=true]) -&gt; string
adstring([ra, dec]) -&gt; string
adstring(dec) -&gt; string
adstring([ra], [dec]) -&gt; ["string1", "string2", ...]</code></pre><p><strong>Purpose</strong></p><p>Returns right ascension and declination as string(s) in sexagesimal format.</p><p><strong>Explanation</strong></p><p>Takes right ascension and declination expressed in decimal format, converts them to sexagesimal and return a formatted string.  The precision of right ascension and declination can be specified.</p><p><strong>Arguments</strong></p><p>Arguments of this function are:</p><ul><li><p><code>ra</code>: right ascension in decimal degrees.  It is converted to hours before printing.</p></li><li><p><code>dec</code>: declination in decimal degrees.</p></li></ul><p>The function can be called in different ways:</p><ul><li><p>Two numeric arguments: first is <code>ra</code>, the second is <code>dec</code>.</p></li><li><p>A 2-tuple <code>(ra, dec)</code>.</p></li><li><p>One 2-element numeric array: <code>[ra, dec]</code>.  A single string is returned.</p></li><li><p>One numeric argument: it is assumed only <code>dec</code> is provided.</p></li><li><p>Two numeric arrays of the same length: <code>ra</code> and <code>dec</code> arrays.  An array of strings is returned.</p></li><li><p>An array of 2-tuples <code>(ra, dec)</code>.</p></li></ul><p>Optional keywords affecting the output format are always available:</p><ul><li><p><code>precision</code> (optional integer keyword): specifies the number of digits of declination seconds.  The number of digits for right ascension seconds is always assumed to be one more <code>precision</code>.  If the function is called with only <code>dec</code> as input, <code>precision</code> default to 1, in any other case defaults to 0.</p></li><li><p><code>truncate</code> (optional boolean keyword): if true, then the last displayed digit in the output is truncated in precision rather than rounded.  This option is useful if <code>adstring</code> is used to form an official IAU name (see http://vizier.u-strasbg.fr/Dic/iau-spec.htx) with coordinate specification.</p></li></ul><p><strong>Output</strong></p><p>The function returns one string if the function was called with scalar <code>ra</code> and <code>dec</code> (or only <code>dec</code>) or a 2-element array <code>[ra, dec]</code>.  If instead it was feeded with arrays of <code>ra</code> and <code>dec</code>, an array of strings will be returned.  The format of strings can be specified with <code>precision</code> and <code>truncate</code> keywords, see above.</p><p><strong>Example</strong></p><pre><code class="language-julia">adstring(30.4, -1.23, truncate=true)
# =&gt; " 02 01 35.9  -01 13 48"
adstring([30.4, -15.63], [-1.23, 48.41], precision=1)
# =&gt; 2-element Array{AbstractString,1}:
#     " 02 01 36.00  -01 13 48.0"
#     "-22 57 28.80  +48 24 36.0"</code></pre></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/adstring.jl#L20-L83" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.airtovac-Tuple{Real}" id="AstroLib.airtovac-Tuple{Real}"><code>AstroLib.airtovac</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">airtovac(wave_air) -&gt; wave_vacuum</code></pre><p><strong>Purpose</strong></p><p>Converts air wavelengths to vacuum wavelengths.</p><p><strong>Explanation</strong></p><p>Wavelengths are corrected for the index of refraction of air under standard conditions.  Wavelength values below <span>$2000 Å$</span> will not be altered.  Uses relation of Ciddor (1996).</p><p><strong>Arguments</strong></p><ul><li><p><code>wave_air</code>: can be either a scalar or an array of numbers.  Wavelengths are</p></li></ul><p>corrected for the index of refraction of air under standard conditions. Wavelength values below <span>$2000 Å$</span> will <em>not</em> be altered, take care within <span>$[1 Å, 2000 Å]$</span>.</p><p><strong>Output</strong></p><p>Vacuum wavelength in angstroms, same number of elements as <code>wave_air</code>.</p><p><strong>Method</strong></p><p>Uses relation of Ciddor (1996), Applied Optics 62, 958.</p><p><strong>Example</strong></p><p>If the air wavelength is <code>w = 6056.125</code> (a Krypton line), then <code>airtovac(w)</code> yields a vacuum wavelength of <code>6057.8019</code>.</p><p><strong>Notes</strong></p><p><code>vactoair</code> converts vacuum wavelengths to air wavelengths.</p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/airtovac.jl#L20-L58" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.aitoff-Tuple{Real,Real}" id="AstroLib.aitoff-Tuple{Real,Real}"><code>AstroLib.aitoff</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">aitoff(l, b) -&gt; x, y</code></pre><p><strong>Purpose</strong></p><p>Convert longitude <code>l</code> and latitude <code>b</code> to <code>(x, y)</code> using an Aitoff projection.</p><p><strong>Explanation</strong></p><p>This function can be used to create an all-sky map in Galactic coordinates with an equal-area Aitoff projection.  Output map coordinates are zero longitude centered.</p><p><strong>Arguments</strong></p><ul><li><p><code>l</code>: longitude, scalar or vector, in degrees.</p></li><li><p><code>b</code>: latitude, number of elements as <code>l</code>, in degrees.</p></li></ul><p>Coordinates can be given also as a 2-tuple <code>(l, b)</code>.</p><p><strong>Output</strong></p><p>2-tuple <code>(x, y)</code>.</p><ul><li><p><code>x</code>: x coordinate, same number of elements as <code>l</code>.  <code>x</code> is normalized to be in <span>$[-180, 180]$</span>.</p></li><li><p><code>y</code>: y coordinate, same number of elements as <code>l</code>.  <code>y</code> is normalized to be in <span>$[-90, 90]$</span>.</p></li></ul><p><strong>Example</strong></p><p>Get <span>$(x ,y)$</span> Aitoff coordinates of Sirius, whose Galactic coordinates are <span>$(227.23, -8.890)$</span>.</p><pre><code class="language-julia">x, y = aitoff(227.23, -8.890)
# =&gt; (-137.92196683723276,-11.772527357473054)</code></pre><p><strong>Notes</strong></p><p>See AIPS memo No. 46 (ftp://ftp.aoc.nrao.edu/pub/software/aips/TEXT/PUBL/AIPSMEMO46.PS), page 4, for details of the algorithm.  This version of <code>aitoff</code> assumes the projection is centered at b=0 degrees.</p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/aitoff.jl#L15-L62" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.altaz2hadec-Tuple{Real,Real,Real}" id="AstroLib.altaz2hadec-Tuple{Real,Real,Real}"><code>AstroLib.altaz2hadec</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">altaz2hadec(alt, az, lat) -&gt; ha, dec</code></pre><p><strong>Purpose</strong></p><p>Convert Horizon (Alt-Az) coordinates to Hour Angle and Declination.</p><p><strong>Explanation</strong></p><p>Can deal with the NCP singularity.  Intended mainly to be used by program <code>hor2eq</code>.</p><p><strong>Arguments</strong></p><p>Input coordinates may be either a scalar or an array, of the same dimension.</p><ul><li><p><code>alt</code>: local apparent altitude, in degrees, scalar or array.</p></li><li><p><code>az</code>: the local apparent azimuth, in degrees, scalar or vector, measured</p></li></ul><p><em>east</em> of <em>north</em>!!!  If you have measured azimuth west-of-south (like the book  Meeus does), convert it to east of north via: <code>az = (az + 180) % 360</code>.</p><ul><li><p><code>lat</code>: the local geodetic latitude, in degrees, scalar or array.</p></li></ul><p><code>alt</code> and <code>az</code> can be given as a 2-tuple <code>(alt, az)</code>.</p><p><strong>Output</strong></p><p>2-tuple <code>(ha, dec)</code></p><ul><li><p><code>ha</code>: the local apparent hour angle, in degrees.  The hour angle is the time that right ascension of 0 hours crosses the local meridian.  It is unambiguously defined.</p></li><li><p><code>dec</code>: the local apparent declination, in degrees.</p></li></ul><p>The output coordinates are always floating points and have the same type (scalar or array) as the input coordinates.</p><p><strong>Example</strong></p><p>Arcturus is observed at an apparent altitude of 59d,05m,10s and an azimuth (measured east of north) of 133d,18m,29s while at the latitude of +43.07833 degrees.  What are the local hour angle and declination of this object?</p><pre><code class="language-julia">ha, dec = altaz2hadec(ten(59,05,10), ten(133,18,29), 43.07833)
# =&gt; (336.6828582472844,19.182450965120402)</code></pre><p>The widely available XEPHEM code gets:</p><pre><code class="language-none">Hour Angle = 336.683
Declination = 19.1824</code></pre><p><strong>Notes</strong></p><p><code>hadec2altaz</code> converts Hour Angle and Declination to Horizon (Alt-Az) coordinates.</p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/altaz2hadec.jl#L22-L79" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.bprecess" id="AstroLib.bprecess"><code>AstroLib.bprecess</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">bprecess(ra, dec[, epoch]) -&gt; ra1950, dec1950
bprecess(ra, dec, muradec[, parallax=parallax, radvel=radvel]) -&gt; ra1950, dec1950</code></pre><p><strong>Purpose</strong></p><p>Precess positions from J2000.0 (FK5) to B1950.0 (FK4).</p><p><strong>Explanation</strong></p><p>Calculates the mean place of a star at B1950.0 on the FK4 system from the mean place at J2000.0 on the FK5 system.</p><p><code>bprecess</code> function has two methods, one for each of the following cases:</p><ul><li><p>the proper motion is known and non-zero</p></li><li><p>the proper motion is unknown or known to be exactly zero (i.e. extragalactic radio sources).  Better precision can be achieved in this case by inputting the epoch of the original observations.</p></li></ul><p><strong>Arguments</strong></p><p>The function has 2 methods.  The common mandatory arguments are:</p><ul><li><p><code>ra</code>: input J2000 right ascension, in degrees.</p></li><li><p><code>dec</code>: input J2000 declination, in degrees.</p></li></ul><p>The two methods have a different third argument (see "Explanation" section for more details).  It can be one of the following:</p><ul><li><p><code>muradec</code>: 2-element vector containing the proper motion in seconds of arc per tropical <em>century</em> in right ascension and declination.</p></li><li><p><code>epoch</code>: scalar giving epoch of original observations.</p></li></ul><p>If none of these two arguments is provided (so <code>bprecess</code> is fed only with right ascension and declination), it is assumed that proper motion is exactly zero and <code>epoch = 2000</code>.</p><p>If it is used the method involving <code>muradec</code> argument, the following keywords are available:</p><ul><li><p><code>parallax</code> (optional numerical keyword): stellar parallax, in seconds of arc.</p></li><li><p><code>radvel</code> (optional numerical keyword): radial velocity in km/s.</p></li></ul><p>Right ascension and declination can be passed as the 2-tuple <code>(ra, dec)</code>.  You can also pass <code>ra</code>, <code>dec</code>, <code>parallax</code>, and <code>radvel</code> as arrays, all of the same length N.  In that case, <code>muradec</code> should be a matrix 2×N.</p><p><strong>Output</strong></p><p>The 2-tuple of right ascension and declination in 1950, in degrees, of input coordinates is returned.  If <code>ra</code> and <code>dec</code> (and other possible optional arguments) are arrays, the 2-tuple of arrays <code>(ra1950, dec1950)</code> of the same length as the input coordinates is returned.</p><p><strong>Method</strong></p><p>The algorithm is taken from the Explanatory Supplement to the Astronomical Almanac 1992, page 186.  See also Aoki et al (1983), A&amp;A, 128, 263.  URL: http://adsabs.harvard.edu/abs/1983A%26A...128..263A.</p><p><strong>Example</strong></p><p>The SAO2000 catalogue gives the J2000 position and proper motion for the star HD</p><ol><li><p>Find the B1950 position.</p></li></ol><ul><li><p>RA(2000) = 13h 42m 12.740s</p></li><li><p>Dec(2000) = 8d 23' 17.69''</p></li><li><p>Mu(RA) = -.0257 s/yr</p></li><li><p>Mu(Dec) = -.090 ''/yr</p></li></ul><pre><code class="language-julia">muradec = 100*[-15*0.0257, -0.090]; # convert to century proper motion
ra = ten(13, 42, 12.74)*15;
decl = ten(8, 23, 17.69);
adstring(bprecess(ra, decl, muradec), precision=2)
# =&gt; " 13 39 44.526  +08 38 28.63"</code></pre><p><strong>Notes</strong></p><p>"When transferring individual observations, as opposed to catalog mean place, the safest method is to transform the observations back to the epoch of the observation, on the FK4 system (or in the system that was used to to produce the observed mean place), convert to the FK5 system, and transform to the the epoch and equinox of J2000.0" – from the Explanatory Supplement (1992), p. 180</p><p><code>jprecess</code> performs the precession to J2000 coordinates.</p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/bprecess.jl#L126-L216" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.calz_unred" id="AstroLib.calz_unred"><code>AstroLib.calz_unred</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">calz_unred(wave, flux, ebv[, r_v]) -&gt; deredden_wave</code></pre><p><strong>Purpose</strong></p><p>Deredden a galaxy spectrum using the Calzetti et al. (2000) recipe.</p><p><strong>Explanation</strong></p><p>Calzetti et al.  (2000, ApJ 533, 682; http://adsabs.harvard.edu/abs/2000ApJ...533..682C) developed a recipe for dereddening the spectra of galaxies where massive stars dominate the radiation output, valid between <span>$0.12$</span> to <span>$2.2$</span> microns.  (<code>calz_unred</code> extrapolates between <span>$0.12$</span> and <span>$0.0912$</span> microns.)</p><p><strong>Arguments</strong></p><ul><li><p><code>wave</code>: wavelength vector (Angstroms)</p></li><li><p><code>flux</code>: calibrated flux vector, same number of elements as <code>wave</code>.</p></li><li><p><code>ebv</code>: color excess E(B-V), scalar.  If a negative <code>ebv</code> is supplied, then fluxes will be reddened rather than deredenned.  Note that the supplied color excess should be that derived for the stellar continuum, EBV(stars), which is related to the reddening derived from the gas, EBV(gas), via the Balmer decrement by EBV(stars) = 0.44*EBV(gas).</p></li><li><p><code>r_v</code> (optional): scalar ratio of total to selective extinction, default is 4.05.  Calzetti et al. (2000) estimate <span>$r_v = 4.05 \pm 0.80$</span> from optical-IR observations of 4 starbursts.</p></li></ul><p><strong>Output</strong></p><p>Unreddened flux vector, same units and number of elements as <code>flux</code>.  Flux values will be left unchanged outside valid domain (<span>$0.0912$</span> - <span>$2.2$</span> microns).</p><p><strong>Example</strong></p><p>Estimate how a flat galaxy spectrum (in wavelength) between <span>$1200 Å$</span> and <span>$3200 Å$</span> is altered by a reddening of E(B-V) = 0.1.</p><pre><code class="language-julia">wave = collect(1200:50:3150);
flux = ones(wave);
flux_new = calz_unred.(wave, flux, -0.1);</code></pre><p>Using a plotting tool you can visualize the unreddend flux.  For example, with <a href="https://github.com/stevengj/PyPlot.jl">PyPlot.jl</a></p><pre><code class="language-julia">using PyPlot
plot(wave, flux_new)</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/calz_unred.jl#L16-L72" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.cirrange" id="AstroLib.cirrange"><code>AstroLib.cirrange</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cirrange(number[, max]) -&gt; restricted_number</code></pre><p><strong>Purpose</strong></p><p>Force a number into a given range <span>$[0, \text{max})$</span>.</p><p><strong>Argument</strong></p><ul><li><p><code>number</code>: the number to modify.  Can be a scalar or an array.</p></li><li><p><code>max</code> (optional numerical argument): specify the extremum of the range <span>$[0, \text{max})$</span></p></li></ul><p>into which the number should be restricted.  If omitted, defaults to <code>360.0</code>.</p><p><strong>Output</strong></p><p>The converted number or array of numbers, as <code>AbstractFloat</code>.</p><p><strong>Example</strong></p><p>Restrict an array of numbers in the range <span>$[0, 2\pi)$</span> as if they are angles expressed in radians:</p><pre><code class="language-julia">cirrange([4pi, 10, -5.23], 2.0*pi)
# =&gt; 3-element Array{Float64,1}:
#     0.0
#     3.71681
#     1.05319</code></pre><p><strong>Notes</strong></p><p>This function does not support the <code>radians</code> keyword like IDL implementation. Use <code>2.0*pi</code> as second argument to restrict a number to the same interval.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/cirrange.jl#L4-L38" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.ct2lst-Tuple{Real,Real}" id="AstroLib.ct2lst-Tuple{Real,Real}"><code>AstroLib.ct2lst</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">ct2lst(longitude, jd) -&gt; local_sidereal_time
ct2lst(longitude, tz, date) -&gt; local_sidereal_time</code></pre><p><strong>Purpose</strong></p><p>Convert from Local Civil Time to Local Mean Sidereal Time.</p><p><strong>Arguments</strong></p><p>The function can be called in two different ways.  The only argument common to both methods is <code>longitude</code>:</p><ul><li><p><code>longitude</code>: the longitude in degrees (east of Greenwich) of the place for which the local sidereal time is desired, scalar.  The Greenwich mean sidereal time (GMST) can be found by setting longitude = <code>0</code>.</p></li></ul><p>The civil date to be converted to mean sidereal time can be specified either by providing the Julian days:</p><ul><li><p><code>jd</code>: this is number of Julian days for the date to be converted.  It can be a scalar or an array.</p></li></ul><p>or the time zone and the date:</p><ul><li><p><code>tz</code>: the time zone of the site in hours, positive East of the Greenwich meridian (ahead of GMT).  Use this parameter to easily account for Daylight Savings time (e.g. -4=EDT, -5 = EST/CDT), scalar.</p><ul><li><p><code>date</code>: this is the local civil time with type <code>DateTime</code>.  It can</p></li></ul><p>be a scalar or an array.</p></li></ul><p><strong>Output</strong></p><p>The local sidereal time for the date/time specified in hours.  This is a scalar or an array of the same length as <code>jd</code> or <code>date</code>.</p><p><strong>Method</strong></p><p>The Julian days of the day and time is question is used to determine the number of days to have passed since 2000-01-01.  This is used in conjunction with the GST of that date to extrapolate to the current GST; this is then used to get the LST.  See Astronomical Algorithms by Jean Meeus, p. 84 (Eq. 11-4) for the constants used.</p><p><strong>Example</strong></p><p>Find the Greenwich mean sidereal time (GMST) on 2008-07-30 at 15:53 in Baltimore, Maryland (longitude=-76.72 degrees).  The timezone is EDT or tz=-4</p><pre><code class="language-julia">lst = ct2lst(-76.72, -4, DateTime(2008, 7, 30, 15, 53))
# =&gt; 11.356505172312609
sixty(lst)
# =&gt; 3-element Array{Float64,1}:
#     11.0    # Hours
#     21.0    # Minutes
#     23.4186 # Seconds</code></pre><p>Find the Greenwich mean sidereal time (GMST) on 2015-11-24 at 13:21 in Heidelberg, Germany (longitude=08° 43' E).  The timezone is CET or tz=1. Provide <code>ct2lst</code> only with the longitude of the place and the number of Julian days.</p><pre><code class="language-julia"># Convert longitude to decimals.
longitude=ten(8, 43);
# Get number of Julian days.  Remember to subtract the time zone in
# order to convert local time to UTC.
jd = jdcnv(DateTime(2015, 11, 24, 13, 21) - Dates.Hour(1));
# Calculate Greenwich Mean Sidereal Time.
lst = ct2lst(longitude, jd)
# =&gt; 17.140685171005316
sixty(lst)
# =&gt; 3-element Array{Float64,1}:
#     17.0    # Hours
#     8.0    # Minutes
#     26.4666 # Seconds</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/ct2lst.jl#L12-L95" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.daycnv" id="AstroLib.daycnv"><code>AstroLib.daycnv</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">daycnv(julian_days) -&gt; DateTime</code></pre><p><strong>Purpose</strong></p><p>Converts Julian days number to Gregorian calendar dates.</p><p><strong>Explanation</strong></p><p>Takes the number of Julian calendar days since epoch <code>-4713-11-24T12:00:00</code> and returns the corresponding proleptic Gregorian Calendar date.</p><p><strong>Argument</strong></p><ul><li><p><code>julian_days</code>: Julian days number, scalar or array.</p></li></ul><p><strong>Output</strong></p><p>Proleptic Gregorian Calendar date, of type <code>DateTime</code>, corresponding to the given Julian days number.</p><p><strong>Example</strong></p><pre><code class="language-julia">daycnv(2440000)
# =&gt; 1968-05-23T12:00:00</code></pre><p><strong>Notes</strong></p><p><code>jdcnv</code> is the inverse of this function.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/daycnv.jl#L4-L35" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.deredd-NTuple{5,Real}" id="AstroLib.deredd-NTuple{5,Real}"><code>AstroLib.deredd</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">deredd(Eby, by, m1, c1, ub) -&gt; by0, m0, c0, ub0</code></pre><p><strong>Purpose</strong></p><p>Deredden stellar Stromgren parameters given for a value of E(b-y)</p><p><strong>Arguments</strong></p><ul><li><p><code>Eby</code>: color index E(b-y), scalar (E(b-y) = 0.73*E(B-V))</p></li><li><p><code>by</code>: b-y color (observed)</p></li><li><p><code>m1</code>: Stromgren line blanketing parameter (observed)</p></li><li><p><code>c1</code>: Stromgren Balmer discontinuity parameter (observed)</p></li><li><p><code>ub</code>: u-b color (observed)</p></li></ul><p>All arguments can be either scalars or arrays all of the same length.</p><p><strong>Output</strong></p><p>The 4-tuple <code>(by0, m0, c0, ub0)</code>.</p><ul><li><p><code>by0</code>: b-y color (dereddened)</p></li><li><p><code>m0</code>: line blanketing index (dereddened)</p></li><li><p><code>c0</code>: Balmer discontinuity parameter (dereddened)</p></li><li><p><code>ub0</code>: u-b color (dereddened)</p></li></ul><p>These are scalars or arrays of the same length as the input arguments.</p><p><strong>Example</strong></p><pre><code class="language-julia">deredd(0.5, 0.2, 1.0, 1.0, 0.1)
# =&gt; (-0.3,1.165,0.905,-0.665)</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/deredd.jl#L12-L50" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.eci2geo-NTuple{4,Real}" id="AstroLib.eci2geo-NTuple{4,Real}"><code>AstroLib.eci2geo</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">eci2geo(x, y, z, jd) -&gt; latitude, longitude, altitude</code></pre><p><strong>Purpose</strong></p><p>Convert Earth-centered inertial coordinates to geographic spherical coordinates.</p><p><strong>Explanation</strong></p><p>Converts from ECI (Earth-Centered Inertial) (x, y, z) rectangular coordinates to geographic spherical coordinates (latitude, longitude, altitude).  Julian day is also needed as input.</p><p>ECI coordinates are in km from Earth center at the supplied time (True of Date). Geographic coordinates assume the Earth is a perfect sphere, with radius equal to its equatorial radius.</p><p><strong>Arguments</strong></p><ul><li><p><code>x</code>: ECI x coordinate at <code>jd</code>, in kilometers.</p></li><li><p><code>y</code>: ECI y coordinate at <code>jd</code>, in kilometers.</p></li><li><p><code>z</code>: ECI z coordinate at <code>jd</code>, in kilometers.</p></li><li><p><code>jd</code>: Julian days.</p></li></ul><p>The three coordinates can be passed as a 3-tuple <code>(x, y, z)</code>.  In addition, <code>x</code>, <code>y</code>, <code>z</code>, and <code>jd</code> can be given as arrays of the same length.</p><p><strong>Output</strong></p><p>The 3-tuple of geographical coordinate (latitude, longitude, altitude).</p><ul><li><p>latitude: latitude, in degrees.</p></li><li><p>longitude: longitude, in degrees.</p></li><li><p>altitude: altitude, in kilometers.</p></li></ul><p>If ECI coordinates are given as arrays, a 3-tuple of arrays of the same length is returned.</p><p><strong>Example</strong></p><p>Obtain the geographic direction of the vernal point on 2015-06-30T14:03:12.857, in geographic coordinates, at altitude 600 km.  Note: equatorial radii of Solar System planets in meters are stored into <code>AstroLib.planets</code> dictionary.</p><pre><code class="language-julia">x = AstroLib.planets["earth"].eqradius*1e-3 + 600;
lat, long, alt = eci2geo(x, 0, 0, jdcnv("2015-06-30T14:03:12.857"))
# =&gt; (0.0,230.87301833205856,600.0)</code></pre><p>These coordinates can be further transformed into geodetic coordinates using <code>geo2geodetic</code> or into geomagnetic coordinates using <code>geo2mag</code>.</p><p><strong>Notes</strong></p><p><code>geo2eci</code> converts geographic spherical coordinates to Earth-centered inertial coordinates.</p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/eci2geo.jl#L17-L76" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.eqpole-Tuple{Real,Real}" id="AstroLib.eqpole-Tuple{Real,Real}"><code>AstroLib.eqpole</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">eqpole(l, b) -&gt; x, y</code></pre><p><strong>Purpose</strong></p><p>Convert right ascension <span>$l$</span> and declination <span>$b$</span> to coordinate <span>$(x, y)$</span> using an equal-area polar projection.</p><p><strong>Explanation</strong></p><p>The output <span>$x$</span> and <span>$y$</span> coordinates are scaled to be in the range <span>$[-90, 90]$</span> and to go from equator to pole to equator.  Output map points can be centered on the north pole or south pole.</p><p><strong>Arguments</strong></p><ul><li><p><code>l</code>: longitude, scalar or vector, in degrees</p></li><li><p><code>b</code>: latitude, same number of elements as right ascension, in degrees</p></li><li><p><code>southpole</code> (optional boolean keyword): keyword to indicate that the plot is to be centered on the south pole instead of the north pole.  Default is <code>false</code>.</p></li></ul><p><strong>Output</strong></p><p>The 2-tuple <span>$(x, y)$</span>:</p><ul><li><p><span>$x$</span> coordinate, same number of elements as right ascension, normalized to be in the range <span>$[-90, 90]$</span>.</p></li><li><p><span>$y$</span> coordinate, same number of elements as declination, normalized to be in the range <span>$[-90, 90]$</span>.</p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia">eqpole(100, 35, southpole=true)
# =&gt; (-111.18287262822456,-19.604540237028665)
eqpole(80, 19)
# =&gt; (72.78853915267848,12.83458333897169)</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/eqpole.jl#L14-L57" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.flux2mag" id="AstroLib.flux2mag"><code>AstroLib.flux2mag</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">flux2mag(flux[, zero_point, ABwave=number]) -&gt; magnitude</code></pre><p><strong>Purpose</strong></p><p>Convert from flux expressed in erg/(s cm² Å) to magnitudes.</p><p><strong>Explanation</strong></p><p>This is the reverse of <code>mag2flux</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>flux</code>: the flux to be converted in magnitude, expressed in erg/(s cm² Å).  It can be either a scalar or an array.</p></li><li><p><code>zero_point</code>: scalar giving the zero point level of the magnitude.  If not</p></li></ul><p>supplied then defaults to 21.1 (Code et al 1976).  Ignored if the <code>ABwave</code>  keyword is supplied</p><ul><li><p><code>ABwave</code> (optional numeric keyword): wavelength scalar or vector in Angstroms.</p></li></ul><p>If supplied, then returns Oke AB magnitudes (Oke &amp; Gunn 1983, ApJ, 266, 713;  http://adsabs.harvard.edu/abs/1983ApJ...266..713O).</p><p><strong>Output</strong></p><p>The magnitude.  It is of the same type, scalar or array, as <code>flux</code>.</p><p>If the <code>ABwave</code> keyword is set then magnitude is given by the expression</p><div>\[\text{ABmag} = -2.5\log_{10}(f) - 5\log_{10}(\text{ABwave}) - 2.406\]</div><p>Otherwise, magnitude is given by the expression</p><div>\[\text{mag} = -2.5\log_{10}(\text{flux}) - \text{zero point}\]</div><p><strong>Example</strong></p><pre><code class="language-julia">flux2mag(5.2e-15)
# =&gt; 14.609991640913002
flux2mag(5.2e-15, 15)
# =&gt; 20.709991640913003
flux2mag(5.2e-15, ABwave=15)
# =&gt; 27.423535345634598</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/flux2mag.jl#L12-L60" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.gal_uvw-NTuple{6,Real}" id="AstroLib.gal_uvw-NTuple{6,Real}"><code>AstroLib.gal_uvw</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">gal_uvw(ra, dec, pmra, pmdec, vrad, plx[, lsr=true]) -&gt; u, v, w</code></pre><p><strong>Purpose</strong></p><p>Calculate the Galactic space velocity <span>$(u, v, w)$</span> of a star.</p><p><strong>Explanation</strong></p><p>Calculates the Galactic space velocity <span>$(u, v, w)$</span> of a star given its (1) coordinates, (2) proper motion, (3) parallax, and (4) radial velocity.</p><p><strong>Arguments</strong></p><p>User must supply a position, proper motion, radial velocity and parallax. Either scalars or arrays all of the same length can be supplied.</p><p>(1) Position:</p><ul><li><p><code>ra</code>: right ascension, in degrees</p></li><li><p><code>dec</code>: declination, in degrees</p></li></ul><p>(2) Proper Motion</p><ul><li><p><code>pmra</code>: proper motion in right ascension in arc units (typically milli-arcseconds/yr).  If given <span>$\mu_\alpha$</span> – proper motion in seconds of time/year – then this is equal to <span>$15 \mu_\alpha cos(\text{dec})$</span>.</p></li><li><p><code>pmdec</code>: proper motion in declination (typically mas/yr).</p></li></ul><p>(3) Radial Velocity</p><ul><li><p><code>vrad</code>: velocity in km/s</p></li></ul><p>(4) Parallax</p><ul><li><p><code>plx</code>: parallax with same distance units as proper motion measurements typically milliarcseconds (mas)</p></li></ul><p>If you know the distance in parsecs, then set <code>plx</code> to <span>$1000/\text{distance}$</span>, if proper motion measurements are given in milli-arcseconds/yr.</p><p>There is an additional optional keyword:</p><ul><li><p><code>lsr</code> (optional boolean keyword): if this keyword is set to <code>true</code>, then the output velocities will be corrected for the solar motion <span>$(u, v, w)_\odot = (-8.5, 13.38, 6.49)$</span> (Coşkunoǧlu et al. 2011 MNRAS, 412, 1237; DOI:<a href="http://dx.doi.org/10.1111/j.1365-2966.2010.17983.x">10.1111/j.1365-2966.2010.17983.x</a>) to the local standard of rest (LSR).  Note that the value of the solar motion through the LSR remains poorly determined.</p></li></ul><p><strong>Output</strong></p><p>The 3-tuple <span>$(u, v, w)$</span></p><ul><li><p><span>$u$</span>: velocity (km/s) positive toward the Galactic <em>anti</em>center</p></li><li><p><span>$v$</span>: velocity (km/s) positive in the direction of Galactic rotation</p></li><li><p><span>$w$</span>: velocity (km/s) positive toward the North Galactic Pole</p></li></ul><p><strong>Method</strong></p><p>Follows the general outline of Johnson &amp; Soderblom (1987, AJ, 93, 864; DOI:<a href="http://dx.doi.org/10.1086/114370">10.1086/114370</a>) except that <span>$u$</span> is positive outward toward the Galactic <em>anti</em>center, and the J2000 transformation matrix to Galactic coordinates is taken from the introduction to the Hipparcos catalog.</p><p><strong>Example</strong></p><p>Compute the U,V,W coordinates for the halo star HD 6755.  Use values from Hipparcos catalog, and correct to the LSR.</p><pre><code class="language-julia">ra=ten(1,9,42.3)*15.; dec = ten(61,32,49.5);
pmra = 627.89;  pmdec = 77.84; # mas/yr
vrad = -321.4; dis = 129; # distance in parsecs
u, v, w = gal_uvw(ra, dec, pmra, pmdec, vrad, 1e3/dis, lsr=true)
# =&gt; (118.2110474553902,-466.4828898385057,88.16573278565097)</code></pre><p><strong>Notes</strong></p><p>This function does not take distance as input.  See "Arguments" section above for how to provide it using parallax argument.</p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/gal_uvw.jl#L33-L119" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.gcirc-Tuple{Integer,Real,Real,Real,Real}" id="AstroLib.gcirc-Tuple{Integer,Real,Real,Real,Real}"><code>AstroLib.gcirc</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">gcirc(units, ra1, dec1, ra2, dec2) -&gt; angular_distance</code></pre><p><strong>Purpose</strong></p><p>Computes rigorous great circle arc distances.</p><p><strong>Explanation</strong></p><p>Input position can be either radians, sexagesimal right ascension and declination, or degrees.</p><p><strong>Arguments</strong></p><ul><li><p><code>units</code>: integer, can be either 0, or 1, or 2.  Describes units of inputs and</p></li></ul><p>output:     * 0: everything (input right ascensions and declinations, and output       distance) is radians     * 1: right ascensions are in decimal hours, declinations in decimal degrees,       output distance in arc seconds     * 2: right ascensions and declinations are in degrees, output distance in arc       seconds</p><ul><li><p><code>ra1</code>:  right ascension or longitude of point 1</p></li><li><p><code>dec1</code>: declination or latitude of point 1</p></li><li><p><code>ra2</code>: right ascension or longitude of point 2</p></li><li><p><code>dec2</code>: declination or latitude of point 2</p></li></ul><p>Both <code>ra1</code> and <code>dec1</code>, and <code>ra2</code> and <code>dec2</code> can be given as 2-tuples <code>(ra1, dec1)</code> and <code>(ra2, dec2)</code>.</p><p><strong>Output</strong></p><p>Angular distance on the sky between points 1 and 2, as a <code>AbstractFloat</code>.  See <code>units</code> argument above for the units.</p><p><strong>Method</strong></p><p>"Haversine formula" see http://en.wikipedia.org/wiki/Great-circle_distance.</p><p><strong>Example</strong></p><pre><code class="language-julia">gcirc(0, 120, -43, 175, +22)
# =&gt; 1.590442261600714</code></pre><p><strong>Notes</strong></p><ul><li><p>If <code>ra1</code>, <code>dec1</code> are scalars, and <code>ra2</code>, <code>dec2</code> are vectors, then the output</p></li></ul><p>is a vector giving the distance of each element of <code>ra2</code>, <code>dec2</code> to <code>ra1</code>,  <code>dec1</code>.  Similarly, if <code>ra1</code>,<code>de1</code> are vectors, and <code>ra2</code>,<code>dec2</code> are scalars,  then the output is a vector giving the distance of each element of <code>ra1</code>,  <code>dec1</code> to <code>ra2</code>, <code>dec2</code>.  If both <code>ra1</code>, <code>dec1</code> and <code>ra2</code>, <code>dec2</code> are vectors  then the output is a vector giving the distance of each element of <code>ra1</code>,  <code>dec1</code> to the corresponding element of <code>ra2</code>, <code>dec2</code>.</p><ul><li><p>The function <code>sphdist</code> provides an alternate method of computing a spherical</p></li></ul><p>distance.</p><ul><li><p>The Haversine formula can give rounding errors for antipodal points.</p></li></ul><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/gcirc.jl#L38-L98" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.geo2eci-NTuple{4,Real}" id="AstroLib.geo2eci-NTuple{4,Real}"><code>AstroLib.geo2eci</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">geo2eci(latitude, longitude, altitude, jd) -&gt; x, y, z</code></pre><p><strong>Purpose</strong></p><p>Convert geographic spherical coordinates to Earth-centered inertial coordinates.</p><p><strong>Explanation</strong></p><p>Converts from geographic spherical coordinates (latitude, longitude, altitude) to ECI (Earth-Centered Inertial) (x, y, z) rectangular coordinates.  Julian days is also needed.</p><p>Geographic coordinates assume the Earth is a perfect sphere, with radius equal to its equatorial radius.  ECI coordinates are in km from Earth center at epoch TOD (True of Date).</p><p><strong>Arguments</strong></p><ul><li><p><code>latitude</code>: geographic latitude, in degrees.</p></li><li><p><code>longitude</code>: geographic longitude, in degrees.</p></li><li><p><code>altitude</code>: geographic altitude, in kilometers.</p></li><li><p><code>jd</code>: Julian days.</p></li></ul><p>The three coordinates can be passed as a 3-tuple <code>(latitude, longitude, altitude)</code>.  In addition, <code>latitude</code>, <code>longitude</code>, <code>altitude</code>, and <code>jd</code> can be given as arrays of the same length.</p><p><strong>Output</strong></p><p>The 3-tuple of ECI (x, y, z) coordinates, in kilometers.  The TOD epoch is the supplied <code>jd</code> time.</p><p>If geographical coordinates are given as arrays, a 3-tuple of arrays of the same length is returned.</p><p><strong>Example</strong></p><p>Obtain the ECI coordinates of the intersection of the equator and Greenwich's meridian on 2015-06-30T14:03:12.857</p><pre><code class="language-julia">geo2eci(0, 0, 0, jdcnv("2015-06-30T14:03:12.857"))
# =&gt; (-4024.8671780315185,4947.835465127513,0.0)</code></pre><p><strong>Notes</strong></p><p><code>eci2geo</code> converts Earth-centered inertial coordinates to geographic spherical coordinates.</p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/geo2eci.jl#L16-L68" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.geo2geodetic-NTuple{5,Real}" id="AstroLib.geo2geodetic-NTuple{5,Real}"><code>AstroLib.geo2geodetic</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">geo2geodetic(latitude, longitude, altitude) -&gt; latitude, longitude, altitude
geo2geodetic(latitude, longitude, altitude, planet) -&gt; latitude, longitude, altitude
geo2geodetic(latitude, longitude, altitude, equatorial_radius, polar_radius) -&gt; latitude, longitude, altitude</code></pre><p><strong>Purpose</strong></p><p>Convert from geographic (or planetographic) to geodetic coordinates.</p><p><strong>Explanation</strong></p><p>Converts from geographic (latitude, longitude, altitude) to geodetic (latitude, longitude, altitude).  In geographic coordinates, the Earth is assumed a perfect sphere with a radius equal to its equatorial radius.  The geodetic (or ellipsoidal) coordinate system takes into account the Earth's oblateness.</p><p>Geographic and geodetic longitudes are identical.  Geodetic latitude is the angle between local zenith and the equatorial plane.  Geographic and geodetic altitudes are both the closest distance between the satellite and the ground.</p><p><strong>Arguments</strong></p><p>The function has two base methods.  The arguments common to all methods and always mandatory are <code>latitude</code>, <code>longitude</code>, and <code>altitude</code>:</p><ul><li><p><code>latitude</code>: geographic latitude, in degrees.</p></li><li><p><code>longitude</code>: geographic longitude, in degrees.</p></li><li><p><code>altitude</code>: geographic altitude, in kilometers.</p></li></ul><p>In order to convert to geodetic coordinates, you can either provide custom equatorial and polar radii of the planet or use the values of one of the planets of Solar System (Pluto included).</p><p>If you want to use the method with explicit equatorial and polar radii the additional mandatory arguments are:</p><ul><li><p><code>equatorial_radius</code>: value of the equatorial radius of the body, in kilometers.</p></li><li><p><code>polar_radius</code>: value of the polar radius of the body, in kilometers.</p></li></ul><p>Instead, if you want to use the method with the selection of a planet, the only additional argument is the planet name:</p><ul><li><p><code>planet</code> (optional string argument): string with the name of the Solar System planet, from "Mercury" to "Pluto".  If omitted (so, when only <code>latitude</code>, <code>longitude</code>, and <code>altitude</code> are provided), the default is "Earth".</p></li></ul><p>In all cases, the three coordinates can be passed as a 3-tuple <code>(latitude, longitude, altitude)</code>.  In addition, geographical <code>latitude</code>, <code>longitude</code>, and <code>altitude</code> can be given as arrays of the same length.</p><p><strong>Output</strong></p><p>The 3-tuple <code>(latitude, longitude, altitude)</code> in geodetic coordinates, for the body with specified equatorial and polar radii (Earth by default).</p><p>If geographical coordinates are given as arrays, a 3-tuple of arrays of the same length is returned.</p><p><strong>Method</strong></p><p>Stephen P.  Keeler and Yves Nievergelt, "Computing geodetic coordinates", SIAM Rev. Vol. 40, No. 2, pp. 300-309, June 1998 (DOI:<a href="http://dx.doi.org/10.1137/S0036144597323921">10.1137/S0036144597323921</a>).</p><p>Planetary constants are from Planetary Fact Sheet (http://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html).</p><p><strong>Example</strong></p><p>Locate the Earth geographic North pole (latitude: 90°, longitude: 0°, altitude 0 km), in geodetic coordinates:</p><pre><code class="language-julia">geo2geodetic(90, 0, 0)
# =&gt; (90.0,0.0,21.38499999999931)</code></pre><p>The same for Jupiter:</p><pre><code class="language-julia">geo2geodetic(90, 0, 0, "Jupiter")
# =&gt; (90.0,0.0,4355.443799999994)</code></pre><p>Find geodetic coordinates for point of geographic coordinates (latitude, longitude, altitude) = (43.16°, -24.32°, 3.87 km) on a planet with equatorial radius 8724.32 km and polar radius 8619.19 km:</p><pre><code class="language-julia">geo2geodetic(43.16, -24.32, 3.87, 8724.32, 8619.19)
# =&gt; (43.849399515234516,-24.32,53.53354478670836)</code></pre><p><strong>Notes</strong></p><p>Whereas the conversion from geodetic to geographic coordinates is given by an exact, analytical formula, the conversion from geographic to geodetic isn't. Approximative iterations (as used here) exist, but tend to become less good with increasing eccentricity and altitude.  The formula used in this routine should give correct results within six digits for all spatial locations, for an ellipsoid (planet) with an eccentricity similar to or less than Earth's.  More accurate results can be obtained via calculus, needing a non-determined amount of iterations.</p><p>In any case, the function <code>geodetic2geo</code>, which converts from geodetic (or planetodetic) to geographic coordinates, can be used to estimate the accuracy of <code>geo2geodetic</code>.</p><pre><code class="language-julia">collect(geodetic2geo(geo2geodetic(67.2, 13.4, 1.2))) - [67.2, 13.4, 1.2]
# =&gt; 3-element Array{Float64,1}:
#     -3.56724e-9
#      0.0
#      9.47512e-10</code></pre><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/geo2geodetic.jl#L25-L143" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.geo2mag" id="AstroLib.geo2mag"><code>AstroLib.geo2mag</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">geo2mag(latitude, longitude[, year]) -&gt; geomagnetic_latitude, geomagnetic_longitude</code></pre><p><strong>Purpose</strong></p><p>Convert from geographic to geomagnetic coordinates.</p><p><strong>Explanation</strong></p><p>Converts from geographic (latitude, longitude) to geomagnetic (latitude, longitude).  Altitude is not involved in this function.</p><p><strong>Arguments</strong></p><ul><li><p><code>latitude</code>: geographic latitude (North), in degrees.</p></li><li><p><code>longitude</code>: geographic longitude (East), in degrees.</p></li><li><p><code>year</code> (optional numerical argument): the year in which to perform conversion. If omitted, defaults to current year.</p></li></ul><p>The coordinates can be passed as arrays of the same length.</p><p><strong>Output</strong></p><p>The 2-tuple of magnetic (latitude, longitude) coordinates, in degrees.</p><p>If geographical coordinates are given as arrays, a 2-tuple of arrays of the same length is returned.</p><p><strong>Example</strong></p><p>Kyoto has geographic coordinates 35° 00' 42'' N, 135° 46' 06'' E, find its geomagnetic coordinates in 2016:</p><pre><code class="language-julia">geo2mag(ten(35,0,42), ten(135,46,6), 2016)
# =&gt; (36.86579228937769,-60.184060536651614)</code></pre><p><strong>Notes</strong></p><p>This function uses list of North Magnetic Pole positions provided by World Magnetic Model (https://www.ngdc.noaa.gov/geomag/data/poles/NP.xy).</p><p><code>mag2geo</code> converts geomagnetical coordinates to geographic coordinates.</p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/geo2mag.jl#L37-L83" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.geodetic2geo-NTuple{5,Real}" id="AstroLib.geodetic2geo-NTuple{5,Real}"><code>AstroLib.geodetic2geo</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">geodetic2geo(latitude, longitude, altitude) -&gt; latitude, longitude, altitude
geodetic2geo(latitude, longitude, altitude, planet) -&gt; latitude, longitude, altitude
geodetic2geo(latitude, longitude, altitude, equatorial_radius, polar_radius) -&gt; latitude, longitude, altitude</code></pre><p><strong>Purpose</strong></p><p>Convert from geodetic (or planetodetic) to geographic coordinates.</p><p><strong>Explanation</strong></p><p>Converts from geodetic (latitude, longitude, altitude) to geographic (latitude, longitude, altitude).  In geographic coordinates, the Earth is assumed a perfect sphere with a radius equal to its equatorial radius.  The geodetic (or ellipsoidal) coordinate system takes into account the Earth's oblateness.</p><p>Geographic and geodetic longitudes are identical.  Geodetic latitude is the angle between local zenith and the equatorial plane.  Geographic and geodetic altitudes are both the closest distance between the satellite and the ground.</p><p><strong>Arguments</strong></p><p>The function has two base methods.  The arguments common to all methods and always mandatory are <code>latitude</code>, <code>longitude</code>, and <code>altitude</code>:</p><ul><li><p><code>latitude</code>: geodetic latitude, in degrees.</p></li><li><p><code>longitude</code>: geodetic longitude, in degrees.</p></li><li><p><code>altitude</code>: geodetic altitude, in kilometers.</p></li></ul><p>In order to convert to geographic coordinates, you can either provide custom equatorial and polar radii of the planet or use the values of one of the planets of Solar System (Pluto included).</p><p>If you want to use the method with explicit equatorial and polar radii the additional mandatory arguments are:</p><ul><li><p><code>equatorial_radius</code>: value of the equatorial radius of the body, in kilometers.</p></li><li><p><code>polar_radius</code>: value of the polar radius of the body, in kilometers.</p></li></ul><p>Instead, if you want to use the method with the selection of a planet, the only additional argument is the planet name:</p><ul><li><p><code>planet</code> (optional string argument): string with the name of the Solar System planet, from "Mercury" to "Pluto".  If omitted (so, when only <code>latitude</code>, <code>longitude</code>, and <code>altitude</code> are provided), the default is "Earth".</p></li></ul><p>In all cases, the three coordinates can be passed as a 3-tuple <code>(latitude, longitude, altitude)</code>.  In addition, geodetic <code>latitude</code>, <code>longitude</code>, and <code>altitude</code> can be given as arrays of the same length.</p><p><strong>Output</strong></p><p>The 3-tuple <code>(latitude, longitude, altitude)</code> in geographic coordinates, for the body with specified equatorial and polar radii (Earth by default).</p><p>If geodetic coordinates are given as arrays, a 3-tuple of arrays of the same length is returned.</p><p><strong>Method</strong></p><p>Stephen P.  Keeler and Yves Nievergelt, "Computing geodetic coordinates", SIAM Rev. Vol. 40, No. 2, pp. 300-309, June 1998 (DOI:<a href="http://dx.doi.org/10.1137/S0036144597323921">10.1137/S0036144597323921</a>).</p><p>Planetary constants from "Allen's Astrophysical Quantities", Fourth Ed., (2000).</p><p><strong>Example</strong></p><p>Find geographic coordinates of geodetic North pole (latitude: 90°, longitude: 0°, altitude 0 km) of the Earth:</p><pre><code class="language-julia">geodetic2geo(90, 0, 0)
# =&gt; (90.0,0.0,-21.38499999999931)</code></pre><p>The same for Jupiter:</p><pre><code class="language-julia">geodetic2geo(90, 0, 0, "Jupiter")
# =&gt; (90.0,0.0,-4355.443799999994)</code></pre><p>Find geographic coordinates for point of geodetic coordinates (latitude, longitude, altitude) = (43.16°, -24.32°, 3.87 km) on a planet with equatorial radius 8724.32 km and polar radius 8619.19 km:</p><pre><code class="language-julia">geodetic2geo(43.16, -24.32, 3.87, 8724.32, 8619.19)
# =&gt; (42.46772711708433,-24.32,-44.52902080669082)</code></pre><p><strong>Notes</strong></p><p><code>geo2geodetic</code> converts from geographic (or planetographic) to geodetic coordinates.</p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/geodetic2geo.jl#L13-L112" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.get_date-Tuple{DateTime,Bool,Bool}" id="AstroLib.get_date-Tuple{DateTime,Bool,Bool}"><code>AstroLib.get_date</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">get_date([date, old=true, timetag=true]) -&gt; string</code></pre><p><strong>Purpose</strong></p><p>Returns the UTC date in <code>"CCYY-MM-DD"</code> format for FITS headers.</p><p><strong>Explanation</strong></p><p>This is the format required by the <code>DATE</code> and <code>DATE-OBS</code> keywords in a FITS header.</p><p><strong>Argument</strong></p><ul><li><p><code>date</code> (optional): the date in UTC standard.  If omitted, defaults to the current UTC time.  It can be either a single date or an array of dates.  Each element can be either a <code>DateTime</code> type or anything that can be converted to that type.  In the case of vectorial input, each element is considered as a date, so you cannot provide a date by parts.</p></li><li><p><code>old</code> (optional boolean keyword): see below.</p></li><li><p><code>timetag</code> (optional boolean keyword): see below.</p></li></ul><p><strong>Output</strong></p><p>A string with the date formatted according to the given optional keywords.</p><ul><li><p>When no optional keywords (<code>timetag</code> and <code>old</code>) are supplied, the format of the output string is <code>"CCYY-MM-DD"</code> (year-month-day part of the date), where <code>CCYY</code> represents a 4-digit calendar year, <code>MM</code> the 2-digit ordinal number of a calendar month within the calendar year, and <code>DD</code> the 2-digit ordinal number of a day within the calendar month.</p></li><li><p>If the boolean keyword <code>old</code> is true (default: false), the year-month-day part of date has <code>"DD/MM/YY"</code> format.  This is the formerly (pre-1997) recommended for FITS.  Note that this format is now deprecated because it uses only a 2-digit representation of the year.</p></li><li><p>If the boolean keyword <code>timetag</code> is true (default: false), <code>"Thh:mm:ss"</code> is appended to the year-month-day part of the date, where &lt;hh&gt; represents the hour in the day, &lt;mm&gt; the minutes, &lt;ss&gt; the seconds, and the literal 'T' the ISO 8601 time designator.</p></li></ul><p>Note that <code>old</code> and <code>timetag</code> keywords can be used together, so that the output string will have <code>"DD/MM/YYThh:mm:ss"</code> format.</p><p><strong>Example</strong></p><pre><code class="language-julia">get_date(timetag=true)
# =&gt; "2016-03-14T11:26:23"</code></pre><p><strong>Notes</strong></p><ol><li><p>A discussion of the DATExxx syntax in FITS headers can be found in</p></li></ol><p>http://www.cv.nrao.edu/fits/documents/standards/year2000.txt</p><ol><li><p>Those who wish to use need further flexibility in their date formats (e.g. to</p></li></ol><p>use TAI time) should look at Bill Thompson's time routines in  http://sohowww.nascom.nasa.gov/solarsoft/gen/idl/time</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/get_date.jl#L4-L62" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.get_juldate-Tuple{}" id="AstroLib.get_juldate-Tuple{}"><code>AstroLib.get_juldate</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">get_juldate() -&gt; julian_days</code></pre><p><strong>Purpose</strong></p><p>Return the number of Julian days for current time.</p><p><strong>Explanation</strong></p><p>Return for current time the number of Julian calendar days since epoch <code>-4713-11-24T12:00:00</code> as a floating point.</p><p><strong>Example</strong></p><pre><code class="language-julia">get_juldate()
daycnv(get_juldate())</code></pre><p><strong>Notes</strong></p><p>Use <code>jdcnv</code> to get the number of Julian days for a different date.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/get_juldate.jl#L4-L25" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.hadec2altaz-Tuple{Real,Real,Real}" id="AstroLib.hadec2altaz-Tuple{Real,Real,Real}"><code>AstroLib.hadec2altaz</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">hadec2altaz(ha, dec, lat[, ws=true]) -&gt; alt, az</code></pre><p><strong>Purpose</strong></p><p>Convert Hour Angle and Declination to Horizon (Alt-Az) coordinates.</p><p><strong>Explanation</strong></p><p>Can deal with the NCP singularity.  Intended mainly to be used by program <code>eq2hor</code>.</p><p><strong>Arguments</strong></p><p>Input coordinates may be either a scalar or an array, of the same dimension.</p><ul><li><p><code>ha</code>: the local apparent hour angle, in degrees.  The hour angle is the time that right ascension of 0 hours crosses the local meridian.  It is unambiguously defined.</p></li><li><p><code>dec</code>: the local apparent declination, in degrees.</p></li><li><p><code>lat</code>: the local geodetic latitude, in degrees, scalar or array.</p></li><li><p><code>ws</code> (optional boolean keyword): if true, the output azimuth is measured West from South.  The default is to measure azimuth East from North.</p></li></ul><p><code>ha</code> and <code>dec</code> can be given as a 2-tuple <code>(ha, dec)</code>.</p><p><strong>Output</strong></p><p>2-tuple <code>(alt, az)</code></p><ul><li><p><code>alt</code>: local apparent altitude, in degrees.</p></li><li><p><code>az</code>: the local apparent azimuth, in degrees.</p></li></ul><p>The output coordinates are always floating points and have the same type (scalar or array) as the input coordinates.</p><p><strong>Example</strong></p><p>Arcturus is observed at an apparent hour angle of 336.6829 and a declination of 19.1825 while at the latitude of +43° 4' 42''.  What are the local altitude and azimuth of this object?</p><pre><code class="language-julia">alt, az = hadec2altaz(336.6829, 19.1825, ten(43, 4, 42))
# =&gt; (59.08617155005683,133.3080693440254)</code></pre><p><strong>Notes</strong></p><p><code>altaz2hadec</code> converts Horizon (Alt-Az) coordinates to Hour Angle and Declination.</p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/hadec2altaz.jl#L27-L80" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.helio_jd-Tuple{Real,Real,Real}" id="AstroLib.helio_jd-Tuple{Real,Real,Real}"><code>AstroLib.helio_jd</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">helio_jd(date, ra, dec[, B1950=true, diff=false]) -&gt; jd_helio
helio_jd(date, ra, dec[, B1950=true, diff=true]) -&gt; time_diff</code></pre><p><strong>Purpose</strong></p><p>Convert geocentric (reduced) Julian date to heliocentric Julian date.</p><p><strong>Explanation</strong></p><p>This procedure corrects for the extra light travel time between the Earth and the Sun.</p><p>An online calculator for this quantity is available at http://www.physics.sfasu.edu/astro/javascript/hjd.html</p><p>Users requiring more precise calculations and documentation should look at the IDL code available at http://astroutils.astronomy.ohio-state.edu/time/</p><p><strong>Arguments</strong></p><ul><li><p><code>date</code>: reduced Julian date (= JD - 2400000), it can be either a scalar or vector.  You can use <code>juldate()</code> to calculate the reduced Julian date.</p></li><li><p><code>ra</code> and <code>dec</code>: scalars giving right ascension and declination in degrees. Default equinox is J2000.</p></li><li><p><code>B1950</code> (optional boolean keyword): if set to <code>true</code>, then input coordinates are assumed to be in equinox B1950 coordinates.  Default is <code>false</code>.</p></li><li><p><code>diff</code> (optional boolean keyword): if set to <code>true</code>, the function returns the time difference (heliocentric JD - geocentric JD) in seconds.  Default is <code>false</code>.</p></li></ul><p><strong>Output</strong></p><p>The return value depends on the value of <code>diff</code> optional keywords:</p><ul><li><p>if <code>diff</code> is <code>false</code> (default), then the heliocentric reduced Julian date is returned.</p></li><li><p>if <code>diff</code> is <code>true</code>, then the time difference in seconds between the geocentric and heliocentric Julian date is returned.</p></li></ul><p><strong>Example</strong></p><p>What is the heliocentric Julian date of an observation of V402 Cygni (J2000: RA = 20 9 7.8, Dec = 37 09 07) taken on June 15, 2016 at 11:40 UT?</p><pre><code class="language-julia">jd = juldate(2016, 6, 15, 11, 40);
helio_jd(jd, ten(20, 9, 7.8)*15, ten(37, 9, 7))
# =&gt; 57554.98808289718</code></pre><p><strong>Notes</strong></p><p>Wayne Warren (Raytheon ITSS) has compared the results of this algorithm with the FORTRAN subroutines in the STARLINK SLALIB library (see http://star-www.rl.ac.uk/).</p><pre><code class="language-none">                                                 Time Diff (sec)
     Date               RA(2000)   Dec(2000)  STARLINK      IDL

1999-10-29T00:00:00.0  21 08 25.  -67 22 00.  -59.0        -59.0
1999-10-29T00:00:00.0  02 56 33.4 +00 26 55.  474.1        474.1
1940-12-11T06:55:00.0  07 34 41.9 -00 30 42.  366.3        370.2
1992-02-29T03:15:56.2  12 56 27.4 +42 10 17.  350.8        350.9
2000-03-01T10:26:31.8  14 28 36.7 -20 42 11.  243.7        243.7
2100-02-26T09:18:24.2  08 26 51.7 +85 47 28.  104.0        108.8</code></pre><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/helio_jd.jl#L25-L95" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.helio_rv" id="AstroLib.helio_rv"><code>AstroLib.helio_rv</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">helio_rv(jd, T, P, V_0, K[, e, ω]) -&gt; rv</code></pre><p><strong>Purpose</strong></p><p>Return the heliocentric radial velocity of a spectroscopic binary.</p><p><strong>Explanation</strong></p><p>This function will return the heliocentric radial velocity of a spectroscopic binary star at a given heliocentric date given its orbit.</p><p><strong>Arguments</strong></p><ul><li><p><code>jd</code>: time of observation, as number of Julian days.  It can be either a scalar or an array.</p></li><li><p><code>T</code>: time of periastron passage (max. +ve velocity for circular orbits), same time system as <code>jd</code></p></li><li><p><code>P</code>: the orbital period in same units as <code>jd</code></p></li><li><p><code>V_0</code>: systemic velocity</p></li><li><p><code>K</code>: velocity semi-amplitude in the same units as <code>V_0</code></p></li><li><p><code>e</code>: eccentricity of the orbit.  It defaults to 0 if omitted</p></li><li><p><code>ω</code>: longitude of periastron in degrees.  It defaults to 0 if omitted</p></li></ul><p><strong>Output</strong></p><p>The predicted heliocentric radial velocity in the same units as Gamma for the date(s) specified by <code>jd</code>.  It is a scalar or an array depending on the type of<code>jd</code>.</p><p><strong>Example</strong></p><p>(1) What was the heliocentric radial velocity of the primary component of HU Tau at 1730 UT 25 Oct 1994?</p><pre><code class="language-julia">jd = juldate(94, 10, 25, 17, 30); # Obtain Geocentric Julian days
hjd = helio_jd(jd, ten(04, 38, 16)*15, ten(20, 41, 05)); # Convert to HJD
helio_rv(hjd, 46487.5303, 2.0563056, -6, 59.3)
# =&gt; -62.965570109145034</code></pre><p>NB: the functions <code>juldate</code> and <code>helio_jd</code> return a reduced HJD (HJD - 2400000) and so T and P must be specified in the same fashion.</p><p>(2) Plot two cycles of an eccentric orbit, <span>$e=0.6$</span>, <span>$\omega=45\degree$</span> for both components of a binary star.  Use <a href="https://github.com/stevengj/PyPlot.jl">PyPlot.jl</a> for plotting.</p><pre><code class="language-julia">using PyPlot
φ = linspace(0, 2, 1000); # Generate 1000 phase points
plot(φ ,helio_rv(φ, 0, 1, 0, 100, 0.6, 45)) # Plot 1st component
plot(φ ,helio_rv(φ, 0, 1, 0, 100, 0.6, 45+180)) # Plot 2nd component</code></pre><p><strong>Notes</strong></p><p>The user should ensure consistency with all time systems being used (i.e. <code>jd</code> and <code>t</code> should be in the same units and time system).  Generally, users should reduce large time values by subtracting a large constant offset, which may improve numerical accuracy.</p><p>If using the the function <code>juldate</code> and <code>helio_jd</code>, the reduced HJD time system must be used throughtout.</p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/helio_rv.jl#L11-L77" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.jdcnv" id="AstroLib.jdcnv"><code>AstroLib.jdcnv</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">jdcnv(date) -&gt; julian_days</code></pre><p><strong>Purpose</strong></p><p>Convert proleptic Gregorian Calendar date in UTC standard to number of Julian days.</p><p><strong>Explanation</strong></p><p>Takes the given proleptic Gregorian date in UTC standard and returns the number of Julian calendar days since epoch <code>-4713-11-24T12:00:00</code>.</p><p><strong>Argument</strong></p><ul><li><p><code>date</code>: date in proleptic Gregorian Calendar.  Can be either a single date or an array of dates.  Each element can be either a <code>DateTime</code> type or anything that can be converted directly to <code>DateTime</code>.  In the case of vectorial input, each element is considered as a date, so you cannot provide a date by parts.</p></li></ul><p><strong>Output</strong></p><p>Number of Julian days, as a floating point.</p><p><strong>Example</strong></p><p>Find the Julian days number at 2016 August 23, 03:39:06.</p><pre><code class="language-julia">jdcnv(DateTime(2016, 08, 23, 03, 39, 06))
# =&gt; 2.4576236521527776e6
jdcnv(2016, 08, 23, 03, 39, 06)
# =&gt; 2.4576236521527776e6
jdcnv("2016-08-23T03:39:06")
# =&gt; 2.4576236521527776e6</code></pre><p><strong>Notes</strong></p><p>This is the inverse of <code>daycnv</code>.</p><p><code>get_juldate</code> returns the number of Julian days for current time.  It is equivalent to <code>jdcnv(now(Dates.UTC))</code>.</p><p>For the conversion of Julian date to number of Julian days, use <code>juldate</code>.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/jdcnv.jl#L4-L49" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.jprecess" id="AstroLib.jprecess"><code>AstroLib.jprecess</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">jprecess(ra, dec[, epoch]) -&gt; ra2000, dec2000
jprecess(ra, dec, muradec[, parallax=parallax, radvel=radvel]) -&gt; ra2000, dec2000</code></pre><p><strong>Purpose</strong></p><p>Precess positions from B1950.0 (FK4) to J2000.0 (FK5).</p><p><strong>Explanation</strong></p><p>Calculate the mean place of a star at J2000.0 on the FK5 system from the mean place at B1950.0 on the FK4 system.</p><p><code>jprecess</code> function has two methods, one for each of the following cases:</p><ul><li><p>the proper motion is known and non-zero</p></li><li><p>the proper motion is unknown or known to be exactly zero (i.e. extragalactic radio sources).  Better precision can be achieved in this case by inputting the epoch of the original observations.</p></li></ul><p><strong>Arguments</strong></p><p>The function has 2 methods.  The common mandatory arguments are:</p><ul><li><p><code>ra</code>: input B1950 right ascension, in degrees.</p></li><li><p><code>dec</code>: input B1950 declination, in degrees.</p></li></ul><p>The two methods have a different third argument (see "Explanation" section for more details).  It can be one of the following:</p><ul><li><p><code>muradec</code>: 2-element vector containing the proper motion in seconds of arc per tropical <em>century</em> in right ascension and declination.</p></li><li><p><code>epoch</code>: scalar giving epoch of original observations.</p></li></ul><p>If none of these two arguments is provided (so <code>jprecess</code> is fed only with right ascension and declination), it is assumed that proper motion is exactly zero and <code>epoch = 1950</code>.</p><p>If it is used the method involving <code>muradec</code> argument, the following keywords are available:</p><ul><li><p><code>parallax</code> (optional numerical keyword): stellar parallax, in seconds of arc.</p></li><li><p><code>radvel</code> (optional numerical keyword): radial velocity in km/s.</p></li></ul><p>Right ascension and declination can be passed as the 2-tuple <code>(ra, dec)</code>.  You can also pass <code>ra</code>, <code>dec</code>, <code>parallax</code>, and <code>radvel</code> as arrays, all of the same length N.  In that case, <code>muradec</code> should be a matrix 2×N.</p><p><strong>Output</strong></p><p>The 2-tuple of right ascension and declination in 2000, in degrees, of input coordinates is returned.  If <code>ra</code> and <code>dec</code> (and other possible optional arguments) are arrays, the 2-tuple of arrays <code>(ra2000, dec2000)</code> of the same length as the input coordinates is returned.</p><p><strong>Method</strong></p><p>The algorithm is taken from the Explanatory Supplement to the Astronomical Almanac 1992, page 184.  See also Aoki et al (1983), A&amp;A, 128, 263.  URL: http://adsabs.harvard.edu/abs/1983A%26A...128..263A.</p><p><strong>Example</strong></p><p>The SAO catalogue gives the B1950 position and proper motion for the  star HD 119288.   Find the J2000 position. </p><ul><li><p>RA(1950) = 13h 39m 44.526s</p></li><li><p>Dec(1950) = 8d 38' 28.63''</p></li><li><p>Mu(RA) = -.0259 s/yr</p></li><li><p>Mu(Dec) = -.093 ''/yr</p></li></ul><pre><code class="language-julia">muradec = 100*[-15*0.0259, -0.093]; # convert to century proper motion
ra = ten(13, 39, 44.526)*15;
decl = ten(8, 38, 28.63);
adstring(jprecess(ra, decl, muradec), precision=2)
# =&gt; " 13 42 12.740  +08 23 17.69"</code></pre><p><strong>Notes</strong></p><p>"When transferring individual observations, as opposed to catalog mean place, the safest method is to tranform the observations back to the epoch of the observation, on the FK4 system (or in the system that was used to to produce the observed mean place), convert to the FK5 system, and transform to the the epoch and equinox of J2000.0" – from the Explanatory Supplement (1992), p. 180</p><p><code>bprecess</code> performs the precession to B1950 coordinates.</p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/jprecess.jl#L126-L216" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.juldate-Tuple{DateTime}" id="AstroLib.juldate-Tuple{DateTime}"><code>AstroLib.juldate</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">juldate(date::DateTime) -&gt; reduced_julia_days</code></pre><p><strong>Purpose</strong></p><p>Convert from calendar to Reduced Julian Days.</p><p><strong>Explanation</strong></p><p>Julian Day Number is a count of days elapsed since Greenwich mean noon on 1 January 4713 B.C.  Julian Days are the number of Julian days followed by the fraction of the day elapsed since the preceding noon.</p><p>This function takes the given <code>date</code> and returns the number of Julian calendar days since epoch <code>1858-11-16T12:00:00</code> (Reduced Julian Days = Julian Days - 2400000).</p><p><strong>Argument</strong></p><ul><li><p><code>date</code>: date in Julian Calendar, UTC standard.  It can be either e single date or an array of dates.  Each element can be given in <code>DateTime</code> type or anything that can be converted to that type.  In the case of vectorial input, each element is considered as a date, so you cannot provide a date by parts.</p></li></ul><p><strong>Output</strong></p><p>The number of Reduced Julian Days is returned.  If <code>date</code> is an array, an array of the same length as <code>date</code> is returned.</p><p><strong>Example</strong></p><p>Get number of Reduced Julian Days at 2016-03-20T15:24:00.</p><pre><code class="language-julia">juldate(DateTime(2016, 03, 20, 15, 24))
# =&gt; 57468.14166666667
juldate(2016, 03, 20, 15, 24)
# =&gt; 57468.14166666667
juldate("2016-03-20T15:24")
# =&gt; 57468.14166666667</code></pre><p><strong>Notes</strong></p><p>Julian Calendar is assumed, thus before <code>1582-10-15T00:00:00</code> this function is <em>not</em> the inverse of <code>daycnv</code>.  For the conversion proleptic Gregorian date to number of Julian days, use <code>jdcnv</code>, which is the inverse of <code>daycnv</code>.</p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/juldate.jl#L4-L53" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.kepler_solver-Tuple{Real,Real}" id="AstroLib.kepler_solver-Tuple{Real,Real}"><code>AstroLib.kepler_solver</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">kepler_solver(M, e) -&gt; E</code></pre><p><strong>Purpose</strong></p><p>Solve Kepler's equation in the elliptic motion regime (<span>$0 \leq e \leq 1$</span>) and return eccentric anomaly <span>$E$</span>.</p><p><strong>Explanation</strong></p><p>In order to find the position of a body in elliptic motion (e.g., in the two-body problem) at a given time <span>$t$</span>, one has to solve the <a href="https://en.wikipedia.org/wiki/Kepler%27s_equation">Kepler's equation</a></p><p><span>$M(t) = E(t) - e\sin E(t)$</span></p><p>where <span>$M(t) = (t - t_{0})/P$</span> is the mean anomaly, <span>$E(t)$</span> the eccentric anomaly, <span>$e$</span> the eccentricity of the orbit, <span>$t_0$</span> is the time of periapsis passage, and <span>$P$</span> is the period of the orbit.  Usually the eccentricity is given and one wants to find the eccentric anomaly <span>$E(t)$</span> at a specific time <span>$t$</span>, so that also the mean anomaly <span>$M(t)$</span> is known.</p><p><strong>Arguments</strong></p><ul><li><p><code>M</code>: mean anomaly.  This can be either a scalar or an array</p></li><li><p><code>e</code>: eccentricity, in the elliptic motion regime (<span>$0 \leq e \leq 1$</span>)</p></li></ul><p><strong>Output</strong></p><p>The eccentric anomaly <span>$E$</span>, restricted to the range <span>$[-\pi, \pi]$</span>.  If an array of mean anomalies is provided in input, an array of the same length as <code>M</code> is returned.</p><p><strong>Method</strong></p><p>Many different numerical methods exist to solve Kepler's equation.  This function implements the algorithm proposed in Markley (1995) Celestial Mechanics and Dynamical Astronomy, 63, 101 (DOI:<a href="http://dx.doi.org/10.1007/BF00691917">10.1007/BF00691917</a>).  This method is not iterative, requires only four transcendental function evaluations, and has been proved to be fast and efficient over the entire range of elliptic motion <span>$0 \leq e \leq 1$</span>.</p><p><strong>Example</strong></p><p>(1) Find the eccentric anomaly for an orbit with eccentricity <span>$e = 0.7$</span> and for <span>$M(t) = 8\pi/3$</span>.</p><pre><code class="language-julia">ecc = 0.7;
E = kepler_solver(8pi/3, ecc)
# =&gt; 2.5085279492864223</code></pre><p>(2) Plot the eccentric anomaly as a function of mean anomaly for eccentricity <span>$e = 0$</span>, <span>$0.5$</span>, <span>$0.9$</span>.  Recall that <code>kepler_solver</code> gives <span>$E \in [-\pi, \pi]$</span>, use <code>cirrange</code> to have it in <span>$[0, 2\pi]$</span>.  Use <a href="https://github.com/stevengj/PyPlot.jl">PyPlot.jl</a> for plotting.</p><pre><code class="language-julia">using PyPlot
M=linspace(0, 2pi, 1001)[1:end-1];
for ecc in (0, 0.5, 0.9); plot(M, cirrange(kepler_solver(M, ecc), 2pi)); end</code></pre><p><strong>Notes</strong></p><p>The true anomaly can be calculated with <code>trueanom</code> function.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/kepler_solver.jl#L47-L115" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.lsf_rotate" id="AstroLib.lsf_rotate"><code>AstroLib.lsf_rotate</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lsf_rotate(delta_v, v_sin_i[, epsilon = 0.3]) -&gt; velocity_grid, lsf</code></pre><p><strong>Purpose</strong></p><p>Create a 1-d convolution kernel to broaden a spectrum from a rotating star.</p><p><strong>Explanation</strong></p><p>Can be used to derive the broadening effect (LSF, line spread function) due to rotation on a synthetic stellar spectrum.  Assumes constant limb darkening across the disk.</p><p><strong>Arguments</strong></p><ul><li><p><code>delta_v</code>: numeric scalar giving the step increment (in km/s) in the output rotation kernel</p></li><li><p><code>v_sin_i</code>: the rotational velocity projected along the line of sight (km/s)</p></li><li><p><code>epsilon</code> (optional numeric argument): numeric scalar giving the limb-darkening coefficient, default = 0.6 which is typical for photospheric lines.  The specific intensity <span>$I$</span> at any angle <span>$\theta$</span> from the specific intensity <span>$I_{\text{cen}}$</span> at the center of the disk is given by:</p><p><span>$I = I_{\text{cen}}\cdot(1 - \varepsilon\cdot(1 - \cos(\theta)))$</span></p></li></ul><p><strong>Output</strong></p><p>The 2-tuple (<code>velocity_grid</code>, <code>lsf</code>):</p><ul><li><p><code>velocity_grid</code>: vector of velocity grid with the same number of elements as <code>lsf</code> (see below)</p></li><li><p><code>lsf</code>: the convolution kernel vector for the specified rotational velocity. The number of points in <code>lsf</code> will be always be odd (the kernel is symmetric) and equal to either <code>ceil(2*v_sin_i/delta_v)</code> or <code>ceil(2*v_sin_i/delta_v) + 1</code>, whichever number is odd.  Elements of <code>lsf</code> will always be of type <code>AbstractFloat</code>.  To actually compute the broadening, the spectrum should be convolved with the rotational <code>lsf</code></p></li></ul><p><strong>Example</strong></p><p>Plot the line spread function for a star rotating at 90 km/s in velocity space every 3 km/s.  Use <a href="https://github.com/stevengj/PyPlot.jl">PyPlot.jl</a> for plotting.</p><pre><code class="language-julia">using PyPlot
plot(lsf_rotate(3, 90)...)</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/lsf_rotate.jl#L15-L67" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.mag2flux" id="AstroLib.mag2flux"><code>AstroLib.mag2flux</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">mag2flux(mag[, zero_point, ABwave=number]) -&gt; flux</code></pre><p><strong>Purpose</strong></p><p>Convert from magnitudes to flux expressed in erg/(s cm² Å).</p><p><strong>Explanation</strong></p><p>This is the reverse of <code>flux2mag</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>mag</code>: the magnitude to be converted in flux.  It can be either a scalar or an array.</p></li><li><p><code>zero_point</code>: scalar giving the zero point level of the magnitude.  If not</p></li></ul><p>supplied then defaults to 21.1 (Code et al 1976).  Ignored if the <code>ABwave</code>  keyword is supplied</p><ul><li><p><code>ABwave</code> (optional numeric keyword): wavelength, scalar or array, in</p></li></ul><p>Angstroms.  If supplied, then the input <code>mag</code> is assumed to contain Oke AB  magnitudes (Oke &amp; Gunn 1983, ApJ, 266, 713;  http://adsabs.harvard.edu/abs/1983ApJ...266..713O).</p><p><strong>Output</strong></p><p>The flux.  It is of the same type, scalar or array, as <code>mag</code>.</p><p>If the <code>ABwave</code> keyword is set, then the flux is given by the expression</p><div>\[\text{flux} = 10^{-0.4(\text{mag} +2.406 + 4\log_{10}(\text{ABwave}))}\]</div><p>Otherwise the flux is given by</p><div>\[\text{flux} =  10^{-0.4(\text{mag} + \text{zero point})}\]</div><p><strong>Example</strong></p><pre><code class="language-julia">mag2flux(8.3)
# =&gt; 1.7378008287493692e-12
mag2flux(8.3, 12)
# =&gt; 7.58577575029182e-9
mag2flux(8.3, ABwave=12)
# =&gt; 3.6244115683017193e-7</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/mag2flux.jl#L12-L61" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.mag2geo" id="AstroLib.mag2geo"><code>AstroLib.mag2geo</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">mag2geo(latitude, longitude[, year]) -&gt; geographic_latitude, geographic_longitude</code></pre><p><strong>Purpose</strong></p><p>Convert from geomagnetic to geographic coordinates.</p><p><strong>Explanation</strong></p><p>Converts from geomagnetic (latitude, longitude) to geographic (latitude, longitude).  Altitude is not involved in this function.</p><p><strong>Arguments</strong></p><ul><li><p><code>latitude</code>: geomagnetic latitude (North), in degrees.</p></li><li><p><code>longitude</code>: geomagnetic longitude (East), in degrees.</p></li><li><p><code>year</code> (optional numerical argument): the year in which to perform conversion. If omitted, defaults to current year.</p></li></ul><p>The coordinates can be passed as arrays of the same length.</p><p><strong>Output</strong></p><p>The 2-tuple of geographic (latitude, longitude) coordinates, in degrees.</p><p>If geomagnetic coordinates are given as arrays, a 2-tuple of arrays of the same length is returned.</p><p><strong>Example</strong></p><p>Find position of North Magnetic Pole in 2016</p><pre><code class="language-julia">mag2geo(90, 0, 2016)
# =&gt; (86.395,-166.29000000000002)</code></pre><p><strong>Notes</strong></p><p>This function uses list of North Magnetic Pole positions provided by World Magnetic Model (https://www.ngdc.noaa.gov/geomag/data/poles/NP.xy).</p><p><code>geo2mag</code> converts geographic coordinates to geomagnetic coordinates.</p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/mag2geo.jl#L42-L87" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.month_cnv-Tuple{Integer}" id="AstroLib.month_cnv-Tuple{Integer}"><code>AstroLib.month_cnv</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">month_cnv(number[, shor=true, up=true, low=true]) -&gt; month_name
month_cnv(name) -&gt; number</code></pre><p><strong>Purpose</strong></p><p>Convert between a month English name and  the equivalent number.</p><p><strong>Explanation</strong></p><p>For example, converts from "January" to 1  or vice-versa.</p><p><strong>Arguments</strong></p><p>The functions has two methods, one with numeric input (and three possible boolean keywords) and the other one with string input.</p><p>Numeric input arguments:</p><ul><li><p><code>number</code>: the number of the month to be converted to month name.</p></li><li><p><code>short</code> (optional boolean keyword): if true, the abbreviated (3-character) name of the month will be returned, e.g. "Apr" or "Oct".  Default is false.</p></li><li><p><code>up</code> (optional boolean keyword): if true, the name of the month will be all in upper case, e.g. "APRIL" or "OCTOBER".  Default is false.</p></li><li><p><code>low</code> (optional boolean keyword): if true, the name of the month will be all in lower case, e.g. "april" or "october".  Default is false.</p></li></ul><p>String input argument:</p><ul><li><p><code>name</code>: month name to be converted to month number.</p></li></ul><p>All mandatory arguments can be provided either as a single element or as an array.</p><p><strong>Output</strong></p><p>The month name or month number, depending on the input.  For numeric input, the format of the month name is influenced by the optional keywords.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; month_cnv.(["janua", "SEP", "aUgUsT"])
3-element Array{Int64,1}:
 1
 9
 8

julia&gt; month_cnv.([2, 12, 6], short=true, low=true)
3-element Array{String,1}:
 "feb"
 "dec"
 "jun"</code></pre></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/month_cnv.jl#L4-L59" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.moonpos-Tuple{Real}" id="AstroLib.moonpos-Tuple{Real}"><code>AstroLib.moonpos</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">moonpos(jd[, radians=true]) -&gt; ra, dec, dis, geolong, geolat</code></pre><p><strong>Purpose</strong></p><p>Compute the right ascension and declination of the Moon at specified Julian date.</p><p><strong>Arguments</strong></p><ul><li><p><code>jd</code>: the Julian ephemeris date.  It can be either a scalar or an array</p></li><li><p><code>radians</code> (optional boolean keyword): if set to <code>true</code>, then all output angular quantities are given in radians rather than degrees.  The default is <code>false</code></p></li></ul><p><strong>Output</strong></p><p>The 5-tuple <code>(ra, dec, dis, geolong, geolat)</code>:</p><ul><li><p><code>ra</code>: apparent right ascension of the Moon in degrees, referred to the true equator of the specified date(s)</p></li><li><p><code>dec</code>: the declination of the Moon in degrees</p></li><li><p><code>dis</code>: the distance between the centre of the Earth and the centre of the Moon in kilometers</p></li><li><p><code>geolong</code>: apparent longitude of the moon in degrees, referred to the ecliptic of the specified date(s)</p></li><li><p><code>geolat</code>: apparent longitude of the moon in degrees, referred to the ecliptic of the specified date(s)</p></li></ul><p>If <code>jd</code> is an array, then all output quantities are arrays of the same length as <code>jd</code>.</p><p><strong>Method</strong></p><p>Derived from the Chapront ELP2000/82 Lunar Theory (Chapront-Touze' and Chapront, 1983, 124, 50), as described by Jean Meeus in Chapter 47 of ``Astronomical Algorithms'' (Willmann-Bell, Richmond), 2nd edition, 1998.  Meeus quotes an approximate accuracy of 10" in longitude and 4" in latitude, but he does not give the time range for this accuracy.</p><p>Comparison of the IDL procedure with the example in ``Astronomical Algorithms'' reveals a very small discrepancy (~1 km) in the distance computation, but no difference in the position calculation.</p><p><strong>Example</strong></p><p>(1) Find the position of the moon on April 12, 1992</p><pre><code class="language-julia">jd = jdcnv(1992, 4, 12);
adstring(moonpos(jd)[1:2],precision=1)
# =&gt; " 08 58 45.23  +13 46 06.1"</code></pre><p>This is within 1" from the position given in the Astronomical Almanac.</p><p>(2) Plot the Earth-moon distance during 2016 with sampling of 6 hours.  Use <a href="https://github.com/stevengj/PyPlot.jl">PyPlot.jl</a> for plotting</p><pre><code class="language-julia">using PyPlot
points = DateTime(2016):Dates.Hour(6):DateTime(2017);
plot(points, moonpos(jdcnv(points))[3])</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/moonpos.jl#L129-L197" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.mphase-Tuple{Real}" id="AstroLib.mphase-Tuple{Real}"><code>AstroLib.mphase</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">mphase(jd) -&gt; k</code></pre><p><strong>Purpose</strong></p><p>Return the illuminated fraction of the Moon at given Julian date(s).</p><p><strong>Arguments</strong></p><ul><li><p><code>jd</code>: the Julian ephemeris date.  It can be either a scalar or an array.</p></li></ul><p><strong>Output</strong></p><p>The illuminated fraction <span>$k$</span> of Moon's disk, with <span>$0 \leq k \leq 1$</span>. <span>$k = 0$</span> indicates a new moon, while <span>$k = 1$</span> stands for a full moon.  If <code>jd</code> is given as an array, an array of the same number of elements as <code>jd</code> is returned.</p><p><strong>Method</strong></p><p>Algorithm from Chapter 46 of "Astronomical Algorithms" by Jean Meeus (Willmann-Bell, Richmond) 1991.  <code>sunpos</code> and <code>moonpos</code> are used to get positions of the Sun and the Moon, and the Moon distance.  The selenocentric elongation of the Earth from the Sun (phase angle) is then computed, and used to determine the illuminated fraction.</p><p><strong>Example</strong></p><p>Plot the illuminated fraction of the Moon for every day in January 2018 with a hourly sampling.  Use <a href="https://github.com/stevengj/PyPlot.jl">PyPlot.jl</a> for plotting</p><pre><code class="language-julia">using PyPlot
points = DateTime(2018,01,01):Dates.Hour(1):DateTime(2018,01,31,23,59,59);
plot(points, mphase(jdcnv(points)))</code></pre><p>Note that in this calendar month there are two full moons, this event is called <a href="https://en.wikipedia.org/wiki/Blue_moon">blue moon</a>.</p><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/mphase.jl#L15-L58" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.nutate-Tuple{Real}" id="AstroLib.nutate-Tuple{Real}"><code>AstroLib.nutate</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">nutate(jd) -&gt; long, obliq</code></pre><p><strong>Purpose</strong></p><p>Return the nutation in longitude and obliquity for a given Julian date.</p><p><strong>Arguments</strong></p><ul><li><p><code>jd</code>: Julian ephemeris date, it can be either a scalar or a vector</p></li></ul><p><strong>Output</strong></p><p>The 2-tuple <code>(long, obliq)</code>, where</p><ul><li><p><code>long</code>: the nutation in longitude</p></li><li><p><code>obl</code>: the nutation in latitude</p></li></ul><p>If <code>jd</code> is an array, <code>long</code> and <code>obl</code> are arrays of the same length.</p><p><strong>Method</strong></p><p>Uses the formula in Chapter 22 of ``Astronomical Algorithms'' by Jean Meeus (1998, 2nd ed.) which is based on the 1980 IAU Theory of Nutation and includes all terms larger than 0.0003".</p><p><strong>Example</strong></p><p>(1) Find the nutation in longitude and obliquity 1987 on Apr 10 at Oh.  This is example 22.a from Meeus</p><pre><code class="language-julia">jd = jdcnv(1987, 4, 10);
nutate(jd)
# =&gt; (-3.787931077110755,9.442520698644401)</code></pre><p>(2) Plot the daily nutation in longitude and obliquity during the 21st century. Use <a href="https://github.com/stevengj/PyPlot.jl">PyPlot.jl</a> for plotting.</p><pre><code class="language-julia">using PyPlot
years = DateTime(2000):DateTime(2100);
long, obl = nutate(jdcnv(years));
plot(years, long); plot(years, obl)</code></pre><p>You can see both the dominant large scale period of nutation, of 18.6 years, and smaller oscillations with shorter periods.</p><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/nutate.jl#L62-L115" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.ordinal-Tuple{Integer}" id="AstroLib.ordinal-Tuple{Integer}"><code>AstroLib.ordinal</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">ordinal(num) -&gt; result</code></pre><p><strong>Purpose</strong></p><p>Convert an integer to a correct English ordinal string.</p><p><strong>Explanation</strong></p><p>The first four ordinal strings are "1st", "2nd", "3rd", "4th" ....</p><p><strong>Arguments</strong></p><ul><li><p><code>num</code>: number to be made ordinal. It should be of type int.</p></li></ul><p><strong>Output</strong></p><ul><li><p><code>result</code>: ordinal string, such as '1st' '3rd '164th' '87th' etc</p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; ordinal.(1:5)
5-element Array{String,1}:
 "1st"
 "2nd"
 "3rd"
 "4th"
 "5th"</code></pre><p><strong>Notes</strong></p><p>This function does not support float arguments, unlike the IDL implementation. Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/ordinal.jl#L3-L37" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.paczynski-Tuple{Real}" id="AstroLib.paczynski-Tuple{Real}"><code>AstroLib.paczynski</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">paczynski(u) -&gt; amplification</code></pre><p><strong>Purpose</strong></p><p>Calculate gravitational microlensing amplification of a point-like source by a single point-like lens.</p><p><strong>Explanation</strong></p><p>Return the <a href="https://en.wikipedia.org/wiki/Gravitational_microlensing">gravitational microlensing</a> amplification of a point-like source by a single point-like lens, using Paczyński formula</p><div>\[A(u) = \frac{u^2 + 2}{u\sqrt{u^2 + 4}}\]</div><p>where <span>$u$</span> is the projected distance between the lens and the source in units of <a href="https://en.wikipedia.org/wiki/Einstein_radius">Einstein radii</a>.</p><p>In order to speed up calculations for extreme values of <span>$u$</span>, the following asyntotic expressions for <span>$A(u)$</span> are used:</p><div>\[A(u) =
\begin{cases}
 1/u &amp; |u| \ll 1 \\
 \text{sgn}(u) &amp; |u| \gg 1
\end{cases}\]</div><p><strong>Arguments</strong></p><ul><li><p><code>u</code>: projected distance between the lens and the source, in units of Einstein radii</p></li></ul><p>The distance can be either a scalar or an array.</p><p><strong>Output</strong></p><p>The microlensing amplification for the given distance.  If <code>u</code> is passed as an array, an array of the same length is returned.</p><p><strong>Example</strong></p><p>Calculate the microlensing amplification for <span>$u = 10^{-10}$</span>, <span>$10^{-1}$</span>, <span>$1$</span>, <span>$10$</span>, <span>$10^{10}$</span>:</p><pre><code class="language-julia">paczynski([1e-10, 1e-1, 1, 10, 1e10])
# =&gt; 5-element Array{Float64,1}:
#      1.0e10
#     10.0375
#      1.34164
#      1.00019
#      1.0</code></pre><p><strong>Notes</strong></p><p>The expression of <span>$A(u)$</span> of microlensing amplification has been given by Bohdan Paczyński in</p><ul><li><p>Paczynski, B. 1986, ApJ, 304, 1. DOI:<a href="http://dx.doi.org/10.1086/164140">10.1086/164140</a>, Bibcode:<a href="http://adsabs.harvard.edu/abs/1986ApJ...304....1P">1986ApJ...304....1P</a></p></li></ul><p>The same expression was actually found by Albert Einstein half a century earlier:</p><ul><li><p>Einstein, A. 1936, Science, 84, 506. DOI:<a href="http://dx.doi.org/10.1126/science.84.2188.506">10.1126/science.84.2188.506</a>, Bibcode:<a href="http://adsabs.harvard.edu/abs/1936Sci....84..506E">1936Sci....84..506E</a></p></li></ul></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/paczynski.jl#L22-L97" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.planck_freq-Tuple{Real,Real}" id="AstroLib.planck_freq-Tuple{Real,Real}"><code>AstroLib.planck_freq</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">planck_freq(frequency, temperature) -&gt; black_body_flux</code></pre><p><strong>Purpose</strong></p><p>Calculate the flux of a black body per unit frequency.</p><p><strong>Explanation</strong></p><p>Return the spectral radiance of a black body per unit frequency using <a href="https://en.wikipedia.org/wiki/Planck%27s_law">Planck's law</a></p><p><span>$B_\nu(\nu, T) = \frac{2h\nu ^3}{c^2} \frac{1}{e^\frac{h\nu}{k_\mathrm{B}T} - 1}$</span></p><p><strong>Arguments</strong></p><ul><li><p><code>frequency</code>: frequency at which the flux is to be calculated, in Hertz.</p></li><li><p><code>temperature</code>: the equilibrium temperature of the black body, in Kelvin.</p></li></ul><p>Both arguments can be either scalar or arrays of the same length.</p><p><strong>Output</strong></p><p>The spectral radiance of the black body, in units of W/(sr·m²·Hz).</p><p><strong>Example</strong></p><p>Plot the spectrum of a black body in <span>$[10^{12}, 10^{15.4}]$</span> Hz at <span>$8000$</span> K. Use <a href="https://github.com/stevengj/PyPlot.jl">PyPlot.jl</a> for plotting.</p><pre><code class="language-julia">using PyPlot
frequency=logspace(12, 15.4, 1000);
temperature=ones(frequency)*8000;
flux=planck_freq(frequency, temperature);
plot(frequency, flux)</code></pre><p><strong>Notes</strong></p><p><code>planck_wave</code> calculates the flux of a black body per unit wavelength.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/planck_freq.jl#L10-L51" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.planck_wave-Tuple{Real,Real}" id="AstroLib.planck_wave-Tuple{Real,Real}"><code>AstroLib.planck_wave</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">planck_wave(wavelength, temperature) -&gt; black_body_flux</code></pre><p><strong>Purpose</strong></p><p>Calculate the flux of a black body per unit wavelength.</p><p><strong>Explanation</strong></p><p>Return the spectral radiance of a black body per unit wavelength using <a href="https://en.wikipedia.org/wiki/Planck%27s_law">Planck's law</a></p><p><span>$B_\lambda(\lambda, T) =\frac{2hc^2}{\lambda^5}\frac{1}{e^{\frac{hc}{\lambda k_\mathrm{B}T}} - 1}$</span></p><p><strong>Arguments</strong></p><ul><li><p><code>wavelength</code>: wavelength at which the flux is to be calculated, in meters.</p></li><li><p><code>temperature</code>: the equilibrium temperature of the black body, in Kelvin.</p></li></ul><p>Both arguments can be either scalar or arrays of the same length.</p><p><strong>Output</strong></p><p>The spectral radiance of the black body, in units of W/(sr·m³).</p><p><strong>Example</strong></p><p>Plot the spectrum of a black body in <span>$[0, 3]$</span> µm at <span>$5000$</span> K.  Use <a href="https://github.com/stevengj/PyPlot.jl">PyPlot.jl</a> for plotting.</p><pre><code class="language-julia">using PyPlot
wavelength=linspace(0, 3e-6, 1000);
temperature=ones(wavelength)*5000;
flux=planck_wave(wavelength, temperature);
plot(wavelength, flux)</code></pre><p><strong>Notes</strong></p><p><code>planck_freq</code> calculates the flux of a black body per unit frequency.</p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/planck_wave.jl#L10-L53" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.polrec-Tuple{Real,Real}" id="AstroLib.polrec-Tuple{Real,Real}"><code>AstroLib.polrec</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">polrec(radius, angle[, degrees=true]) -&gt; x, y</code></pre><p><strong>Purpose</strong></p><p>Convert 2D polar coordinates to rectangular coordinates.</p><p><strong>Explanation</strong></p><p>This is the partial inverse function of <code>recpol</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>radius</code>: radial coordinate of the point.  It may be a scalar or an array.</p></li><li><p><code>angle</code>: the angular coordinate of the point.  It may be a scalar or an array of the same lenth as <code>radius</code>.</p></li><li><p><code>degrees</code> (optional boolean keyword): if <code>true</code>, the <code>angle</code> is assumed to be in degrees, otherwise in radians.  It defaults to <code>false</code>.</p></li></ul><p>Mandatory arguments can also be passed as the 2-tuple <code>(radius, angle)</code>, so that it is possible to execute <code>recpol(polrec(radius, angle))</code>.</p><p><strong>Output</strong></p><p>A 2-tuple <code>(x, y)</code> with the rectangular coordinate of the input.  If <code>radius</code> and <code>angle</code> are arrays, <code>x</code> and <code>y</code> are arrays of the same length as <code>radius</code> and <code>angle</code>.</p><p><strong>Example</strong></p><p>Get rectangular coordinates <span>$(x, y)$</span> of the point with polar coordinates <span>$(r, \varphi) = (1.7, 227)$</span>, with angle <span>$\varphi$</span> expressed in degrees.</p><pre><code class="language-julia">x, y = polrec(1.7, 227, degrees=true)
# =&gt; (-1.1593972121062475,-1.2433012927525897)</code></pre></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/polrec.jl#L12-L50" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.posang-Tuple{Integer,Real,Real,Real,Real}" id="AstroLib.posang-Tuple{Integer,Real,Real,Real,Real}"><code>AstroLib.posang</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">posang(units, ra1, dec1, ra2, dec2) -&gt; angular_distance</code></pre><p><strong>Purpose</strong></p><p>Compute rigorous position angle of point 2 relative to point 1.</p><p><strong>Explanation</strong></p><p>Computes the rigorous position angle of point 2 (with given right ascension and declination) using point 1 (with given right ascension and declination) as the center.</p><p><strong>Arguments</strong></p><ul><li><p><code>units</code>: integer, can be either 0, or 1, or 2.  Describes units of inputs and</p></li></ul><p>output:     * 0: everything (input right ascensions and declinations, and output       distance) is radians     * 1: right ascensions are in decimal hours, declinations in decimal degrees,       output distance in degrees     * 2: right ascensions and declinations are in degrees, output distance in       degrees</p><ul><li><p><code>ra1</code>:  right ascension or longitude of point 1</p></li><li><p><code>dec1</code>: declination or latitude of point 1</p></li><li><p><code>ra2</code>: right ascension or longitude of point 2</p></li><li><p><code>dec2</code>: declination or latitude of point 2</p></li></ul><p>Both <code>ra1</code> and <code>dec1</code>, and <code>ra2</code> and <code>dec2</code> can be given as 2-tuples <code>(ra1, dec1)</code> and <code>(ra2, dec2)</code>.</p><p><strong>Output</strong></p><p>Angle of the great circle containing <code>[ra2, dec2]</code> from the meridian containing <code>[ra1, dec1]</code>, in the sense north through east rotating about <code>[ra1, dec1]</code>. See <code>units</code> argument above for units.</p><p><strong>Method</strong></p><p>The "four-parts formula" from spherical trigonometry (p. 12 of Smart's Spherical Astronomy or p. 12 of Green' Spherical Astronomy).</p><p><strong>Example</strong></p><p>Mizar has coordinates (ra, dec) = (13h 23m 55.5s, +54° 55' 31'').  Its companion, Alcor, has coordinates (ra, dec) = (13h 25m 13.5s, +54° 59' 17''). Find the position angle of Alcor with respect to Mizar.</p><pre><code class="language-julia">posang(1, ten(13, 25, 13.5), ten(54, 59, 17), ten(13, 23, 55.5), ten(54, 55, 31))
# =&gt; -108.46011246802047</code></pre><p><strong>Notes</strong></p><ul><li><p>If <code>ra1</code>, <code>dec1</code> are scalars, and <code>ra2</code>, <code>dec2</code> are vectors, then the output</p></li></ul><p>is a vector giving the distance of each element of <code>ra2</code>, <code>dec2</code> to <code>ra1</code>,  <code>dec1</code>.  Similarly, if <code>ra1</code>,<code>de1</code> are vectors, and <code>ra2</code>,<code>dec2</code> are scalars,  then the output is a vector giving the distance of each element of <code>ra1</code>,  <code>dec1</code> to <code>ra2</code>, <code>dec2</code>.  If both <code>ra1</code>, <code>dec1</code> and <code>ra2</code>, <code>dec2</code> are vectors  then the output is a vector giving the distance of each element of <code>ra1</code>,  <code>dec1</code> to the corresponding element of <code>ra2</code>, <code>dec2</code>.</p><ul><li><p>The function <code>sphdist</code> provides an alternate method of computing a spherical</p></li></ul><p>distance.</p><ul><li><p>Note that <code>posang</code> is not commutative: the position angle between A and B is <span>$\theta$</span>, then the position angle between B and A is <span>$180 + \theta$</span>.</p></li></ul><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/posang.jl#L38-L107" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.precess-NTuple{4,Real}" id="AstroLib.precess-NTuple{4,Real}"><code>AstroLib.precess</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">precess(ra, dec, equinox1, equinox2[, FK4=true, radians=true]) -&gt; prec_ra, prec_dec</code></pre><p><strong>Purpose</strong></p><p>Precess coordinates from <code>equinox1</code> to <code>equinox2</code>.</p><p><strong>Explanation</strong></p><p>The default <code>(ra, dec)</code> system is FK5 based on epoch J2000.0 but FK4 based on B1950.0 is available via the <code>FK4</code> boolean keyword.</p><p><strong>Arguments</strong></p><ul><li><p><code>ra</code>: input right ascension, scalar or vector, in degrees, unless the <code>radians</code> keyword is set to <code>true</code></p></li><li><p><code>dec</code>: input declination, scalar or vector, in degrees, unless the <code>radians</code> keyword is set to <code>true</code></p></li><li><p><code>equinox1</code>: original equinox of coordinates, numeric scalar.</p></li><li><p><code>equinox2</code>: equinox of precessed coordinates.</p></li><li><p><code>FK4</code> (optional boolean keyword): if this keyword is set to <code>true</code>, the FK4 (B1950.0) system precession angles are used to compute the precession matrix. When it is <code>false</code>, the default, use FK5 (J2000.0) precession angles.</p></li><li><p><code>radians</code> (optional boolean keyword): if this keyword is set to <code>true</code>, then the input and output right ascension and declination vectors are in radians rather than degrees.</p></li></ul><p><strong>Output</strong></p><p>The 2-tuple <code>(ra, dec)</code> of coordinates modified by precession.</p><p><strong>Example</strong></p><p>The Pole Star has J2000.0 coordinates (2h, 31m, 46.3s, 89d 15' 50.6"); compute its coordinates at J1985.0</p><pre><code class="language-julia">ra, dec = ten(2,31,46.3)*15, ten(89,15,50.6)
# =&gt; (37.94291666666666,89.26405555555556)
adstring(precess(ra, dec, 2000, 1985), precision=1)
# =&gt; " 02 16 22.73  +89 11 47.3"</code></pre><p>Precess the B1950 coordinates of Eps Ind (RA = 21h 59m,33.053s, DEC = (-56d, 59', 33.053") to equinox B1975.</p><pre><code class="language-julia">ra, dec = ten(21, 59, 33.053)*15, ten(-56, 59, 33.053)
# =&gt; (329.88772083333333,-56.992514722222225)
adstring(precess(ra, dec, 1950, 1975, FK4=true), precision=1)
# =&gt; " 22 01 15.46  -56 52 18.7"</code></pre><p><strong>Method</strong></p><p>Algorithm from "Computational Spherical Astronomy" by Taff (1983), p. 24. (FK4). FK5 constants from "Explanatory Supplement To The Astronomical Almanac" 1992, page 104 Table 3.211.1 (https://archive.org/details/131123ExplanatorySupplementAstronomicalAlmanac).</p><p><strong>Notes</strong></p><p>Accuracy of precession decreases for declination values near 90 degrees. <code>precess</code> should not be used more than 2.5 centuries from 2000 on the FK5 system (1950.0 on the FK4 system).  If you need better accuracy, use <code>bprecess</code> or <code>jprecess</code> as needed.</p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/precess.jl#L27-L95" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.precess_xyz-NTuple{5,Real}" id="AstroLib.precess_xyz-NTuple{5,Real}"><code>AstroLib.precess_xyz</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">precess_xyz(x, y, z, equinox1, equinox2) -&gt; prec_x, prec_y, prec_z</code></pre><p><strong>Purpose</strong></p><p>Precess equatorial geocentric rectangular coordinates.</p><p><strong>Arguments</strong></p><ul><li><p><code>x</code>, <code>y</code>, <code>z</code>: scalars or vectors giving heliocentric rectangular coordinates.</p></li><li><p><code>equinox1</code>: original equinox of coordinates, numeric scalar.</p></li><li><p><code>equinox2</code>: equinox of precessed coordinates, numeric scalar.</p></li></ul><p>Input coordinates can be given also a 3-tuple <code>(x, y, z)</code>.</p><p><strong>Output</strong></p><p>The 3-tuple <code>(x, y, z)</code> of coordinates modified by precession.</p><p><strong>Example</strong></p><p>Precess 2000 equinox coordinates <code>(1, 1, 1)</code> to 2050.</p><pre><code class="language-julia">precess_xyz(1, 1, 1, 2000, 2050)
# =&gt; (0.9838854500981734,1.0110925876508692,1.0048189888146941)</code></pre><p><strong>Method</strong></p><p>The equatorial geocentric rectangular coordinates are converted to right ascension and declination, precessed in the normal way, then changed back to <code>x</code>, <code>y</code> and <code>z</code> using unit vectors.</p><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/precess_xyz.jl#L17-L54" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.premat-Tuple{Real,Real}" id="AstroLib.premat-Tuple{Real,Real}"><code>AstroLib.premat</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">premat(equinox1, equinox2[, FK4=true]) -&gt; precession_matrix</code></pre><p><strong>Purpose</strong></p><p>Return the precession matrix needed to go from <code>equinox1</code> to <code>equinox2</code>.</p><p><strong>Explanation</strong></p><p>This matrix is used by <code>precess</code> and <code>baryvel</code> to precess astronomical coordinates.</p><p><strong>Arguments</strong></p><ul><li><p><code>equinox1</code>: original equinox of coordinates, numeric scalar.</p></li><li><p><code>equinox2</code>: equinox of precessed coordinates.</p></li><li><p><code>FK4</code> (optional boolean keyword): if this keyword is set to <code>true</code>, the FK4 (B1950.0) system precession angles are used to compute the precession matrix. When it is <code>false</code>, the default, use FK5 (J2000.0) precession angles.</p></li></ul><p><strong>Output</strong></p><p>A 3×3 <code>AbstractFloat</code> matrix, used to precess equatorial rectangular coordinates.</p><p><strong>Example</strong></p><p>Return the precession matrix from 1950.0 to 1975.0 in the FK4 system</p><pre><code class="language-julia">premat(1950,1975,FK4=true)
# =&gt; 3x3 Array{Float64,2}:
#     0.999981    -0.00558775  -0.00242909
#     0.00558775   0.999984    -6.78691e-6
#     0.00242909  -6.78633e-6   0.999997</code></pre><p><strong>Method</strong></p><p>FK4 constants from "Computational Spherical Astronomy" by Taff (1983), p. 24. (FK4). FK5 constants from "Explanatory Supplement To The Astronomical Almanac" 1992, page 104 Table 3.211.1 (https://archive.org/details/131123ExplanatorySupplementAstronomicalAlmanac).</p><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/premat.jl#L32-L79" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.rad2sec-Tuple{Real}" id="AstroLib.rad2sec-Tuple{Real}"><code>AstroLib.rad2sec</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">rad2sec(rad) -&gt; seconds</code></pre><p><strong>Purpose</strong></p><p>Convert from radians to seconds.</p><p><strong>Argument</strong></p><ul><li><p><code>rad</code>: number of radians.  It can be either a scalar or a vector.</p></li></ul><p><strong>Output</strong></p><p>The number of seconds corresponding to <code>rad</code>.  If <code>rad</code> is an array, an array of the same length is returned.</p><p><strong>Example</strong></p><pre><code class="language-julia">rad2sec(1)
# =&gt; 206264.80624709636</code></pre><p><strong>Notes</strong></p><p>Use <code>sec2rad</code> to convert seconds to radians.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/rad2sec.jl#L6-L32" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.radec-Tuple{Real,Real}" id="AstroLib.radec-Tuple{Real,Real}"><code>AstroLib.radec</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">radec(ra::Real, dec::Real[, hours=true]) -&gt; ra_hours, ra_minutes, ra_seconds, dec_degrees, dec_minutes, dec_seconds</code></pre><p><strong>Purpose</strong></p><p>Convert right ascension and declination from decimal to sexagesimal units.</p><p><strong>Explanation</strong></p><p>The conversion is to sexagesimal hours for right ascension, and sexagesimal degrees for declination.</p><p><strong>Arguments</strong></p><ul><li><p><code>ra</code>: decimal right ascension, scalar or array.  It is expressed in degrees, unless the optional keyword <code>hours</code> is set to <code>true</code>.</p></li><li><p><code>dec</code>: declination in decimal degrees, scalar or array, same number of elements as <code>ra</code>.</p></li><li><p><code>hours</code> (optional boolean keyword): if <code>false</code> (the default), <code>ra</code> is assumed to be given in degrees, otherwise <code>ra</code> is assumed to be expressed in hours.</p></li></ul><p><strong>Output</strong></p><p>A 6-tuple of <code>AbstractFloat</code>:</p><pre><code class="language-none">(ra_hours, ra_minutes, ra_seconds, dec_degrees, dec_minutes, dec_seconds)</code></pre><p>If <code>ra</code> and <code>dec</code> are arrays, also each element of the output 6-tuple are arrays of the same dimension.</p><p><strong>Example</strong></p><p>Position of Sirius in the sky is (ra, dec) = (6.7525, -16.7161), with right ascension expressed in hours.  Its sexagesimal representation is given by</p><pre><code class="language-julia">radec(6.7525, -16.7161, hours=true)
# =&gt; (6.0,45.0,9.0,-16.0,42.0,57.9600000000064)</code></pre></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/radec.jl#L16-L55" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.recpol-Tuple{Real,Real}" id="AstroLib.recpol-Tuple{Real,Real}"><code>AstroLib.recpol</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">recpol(x, y[, degrees=true]) -&gt; radius, angle</code></pre><p><strong>Purpose</strong></p><p>Convert 2D rectangular coordinates to polar coordinates.</p><p><strong>Explanation</strong></p><p>This is the partial inverse function of <code>polrec</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>x</code>: the abscissa coordinate of the point.  It may be a scalar or an array.</p></li><li><p><code>y</code>: the ordinate coordinate of the point.  It may be a scalar or an array of the same lenth as <code>x</code>.</p></li><li><p><code>degrees</code> (optional boolean keyword): if <code>true</code>, the output <code>angle</code> is given</p></li></ul><p>in degrees, otherwise in radians.  It defaults to <code>false</code>.</p><p>Mandatory arguments may also be passed as the 2-tuple <code>(x, y)</code>, so that it is possible to execute <code>polrec(recpol(x, y))</code>.</p><p><strong>Output</strong></p><p>A 2-tuple <code>(radius, angle)</code> with the polar coordinates of the input.  The coordinate <code>angle</code> coordinate lies in the range <span>$[-\pi, \pi]$</span> if <code>degrees=false</code>, or <span>$[-180, 180]$</span> when <code>degrees=true</code>.</p><p>If <code>x</code> and <code>y</code> are arrays, <code>radius</code> and <code>angle</code> are arrays of the same length as <code>radius</code> and <code>angle</code>.</p><p><strong>Example</strong></p><p>Calculate polar coordinates <span>$(r, \varphi)$</span> of point with rectangular coordinates <span>$(x, y) = (2.24, -1.87)$</span>.</p><pre><code class="language-julia">r, phi = recpol(2.24, -1.87)
# =&gt; (2.9179616172938263,-0.6956158538564537)</code></pre><p>Angle <span>$\varphi$</span> is given in radians.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/recpol.jl#L12-L55" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.rhotheta-NTuple{8,Real}" id="AstroLib.rhotheta-NTuple{8,Real}"><code>AstroLib.rhotheta</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">rhotheta(period, periastron, eccentricity, semimajor_axis, inclination, omega, omega2, epoch) -&gt; rho, theta</code></pre><p><strong>Purpose</strong></p><p>Calculate the separation and position angle of a binary star.</p><p><strong>Explanation</strong></p><p>This function will return the separation <span>$\rho$</span> and position angle <span>$\theta$</span> of a visual binary star derived from its orbital elements.  The algorithms described in the following book will be used: Meeus J., 1992, Astronomische Algorithmen, Barth.  Compared to the examples given at page 400 and no discrepancy found.</p><p><strong>Arguments</strong></p><ul><li><p><code>period</code>: period [year]</p></li><li><p><code>periastro</code>: time of periastron passage [year]</p></li><li><p><code>eccentricity</code>: eccentricity of the orbit</p></li><li><p><code>semimajor_axis</code>: semi-major axis [arc second]</p></li><li><p><code>inclination</code>: inclination angle [degree]</p></li><li><p><code>omega</code>: node [degree]</p></li><li><p><code>omega2</code>: longitude of periastron [degree]</p></li><li><p><code>epoch</code>: epoch of observation [year]</p></li></ul><p>All input parameters have to be scalars.</p><p><strong>Output</strong></p><p>The 2-tuple <span>$(\rho, \theta)$</span>, where</p><ul><li><p><span>$\rho$</span> is separation [arc second], and</p></li><li><p><span>$\theta$</span> is position angle (degree).</p></li></ul><p><strong>Example</strong></p><p>Find the position of Eta Coronae Borealis at the epoch 2016</p><pre><code class="language-julia">ρ, θ = rhotheta(41.623, 1934.008, 0.2763, 0.907, 59.025, 23.717, 219.907, 2016)
# =&gt; (0.6351167848228113,214.42513388052114)</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/rhotheta.jl#L25-L72" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.sec2rad-Tuple{Real}" id="AstroLib.sec2rad-Tuple{Real}"><code>AstroLib.sec2rad</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">sec2rad(sec) -&gt; radians</code></pre><p><strong>Purpose</strong></p><p>Convert from seconds to radians.</p><p><strong>Argument</strong></p><ul><li><p><code>sec</code>: number of seconds.  It can be either a scalar or a vector.</p></li></ul><p><strong>Output</strong></p><p>The number of radians corresponding to <code>sec</code>.  If <code>sec</code> is an array, an array of the same length is returned.</p><p><strong>Example</strong></p><pre><code class="language-julia">sec2rad(3600*30)
# =&gt; 0.5235987755982988</code></pre><p><strong>Notes</strong></p><p>Use <code>rad2sec</code> to convert radians to seconds.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/sec2rad.jl#L6-L32" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.sixty-Tuple{Real}" id="AstroLib.sixty-Tuple{Real}"><code>AstroLib.sixty</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">sixty(number) -&gt; [deg, min, sec]</code></pre><p><strong>Purpose</strong></p><p>Converts a decimal number to sexagesimal.</p><p><strong>Explanation</strong></p><p>The reverse of <code>ten</code> function.</p><p><strong>Argument</strong></p><ul><li><p><code>number</code>: decimal number to be converted to sexagesimal.</p></li></ul><p><strong>Output</strong></p><p>An array of three <code>AbstractFloat</code>, that are the sexagesimal counterpart (degrees, minutes, seconds) of <code>number</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">sixty(-0.615)
# =&gt; 3-element Array{Float64,1}:
#     -0.0
#     36.0
#     54.0</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/sixty.jl#L19-L52" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.sphdist-NTuple{4,Real}" id="AstroLib.sphdist-NTuple{4,Real}"><code>AstroLib.sphdist</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">sphdist(long1, lat1, long2, lat2[, degrees=true]) -&gt; angular_distance</code></pre><p><strong>Purpose</strong></p><p>Angular distance between points on a sphere.</p><p><strong>Arguments</strong></p><ul><li><p><code>long1</code>:  longitude of point 1</p></li><li><p><code>lat1</code>: latitude of point 1</p></li><li><p><code>long2</code>: longitude of point 2</p></li><li><p><code>lat2</code>: latitude of point 2</p></li><li><p><code>degrees</code> (optional boolean keyword): if <code>true</code>, all angles, including the output distance, are assumed to be in degrees, otherwise they are all in radians.  It defaults to <code>false</code>.</p></li></ul><p><strong>Output</strong></p><p>Angular distance on a sphere between points 1 and 2, as an <code>AbstractFloat</code>.  It is expressed in radians unless <code>degrees</code> keyword is set to <code>true</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">sphdist(120, -43, 175, +22)
# =&gt; 1.5904422616007134</code></pre><p><strong>Notes</strong></p><ul><li><p><code>gcirc</code> function is similar to <code>sphdist</code>, but may be more suitable for astronomical applications.</p></li><li><p>If <code>long1</code>, <code>lat1</code> are scalars, and <code>long2</code>, <code>lat2</code> are vectors, then the</p></li></ul><p>output is a vector giving the distance of each element of <code>long2</code>, <code>lat2</code> to  <code>long1</code>, <code>lat1</code>.  Similarly, if <code>long1</code>,<code>de1</code> are vectors, and <code>long2</code>,<code>lat2</code>  are scalars, then the output is a vector giving the distance of each element of  <code>long1</code>, <code>lat1</code> to <code>long2</code>, <code>lat2</code>.  If both <code>long1</code>, <code>lat1</code> and <code>long2</code>,  <code>lat2</code> are vectors then the output is a vector giving the distance of each  element of <code>long1</code>, <code>lat1</code> to the corresponding element of <code>long2</code>, <code>lat2</code>.</p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/sphdist.jl#L23-L65" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.sunpos-Tuple{Real}" id="AstroLib.sunpos-Tuple{Real}"><code>AstroLib.sunpos</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">sunpos(jd[, radians=true]) -&gt; ra, dec, elong, obliquity</code></pre><p><strong>Purpose</strong></p><p>Compute the right ascension and declination of the Sun at a given date.</p><p><strong>Arguments</strong></p><ul><li><p><code>jd</code>: the Julian date of when you want to calculate Sun position.  It can be either a scalar or a vector.  Use <code>jdcnv</code> to get the Julian date for a given date and time.</p></li><li><p><code>radians</code> (optional boolean keyword): if set to <code>true</code>, all output quantities are given in radians.  The default is <code>false</code>, so all quantities are given in degrees.</p></li></ul><p><strong>Output</strong></p><p>The 4-tuple <code>(ra, dec, elong, obliquity)</code>:</p><ul><li><p><code>ra</code>: the right ascension of the Sun at that date</p></li><li><p><code>dec</code>: the declination of the Sun at that date</p></li><li><p><code>elong</code>: ecliptic longitude of the Sun at that date</p></li><li><p><code>obliquity</code>: the obliquity of the ecliptic</p></li></ul><p>All quantities are given in degrees, unless <code>radians</code> keyword is set to <code>true</code> (see "Arguments" section).  If <code>jd</code> is an array, arrays of the same given as <code>jd</code> are returned.</p><p><strong>Method</strong></p><p>Uses a truncated version of Newcomb's Sun.  Adapted from the IDL routine SUN_POS by CD Pike, which was adapted from a FORTRAN routine by B. Emerson (RGO).</p><p><strong>Example</strong></p><p>(1) Find the apparent right ascension and declination of the Sun on May 1, 1982</p><pre><code class="language-julia">adstring(sunpos(jdcnv(1982, 5, 1))[1:2], precision=2)
# =&gt; " 02 31 32.614  +14 54 34.92"</code></pre><p>The Astronomical Almanac gives <code>02 31 32.58 +14 54 34.9</code> so the error for this case is &lt; 0.5".</p><p>(2) Plot the apparent right ascension, in hours, and declination of the Sun, in degrees, for every day in 2016.  Use <a href="https://github.com/stevengj/PyPlot.jl">PyPlot.jl</a> for plotting.</p><pre><code class="language-julia">using PyPlot
days = DateTime(2016):DateTime(2016, 12, 31);
ra, declin = sunpos(jdcnv(days));
plot(days, ra/15); plot(days, declin)</code></pre><p><strong>Notes</strong></p><p>Patrick Wallace (Rutherford Appleton Laboratory, UK) has tested the accuracy of a C adaptation of the present algorithm and found the following results.  From 1900-2100 <code>sunpos</code> gave 7.3 arcsec maximum error, 2.6 arcsec RMS.  Over the shorter interval 1950-2050 the figures were 6.4 arcsec max, 2.2 arcsec RMS.</p><p>The returned <code>ra</code> and <code>dec</code> are in the given date's equinox.</p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/sunpos.jl#L62-L129" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.ten" id="AstroLib.ten"><code>AstroLib.ten</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ten(deg[, min, sec]) -&gt; decimal
ten("deg:min:sec") -&gt; decimal</code></pre><p><strong>Purpose</strong></p><p>Converts a sexagesimal number or string to decimal.</p><p><strong>Explanation</strong></p><p><code>ten</code> is the inverse of the <code>sixty</code> function. of <code>ten</code>.</p><p><strong>Arguments</strong></p><p><code>ten</code> takes as argument either three scalars (<code>deg</code>, <code>min</code>, <code>sec</code>) or a string. The string should have the form <code>"deg:min:sec"</code> or <code>"deg min sec"</code>.  Also any iterable like <code>(deg, min, sec)</code> or <code>[deg, min, sec]</code> is accepted as argument.</p><p>If minutes and seconds are not specified they default to zero.</p><p><strong>Output</strong></p><p>The decimal conversion of the sexagesimal numbers provided is returned.  The output has the same dimension as the input.</p><p><strong>Method</strong></p><p>The formula used for the conversion is</p><div>\[\mathrm{sign}(\mathrm{deg})·\left(|\mathrm{deg}| + \frac{\mathrm{min}}{60} + \frac{\mathrm{sec}}{3600}\right)\]</div><p><strong>Example</strong></p><pre><code class="language-julia">ten(-0.0, 19, 47)
# =&gt; -0.3297222222222222
ten("+5:14:58")
# =&gt; 5.249444444444444
ten("-10 26")
# =&gt; -10.433333333333334
ten((-10, 26))
# =&gt; -10.433333333333334</code></pre><p><strong>Notes</strong></p><p>These functions cannot deal with <code>-0</code> (negative integer zero) in numeric input. If it is important to give sense to negative zero, you can either make sure to pass a floating point negative zero <code>-0.0</code> (this is the best option), or use negative minutes and seconds, or non-integer negative degrees and minutes.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/ten.jl#L29-L80" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.tic_one" id="AstroLib.tic_one"><code>AstroLib.tic_one</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">tic_one(zmin, pixx, incr[, ra=true]) -&gt; min2, tic1</code></pre><p><strong>Purpose</strong></p><p>Determine the position of the first tic mark for astronomical images.</p><p><strong>Explanation</strong></p><p>For use in labelling images with right ascension and declination axes. This routine determines the position in pixels of the first tic.</p><p><strong>Arguments</strong></p><ul><li><p><code>zmin</code>: astronomical coordinate value at axis zero point (degrees  or hours).</p></li><li><p><code>pixx</code>: distance in pixels between tic marks (usually obtained from <a href="@ref">tics</a>).</p></li><li><p><code>incr</code> - increment in minutes for labels (usually an even number obtained  from the procedure <a href="@ref">tics</a>).</p></li><li><p><code>ra</code> (optional boolean keyword): if true, incremental value being entered  is in minutes of time, else it is assumed that value is in else it's in minutes of arc.  Default is false.</p></li></ul><p><strong>Output</strong></p><p>The 2 tuple <code>(min2, tic1)</code>:</p><ul><li><p><code>min2</code>: astronomical coordinate value at first tic mark</p></li><li><p><code>tic1</code>: position in pixels of first tic mark</p></li></ul><p><strong>Example</strong></p><p>Suppose a declination axis has a value of 30.2345 degrees at its zero point.  A tic mark is desired every 10 arc minutes, which corresponds to 12.74 pixels, with increment for labels being 10 minutes. Then</p><pre><code class="language-julia">julia&gt; tic_one(30.2345, 12.74, 10)
(30.333333333333332, 7.554820000000081)</code></pre><p>yields values of min2 ≈ 30.333 and tic1 ≈ 7.55482, i.e. the first tic mark should be labeled 30 deg 20 minutes and be placed at pixel value 7.55482.</p><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/tic_one.jl#L24-L73" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.ticpos-Tuple{Real,Real,Real}" id="AstroLib.ticpos-Tuple{Real,Real,Real}"><code>AstroLib.ticpos</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">ticpos(deglen, pixlen, ticsize) -&gt; ticsize, incr, units</code></pre><p><strong>Purpose</strong></p><p>Specify distance between tic marks for astronomical coordinate overlays.</p><p><strong>Explanation</strong></p><p>User inputs number an approximate distance between tic marks, and the axis length in degrees. <code>ticpos</code> will return a distance between tic marks such that the separation is a round multiple in arc seconds, arc minutes, or degrees.</p><p><strong>Arguments</strong></p><ul><li><p><code>deglen</code>: length of axis in degrees, positive scalar</p></li><li><p><code>pixlen</code>: length of axis in plotting units (pixels), postive scalar</p></li><li><p><code>ticsize</code>: distance between tic marks (pixels).  This value will be  adjusted by <code>ticpos</code> such that the distance corresponds to a round  multiple in the astronomical coordinate.</p></li></ul><p><strong>Output</strong></p><p>The 3-tuple <code>(ticsize, incr, units)</code>:</p><ul><li><p><code>ticsize</code>: distance between tic marks (pixels), positive scalar</p></li><li><p><code>incr</code>: incremental value for tic marks in round units given  by the <code>units</code> parameter</p></li><li><p><code>units</code>: string giving units of ticsize, either 'Arc Seconds', 'Arc Minutes', or 'Degrees'</p></li></ul><p><strong>Example</strong></p><p>Suppose a 512 x 512 image array corresponds to 0.2 x 0.2 degrees on the sky. A tic mark is desired in round angular units, approximately every 75 pixels. Then</p><pre><code class="language-julia">julia&gt; ticpos(0.2, 512, 75)
(85.33333333333333, 2, "Arc Minutes")</code></pre><p>i.e. a good tic mark spacing is every 2 arc minutes, corresponding to 85.333 pixels.</p><p><strong>Notes</strong></p><p>All the arguments taken as input are assumed to be positive in nature.</p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/ticpos.jl#L57-L108" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.tics" id="AstroLib.tics"><code>AstroLib.tics</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">tics(radec_min, radec_max, numx, ticsize[, ra=true]) -&gt; ticsize, incr</code></pre><p><strong>Purpose</strong></p><p>Compute a nice increment between tic marks for astronomical images.</p><p><strong>Explanation</strong></p><p>For use in labelling a displayed image with right ascension or declination axes.  An approximate distance between tic marks is input, and a new value is computed such that the distance between tic marks is in simple increments of the tic label values.</p><p><strong>Arguements</strong></p><ul><li><p><code>radec_min</code> : minimum axis value (degrees).</p></li><li><p><code>radec_min</code> : maximum axis value (degrees).</p></li><li><p><code>numx</code> : number of pixels in x direction.</p></li><li><p><code>ticsize</code> : distance between tic marks (pixels).</p></li><li><p><code>ra</code> (optional boolean keyword): if true, incremental value would be in minutes of time. Default is false.</p></li></ul><p><strong>Output</strong></p><p>A 2-tuple <code>(ticsize, incr)</code>:</p><ul><li><p><code>ticsize</code> : distance between tic marks (pixels).</p></li><li><p><code>incr</code> : incremental value for tic labels.  The format is dependent on the optional keyword. If true (i.e for right ascension), it's in minutes of time, else it's in minutes of arc (for declination).</p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; tics(55, 60, 100.0, 1/2)
(0.66, 2)

julia&gt; tics(30, 60, 12, 2, true)
(2.75, 30)</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/tics.jl#L68-L112" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.trueanom-Tuple{Real,Real}" id="AstroLib.trueanom-Tuple{Real,Real}"><code>AstroLib.trueanom</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">trueanom(E, e) -&gt; true anomaly</code></pre><p><strong>Purpose</strong></p><p>Calculate true anomaly for a particle in elliptic orbit with eccentric anomaly <span>$E$</span> and eccentricity <span>$e$</span>.</p><p><strong>Explanation</strong></p><p>In the two-body problem, once that the <a href="https://en.wikipedia.org/wiki/Kepler%27s_equation">Kepler's equation</a> is solved and <span>$E(t)$</span> is determined, the polar coordinates <span>$(r(t), \theta(t))$</span> of the body at time <span>$t$</span> in the elliptic orbit are given by</p><p><span>$\theta(t) = 2\arctan \left(\sqrt{\frac{1 + e}{1 - e}} \tan\frac{E(t)}{2} \right)$</span></p><p><span>$r(t) = \frac{a(1 - e^{2})}{1 + e\cos(\theta(t) - \theta_{0})}$</span></p><p>in which <span>$a$</span> is the semi-major axis of the orbit, and <span>$\theta_0$</span> the value of angular coordinate at time <span>$t = t_{0}$</span>.</p><p><strong>Arguments</strong></p><ul><li><p><code>E</code>: eccentric anomaly.  This can be either a scalar or an array</p></li><li><p><code>e</code>: eccentricity, in the elliptic motion regime (<span>$0 \leq e \leq 1$</span>)</p></li></ul><p><strong>Output</strong></p><p>The true anomaly.  If an array of eccentric anomalies is provided in input, an array of the same length as <code>E</code> is returned.</p><p><strong>Example</strong></p><p>Plot the true anomaly as a function of mean anomaly for eccentricity <span>$e = 0$</span>, <span>$0.5$</span>, <span>$0.9$</span>.  Use <a href="https://github.com/stevengj/PyPlot.jl">PyPlot.jl</a> for plotting.</p><pre><code class="language-julia">using PyPlot
M = linspace(0, 2pi, 1001)[1:end-1];
for ecc in (0, 0.5, 0.9)
    plot(M, cirrange.(trueanom.(kepler_solver.(M, ecc), ecc), 2pi))
end</code></pre><p><strong>Notes</strong></p><p>The eccentric anomaly can be calculated with <a href="ref.html#AstroLib.kepler_solver-Tuple{Real,Real}"><code>kepler_solver</code></a> function.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/trueanom.jl#L9-L58" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.vactoair-Tuple{Real}" id="AstroLib.vactoair-Tuple{Real}"><code>AstroLib.vactoair</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">vactoair(wave_vacuum) -&gt; wave_air</code></pre><p><strong>Purpose</strong></p><p>Converts vacuum wavelengths to air wavelengths.</p><p><strong>Explanation</strong></p><p>Corrects for the index of refraction of air under standard conditions. Wavelength values below <span>$2000 Å$</span> will not be altered.  Uses relation of Ciddor (1996).</p><p><strong>Arguments</strong></p><ul><li><p><code>wave_vacuum</code>: vacuum wavelength in angstroms.  Can be either a scalar or an array of numbers.  Wavelengths are corrected for the index of refraction of air under standard conditions.  Wavelength values below <span>$2000 Å$</span> will <em>not</em> be altered, take care within <span>$[1 Å, 2000 Å]$</span>.</p></li></ul><p><strong>Output</strong></p><p>Air wavelength in angstroms, same number of elements as <code>wave_vacuum</code>.</p><p><strong>Method</strong></p><p>Uses relation of Ciddor (1996), Applied Optics 35, 1566 (http://adsabs.harvard.edu/abs/1996ApOpt..35.1566C).</p><p><strong>Example</strong></p><p>If the vacuum wavelength is <code>w = 2000</code>, then <code>vactoair(w)</code> yields an air wavelength of <code>1999.353</code>.</p><p><strong>Notes</strong></p><p><code>airtovac</code> converts air wavelengths to vacuum wavelengths.</p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/vactoair.jl#L16-L55" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.xyz" id="AstroLib.xyz"><code>AstroLib.xyz</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">xyz(jd[, equinox]) -&gt; x, y, z, v_x, v_y, v_z</code></pre><p><strong>Purpose</strong></p><p>Calculate geocentric <span>$x$</span>, <span>$y$</span>, and <span>$z$</span> and velocity coordinates of the Sun.</p><p><strong>Explanation</strong></p><p>Calculates geocentric <span>$x$</span>, <span>$y$</span>, and <span>$z$</span> vectors and velocity coordinates (<span>$dx$</span>, <span>$dy$</span> and <span>$dz$</span>) of the Sun.  (The positive <span>$x$</span> axis is directed towards the equinox, the <span>$y$</span>-axis, towards the point on the equator at right ascension 6h, and the <span>$z$</span> axis toward the north pole of the equator).  Typical position accuracy is <span>$&lt;10^{-4}$</span> AU (15000 km).</p><p><strong>Arguments</strong></p><ul><li><p><code>jd</code>: number of Reduced Julian Days for the wanted date.  It can be either a scalar or a vector.</p></li><li><p><code>equinox</code> (optional numeric argument): equinox of output. Default is 1950.</p></li></ul><p>You can use <code>juldate</code> to get the number of Reduced Julian Days for the selected dates.</p><p><strong>Output</strong></p><p>The 6-tuple <span>$(x, y, z, v_x, v_y, v_z)$</span>, where</p><ul><li><p><span>$x, y, z$</span>: scalars or vectors giving heliocentric rectangular coordinates (in AU) for each date supplied.  Note that <span>$\sqrt{x^2 + y^2 + z^2}$</span> gives the Earth-Sun distance for the given date.</p></li><li><p><span>$v_x, v_y, v_z$</span>: velocity vectors corresponding to <span>$x, y$</span>, and <span>$z$</span>.</p></li></ul><p><strong>Example</strong></p><p>What were the rectangular coordinates and velocities of the Sun on 1999-01-22T00:00:00 (= JD 2451200.5) in J2000 coords?  Note: Astronomical Almanac (AA) is in TDT, so add 64 seconds to UT to convert.</p><pre><code class="language-julia">jd = juldate(DateTime(1999, 1, 22))
# =&gt; 51200.5
xyz(jd + 64./86400., 2000)
# =&gt; (0.5145687092402946,-0.7696326261820777,-0.33376880143026394,0.014947267514081075,0.008314838205475709,0.003606857607574784)</code></pre><p>Compare to Astronomical Almanac (1999 page C20)</p><pre><code class="language-none">            x  (AU)        y  (AU)     z (AU)
xyz:      0.51456871   -0.76963263  -0.33376880
AA:       0.51453130   -0.7697110   -0.3337152
abs(err): 0.00003739    0.00007839   0.00005360
abs(err)
    (km):   5609          11759         8040</code></pre><p>NOTE: Velocities in AA are for Earth/Moon barycenter       (a very minor offset) see AA 1999 page E3</p><pre><code class="language-none">           x vel (AU/day) y vel (AU/day)   z vel (AU/day)
xyz:      -0.014947268   -0.0083148382    -0.0036068576
AA:       -0.01494574    -0.00831185      -0.00360365
abs(err):  0.000001583    0.0000029886     0.0000032076
abs(err)
 (km/sec): 0.00265        0.00519          0.00557</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/xyz.jl#L119-L190" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.ydn2md-Tuple{Integer,Integer}" id="AstroLib.ydn2md-Tuple{Integer,Integer}"><code>AstroLib.ydn2md</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">ydn2md(year, day) -&gt; date</code></pre><p><strong>Purpose</strong></p><p>Convert from year and day number of year to a date.</p><p><strong>Explanation</strong></p><p>Returns the date corresponding to the <code>day</code> of <code>year</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>year</code>: the year, as a scalar integer.</p></li><li><p><code>day</code>: the day of <code>year</code>, as an integer.  It is can be either a scalar or array of integers.</p></li></ul><p><strong>Output</strong></p><p>The date, of <code>Date</code> type, of <span>$\text{day} - 1$</span> days after January 1st of <code>year</code>.</p><p><strong>Example</strong></p><p>Find the date of the 60th and 234th days of the year 2016.</p><pre><code class="language-julia">ydn2md(2016, [60, 234])
# =&gt; 2-element Array{Date,1}:
#     2016-02-29
#     2016-08-21</code></pre><p><strong>Note</strong></p><p><code>ymd2dn</code> converts from a date to day of the year.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/ydn2md.jl#L4-L40" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.ymd2dn" id="AstroLib.ymd2dn"><code>AstroLib.ymd2dn</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ymd2dn(date) -&gt; number_of_days</code></pre><p><strong>Purpose</strong></p><p>Convert from a date to day of the year.</p><p><strong>Explanation</strong></p><p>Returns the day of the year for <code>date</code> with January 1st being day 1.</p><p><strong>Arguments</strong></p><ul><li><p><code>date</code>: the date with <code>Date</code> type.  Can be a single date or an array of dates.</p></li></ul><p><strong>Output</strong></p><p>The day of the year for the given <code>date</code>.  If <code>date</code> is an array, returns an array of days.</p><p><strong>Example</strong></p><p>Find the days of the year for March 5 in the years 2015 and 2016 (this is a leap year).</p><pre><code class="language-julia">ymd2dn([Date(2015, 3, 5), Date(2016, 3, 5)])
# =&gt; 2-element Array{Int64,1}:
#     64
#     65</code></pre><p><strong>Note</strong></p><p><code>ydn2md</code> converts from year and day number of year to a date.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/ymd2dn.jl#L4-L39" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.zenpos" id="AstroLib.zenpos"><code>AstroLib.zenpos</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">zenpos(jd, latitude, longitude) -&gt; zenith_right_ascension, declination
zenpos(date, latitude, longitude, tz) -&gt; zenith_right_ascension, declination</code></pre><p><strong>Purpose</strong></p><p>Return the zenith right ascension and declination in radians for a given Julian date or a local civil time and timezone.</p><p><strong>Explanation</strong></p><p>The local sidereal time is computed with the help of <a href="@ref">ct2lst</a>, which is the right ascension of the zenith. This and the observatories latitude (corresponding to the declination) are converted to radians and returned as the zenith direction.</p><p><strong>Arguments</strong></p><p>The function can be called in two different ways. The arguments common to both methods are <code>latitude</code> and <code>longitude</code>:</p><ul><li><p><code>latitude</code> : latitude of the desired location.</p></li><li><p><code>longitude</code> : longitude of the desired location.</p></li></ul><p>The zenith direction can be computed either by providing the Julian date:</p><ul><li><p><code>jd</code> : the Julian date of the date and time for which the zenith position is desired.</p></li></ul><p>or the time zone and the date:</p><ul><li><p><code>tz</code>: the time zone (in hours) of the desired location (e.g. 4 = EDT, 5 = EST)</p></li><li><p><code>date</code>: the local civil time with type <code>DateTime</code>. It can be a scalar or an array.</p></li></ul><p><strong>Output</strong></p><p>A 2-tuple <code>(ra, dec)</code>:</p><ul><li><p><code>ra</code> : the right ascension (in radians) of the zenith.</p></li><li><p><code>dec</code> : the declination (in radians) of the zenith.</p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; zenpos(DateTime(2017, 04, 25, 18, 59), 43.16, -24.32, 4)
(0.946790432684706, 0.7532841051607526)

julia&gt; zenpos(jdcnv(2016, 05, 05, 13, 41), ten(35,0,42), ten(135,46,6))
(3.5757821152779536, 0.6110688599440813)</code></pre><p><strong>Notes</strong></p><p>Code of this function is based on IDL Astronomy User's Library.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/zenpos.jl#L3-L57" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.POLELATLONG" id="AstroLib.POLELATLONG"><code>AstroLib.POLELATLONG</code></a> — <span class="docstring-category">Constant</span>.</div><div><p>List of locations of North Magnetic Pole since 1590.</p><p>This is provided by World Magnetic Model (https://www.ngdc.noaa.gov/geomag/data/poles/NP.xy).</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/common.jl#L4-L9" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.observatories" id="AstroLib.observatories"><code>AstroLib.observatories</code></a> — <span class="docstring-category">Constant</span>.</div><div><p>List of observing sites.  The observatories have <code>Observatory</code> type.</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/common.jl#L45-L47" target="_blank">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#AstroLib.planets" id="AstroLib.planets"><code>AstroLib.planets</code></a> — <span class="docstring-category">Constant</span>.</div><div><p>List of planets of the Solar System, from Mercury to Pluto.  The elements of the list have <code>Planet</code> type.</p><p>Reference for most quantities is the Planetary Fact Sheet: http://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html</p></div><a class="source-link" href="https://github.com/JuliaAstro/AstroLib.jl/tree/0bd8f0c24a94128f32951611aa0379e3c3d5bdbc/src/common.jl#L135-L141" target="_blank">source</a><br/></section><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Introduction</span></a></footer></article></body></HTML>