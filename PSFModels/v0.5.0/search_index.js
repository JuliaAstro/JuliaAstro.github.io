var documenterSearchIndex = {"docs":
[{"location":"api/#API/Reference","page":"API/Reference","title":"API/Reference","text":"","category":"section"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"using PSFModels\nusing Plots","category":"page"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"","category":"page"},{"location":"api/#Gaussian","page":"API/Reference","title":"Gaussian","text":"","category":"section"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"gaussian\nnormal","category":"page"},{"location":"api/#PSFModels.gaussian","page":"API/Reference","title":"PSFModels.gaussian","text":"gaussian([T=Float64], point; x, y, fwhm, amp=1, theta=0)\ngaussian([T=Float64], px, py; x, y, fwhm, amp=1, theta=0)\n\nAn unnormalized bivariate Gaussian distribution. The position can be specified in (x, y) coordinates as a Tuple, AbstractVector, or as separate arguments. If theta is given, the PSF will be rotated by theta degrees counter-clockwise from the x-axis.\n\nThe fwhm can be a scalar (isotropic) or a vector/tuple (diagonal). Keep in mind that theta has no effect for isotropic distributions and is degenerate with the fwhm parameters (i.e., theta=90 is the same as reversing the fwhm tuple)\n\nFunctional form\n\nf(x | x̂, FWHM) = exp[-4ln(2) * ||x - x̂|| / FWHM^2]\n\nwhere x̂ and x are position vectors (indices) ||⋅|| represents the square-distance, and FWHM is the full width at half-maximum. If FWHM is a scalar, the Gaussian distribution will be isotropic. If FWHM is a vector or tuple, the weighting is applied along each axis (diagonal).\n\n\n\n\n\n","category":"function"},{"location":"api/#PSFModels.normal","page":"API/Reference","title":"PSFModels.normal","text":"normal\n\nAn alias for gaussian\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"gauss = gaussian(x=0, y=0, fwhm=10)\npsfplot(gauss, -50:50, -50:50; title=\"gaussian(fwhm=10)\",\n        colorbar_scale=:log10, clims=(1e-5, 1))","category":"page"},{"location":"api/#Airy-Disk","page":"API/Reference","title":"Airy Disk","text":"","category":"section"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"airydisk","category":"page"},{"location":"api/#PSFModels.airydisk","page":"API/Reference","title":"PSFModels.airydisk","text":"airydisk([T=Float64], point; x, y, fwhm, ratio=0, amp=1, theta=0)\nairydisk([T=Float64], px, py; x, y, fwhm, ratio=0, amp=1, theta=0)\n\nAn unnormalized Airy disk. The position can be specified in (x, y) coordinates as a Tuple, AbstractVector, or as separate arguments. If theta is given, the PSF will be rotated by theta degrees counter-clockwise from the x-axis.\n\nThe fwhm can be a scalar (isotropic) or a vector/tuple (diagonal). Keep in mind that theta has no effect for isotropic distributions and is degenerate with the fwhm parameters (i.e., theta=90 is the same as reversing the fwhm tuple)\n\nIf ratio is supplied, this will be the Airy pattern for a centrally-obscured aperture (e.g., a Newtonian telescope). This has a slightly expanded functional form, and in general the central Airy disk will be smaller and the first Airy ring will be brighter.\n\nFunctional form\n\nThe Airy disk is a distribution over the radius r (the square-Euclidean distance)\n\nf(x | x̂, FWHM) = [ 2J₁(q) / q ]^2\n\nwhere J₁ is the first-order Bessel function of the first kind and\n\nq ≈ π * r * D/ λ ≈ π * r / (0.973 * FWHM)\n\nIf user a non-zero central obscuration via ratio, the functional form becomes\n\nf(x | x̂, FWHM, ϵ) = [ 2J₁(q) / q - 2ϵJ₁(ϵq) / q ]^2 / (1 - ϵ^2)^2\n\nwhere ϵ is the ratio (0 ≤ ϵ < 1).\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"airy = airydisk(x=0, y=0, fwhm=10)\npsfplot(airy, -50:50, -50:50; title=\"airydisk(fwhm=10)\",\n        colorbar_scale=:log10, clims=(1e-5, 1))","category":"page"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"airy_obscured = airydisk(x=0, y=0, fwhm=10, ratio=0.3)\npsfplot(airy_obscured, -50:50, -50:50; title=\"airydisk(fwhm=10, ratio=0.3)\",\n        colorbar_scale=:log10, clims=(1e-5, 1))","category":"page"},{"location":"api/#Moffat","page":"API/Reference","title":"Moffat","text":"","category":"section"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"moffat","category":"page"},{"location":"api/#PSFModels.moffat","page":"API/Reference","title":"PSFModels.moffat","text":"moffat([T=Float64], point; x, y, fwhm, alpha=1, amp=1, theta=0)\nmoffat([T=Float64], px, py; x, y, fwhm, alpha=1, amp=1, theta=0)\n\nTwo dimensional Moffat model. The position can be specified in (x, y) coordinates as a Tuple, AbstractVector, or as separate arguments. If theta is given, the PSF will be rotated by theta degrees counter-clockwise from the x-axis.\n\nThe fwhm can be a scalar (isotropic) or a vector/tuple (diagonal). Keep in mind that theta has no effect for isotropic distributions and is degenerate with the fwhm parameters (i.e., theta=90 is the same as reversing the fwhm tuple)\n\nFunctional form\n\nf(x | x̂, FWHM, α) = A / (1 + ||x - x̂|| / (FWHM / 2)^2)^α\n\nwhere x̂ and x are position vectors (indices) ||⋅|| represents the square-distance, and FWHM is the full width at half-maximum. If FWHM is a vector or tuple, the weighting is applied along each axis.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"moff = moffat(x=0, y=0, fwhm=10)\npsfplot(moff, -50:50, -50:50; title=\"moffat(fwhm=10)\",\n        colorbar_scale=:log10, clims=(1e-5, 1))","category":"page"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"moff2 = moffat(x=0, y=0, fwhm=10, alpha=2)\npsfplot(moff2, -50:50, -50:50; title=\"moffat(fwhm=10, alpha=2)\",\n        colorbar_scale=:log10, clims=(1e-5, 1))","category":"page"},{"location":"api/#Comparison","page":"API/Reference","title":"Comparison","text":"","category":"section"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"xs = range(0, 50, length=1000)\nplot(\n    xs, [gauss.(xs, 0) airy.(xs, 0) moff.(xs, 0)], \n    label=[\"gaussian\" \"airydisk\" \"moffat\"], yscale=:log10,\n    xlabel=\"x\", ylabel=\"I\", ylims=(1e-5, 1)\n)","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Fitting-a-PSF","page":"Examples","title":"Fitting a PSF","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here is a brief example which shows how to construct a loss function for fitting a PSFModel to some data.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using PSFModels\nusing HCIDatasets: BetaPictoris\nusing Plots\nusing Statistics\n\n# convenience function for plotting\nfunction imshow(data; kwargs...)\n    xlim = extrema(axes(data, 1))\n    ylim = extrema(axes(data, 2))\n    heatmap(transpose(data); xlim=xlim, ylim=ylim, aspect_ratio=1, kwargs...)\nend\n\n# get a PSF from HCIDatasets.jl;\n# you may be prompted to download the file\npsf = transpose(BetaPictoris[:psf])\n\nimshow(psf)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# generative model\nfunction model(X::AbstractVector{T}) where T\n    x    =       X[1]   # position\n    y    =       X[2]\n    fwhm = @view X[3:4] # fwhm_x, fwhm_y\n    amp  =       X[5]   # amplitude\n    return airydisk(T; x, y, fwhm, amp)\nend\n\n# objective function\nfunction loss(X::AbstractVector{T}, target) where T\n    # cheap way to enforce positivity\n    all(>(0), X) || return T(Inf)\n    # get generative model\n    m = model(X)\n    # mean square error\n    return mean(idx -> (m(idx) - psf[idx])^2, CartesianIndices(psf))\nend\n\n# params are [x, y, fwhm_x, fwhm_y, amp]\ntest_params = eltype(psf)[20, 20, 5, 5, 1]\nloss(test_params, psf)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The objective function can then be used with an optimization library like Optim.jl to find best-fitting parameters","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Optim\n\n# Fit our data using test_params as a starting point\n# uses Nelder-Mead optimization\nres = optimize(P -> loss(P, psf), test_params)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# utilize automatic differentiation (AD) to enable\n# advanced algorithms, like LBFGS\nres_ad = optimize(P -> loss(P, psf), test_params, LBFGS(); autodiff=:forward)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"we can see which result has the better loss, and then use the generative model to create a model that we can use elsewhere","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"best_res = minimum(res) < minimum(res_ad) ? res : res_ad\nbest_fit_params = Optim.minimizer(best_res)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"synth_psf = model(best_fit_params)\n\nplot(\n    imshow(psf, title=\"Data\"),\n    psfplot(synth_psf, axes(psf); title=\"Model\"),\n    cbar=false,\n    ticks=false,\n    xlabel=\"\",\n    ylabel=\"\",\n    layout=2,\n    size=(600, 300)\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PSFModels","category":"page"},{"location":"#PSFModels.jl","page":"Home","title":"PSFModels.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: GitHub) (Image: Build Status) (Image: PkgEval) (Image: Coverage) (Image: License)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PSFModels can be added from the Julia package manager","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia>]\n\n(@v1.6) pkg> add PSFModels","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To import the library","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using PSFModels","category":"page"},{"location":"","page":"Home","title":"Home","text":"None of the models are exported to avoid namespace clashes, but it can be verbose to continuously rewrite PSFModels. You can either import names directly","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using PSFModels: gaussian\n\njulia> model = gaussian(x=0, y=0, fwhm=8)","category":"page"},{"location":"","page":"Home","title":"Home","text":"or you can create an alias for PSFModels","category":"page"},{"location":"","page":"Home","title":"Home","text":"# julia version 1.5 or below\nusing PSFModels\nconst M = PSFModels\n# julia version 1.6 or above\nimport PSFModels as M\n\nmodel = M.gaussian(x=0, y=0, fwhm=10)","category":"page"},{"location":"","page":"Home","title":"Home","text":"PSFModels","category":"page"},{"location":"#PSFModels.PSFModels","page":"Home","title":"PSFModels.PSFModels","text":"PSFModels\n\nStatistical models for constructing point-spread functions (PSFs).\n\nModels\n\nThe following models are currently implemented\n\ngaussian/normal\nairydisk\nmoffat\n\nParameters\n\nIn general, the PSFs have a position, a full-width at half-maximum (FWHM) measure, and an amplitude. The position follows a 1-based pixel coordinate system, where (1, 1) represents the center of the bottom left pixel. This matches the indexing style of Julia as well as DS9, IRAF, SourceExtractor, and WCS. The FWHM is a consistent scale parameter for the models. That means a gaussian with a FWHM of 5 will be visually similar to an airydisk with a FWHM of 5. All models support a scalar (isotropic) FWHM and a FWHM for each axis (diagonal), as well as arbitrarily rotating the PSF.\n\nUsage\n\nDirectly evaluating the functions is the most straightforward way to use this package\n\njulia> gaussian(0, 0; x=0, y=0, fwhm=3)\n1.0\n\njulia> gaussian(BigFloat, 0, 0; x=0, y=0, fwhm=3, amp=0.1)\n0.1000000000000000055511151231257827021181583404541015625\n\nWe also provide \"curried\" versions of the functions, which allow you to specify the parameters and evaluate the PSF later\n\njulia> model = gaussian(x=0, y=0, fwhm=3);\n\njulia> model(0, 0)\n1.0\n\nIf we want to collect the model into a dense matrix, simply iterate over indices\n\njulia> inds = CartesianIndices((-2:2, -2:2));\n\njulia> model.(inds) # broadcasting\n5x5 Matrix{Float64}:\n 0.0850494  0.214311  0.291632  0.214311  0.0850494\n 0.214311   0.54003   0.734867  0.54003   0.214311\n 0.291632   0.734867  1.0       0.734867  0.291632\n 0.214311   0.54003   0.734867  0.54003   0.214311\n 0.0850494  0.214311  0.291632  0.214311  0.0850494\n\nThis makes it very easy to evaluate the PSF on the same axes as an image (array)\n\njulia> img = randn(5, 5);\n\njulia> model.(CartesianIndices(img))\n5x5 Matrix{Float64}:\n 0.54003      0.214311     0.0459292    0.00531559   0.000332224\n 0.214311     0.0850494    0.018227     0.00210949   0.000131843\n 0.0459292    0.018227     0.00390625   0.000452087  2.82555e-5\n 0.00531559   0.00210949   0.000452087  5.2322e-5    3.27013e-6\n 0.000332224  0.000131843  2.82555e-5   3.27013e-6   2.04383e-7\n\nthis is trivially expanded to fit \"stamps\" in images\n\njulia> big_img = randn(1000, 1000);\n\njulia> stamp_inds = (750:830, 400:485);\n\njulia> stamp = @view big_img[stamp_inds...];\n\njulia> stamp_model = model.(CartesianIndices(stamp_inds));\n\nor we can create a loss function for fitting PSFs without allocating any memory. We are simply iterating over the image array!\n\njulia> using Statistics\n\njulia> mse = mean(I -> (big_img[I] - model(I))^2, CartesianIndices(stamp_inds));\n\nfinally, we provide plotting recipes from RecipesBase.jl, which can be seen in use in the API/Reference section.\n\nusing Plots\ndefault(colorbar_scale=:log10)\nmodel = gaussian(x=0, y=0, fwhm=(8, 10), theta=12)\npsfplot(model, (-30:30, -30:30))              # default axes\n\n\n\n\n\n","category":"module"},{"location":"#Benchmarks","page":"Home","title":"Benchmarks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The benchmarks can be found in the bench/ folder. To run them, first install the python dependencies","category":"page"},{"location":"","page":"Home","title":"Home","text":"$ cd bench\n$ poetry install\n$ poetry shell","category":"page"},{"location":"","page":"Home","title":"Home","text":"then get the Julia project set up","category":"page"},{"location":"","page":"Home","title":"Home","text":"$ PYTHON=$(which python) julia --project=@. -e 'using Pkg; Pkg.instantiate(); Pkg.build(\"PyCall\")'","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then run the benchmark","category":"page"},{"location":"","page":"Home","title":"Home","text":"$ julia --project=. bench.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"System Information","category":"page"},{"location":"","page":"Home","title":"Home","text":"Julia Version 1.6.0\nCommit f9720dc2eb* (2021-03-24 12:55 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin20.3.0)\n  CPU: Intel(R) Core(TM) i5-8259U CPU @ 2.30GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, skylake)\nEnvironment:\n  JULIA_NUM_THREADS = 1","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Evaluation-benchmark","page":"Home","title":"Evaluation benchmark","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"warning: Out of date\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"These benchmarks are out of date, but will be re-ran using the new, functional interface soon!","category":"page"},{"location":"","page":"Home","title":"Home","text":"This benchmark tests how long it takes to evaluate a single point in the PSF model. This may seem contrived, but we expect performance to scale directly from this measure: if it takes 1 microsecond to evaluate a single point, it should take ~1 second to evaluate a 1000x1000 image, with speedups potentially from multithreading or SIMD loop evaluation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CSV, DataFrames\nusing StatsPlots\nbenchdir(args...) = joinpath(\"..\", \"..\" ,\"bench\", args...);","category":"page"},{"location":"","page":"Home","title":"Home","text":"table = CSV.File(benchdir(\"results.csv\")) |> DataFrame","category":"page"},{"location":"","page":"Home","title":"Home","text":"@df table groupedbar(:name, [:psfmodels :astropy];\n    ylabel=\"time (s)\", yscale=:log10, leg=:outertopright,\n    label=[\"PSFModels.jl\" \"Astropy\"], size=(500, 300))","category":"page"},{"location":"#Contributing-and-Support","page":"Home","title":"Contributing and Support","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you would like to contribute, feel free to open a pull request. If you want to discuss something before contributing, head over to discussions and join or open a new topic. If you're having problems with something, please open an issue.","category":"page"}]
}
